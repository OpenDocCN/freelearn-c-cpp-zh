- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving Deep into the C++ Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will pay special attention to the object in the C++ language.
    But what makes the object in C++ so special that we should pay so much attention
    to it? Well, considering the fact that C++ supports the object-oriented programming
    paradigm, it is assumed that the object itself takes a central position in the
    structure of the language. You will see that there are many specifics around objects
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the fundamental aspects of objects in C++.
    We will start by examining how the C++ standard specifies the definition of an
    object. Moving on from there, we will take a closer look at the different types
    of object initializations, such as aggregate, direct, and copy initialization,
    and their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explore the concept of storage duration for objects. Additionally,
    we will take a look at the scope and lifetime of objects in C++. We will also
    see what references are and how they correlate to objects.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress further, we will learn about temporary objects and why it is
    important to handle them with care, and the concept of function objects and lambdas
    in C++. We will explore an example of how to use lambdas with a **Standard Template
    Library** (**STL**) algorithm, which will help us gain a comprehensive understanding
    of how to leverage these powerful features to create more efficient and optimized
    code.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a clear understanding of the fundamental
    concepts of objects in C++, and you will be familiar with some techniques you
    can use to create more robust and efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ object model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope, storage duration, and lifetimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors and lambdas in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright, it’s time to begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux Mint 21 Cinnamon edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 12.2 with compiler flags – `-``std=c++20`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please make sure your environment uses these versions or later. For all the
    examples you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the C++ object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ programs involve the creation, manipulation, and destruction of various
    entities known as *objects*. An object in C++ possesses several attributes such
    as *type*, *size*, *storage duration*, *lifetime*, *alignment requirements*, and
    *value*. The *name* of the object is *optional*.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of the named object is bounded by its storage duration, and if
    the object doesn’t have a name, it is considered a *temporary* object. However,
    not all entities in C++ are considered objects. For example, the reference is
    one such non-object.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s take a brief look at the terminology because it is important to
    be aware of it, as it will help us in our daily work with the C++ language.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration versus definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, the terms *declaration* and *definition* are often used to refer to
    different aspects of a variable, function, or class. Here’s what each term means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaration**: A declaration introduces a name into a program and specifies
    the type of the variable, function, or class, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, `x`, `foo`, and `Point` are all *declared* but not
    defined. The `extern` keyword in the variable declaration indicates that `x` is
    defined elsewhere in the program. In declaration, no memory is allocated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Definition**: A definition provides the actual implementation for a name
    that has been declared. It reserves memory for variables, allocates code space
    for functions, and defines the layout of classes, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, `x`, `foo`, and `Point` are all *defined*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, the *declaration* introduces a name and specifies its type, while the *definition*
    provides the actual implementation and allocates memory for the object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the terminology, let’s dive deep into the specifics
    of the objects in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Scope, storage duration, and lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each object or reference in a C++ program has a specific region in the program
    where it is visible and accessible, a specific lifetime, and a specific type of
    memory it occupies. Let’s take a closer look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C++, the scope of a variable, function, or class refers to the region of
    the program where the name of the entity is visible and can be accessed without
    qualification. The scope rules determine which identifiers are visible and accessible
    in different parts of the program. The standard defines several types of scopes
    in C++. Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global**: Variables, functions, and classes declared outside any function
    or class have global scope. They can be accessed from any part of the program,
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Function**: Variables declared inside a function have function scope. They
    can be accessed only within the function where they are declared, such as the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`{}`), have block scope. They can be accessed only within the block where they
    are declared, or in inner blocks if there are any, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are some of the scopes we use in C++. Now, let’s see what storage duration
    means in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Storage duration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C++, *storage duration* refers to the lifetime of an object, or how long
    it exists in memory. There are four types of storage duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` keyword and function parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static` keyword inside a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new` operator and destroyed with the `delete` operator. They exist on the
    heap and can be accessed by multiple parts of a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread-local**: These objects are created when a thread is created and destroyed
    when the thread terminates. They are like objects with static storage duration,
    but they are specific to a particular thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that illustrates the different types of storage duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `global_var` has static storage duration because it is a global
    variable. `automatic_var` has automatic storage duration because it is declared
    inside the `foo` function. `static_var` also has static storage duration, but
    it retains its value between calls to `foo` because of the `static` keyword. `dynamic_var`
    itself has an automatic storage duration, but the allocated memory that it points
    to has dynamic storage duration because it is allocated with the `new` operator.
    When `foo` returns, `automatic_var` is automatically destroyed, `dynamic_var`
    is destroyed with the help of the `delete` operator, while `static_var` and `global_var`
    persist throughout a program’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *lifetime* refers to the duration of the existence of an object or
    a reference within a program. Every object and reference in C++ has a specific
    lifetime. The lifetime of an object begins when memory is allocated for it, and
    it is initialized. If the object’s type has a constructor, then the lifetime begins
    when the constructor is successfully completed. The lifetime of an object ends
    either when its destructor is called or, if no destructor exists, when it is destroyed.
    Thus, an object’s lifetime is equivalent to or smaller than the duration of its
    storage. Similarly, the lifetime of a reference begins when its initialization
    is completed and ends up like a scalar object.
  prefs: []
  type: TYPE_NORMAL
- en: The object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each object is created by a definition statement that introduces, creates, and
    optionally initializes a *variable*. A variable is an *object* or a *reference*
    that is not a non-static data member, and it is introduced by a declaration (Object
    - [cppreference.com](http://cppreference.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a simple variable and create an object from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined and, at the same time, instantiated an object from an integer
    type on the stack of the `foo()` function. Each object in C++ occupies a certain
    amount of memory at a specific memory region. Being on the stack, this object
    has an automatic storage duration. In our example, it means that the object will
    be created when the function starts and will be automatically destroyed when the
    function ends. When it is instantiated, it uses some amount of memory. This amount
    is a compile-time known value, and it can be acquired with the `sizeof` operator.
    Keep in mind that the size of some types can vary depending on the underlying
    hardware where your program runs, so if you need to be sure of the size, always
    use the operator to calculate it. Such an example is the fundamental `int` type.
    The standard says that the size of the `int` type can’t be less than 16 bits.
    For Linux Mint 21 with GCC 12.2, in which the examples of this chapter are run,
    the used underlying data model is LP64\. This means that `int` is 4 bytes, and
    `long` and `pointer` are 8 bytes. In the next example, we demonstrate the size
    of the types mentioned earlier. In order to compile and run this code, you have
    to pass it in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Nothing surprising so far. `int` is 4 bytes, but the pointer, no matter which
    type it points to, is 8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define several structures and check their memory footprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined three structures – `Empty`, `Padding`, and `Virt`. The `Empty`
    structure, as the name suggests, is just an empty structure without any members
    in it. The `Padding` structure contains two members – `long` and `char`. As we
    saw from the previous example, in my testing environment, `long` is 8 bytes and
    `char` is 1 byte. Finally, the `Virt` structure has only one member of type `char`
    and one virtual method. Structure and class methods are not part of the object
    itself. They reside in the text segment rather than in the memory occupied by
    the object. Let’s execute the earlier code and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that all the objects occupy memory. Even the empty one! This is guaranteed
    by the standard because any object in the system has to have an address on which
    it resides. If it doesn’t occupy any memory, then no address can be assigned to
    it. Therefore, at least 1 byte is reserved for every object in the program.
  prefs: []
  type: TYPE_NORMAL
- en: The `Padding` structure occupies more memory than the sum of its members’ memory.
    This is because the compilers are free to place the objects on an address, which
    requires less instruction arithmetic in order to be accessed faster. Therefore,
    they add padding bytes to the size of the type if this is required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Virt` structure contains only one member, which has type `char`.
    However, the structure occupies the same amount of memory as the `Padding` structure.
    This is a result of how the mechanics of the polymorphism are implemented in C++.
    The structure contains a virtual method that notifies the compiler that this user-defined
    type will be used polymorphically. As a result, the compiler injects in every
    instantiated object from this type a pointer to a table, with the addresses of
    all the virtual methods of the class.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of all these examples, we can conclude that each object occupies
    memory once it is instantiated, and the size of the memory can vary depending
    on the underlying system and the definition of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will get familiar with references in C++ and how they differ from objects
    in the language.
  prefs: []
  type: TYPE_NORMAL
- en: The reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we found out that we can declare a variable not only
    from an object but also from a reference. But what is a *reference* in terms of
    C++? According to the standard, a reference variable is an *alias* to an already-existing
    object or function. This means that we can use aliases to work with objects without
    having a difference in the syntax, rather than working with pointers to objects
    where the syntax is quite different. Let’s have a look in the following example.
    In order to compile and run it, you need to invoke it from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we declare three variables – a character, a reference to a
    character, and a pointer to a character. An important detail when working with
    reference variables is that at the point of its declaration, we must also initialize
    it with the object it will refer to. From this moment on, every operation invoked
    on the reference variable is actually invoked on the aliased object. But what
    indeed is an alias? Does it occupy memory just like the pointer does? Well, this
    is a gray area. The standard says that the references, unlike objects, do not
    always occupy storage. However, the compiler may allocate storage if required
    to implement the intended semantics. As a result of this, you *can’t use* the
    `sizeof` operator to get the size of a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the pointer size matches the expectation rather than the size
    of the reference type, where it matches the size of the type to which it has an
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why initialization matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Initialization* is the process of setting the initial value of an object during
    its construction. In C++, there are several types of initializations depending
    mostly on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The storage duration which the object belongs to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the different types of initializations and exactly when they happen
    will certainly make you more confident in writing predictable code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few examples of various types of initializations that the C++
    language supports. This will make it clearer when initialization occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Default initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the next example, you can see a *default initialization*. In order to run
    and test this code, you have to invoke the `foo()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In marker `{1}`, we have declared a stack variable from type `long`. The type
    of initialization that will apply on an object depends mainly on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The storage duration it occupies**: This means that different initialization
    policies may apply, depending on whether the object lives on the stack, in the
    global space, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` value, how exactly we have passed that `init` value, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `long a;` variable in our example has automatic storage duration, meaning
    it lives on the function’s stack. In its declaration, we haven’t specified any
    initialization value. For such objects, we will apply *default initialization*.
    When an object is default-initialized, the C++ compiler will generate code that
    calls the default constructor of the object’s type if one exists. However, since
    `long` is a fundamental C++ type that lacks a default constructor, the C++ runtime
    *does not perform any initialization on it*, resulting in an *unpredictable value*.
    This means that the value that will be used for initialization is not specified
    and could be literally any. This is also the case with the `Point p1;` object,
    which is a user-defined type, but we did not specify a default constructor for
    it. The `Point` structure is a so-called **Plain Old Data** (**POD**) type because
    it is fully compatible with the structures from the C language. For such types,
    the compiler will generate a *trivial default constructor* for you, which effectively
    does nothing when called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the earlier example will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In my environment, the `a` and `p1` objects both have indeterministic values.
    If you run the example of your own, you will possibly get different values.
  prefs: []
  type: TYPE_NORMAL
- en: Direct initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our next example, we will learn about C++ *direct initialization*. In order
    to run and test this code, you have to invoke the `foo()` method again. Bear in
    mind that the `int c_warn{2.2};` `// {4.2}` statement from this example should
    be commented out in order to compile successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the first statement from the example, `int b(1);`, we have defined a variable
    of type `int`, and we have explicitly initialized it with a value of `1`. This
    is the *direct initialization* that we have known since the dawn of the C++ language.
    In order to invoke it, you have to specify the initialization value in parentheses,
    and that value has to match some of the conversion constructors of the object’s
    type. These conversion constructors can be compiler-generated. In our example,
    we use `int`, which is a fundamental C++ type and supports direct initialization
    with integer values. As a result, the `b` object will be initialized with a value
    of `1`, so nothing new so far.
  prefs: []
  type: TYPE_NORMAL
- en: With the next statement, we declare an `int b_trunc(1.2);` variable, but this
    time, we initialize it with a floating-point value of `1.2`. This statement works
    fine and declares a variable of type `int` and initializes it with a value of…
    `1`! Yes, according to the C++ standard, which tries to be as compatible as possible
    with the C language for features that are present in both languages, the value
    is *truncated down* to its mantissa. In some cases, it could be useful to initialize
    an integer object with a floating-point value, but in others, this could be an
    inadvertent error. In such a case, we will expect the compiler to warn us that
    we are potentially doing something wrong. Therefore, C++11 introduced the so-called
    *uniform initialization*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next statement from the example, `int c{2};`, we again declare a variable
    of type `int`, but we initialize it using curly braces rather than parentheses.
    This notifies the compiler to invoke *direct list initialization*, which is a
    kind of uniform initialization. It is a named list initialization because it can
    be used as an initialization list of values of different types to initialize complex
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason to prefer using uniform initialization wherever this is possible
    is visible in the next statement from the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we just saw, using direct initialization to initialize an object of a specific
    type with a value of a wider type leads to a silently truncated initialized value.
    In some situations, this can lead to bugs. One way to avoid this potential side
    effect is to use uniform initialization instead. In our example, we defined a
    variable of type `int` and again initialized it with a floating-point value. However,
    this time, the compiler will not silently initialize `c_warn` with a value of
    `2`, but it will generate an error similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The error is produced because we try to perform a narrowing conversion in the
    initialization of an `int` variable with a `double` value. Therefore, it is safer
    to use uniform initialization over a direct one because it protects you from narrowing
    conversions during initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Zero and aggregate initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see another initialization example. We will initialize an object that
    holds the personal data for `Person` and a few integer objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we already explained, the objects with automatic storage duration and without
    explicit initialization get random initialization values. In this example, from
    markers `{1}` to `{3}`, we have initialized the objects using *zero initialization*,
    which effectively sets their values to zero. Zero initialization happens for non-class,
    built-in types and for the members of user-defined types that have no constructors.
    Preferably use curly brace notation and uniform initialization, such as marker
    `{1}`, when you need to zero-initialize your objects, rather than copying zero
    initialization, such as markers `{2}` and `{3}`.
  prefs: []
  type: TYPE_NORMAL
- en: Statement `{4}` demonstrates another method of initialization called *aggregate
    initialization*. It allows us to initialize an aggregate object using uniform
    initialization notation. An aggregate is considered any object that is an array
    or a class type that has no user-declared or inherited constructors; all of its
    non-static members are publicly visible, and it has no virtual base classes and
    no virtual methods. Statement `{5}` performs another way of *aggregate initialization*
    but using *designators*. The designators explicitly specify the members being
    initialized, and the order of the designators in the initialization should follow
    the order of the declaration of the members in the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Copy initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Copy initialization occurs when an object of a specific type is initialized
    by another object of the same type. Let’s look at the following examples of syntax
    that triggers copy initialization. In order to run and test this code, you have
    to invoke the `foo()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Markers `{1}` and `{3}` from this example demonstrate the well-known copy initialization
    present in the language even before C++11\. An object of type `int` is initialized
    by another object of the same type. As we already saw, this kind of initialization
    doesn’t give any protection against types narrowing. This means that our `int`
    objects can be silently initialized by `double` objects, which will lead to narrowing.
    Fortunately, this is not the case with markers `{2}` and `{4}`. They use uniform
    copy initialization, which forces the compiler to verify that the initialization
    object is from the same type as the object being initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at several scenarios of copy initialization for user-defined
    types. We have defined two classes – `Person` and `Employee`. The `Person` class
    has one user-defined constructor that receives a reference to the `std::string`
    parameter, used to initialize the name of the person. The constructor is marked
    as `explicit`. This means that it will be used only as a non-converting constructor.
    The *converting constructor* is a constructor that makes an implicit conversion
    from its argument types to its class types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other class, `Employee`, has two constructors, one of which gets a reference
    to a `Person` object, while the other is a copy constructor. The copy constructor
    is also marked as `explicit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use these two classes in different initialization scenarios. In order
    to run and test this code, you have to rework and invoke the `foo()` method again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We first defined a `Person` object named `john`, and in marker `{1}`, we initialize
    an `Employee` object using `john`. This is actually valid because the `Employee`
    class has a constructor that accepts the `Person` objects. The next statement,
    marker `{2}`, which is commented out, gets as an argument an object of type `std::string`,
    but the compiler will generate an error. This is because the `Employee` class
    doesn’t have a constructor that gets a string object. It has a converting constructor
    from the `Person` object. However, the `Person` constructor is marked as `explicit`,
    and it is not allowed to be used in implicit type conversions, so the compilation
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The next statement, marker `{3}`, will compile successfully because `Employee`
    is copy-constructed and initialized by another `Employee` object without any implicit
    type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The final two statements from the example – markers `{4}` and `{5}` – are also
    commented out to avoid compilation errors. The reason for the compiler error is
    that the copy constructor of the `Employee` class is also marked as `explicit`.
    This means that copy construction and initialization using equal `"="` sign is
    not allowed for explicit copy constructors. Only direct copy initialization is
    permitted.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with what the scope, storage duration, and lifetime
    of the object are, we can have a look at some slightly different kinds of objects,
    which behave more like functions rather than objects – functors and lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Functors and lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will delve into functional objects – their definition, usefulness,
    and proper usage. We’ll begin by examining an example of a functional object used
    with an STL algorithm and discuss potential issues, such as the creation of temporary
    objects and dangling references. After that, we’ll move on to exploring lambda
    expressions – what they are, how to use them, and specific situations where they
    can be especially advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring functional objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Scope, storage duration, and lifetimes* section, we looked at various
    types of object initialization in C++, but our focus was mostly on objects that
    represent data, such as integers or coordinates. In this section, we’ll shift
    our attention to another type of object – those designed to be *callable*, such
    as a function, but with a crucial difference: they can maintain a state between
    different function calls. These objects are known as *functional objects* or *functors*.
    We’ll start by defining a functor and then use it to compute the mean value of
    a vector containing floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The functor is an object like any other. It has a type, storage duration, and
    scope. In order to define a functor, you have to either define a struct or class
    of a user-defined type, and this type must have implemented a *function* *call
    operator*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we defined `struct Mean` with two members in it, which are zero-initialized.
    The first one, `sum`, will be used to accumulate the input data that this object
    receives during the function call operator invocations, preserving it between
    different invocations. And the other member, `count`, will be used to count the
    number of invocations of the function call operator.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the function call operator gets one parameter of a `double`
    type, and then the method prints its name and adds the input value to the already
    accumulated value from the previous invocations. Finally, it increments the invocation
    counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function call operator doesn’t return any type and is not defined as a
    `const` method because it mutates the state of the `Mean` object. We also overloaded
    the stream extraction operator, which will be used to report the calculated mean
    value to the standard output. If there is no accumulated value, then `nan` (“not
    a number”) will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Please keep in mind that the operator is overloaded outside of the `Mean` structure,
    and it is declared as a *friend* method to it. This is because it needs to get
    `std::ostream` as a left-hand argument and the `Mean` parameter as the right argument,
    and therefore, it can’t be implemented as a member method. It’s defined as *friend*
    because it has to have access to the *private* members of the `Mean` structure.
  prefs: []
  type: TYPE_NORMAL
- en: In order to calculate the mean value, our algorithm iterates over all values
    in the vector using the `std::for_each` STL algorithm. `std::for_each` expects
    to receive a container on which to operate and function, which will be invoked
    with each of the elements from the container; therefore, this function must accept
    one parameter as an input argument.
  prefs: []
  type: TYPE_NORMAL
- en: In the main method, we define an object of type `Mean calc_mean;`, which will
    be used to calculate the mean value of `std::vector v1{1.0, 2.5, 4.0, 5.5};`.
    As you can see, we don’t need to explicitly specify the template argument type
    of the `std::vector` class because it is automatically deduced by the type of
    the initializer list values it is initialized with. In our case, these are `double`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that since C++17, the automatic class template argument deduction
    is already supported, based on the type of its initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect that the program will invoke the function operator of the `Mean`
    object for each element in the vector. The function operator will accumulate all
    values, and when the result is printed out, it will be `3.25`. Let’s see the output
    of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we expected, the operator function call is invoked for each of the elements
    from the vector, but surprisingly, there is no calculated mean value. In order
    to get a better understanding of what went wrong with the calculation, we need
    to see what has happened with the `calc_mean` object, which has been used by the
    `std::for_each` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of temporaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the sake of investigation, in the `Mean` structure, we need to define the
    `copy` and `move` constructors, the `move` operator, and a destructor, whose only
    goal will be to print whether they are invoked and the address of the object that
    they belong to. We also need to add markers for when the calculation starts and
    when it finishes. Let’s see the reworked example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to slightly change the `main()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we re-execute the already reworked program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we expected, the program starts with the construction of the object with
    the address `0x7ffef7956c50`, then the calculation is started, and we can see
    that a copy constructor is invoked. This is because `std::for_each`, like many
    other algorithms in the standard library, is a template method that gets its functor
    by value. Here is what the standard says about its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This means that no matter what calculation it does, all the accumulated values
    will be stored in the copied object rather than the original. Actually, the object
    created by this copy constructor is just a *temporary object*. Temporary objects
    are unnamed objects that are automatically created and destroyed by the compiler.
    They often lead to side effects that are not trivially recognizable by the developers.
    Temporary objects are most frequently created as a result of implicit conversions
    of arguments and functions’ returned values. They frequently have a limited lifetime,
    till the end of the statement they are created by, if they are not bound to some
    named reference. So, be careful with them because they can impact the performance
    of your program, but more importantly, they can lead to unexpected behavior, as
    in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding code, we can see that all the accumulations are done in
    the newly created temporary object. Once the `std::for_each` method finishes its
    execution, a move constructor of a new temporary object is invoked. This happens
    because, according to the definition of `std::for_each`, the passed-by value input
    functor is returned back as a result of the operation. So, if we need to get the
    accumulated value back to the original object, we need to assign the return value
    of `std::for_each` back to the original object – `calc_mean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the result is what we expected but at the price of creating several
    temporary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In our example, this is not a problem, but for really complex objects where
    temporary object creation involves expensive and potentially slow operations,
    such as resource acquisition, this could be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at how we can improve our example by avoiding unnecessary
    copy operations.
  prefs: []
  type: TYPE_NORMAL
- en: Passing by reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One way to improve the earlier example is to pass the functor not by value
    but by reference. This will avoid the creation of unnecessary temporary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to pass by reference the `Mean` object, you have to explicitly state
    your intention to the compiler by explicitly specifying that the `Mean` template
    parameter is a reference. Otherwise, the automatic template argument deduction
    will deduce that you are passing by value. As a result, this forces you to avoid
    using automatic class template argument deduction and makes your code harder to
    read. Fortunately, the standard provides a solution for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the factory method, `std::ref`, for the creation of the `std::reference_wrapper`
    objects. `std::reference_wrapper` is a class template that wraps a reference inside
    an assignable, copyable object. It’s commonly used to store references within
    standard containers that can’t typically hold them. The usage of `std::ref`, in
    our example, eliminates the need to explicitly specify that the functor template
    parameter of `std::for_each` is a reference type rather than a value. Here is
    the result of our refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no additional creation and destruction of temporary
    objects because the algorithm works directly with the reference of the `calc_mean`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of dangling references
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure that the references you pass across the program will refer
    to live objects until they are in use!
  prefs: []
  type: TYPE_NORMAL
- en: Functors are just one option that we can use in our example. There is also another
    approach here that can make our code even more expressive. These are lambda expressions.
    Let’s have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *lambda expression*, or just *lambda* in C++, is a concise way to define
    an *anonymous function* or *functor* inline, which can be used immediately or
    assigned to a variable for later use. It allows programmers to write small, throwaway
    functions on the fly without having to define a named function or a `functor`
    class. Lambdas are commonly used with algorithms and containers from the standard
    library, allowing for more concise and expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a simple lambda that just prints to the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Each lambda expression is an *object*, which means that it has a lifetime and
    occupies memory. Every defined lambda is a de facto functor class definition,
    and as such, it has a *unique type*. There can’t be two or more lambdas with the
    same *type* in a program. This *type* name is platform-specific, and therefore,
    if you need to assign a lambda to a variable, you have to define this variable
    with the `auto` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of a lambda consists of the `[ ]` symbol, which is followed by an
    optional capture list, an optional parameter list, an optional return type, an
    optional *mutable* specifier, and a function body. Lambdas can capture variables
    from the outer scope by value or by reference, and they can also have a return
    type deduction or an explicit return type, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the outer scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lambdas can gain access to other objects in the scope where they’re defined
    by utilizing a *capture list*. If the capture list is empty, then no objects are
    captured. Global objects are always visible in lambdas without needing to be explicitly
    captured. When defining the capture list, you can choose to capture objects by
    *value* or by *reference*, or even a mixture of both.
  prefs: []
  type: TYPE_NORMAL
- en: When capturing variables by value in a lambda expression, the variables are
    *copied* into the lambda object at the *moment of its definition*. Any modifications
    made to the original variables after the lambda is defined won’t affect the copies
    stored inside it. All captured objects are, by default, *read-only*, and to modify
    them, you must explicitly specify the lambda as *mutable*.
  prefs: []
  type: TYPE_NORMAL
- en: Another option to capture variables is by reference, which creates a reference
    to every captured object inside the lambda. This allows the lambda to communicate
    with the outer scope, but it’s crucial to ensure that the lifetime of all captured
    objects by reference exceeds the lifetime of the lambda to prevent *dangling references*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s refactor the example from the previous section to calculate the
    mean value of a vector with floating-point numbers, using a lambda instead of
    a functor. In order to run the following code, you have to invoke the `foo()`
    method from your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: One of the key advantages of lambdas compared to named functions and functors
    is that they can be inlined in the place of their invocation. In our example,
    we have defined the lambda directly inside the `std::for_each` invocation statement.
    This approach explicitly highlights that this lambda has no other reason to exist
    except to serve the preceding case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get a closer look at the lambda prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the capture list, we have captured four objects. The first one, `mean`, is
    captured by reference. Putting `&` before the variable name specifies that it
    is captured by reference. We will use `mean` to report outside of the lambda the
    calculated mean value. The next two variables in the capture list, `sum` and `count`,
    are captured by value. If `&` doesn’t precede the name of the variable, it means
    that it is captured by value. The only exception to this rule is when capturing
    the `this` pointer of a class, which will be captured by value, but the access
    to the class members will be by reference. As you can see, the captures, `sum`
    and `count`, are not defined in the outer scope; they are defined only in the
    scope of the lambda for the purpose of our example. Just like the functor example,
    they are used to store the accumulated sum and the count of the iterations. This
    is a convenient way to explicitly add state into your lambda for use in further
    calculations. Of course, you need to initialize them by passing initializers to
    the captures for two reasons – in order to allow the compiler to deduce their
    type and to get the expected result in the calculations. The implementation logic
    will update the values of `sum` and `count` during its execution, but as stated
    previously, these captures are read-only in the context of the lambda. Therefore,
    we cannot just mutate them without explicitly stating our intention during the
    lambda definition. This is done by appending the `mutable` keyword after the argument
    list and before the body of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: The last captured object is `text`. It is also captured by value, but this time,
    it is captured from the outer scope in the `foo()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the program is executed, we have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we expected, our lambda has been called four times, and the calculated mean
    value is exactly the same as the value calculated by the functor in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to capture objects in the capture list. The following list
    shows some rules that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Ways to capture objects in a capture list](img/Figure_4.1_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Ways to capture objects in a capture list
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to properly capture the outer scope, let’s get familiar
    with a lambda’s parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parameter list of a lambda is just like any other function parameter list.
    This is because the lambda’s parameter list is effectively the parameter list
    of the function call operator in a functor class. You can define your lambda to
    accept an arbitrary list of parameters, depending on the use case you have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `auto` specifier as a parameter type of one or more of the parameters
    in the lambda parameter lists makes it a *generic lambda*. A generic lambda acts
    as a template function call operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This effectively acts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With the C++20 release, if you wish you can explicitly specify the template
    parameters that your lambda can get. The preceding example could be rewritten
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Another important characteristic of lambdas is the return type. Let’s see its
    specifics.
  prefs: []
  type: TYPE_NORMAL
- en: The return type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying the return type of the lambda is *optional*. If you don’t explicitly
    specify it, the compiler will try to deduce it for you. If it doesn’t succeed,
    then a compiler error in type deduction will be generated. Then, you have to either
    change your code to allow automatic return type deduction or explicitly specify
    the return type of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a compiler error in return type deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code will not compile because the compiler will fail to automatically deduce
    the return type of the lambda. It’s implementation logic has two execution branches.
    The first one returns an `integer` literal, `0`, but the other one returns the
    result of a division, the quotient, which is a `double` number.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix this, we need to explicitly specify that the return type of
    the lambda is `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an explicitly specified return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, for the compiler, it is clear that the return result is always converted
    to `double`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various aspects of objects in C++, including storage
    duration, scope, and lifetimes. We distinguished between objects and references
    and discussed different ways of initializing objects and when these initializations
    occur. Additionally, we delved into the world of functors, gaining an understanding
    of what they are and how to use them effectively. Building on that knowledge,
    we also learned about lambda expressions and their advantages over functors. We
    covered how to properly use both lambdas and functors with STL algorithms. Armed
    with this knowledge of object specifics, we can now move on to discussing error
    handling in C++ in the next chapter.
  prefs: []
  type: TYPE_NORMAL
