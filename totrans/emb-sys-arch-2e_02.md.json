["```cpp\n$ gcc -c hello.c\n```", "```cpp\n$ gcc -o helloworld hello.o world.o\n```", "```cpp\ntarget: [prerequisites]\n recipe\n recipe\n ...\n```", "```cpp\nOBJS = hello.o world.o\n```", "```cpp\nhelloworld: $(OBJS)\n gcc -o $(@) $(^)\n```", "```cpp\nhello: world.o\n```", "```cpp\n$ arm-none-eabi-gcc -c test.c -mthumb -mcpu=cortex-m4\n```", "```cpp\nCC=arm-none-eabi-gcc\n```", "```cpp\nCFLAGS=-mthumb -mcpu=cortex-m4 -ffreestanding\n```", "```cpp\n$ ct-ng menuconfig\n```", "```cpp\n$ ct-ng build\n```", "```cpp\nvoid __attribute__(weak) my_procedure(int x) {/* do nothing */}\n```", "```cpp\nvoid my_procedure(int x) { y = x; }\n```", "```cpp\nconst uint8_t\n __attribute__((section(\".keys\")))\n private_key[KEY_SIZE] = {0};\n```", "```cpp\nconst uint8_t    __attribute__((used,section(\".keys\")))\n   private_key[KEY_SIZE] = {0};\n```", "```cpp\nMEMORY {\n  FLASH(rx) : ORIGIN = 0x00000000, LENGTH=256k\n  RAM(rwx) : ORIGIN = 0x20000000, LENGTH=64k\n}\n```", "```cpp\nSECTIONS\n{\n    /* Text section (code and read-only data) */\n    .text :\n    {\n        . = ALIGN(4);\n        _start_text = .;\n        *(.text*) /* code */\n        . = ALIGN(4);\n        _end_text = .;\n        *(.rodata*) /* read only data */\n        . = ALIGN(4);\n        _end_rodata = .;\n} > FLASH\n```", "```cpp\n_stored_data = .;\n.data: AT(__stored_data)\n{\n    . = ALIGN(4);\n    _start_data = .;\n    *(.data*)\n    . = ALIGN(4);\n    _start_data = .;\n} > RAM\n.bss (NOLOAD):\n{\n    . = ALIGN(4);\n    _start_bss = .;\n    *(.bss*)\n    . = ALIGN(4);\n    _end_bss = .;\n} > RAM\n```", "```cpp\n.keys :\n{\n    . = ALIGN(4);\n    *(.keys*) = .;\n    KEEP(*(.keys*));\n} > FLASH\n```", "```cpp\n$ arm-none-eabi-ld -o image.elf object1.o object2.o \n-T linker_script.ld -Map=map_file.map\n```", "```cpp\n$ arm-none-eabi-objcopy -I elf -O binary image.elf image.bin\n```", "```cpp\narm-none-eabi-objdump -d image.elf\n```", "```cpp\ntelnet_port 4444\ngdb_port 3333\nsource [find board/stm32f7discovery.cfg]\n```", "```cpp\n$ telnet localhost 4444\nOpen On-Chip Debugger\n>\n```", "```cpp\n> init\n> halt\n> flash probe 0\n```", "```cpp\ndevice id = 0x10016449\nflash size = 1024kbytes\nflash \"stm32f2x\" found at 0x08000000\n```", "```cpp\n> flash info 0\n```", "```cpp\n#0 : stm32f2x at 0x08000000, size 0x00100000, buswidth 0, chipwidth 0\n# 0: 0x00000000 (0x8000 32kB) not protected\n# 1: 0x00008000 (0x8000 32kB) not protected\n# 2: 0x00010000 (0x8000 32kB) not protected\n# 3: 0x00018000 (0x8000 32kB) not protected\n# 4: 0x00020000 (0x20000 128kB) not protected\n# 5: 0x00040000 (0x40000 256kB) not protected\n# 6: 0x00080000 (0x40000 256kB) not protected\n# 7: 0x000c0000 (0x40000 256kB) not protected\nSTM32F7[4|5]x - Rev: Z\n```", "```cpp\n> flash erase_sector 0 0 7\n```", "```cpp\n> flash write_image /path/to/image.bin 0x08000000\n```", "```cpp\n> target remote localhost:3333\n```", "```cpp\n> tar rem :3333\n```", "```cpp\nint serial_parser(char *buffer, uint32_t max_len)\n{\n  int pos = 0;\n  while (pos < max_len) {\n    buffer[pos] = read_from_serial();\n    if (buffer[pos] == (char)0)\n      break;\n    if (buffer[pos] == ESC) {\n       buffer[++pos] = read_from_serial();\n       if (buffer[pos] == 'c')\n         pos = pos - 1;\n         continue;\n    }\n    pos++;\n  }\n  return pos;\n}\n```", "```cpp\nSTART_TEST(test_plain) {\n  const char test0[] = \"hello world!\";\n  char buffer[40];\n  set_mock_buffer(test0);\n  fail_if(serial_parser(buffer, 40) != strlen(test0));\n  fail_if(strcmp(test0,buffer) != 0);\n}\nEND_TEST\n```", "```cpp\nSTART_TEST(test_escape) {\n  const char test0[] = \"hello world!\";\n  const char test1[] = \"hello \\033cworld!\";\n  char buffer[40];\n  set_mock_buffer(test1);\n  fail_if(serial_parser(buffer, 40) != strlen(test0));\n  fail_if(strcmp(test0,buffer) != 0);\n}\nEND_TEST\nSTART_TEST(test_other) {\n  const char test2[] = \"hello \\033dworld!\";\n  char buffer[40];\n  set_mock_buffer(test2);\n  fail_if(serial_parser(buffer, 40) != strlen(test2));\n  fail_if(strcmp(test2,buffer) != 0);\n}\nEND_TEST\n```", "```cpp\nstatic int serial_pos = 0;\nstatic char serial_buffer[40];\nchar read_from_serial(void) {\n  return serial_buffer[serial_pos++];\n}\nvoid set_mock_buffer(const char *buf)\n{\n  serial_pos = 0;\n  strncpy(serial_buffer, buf, 20);\n}\n```", "```cpp\n$ qemu-system-arm -M lm3s6965evb --kernel image.bin\n```", "```cpp\n$ qemu-system-arm -M lm3s6965evb --kernel image.bin -nographic -S -gdb tcp::3333\n```", "```cpp\n$ renode /opt/renode/scripts/single-node/stm32f4_discovery.resc\n```", "```cpp\nsysbus LoadELF $bin\n```", "```cpp\nmachine StartGdbServer 3333\n```"]