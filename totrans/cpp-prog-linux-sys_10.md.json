["```cpp\n#include <coroutine>\n...\nTask exCoroutine() {\n    co_return;\n}\nint main() { Task async_task = exCoroutine(); }\n```", "```cpp\nstruct Task {\n    struct promise_type {\n        Task get_return_object()\n            { return {}; }\n        std::suspend_never initial_suspend()\n            { return {}; }\n        std::suspend_never final_suspend() noexcept\n            { return {}; }\n        void return_void() {}\n        void unhandled_exception() {}\n    };\n};\n```", "```cpp\nusing namespace std;\nstruct Task {\n    struct promise_type {\n        using Handle = coroutine_handle<promise_type>;\n        Task get_return_object() {\n            return Task { Handle::from_promise(*this) };\n        }\n...\n```", "```cpp\n    explicit Task (promise_type::Handle crtHdnl) :\n                                 crtHandle(crtHdnl) {}\n    void resume() { crtHandle.resume(); } // {1}\nprivate:\n        promise_type::Handle crtHandle;   // {2}\n...\n    auto async_task = exCoroutine();\n    async_task.resume();  // {3}\n```", "```cpp\n...\n   suspend_always yield_value(auto value) {\n            currValue = value;\n            return {};\n        }\n...\n        uint32_t currValue;\n    };\n```", "```cpp\n    int next() {\n        crtHndl.resume();\n        return crtHndl.promise().currValue; } ...\n```", "```cpp\nGenerator exCoroutine() {\n    auto idx = 0;\n    for (;;) {\n        co_yield idx++;\n    }\n}\nint main() {\n    auto crt = exCoroutine();\n    for (auto idx = 1; (idx = crt.next()) <= 100000; )\n        cout << idx << \" \";\n    cout << endl;\n    return 0;\n}\n```", "```cpp\n1 2 3 4 ... 100000\n```", "```cpp\ntemplate<typename T> struct Generator {\n    Generator(const Generator&)              = delete;\n    Generator& operator = (const Generator&) = delete;\n    Generator(Generator&& other) noexcept :\n        c_routine(other.c_routine) {\n        other.c_routine = {};\n    }\n```", "```cpp\n    Generator& operator = (Generator&& other) noexcept {\n        if (this == &other)\n            return *this;\n        if (c_routine)\n            c_routine.destroy();\n        c_routine = other.c_routine;\n        other.c_routine = {};\n        return *this;\n    }\n    optional<T> operator()() {\n        c_routine.resume();\n        if (c_routine.done()) {\n            return nullopt;\n        }\n        return c_routine.promise().currValue;\n    }\n```", "```cpp\n        void unhandled_exception() {\n            exit(EXIT_FAILURE);\n   }\n```", "```cpp\n   auto sockfd = 0;\n    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n        const auto ecode{ make_error_code(errc{errno}) };\n        cerr << \"Error opening shm region\";\n        system_error exception{ ecode };\n        throw exception;\n    }\n    auto server = jthread([&sockfd] {\n        struct sockaddr_in servaddr = { 0 };\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = INADDR_ANY;\n        servaddr.sin_port = htons(PORT);\n        if (bind(sockfd,\n            (const struct sockaddr*)&servaddr,\n            sizeof(struct sockaddr_in)) < 0) {\n            perror(\"Bind failed\");\n            exit(EXIT_FAILURE);\n        }\n        cout << \"\\nsend_to():\\n\";\n        string_view message{ \"This is a test!\" };\n        auto sender = send_to(sockfd, message,\n           servaddr);\n                                                   // {9}\n```", "```cpp\n    for (int i = 1; i <= 10; i++) {\n            auto sentData = sender();\n            cout << i << \" Bytes sent: \"\n                 << *sentData << endl;     // {10}\n        }\n    });\n```", "```cpp\n    auto client = jthread([&sockfd] {\n        cout << \"\\nrecv_from():\\n\" << endl;\n        struct sockaddr_in clntaddr = { 0 };\n        auto receiver = recv_from(sockfd, clntaddr);\n        for (auto i = 1; i <= 10; i++) {\n            auto recvData = receiver();\n            cout << i << \" Message received: \"\n                 << *recvData << endl;   // {11}\n        }\n    });\n    server.join(); client.join();\n    close(sockfd); return 0;\n}\n```", "```cpp\nGenerator<size_t> send_to(int sockfd,\n                          string_view buffer,\n                          auto servaddr) noexcept {\n    for (;;) {\n        auto value = sendto(sockfd,\n                            buffer.data(),\n                            buffer.size(),\n                            MSG_DONTWAIT,\n                            (const struct sockaddr*)\n                                &servaddr,\n                            sizeof(servaddr));\n        co_yield value;\n    }\n}\n```", "```cpp\nGenerator<string> recv_from(int sockfd,\n                                 auto clntaddr,\n                                 size_t buf_size =\n                                       BUF_SIZE) noexcept {\n    socklen_t len = sizeof(struct sockaddr_in);\n    array<char, BUF_SIZE> tmp_buf = {};\n```", "```cpp\n    for (;;) {\n         recvfrom(sockfd,\n                  tmp_buf.data(),\n                  tmp_buf.size(),\n                  MSG_DONTWAIT,\n                  (struct sockaddr*)&clntaddr,\n                  &len);\n         co_yield tmp_buf.data();\n    }\n```", "```cpp\nsend_to():\n1 Bytes sent: 15\n...\n10 Bytes sent: 15\nrecv_from():\n1 Message received: This is a test!\n...\n10 Message received: This is a test!\n```", "```cpp\ntemplate<typename T, typename N>\nTask receiver(Event& event, int fd, N size) {\n    co_await event;\n    ftruncate(fd, size);\n```", "```cpp\n    if (const auto ptr = mmap(0, size,\n                           PROT_RW, MAP_SHARED,\n                           fd, 0); ptr != MAP_FAILED) {\n        auto* obj = static_cast<T*>(ptr);\n        auto del = mmap_deallocator<T>(size);\n        auto res =\n            unique_ptr<T, mmap_deallocator<T>>(obj, del);\n        if (res != nullptr)\n            cout << \"Receiver: \" << *res << endl;\n    }\n    else {\n        cerr << \"Error mapping shm region\";\n    } }\n```", "```cpp\ntemplate<typename T, typename N>\nvoid Event::notify(T buffer, int fd, N size) noexcept {\n    notified = false;\n    auto* waiter =\n        static_cast<Awaiter*>(suspended.load());\n    if (waiter != nullptr) {\n        ftruncate(fd, size);\n```", "```cpp\n        if (const auto ptr = mmap(0, size,\n                                  PROT_RW, MAP_SHARED,\n                                  fd, 0);\n                              ptr != MAP_FAILED) {\n            auto* obj = new (ptr) T(buffer);\n            auto del = mmap_deallocator<T>(size);\n            auto res =\n                unique_ptr<T, mmap_deallocator<T>>\n                                                (obj, del);\n        }\n        else {\n            cerr << \"Error mapping shm region\";\n        }\n        waiter->coroutineHandle.resume();\n    }\n}\n```", "```cpp\nbool\nEvent::Awaiter::await_suspend(coroutine_handle<> handle)\n  noexcept {\n    coroutineHandle = handle;\n    if (event.notified) return false;\n    event.suspended.store(this);\n    return true;\n}\n```", "```cpp\n    Event event{};\n    int fd = shm_open(SHM_ID, O_CREAT | O_RDWR, 0644);\n    auto senderT = jthread([&event, &fd]{\n         event.notify<const char*, size_t>(message.data(),\n                                           fd,\n                                           message.size());\n    });\n```", "```cpp\n    auto receiverT = jthread([&event, &fd]{\n         receiver<char*, size_t>(ref(event),\n                                 fd, (message.size())); });\n```", "```cpp\nThis is a testing message!\n```"]