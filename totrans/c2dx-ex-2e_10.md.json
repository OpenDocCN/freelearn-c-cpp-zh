["```cpp\n-- a comment\n--[[ \na \nmultiline \ncomment \n]]\n-- a table declared as a local variable\nlocal myTable = {}\n-- the length of a table\nlocal len = #myTable\n-- looping the table (starting with index 1!)\nfor i = 1, #myTable do\n   local element = myTable[i]\n   -- an if elseif else statement\n   if (element ~= true ) then\n      -- do something\n   elseif (element == true) then\n      -- do something else\n   else\n      -- we'll never get here!   \n   end\nend\n```", "```cpp\nmyTableClassObject:myMethod()\n```", "```cpp\nself.myProperty = 1\nself:myOtherMethod()\n```", "```cpp\nmyTableClassObject.myMethod(myTableClassObject)\n```", "```cpp\ncc.AsyncTaskPool = {}\n```", "```cpp\n    cc.Director:getInstance():getOpenGLView(): setDesignResolutionSize(640, 960,  cc.ResolutionPolicy.SHOW_ALL)\n       local screenSize =  cc.Director:getInstance():getVisibleSize()\n       local designSize = cc.size(640, 960)\n       if (screenSize.width > 320) then\n         cc.Director:getInstance():setContentScaleFactor(640/   designSize.width)       \n         cc.FileUtils:getInstance():addSearchPath(\"res/hd/\") \n       else\n         cc.Director:getInstance():setContentScaleFactor(320/designSize.width)\n         cc.FileUtils:getInstance():addSearchPath(\"res/sd/\")         \n       end\n    ```", "```cpp\n           local bgMusicPath =  cc.FileUtils:getInstance():fullPathForFilename(\"background.mp3\") \n           cc.SimpleAudioEngine:getInstance():preloadMusic(bgMusicPath)    \n           local effectPath =  cc.FileUtils:getInstance():fullPathForFilename(\"match.wav\")\n           cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)\n       effectPath =  cc.FileUtils:getInstance():fullPathForFilename(\"diamond.wav\")\n           cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)\n           effectPath =  cc.FileUtils:getInstance():fullPathForFilename(\"diamond2.wav\")\n           cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)\n           effectPath =  cc.FileUtils:getInstance():fullPathForFilename(\"wrong.wav\")\n       cc.SimpleAudioEngine:getInstance():preloadEffect(effectPath)\n    ```", "```cpp\n    --create scene \n    local scene = require(\"MenuScene\")\n    local menuScene = scene.create()\n    if cc.Director:getInstance():getRunningScene() then\n            cc.Director:getInstance():replaceScene(menuScene)\n        else\n            cc.Director:getInstance():runWithScene(menuScene)\n        end\n    ```", "```cpp\n    local constants = require (\"constants\")\n    ```", "```cpp\n    local MenuScene = class(\"MenuScene\", function()\n        return cc.Scene:create()\n    end)\n\n    function MenuScene.create()\n        local scene = MenuScene.new()\n        return scene\n    end\n\n    function MenuScene:ctor()\n        self.visibleSize =  cc.Director:getInstance():getVisibleSize()\n        self.middle = {x = self.visibleSize.width * 0.5,  y = self.visibleSize.height * 0.5}\n        self.origin = cc.Director:getInstance():getVisibleOrigin()\n        self:init()\n    end\n    return MenuScene\n    ```", "```cpp\n    function MenuScene:init ()\n        local bg = cc.Sprite:create(\"introbg.jpg\")\n        bg:setPosition(self.middle.x, self.middle.y)\n        self:addChild(bg)\n        --create pterodactyl animation\n       local pterodactyl = cc.Sprite:create(\"ptero_frame1.png\")\n       pterodactyl:setPosition(cc.p(self.visibleSize.width + 100,  self.visibleSize.height * 0.8))\n       self:addChild(pterodactyl)\n       local animation = cc.Animation:create()\n       local number, name\n       for i = 1, 3 do\n         number = i\n         name = \"ptero_frame\"..number..\".png\"\n         animation:addSpriteFrameWithFile(name)\n       end\n       animation:setDelayPerUnit(0.5 / 3.0)\n       animation:setRestoreOriginalFrame(true)\n       animation:setLoops(-1)\n       local animate = cc.Animate:create(animation)\n       pterodactyl:runAction( animate )\n       local moveOut = cc.MoveTo:create(0, cc.p(self.visibleSize.width + 100, self.visibleSize.height *  0.8))\n       local moveIn = cc.MoveTo:create(4.0, cc.p(-100,  self.visibleSize.height * 0.8))\n       local delay = cc.DelayTime:create(2.5)\n    pterodactyl:runAction(cc.RepeatForever:create (cc.Sequence:create(moveOut, moveIn, delay) ) )\n        local character = cc.Sprite:create(\"introCharacter.png\")\n        character:setPosition(self.middle.x, self.middle.y + 110)\n        self:addChild(character)\n        local frame = cc.Sprite:create(\"frame.png\")\n        frame:setPosition(self.middle.x, self.middle.y)\n        self:addChild(frame)    \n    end\n    ```", "```cpp\n    --create play button\n    local function playGame()\n       local bgMusicPath =    cc.FileUtils:getInstance():fullPathForFilename(\"background.mp3\") \n       cc.SimpleAudioEngine:getInstance():playMusic(bgMusicPath, true)\n       local scene = require(\"GameScene\")\n       local gameScene = scene.create()\n       cc.Director:getInstance():replaceScene(gameScene)\n    end\n\n    local btnPlay = cc.MenuItemImage:create(\"playBtn.png\",  \"playBtnOver.png\")\n    btnPlay:setPosition(0,0)\n    btnPlay:registerScriptTapHandler(playGame)\n    local menu  = cc.Menu:create(btnPlay)\n    menu:setPosition(self.middle.x, 80)\n    self:addChild(menu)\n    ```", "```cpp\n    function GameScene:addTouchEvents()\n        local bg = cc.Sprite:create(\"background.jpg\")\n        bg:setPosition(self.middle.x, self.middle.y)\n        self:addChild(bg)\n\n        local function onTouchBegan(touch, event)\n            self.gridController:onTouchDown(touch:getLocation())\n            return true\n        end\n\n        local function onTouchMoved(touch, event)\n            self.gridController:onTouchMove(touch:getLocation())\n        end\n\n        local function onTouchEnded(touch, event)\n            self.gridController:onTouchUp(touch:getLocation())\n        end\n\n        local listener = cc.EventListenerTouchOneByOne:create()\n           listener:registerScriptHandler (onTouchBegan,cc.Handler.EVENT_TOUCH_BEGAN )\n       listener:registerScriptHandler (onTouchMoved,cc.Handler.EVENT_TOUCH_MOVED )\n        listener:registerScriptHandler (onTouchEnded,cc.Handler.EVENT_TOUCH_ENDED )\n        local eventDispatcher = bg:getEventDispatcher()\n           eventDispatcher:addEventListenerWithSceneGraphPriority (listener, bg)\n    end\n    ```", "```cpp\n    function GameScene:init ()\n        self.gridController = GridController:create()\n        self.gridAnimations = GridAnimations:create()\n        self.objectPools = ObjectPools.create()\n\n        self.gridAnimations:setGameLayer(self)\n        self.gridController:setGameLayer(self)\n        self.objectPools:createPools(self)\n    ```", "```cpp\n    self:addChild( self.gemsContainer )\n    self.gemsContainer:setPosition( 25, 80)\n    --build interface\n    local frame = cc.Sprite:create(\"frame.png\")\n    frame:setPosition(self.middle.x, self.middle.y)\n    self:addChild(frame)\n    local diamondScoreBg = cc.Sprite:create(\"diamondScore.png\")\n    diamondScoreBg:setPosition(100, constants.SCREEN_HEIGHT - 30)\n    self:addChild(diamondScoreBg)\n    local scoreBg = cc.Sprite:create(\"gemsScore.png\")\n    scoreBg:setPosition(280, constants.SCREEN_HEIGHT - 30)\n    self:addChild(scoreBg)\n    local ttfConfig = {}\n    ttfConfig.fontFilePath=\"fonts/myriad-pro.ttf\"\n    ttfConfig.fontSize=20\n    self.diamondScoreLabel = cc.Label:createWithTTF(ttfConfig,  \"0\", cc.TEXT_ALIGNMENT_RIGHT , 150)    \n    self.diamondScoreLabel:setPosition  (140, constants.SCREEN_HEIGHT - 30)\n    self:addChild(self.diamondScoreLabel)\n    self.scoreLabel = cc.Label:createWithTTF(ttfConfig,  \"0\", cc.TEXT_ALIGNMENT_RIGHT , 150)    \n    self.scoreLabel:setPosition (330, constants.SCREEN_HEIGHT - 30)\n    self:addChild(self.scoreLabel) \n    end\n    ```", "```cpp\n    function GameScene:buildGrid ()\n       math.randomseed(os.clock())\n       self.enabled = false\n        local g\n        for c = 1, constants.GRID_SIZE_X do\n            self.grid[c] = {}\n            self.gridGemsColumnMap[c] = {}\n            for r = 1, constants.GRID_SIZE_Y do\n                if (c < 3) then\n                    self.grid[c][r] =  constants.TYPES[ self:getVerticalUnique(c,r) ]\n                else\n                    self.grid[c][r] =  constants.TYPES[ self:getVerticalHorizontalUnique(c,r) ]\n                end\n               g = Gem:create()\n                g:setType(  self.grid[c][r] )\n               g:setPosition ( c * (constants.TILE_SIZE +  constants.GRID_SPACE), \n                    r * (constants.TILE_SIZE +  constants.GRID_SPACE))\n               self.gemsContainer:addChild(g)           \n                self.gridGemsColumnMap[c][r] = g\n                table.insert(self.allGems, g)\n           end\n        end\n        self.gridAnimations:animateIntro()    \n    end\n    ```", "```cpp\n    function GameScene:getVerticalUnique (col, row)\n       local type = math.floor (math.random () *  #constants.TYPES + 1 )\n       if (self.grid[col][row-1] == constants.TYPES[type] and  self.grid[col][row-2] ~= nil and self.grid[col][row-2] ==  constants.TYPES[type]) then\n            type = type + 1; \n            if (type == #constants.TYPES + 1) then type = 1 end\n        end\n        return type\n    end\n    ```", "```cpp\n    function GameScene:getVerticalHorizontalUnique (col, row)\n       local type = self:getVerticalUnique (col, row)\n       if (self.grid[col - 1][row] == constants.TYPES[type] and  self.grid[col - 2][row] ~= nil and self.grid[col - 2][row] ==  constants.TYPES[type]) then\n            local unique = false\n            while unique == false do\n              type = self:getVerticalUnique (col, row)\n              if (self.grid[col-1][row] == constants.TYPES[type] and\n              self.grid[col - 2 ][row] ~= nil and  self.grid[col -  2 ][row] == constants.TYPES[type]) then\n                --do nothing\n              else\n                 unique = true\n              end           \n            end\n        end\n        return type\n    end\n    ```", "```cpp\n    function GridController:onTouchDown (touch)\n        if (self.gameLayer.running == false) then\n            local scene = require(\"GameScene\")\n            local gameScene = scene.create()\n            cc.Director:getInstance():replaceScene(gameScene)\n            local bgMusicPath =  cc.FileUtils:getInstance():fullPathForFilename(\"background.mp3\") \n            cc.SimpleAudioEngine:getInstance():playMusic(bgMusicPath, true)\n            return \n        end\n    ```", "```cpp\n      self.touchDown = true\n        if (self.enabled == false) then return end\n        local touchedGem = self:findGemAtPosition (touch)\n        if (touchedGem.gem ~= nil ) then \n            if (self.gameLayer.selectedGem == nil) then\n                self:selectStartGem(touchedGem)\n            else\n                if (self:isValidTarget(touchedGem.x,  touchedGem.y, touch) == true) then \n                    self:selectTargetGem(touchedGem)\n                else\n                    if (self.gameLayer.selectedGem ~= nil)  then self.gameLayer.selectedGem:deselect() end\n                    self.gameLayer.selectedGem = nil\n                    self:selectStartGem (touchedGem)\n                end\n            end\n        end\n    end\n    ```", "```cpp\n    function GridController:findGemAtPosition (position)\n        local mx = position.x\n        local my = position.y\n        local gridWidth = constants.GRID_SIZE_X *  (constants.TILE_SIZE + constants.GRID_SPACE)\n        local gridHeight = constants.GRID_SIZE_Y *  (constants.TILE_SIZE + constants.GRID_SPACE)\n        mx = mx - self.gameLayer.gemsContainer:getPositionX()\n        my = my - self.gameLayer.gemsContainer:getPositionY()\n        if (mx < 0) then mx = 0 end\n        if (my < 0) then my = 0 end\n        if (mx > gridWidth) then mx = gridWidth end\n        if (my > gridHeight) then my = gridHeight end\n    ```", "```cpp\n    local x = math.ceil ((mx - constants.TILE_SIZE * 0.5) /  (constants.TILE_SIZE + constants.GRID_SPACE))\n        local y = math.ceil ((my - constants.TILE_SIZE * 0.5) /  (constants.TILE_SIZE + constants.GRID_SPACE))\n        if (x < 1) then x = 1 end\n        if (y < 1) then y = 1 end\n        if (x > constants.GRID_SIZE_X) then x =  constants.GRID_SIZE_X end\n        if (y > constants.GRID_SIZE_Y) then y =  constants.GRID_SIZE_Y end\n        return {x = x, y = y, gem =  self.gameLayer.gridGemsColumnMap[x][y]}\n    end\n    ```", "```cpp\n    function GridController:isValidTarget (px, py, touch)\n        local offbounds = false\n        if (px > self.gameLayer.selectedIndex.x + 1) then \n    offbounds = true end\n        if (px < self.gameLayer.selectedIndex.x - 1) then \n    offbounds = true end\n        if (py > self.gameLayer.selectedIndex.y + 1) then \n    offbounds = true end\n        if (py < self.gameLayer.selectedIndex.y - 1) then \n    offbounds = true end\n    ```", "```cpp\n    local cell = math.sin (math.atan2  (math.pow( self.gameLayer.selectedIndex.x - px, 2),  math.pow( self.gameLayer.selectedIndex.y- py, 2) ) )\n        if (cell ~= 0 and cell ~= 1) then\n            offbounds = true\n        end\n        if (offbounds == true) then\n            return false\n        end\n    ```", "```cpp\n       local touchedGem = self.gameLayer.gridGemsColumnMap[px][py]\n        if (touchedGem.gem == self.gameLayer.selectedGem or  (px == self.gameLayer.selectedIndex.x and  py == self.gameLayer.selectedIndex.y)) then\n            self.gameLayer.targetGem = nil\n            return false\n        end\n        return true\n    end\n    ```", "```cpp\n    function GridController:onTouchUp (touch)\n        if (self.gameLayer.running == false) then return end\n        self.touchDown = false\n        if (self.enabled == false) then return end\n        if (self.gameLayer.selectedGem ~= nil) then  self.gameLayer:dropSelectedGem() end\n    end\n    ```", "```cpp\n    function GridController:onTouchMove (touch)\n        if (self.gameLayer.running == false) then return end\n        if (self.enabled == false) then return end\n        --track to see if we have a valid target\n        if (self.gameLayer.selectedGem ~= nil and  self.touchDown == true) then\n            self.gameLayer.selectedGem:setPosition(\n            touch.x - self.gameLayer.gemsContainer:getPositionX(), \n            touch.y - self.gameLayer.gemsContainer:getPositionY())\n            local touchedGem = self:findGemAtPosition (touch)\n            if (touchedGem.gem ~= nil and self:isValidTarget(touchedGem.x, touchedGem.y, touch) == true ) then\n                self:selectTargetGem(touchedGem)\n            end\n        end\n    end\n    ```", "```cpp\n    function GridController:selectStartGem (touchedGem)\n           if (self.gameLayer.selectedGem == nil) then\n            self.gameLayer.selectedGem = touchedGem.gem\n            self.gameLayer.targetGem = nil\n            self.gameLayer.targetIndex = nil\n            touchedGem.gem:setLocalZOrder(constants.Z_SWAP_2)\n            self.gameLayer.selectedIndex = {x = touchedGem.x,  y = touchedGem.y}\n            self.gameLayer.selectedGemPosition =  {x = touchedGem.gem:getPositionX(),\n                                                  y =  touchedGem.gem:getPositionY()}\n            self.gameLayer.gridAnimations:animateSelected  (touchedGem.gem)                                              \n        end\n    end\n    ```", "```cpp\n    function GridController:selectTargetGem (touchedGem)\n        if (self.gameLayer.targetGem ~= nil) then return end\n        self.enabled = false\n        self.gameLayer.targetIndex = {x = touchedGem.x,  y = touchedGem.y}\n        self.gameLayer.targetGem = touchedGem.gem\n        self.gameLayer.targetGem:setLocalZOrder(constants.Z_SWAP_1)\n        self.gameLayer:swapGemsToNewPosition()\n    end\n    ```", "```cpp\n    function GameScene:swapGemsToNewPosition ()\n        local function onMatchedAnimatedOut (sender)\n            self:collapseGrid()\n        end\n\n        local function onReturnSwapComplete (sender)\n            self.gridController.enabled = true\n        end\n\n        local function onNewSwapComplete (sender)\n           self.gridGemsColumnMap[self.targetIndex.x][self.targetIndex.y]  = self.selectedGem\n            self.gridGemsColumnMap[self.selectedIndex.x][self.selectedIndex.y] =  self.targetGem\n            self.grid[self.targetIndex.x][self.targetIndex.y] =  self.selectedGem.type\n            self.grid[self.selectedIndex.x][self.selectedIndex.y] =  self.targetGem.type\n    The call back switches the gems around inside the grid array.\n            self.combos = 0\n            self.addingCombos = true\n    Combos are used to track if we have more than 3 gems matched  after the player's move.        \n            --check for new matches\n            if (self.gridController:checkGridMatches() == true) then\n    ```", "```cpp\n                    --animate matched gems\n                if (#self.gridController.matchArray > 3) then  self.combos = self.combos + (#self.gridController.matchArray -  3) end \n                self.gridAnimations:animateMatches  (self.gridController.matchArray, onMatchedAnimatedOut)\n                self:showMatchParticle  (self.gridController.matchArray)\n                self:setGemsScore(#self.gridController.matchArray *  constants.POINTS)\n                self:playFX(\"match2.wav\")\n            else\n                --no matches, swap gems back\n                self.gridAnimations:swapGems (self.targetGem,  self.selectedGem, onReturnSwapComplete)\n                self.gridGemsColumnMap[self.targetIndex.x][self.targetIndex.y]  = self.targetGem\n                self.gridGemsColumnMap[self.selectedIndex.x][self.selectedIndex.y]  = self.selectedGem\n                self.grid[self.targetIndex.x][self.targetIndex.y] =  self.targetGem.type\n                self.grid[self.selectedIndex.x][self.selectedIndex.y] =  self.selectedGem.type\n                self:playFX(\"wrong.wav\")\n            end\n    ```", "```cpp\n            self.selectedGem = nil\n            self.targetGem = nil\n       end\n    ```", "```cpp\n       self.gridAnimations:swapGems (self.selectedGem, self.targetGem, onNewSwapComplete)\n    end\n    ```", "```cpp\n    function GridController:checkGridMatches ()\n        self.matchArray = {}\n        for c = 1, constants.GRID_SIZE_X do\n            for r = 1, constants.GRID_SIZE_Y do\n                self:checkTypeMatch(c,r)\n            end\n        end\n        if (#self.matchArray >= 2) then\n            self.gameLayer:addToScore()\n            return true\n        end\n        print(\"no matches\")\n        return false\n    end\n    ```", "```cpp\n    function GridController:checkTypeMatch (c, r)\n        local type = self.gameLayer.grid[c][r]\n        local stepC = c\n        local stepR = r\n        local temp_matches = {}\n        --check top\n        while stepR -1 >= 1 and self.gameLayer.grid[c][stepR-1] ==  type do\n            stepR = stepR - 1\n            table.insert (temp_matches, {x = c, y = stepR})\n        end \n        if (#temp_matches >= 2) then self:addMatches (temp_matches) end\n        temp_matches = {}\n        --check bottom\n        stepR = r\n        while stepR + 1 <= constants.GRID_SIZE_Y \n       and self.gameLayer.grid[c][stepR + 1] == type do\n            stepR = stepR + 1\n            table.insert (temp_matches, {x = c, y= stepR})\n        end\n        if (#temp_matches >= 2) then self:addMatches (temp_matches) end\n        temp_matches = {}\n        --check left\n        while stepC - 1 >= 1 and self.gameLayer.grid[stepC - 1][r]  == type do\n            stepC = stepC - 1\n            table.insert (temp_matches, {x = stepC, y= r})\n        end\n        if (#temp_matches >= 2) then self:addMatches (temp_matches) end\n        temp_matches = {}\n        --check right\n        stepC = c;\n        while stepC + 1 <= constants.GRID_SIZE_X and  self.gameLayer.grid[stepC + 1][r] == type do\n            stepC = stepC + 1\n            table.insert (temp_matches, {x = stepC, y = r})\n        end\n        if (#temp_matches >= 2) then self:addMatches (temp_matches) end\n    end\n    ```", "```cpp\n    function GridController:addMatches (matches)\n        for key, value in pairs(matches) do\n            if (self:find(value, self.matchArray) == false) then\n                table.insert(self.matchArray, value)\n            end\n        end\n    end\n    ```", "```cpp\n    function GridController:find (np, array)\n        for key, value in pairs(array) do\n            if (value.x == np.x and value.y == np.y) then return true end\n        end\n        return false\n    end\n    ```", "```cpp\n    function GameScene:collapseGrid ()\n        for i = 1, #self.gridController.matchArray do\n            self.grid[self.gridController.matchArray[i].x]\n            [self.gridController.matchArray[i].y] = -1\n        end\n\n        local column = nil\n        local newColumn = nil\n        local i\n    ```", "```cpp\n        for c = 1, constants.GRID_SIZE_X do\n            column = self.grid[c]\n            newColumn = {}\n            i = 1\n            while #newColumn < #column do\n                if (#column > i) then\n                    if (column[i] ~= -1) then\n                        --move gem\n                        table.insert(newColumn, column[i])\n                    end\n                else\n                    --create new gem\n                    table.insert(newColumn, 1, column[i])\n                end\n                i = i+1            \n            end\n            self.grid[c] = newColumn\n        end\n        self.gridAnimations:animateCollapse  (onGridCollapseComplete)\n    end\n    ```", "```cpp\n    local function onGridCollapseComplete (sender)\n       local function onMatchedAnimatedOut (sender)\n          self:collapseGrid()\n       end\n       for i = 1, #self.allGems do\n          local gem = self.allGems[i]\n          local xIndex = math.ceil ((gem:getPositionX() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))\n          local yIndex = math.ceil ((gem:getPositionY() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))\n          self.gridGemsColumnMap[xIndex][yIndex] = gem\n          self.grid[xIndex][yIndex] = gem.type\n       end\n    ```", "```cpp\n    if (self.gridController:checkGridMatches () == true) then\n          --animate matched games\n          if (self.addingCombos == true) then\n             if (#self.gridController.matchArray > 3) then  self.combos = self.combos + (#self.gridController.matchArray -  3) end\n          end\n          self.gridAnimations:animateMatches  (self.gridController.matchArray, onMatchedAnimatedOut)\n          self:showMatchParticle (self.gridController.matchArray)\n          self:setGemsScore(#self.gridController.matchArray *  constants.POINTS)\n          self:playFX(\"match.wav\")\n    ```", "```cpp\n    else \n       --no more matches, check for combos\n       if (self.combos > 0) then\n       --now turn random gems into diamonds\n           local diamonds = {}\n           local removeGems = {}\n           local i = 0\n\n           math.randomseed(os.clock())\n           while i < self.combos do\n             i = i + 1\n             local randomGem = nil\n             local randomX,randomY = 0\n             while randomGem == nil do\n               randomX = math.random(1, constants.GRID_SIZE_X)\n               randomY = math.random(1, constants.GRID_SIZE_Y)\n               randomGem = self.gridGemsColumnMap[randomX][randomY]\n               if (randomGem.type == constants.TYPE_GEM_WHITE)  then randomGem = nil end\n           end\n    ```", "```cpp\n            local diamond = self.objectPools:getDiamond()\n          diamond:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())\n          local diamondParticle =  self.objectPools:getDiamondParticle()\n          diamondParticle:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())\n             table.insert(diamonds, diamond)   \n             table.insert(removeGems, {x=randomX, y=randomY}) \n            end\n            self:setDiamondScore(#diamonds *  constants.DIAMOND_POINTS)\n    ```", "```cpp\n            self.gridAnimations:animateMatches(removeGems,  onMatchedAnimatedOut)                \n         self.gridAnimations:collectDiamonds(diamonds)\n         self.combos = 0 \n         self:playFX(\"diamond2.wav\")  \n        else\n         self.gridController.enabled = true\n        end\n         self.addingCombos = false\n       end\n    end\n    ```", "```cpp\n    function GameScene:collapseGrid ()\n        local function onGridCollapseComplete (sender)\n           local function onMatchedAnimatedOut (sender)\n                self:collapseGrid()\n            end\n           for i = 1, #self.allGems do\n                local gem = self.allGems[i]\n                local xIndex = math.ceil ((gem:getPositionX() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))\n                local yIndex = math.ceil ((gem:getPositionY() -  constants.TILE_SIZE * 0.5) / (constants.TILE_SIZE +  constants.GRID_SPACE))\n                self.gridGemsColumnMap[xIndex][yIndex] = gem\n                self.grid[xIndex][yIndex] = gem.type\n            end\n            if (self.gridController:checkGridMatches () == true) then\n               --animate matched games\n               if (self.addingCombos == true) then\n                   if (#self.gridController.matchArray > 3) then  self.combos = self.combos + (#self.gridController.matchArray -  3) end\n               end\n               self.gridAnimations:animateMatches  (self.gridController.matchArray, onMatchedAnimatedOut)\n               self:showMatchParticle  (self.gridController.matchArray)\n               self:setGemsScore(#self.gridController.matchArray *  constants.POINTS)\n               self:playFX(\"match.wav\")\n            else \n                --no more matches, check for combos\n                if (self.combos > 0) then\n                    --now turn random gems into diamonds\n                    local diamonds = {}\n                    local removeGems = {}\n                    local i = 0\n                    math.randomseed(os.clock())\n                    while i < self.combos do\n                       i = i + 1\n                       local randomGem = nil\n                        local randomX,randomY = 0\n                       while randomGem == nil do\n                            randomX =  math.random(1, constants.GRID_SIZE_X)\n                            randomY =  math.random(1, constants.GRID_SIZE_Y)\n                            randomGem =  self.gridGemsColumnMap[randomX][randomY]\n                            if (randomGem.type ==  constants.TYPE_GEM_WHITE) then randomGem = nil end\n                        end\n                        local diamond =  self.objectPools:getDiamond()\n                        diamond:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())\n                        local diamondParticle =  self.objectPools:getDiamondParticle()\n                        diamondParticle:setPosition(randomGem:getPositionX(),  randomGem:getPositionY())\n                        table.insert(diamonds, diamond)\n                        table.insert(removeGems, {x=randomX,  y=randomY}) \n                    end\n                    self:setDiamondScore(#diamonds *  constants.DIAMOND_POINTS)\n                    self.gridAnimations:animateMatches(removeGems,  onMatchedAnimatedOut)                \n                    self.gridAnimations:collectDiamonds(diamonds)\n                    self.combos = 0 \n                    self:playFX(\"diamond2.wav\")                 \n                else\n                    self.gridController.enabled = true\n                end\n                self.addingCombos = false\n            end\n        end\n        for i = 1, #self.gridController.matchArray do\n            self.grid[self.gridController.matchArray[i].x] [self.gridController.matchArray[i].y] = -1\n        end\n\n        local column = nil\n        local newColumn = nil\n        local i\n        for c = 1, constants.GRID_SIZE_X do\n            column = self.grid[c]\n            newColumn = {}\n            i = 1\n            while #newColumn < #column do\n                if (#column > i) then\n                    if (column[i] ~= -1) then\n                        --move gem\n                        table.insert(newColumn, column[i])\n                    end\n                else\n                    --create new gem\n                    table.insert(newColumn, 1, column[i])\n                end\n                i = i+1            \n            end\n            self.grid[c] = newColumn\n        end\n        self.gridAnimations:animateCollapse  (onGridCollapseComplete)\n    end\n    ```", "```cpp\n    function GridAnimations:animateSelected (gem)\n        gem:select()\n        gem:stopAllActions()\n        local rotate = cc.EaseBounceOut:create ( cc.RotateBy:create(0.5, 360) )\n        gem:runAction(rotate)\n    end\n    ```", "```cpp\n    function GridAnimations:swapGems  (gemOrigin, gemTarget, onComplete)\n        gemOrigin:deselect()\n       local origin = self.gameLayer.selectedGemPosition\n        local target = cc.p(gemTarget:getPositionX(),  gemTarget:getPositionY()) \n       local moveSelected =  cc.EaseBackOut:create(cc.MoveTo:create(0.8, target) )   \n        local moveTarget =  cc.EaseBackOut:create(cc.MoveTo:create(0.8, origin) )\n        local callback = cc.CallFunc:create(onComplete)\n       gemOrigin:runAction(moveSelected)\n        gemTarget:runAction (cc.Sequence:create(moveTarget, callback))\n    end\n    ```", "```cpp\n    function GridAnimations:animateMatches (matches, onComplete)\n        local function onCompleteMe (sender)\n           self.animatedMatchedGems = self.animatedMatchedGems - 1;\n            if (self.animatedMatchedGems == 0) then\n                if (onComplete ~= nil) then onComplete() end\n            end\n    end\n        self.animatedMatchedGems = #matches\n       local gem = nil\n        for i, point in ipairs(matches) do\n            gem = self.gameLayer.gridGemsColumnMap[point.x] [point.y]\n            gem:stopAllActions()\n            local scale = cc.EaseBackOut:create  ( cc.ScaleTo:create(0.3, 0))\n            local callback = cc.CallFunc:create(onCompleteMe)\n            local action = cc.Sequence:create (scale, callback)\n            gem.gemContainer:runAction(action)\n        end\n    end\n    ```", "```cpp\n    function GridAnimations:collectDiamonds(diamonds)\n        local function removeDiamond (sender)\n            sender:setVisible(false)\n        end\n        for i = 1, #diamonds do\n            local delay = cc.DelayTime:create(i * 0.05)\n            local moveTo = cc.EaseBackIn:create( cc.MoveTo:create ( 0.8, cc.p(50, constants.SCREEN_HEIGHT - 50) ) )\n            local action = cc.Sequence:create  (delay, moveTo, cc.CallFunc:create(removeDiamond))\n            diamonds[i]:runAction(action)\n        end\n    end\n    ```", "```cpp\n    function GridAnimations:animateCollapse ( onComplete )\n        self.animatedCollapsedGems = 0\n        local gem = nil\n        local drop  = 1\n       for c = 1, constants.GRID_SIZE_X do \n            drop = 1\n            for r = 1, constants.GRID_SIZE_Y do\n                gem = self.gameLayer.gridGemsColumnMap[c][r]\n                --if this gem has been resized, move it to the top \n                if (gem.gemContainer:getScaleX() ~= 1) then\n                    gem:setPositionY((constants.GRID_SIZE_Y +  (drop)) * (constants.TILE_SIZE + constants.GRID_SPACE))\n                    self.animatedCollapsedGems =  self.animatedCollapsedGems + 1\n                    gem:setType ( self.gameLayer:getNewGem() )\n                    gem:setVisible(true)\n                    local newY = (constants.GRID_SIZE_Y -  (drop - 1)) * (constants.TILE_SIZE + constants.GRID_SPACE)\n                    self:dropGemTo (gem, newY,  0.2, onComplete)\n                    drop = drop + 1\n                else\n                   if (drop > 1) then\n                        self.animatedCollapsedGems =  self.animatedCollapsedGems + 1\n                        local newY = gem:getPositionY() -  (drop - 1) * (constants.TILE_SIZE + constants.GRID_SPACE)\n                        self:dropGemTo (gem, newY, 0, onComplete)\n                    end\n               end\n            end \n        end\n    end \n    ```", "```cpp\n    gem:setType ( self.gameLayer:getNewGem() )\n    ```", "```cpp\n    function GridAnimations:dropGemTo (gem, y, delay, onComplete)\n          gem:stopAllActions()\n        gem:reset()\n        local function onCompleteMe  (sender)\n            self.animatedCollapsedGems =  self.animatedCollapsedGems - 1;\n            if ( self.animatedCollapsedGems == 0 ) then\n                if (onComplete ~= nil) then onComplete() end\n            end\n        end\n        local move = cc.EaseBounceOut:create  (cc.MoveTo:create (0.6, cc.p(gem:getPositionX(), y) ) )\n        local action = cc.Sequence:create  (cc.DelayTime:create(delay), move,  cc.CallFunc:create(onCompleteMe))\n        gem:runAction(action)\n    end\n    ```"]