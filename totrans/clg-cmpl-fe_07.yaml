- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clang-Tidy Linter Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces Clang-Tidy, the clang-based linter framework that utilizes
    the **Abstract Syntax Tree** (**AST**) to identify anti-patterns in C/C++/Objective-C
    code. First, we’ll discuss Clang-Tidy’s capabilities, the types of checks it offers,
    and how to use them. After that, we will delve into the architecture of Clang-Tidy
    and explore how to create our own custom lint check. In this chapter, we’ll cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Clang-Tidy, including a brief description of the different checks
    provided by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal design of Clang-Tidy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a custom Clang-Tidy check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located in the `chapter5` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter5](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter5).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Overview of Clang-Tidy and usage examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clang-Tidy is a linter and static analysis tool for C and C++ code. It is a
    part of the Clang and LLVM project. The tool is built on top of the Clang frontend,
    which means it understands your code in depth, giving it the ability to catch
    a wide range of issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points to understand about Clang-Tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checks**: Clang-Tidy contains a series of ”checks” that identify various
    issues or suggest enhancements. These checks range from performance improvements
    and potential bugs to coding style and modern C++ best practices. For instance,
    it might suggest using `emplace_back` instead of `push_back` for certain cases
    or identify areas where you might be accidentally using integer overflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: New checks can be added to Clang-Tidy, making it a highly
    extensible tool. If you have specific coding guidelines or practices you want
    to enforce, you can write a check for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: Clang-Tidy is often used within CI/CD pipelines or integrated
    with development environments. Many IDEs support Clang-Tidy directly or via plugins,
    so you can get real-time feedback on your code as you write it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic fixes**: One of the powerful features of Clang-Tidy is its ability
    to not only identify issues but also automatically fix many of them. This is done
    with the `-fix` option. It is, however, important to review the proposed changes,
    as automatic fixes might not always be perfect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: You can configure which checks Clang-Tidy performs using
    a configuration file or command-line options. This allows teams to enforce specific
    coding standards or prioritize certain types of issues. For example, the `-checks=’-*,modernize-*’`
    command-line option will disable all checks but not the checks from modernize
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modern C++ best practices**: One of the often-appreciated features of Clang-Tidy
    is its emphasis on modern C++ idioms and best practices. It can guide developers
    to write safer, more performant, and more idiomatic C++ code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After acquiring basic knowledge about Clang-Tidy, let’s examine how it can be
    built.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Building and testing Clang-Tidy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the basic build configuration specified in [Figure 1.4](B19722_01.xhtml#x1-27004r4)
    and build Clang-Tidy with the following Ninja command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.1**: Using the Ninja command to build Clang-Tidy'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install the Clang-Tidy binary to the designated `install` folder using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.2**: Using the Ninja command to install Clang-Tidy'
  prefs: []
  type: TYPE_NORMAL
- en: Using the build configuration from [Figure 1.4](B19722_01.xhtml#x1-27004r4),
    the command will install the Clang-Tidy binary under the `<...>/llvm-project/install/bin`
    folder. Here, `<...>/llvm-project` refers to the path where the LLVM code base
    was cloned (see [Figure 1.1](B19722_01.xhtml#x1-25005r1)).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you use a build configuration with shared libraries (with the `BUILD``_SHARED``_LIBS`
    flag set to `ON` ), as shown in [Figure 1.12](B19722_01.xhtml#x1-30003r12), then
    you might need to install and built all artifacts with `ninja` `install` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang-Tidy is part of Clang-Tools-Extra, and its tests are a part of the `clang-tools`
    CMake target. Thus, we can run the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.3**: Using the Ninja command to run Clang-Tidy tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will run LIT tests (see [*Section** 4.5.2*](B19722_04.xhtml#x1-830002)*,
    LLVM test* *framework*) for all Clang-Tidy checks, and will also run unit tests
    for the Clang-Tidy core system. You can also run a specific LIT test separately;
    for example, if we want to run the LIT test for the `modernize-loop-convert` check,
    we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.4**: Testing the modernize-loop-convert clang-tidy check'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.5**: LIT test output for the cppcoreguidelines-owning-memory clang-tidy
    check'
  prefs: []
  type: TYPE_NORMAL
- en: After building and testing Clang-Tidy, it’s now time to run it on some code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 Clang-Tidy usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test Clang-Tidy, we will use the following test program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.6**: Test program for Clang-Tidy: loop-convert.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is correctly written in the older C++ code style, that is, before
    C++11\. Clang-Tidy has a set of checks that encourage adopting the modern C++
    code style and using new C++ idioms available in the latest C++ standard. These
    checks can be run on the program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.7**: Running Clang-Tidy modernize checks on loop-convert.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parts of [Figure 5.7](#x1-103021r7) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 1*: The path to the Clang-Tidy binary is specified here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 2*: We remove all checks using the ’`-*` ’ option. Then, we enable all
    checks with the ’`modernize` ’ prefix by using the ’`-*,modernize-*` ’ value for
    the ’`--checks` ’ argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 3*: We specify the path to the code to be tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 4*: We pass additional arguments to the compiler, notably specifying
    that we want the compiler to use C++17 as the C++ standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.8**: Output from running Clang-Tidy on loop-convert.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, several issues were detected, and Clang-Tidy suggested some
    fixes. Unfortunately, some of them conflict with each other, especially `modernize-loop-convert`
    and `modernize-use-auto` , and cannot be applied together. On the other hand,
    we can apply the fix suggested by `modernize-loop-convert` by running only this
    specific check to avoid any conflicts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.9**: Running a modernize-loop-convert check on loop-convert.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the second line has changed compared to [Figure 5.7](#x1-103021r7),
    and another line (3) has been added. The latter instructs Clang-Tidy to apply
    the fixes suggested by the check. The resulting code can be found in the original
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.10**: Fixed test program for Clang-Tidy: loop-convert.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, *Lines 6* and *7* have changed compared to the original code
    from [Figure 5.6](#x1-103014r6). This functionality makes Clang-Tidy a powerful
    tool that can not only detect issues but also fix them. We will explore this possibility
    in greater depth later in [*Section** 7.3*](B19722_07.xhtml#x1-1410003)*, Clang-Tidy
    as a code modification* *tool*.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3 Clang-Tidy checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clang-Tidy has a wide variety of checks grouped into different categories.
    Here’s a concise list of some of the main categories, with an example check from
    each and a brief description:'
  prefs: []
  type: TYPE_NORMAL
- en: '**boost-***:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boost-use-to-string`: Suggests replacing `boost::lexical``_cast<std:` `:string>`
    with `boost::to``_string`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bugprone-***:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bugprone-integer-division`: Warns when integer division in a floating-point
    context is likely to cause unintended loss of precision'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cert-*** (Checks related to the CERT C++ Secure Coding Standard):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cert-dcl03-c`: Ensures that macros are not used in unsafe contexts'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cppcoreguidelines-*** (Checks from C++ Core Guidelines):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cppcoreguidelines-slicing`: Warns on slicing (object slicing, where a derived
    object is assigned to a base object, cutting off the derived parts)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**google-*** (Google’s coding conventions):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`google-build-using-namespace`: Flags using-directives'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**llvm-*** (LLVM coding conventions):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`llvm-namespace-comment`: Ensures that namespaces have closing comments'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**misc-*** (Miscellaneous checks):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`misc-unused-parameters`: Flags parameters that are unused'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**modernize-*** (Modernization checks for C++):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`modernize-use-auto`: Recommends the use of `auto` for variable declarations
    when appropriate'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**performance-***:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`performance-faster-string-find`: Suggests faster alternatives for string searching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**readability-***:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`readability-identifier-naming`: Ensures consistent identifier naming'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is just a representation of a subset of the checks available. Each
    category contains multiple checks, and there are additional categories in the
    tool as well. For a complete, up-to-date list of checks and their detailed descriptions,
    refer to the official Clang-Tidy documentation [[17](B19722_Bib.xhtml#Xllvm_clang_tidy)]
    or use the `clang-tidy -list-checks` command on your system.
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to build and use clang-tidy, it’s time to delve deeper and
    examine its internal design.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Clang-Tidy’s internal design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Tidy is built on top of Clang. At its core, Clang-Tidy leverages Clang’s
    ability to parse and analyze source code into an AST. Each check in Clang-Tidy
    essentially involves defining patterns or conditions to match against this AST.
    When a match is found, a diagnostic can be raised, and in many cases, an automatic
    fix can be suggested. The tool operates on the basis of individual ”checks” that
    target specific issues or coding styles. Checks are implemented as plugins, making
    Clang-Tidy extensible. The `ASTMatchers` library facilitates writing these checks
    by providing a domain-specific language to query the AST; see [*Section** 3.5*](B19722_03.xhtml#x1-630005)*,
    AST matchers* and the official documentation [[16](B19722_Bib.xhtml#Xllvm_astmatchers)]
    for more info. This ensures that checks are both concise and expressive. Clang-Tidy
    also has support for analyzing the code base using a compilation database, which
    provides context such as compile flags (see [*Chapter** 9*](B19722_09.xhtml#x1-1810009)*,
    Appendix 1: Compilation Database* for more info). This comprehensive integration
    with Clang’s internals makes Clang-Tidy a powerful static analysis tool with precise
    code transformation capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Internal organization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The internal organization of clang-tidy within the Clang code base can be complex
    due to its deep integration with the Clang libraries, but at a high level, the
    organization can be broken down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source and headers**: The main source code and headers for `clang-tidy` are
    located in the `clang-tools-extra` repository, specifically within the `clang-tidy`
    directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Main driver**: The `ClangTidyMain.cpp` file, located in the `tool` subfolder,
    serves as the main driver for the Clang-Tidy tool.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Core infrastructure**: Files such as `ClangTidy.cpp` , `ClangTidy.h` manage
    the core functionalities and options.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Checks**: Checks are organized into subdirectories based on categories (e.g.,
    `bugprone` or `modernize` ).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Utilities**: The `utils` directory contains utility classes and functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AST Matchers**: The `ASTMatchers` library, which we explored previously in
    [*Section** 3.5*](B19722_03.xhtml#x1-630005)*, AST matchers*, is integral for
    querying the AST.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clang diagnostics**: Clang-Tidy actively uses the Clang diagnostics subsystem
    to print diagnostics messages and suggest fixes (see [*Section** 4.4.2*](B19722_04.xhtml#x1-800002)*,
    Diagnostics support*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tests**: Tests are located in the `test` directory and use LLVM’s LIT framework
    (see [*Section** 4.5.2*](B19722_04.xhtml#x1-830002)*, LLVM test framework*). It’s
    worth noting that the test folder is shared with other projects inside the `clang-tools-extra`
    folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Documentation**: The `docs` directory contains documentation for Clang-Tidy.
    As well as the tests, the documentation is a part of other projects inside the
    `clang-tools-extra` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These relationships are schematically illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Clang-Tidy’s internal organization ](img/Figure5.11_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.11**: Clang-Tidy’s internal organization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have gained an understanding of Clang-Tidy’s internals and its
    relationship with other parts of Clang/LLVM, it’s time to explore components external
    to the Clang-Tidy binary: its configuration and other tools that leverage the
    functionality provided by Clang-Tidy.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 Configuration and integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Clang-Tidy binary can interact with other components, as shown in [Figure 5.12](#Figure5.12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Clang-Tidy external components: configuration and integrations
    ](img/Figure5.12_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.12**: Clang-Tidy external components: configuration and integrations'
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy can be seamlessly integrated with various **Integrated Development**
    **Environments** (**IDEs**), such as Visual Studio Code, CLion, and Eclipse, to
    provide real-time feedback during coding. We will explore this possibility later
    in [*Section** 8.5.2*](B19722_08.xhtml#x1-1700002)*, Clang-Tidy*.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be incorporated into build systems such as CMake and Bazel to run
    checks during builds. **Continuous Integration** (**CI**) platforms, such as Jenkins
    and GitHub Actions, often employ Clang-Tidy to ensure code quality on pull requests.
    Code review platforms, such as Phabricator, utilize Clang-Tidy for automated reviews.
    Additionally, custom scripts and static analysis platforms can harness Clang-Tidy’s
    capabilities for tailored workflows and combined analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of Clang-Tidy shown in [Figure 5.12](#Figure5.12) is
    its configuration. Let’s explore it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Clang-Tidy uses a configuration file to specify which checks to run and to set
    options for those checks. This configuration is done using a `.clang-tidy` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.clang-tidy` file is written in YAML format. It typically contains two
    main keys: `Checks` and `CheckOptions` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the `Checks` key, which allows us to specify which checks
    to enable or disable:'
  prefs: []
  type: TYPE_NORMAL
- en: Use - to disable a check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use * as a wildcard to match multiple checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks are comma-separated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.13**: Checks key of a .clang-tidy config file'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next key is `CheckOptions` . This key allows us to set options for specific
    checks, with each option specified as a key-value pair. An example is provided
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.14**: CheckOptions key of a .clang-tidy config file'
  prefs: []
  type: TYPE_NORMAL
- en: When Clang-Tidy is run, it searches for the `.clang-tidy` file in the directory
    of the file being processed and its parent directories. The search stops when
    the file is found.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of Clang-Tidy’s internal design, it’s time
    to create our first custom Clang-Tidy check using the information we’ve gathered
    from this and previous chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Custom Clang-Tidy check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part of the chapter, we will transform our plugin example (see [*Section** 4.6*](B19722_04.xhtml#x1-840006)*,
    Clang plugin project*) into a Clang-Tidy check. This check will estimate the complexity
    of a C++ class based on the number of methods it contains. We will define a threshold
    as a parameter for the check.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy offers a tool designed to aid in the creation of checks. Let’s begin
    by creating a skeleton for our check.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Creating a skeleton for the check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clang-Tidy provides a specific Python script, `add``_new``_check.py` , to assist
    in creating new checks. This script is located in the `clang-tools-extra/clang-tidy`
    directory. The script requires two positional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module` : This refers to the module directory where the new tidy check will
    be placed. In our case, this will be `misc` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check` : This is the name of the new tidy check to add. For our purposes,
    we will name it `classchecker` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By running the script in the `llvm-project` directory (which contains the cloned
    LLVM repository), we receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.15**: Creating a skeleton for the misc-classchecker check'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output, we can observe that several files under the `clang-tools-extra/`
    `clang-tidy` directory have been updated. These files pertain to checks registration,
    such as `misc/MiscTidyModule.cpp` , or build configuration, such as `misc/CMakeLists.txt`
    . The script also generated several new files, which we need to modify in order
    to implement our check’s desired logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`misc/ClasscheckerCheck.h` : This is the header file for our check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`misc/ClasscheckerCheck.cpp` : This file will house the implementation of our
    check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the script has generated a LIT test for our check, named `ClassChecker.cpp.`
    This test can be found in the `clang-tools-extra/test/clang-tidy/checkers/misc`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the source files, the script also modifies some documentation files
    in the `clang-tools-extra/docs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReleaseNotes.rst` : This file contains updated release notes with placeholder
    entries for our new check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang-tidy/checks/misc/classchecker.rst` : This serves as the primary documentation
    for our check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang-tidy/checks/list.rst` : The list of checks has been updated to include
    our new check alongside other checks from the ’`misc` ’ module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now turn our attention to implementing the check and the subsequent
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 Clang-Tidy check implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll begin by modifying `ClasscheckerCheck.cpp` . The generated file can be
    found in the `clang-tools-extra/clang-tidy/misc` directory. Let’s replace the
    generated code with the following (note: the generated comment containing the
    license info has been omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.16**: Modifications to ClasscheckerCheck.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: We replaced the original stub with *Lines 15-35* to implement the necessary
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: To integrate our check into the Clang-Tidy binary, we can execute the standard
    build procedure from the `build` directory within the LLVM source tree; see [Figure 5.2](#x1-102004r2).
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of our check is defined in the modified `MiscTidyModule.cpp` file
    in `clang-tools-extra/clang-tidy/misc` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.17**: Modifications to MiscTidyModule.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in [Figure 5.17](#x1-111042r17) (*Lines 43-44*), we registered
    the new check under the name `"``misc``-``classchecker``"`. After the code modification,
    we are ready to recompile Clang-Tidy with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the check has been added by executing Clang-Tidy with the
    `-list-checks` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.18**: Clang-Tidy `-list-checks` option'
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that we enabled all checks using the `-checks ’*’` command-line
    option, as shown in [Figure 5.18](#x1-111044r18).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the check, we can use the file from the clang plugin project, as seen
    in [Figure 4.39](B19722_04.xhtml#x1-91014r39):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.19**: Test file for the misc-classchecker clang-tidy check: test.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'This file contains three methods. To trigger a warning, we must set the threshold
    to 2, as demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.20**: Run a misc-classchecker check on the test file: test.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.21**: Output of the misc-classchecker check for the test.cpp test
    file'
  prefs: []
  type: TYPE_NORMAL
- en: After testing the file with custom source code, it’s time to create an LIT test
    for our check.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3 LIT test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the LIT test, we will use the slightly modified code from [Figure 4.43](B19722_04.xhtml#x1-93048r43).
    Let’s modify `classchecker.cpp` , located in the `clang-tools-extra/test/clang-tidy/checkers/misc`
    folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.22**: LIT test: classchecker.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the only difference compared to [Figure 4.43](B19722_04.xhtml#x1-93048r43)
    is in *Line 1*, where we specify which commands should be run, and in *Line 9*,
    where we define the test pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.23**: Testing the misc-classchecker clang-tidy check'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.24**: Testing output for misc-classchecker'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the command shown in [Figure 5.3](#x1-102007r3) to run all clang-tidy
    checks, including our newly added one.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our check on a real code base, as opposed to synthetic tests, we
    may encounter unexpected results. One such issue has already been discussed in
    [*Section** 3.7*](B19722_03.xhtml#x1-650007)*, Processing AST in the case of errors*
    and pertains to the impact of compilation errors on Clang-Tidy results. Let’s
    delve into this problem using a specific example.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.4 Results in the case of compilation errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clang-Tidy uses AST as the information provider for checks, and the checks can
    produce wrong results if the information source is broken. The typical case is
    when the analyzed code has compilation errors (see [*Section** 3.7*](B19722_03.xhtml#x1-650007)*,
    Processing AST in the case of errors*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.25**: Test file with compilation errors: error.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we made a syntax error in *Line 6*: the method name is incorrectly
    written as ’doSometing’ instead of ’doSomet**h**ing’. If we run our check on the
    file without any parameters, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.26**: Running a misc-classchecker check on a file containing compilation
    errors'
  prefs: []
  type: TYPE_NORMAL
- en: Our check seems to be working incorrectly with this code. It assumes the class
    has seven methods when, in fact, it has only one.
  prefs: []
  type: TYPE_NORMAL
- en: The case of compilation errors can be considered an edge case, and we can process
    it correctly. Before addressing these cases, we should investigate the produced
    AST to examine the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5 Compilation errors as edge cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use `clang-query` (see [*Section** 3.6*](B19722_03.xhtml#x1-640006)*,
    Explore Clang AST with* *clang-query*) to explore what has happened with the AST.
    The program with the error fixed is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.27**: noerror.cpp test file with compilation errors fixed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clang-query` command can be run on the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.28**: Clang-Query run on noerror.cpp file with compilation errors
    fixed'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will set up Clang-Query’s output as `dump` and find all matches for
    `CXXRecordDecl`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.29**: Setup Clang-Query output and run matchers'
  prefs: []
  type: TYPE_NORMAL
- en: The result is shown below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.30**: AST for the noerror.cpp file with compilation errors fixed'
  prefs: []
  type: TYPE_NORMAL
- en: Compare it with the output for the code with an error (see [Figure 5.25](#x1-113009r25)).
    We run Clang-Query on the error.cpp file and set up the required matcher as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.31**: Clang-Query run on error.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The found match is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.32**: AST for the error.cpp file with a compilation error'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, all additional methods are added implicitly. We can exclude
    them by modifying *Line 30* (see [Figure 5.16](#x1-111031r16)) of our check code,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.33**: Exclude implicit declaration from the check report'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the modified check on the file that contains compilation errors,
    we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 5.34**: Running a fixed misc-classchecker check on a file containing
    compilation errors'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the compiler error is reported, but our check does not trigger
    any warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the fact that we correctly processed the unusual clang-tidy result,
    it’s worth noting that not every compilation error can be correctly processed.
    As mentioned in [*Section** 3.7*](B19722_03.xhtml#x1-650007)*, Processing AST
    in the case of errors*, the Clang compiler tries to produce an AST even when encountering
    compilation errors. This approach is because it’s designed for use by IDEs and
    other tools that benefit from as much information as possible, even in the presence
    of errors. However, this ”error-recovery” mode of the AST can produce structures
    that Clang-Tidy might not anticipate. Therefore, we should adhere to the following
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always ensure your code compiles without errors before running Clang-Tidy and
    other Clang Tools. This guarantees that the AST is both accurate and complete.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we delved into Clang-Tidy, a robust tool for code analysis.
    We explored its configuration, execution, and internal architecture. Additionally,
    we developed a custom Clang-Tidy check to assess class complexity. Our check utilized
    basic AST matchers, akin to regular expressions within the AST. For complexity
    determination, we employed a simple method. More sophisticated metrics, such as
    cyclomatic complexity, demand tools such as **Control Flow Graphs** (**CFGs**).
    The adventure continues in the next chapter, where we’ll dive deep into designing
    intricate checks using CFG.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Tidy extra Clang tools documentation: [https://clang.llvm.org/extra/clang-tidy/](https://clang.llvm.org/extra/clang-tidy/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AST matcher reference: [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
