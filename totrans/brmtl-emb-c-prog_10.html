<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer096">
			<h1 id="_idParaDest-159" class="chapter-number"><a id="_idTextAnchor278"/>10</h1>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor279"/>The Universal Asynchronous Receiver/Transmitter Protocol</h1>
			<p>In this chapter, we will learn about the <strong class="bold">universal asynchronous receiver/transmitter</strong> (<strong class="bold">UART</strong>) protocol, an important communication method widely used in <a id="_idIndexMarker643"/>embedded systems. UART is fundamental for enabling communication between microcontrollers and various peripherals, making it an essential component in embedded <span class="No-Break">systems development.</span></p>
			<p>We will start by discussing the significance of communication protocols in embedded systems and highlight common use cases for UART alongside other protocols such as SPI and I2C. Following this, we will provide a comprehensive overview of the UART protocol, detailing its operational principles and features. Next, we will extract and examine the relevant registers for UART from the STM32 reference manual, providing the necessary foundational knowledge for driver development. Finally, we will apply this knowledge to develop a bare-metal UART driver, illustrating the practical aspects of initializing and transmitting data <span class="No-Break">via UART.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Introduction to <span class="No-Break">communication protocols</span><a id="_idTextAnchor280"/></li>
				<li>Overview of the <span class="No-Break">UART protocol</span></li>
				<li>The STM32F4 <span class="No-Break">UART peripheral</span></li>
				<li>Developing the <span class="No-Break">UART driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the UART protocol and the skills needed to develop bare-metal drivers for <span class="No-Break">UART communication.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor281"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor282"/>Introduction to communication protocols</h1>
			<p>In the world of <a id="_idIndexMarker644"/>embedded systems, communication protocols are essential conduits that enable microcontrollers and peripheral devices to talk to each other seamlessly. Think of them as the languages that different devices use to understand and exchange information, ensuring that everything from your smartphone to your smart home devices <span class="No-Break">works smoothly.</span></p>
			<p>Let’s dive into what communication protocols are, how they are grouped, their unique features and advantages, and explore some common use cases to see these protocols <span class="No-Break">in action.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor283"/>What are communication protocols?</h2>
			<p>Communication protocols are sets of rules and conventions that allow electronic devices to communicate with each other. These protocols define how data is formatted, transmitted, and received, ensuring that devices can exchange information accurately and reliably. Without these protocols, it would be like trying to have a conversation with someone who speaks a completely different language – communication would be chaotic <span class="No-Break">and error-prone.</span></p>
			<p>In embedded systems, these protocols are crucial because they facilitate the interaction between microcontrollers and peripherals such as sensors, actuators, displays, and other microcontrollers. Whether it’s sending a simple temperature reading from a sensor to a microcontroller or streaming video data from a camera module, communication protocols make <span class="No-Break">it happen.</span></p>
			<p>Let’s analyze the classification of communication protocols, starting with the big picture: what communication protocols can be broadly classified into – <strong class="bold">serial</strong> and <span class="No-Break"><strong class="bold">parallel</strong></span><span class="No-Break"> communication.</span></p>
			<h3>Serial versus parallel communication</h3>
			<p>Let’s start<a id="_idIndexMarker645"/> with <span class="No-Break">serial</span><span class="No-Break"><a id="_idIndexMarker646"/></span><span class="No-Break"> communication.</span></p>
			<h4>Serial communication</h4>
			<p>In this category, communication<a id="_idIndexMarker647"/> protocols can be further broken down into asynchronous and <span class="No-Break">synchronous protocols:</span></p>
			<ul>
				<li><strong class="bold">Asynchronous</strong>: This type of <a id="_idIndexMarker648"/>communication <a id="_idIndexMarker649"/>sends data one bit at a time without a clock signal to synchronize the sender and receiver. Think of it as sending letters through the mail without a scheduled delivery time. A common example is UART, which is simple and efficient for <span class="No-Break">many applications.</span></li>
				<li> <strong class="bold">Synchronous</strong>: Unlike<a id="_idIndexMarker650"/> asynchronous<a id="_idIndexMarker651"/> communication, this form of communication uses a clock signal to coordinate the transmission of bits. It’s like having a drumbeat to ensure everyone <a id="_idIndexMarker652"/>marches in step. Examples include <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) and <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>). These <a id="_idIndexMarker653"/>protocols ensure data integrity and timing, making them suitable for more <span class="No-Break">complex tasks.</span></li>
			</ul>
			<h4>Parallel communication</h4>
			<p>This type involves<a id="_idIndexMarker654"/> transmitting multiple bits simultaneously over multiple channels. Imagine sending a whole fleet of cars instead of a single one – it’s faster but requires more lanes (or pins, in our case). While parallel communication is faster, it’s less common in embedded systems due to the higher pin count. Also, it’s prone to crosstalk and signal integrity problems, especially over <span class="No-Break">longer distances.</span></p>
			<p>We can also classify communication protocols based on their architecture. In this classification system, we have point-to-point communication and <span class="No-Break">multi-device communication.</span></p>
			<h3>Point-to-point versus multi-device communication</h3>
			<p>Let’s look<a id="_idIndexMarker655"/> at <a id="_idIndexMarker656"/><span class="No-Break">the differences.</span></p>
			<h4>Point-to-point</h4>
			<p>This is a direct line<a id="_idIndexMarker657"/> of communication between two devices. <strong class="bold">UART</strong> is a<a id="_idIndexMarker658"/> classic example, where data flows directly between a microcontroller and a peripheral device. It’s straightforward, reliable, and ideal for many <span class="No-Break">embedded systems.</span></p>
			<h4>Multi-device (bus) communication</h4>
			<p>Here, multiple devices<a id="_idIndexMarker659"/> share the same communication lines, which can be either of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Multi-master</strong>: Multiple <a id="_idIndexMarker660"/>devices can control the communication bus. <strong class="bold">I2C</strong> is a great example as it allows multiple masters and slaves on the same <a id="_idIndexMarker661"/>bus. It’s like a group of friends taking turns talking in <span class="No-Break">a conversation.</span></li>
				<li><strong class="bold">Master-slave</strong>: One<a id="_idIndexMarker662"/> master device controls the communication, directing traffic to and from multiple slave devices. <strong class="bold">SPI</strong> operates<a id="_idIndexMarker663"/> this way, with a single master communicating with multiple slaves through dedicated lines. <strong class="bold">I2C</strong> can also operate this way. It’s akin to a teacher (master) calling on students one at a time <span class="No-Break">to speak.</span></li>
			</ul>
			<p>Lastly, communication protocols can be classified based on their data <span class="No-Break">flow capabilities.</span></p>
			<h3>Full-duplex versus half-duplex</h3>
			<p>Let’s see the differences between full-duplex <span class="No-Break">and half-duplex:</span></p>
			<ul>
				<li><strong class="bold">Full-duplex</strong>: This allows<a id="_idIndexMarker664"/> simultaneous two-way communication. Imagine a two-lane road where cars can travel in both directions at the same <a id="_idIndexMarker665"/>time. <strong class="bold">UART</strong> and <strong class="bold">SPI</strong> support<a id="_idIndexMarker666"/> full-duplex communication, making them highly efficient for real-time <span class="No-Break">data exchange.</span></li>
				<li><strong class="bold">Half-duplex</strong>: Here, communication can occur in both directions, but not at the same time – it’s like a single-lane road where cars must take<a id="_idIndexMarker667"/> turns. <strong class="bold">I2C</strong> typically operates in half-duplex<a id="_idIndexMarker668"/> mode, which works well for its intended applications but can be a limitation in high-speed <span class="No-Break">data scenarios.</span></li>
			</ul>
			<p>Now, let’s closely compare the three common communication protocols that are used in modern <span class="No-Break">embedded systems.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor284"/>Comparing UART, SPI, and I2C</h2>
			<p>Let’s start <span class="No-Break">with UART.</span></p>
			<h3>UART</h3>
			<p>Here are some key features<a id="_idIndexMarker669"/> <span class="No-Break">of UART:</span></p>
			<ul>
				<li><strong class="bold">Asynchronous communication</strong>: UART doesn’t require a clock signal. Instead, it uses start and stop bits to synchronize <span class="No-Break">data transmission.</span></li>
				<li><strong class="bold">Full-duplex</strong>: UART can send and receive data simultaneously, which is ideal for many applications requiring <span class="No-Break">real-time communication.</span></li>
				<li><strong class="bold">Simple and cost-effective</strong>: With minimal hardware requirements, UART is easy to implement <span class="No-Break">and cost-effective.</span></li>
			</ul>
			<p>The following are some of <span class="No-Break">its advantages:</span></p>
			<ul>
				<li><strong class="bold">Ease of use</strong>: Setting up<a id="_idIndexMarker670"/> UART communication is straightforward, making it a popular choice for beginners and <span class="No-Break">simple applications</span></li>
				<li><strong class="bold">Wide support</strong>: UART is universally supported by most microcontrollers and <span class="No-Break">peripheral devices</span></li>
				<li><strong class="bold">Low overhead</strong>: The <a id="_idIndexMarker671"/>lack of a clock signal means fewer pins are used, <span class="No-Break">reducing complexity</span></li>
			</ul>
			<p>However, it also has <span class="No-Break">some disadvantages:</span></p>
			<ul>
				<li><strong class="bold">Speed limitations</strong>: UART is<a id="_idIndexMarker672"/> generally slower compared to SPI and I2C, making it less suitable for high-speed <span class="No-Break">data transfer</span></li>
				<li><strong class="bold">Limited distance</strong>: Susceptibility to noise over long distances can limit the range of <span class="No-Break">reliable communication</span></li>
				<li><strong class="bold">Point-to-point only</strong>: UART is designed for direct, point-to-point communication, which can be a limitation if multiple devices need <span class="No-Break">to communicate</span></li>
			</ul>
			<p>Next, we <span class="No-Break">have SPI.</span></p>
			<h3>SPI</h3>
			<p>Here are some <a id="_idIndexMarker673"/>key features <span class="No-Break">of SPI:</span></p>
			<ul>
				<li><strong class="bold">Synchronous communication</strong>: SPI uses a clock signal along with data lines, ensuring synchronized <span class="No-Break">data transfer</span></li>
				<li><strong class="bold">Full-duplex</strong>: It allows data to be sent and <span class="No-Break">received simultaneously</span></li>
				<li><strong class="bold">Master-slave architecture</strong>: One master device controls multiple slave devices, with dedicated lines <span class="No-Break">for each</span></li>
			</ul>
			<p>The following are some of <span class="No-Break">its advantages:</span></p>
			<ul>
				<li><strong class="bold">High speed</strong>: SPI <a id="_idIndexMarker674"/>supports high-speed data transfer, making it ideal for applications requiring <span class="No-Break">fast communication</span></li>
				<li><strong class="bold">Versatility</strong>: SPI can connect multiple devices with different configurations, providing flexibility <a id="_idIndexMarker675"/><span class="No-Break">in design</span></li>
			</ul>
			<p>However, it also has <span class="No-Break">some disadvantages:</span></p>
			<ul>
				<li><strong class="bold">More pins required</strong>: Each slave <a id="_idIndexMarker676"/>device needs a separate select line, which can increase the pin <span class="No-Break">count significantly</span></li>
				<li><strong class="bold">No standardized acknowledgment</strong>: Unlike I2C, SPI does not have a built-in acknowledgment mechanism, which can make error detection <span class="No-Break">more challenging</span></li>
				<li><strong class="bold">Limited multi-master capability</strong>: SPI is not designed for multi-master systems, which<a id="_idIndexMarker677"/> can be a limitation in <span class="No-Break">some scenarios</span></li>
			</ul>
			<p>The final common communication protocol we’ll cover <span class="No-Break">is I2C.</span></p>
			<h3>I2C</h3>
			<p>Here are some key<a id="_idIndexMarker678"/> features <span class="No-Break">of I2C:</span></p>
			<ul>
				<li><strong class="bold">Synchronous communication</strong>: I2C uses a clock signal for synchronized <span class="No-Break">data transfer</span></li>
				<li><strong class="bold">Multi-master capability</strong>: Multiple master devices can share the same bus, which is useful in more <span class="No-Break">complex systems</span></li>
				<li><strong class="bold">Two-wire interface</strong>: I2C requires only two lines (SDA and SCL) for communication, minimizing the <span class="No-Break">pin count</span></li>
			</ul>
			<p>The following are some of <span class="No-Break">its advantages:</span></p>
			<ul>
				<li><strong class="bold">Simplicity in wiring</strong>: The two-wire<a id="_idIndexMarker679"/> interface reduces the complexity and number of <span class="No-Break">pins required</span></li>
				<li><strong class="bold">Multi-device support</strong>: I2C easily connects multiple devices on the same bus, each with a <span class="No-Break">unique address</span></li>
				<li><strong class="bold">Built-in addressing</strong>: I2C has a built-in addressing mechanism, making communication with multiple <a id="_idIndexMarker680"/><span class="No-Break">devices straightforward</span></li>
			</ul>
			<p>However, it does have <span class="No-Break">some disadvantages:</span></p>
			<ul>
				<li><strong class="bold">Slower speed</strong>: I2C is <a id="_idIndexMarker681"/>generally slower than SPI, which can be a limitation for <span class="No-Break">high-speed applications</span></li>
				<li><strong class="bold">Complex protocol</strong>: The protocol is more complex than UART and SPI, requiring more sophisticated handling of data transfers <span class="No-Break">and addressing</span></li>
				<li><strong class="bold">Susceptible to noise</strong>: Like UART, I2C can be susceptible to noise over longer distances, potentially <a id="_idIndexMarker682"/>affecting <span class="No-Break">communication reliability</span></li>
			</ul>
			<p>Choosing the right communication protocol depends on your specific application needs. If you need simple, straightforward communication and can tolerate slower speeds, <strong class="bold">UART</strong> is a great <a id="_idIndexMarker683"/>choice. For high-speed applications with a need for full-duplex communication, <strong class="bold">SPI</strong> is ideal, especially<a id="_idIndexMarker684"/> if you can manage the higher pin count. When you need to connect multiple devices with minimal wiring and have a complex communication setup, <strong class="bold">I2C</strong> is<a id="_idIndexMarker685"/> your go-to protocol. To help you better understand when to choose which protocol, let’s explore some common <span class="No-Break">use cases.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor285"/>Common use cases for the UART, SPI, and I2C protocols</h2>
			<p>When designing embedded systems, selecting the right communication protocol is crucial for ensuring efficient and reliable data exchange. UART, SPI, and I2C each have unique strengths, making them suitable for different applications. Let’s explore the practical use cases and compelling case studies for each protocol, highlighting their professional and <span class="No-Break">real-world relevance.</span></p>
			<h3>UART</h3>
			<p>Let’s look at some<a id="_idIndexMarker686"/> common use cases for the <span class="No-Break">UART protocol:</span></p>
			<ul>
				<li><strong class="bold">Serial communication with PCs</strong>: UART is often used for serial communication between microcontrollers and computers, particularly for debugging, firmware updates, and <span class="No-Break">data logging</span></li>
				<li><strong class="bold">GPS modules</strong>: UART can be used to transmit location data from a GPS module to <span class="No-Break">a microcontroller</span></li>
				<li><strong class="bold">Bluetooth modules</strong>: UART enables wireless communication with devices <span class="No-Break">via Bluetooth</span></li>
			</ul>
			<p>These use cases represent<a id="_idIndexMarker687"/> some of the most common applications of UART, but the protocol is versatile and can be used in many other scenarios that require simple <span class="No-Break">serial communication.</span></p>
			<p class="callout-heading">Case study – GPS module integration for autonomous drones</p>
			<p class="callout">Imagine you’re <a id="_idIndexMarker688"/>developing an autonomous<a id="_idIndexMarker689"/> drone that requires precise navigation to perform tasks such as surveying and mapping. Integrating a GPS module using UART can provide real-time location data essential <span class="No-Break">for navigation.</span></p>
			<p class="callout"><strong class="bold">Setup</strong>: Connect the GPS module’s transmit (TX) pin to the microcontroller’s receive (RX) pin and vice versa. Configure the baud rate so that it matches the GPS <span class="No-Break">module’s output.</span></p>
			<p class="callout"><strong class="bold">Operation</strong>: The GPS module continuously sends NMEA sentences (text strings) containing location data. The microcontroller reads these strings via UART, parses them, and uses the location information to navigate the <span class="No-Break">drone accurately.</span></p>
			<p class="callout"><strong class="bold">Advantage</strong>: UART’s simplicity and widespread support make it straightforward to integrate the GPS module, providing reliable and continuous data flow without a <span class="No-Break">complex setup.</span></p>
			<p>Next, we’ll look <span class="No-Break">at SPI.</span></p>
			<h3>SPI</h3>
			<p>The following are <a id="_idIndexMarker690"/>some common use cases for the <span class="No-Break">SPI protocol:</span></p>
			<ul>
				<li><strong class="bold">High-speed data transfer</strong>: It’s <a id="_idIndexMarker691"/>ideal for<a id="_idIndexMarker692"/> applications such as memory cards, <strong class="bold">analog-to-digital converters</strong> (<strong class="bold">ADCs</strong>), <strong class="bold">digital-to-analog converters</strong> (<strong class="bold">DACs</strong>), <span class="No-Break">and displays</span></li>
				<li><strong class="bold">Display modules</strong>: SPI can be used for communicating with high-resolution displays requiring fast <span class="No-Break">refresh rates</span></li>
				<li><strong class="bold">Sensors and actuators</strong>: SPI can handle high-frequency data outputs from <span class="No-Break">various sensors</span></li>
			</ul>
			<p>Like UART, these examples highlight some typical uses of SPI, but the protocol’s high-speed capabilities make it suitable for a wide range of other applications requiring rapid <span class="No-Break">data transfer.</span></p>
			<p class="callout-heading">Case study – SD card data logging for industrial equipment</p>
			<p class="callout">Consider an industrial <a id="_idIndexMarker693"/>monitoring system that logs data from various sensors to an SD card for long-term analysis. SPI is the perfect protocol for this high-speed <span class="No-Break">data transfer.</span></p>
			<p class="callout"><strong class="bold">Setup</strong>: Connect the microcontroller to the SD card using SPI pins (MISO, MOSI, SCLK, and CS). Initialize the SPI bus and configure the <span class="No-Break">SD card.</span></p>
			<p class="callout"><strong class="bold">Operation</strong>: The microcontroller collects data from sensors (for example, temperature, pressure, and vibration) and writes this data to the SD card in <span class="No-Break">real time.</span></p>
			<p class="callout"><strong class="bold">Advantage</strong>: SPI’s high-speed data transfer ensures that large amounts of data are logged quickly and efficiently, preventing any data loss and ensuring <span class="No-Break">accurate monitoring.</span></p>
			<p>Using SPI in this<a id="_idIndexMarker694"/> scenario allows the industrial system to maintain precise logs of critical parameters, which are essential for predictive maintenance and <span class="No-Break">operational efficiency.</span></p>
			<p>Finally, we <span class="No-Break">have I2C.</span></p>
			<h3>I2C</h3>
			<p>Let’s consider two<a id="_idIndexMarker695"/> common use cases related <span class="No-Break">to I2C:</span></p>
			<ul>
				<li><strong class="bold">Multiple sensor integration systems</strong>: This involves connecting several sensors with different addresses on the same <span class="No-Break">I2C bus</span></li>
				<li><strong class="bold">Peripheral expansion</strong>: This involves adding more GPIO pins to a microcontroller using <span class="No-Break">I2C expanders</span></li>
			</ul>
			<p>These use cases are just two examples of I2C’s applications. Its ability to support multiple devices on a single bus makes it an excellent choice for many other scenarios where scalability <span class="No-Break">is important.</span></p>
			<p class="callout-heading">Case study – environmental monitoring system for smart agriculture</p>
			<p class="callout">Let’s say you’re <a id="_idIndexMarker696"/>developing a smart agriculture system that <a id="_idIndexMarker697"/>uses multiple sensors (temperature, humidity, and soil moisture) to optimize farming conditions. I2C is the ideal protocol for this <span class="No-Break">multi-sensor integration.</span></p>
			<p class="callout"><strong class="bold">Setup</strong>: Connect all sensors to the I2C bus (SDA and SCL lines). Assign each sensor a <span class="No-Break">unique address.</span></p>
			<p class="callout"><strong class="bold">Operation</strong>: The microcontroller queries each sensor in sequence, collects the data, and processes it to provide insights and control irrigation, ventilation, and <span class="No-Break">lighting systems.</span></p>
			<p class="callout"><strong class="bold">Advantage</strong>: I2C’s ability to support multiple devices on the same bus with just two lines simplifies wiring, reduces costs, and saves GPIO pins, making it an efficient solution for complex <span class="No-Break">sensor networks.</span></p>
			<p>Starting with the next section, we’ll focus exclusively on the UART protocol. We’ll cove<a id="_idTextAnchor286"/>r the I2C and SPI protocols in the <span class="No-Break">following chapters.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor287"/>Overview of the UART protocol</h1>
			<p>One of the most fundamental and widely used protocols is UART. Whether you’re debugging hardware or enabling communication between a microcontroller and peripherals, understanding UART is cr<a id="_idTextAnchor288"/>ucial. Let’s delve into the workings of <span class="No-Break">this protocol.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor289"/>What is UART?</h2>
			<p>UART is a hardware<a id="_idIndexMarker698"/> communication protocol that operates using asynchronous serial communication, allowing for adjustable data transmission speeds. The “asynchronous” nature of UART means it doesn’t require a clock signal to align the transmission of bits between the sender and receiver. Instead, both devices must agree on a specific baud rate, which dictates the speed at which<a id="_idTextAnchor290"/> data is exchanged. Let’s take a look at <span class="No-Break">the interface.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor291"/>The interface</h2>
			<p>The UART interface<a id="_idIndexMarker699"/> employs two wires for communication: TX and RX. To establish a connection between two devices, we simply connect the TX pin of the first device to the RX pin of the second device, and the RX pin of the first device to the TX pin of the second device. Additionally, it’s crucial to connect the ground pins of both devices to ensure a common electrical reference. <span class="No-Break"><em class="italic">Figur<a id="_idTextAnchor292"/><a id="_idTextAnchor293"/>e 10</em></span><em class="italic">.1</em> shows the connection betw<a id="_idTextAnchor294"/>een two <span class="No-Break">UART devices:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B21914_10_1.jpg" alt="Figure 10.1: The UART interface" width="1210" height="431"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The UART interface</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor295"/>How UART works</h2>
			<p>Data in <a id="_idIndexMarker700"/>UART is transmitted as frames containing a <strong class="bold">start bit</strong>, <strong class="bold">data bits</strong>, an optional <strong class="bold">parity bit</strong>, and <span class="No-Break"><strong class="bold">stop bits</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B21914_10_2.jpg" alt="Figure 10.2: The UART data packet" width="1512" height="225"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: The UART data packet</p>
			<p>Here’s a step-by-step breakdown of <span class="No-Break">the process:</span></p>
			<ol>
				<li><strong class="bold">Start bit</strong>: The transmission line is normally held high. To start the data transfer, the transmitting UART pulls the line low for one clock cycle. This indicates the start of a new <span class="No-Break">data frame.</span></li>
				<li><strong class="bold">Data frame</strong>: Following the start bit, the data frame typically consists of 5 to 9 bits and is sent from<a id="_idIndexMarker701"/> the <strong class="bold">least significant bit</strong> (<strong class="bold">LSB</strong>) to<a id="_idIndexMarker702"/> the <strong class="bold">most significant </strong><span class="No-Break"><strong class="bold">bit</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">MSB</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Parity bit</strong>: This is optional and is used for error checking. It ensures that the number of set bits (1s) in the data is even <span class="No-Break">or odd.</span></li>
				<li><strong class="bold">Stop bits</strong>: This is one or two bits indicating the end of the data packet. The line is driven high during the <span class="No-Break">stop bits.</span></li>
			</ol>
			<p>Let’s take a closer look at the start, stop, and <span class="No-Break">parity bits.</span></p>
			<h3>The start, stop, and parity bits</h3>
			<p>These bits form the backbone of the UART protocol, allowing devices to synchronize and verify the integrity of the <span class="No-Break">transmitted data.</span></p>
			<h4>Start bit</h4>
			<p>The start bit<a id="_idIndexMarker703"/> is the<a id="_idIndexMarker704"/> initial signal that marks the beginning of a data frame in UART communication. When the transmitting device is idle, the data line is held at a high voltage level (logic 1). To signal the start of transmission, the UART transmitter pulls the line to a low voltage level (logic 0) for a 1-bit duration. This transition from high to low alerts the receiving device that a new data packet is incoming, allowing it to<a id="_idIndexMarker705"/> synchronize and prepare for <span class="No-Break">data</span><span class="No-Break"><a id="_idIndexMarker706"/></span><span class="No-Break"> reception.</span></p>
			<h4>Stop bit</h4>
			<p>After the data bits<a id="_idIndexMarker707"/> and optional parity bit are transmitted, the stop bit<a id="_idIndexMarker708"/> signals the end of the data frame. The transmitter drives the data line back to a high voltage level (logic 1) for 1 or 2-bit durations, depending on the configuration. The stop bit(s) ensure that the receiver has time to process the last data bit and prepare for the next start bit. In essence, the stop bit acts as a buffer, providing a clear demarcation between successive data frames and helping maintain synchronization between the <span class="No-Break">communicating devices.</span></p>
			<h4>Parity bit</h4>
			<p>The parity bit<a id="_idIndexMarker709"/> is <a id="_idIndexMarker710"/>an optional feature that’s used for basic error checking in UART communication. It provides a simple method to detect errors that may have occurred during data transmission. The parity bit can be configured for either even or <span class="No-Break">odd parity:</span></p>
			<ul>
				<li><strong class="bold">Even parity</strong>: The parity bit <a id="_idIndexMarker711"/>is set to 0 if the number of 1s in the data frame is even, and set to 1 if the number of 1s is odd. This ensures that the total number of 1s (including the parity bit) <span class="No-Break">is even.</span></li>
				<li><strong class="bold">Odd parity</strong>: The <a id="_idIndexMarker712"/>parity bit is set to 0 if the number of 1s in the data frame is odd, and set to 1 if the number of 1s is even. This ensures that the total number of 1s (including the parity bit) <span class="No-Break">is odd.</span></li>
			</ul>
			<p>When the receiver gets the data frame, it checks the parity bit against the received data bits. If there’s a mismatch, it indicates that an error occurred during transmission. While parity doesn’t correct errors, it helps in identifying them, prompting for retransmission <span class="No-Break">if necessary.</span></p>
			<p>The start, stop, and parity bits are essential components of UART communication, each playing a critical role in ensuring data integrity and synchronization. The start bit signals the beginning of transmission, the stop bit marks the end, and the parity bit provides a basic error-checking mechanism. Together, they create a robust framework for reliable and efficient serial communication <span class="No-Break">between devices.</span></p>
			<p>Before wrapping up this section, let’s take a moment to understand the unit of speed that’s used in <span class="No-Break">UART communication.</span></p>
			<h3>Understanding the baud rate – the speed of communication in embedded systems</h3>
			<p>In the world of embedded<a id="_idIndexMarker713"/> systems, <strong class="bold">baud rate</strong> is a term you’ll encounter frequently. Whether you’re debugging a microcontroller, setting up a serial communication link, or working with various peripherals, understanding the baud rate is essential. But what exactly is the baud rate, and why is it so important? Let’s break <span class="No-Break">it down.</span></p>
			<h4>What is the baud rate?</h4>
			<p>The baud rate is <a id="_idIndexMarker714"/>essentially the speed at which data is transmitted over a communication channel. It’s <a id="_idIndexMarker715"/>measured in <strong class="bold">bits per second</strong> (<strong class="bold">bps</strong>). Think of it as the speed limit on a highway: the higher the baud rate, the more data can travel along the communication path in a given amount <span class="No-Break">of time.</span></p>
			<p>For example, a baud rate of <em class="italic">9,600</em> means <em class="italic">9,600 bits</em> of data are transmitted each <em class="italic">second</em>. In other words, it sets the pace for how fast data packets are sent <span class="No-Break">and received.</span></p>
			<p>However, it’s important to distinguish between the baud rate<a id="_idIndexMarker716"/> and the <strong class="bold">bit rate</strong>. While the baud rate refers to the number of signal changes per second, the bit rate is the number of bits transmitted per second. In simple systems, <em class="italic">each signal change can represent one bit</em>, making the baud rate and bit rate the same. In more complex systems, each signal change can represent multiple bits, resulting in a bit rate higher than the <span class="No-Break">baud rate.</span></p>
			<h4>Why does the baud rate matter?</h4>
			<p>Imagine trying to<a id="_idIndexMarker717"/> have a conversation with someone who speaks at a wildly different speed than you. It would be confusing and inefficient, right? The same principle applies to electronic devices communicating with each other. Both the transmitting and receiving devices need to agree on a common baud rate to understand each other correctly. If they don’t, the data might get lost or garbled, leading to <span class="No-Break">communication errors.</span></p>
			<p>For successful communication, both the sender and receiver must have the same baud rate to synchronize correctly. If one device is set to 9,600 bps and the other to 115,200 bps, the communication will fail, similar to how a conversation fails if one person is speaking too fast or too slow for the other <span class="No-Break">to understand.</span></p>
			<p>There are standard baud rate<a id="_idIndexMarker718"/>s that are commonly used in serial communication. Here are <span class="No-Break">a few:</span></p>
			<ul>
				<li><strong class="bold">300 bps</strong>: Very slow, often used for long-distance communication where bandwidth <span class="No-Break">is limited</span></li>
				<li><strong class="bold">9,600 bps</strong>: A widely used default rate for many devices, <span class="No-Break">including microcontrollers</span></li>
				<li><strong class="bold">19,200 bps</strong>: Faster, often used in more <span class="No-Break">data-intensive applications</span></li>
				<li><strong class="bold">115,200 bps</strong>: High-speed communication, common in applications requiring quick <span class="No-Break">data transfer</span></li>
			</ul>
			<p>This concludes our <a id="_idIndexMarker719"/>overview of the UART protocol. In the next se<a id="_idTextAnchor296"/>ction, we will explore the UART peripheral in the <span class="No-Break">STM32F4 microcontroller.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor297"/>The STM32F4 UART peripheral</h2>
			<p>STM32 microcontrollers<a id="_idIndexMarker720"/> often include several UART peripherals, though the number varies depending on the specific model. The STM32F411 microcontroller has three <span class="No-Break">UART peripherals:</span></p>
			<ul>
				<li><span class="No-Break">USART1</span></li>
				<li><span class="No-Break">USART2</span></li>
				<li><span class="No-Break">USART6</span></li>
			</ul>
			<p class="callout-heading">USART versus UART</p>
			<p class="callout">Our STM32 documentation refers to the UART peripheral as <strong class="bold">USART</strong> because it stands for universal <strong class="bold">synchronous/asynchronous</strong> receiver/transmitter. This name reflects the dual functionality of <span class="No-Break">the peripheral:</span></p>
			<p class="callout"><strong class="bold">Asynchronous mode</strong> (<strong class="bold">UART</strong>): In this<a id="_idIndexMarker721"/> mode, the USART operates as a traditional UART. It transmits and receives data without needing a clock signal, which is typical for standard <span class="No-Break">serial communication.</span></p>
			<p class="callout"><strong class="bold">Synchronous mode</strong> (<strong class="bold">USART</strong>): In this<a id="_idIndexMarker722"/> mode, the USART can also operate with a synchronous clock signal, allowing it to communicate with devices that require a clock line in addition to the <span class="No-Break">data lines.</span></p>
			<p>Let’s analyze the key<a id="_idIndexMarker723"/> registers of this peripheral, starting with the USART <span class="No-Break">Status Register.</span></p>
			<h3>USART Status Register (USART_SR)</h3>
			<p>The <strong class="source-inline">USART_SR</strong> register is <a id="_idIndexMarker724"/>one of the main<a id="_idIndexMarker725"/> registers used to monitor the status of the UART peripheral. It provides real-time information about various operational flags <span class="No-Break">and errors.</span></p>
			<p>Let’s consider the key bits in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">Transmit data register empty</strong> (<strong class="bold">TXE</strong>): This <a id="_idIndexMarker726"/>bit is set when the data register <a id="_idIndexMarker727"/>is empty and ready for new data to be written. It indicates that the transmitter can send <span class="No-Break">more data.</span></li>
				<li><strong class="bold">Read data register not empty</strong> (<strong class="bold">RXNE</strong>): This<a id="_idIndexMarker728"/> bit indicates that the data<a id="_idIndexMarker729"/> register contains data that has not been read yet. It signals that there is incoming data to <span class="No-Break">be processed.</span></li>
				<li><strong class="bold">Transmission complete</strong> (<strong class="bold">TC</strong>): This bit is<a id="_idIndexMarker730"/> set when the last transmission has <a id="_idIndexMarker731"/>been completed, including all the stop bits. It shows that the data has been <span class="No-Break">fully sent.</span></li>
				<li><strong class="bold">Overrun error</strong> (<strong class="bold">ORE</strong>): This bit <a id="_idIndexMarker732"/>indicates that the data was lost beca<a id="_idTextAnchor298"/>use the data <a id="_idIndexMarker733"/>register wasn’t read before new data arrived. It flags an <span class="No-Break">error condition.</span></li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 547</em> of the <em class="italic">STM32F411 reference manual (RM0383)</em>. Next, we have the <strong class="bold">USART Data </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">USART_DR</strong></span><span class="No-Break">).</span></p>
			<h3>USART Data Register (USART_DR)</h3>
			<p>The <strong class="source-inline">USART_DR</strong> register is<a id="_idIndexMarker734"/> used for both transmitting<a id="_idIndexMarker735"/> and receiving data. It acts as the primary interface for data exchange through the <span class="No-Break">UART peripheral.</span></p>
			<p>The following are the key functions in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">Transmitting data</strong>: Writing <a id="_idIndexMarker736"/>a byte to <strong class="source-inline">USART_DR</strong> sends the data through the TX line. The UART peripheral handles the conversion and <span class="No-Break">transmission serially.</span></li>
				<li><strong class="bold">Receiving data</strong>: Reading from <strong class="source-inline">USART_DR</strong> retrieves the data received on the RX line. This should be done promptly to avoid <span class="No-Break">data overrun.</span></li>
			</ul>
			<p>Next, we have the <strong class="bold">USART Baud Rate </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">USART_BRR</strong></span><span class="No-Break">).</span></p>
			<h3>USART Baud Rate Register (USART_BRR)</h3>
			<p>The <strong class="source-inline">USART_BRR</strong> register is <a id="_idIndexMarker737"/>used to set the baud <a id="_idIndexMarker738"/>rate for the UART communication, which is critical for synchronizing the data transfer speed <span class="No-Break">between devices.</span></p>
			<p>This register has <span class="No-Break">two fields:</span></p>
			<ul>
				<li><strong class="bold">Mantissa</strong>: The integer<a id="_idIndexMarker739"/> part of the division factor that sets the <span class="No-Break">baud rate</span></li>
				<li><strong class="bold">Fraction</strong>: The<a id="_idIndexMarker740"/> fractional part of the division factor that fine-tunes the <span class="No-Break">baud rate</span></li>
			</ul>
			<p>The final register we will examine is the <strong class="bold">USART Control Register </strong><span class="No-Break"><strong class="bold">1</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">USART_CR1</strong></span><span class="No-Break">).</span></p>
			<h3>USART Control Register 1 (USART_CR1)</h3>
			<p>The <strong class="source-inline">USART_CR1</strong> register <a id="_idIndexMarker741"/>i<a id="_idTextAnchor299"/>s<a id="_idIndexMarker742"/> a comprehensive control register that enables various UART functionalities <span class="No-Break">and configurations.</span></p>
			<p>Let’s consider the key bits in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">USART enable</strong> (<strong class="bold">UE</strong>): This bit enables or disables the UART peripheral. It must<a id="_idIndexMarker743"/> be set to activate <span class="No-Break">UART communication.</span></li>
				<li><strong class="bold">Word length</strong> (<strong class="bold">M</strong>): This bit configures the word length, allowing 8-bit or 9-bit<a id="_idIndexMarker744"/> <span class="No-Break">data frames.</span></li>
				<li><strong class="bold">Parity control enable</strong> (<strong class="bold">PCE</strong>): This bit enables parity checking for <a id="_idIndexMarker745"/><span class="No-Break">error detection.</span></li>
				<li><strong class="bold">Parity selection</strong> (<strong class="bold">PS</strong>): This bit selects <a id="_idIndexMarker746"/>even or <span class="No-Break">odd parity.</span></li>
				<li><strong class="bold">Transmitter enable</strong> (<strong class="bold">TE</strong>): This bit enables the transmitter, allowing data to <a id="_idIndexMarker747"/><span class="No-Break">be sent.</span></li>
				<li><strong class="bold">Receiver enable</strong> (<strong class="bold">RE</strong>): This bit enables the receiver, allowing data to <span class="No-Break">be </span><span class="No-Break"><a id="_idIndexMarker748"/></span><span class="No-Break">received.</span></li>
			</ul>
			<p>With these registers in mind, we’re now ready to develop the UART driver. We will dive into that in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor300"/>Developing the UART driver</h1>
			<p>In this section, we <a id="_idIndexMarker749"/>will apply everything we’ve learned about the UART peripheral to develop a driver for transmitting data using the <span class="No-Break"><strong class="source-inline">USART2</strong></span><span class="No-Break"> peripheral.</span></p>
			<p>Let’s begin by identifying the GPIO pins connected to the UART2 peripheral. To do this, refer to the table on <em class="italic">page 39</em> of the <em class="italic">STM32F411RE datasheet</em>. This table lists all the GPIO pins of the microcontroller, along with their descriptions and additional functionalities. As shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.3</em>, part of this table reveals that PA1 has an alternate function labeled <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">USART2_TX</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B21914_10_3.jpg" alt="Figure 10.3: The USART2_TX pin" width="1245" height="232"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: The USART2_TX pin</p>
			<p>To use PA2 as the <strong class="source-inline">USART2_TX</strong> line, we need to configure <strong class="source-inline">PA2</strong> as an alternate function pin in the <strong class="source-inline">GPIOA_MODER</strong> register and then specify the alternate function number for <strong class="source-inline">USART2_TX</strong> in the <strong class="source-inline">GPIOA_AFRL</strong> register. The STM32F4 microcontroller allows us to choose from 16 different alternate functions, numbered from <strong class="source-inline">AF00</strong> to <strong class="source-inline">AF15</strong>. The alternate function mapping table, which you can find on <em class="italic">page 47</em> of the datasheet, outlines these functions and their corresponding numbers. As shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em>, sourced from the datasheet, configuring <strong class="source-inline">PA2</strong> as <strong class="source-inline">AF07</strong> will set it to function as the <span class="No-Break"><strong class="source-inline">USART2_TX</strong></span><span class="No-Break"> line:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B21914_10_4.jpg" alt="Figure 10.4: PA2 alternate function" width="1516" height="344"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: P<a id="_idTextAnchor301"/>A2 alternate function</p>
			<p>We now have all<a id="_idIndexMarker750"/> the information we need to develop the UART2 <span class="No-Break">transmitter driver.</span></p>
			<p>Create a copy of your previous project and rename it <strong class="source-inline">UART</strong>. Next, create a new file named <strong class="source-inline">uart.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">uart.h</strong> in the <strong class="source-inline">Inc</strong> folder. Populate your <strong class="source-inline">uart.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#define</strong> GPIOAEN        (1U&lt;&lt;0)
<strong class="bold">#define</strong> UART2EN        (1U&lt;&lt;17)
<strong class="bold">#define</strong> DBG_UART_BAUDRATE        115200
<strong class="bold">#define</strong> SYS_FREQ                16000000
<strong class="bold">#define</strong> APB1_CLK                SYS_FREQ
<strong class="bold">#define</strong> CR1_TE                (1U&lt;&lt;3)
<strong class="bold">#define</strong> CR1_UE                (1U&lt;&lt;13)
<strong class="bold">#define</strong> SR_TXE                (1U&lt;&lt;7)
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk,uint32_t baudrate);
<strong class="bold">static void uart_write</strong>(<strong class="bold">int</strong> ch);
<strong class="bold">int __io_putchar</strong>(<strong class="bold">int</strong> ch)
{
    uart_write(ch);
    <strong class="bold">return</strong> ch;
}
<strong class="bold">void uart_init</strong>(<strong class="bold">void</strong>)
{
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set the mode of PA2 to alternate function mode*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;4);
    GPIOA-&gt;MODER |=(1U&lt;&lt;5);
    /*Set alternate function type to AF7(UART2_TX)*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;8);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;9);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;10);
    GPIOA-&gt;AFR[0] &amp;=~(1U&lt;&lt;11);
    /*Enable clock access to UART2*/
     RCC-&gt;APB1ENR |=    UART2EN;
    /*Configure <strong class="bold">uart</strong> <strong class="bold">baudrate</strong>*/
      uart_set_baudrate(APB1_CLK,DBG_UART_BAUDRATE);
    /*Configure transfer direction*/
     USART2-&gt;CR1 = CR1_TE;
    /*Enable UART Module*/
     USART2-&gt;CR1 |= CR1_UE;
}
<strong class="bold">static void uart_write</strong>(<strong class="bold">int</strong> ch)
{
    /*Make sure transmit data register is empty*/
    <strong class="bold">while</strong>(!(USART2-&gt;SR &amp; SR_TXE)){}
    /*Write to transmit data register*/
    USART2-&gt;DR =(ch &amp; 0xFF);
}
<strong class="bold">static</strong> uint16_t <strong class="bold">compute_uart_bd</strong>(uint32_t periph_clk,uint32_t baudrate)
{
    <strong class="bold">return</strong>((periph_clk + (baudrate/2U))/baudrate);
}
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk,uint32_t baudrate)
{
    USART2-&gt;BRR = compute_uart_bd(periph_clk,baudrate);
}</pre>			<p>Let’s break <span class="No-Break">it down.</span></p>
			<p>First, we have<a id="_idIndexMarker751"/> the necessary includes <span class="No-Break">and macros.</span></p>
			<pre class="source-code">
#include &lt;stdint.h&gt;
#include "uart.h"
#define GPIOAEN (1U&lt;&lt;0)
#define UART2EN (1U&lt;&lt;17)
#define DBG_UART_BAUDRATE 115200
#define SYS_FREQ 16000000
#define APB1_CLK SYS_FREQ
#define CR1_TE (1U&lt;&lt;3)
#define CR1_UE (1U&lt;&lt;13)
#define SR_TXE (1U&lt;&lt;7)</pre>			<p>Here are the uses of <span class="No-Break">the macros:</span></p>
			<ul>
				<li><strong class="source-inline">GPIOAEN</strong>: This macro enables the clock for GPIOA by setting bit 0 in the <span class="No-Break"><strong class="source-inline">AHB1ENR</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="source-inline">UART2EN</strong>: This macro enables the clock for UART2 by setting bit 17 in the <span class="No-Break"><strong class="source-inline">APB1ENR</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="source-inline">DBG_UART_BAUDRATE</strong>: This macro defines the baud rate for UART communication, set to <span class="No-Break"><strong class="source-inline">115200</strong></span><span class="No-Break"> bps.</span></li>
				<li><strong class="source-inline">SYS_FREQ</strong>: This macro defines the system frequency, set to 16 MHz, and the default frequency of the STM32F411 microcontroller on the NUCLEO <span class="No-Break">development board.</span></li>
				<li><strong class="source-inline">APB1_CLK</strong>: This macro sets the APB1 peripheral clock frequency to the system frequency (<span class="No-Break">16 MHz).</span></li>
				<li><strong class="source-inline">CR1_TE</strong>: This macro enables the transmitter by setting bit 3 in the <span class="No-Break"><strong class="source-inline">USART_CR1</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="source-inline">CR1_UE</strong>: This macro enables the UART module by setting bit 13 in the <span class="No-Break"><strong class="source-inline">USART_CR1</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="source-inline">SR_TXE</strong>: This macro represents the TXE bit in the <span class="No-Break"><strong class="source-inline">USART_SR</strong></span><span class="No-Break"> register.</span></li>
			</ul>
			<p>Next, we have the helper<a id="_idIndexMarker752"/> functions for computing and setting the <span class="No-Break">baud rate:</span></p>
			<pre class="source-code">
static uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate)
{
    return ((periph_clk + (baudrate / 2U)) / baudrate);
}</pre>			<p>This helper function calculates the baud rate divisor. It uses the peripheral clock and desired baud rate to compute the value to be set in <a id="_idIndexMarker753"/>the <strong class="bold">Baud Rate </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">BRR</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
static void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate)
{
    USART2-&gt;BRR = compute_uart_bd(periph_clk, baudrate);
}</pre>			<p>This function sets the baud rate for UART2 by writing the computed divisor to the BRR. Let’s turn our focus to the <span class="No-Break">initialization function:</span></p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOAEN;</pre>			<p>This line enables the clock for GPIOA by setting the appropriate bit in the AHB1 peripheral clock <span class="No-Break">enable register:</span></p>
			<pre class="source-code">
GPIOA-&gt;MODER &amp;= ~(1U &lt;&lt; 4);
GPIOA-&gt;MODER |= (1U &lt;&lt; 5);</pre>			<p>These lines configure pin PA2 to operate in alternate function mode, which is necessary for <span class="No-Break">UART functionality:</span></p>
			<pre class="source-code">
GPIOA-&gt;AFR[0] |= (1U &lt;&lt; 8);
GPIOA-&gt;AFR[0] |= (1U &lt;&lt; 9);
GPIOA-&gt;AFR[0] |= (1U &lt;&lt; 10);
GPIOA-&gt;AFR[0] &amp;= ~(1U &lt;&lt; 11);</pre>			<p>These lines configure<a id="_idIndexMarker754"/> PA2 as an alternate function (<strong class="source-inline">AF7</strong>), which corresponds <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">UART2_TX</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
 RCC-&gt;APB1ENR |= UART2EN;</pre>			<p>This line enables the clock for UART2 by setting the appropriate bit in the APB1 peripheral clock <span class="No-Break">enable register:</span></p>
			<pre class="source-code">
uart_set_baudrate(APB1_CLK, DBG_UART_BAUDRATE);</pre>			<p>This function call sets the baud rate for UART2 using the <span class="No-Break"><strong class="source-inline">uart_set_baudrate()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
USART2-&gt;CR1 = CR1_TE;</pre>			<p>This configures UART2 for transmission by setting the transmitter enable bit in the <span class="No-Break">control register:</span></p>
			<pre class="source-code">
USART2-&gt;CR1 |= CR1_UE;</pre>			<p>This enables the UART2 module by setting the UART enable bit in the <span class="No-Break">control register.</span></p>
			<p>Next, we have the function for writing <span class="No-Break">to UART:</span></p>
			<pre class="source-code">
static void uart_write(int ch)
{
    /* Make sure transmit data register is empty */
    while (!(USART2-&gt;SR &amp; SR_TXE)) {}
    /* Write to transmit data register */
    USART2-&gt;DR = (ch &amp; 0xFF);
}</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<pre class="source-code">
while (!(USART2-&gt;SR &amp; SR_TXE)) {}</pre>			<p>This loop ensures that the transmit data register is empty before we write <span class="No-Break">new data:</span></p>
			<pre class="source-code">
USART2-&gt;DR = (ch &amp; 0xFF);</pre>			<p>This line writes the <a id="_idIndexMarker755"/>character to the data register <span class="No-Break">for transmission.</span></p>
			<p>Finally, we have a useful function that allows us to redirect <strong class="source-inline">printf</strong> output to our <span class="No-Break">UART transmitter:</span></p>
			<pre class="source-code">
int __io_putchar(int ch)
{
    uart_write(ch);
    return ch;
}</pre>			<p>It calls <strong class="source-inline">uart_write()</strong> to send the character and then returns <span class="No-Break">the character.</span></p>
			<p>After sending the character, <strong class="source-inline">__io_putchar</strong> returns the same <span class="No-Break">character, </span><span class="No-Break"><strong class="source-inline">ch</strong></span><span class="No-Break">.</span></p>
			<p>Returning the character is a standard practice, allowing the function to comply with the typical <strong class="source-inline">putchar</strong> function signature, which returns the character written as an <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> variable.</span></p>
			<p>Our next task is to populate the <strong class="source-inline">uart.h</strong> file. Here’s <span class="No-Break">the code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> __UART_H__
<strong class="bold">#define</strong> __UART_H__
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void uart_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">#endif</strong></pre>			<p>Here, we are simply exposing the uart initialization function implemented in <strong class="source-inline">uart.c</strong>, making it callable from other files. We are now ready to test our driver in <strong class="source-inline">main.c</strong>. Update your <strong class="source-inline">main.c</strong> file, <span class="No-Break">like </span><span class="No-Break"><a id="_idIndexMarker756"/></span><span class="No-Break">so:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    <strong class="bold">while</strong>(1)
    {
        <strong class="bold">printf</strong>("Hello from STM32...\r\n");
    }
}</pre>			<p>This main function simply initializes the UART2 peripheral and then continuously prints the sentence <strong class="source-inline">Hello </strong><span class="No-Break"><strong class="source-inline">from STM32…</strong></span><span class="No-Break">.</span></p>
			<p>Let’s test the project. To do so, we’ll need to install a program on our computer that can display the data that’s received through the computer’s serial port. In this setup, our development board acts as the transmitter, while the computer is <span class="No-Break">the receiver.</span></p>
			<ol>
				<li><strong class="bold">Install a serial </strong><span class="No-Break"><strong class="bold">terminal program</strong></span><span class="No-Break">:</span><ul><li>Choose a serial terminal program that’s appropriate for your operating system. Options include <em class="italic">Realterm</em>, <em class="italic">Tera Term</em>, <em class="italic">Hercules</em>, and <span class="No-Break"><em class="italic">Cool Term</em></span><span class="No-Break">.</span></li><li>If you’re using Windows, I recommend Realterm. You can download it from <span class="No-Break">SourceForge: </span><a href="https://sourceforge.net/projects/realterm/"><span class="No-Break">https://sourceforge.net/projects/realterm/</span></a><span class="No-Break">.</span></li><li>Follow the installation wizard to complete <span class="No-Break">the setup.</span></li></ul></li>
				<li><strong class="bold">Prepare to identify your development board’s </strong><span class="No-Break"><strong class="bold">serial port</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Disconnect your development board from <span class="No-Break">your computer.</span></li><li class="upper-roman">Open Realterm and navigate to the <span class="No-Break"><strong class="bold">Port</strong></span><span class="No-Break"> tab.</span></li><li class="upper-roman">Click on the <strong class="bold">Port</strong> drop-down<a id="_idIndexMarker757"/> menu; you’ll see a list of available ports. Since your development board is currently disconnected, its port won’t appear in the list. <strong class="bold">Take note</strong> of the <span class="No-Break">listed ports.</span></li></ol></li>
				<li><strong class="bold">Identify the development </strong><span class="No-Break"><strong class="bold">board’s port</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Close Realterm and connect your development board to <span class="No-Break">the computer.</span></li><li class="upper-roman">Reopen Realterm and go back to the <strong class="bold">Port</strong> drop-down menu. You should now see a new port in the list, which corresponds to your <span class="No-Break">development board.</span></li><li class="upper-roman">Select this newly <span class="No-Break">added port.</span></li></ol></li>
				<li><strong class="bold">Set the </strong><span class="No-Break"><strong class="bold">baud rate</strong></span><span class="No-Break">:</span><p class="list-inset">Click the <strong class="bold">Baud</strong> drop-down menu and select <strong class="bold">115200</strong>. This is the baud rate we configured in <span class="No-Break">our driver.</span></p></li>
				<li><strong class="bold">Build and run </strong><span class="No-Break"><strong class="bold">the project</strong></span><span class="No-Break">:</span><p class="list-inset">Return to your IDE, build the project, and run the firmware on <span class="No-Break">your microcontroller.</span></p></li>
				<li><strong class="bold">Test </strong><span class="No-Break"><strong class="bold">the setup</strong></span><span class="No-Break">:</span><ul><li>Go back to Realterm and click the <strong class="bold">Open</strong> button to start <span class="No-Break">the communication.</span></li><li>You should see a message stating <strong class="source-inline">Hello from STM32…</strong> continuously being printed in the <span class="No-Break">Terminal window.</span></li></ul></li>
			</ol>
			<p><span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">0</em></span><em class="italic">.5</em> shows the settings<a id="_idIndexMarker758"/> described <span class="No-Break">for Realterm:</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B21914_10_5.jpg" alt="Figure 10.5: Realterm settings" width="1248" height="809"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Realterm settings</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor302"/>Summary</h1>
			<p>In this chapter, we learned about the UART protocol, a fundamental communication method that’s widely used in embedded systems. We began by discussing the importance of communication protocols in embedded systems, emphasizing how UART, alongside SPI and I2C, facilitates seamless communication between microcontrollers and <span class="No-Break">peripheral devices.</span></p>
			<p>Next, we provided a detailed overview of the UART protocol while covering its operational principles, including how data is transmitted asynchronously using start and stop bits, and the role of parity in error checking. We also discussed how the baud rate, a critical aspect of UART communication, is configured to ensure synchronized data transfer <span class="No-Break">between devices.</span></p>
			<p>Then, we delved into the specifics of the STM32 UART peripheral, examining key registers such as the Status Register (<strong class="source-inline">USART_SR</strong>), Data Register (<strong class="source-inline">USART_DR</strong>), Baud Rate Register (<strong class="source-inline">USART_BRR</strong>), and Control Register 1 (<strong class="source-inline">USART_CR1</strong>). Understanding these registers is essential for configuring UART for effective communication in <span class="No-Break">STM32 microcontrollers.</span></p>
			<p>Finally, we applied our theoretical understanding by developing a bare-metal UART driver for the STM32F4 microcontroller. This involved initializing the UART peripheral, setting the baud rate, and implementing functions for transmitting data. We also demonstrated how to redirect <strong class="source-inline">printf</strong> output to the UART, enabling easy debugging and data logging through a <span class="No-Break">serial terminal.</span></p>
			<p>In the next chapter, we will learn about the <strong class="bold">analog-to-digital </strong><span class="No-Break"><strong class="bold">converter</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ADC</strong></span><span class="No-Break">).</span></p>
		</div>
	</div>
</div>
</body></html>