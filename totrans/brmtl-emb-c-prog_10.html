<html><head></head><body>
<div><div><div><h1 id="_idParaDest-159" class="chapter-number"><a id="_idTextAnchor278"/>10</h1>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor279"/>The Universal Asynchronous Receiver/Transmitter Protocol</h1>
			<p>In this chapter, we will learn about the <strong class="bold">universal asynchronous receiver/transmitter</strong> (<strong class="bold">UART</strong>) protocol, an important communication method widely used in <a id="_idIndexMarker643"/>embedded systems. UART is fundamental for enabling communication between microcontrollers and various peripherals, making it an essential component in embedded systems development.</p>
			<p>We will start by discussing the significance of communication protocols in embedded systems and highlight common use cases for UART alongside other protocols such as SPI and I2C. Following this, we will provide a comprehensive overview of the UART protocol, detailing its operational principles and features. Next, we will extract and examine the relevant registers for UART from the STM32 reference manual, providing the necessary foundational knowledge for driver development. Finally, we will apply this knowledge to develop a bare-metal UART driver, illustrating the practical aspects of initializing and transmitting data via UART.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Introduction to communication protocols<a id="_idTextAnchor280"/></li>
				<li>Overview of the UART protocol</li>
				<li>The STM32F4 UART peripheral</li>
				<li>Developing the UART driver</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the UART protocol and the skills needed to develop bare-metal drivers for UART communication.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor281"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor282"/>Introduction to communication protocols</h1>
			<p>In the world of <a id="_idIndexMarker644"/>embedded systems, communication protocols are essential conduits that enable microcontrollers and peripheral devices to talk to each other seamlessly. Think of them as the languages that different devices use to understand and exchange information, ensuring that everything from your smartphone to your smart home devices works smoothly.</p>
			<p>Let’s dive into what communication protocols are, how they are grouped, their unique features and advantages, and explore some common use cases to see these protocols in action.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor283"/>What are communication protocols?</h2>
			<p>Communication protocols are sets of rules and conventions that allow electronic devices to communicate with each other. These protocols define how data is formatted, transmitted, and received, ensuring that devices can exchange information accurately and reliably. Without these protocols, it would be like trying to have a conversation with someone who speaks a completely different language – communication would be chaotic and error-prone.</p>
			<p>In embedded systems, these protocols are crucial because they facilitate the interaction between microcontrollers and peripherals such as sensors, actuators, displays, and other microcontrollers. Whether it’s sending a simple temperature reading from a sensor to a microcontroller or streaming video data from a camera module, communication protocols make it happen.</p>
			<p>Let’s analyze the classification of communication protocols, starting with the big picture: what communication protocols can be broadly classified into – <strong class="bold">serial</strong> and <strong class="bold">parallel</strong> communication.</p>
			<h3>Serial versus parallel communication</h3>
			<p>Let’s start<a id="_idIndexMarker645"/> with serial<a id="_idIndexMarker646"/> communication.</p>
			<h4>Serial communication</h4>
			<p>In this category, communication<a id="_idIndexMarker647"/> protocols can be further broken down into asynchronous and synchronous protocols:</p>
			<ul>
				<li><strong class="bold">Asynchronous</strong>: This type of <a id="_idIndexMarker648"/>communication <a id="_idIndexMarker649"/>sends data one bit at a time without a clock signal to synchronize the sender and receiver. Think of it as sending letters through the mail without a scheduled delivery time. A common example is UART, which is simple and efficient for many applications.</li>
				<li> <strong class="bold">Synchronous</strong>: Unlike<a id="_idIndexMarker650"/> asynchronous<a id="_idIndexMarker651"/> communication, this form of communication uses a clock signal to coordinate the transmission of bits. It’s like having a drumbeat to ensure everyone <a id="_idIndexMarker652"/>marches in step. Examples include <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) and <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>). These <a id="_idIndexMarker653"/>protocols ensure data integrity and timing, making them suitable for more complex tasks.</li>
			</ul>
			<h4>Parallel communication</h4>
			<p>This type involves<a id="_idIndexMarker654"/> transmitting multiple bits simultaneously over multiple channels. Imagine sending a whole fleet of cars instead of a single one – it’s faster but requires more lanes (or pins, in our case). While parallel communication is faster, it’s less common in embedded systems due to the higher pin count. Also, it’s prone to crosstalk and signal integrity problems, especially over longer distances.</p>
			<p>We can also classify communication protocols based on their architecture. In this classification system, we have point-to-point communication and multi-device communication.</p>
			<h3>Point-to-point versus multi-device communication</h3>
			<p>Let’s look<a id="_idIndexMarker655"/> at <a id="_idIndexMarker656"/>the differences.</p>
			<h4>Point-to-point</h4>
			<p>This is a direct line<a id="_idIndexMarker657"/> of communication between two devices. <strong class="bold">UART</strong> is a<a id="_idIndexMarker658"/> classic example, where data flows directly between a microcontroller and a peripheral device. It’s straightforward, reliable, and ideal for many embedded systems.</p>
			<h4>Multi-device (bus) communication</h4>
			<p>Here, multiple devices<a id="_idIndexMarker659"/> share the same communication lines, which can be either of the following:</p>
			<ul>
				<li><strong class="bold">Multi-master</strong>: Multiple <a id="_idIndexMarker660"/>devices can control the communication bus. <strong class="bold">I2C</strong> is a great example as it allows multiple masters and slaves on the same <a id="_idIndexMarker661"/>bus. It’s like a group of friends taking turns talking in a conversation.</li>
				<li><strong class="bold">Master-slave</strong>: One<a id="_idIndexMarker662"/> master device controls the communication, directing traffic to and from multiple slave devices. <strong class="bold">SPI</strong> operates<a id="_idIndexMarker663"/> this way, with a single master communicating with multiple slaves through dedicated lines. <strong class="bold">I2C</strong> can also operate this way. It’s akin to a teacher (master) calling on students one at a time to speak.</li>
			</ul>
			<p>Lastly, communication protocols can be classified based on their data flow capabilities.</p>
			<h3>Full-duplex versus half-duplex</h3>
			<p>Let’s see the differences between full-duplex and half-duplex:</p>
			<ul>
				<li><strong class="bold">Full-duplex</strong>: This allows<a id="_idIndexMarker664"/> simultaneous two-way communication. Imagine a two-lane road where cars can travel in both directions at the same <a id="_idIndexMarker665"/>time. <strong class="bold">UART</strong> and <strong class="bold">SPI</strong> support<a id="_idIndexMarker666"/> full-duplex communication, making them highly efficient for real-time data exchange.</li>
				<li><strong class="bold">Half-duplex</strong>: Here, communication can occur in both directions, but not at the same time – it’s like a single-lane road where cars must take<a id="_idIndexMarker667"/> turns. <strong class="bold">I2C</strong> typically operates in half-duplex<a id="_idIndexMarker668"/> mode, which works well for its intended applications but can be a limitation in high-speed data scenarios.</li>
			</ul>
			<p>Now, let’s closely compare the three common communication protocols that are used in modern embedded systems.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor284"/>Comparing UART, SPI, and I2C</h2>
			<p>Let’s start with UART.</p>
			<h3>UART</h3>
			<p>Here are some key features<a id="_idIndexMarker669"/> of UART:</p>
			<ul>
				<li><strong class="bold">Asynchronous communication</strong>: UART doesn’t require a clock signal. Instead, it uses start and stop bits to synchronize data transmission.</li>
				<li><strong class="bold">Full-duplex</strong>: UART can send and receive data simultaneously, which is ideal for many applications requiring real-time communication.</li>
				<li><strong class="bold">Simple and cost-effective</strong>: With minimal hardware requirements, UART is easy to implement and cost-effective.</li>
			</ul>
			<p>The following are some of its advantages:</p>
			<ul>
				<li><strong class="bold">Ease of use</strong>: Setting up<a id="_idIndexMarker670"/> UART communication is straightforward, making it a popular choice for beginners and simple applications</li>
				<li><strong class="bold">Wide support</strong>: UART is universally supported by most microcontrollers and peripheral devices</li>
				<li><strong class="bold">Low overhead</strong>: The <a id="_idIndexMarker671"/>lack of a clock signal means fewer pins are used, reducing complexity</li>
			</ul>
			<p>However, it also has some disadvantages:</p>
			<ul>
				<li><strong class="bold">Speed limitations</strong>: UART is<a id="_idIndexMarker672"/> generally slower compared to SPI and I2C, making it less suitable for high-speed data transfer</li>
				<li><strong class="bold">Limited distance</strong>: Susceptibility to noise over long distances can limit the range of reliable communication</li>
				<li><strong class="bold">Point-to-point only</strong>: UART is designed for direct, point-to-point communication, which can be a limitation if multiple devices need to communicate</li>
			</ul>
			<p>Next, we have SPI.</p>
			<h3>SPI</h3>
			<p>Here are some <a id="_idIndexMarker673"/>key features of SPI:</p>
			<ul>
				<li><strong class="bold">Synchronous communication</strong>: SPI uses a clock signal along with data lines, ensuring synchronized data transfer</li>
				<li><strong class="bold">Full-duplex</strong>: It allows data to be sent and received simultaneously</li>
				<li><strong class="bold">Master-slave architecture</strong>: One master device controls multiple slave devices, with dedicated lines for each</li>
			</ul>
			<p>The following are some of its advantages:</p>
			<ul>
				<li><strong class="bold">High speed</strong>: SPI <a id="_idIndexMarker674"/>supports high-speed data transfer, making it ideal for applications requiring fast communication</li>
				<li><strong class="bold">Versatility</strong>: SPI can connect multiple devices with different configurations, providing flexibility <a id="_idIndexMarker675"/>in design</li>
			</ul>
			<p>However, it also has some disadvantages:</p>
			<ul>
				<li><strong class="bold">More pins required</strong>: Each slave <a id="_idIndexMarker676"/>device needs a separate select line, which can increase the pin count significantly</li>
				<li><strong class="bold">No standardized acknowledgment</strong>: Unlike I2C, SPI does not have a built-in acknowledgment mechanism, which can make error detection more challenging</li>
				<li><strong class="bold">Limited multi-master capability</strong>: SPI is not designed for multi-master systems, which<a id="_idIndexMarker677"/> can be a limitation in some scenarios</li>
			</ul>
			<p>The final common communication protocol we’ll cover is I2C.</p>
			<h3>I2C</h3>
			<p>Here are some key<a id="_idIndexMarker678"/> features of I2C:</p>
			<ul>
				<li><strong class="bold">Synchronous communication</strong>: I2C uses a clock signal for synchronized data transfer</li>
				<li><strong class="bold">Multi-master capability</strong>: Multiple master devices can share the same bus, which is useful in more complex systems</li>
				<li><strong class="bold">Two-wire interface</strong>: I2C requires only two lines (SDA and SCL) for communication, minimizing the pin count</li>
			</ul>
			<p>The following are some of its advantages:</p>
			<ul>
				<li><strong class="bold">Simplicity in wiring</strong>: The two-wire<a id="_idIndexMarker679"/> interface reduces the complexity and number of pins required</li>
				<li><strong class="bold">Multi-device support</strong>: I2C easily connects multiple devices on the same bus, each with a unique address</li>
				<li><strong class="bold">Built-in addressing</strong>: I2C has a built-in addressing mechanism, making communication with multiple <a id="_idIndexMarker680"/>devices straightforward</li>
			</ul>
			<p>However, it does have some disadvantages:</p>
			<ul>
				<li><strong class="bold">Slower speed</strong>: I2C is <a id="_idIndexMarker681"/>generally slower than SPI, which can be a limitation for high-speed applications</li>
				<li><strong class="bold">Complex protocol</strong>: The protocol is more complex than UART and SPI, requiring more sophisticated handling of data transfers and addressing</li>
				<li><strong class="bold">Susceptible to noise</strong>: Like UART, I2C can be susceptible to noise over longer distances, potentially <a id="_idIndexMarker682"/>affecting communication reliability</li>
			</ul>
			<p>Choosing the right communication protocol depends on your specific application needs. If you need simple, straightforward communication and can tolerate slower speeds, <strong class="bold">UART</strong> is a great <a id="_idIndexMarker683"/>choice. For high-speed applications with a need for full-duplex communication, <strong class="bold">SPI</strong> is ideal, especially<a id="_idIndexMarker684"/> if you can manage the higher pin count. When you need to connect multiple devices with minimal wiring and have a complex communication setup, <strong class="bold">I2C</strong> is<a id="_idIndexMarker685"/> your go-to protocol. To help you better understand when to choose which protocol, let’s explore some common use cases.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor285"/>Common use cases for the UART, SPI, and I2C protocols</h2>
			<p>When designing embedded systems, selecting the right communication protocol is crucial for ensuring efficient and reliable data exchange. UART, SPI, and I2C each have unique strengths, making them suitable for different applications. Let’s explore the practical use cases and compelling case studies for each protocol, highlighting their professional and real-world relevance.</p>
			<h3>UART</h3>
			<p>Let’s look at some<a id="_idIndexMarker686"/> common use cases for the UART protocol:</p>
			<ul>
				<li><strong class="bold">Serial communication with PCs</strong>: UART is often used for serial communication between microcontrollers and computers, particularly for debugging, firmware updates, and data logging</li>
				<li><strong class="bold">GPS modules</strong>: UART can be used to transmit location data from a GPS module to a microcontroller</li>
				<li><strong class="bold">Bluetooth modules</strong>: UART enables wireless communication with devices via Bluetooth</li>
			</ul>
			<p>These use cases represent<a id="_idIndexMarker687"/> some of the most common applications of UART, but the protocol is versatile and can be used in many other scenarios that require simple serial communication.</p>
			<p class="callout-heading">Case study – GPS module integration for autonomous drones</p>
			<p class="callout">Imagine you’re <a id="_idIndexMarker688"/>developing an autonomous<a id="_idIndexMarker689"/> drone that requires precise navigation to perform tasks such as surveying and mapping. Integrating a GPS module using UART can provide real-time location data essential for navigation.</p>
			<p class="callout"><strong class="bold">Setup</strong>: Connect the GPS module’s transmit (TX) pin to the microcontroller’s receive (RX) pin and vice versa. Configure the baud rate so that it matches the GPS module’s output.</p>
			<p class="callout"><strong class="bold">Operation</strong>: The GPS module continuously sends NMEA sentences (text strings) containing location data. The microcontroller reads these strings via UART, parses them, and uses the location information to navigate the drone accurately.</p>
			<p class="callout"><strong class="bold">Advantage</strong>: UART’s simplicity and widespread support make it straightforward to integrate the GPS module, providing reliable and continuous data flow without a complex setup.</p>
			<p>Next, we’ll look at SPI.</p>
			<h3>SPI</h3>
			<p>The following are <a id="_idIndexMarker690"/>some common use cases for the SPI protocol:</p>
			<ul>
				<li><strong class="bold">High-speed data transfer</strong>: It’s <a id="_idIndexMarker691"/>ideal for<a id="_idIndexMarker692"/> applications such as memory cards, <strong class="bold">analog-to-digital converters</strong> (<strong class="bold">ADCs</strong>), <strong class="bold">digital-to-analog converters</strong> (<strong class="bold">DACs</strong>), and displays</li>
				<li><strong class="bold">Display modules</strong>: SPI can be used for communicating with high-resolution displays requiring fast refresh rates</li>
				<li><strong class="bold">Sensors and actuators</strong>: SPI can handle high-frequency data outputs from various sensors</li>
			</ul>
			<p>Like UART, these examples highlight some typical uses of SPI, but the protocol’s high-speed capabilities make it suitable for a wide range of other applications requiring rapid data transfer.</p>
			<p class="callout-heading">Case study – SD card data logging for industrial equipment</p>
			<p class="callout">Consider an industrial <a id="_idIndexMarker693"/>monitoring system that logs data from various sensors to an SD card for long-term analysis. SPI is the perfect protocol for this high-speed data transfer.</p>
			<p class="callout"><strong class="bold">Setup</strong>: Connect the microcontroller to the SD card using SPI pins (MISO, MOSI, SCLK, and CS). Initialize the SPI bus and configure the SD card.</p>
			<p class="callout"><strong class="bold">Operation</strong>: The microcontroller collects data from sensors (for example, temperature, pressure, and vibration) and writes this data to the SD card in real time.</p>
			<p class="callout"><strong class="bold">Advantage</strong>: SPI’s high-speed data transfer ensures that large amounts of data are logged quickly and efficiently, preventing any data loss and ensuring accurate monitoring.</p>
			<p>Using SPI in this<a id="_idIndexMarker694"/> scenario allows the industrial system to maintain precise logs of critical parameters, which are essential for predictive maintenance and operational efficiency.</p>
			<p>Finally, we have I2C.</p>
			<h3>I2C</h3>
			<p>Let’s consider two<a id="_idIndexMarker695"/> common use cases related to I2C:</p>
			<ul>
				<li><strong class="bold">Multiple sensor integration systems</strong>: This involves connecting several sensors with different addresses on the same I2C bus</li>
				<li><strong class="bold">Peripheral expansion</strong>: This involves adding more GPIO pins to a microcontroller using I2C expanders</li>
			</ul>
			<p>These use cases are just two examples of I2C’s applications. Its ability to support multiple devices on a single bus makes it an excellent choice for many other scenarios where scalability is important.</p>
			<p class="callout-heading">Case study – environmental monitoring system for smart agriculture</p>
			<p class="callout">Let’s say you’re <a id="_idIndexMarker696"/>developing a smart agriculture system that <a id="_idIndexMarker697"/>uses multiple sensors (temperature, humidity, and soil moisture) to optimize farming conditions. I2C is the ideal protocol for this multi-sensor integration.</p>
			<p class="callout"><strong class="bold">Setup</strong>: Connect all sensors to the I2C bus (SDA and SCL lines). Assign each sensor a unique address.</p>
			<p class="callout"><strong class="bold">Operation</strong>: The microcontroller queries each sensor in sequence, collects the data, and processes it to provide insights and control irrigation, ventilation, and lighting systems.</p>
			<p class="callout"><strong class="bold">Advantage</strong>: I2C’s ability to support multiple devices on the same bus with just two lines simplifies wiring, reduces costs, and saves GPIO pins, making it an efficient solution for complex sensor networks.</p>
			<p>Starting with the next section, we’ll focus exclusively on the UART protocol. We’ll cove<a id="_idTextAnchor286"/>r the I2C and SPI protocols in the following chapters.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor287"/>Overview of the UART protocol</h1>
			<p>One of the most fundamental and widely used protocols is UART. Whether you’re debugging hardware or enabling communication between a microcontroller and peripherals, understanding UART is cr<a id="_idTextAnchor288"/>ucial. Let’s delve into the workings of this protocol.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor289"/>What is UART?</h2>
			<p>UART is a hardware<a id="_idIndexMarker698"/> communication protocol that operates using asynchronous serial communication, allowing for adjustable data transmission speeds. The “asynchronous” nature of UART means it doesn’t require a clock signal to align the transmission of bits between the sender and receiver. Instead, both devices must agree on a specific baud rate, which dictates the speed at which<a id="_idTextAnchor290"/> data is exchanged. Let’s take a look at the interface.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor291"/>The interface</h2>
			<p>The UART interface<a id="_idIndexMarker699"/> employs two wires for communication: TX and RX. To establish a connection between two devices, we simply connect the TX pin of the first device to the RX pin of the second device, and the RX pin of the first device to the TX pin of the second device. Additionally, it’s crucial to connect the ground pins of both devices to ensure a common electrical reference. <em class="italic">Figur<a id="_idTextAnchor292"/><a id="_idTextAnchor293"/>e 10</em><em class="italic">.1</em> shows the connection betw<a id="_idTextAnchor294"/>een two UART devices:</p>
			<div><div><img src="img/B21914_10_1.jpg" alt="Figure 10.1: The UART interface" width="1210" height="431"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The UART interface</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor295"/>How UART works</h2>
			<p>Data in <a id="_idIndexMarker700"/>UART is transmitted as frames containing a <strong class="bold">start bit</strong>, <strong class="bold">data bits</strong>, an optional <strong class="bold">parity bit</strong>, and <strong class="bold">stop bits</strong>:</p>
			<div><div><img src="img/B21914_10_2.jpg" alt="Figure 10.2: The UART data packet" width="1512" height="225"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: The UART data packet</p>
			<p>Here’s a step-by-step breakdown of the process:</p>
			<ol>
				<li><strong class="bold">Start bit</strong>: The transmission line is normally held high. To start the data transfer, the transmitting UART pulls the line low for one clock cycle. This indicates the start of a new data frame.</li>
				<li><strong class="bold">Data frame</strong>: Following the start bit, the data frame typically consists of 5 to 9 bits and is sent from<a id="_idIndexMarker701"/> the <strong class="bold">least significant bit</strong> (<strong class="bold">LSB</strong>) to<a id="_idIndexMarker702"/> the <strong class="bold">most significant </strong><strong class="bold">bit</strong> (<strong class="bold">MSB</strong>).</li>
				<li><strong class="bold">Parity bit</strong>: This is optional and is used for error checking. It ensures that the number of set bits (1s) in the data is even or odd.</li>
				<li><strong class="bold">Stop bits</strong>: This is one or two bits indicating the end of the data packet. The line is driven high during the stop bits.</li>
			</ol>
			<p>Let’s take a closer look at the start, stop, and parity bits.</p>
			<h3>The start, stop, and parity bits</h3>
			<p>These bits form the backbone of the UART protocol, allowing devices to synchronize and verify the integrity of the transmitted data.</p>
			<h4>Start bit</h4>
			<p>The start bit<a id="_idIndexMarker703"/> is the<a id="_idIndexMarker704"/> initial signal that marks the beginning of a data frame in UART communication. When the transmitting device is idle, the data line is held at a high voltage level (logic 1). To signal the start of transmission, the UART transmitter pulls the line to a low voltage level (logic 0) for a 1-bit duration. This transition from high to low alerts the receiving device that a new data packet is incoming, allowing it to<a id="_idIndexMarker705"/> synchronize and prepare for data<a id="_idIndexMarker706"/> reception.</p>
			<h4>Stop bit</h4>
			<p>After the data bits<a id="_idIndexMarker707"/> and optional parity bit are transmitted, the stop bit<a id="_idIndexMarker708"/> signals the end of the data frame. The transmitter drives the data line back to a high voltage level (logic 1) for 1 or 2-bit durations, depending on the configuration. The stop bit(s) ensure that the receiver has time to process the last data bit and prepare for the next start bit. In essence, the stop bit acts as a buffer, providing a clear demarcation between successive data frames and helping maintain synchronization between the communicating devices.</p>
			<h4>Parity bit</h4>
			<p>The parity bit<a id="_idIndexMarker709"/> is <a id="_idIndexMarker710"/>an optional feature that’s used for basic error checking in UART communication. It provides a simple method to detect errors that may have occurred during data transmission. The parity bit can be configured for either even or odd parity:</p>
			<ul>
				<li><strong class="bold">Even parity</strong>: The parity bit <a id="_idIndexMarker711"/>is set to 0 if the number of 1s in the data frame is even, and set to 1 if the number of 1s is odd. This ensures that the total number of 1s (including the parity bit) is even.</li>
				<li><strong class="bold">Odd parity</strong>: The <a id="_idIndexMarker712"/>parity bit is set to 0 if the number of 1s in the data frame is odd, and set to 1 if the number of 1s is even. This ensures that the total number of 1s (including the parity bit) is odd.</li>
			</ul>
			<p>When the receiver gets the data frame, it checks the parity bit against the received data bits. If there’s a mismatch, it indicates that an error occurred during transmission. While parity doesn’t correct errors, it helps in identifying them, prompting for retransmission if necessary.</p>
			<p>The start, stop, and parity bits are essential components of UART communication, each playing a critical role in ensuring data integrity and synchronization. The start bit signals the beginning of transmission, the stop bit marks the end, and the parity bit provides a basic error-checking mechanism. Together, they create a robust framework for reliable and efficient serial communication between devices.</p>
			<p>Before wrapping up this section, let’s take a moment to understand the unit of speed that’s used in UART communication.</p>
			<h3>Understanding the baud rate – the speed of communication in embedded systems</h3>
			<p>In the world of embedded<a id="_idIndexMarker713"/> systems, <strong class="bold">baud rate</strong> is a term you’ll encounter frequently. Whether you’re debugging a microcontroller, setting up a serial communication link, or working with various peripherals, understanding the baud rate is essential. But what exactly is the baud rate, and why is it so important? Let’s break it down.</p>
			<h4>What is the baud rate?</h4>
			<p>The baud rate is <a id="_idIndexMarker714"/>essentially the speed at which data is transmitted over a communication channel. It’s <a id="_idIndexMarker715"/>measured in <strong class="bold">bits per second</strong> (<strong class="bold">bps</strong>). Think of it as the speed limit on a highway: the higher the baud rate, the more data can travel along the communication path in a given amount of time.</p>
			<p>For example, a baud rate of <em class="italic">9,600</em> means <em class="italic">9,600 bits</em> of data are transmitted each <em class="italic">second</em>. In other words, it sets the pace for how fast data packets are sent and received.</p>
			<p>However, it’s important to distinguish between the baud rate<a id="_idIndexMarker716"/> and the <strong class="bold">bit rate</strong>. While the baud rate refers to the number of signal changes per second, the bit rate is the number of bits transmitted per second. In simple systems, <em class="italic">each signal change can represent one bit</em>, making the baud rate and bit rate the same. In more complex systems, each signal change can represent multiple bits, resulting in a bit rate higher than the baud rate.</p>
			<h4>Why does the baud rate matter?</h4>
			<p>Imagine trying to<a id="_idIndexMarker717"/> have a conversation with someone who speaks at a wildly different speed than you. It would be confusing and inefficient, right? The same principle applies to electronic devices communicating with each other. Both the transmitting and receiving devices need to agree on a common baud rate to understand each other correctly. If they don’t, the data might get lost or garbled, leading to communication errors.</p>
			<p>For successful communication, both the sender and receiver must have the same baud rate to synchronize correctly. If one device is set to 9,600 bps and the other to 115,200 bps, the communication will fail, similar to how a conversation fails if one person is speaking too fast or too slow for the other to understand.</p>
			<p>There are standard baud rate<a id="_idIndexMarker718"/>s that are commonly used in serial communication. Here are a few:</p>
			<ul>
				<li><strong class="bold">300 bps</strong>: Very slow, often used for long-distance communication where bandwidth is limited</li>
				<li><strong class="bold">9,600 bps</strong>: A widely used default rate for many devices, including microcontrollers</li>
				<li><strong class="bold">19,200 bps</strong>: Faster, often used in more data-intensive applications</li>
				<li><strong class="bold">115,200 bps</strong>: High-speed communication, common in applications requiring quick data transfer</li>
			</ul>
			<p>This concludes our <a id="_idIndexMarker719"/>overview of the UART protocol. In the next se<a id="_idTextAnchor296"/>ction, we will explore the UART peripheral in the STM32F4 microcontroller.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor297"/>The STM32F4 UART peripheral</h2>
			<p>STM32 microcontrollers<a id="_idIndexMarker720"/> often include several UART peripherals, though the number varies depending on the specific model. The STM32F411 microcontroller has three UART peripherals:</p>
			<ul>
				<li>USART1</li>
				<li>USART2</li>
				<li>USART6</li>
			</ul>
			<p class="callout-heading">USART versus UART</p>
			<p class="callout">Our STM32 documentation refers to the UART peripheral as <strong class="bold">USART</strong> because it stands for universal <strong class="bold">synchronous/asynchronous</strong> receiver/transmitter. This name reflects the dual functionality of the peripheral:</p>
			<p class="callout"><strong class="bold">Asynchronous mode</strong> (<strong class="bold">UART</strong>): In this<a id="_idIndexMarker721"/> mode, the USART operates as a traditional UART. It transmits and receives data without needing a clock signal, which is typical for standard serial communication.</p>
			<p class="callout"><strong class="bold">Synchronous mode</strong> (<strong class="bold">USART</strong>): In this<a id="_idIndexMarker722"/> mode, the USART can also operate with a synchronous clock signal, allowing it to communicate with devices that require a clock line in addition to the data lines.</p>
			<p>Let’s analyze the key<a id="_idIndexMarker723"/> registers of this peripheral, starting with the USART Status Register.</p>
			<h3>USART Status Register (USART_SR)</h3>
			<p>The <code>USART_SR</code> register is <a id="_idIndexMarker724"/>one of the main<a id="_idIndexMarker725"/> registers used to monitor the status of the UART peripheral. It provides real-time information about various operational flags and errors.</p>
			<p>Let’s consider the key bits in this register:</p>
			<ul>
				<li><strong class="bold">Transmit data register empty</strong> (<strong class="bold">TXE</strong>): This <a id="_idIndexMarker726"/>bit is set when the data register <a id="_idIndexMarker727"/>is empty and ready for new data to be written. It indicates that the transmitter can send more data.</li>
				<li><strong class="bold">Read data register not empty</strong> (<strong class="bold">RXNE</strong>): This<a id="_idIndexMarker728"/> bit indicates that the data<a id="_idIndexMarker729"/> register contains data that has not been read yet. It signals that there is incoming data to be processed.</li>
				<li><strong class="bold">Transmission complete</strong> (<strong class="bold">TC</strong>): This bit is<a id="_idIndexMarker730"/> set when the last transmission has <a id="_idIndexMarker731"/>been completed, including all the stop bits. It shows that the data has been fully sent.</li>
				<li><strong class="bold">Overrun error</strong> (<strong class="bold">ORE</strong>): This bit <a id="_idIndexMarker732"/>indicates that the data was lost beca<a id="_idTextAnchor298"/>use the data <a id="_idIndexMarker733"/>register wasn’t read before new data arrived. It flags an error condition.</li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 547</em> of the <em class="italic">STM32F411 reference manual (RM0383)</em>. Next, we have the <code>USART_DR</code>).</p>
			<h3>USART Data Register (USART_DR)</h3>
			<p>The <code>USART_DR</code> register is<a id="_idIndexMarker734"/> used for both transmitting<a id="_idIndexMarker735"/> and receiving data. It acts as the primary interface for data exchange through the UART peripheral.</p>
			<p>The following are the key functions in this register:</p>
			<ul>
				<li><code>USART_DR</code> sends the data through the TX line. The UART peripheral handles the conversion and transmission serially.</li>
				<li><code>USART_DR</code> retrieves the data received on the RX line. This should be done promptly to avoid data overrun.</li>
			</ul>
			<p>Next, we have the <code>USART_BRR</code>).</p>
			<h3>USART Baud Rate Register (USART_BRR)</h3>
			<p>The <code>USART_BRR</code> register is <a id="_idIndexMarker737"/>used to set the baud <a id="_idIndexMarker738"/>rate for the UART communication, which is critical for synchronizing the data transfer speed between devices.</p>
			<p>This register has two fields:</p>
			<ul>
				<li><strong class="bold">Mantissa</strong>: The integer<a id="_idIndexMarker739"/> part of the division factor that sets the baud rate</li>
				<li><strong class="bold">Fraction</strong>: The<a id="_idIndexMarker740"/> fractional part of the division factor that fine-tunes the baud rate</li>
			</ul>
			<p>The final register we will examine is the <code>USART_CR1</code>).</p>
			<h3>USART Control Register 1 (USART_CR1)</h3>
			<p>The <code>USART_CR1</code> register <a id="_idIndexMarker741"/>i<a id="_idTextAnchor299"/>s<a id="_idIndexMarker742"/> a comprehensive control register that enables various UART functionalities and configurations.</p>
			<p>Let’s consider the key bits in this register:</p>
			<ul>
				<li><strong class="bold">USART enable</strong> (<strong class="bold">UE</strong>): This bit enables or disables the UART peripheral. It must<a id="_idIndexMarker743"/> be set to activate UART communication.</li>
				<li><strong class="bold">Word length</strong> (<strong class="bold">M</strong>): This bit configures the word length, allowing 8-bit or 9-bit<a id="_idIndexMarker744"/> data frames.</li>
				<li><strong class="bold">Parity control enable</strong> (<strong class="bold">PCE</strong>): This bit enables parity checking for <a id="_idIndexMarker745"/>error detection.</li>
				<li><strong class="bold">Parity selection</strong> (<strong class="bold">PS</strong>): This bit selects <a id="_idIndexMarker746"/>even or odd parity.</li>
				<li><strong class="bold">Transmitter enable</strong> (<strong class="bold">TE</strong>): This bit enables the transmitter, allowing data to <a id="_idIndexMarker747"/>be sent.</li>
				<li><strong class="bold">Receiver enable</strong> (<strong class="bold">RE</strong>): This bit enables the receiver, allowing data to be <a id="_idIndexMarker748"/>received.</li>
			</ul>
			<p>With these registers in mind, we’re now ready to develop the UART driver. We will dive into that in the next section.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor300"/>Developing the UART driver</h1>
			<p>In this section, we <a id="_idIndexMarker749"/>will apply everything we’ve learned about the UART peripheral to develop a driver for transmitting data using the <code>USART2</code> peripheral.</p>
			<p>Let’s begin by identifying the GPIO pins connected to the UART2 peripheral. To do this, refer to the table on <em class="italic">page 39</em> of the <em class="italic">STM32F411RE datasheet</em>. This table lists all the GPIO pins of the microcontroller, along with their descriptions and additional functionalities. As shown in <em class="italic">Figure 10</em><em class="italic">.3</em>, part of this table reveals that PA1 has an alternate function labeled as <code>USART2_TX</code>:</p>
			<div><div><img src="img/B21914_10_3.jpg" alt="Figure 10.3: The USART2_TX pin" width="1245" height="232"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: The USART2_TX pin</p>
			<p>To use PA2 as the <code>USART2_TX</code> line, we need to configure <code>PA2</code> as an alternate function pin in the <code>GPIOA_MODER</code> register and then specify the alternate function number for <code>USART2_TX</code> in the <code>GPIOA_AFRL</code> register. The STM32F4 microcontroller allows us to choose from 16 different alternate functions, numbered from <code>AF00</code> to <code>AF15</code>. The alternate function mapping table, which you can find on <em class="italic">page 47</em> of the datasheet, outlines these functions and their corresponding numbers. As shown in <em class="italic">Figure 10</em><em class="italic">.4</em>, sourced from the datasheet, configuring <code>PA2</code> as <code>AF07</code> will set it to function as the <code>USART2_TX</code> line:</p>
			<div><div><img src="img/B21914_10_4.jpg" alt="Figure 10.4: PA2 alternate function" width="1516" height="344"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: P<a id="_idTextAnchor301"/>A2 alternate function</p>
			<p>We now have all<a id="_idIndexMarker750"/> the information we need to develop the UART2 transmitter driver.</p>
			<p>Create a copy of your previous project and rename it <code>UART</code>. Next, create a new file named <code>uart.c</code> in the <code>Src</code> folder and another file named <code>uart.h</code> in the <code>Inc</code> folder. Populate your <code>uart.c</code> file with the following code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#define</strong> GPIOAEN        (1U&lt;&lt;0)
<strong class="bold">#define</strong> UART2EN        (1U&lt;&lt;17)
<strong class="bold">#define</strong> DBG_UART_BAUDRATE        115200
<strong class="bold">#define</strong> SYS_FREQ                16000000
<strong class="bold">#define</strong> APB1_CLK                SYS_FREQ
<strong class="bold">#define</strong> CR1_TE                (1U&lt;&lt;3)
<strong class="bold">#define</strong> CR1_UE                (1U&lt;&lt;13)
<strong class="bold">#define</strong> SR_TXE                (1U&lt;&lt;7)
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk,uint32_t baudrate);
<strong class="bold">static void uart_write</strong>(<strong class="bold">int</strong> ch);
<strong class="bold">int __io_putchar</strong>(<strong class="bold">int</strong> ch)
{
    uart_write(ch);
    <strong class="bold">return</strong> ch;
}
<strong class="bold">void uart_init</strong>(<strong class="bold">void</strong>)
{
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set the mode of PA2 to alternate function mode*/
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;4);
    GPIOA-&gt;MODER |=(1U&lt;&lt;5);
    /*Set alternate function type to AF7(UART2_TX)*/
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;8);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;9);
    GPIOA-&gt;AFR[0] |=(1U&lt;&lt;10);
    GPIOA-&gt;AFR[0] &amp;=~(1U&lt;&lt;11);
    /*Enable clock access to UART2*/
     RCC-&gt;APB1ENR |=    UART2EN;
    /*Configure <strong class="bold">uart</strong> <strong class="bold">baudrate</strong>*/
      uart_set_baudrate(APB1_CLK,DBG_UART_BAUDRATE);
    /*Configure transfer direction*/
     USART2-&gt;CR1 = CR1_TE;
    /*Enable UART Module*/
     USART2-&gt;CR1 |= CR1_UE;
}
<strong class="bold">static void uart_write</strong>(<strong class="bold">int</strong> ch)
{
    /*Make sure transmit data register is empty*/
    <strong class="bold">while</strong>(!(USART2-&gt;SR &amp; SR_TXE)){}
    /*Write to transmit data register*/
    USART2-&gt;DR =(ch &amp; 0xFF);
}
<strong class="bold">static</strong> uint16_t <strong class="bold">compute_uart_bd</strong>(uint32_t periph_clk,uint32_t baudrate)
{
    <strong class="bold">return</strong>((periph_clk + (baudrate/2U))/baudrate);
}
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk,uint32_t baudrate)
{
    USART2-&gt;BRR = compute_uart_bd(periph_clk,baudrate);
}</pre>			<p>Let’s break it down.</p>
			<p>First, we have<a id="_idIndexMarker751"/> the necessary includes and macros.</p>
			<pre class="source-code">
#include &lt;stdint.h&gt;
#include "uart.h"
#define GPIOAEN (1U&lt;&lt;0)
#define UART2EN (1U&lt;&lt;17)
#define DBG_UART_BAUDRATE 115200
#define SYS_FREQ 16000000
#define APB1_CLK SYS_FREQ
#define CR1_TE (1U&lt;&lt;3)
#define CR1_UE (1U&lt;&lt;13)
#define SR_TXE (1U&lt;&lt;7)</pre>			<p>Here are the uses of the macros:</p>
			<ul>
				<li><code>GPIOAEN</code>: This macro enables the clock for GPIOA by setting bit 0 in the <code>AHB1ENR</code> register.</li>
				<li><code>UART2EN</code>: This macro enables the clock for UART2 by setting bit 17 in the <code>APB1ENR</code> register.</li>
				<li><code>DBG_UART_BAUDRATE</code>: This macro defines the baud rate for UART communication, set to <code>115200</code> bps.</li>
				<li><code>SYS_FREQ</code>: This macro defines the system frequency, set to 16 MHz, and the default frequency of the STM32F411 microcontroller on the NUCLEO development board.</li>
				<li><code>APB1_CLK</code>: This macro sets the APB1 peripheral clock frequency to the system frequency (16 MHz).</li>
				<li><code>CR1_TE</code>: This macro enables the transmitter by setting bit 3 in the <code>USART_CR1</code> register.</li>
				<li><code>CR1_UE</code>: This macro enables the UART module by setting bit 13 in the <code>USART_CR1</code> register.</li>
				<li><code>SR_TXE</code>: This macro represents the TXE bit in the <code>USART_SR</code> register.</li>
			</ul>
			<p>Next, we have the helper<a id="_idIndexMarker752"/> functions for computing and setting the baud rate:</p>
			<pre class="source-code">
static uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate)
{
    return ((periph_clk + (baudrate / 2U)) / baudrate);
}</pre>			<p>This helper function calculates the baud rate divisor. It uses the peripheral clock and desired baud rate to compute the value to be set in <a id="_idIndexMarker753"/>the <strong class="bold">Baud Rate </strong><strong class="bold">Register</strong> (<strong class="bold">BRR</strong>):</p>
			<pre class="source-code">
static void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate)
{
    USART2-&gt;BRR = compute_uart_bd(periph_clk, baudrate);
}</pre>			<p>This function sets the baud rate for UART2 by writing the computed divisor to the BRR. Let’s turn our focus to the initialization function:</p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOAEN;</pre>			<p>This line enables the clock for GPIOA by setting the appropriate bit in the AHB1 peripheral clock enable register:</p>
			<pre class="source-code">
GPIOA-&gt;MODER &amp;= ~(1U &lt;&lt; 4);
GPIOA-&gt;MODER |= (1U &lt;&lt; 5);</pre>			<p>These lines configure pin PA2 to operate in alternate function mode, which is necessary for UART functionality:</p>
			<pre class="source-code">
GPIOA-&gt;AFR[0] |= (1U &lt;&lt; 8);
GPIOA-&gt;AFR[0] |= (1U &lt;&lt; 9);
GPIOA-&gt;AFR[0] |= (1U &lt;&lt; 10);
GPIOA-&gt;AFR[0] &amp;= ~(1U &lt;&lt; 11);</pre>			<p>These lines configure<a id="_idIndexMarker754"/> PA2 as an alternate function (<code>AF7</code>), which corresponds to <code>UART2_TX</code>:</p>
			<pre class="source-code">
 RCC-&gt;APB1ENR |= UART2EN;</pre>			<p>This line enables the clock for UART2 by setting the appropriate bit in the APB1 peripheral clock enable register:</p>
			<pre class="source-code">
uart_set_baudrate(APB1_CLK, DBG_UART_BAUDRATE);</pre>			<p>This function call sets the baud rate for UART2 using the <code>uart_set_baudrate()</code> function:</p>
			<pre class="source-code">
USART2-&gt;CR1 = CR1_TE;</pre>			<p>This configures UART2 for transmission by setting the transmitter enable bit in the control register:</p>
			<pre class="source-code">
USART2-&gt;CR1 |= CR1_UE;</pre>			<p>This enables the UART2 module by setting the UART enable bit in the control register.</p>
			<p>Next, we have the function for writing to UART:</p>
			<pre class="source-code">
static void uart_write(int ch)
{
    /* Make sure transmit data register is empty */
    while (!(USART2-&gt;SR &amp; SR_TXE)) {}
    /* Write to transmit data register */
    USART2-&gt;DR = (ch &amp; 0xFF);
}</pre>			<p>Let’s break it down:</p>
			<pre class="source-code">
while (!(USART2-&gt;SR &amp; SR_TXE)) {}</pre>			<p>This loop ensures that the transmit data register is empty before we write new data:</p>
			<pre class="source-code">
USART2-&gt;DR = (ch &amp; 0xFF);</pre>			<p>This line writes the <a id="_idIndexMarker755"/>character to the data register for transmission.</p>
			<p>Finally, we have a useful function that allows us to redirect <code>printf</code> output to our UART transmitter:</p>
			<pre class="source-code">
int __io_putchar(int ch)
{
    uart_write(ch);
    return ch;
}</pre>			<p>It calls <code>uart_write()</code> to send the character and then returns the character.</p>
			<p>After sending the character, <code>__io_putchar</code> returns the same character, <code>ch</code>.</p>
			<p>Returning the character is a standard practice, allowing the function to comply with the typical <code>putchar</code> function signature, which returns the character written as an <code>int</code> variable.</p>
			<p>Our next task is to populate the <code>uart.h</code> file. Here’s the code:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> __UART_H__
<strong class="bold">#define</strong> __UART_H__
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void uart_init</strong>(<strong class="bold">void</strong>);
<code>uart.c</code>, making it callable from other files. We are now ready to test our driver in <code>main.c</code>. Update your <code>main.c</code> file, like <a id="_idIndexMarker756"/>so:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    <strong class="bold">while</strong>(1)
    {
        <strong class="bold">printf</strong>("Hello from STM32...\r\n");
    }
}</pre>			<p>This main function simply initializes the UART2 peripheral and then continuously prints the sentence <code>Hello </code><code>from STM32…</code>.</p>
			<p>Let’s test the project. To do so, we’ll need to install a program on our computer that can display the data that’s received through the computer’s serial port. In this setup, our development board acts as the transmitter, while the computer is the receiver.</p>
			<ol>
				<li><strong class="bold">Install a serial </strong><strong class="bold">terminal program</strong>:<ul><li>Choose a serial terminal program that’s appropriate for your operating system. Options include <em class="italic">Realterm</em>, <em class="italic">Tera Term</em>, <em class="italic">Hercules</em>, and <em class="italic">Cool Term</em>.</li><li>If you’re using Windows, I recommend Realterm. You can download it from SourceForge: <a href="https://sourceforge.net/projects/realterm/">https://sourceforge.net/projects/realterm/</a>.</li><li>Follow the installation wizard to complete the setup.</li></ul></li>
				<li><strong class="bold">Prepare to identify your development board’s </strong><strong class="bold">serial port</strong>:<ol><li class="upper-roman">Disconnect your development board from your computer.</li><li class="upper-roman">Open Realterm and navigate to the <strong class="bold">Port</strong> tab.</li><li class="upper-roman">Click on the <strong class="bold">Port</strong> drop-down<a id="_idIndexMarker757"/> menu; you’ll see a list of available ports. Since your development board is currently disconnected, its port won’t appear in the list. <strong class="bold">Take note</strong> of the listed ports.</li></ol></li>
				<li><strong class="bold">Identify the development </strong><strong class="bold">board’s port</strong>:<ol><li class="upper-roman">Close Realterm and connect your development board to the computer.</li><li class="upper-roman">Reopen Realterm and go back to the <strong class="bold">Port</strong> drop-down menu. You should now see a new port in the list, which corresponds to your development board.</li><li class="upper-roman">Select this newly added port.</li></ol></li>
				<li><strong class="bold">Set the </strong><strong class="bold">baud rate</strong>:<p class="list-inset">Click the <strong class="bold">Baud</strong> drop-down menu and select <strong class="bold">115200</strong>. This is the baud rate we configured in our driver.</p></li>
				<li><strong class="bold">Build and run </strong><strong class="bold">the project</strong>:<p class="list-inset">Return to your IDE, build the project, and run the firmware on your microcontroller.</p></li>
				<li><code>Hello from STM32…</code> continuously being printed in the Terminal window.</li></ul></li>
			</ol>
			<p><em class="italic">Figure 1</em><em class="italic">0</em><em class="italic">.5</em> shows the settings<a id="_idIndexMarker758"/> described for Realterm:</p>
			<div><div><img src="img/B21914_10_5.jpg" alt="Figure 10.5: Realterm settings" width="1248" height="809"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Realterm settings</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor302"/>Summary</h1>
			<p>In this chapter, we learned about the UART protocol, a fundamental communication method that’s widely used in embedded systems. We began by discussing the importance of communication protocols in embedded systems, emphasizing how UART, alongside SPI and I2C, facilitates seamless communication between microcontrollers and peripheral devices.</p>
			<p>Next, we provided a detailed overview of the UART protocol while covering its operational principles, including how data is transmitted asynchronously using start and stop bits, and the role of parity in error checking. We also discussed how the baud rate, a critical aspect of UART communication, is configured to ensure synchronized data transfer between devices.</p>
			<p>Then, we delved into the specifics of the STM32 UART peripheral, examining key registers such as the Status Register (<code>USART_SR</code>), Data Register (<code>USART_DR</code>), Baud Rate Register (<code>USART_BRR</code>), and Control Register 1 (<code>USART_CR1</code>). Understanding these registers is essential for configuring UART for effective communication in STM32 microcontrollers.</p>
			<p>Finally, we applied our theoretical understanding by developing a bare-metal UART driver for the STM32F4 microcontroller. This involved initializing the UART peripheral, setting the baud rate, and implementing functions for transmitting data. We also demonstrated how to redirect <code>printf</code> output to the UART, enabling easy debugging and data logging through a serial terminal.</p>
			<p>In the next chapter, we will learn about the <strong class="bold">analog-to-digital </strong><strong class="bold">converter</strong> (<strong class="bold">ADC</strong>).</p>
		</div>
	</div>
</div>
</body></html>