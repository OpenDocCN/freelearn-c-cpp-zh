- en: Working with Signals and Slots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号和槽
- en: 'Thus far, we have learned how to create applications and display various kinds
    of widgets. If that were all that GUI applications were made of, that would be
    the end of the matter. But there is more that we need to do in order to make our
    applications usable. In this chapter, we will set about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建应用程序并显示各种类型的窗口部件。如果GUI应用程序只由这些组成，那么事情就结束了。但是，为了使我们的应用程序可用，我们还需要做更多的事情。在本章中，我们将着手以下内容：
- en: Understanding the concept behind signals and slots
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解信号和槽背后的概念
- en: Learning the different ways to connect signals and slots
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习连接信号和槽的不同方法
- en: 'GUI toolkits usually provide a means to react to things that occur within an
    application. Nothing is left to chance. Every tick that happens within the application
    is registered and taken note of. For example, when you move a window or resize
    it, the action gets registered, and provided ample code has been written, it will
    be executed as a reaction to the moving or resizing of the window. For every action
    that occurs, a number of outcomes may happen. Essentially, the questions we want
    to answer are as follows: what do we do when a particular action or event has
    occurred? How do we handle it?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GUI工具包通常提供一种方法来响应应用程序内部发生的事情。不会留下任何偶然。应用程序内部发生的每一个动作都会被注册并记录下来。例如，当你移动一个窗口或调整其大小时，该动作会被注册，并且如果已经编写了足够的代码，它将作为对窗口移动或调整大小的反应来执行。对于发生的每一个动作，可能会有许多结果发生。本质上，我们想要回答的问题是：当特定的动作或事件发生时，我们该怎么办？我们如何处理它？
- en: One way to implement the ability to react to an action that has occurred is
    by using the design pattern called the **Observer Pattern**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实现对已发生动作的响应能力的一种方法是通过使用称为**观察者模式**的设计模式。
- en: 'In the Observer Pattern design, an observable object communicates its state
    change to other objects that are observing it. For instance, any time an object
    (A) wants to be notified of a state change of some other object (B), it first
    has to identify that object (B) and register itself as one of the objects that
    should receive such notification of the state change. Sometime in the future,
    when the state of an object (B) occurs, object (B) will go through a list of objects
    it keeps that want to be informed regarding the state change. This will, at this
    point, include object (A):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式设计中，一个可观察对象将其状态变化通知给正在观察它的其他对象。例如，任何时间一个对象（A）想要通知另一个对象（B）的状态变化，它首先必须识别该对象（B）并将自己注册为应该接收此类状态变化通知的对象之一。在未来某个时刻，当对象（B）的状态发生变化时，对象（B）将遍历它保持的想要了解状态变化的对象列表，此时将包括对象（A）：
- en: '![](img/8e26039c-0d1e-4b15-ae9c-f33929c73fc2.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e26039c-0d1e-4b15-ae9c-f33929c73fc2.png)'
- en: From the preceding diagram, the **Subject** circle is termed the observable
    object, while the circles in the bounded box are the observers. They are being
    notified of the state change of the **Subject** as its count variable is increased
    from 1 to 5.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中可以看出，**主题**圆圈被称为可观察对象，而边界框中的圆圈是观察者。它们正在被通知**主题**的状态变化，因为其计数变量从1增加到5。
- en: 'Some events or actions that may occur within our application that we will be
    interested in and would want to react to include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中可能发生的一些事件或动作，我们可能会感兴趣并希望对其做出反应，包括以下内容：
- en: A window being resized
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口正在调整大小
- en: A button clicked
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮被点击
- en: Pressing the return key
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下回车键
- en: A widget being dragged
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口部件正在被拖动
- en: A mouse hovering over the widget
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标悬停在窗口部件上
- en: In the case of a button, a typical response to a click of a mouse would be to
    start a download process or send an email.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮来说，对鼠标点击的典型响应可能是启动下载过程或发送电子邮件。
- en: Signals and slots
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽
- en: In Qt, this action-response scheme is handled by signals and slots. This section
    will include a few definitions, and then we shall jump into an example for further
    explanation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，这种动作-响应方案由信号和槽处理。本节将包含一些定义，然后我们将通过一个示例进行进一步解释。
- en: A signal is a message that is passed to communicate that the state of an object
    has changed. This signal may carry information about the change that has occurred.
    For instance, when a window has been resized, the signal will usually carry the
    coordinates of the new state (or size) of the window. Sometimes, a signal may
    carry no extra information, such as that of a button click.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一个传递的消息，用于传达对象状态已发生变化。这个信号可能携带有关发生变化的额外信息。例如，当一个窗口被调整大小时，信号通常会携带新状态（或大小）的坐标。有时，信号可能不携带额外信息，例如按钮点击。
- en: A slot is a specific function of an object that is called whenever a certain
    signal has been emitted. Since slots are functions, they will embody lines of
    code that perform an action, such as closing a window, disabling a button, and
    sending an email, to mention but a few.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 槽是对象的一个特定函数，每当发出某个信号时都会被调用。由于槽是函数，它们将包含执行动作的代码行，例如关闭窗口、禁用按钮和发送电子邮件，仅举几例。
- en: Signals and slots have to be connected (in code). Without writing code to connect
    a signal and a slot, they will exist as independent entities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽必须被连接（在代码中）。如果不编写代码来连接信号和槽，它们将作为独立的实体存在。
- en: Most of the widgets in Qt come with a number of signals and slots. However,
    it is possible to write your own signals and slots too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Qt中的部件都自带一系列的信号和槽。然而，你也可以编写自己的信号和槽。
- en: So what do a signal and a slot look like?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，信号和槽看起来是什么样子？
- en: 'Consider the following code listing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码列表：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As usual, we shall use the following steps to compile the project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将使用以下步骤来编译项目：
- en: Create a new folder with an appropriate name of your choosing
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有适当名称的新文件夹
- en: Create a `.cpp` file named `main.cpp`
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.cpp`的`.cpp`文件
- en: 'Issue the following commands in the Terminal:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be sure to edit the `.pro` file to include the `widget` module during compilation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要编辑`.pro`文件，在编译时包含`widget`模块。
- en: Compile and run the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用。
- en: An instance of `QPushButton` is created, `quitButton`. The `quitButton` instance
    here is the observable object. Anytime this button is clicked, the `clicked()`
    signal will be emitted. The `clicked()` signal here is a method belonging to the
    `QPushButton` class that has only been earmarked as a signal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`QPushButton`的实例，命名为`quitButton`。这里的`quitButton`实例是可观察对象。任何时候点击这个按钮，都会发出`clicked()`信号。这里的`clicked()`信号是`QPushButton`类的一个方法，它已经被标记为信号。
- en: The `quit()` method of the `app` object is called, which terminates the `event`
    loop.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`对象的`quit()`方法被调用，这终止了`event`循环。'
- en: To specify what should happen when `quitButton` has been clicked, we pass `app`
    and say that the `quit()` method on the `app` object should be called. These four
    parameters are connected by the static function, `connect()`, of the `QObject`
    class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定当`quitButton`被点击时应该发生什么，我们传递`app`并说明`app`对象上的`quit()`方法应该被调用。这四个参数通过`QObject`类的静态函数`connect()`连接起来。
- en: The general format is (`objectA`, *signals* (`methodOnObjectA()`), `objectB`,
    *slots* (`methodOnObjectB()`)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通用格式是（`objectA`，*信号*（`methodOnObjectA()`），`objectB`，*槽*（`methodOnObjectB()`））。
- en: The second and final parameters are the signatures of the methods representing
    the signals and the slots. The first and third parameters are pointers and should
    contain the address to objects. Since `quitButton` is already a pointer, we simply
    pass it as it is. On the other hand, `&app` would return the address of `app`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和最后一个参数是表示信号和槽的方法的签名。第一个和第三个参数是指针，应该包含对象的地址。由于`quitButton`已经是一个指针，我们只需按原样传递它。另一方面，`&app`会返回`app`的地址。
- en: 'Now, click on the button and the application will close:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击按钮，应用将会关闭：
- en: '![](img/585eba7e-8d2f-4e6e-a267-190e61b0a482.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/585eba7e-8d2f-4e6e-a267-190e61b0a482.png)'
- en: When this application is run, you should see the following.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个应用运行时，你应该看到以下内容。
- en: 'The example we have just illustrated is quite primitive. Let''s write an application
    where a change in the state of one widget is passed to another widget. Not only
    will the signal be connected to a slot, but data will be carried along:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所展示的例子相当原始。让我们编写一个应用，其中一个部件状态的变化传递给另一个部件。信号不仅会连接到一个槽，还会携带数据：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is yet another simple program that illustrates how data is passed between
    the signal and slot. An instance of `QVBoxLayout` is created, `layout`. A `QLabel`
    instance, `volumeLabel`, is created and will be used to display changes that occur.
    It is initialized with the string `0`. Next, an instance of `QDial` is created
    with `QDial *volumeDial = new QDial`. The `QDial` widget is a knob-like looking
    widget that is graduated with a minimum and maximum range of numbers. With the
    aid of a mouse, the knob can be turned, just like you would turn up the volume
    on a speaker or radio.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个说明如何在信号和槽之间传递数据的另一个简单程序。创建了一个`QVBoxLayout`实例，命名为`layout`。创建了一个`QLabel`实例，命名为`volumeLabel`，它将用于显示发生的变化。它被初始化为字符串`0`。接下来，创建了一个`QDial`实例，命名为`QDial
    *volumeDial = new QDial`。`QDial`小部件是一个类似旋钮的控件，带有最小和最大数值范围。借助鼠标，可以旋转旋钮，就像你会上调扬声器或收音机的音量一样。
- en: These two widgets, `volumeLabel` and `volumeDial`, are then added to the layout
    using the `addWidget()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个小部件`volumeLabel`和`volumeDial`随后使用`addWidget()`方法添加到布局中。
- en: Whenever we change to move the knob of `QDial`, a signal called `valueChanged(int)`
    is emitted. The slot named `setNum(int)` of the `volumeLabel` object is a method
    that accepts an `int` value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们改变`QDial`的旋钮时，都会发出一个名为`valueChanged(int)`的信号。`volumeLabel`对象的名为`setNum(int)`的槽是一个接受`int`值的函数。
- en: 'Note how the connection between the signals and slots is established in the
    following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中信号与槽之间的连接是如何建立的：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This literally establishes a connection that reads "*Anytime the* `QDial` *changes
    its value, call the* `setNum()` *method of the* `volumeLabel` *object and pass
    it an* `int` *value*." There can be a number of state changes that may occur in
    `QDial`. The connection further makes it explicit that we are only interested
    in the value that has changed when the knob (`QDial`) was moved, which, in turn,
    emitted its current value through the `valueChanged(int)` signal.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上建立了一个连接，该连接读取“*每当* `QDial` *改变其值时，调用* `volumeLabel` *对象的* `setNum()` *方法，并传递一个*
    `int` *值*。”`QDial`中可能发生许多状态变化。该连接进一步明确指出，我们只对旋钮（`QDial`）移动时发出的已更改的值感兴趣，这反过来又通过`valueChanged(int)`信号发出其当前值。
- en: To dry run the program, let's assume that the range of `QDial` is representing
    a radio volume range between `0` and `100`. If the knob of `QDial` is changed
    to half of the range, the `valueChanged(50)` signal will be emitted. Now, the
    value 50 will be passed to the `setNum(50)` function. This will be used to set
    the text of the label, `volumeLabel` in our example, to display 50.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行干燥运行程序，让我们假设`QDial`的范围代表从`0`到`100`的广播音量范围。如果`QDial`的旋钮改变到范围的一半，将发出`valueChanged(50)`信号。现在，值50将被传递给`setNum(50)`函数。这将用于设置标签的文本，在我们的例子中是`volumeLabel`，以显示50。
- en: 'Compile the application and run it. The following output will be displayed
    on the first run:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应用程序并运行它。第一次运行时将显示以下输出：
- en: '![](img/8d01a7f7-6300-47d4-9ecd-11d73df6ed4d.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d01a7f7-6300-47d4-9ecd-11d73df6ed4d.png)'
- en: 'As you can see, the initial state of `QDial` is zero. The following label shows
    that too. Move the dial, and you will see that the label will have its value change
    accordingly. The following screenshot shows the state of the application after
    the knob has been moved to half of the range:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`QDial`的初始状态为零。下面的标签也显示了这一点。移动旋钮，你会看到标签的值会相应地改变。以下截图显示了旋钮移动到范围一半后的应用程序状态：
- en: '![](img/8df0bd5f-3c2b-4242-9dc3-7c0ff5fcc75a.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8df0bd5f-3c2b-4242-9dc3-7c0ff5fcc75a.png)'
- en: Move the knob around and observe how the label changes accordingly. This is
    all made possible by means of the signals and slots mechanism.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 移动旋钮并观察标签如何相应地改变。这一切都是通过信号和槽机制实现的。
- en: Signals and slots configuration
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽配置
- en: It is not only possible to connect one signal to one slot, but to connect one
    signal to more than one slot. This involves repeating the `QObject::connect()`
    call and, in each instance, specifying the slot that should be called when a particular
    signal has been emitted.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以将一个信号连接到一个槽，还可以将一个信号连接到多个槽。这涉及到重复`QObject::connect()`调用，并在每个实例中指定当特定信号发出时应调用的槽。
- en: Single signal, multiple slots
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个信号，多个槽
- en: In this section, we shall concern ourselves with how to connect a single signal
    to multiple slots.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注如何将单个信号连接到多个槽。
- en: 'Examine the following program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下程序：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We want to illustrate how one signal can be connected to two different slots, or
    more than one slot for that matter. The widget that will be emitting the signal
    is an instance of `QDial`, `volumeDial`. An instance of `QLCDNumber`, `volumeLCD` is
    created. This widget displays information in an LCD-like digit form. Note `volumeLabel`
    is an instance of a `QLabel`. These two widgets shall provide the two slots.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想说明一个信号如何连接到两个不同的槽，或者更确切地说，连接到多个槽。将要发出信号的部件是`QDial`的一个实例，即`volumeDial`。创建了一个`QLCDNumber`的实例，即`volumeLCD`。此小部件以类似LCD的数字形式显示信息。注意`volumeLabel`是`QLabel`的一个实例。这两个小部件将提供两个槽。
- en: To make the text of `volumeLCD` stand out, we set the color of the display to
    red with `volumeLCD->setPalette(Qt::red);`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`volumeLCD`的文本突出，我们使用`volumeLCD->setPalette(Qt::red);`将显示器的颜色设置为红色。
- en: 'The fact that `layout` is an instance of `QVBoxLayout` means that widgets added
    to this layout will flow from top to bottom. Each widget added to the layout will
    be centered around the middle as we set `setAlignment(Qt::AlignHCenter);` on `volumeLabel`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout`是一个`QVBoxLayout`的实例，这意味着添加到该布局中的小部件将从上到下流动。每个添加到布局中的小部件都将围绕中间对齐，因为我们已经在`volumeLabel`上设置了`setAlignment(Qt::AlignHCenter);`：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The graduations on `volumeDial` are visible when the `setNotchesVisible(true)`
    method is called. The default argument to `setNotchesVisible()` is `false`, which
    makes the small ticks (graduations) on the dial invisible. The range for our `QDial`
    instance is set by calling `setMinimum(0)` and `setMaximum(100)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`setNotchesVisible(true)`方法时，`volumeDial`上的刻度可见。`setNotchesVisible()`方法的默认参数是`false`，这使得刻度（刻度）不可见。我们通过调用`setMinimum(0)`和`setMaximum(100)`来设置`QDial`实例的范围。
- en: 'The three widgets are added accordingly with each call to the `addWidget()`
    method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addWidget()`方法调用相应地添加了三个小部件：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, `volumeDial` emits the signal, `valueChanged(int)`, which we connect to
    the `setNum(int)` slot of `volumeLabel`. When the knob of `volumeDial` changes,
    the current value will be sent for display in `volumeLabel`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`volumeDial`发出信号`valueChanged(int)`，我们将其连接到`volumeLabel`的`setNum(int)`槽。当`volumeDial`的旋钮改变时，当前值将被发送到`volumeLabel`进行显示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This same signal, `valueChanged(int)` of `volumeDial`, is also connected to
    the `display(int)` slot of `volumeLCD`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相同的信号，`volumeDial`的`valueChanged(int)`，也连接到了`volumeLCD`的`display(int)`槽。
- en: The total effect of these two connections is that when there is a change in
    `volumeDial`, both `volumeLabel` and `volumeLCD` will be updated with the current
    value of `volumeDial`. All this happens at the same time without the application
    clogging up, all thanks to the efficient design of signals and slots.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个连接的总效果是，当`volumeDial`发生变化时，`volumeLabel`和`volumeLCD`都会更新为`volumeDial`的当前值。所有这些都在同一时间发生，应用程序没有阻塞，这都要归功于信号和槽的高效设计。
- en: 'Compile and run the project. A typical output of the program is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目。程序的典型输出如下：
- en: '![](img/5b15b2eb-974e-4750-9c6a-60cc246ca323.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b15b2eb-974e-4750-9c6a-60cc246ca323.png)'
- en: In the preceding screenshot, when the `QDial` widget (that is the round-looking
    object) was moved to 32, both `volumeLabel` and `volumeLCD` were updated. As you
    move the dial, `volumeLabel` and `volumeLCD` will receive the updates by way of
    signals and will update themselves accordingly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，当`QDial`小部件（即看起来像圆形的对象）移动到32时，`volumeLabel`和`volumeLCD`都进行了更新。当你移动旋钮时，`volumeLabel`和`volumeLCD`将通过信号接收更新，并相应地更新自己。
- en: Single slot, multiple signals
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单槽，多信号
- en: 'In the next example, we shall connect two signals from different widgets to
    a single slot. Let''s modify our earlier program as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将连接来自不同小部件的两个信号到一个单独的槽。让我们按照以下方式修改我们之前的程序：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `include` statements, we add the line, `#include <QSlider>`, to add
    the `QSlider` class, which is a widget that can be set to a value within a given
    range:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`include`语句中，我们添加了`#include <QSlider>`这一行，以添加`QSlider`类，这是一个可以设置在给定范围内的值的部件：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `QSlider` widget is instantiated and passed `Qt::Horizontal`, which is
    a constant that changes the orientation of the widgets such that it is presented
    horizontally. Everything else is the same as we saw in previous examples. The
    window and layout are instantiated, together with the `QDial` and `QSlider` objects:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化了`QSlider`小部件，并传递了`Qt::Horizontal`，这是一个常数，它改变了小部件的方向，使其水平显示。其他一切都是与之前示例中看到的一样。实例化了窗口和布局，以及`QDial`和`QSlider`对象：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first widget that shall emit a signal in this example is the `volumeDial`
    object. But now, the `QSlider` instance also emits a signal that allows us to
    get the state of the `QSlider` whenever it has changed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，第一个应该发出信号的部件是`volumeDial`对象。但现在，`QSlider`实例也发出一个信号，允许我们在`QSlider`状态改变时获取其状态。
- en: To show the graduations on `QSlider`, we invoke the `setTickPosition()` method
    and pass the constant, `QSlider::TicksAbove`. This will show the graduations on
    top of the slider, very similar to how the graduations on a straight edge appear.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`QSlider`上显示刻度，我们调用`setTickPosition()`方法并传递常量`QSlider::TicksAbove`。这将显示在滑块顶部的刻度，非常类似于直边上的刻度显示。
- en: The `setMinimum()` and `setMaximum()` variables are used to set the range of
    values for our `QSlider` instance. The range here is between `0` and `100`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMinimum()`和`setMaximum()`变量用于设置`QSlider`实例的值范围。这里的范围是`0`到`100`。'
- en: The `setTickInterval(10)` method on the `lengthSlider` object is used to set
    the interval between the ticks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`lengthSlider`对象上的`setTickInterval(10)`方法用于设置刻度之间的间隔。'
- en: 'The `QVBoxLayout` object, `layout`, adds the `lengthSlider` widget object to
    the list of widgets it will house with the line, `layout->addWidget(lengthSlider);`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVBoxLayout`对象`layout`通过以下行将`lengthSlider`部件对象添加到它将容纳的部件列表中，`layout->addWidget(lengthSlider);`：'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are two calls to the static method, `connect()`. The first call will establish
    a connection between the `valueChanged(int)` signal of `volumeDial` with the  `display(int)`
    slot of `volumeLCD`. As a result, whenever the `QDial` object changes, the value
    will be passed to the `display(int)` slot for display.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个对静态方法`connect()`的调用。第一个调用将在`volumeDial`的`valueChanged(int)`信号与`volumeLCD`的`display(int)`槽之间建立连接。结果，每当`QDial`对象改变时，值将被传递到`display(int)`槽进行显示。
- en: From a different object, we shall connect the `valueChanged(int)` signal of
    `lengthSlider` to the same slot, `display()`, of the `volumeLCD` object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的对象，我们将`lengthSlider`的`valueChanged(int)`信号连接到`volumeLCD`对象的相同槽`display()`。
- en: The remainder of the program is the same as usual.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分与往常一样。
- en: Compile and run the program from the command line as we have done for the previous
    examples.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们为前一个示例所做的那样，从命令行编译并运行程序。
- en: 'The first time the application is run, the output should be similar to the
    following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行应用程序时，输出应类似于以下内容：
- en: '![](img/82b87945-6637-4767-997d-70074c28d257.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82b87945-6637-4767-997d-70074c28d257.png)'
- en: 'Both `QDial` and `QSlider` are at zero. Now, we will move the `QDial` to 48\.
    See how the `QLCDNumber` is updated accordingly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDial`和`QSlider`都处于零的位置。现在，我们将`QDial`移动到48。看看`QLCDNumber`是如何相应更新的：'
- en: '![](img/54a31e9b-fe3d-4b95-94a3-f192f739af09.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54a31e9b-fe3d-4b95-94a3-f192f739af09.png)'
- en: 'With the way we have set up our signals and slots, it will also be possible
    for `QSlider` to also update the same widget, `volumeLCD`. When we move `QSlider`,
    we will see that `volumeLCD` is updated immediately by its value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们设置的信号和槽，`QSlider`也可以更新相同的部件，即`volumeLCD`。当我们移动`QSlider`时，我们会看到`volumeLCD`会立即根据其值更新：
- en: '![](img/5cfdb730-c33f-41bd-9780-3e3e3f68b6ca.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cfdb730-c33f-41bd-9780-3e3e3f68b6ca.png)'
- en: As can be seen, `QSlider` has been moved to the tail end of its range and the
    value has been passed onto `volumeLCD`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`QSlider`已经移动到其范围的末端，并且值已经传递到`volumeLCD`。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a look at the core concept of signals and slots in
    Qt. After creating our first application, we looked at the various ways in which
    signals and slots can be connected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Qt中信号和槽的核心概念。在创建我们的第一个应用程序后，我们研究了信号和槽可以连接的各种方式。
- en: We saw how to connect one signal from a widget to multiple slots. This is a
    typical way to set up signals and slots, especially when a change in the state
    of a widget has to be communicated to many other widgets.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何将一个部件的信号连接到多个槽。这是一种典型的设置信号和槽的方式，尤其是在部件状态的变化需要通知许多其他部件时。
- en: To show how flexible signals and slots could be configured, we also looked at
    an example where multiple signals were connected to one slot of a widget. This
    type of arrangement is useful when different widgets can be used to achieve the
    same effect on a widget.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示信号和槽可以如何灵活地配置，我们还查看了一个例子，其中多个信号连接到部件的一个槽。这种安排在可以使用不同的部件在部件上实现相同效果时很有用。
- en: In [Chapter 4](d0636a57-1cac-4853-836b-850c773e82db.xhtml), *Implementing Windows
    and Dialog*, we shall change our style of writing applications and study how to
    make full-blown window applications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](d0636a57-1cac-4853-836b-850c773e82db.xhtml)，*实现窗口和对话框*，我们将改变编写应用程序的风格，并学习如何制作完整的窗口应用程序。
