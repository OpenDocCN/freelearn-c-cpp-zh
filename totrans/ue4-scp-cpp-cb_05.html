<html><head></head><body>
        

                            
                    <h1 class="header-title">Handling Events and Delegates</h1>
                
            
            
                
<p>We will cover the following recipes in this chapter:</p>
<ul>
<li>Handling events that have been implemented via virtual functions</li>
<li>Creating a delegate that is bound to a UFUNCTION</li>
<li>Unregistering a delegate</li>
<li>Creating a delegate that takes input parameters</li>
<li>Passing payload data with a delegate binding</li>
<li>Creating a multicast delegate</li>
<li>Creating a custom Event</li>
<li>Creating a Time of Day handler</li>
<li>Creating a respawning pickup for a First Person Shooter</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Unreal uses events to notify objects about things that happen in the game world in an efficient manner. Events and delegates are useful to ensure that these notifications can be issued in a way that minimizes class coupling, and allows arbitrary classes to subscribe to be notified.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and their requirements can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling events that have been implemented via virtual functions</h1>
                
            
            
                
<p>Some <kbd>Actor</kbd> and <kbd>Component</kbd> classes provided with Unreal include event handlers in the form of <kbd>virtual</kbd> functions. This recipe will show you how to customize those handlers by overriding the <kbd>virtual</kbd> functions in question.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create an empty <kbd>Actor</kbd> in the Editor. Call it <kbd>MyTriggerVolume</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d1d05cdf-0c3c-4ae6-be67-354df71b2b43.png"/></p>
<ol start="2">
<li>Add the following code to the class header:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY() <br/>UBoxComponent* TriggerZone; <br/> <br/>UFUNCTION() <br/>virtual void NotifyActorBeginOverlap(AActor* OtherActor) override; <br/><br/>UFUNCTION() <br/>virtual void NotifyActorEndOverlap(AActor* OtherActor) override;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Because we are referencing a class that's isn't a part of our project already, we also need to add an <kbd>#include</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/BoxComponent.h"</strong><br/>#include "MyTriggerVolume.generated.h"</pre>
<p style="padding-left: 60px">Remember to place the include above the <kbd>.generated.h</kbd> file.</p>
<ol start="4">
<li>Add the following script to the constructor to create the <kbd>BoxComponent</kbd>. This will trigger our events:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AMyTriggerVolume::AMyTriggerVolume()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn <br/>   // this off to improve performance if you don't need it. <br/>  <br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    // Create a new component for the instance and initialize <br/>       it</strong><br/><strong>    TriggerZone = CreateDefaultSubobject&lt;UBoxComponent&gt;("TriggerZone");</strong><br/><strong>    TriggerZone-&gt;SetBoxExtent(FVector(200, 200, 100));</strong><br/>}</pre>
<ol start="5">
<li>Add the implementation for the preceding additional functions to the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor) <br/>{ <br/>    auto Message = FString::Printf(TEXT("%s entered me"), <br/>                   *(OtherActor-&gt;GetName()));<br/><br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, Message); <br/>} <br/> <br/>void AMyTriggerVolume::NotifyActorEndOverlap(AActor* OtherActor) <br/>{ <br/>    auto Message = FString::Printf(TEXT("%s left me"), <br/>                   *(OtherActor-&gt;GetName()));<br/><br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, Message); <br/>} </pre>
<ol start="6">
<li>Compile your project and place an instance of <kbd>MyTriggerActor</kbd> into the level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e8b4d60a-7163-4710-a5c9-2556e1be3566.png"/></p>
<p>Trigger Volume placed in the level</p>
<p style="padding-left: 60px">You should see the lines around the object, indicating where collisions would take place. Feel free to move it around and/or adjust the properties as needed so that they fit where you want.</p>
<ol start="7">
<li>Then, verify that overlap/touch events are handled by walking into the volume and viewing the output that's printed to the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/22bfbd2a-71b3-4cd8-be0c-5a2d0de42001.png" style="width:48.67em;height:22.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As always, we first declare a <kbd>UPROPERTY</kbd> to hold a reference to our component subobject. We then create two <kbd>UFUNCTION</kbd> declarations. These are marked as <kbd>virtual</kbd> and <kbd>override</kbd> so that the compiler understands that we want to replace the parent implementation, and that our function implementations can be replaced in turn.</p>
<p>In the constructor for the object, we create the subobject using the <kbd>CreateDefaultSubobject</kbd> function. Afterwards, we set the extents (size) of the box via the <kbd>SetBoxExtent</kbd> function using a <kbd>FVector</kbd> holding the <em>X</em>, <em>Y</em>, and <em>Z</em> sizes we want the box to have, respectively.</p>
<p>In the implementation of the functions, we create an <kbd>FString</kbd> from some preset text and substitute some data parameters using the <kbd>FString::Printf</kbd> function. Note that the <kbd>Actor-&gt;GetName()</kbd> function returns an <kbd>FString</kbd> as well, and is dereferenced using the <kbd>*</kbd> operator before being passed into <kbd>FString::Printf</kbd>. Not doing this results in an error.</p>
<p>This <kbd>FString</kbd> is then passed to a global engine function, <kbd>AddOnScreenDebugMessage</kbd>, to display this information on the screen. </p>
<p>The first argument of <kbd>-1</kbd> tells the engine that duplicate strings are allowed, the second parameter is the length of time the message should be displayed for in seconds, the third argument is the color, and the fourth is the actual string to print itself. While it would be possible to not create an additional variable and just put the information within the function call, it makes the code more difficult to read.</p>
<p>Now, when a component of our actor overlaps something else, its <kbd>UpdateOverlaps</kbd> function will call <kbd>NotifyActorBeginOverlap</kbd>, and the virtual function dispatch will call our custom implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Unreal's documentation contains information on all of the variables and functions that all of their built-in classes have. For instance, the <kbd>Actor</kbd> class can be found at <a href="https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html">https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html</a>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1790133f-4584-4b4b-8fa6-3fa534aa72b7.png"/></p>
<p class="mce-root"/>
<p>If you scroll down to the functions we used in this recipe, you can see more information on them (feel free to use <em>Ctrl</em> + <em>F</em> to find a particular item):</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/9388a24b-1449-414c-bc5a-f8cb197f191f.png"/></p>
<p>On the left-most tab, you'll see some icons where the blue circle with the V inside it indicates that the function is <kbd>virtual</kbd> and can be overwritten in your own class. If you haven't gotten a chance to yet, it would also be a good idea to look at all of the events so that you are familiar with what's already been included.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a delegate that is bound to a UFUNCTION</h1>
                
            
            
                
<p>Pointers are great since we are able to assign them at runtime and can change where in memory they are pointing to. In addition to standard types, we can also create pointers to functions as well, but these raw function pointers are unsafe to use for a number of reasons. Delegates are a much safer version of function pointers that gives us the flexibility to call a function without knowing which function is assigned until the moment it is called. This flexibility is one of the main reasons to prefer delegates over static functions. This recipe shows you how to associate a <kbd>UFUNCTION</kbd> to a delegate so that it will be called when the delegate is executed.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Ensure you've followed the previous recipe in order to create the <kbd>MyTriggerVolume</kbd> class because we will be using that to call our delegate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Inside our Unreal project's <kbd>GameMode</kbd> header, declare the delegate with the following macro, just before the class declaration:</li>
</ol>
<pre style="padding-left: 60px"><strong>DECLARE_DELEGATE(FStandardDelegateSignature)</strong><br/>UCLASS()<br/>class CHAPTER_05_API AChapter_05GameModeBase : public AGameModeBase</pre>
<ol start="2">
<li>Add a new member to our game mode:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_DELEGATE(FStandardDelegateSignature)<br/>UCLASS()<br/>class CHAPTER_05_API AChapter_05GameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>    FStandardDelegateSignature MyStandardDelegate;</strong><br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Create a new <kbd>Actor</kbd> class called <kbd>DelegateListener</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/44ea8a24-0a8b-447a-b937-7258cbb81cee.png"/></p>
<ol start="4">
<li>Add the following to the declaration of that class:</li>
</ol>
<pre style="padding-left: 60px">UFUNCTION() 
void EnableLight(); 
 
UPROPERTY() 
UPointLightComponent* PointLight; </pre>
<ol start="5">
<li>Since the script doesn't know what the <kbd>UPointLightComponent</kbd> class is, we will also need to add the following new <kbd>#include</kbd> above the generated <kbd>.h</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/PointLightComponent.h"</strong><br/>#include "DelegateListener.generated.h"</pre>
<ol start="6">
<li>In the class implementation <kbd>.cpp</kbd> file, add the following code, in bold, to the constructor:</li>
</ol>
<pre style="padding-left: 60px">ADelegateListener::ADelegateListener()<br/>{<br/>  // Set this actor to call Tick() every frame. You can turn this<br/> // off to improve performance if you don't need it.<br/> PrimaryActorTick.bCanEverTick = true;<br/><br/> <strong> // Create a point light</strong><br/><strong> PointLight = CreateDefaultSubobject&lt;UPointLightComponent&gt;("PointLight");</strong><br/><strong> RootComponent = PointLight;</strong><br/><br/><strong> // Turn it off at the beginning so we can turn it on later <br/> //   through code </strong><br/><strong> PointLight-&gt;SetVisibility(false);</strong><br/><br/><strong> // Set the color to blue to make it easier to see</strong><br/><strong> PointLight-&gt;SetLightColor(FLinearColor::Blue);</strong><br/><br/>}</pre>
<ol start="7">
<li>Inside the <kbd>ADelegateListener::BeginPlay</kbd> implementation, add the following code:</li>
</ol>
<pre style="padding-left: 60px">void ADelegateListener::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/><strong>    UWorld* TheWorld = GetWorld();</strong><br/><strong>    if (TheWorld != nullptr)</strong><br/><strong>    {</strong><br/><strong>        AGameModeBase* GameMode = </strong><br/><strong>                               UGameplayStatics::GetGameMode(TheWorld);</strong><br/><br/><strong>        AChapter_05GameModeBase * MyGameMode = </strong><br/><strong>                               Cast&lt;AChapter_05GameModeBase&gt;(GameMode);</strong><br/><br/><strong>        if (MyGameMode != nullptr)</strong><br/><strong>        {</strong><br/><strong>            MyGameMode-&gt;MyStandardDelegate.BindUObject(this, </strong><br/><strong>                                      &amp;ADelegateListener::EnableLight);</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/>  <br/>}</pre>
<ol start="8">
<li>Since the script does not know about the <kbd>UGameplayStatics</kbd> class or our <kbd>GameMode</kbd> in the <kbd>DelegateListener.cpp</kbd> file, add the following #includes:</li>
</ol>
<pre style="padding-left: 60px">#include "DelegateListener.h"<br/><strong>#include "Chapter_05GameModeBase.h"</strong><br/><strong>#include "Kismet/GameplayStatics.h"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="9">
<li>Lastly, implement <kbd>EnableLight</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void ADelegateListener::EnableLight() 
{ 
  PointLight-&gt;SetVisibility(true); 
} </pre>
<ol start="10">
<li>Put the following code in our <kbd>NotifyActorBeginOverlap</kbd> function of <kbd>TriggerVolume</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor) <br/>{ <br/>    auto Message = FString::Printf(TEXT("%s entered me"), <br/>                   *(OtherActor-&gt;GetName()));<br/><br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, Message); <br/><br/>    <strong>// Call our delegate</strong><br/><strong>    UWorld* TheWorld = GetWorld();</strong><br/><br/><strong>    if (TheWorld != nullptr)</strong><br/><strong>    {</strong><br/><strong>        AGameModeBase* GameMode = <br/>                               UGameplayStatics::GetGameMode(TheWorld); </strong><br/><strong>        AChapter_05GameModeBase * MyGameMode = <br/>                               Cast&lt;AChapter_05GameModeBase&gt;(GameMode);</strong><br/><br/><strong>        if(MyGameMode != nullptr)</strong><br/><strong>        {</strong><br/><strong>            MyGameMode-&gt;MyStandardDelegate.ExecuteIfBound();</strong><br/><strong>        }</strong><br/><strong>        </strong><br/><strong>    }</strong><br/>} </pre>
<ol start="11">
<li>Just like we previously included, be sure that you add the following code to your CPP file too so that the compiler knows about the class before we use it:</li>
</ol>
<pre style="padding-left: 60px">#include "MyTriggerVolume.h"<br/><strong>#include "Chapter_05GameModeBase.h"</strong><br/><strong>#include "Kismet/GameplayStatics.h"</strong></pre>
<p class="mce-root"/>
<ol start="12">
<li>Compile your game. Make sure that your game mode is set in the current level (refer to the <em>Instantiating an Actor using SpawnActor</em> recipe in <a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, <em>Actors and Components</em>, if you don't know how), and drag a copy of your <kbd>MyTriggerVolume</kbd> out into the level. Also, drag a copy of <kbd>DelegateListener</kbd> out into the level, and place it about 100 units above a flat surface so that we can see the light when playing the game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2342fe47-0609-4ba6-a7c8-f06b193ea181.png" style="width:73.25em;height:39.17em;"/></p>
<p>The DelegateListener positioned above the ground plane</p>
<ol start="13">
<li>When you hit Play and walk into the area covered by the Trigger volume, you should see the <kbd>PointLight</kbd> component, which we added to <kbd>DelegateListener</kbd>, turn on:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/08d981f9-afb0-4702-93df-d93340ffdbc2.png" style="width:47.42em;height:21.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Inside our <kbd>GameMode</kbd> header, we declare a type of delegate that doesn't take any parameters, called <kbd>FStandardDelegateSignature</kbd>. We then create an instance of the delegate as a member of our <kbd>GameModeBase</kbd> class.</p>
<p>We add a <kbd>PointLight</kbd> component inside of the <kbd>DelegateListener</kbd> so that we have a visual representation of the delegate being executed that we can turn on later on. In the constructor, we initialize our <kbd>PointLight</kbd>, and then disable it. To make it easier to see, we also change the color to blue.</p>
<p>We override <kbd>BeginPlay</kbd>. We first call the parent class's implementation of <kbd>BeginPlay()</kbd>. Then, we get the game world, retrieving the <kbd>GameMode</kbd> class using <kbd>GetGameMode()</kbd>. Casting the resulting <kbd>AGameMode*</kbd> to a pointer of our <kbd>GameMode</kbd> class requires the use of the <kbd>Cast</kbd> template function. We can then access the delegate instance member of the <kbd>GameMode</kbd> and bind our <kbd>EnableLight</kbd> function to the delegate so that it will be called when the delegate is executed. In this case, we are binding to <kbd>UFUNCTION()</kbd>, so we use <kbd>BindUObject</kbd>.</p>
<p class="mce-root"/>
<p>If we had wanted to bind to a plain C++ class function, we would have used <kbd>BindRaw</kbd>. If we had wanted to bind to a static function, we would have used <kbd>BindStatic()</kbd>. If you're using these, you must be very careful and unbind them manually when an object is being destroyed. It's the same as using naked C++ memory allocation. When it comes to UE4, the general rule of thumb is to use a <kbd>UObject</kbd> wherever possible. It saves a lot of headaches!</p>
<p>When <kbd>TriggerVolume</kbd> overlaps the player, it retrieves <kbd>GameMode</kbd>, then calls <kbd>ExecuteIfBound</kbd> on the delegate. <kbd>ExecuteIfBound</kbd> checks that there's a function bound to the delegate, and then invokes it for us. The <kbd>EnableLight</kbd> function enables the <kbd>PointLight</kbd> component when it's invoked by the delegate object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The next recipe, <em>Unregistering a delegate,</em> shows you how to safely unregister your delegate binding in the event of the <kbd>Listener</kbd> being destroyed before the delegate is called</li>
</ul>
<p>To learn more about this and additional options for working with delegates, check out <a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates">https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unregistering a delegate</h1>
                
            
            
                
<p>Sometimes, it is necessary to remove a delegate binding. This is like setting a function pointer to <kbd>nullptr</kbd> so that it no longer references an object that has been deleted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You'll need to follow the previous recipe so that you have a delegate to unregister.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>In the <kbd>DelegateListener</kbd> class, add the following overridden function declaration:</li>
</ol>
<pre style="padding-left: 60px">UFUNCTION() <br/>virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;</pre>
<ol start="2">
<li>Implement the function like this:</li>
</ol>
<pre style="padding-left: 60px">void ADelegateListener::EndPlay(const EEndPlayReason::Type EndPlayReason)<br/>{<br/>    Super::EndPlay(EndPlayReason);<br/>    UWorld* TheWorld = GetWorld();<br/><br/>    if (TheWorld != nullptr)<br/>    {<br/>        AGameModeBase* GameMode = <br/>                               UGameplayStatics::GetGameMode(TheWorld);<br/><br/>        AChapter_05GameModeBase * MyGameMode = <br/>                               Cast&lt;AChapter_05GameModeBase&gt;(GameMode);<br/><br/>        if (MyGameMode != nullptr)<br/>        {<br/>            MyGameMode-&gt;MyStandardDelegate.Unbind();<br/>        }<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This recipe combines both of the previous recipes in this chapter so far. We override <kbd>EndPlay</kbd>, which is an event that's implemented as a virtual function, so that we can execute code when our <kbd>DelegateListener</kbd> leaves play.</p>
<p>In that overridden implementation, we call the <kbd>Unbind()</kbd> method on the delegate, which unlinks the member function from the <kbd>DelegateListener</kbd> instance.</p>
<p class="mce-root"/>
<p>Without this being done, the delegate dangles like a pointer, leaving it in an invalid state when the <kbd>DelegateListener</kbd> leaves the game. Using <kbd>BindUObject()</kbd> helps avoid most of these situations, and just a few unfortunate timing situations could cause calls on objects to be marked for destruction. It is still a good practice to unbind delegates manually, even when using <kbd>BindUObject()</kbd>, because when these timing mishaps cause bugs, they're almost impossible to track down.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a delegate that takes input parameters</h1>
                
            
            
                
<p>So far, the delegates that we've used haven't taken any input parameters. This recipe shows you how to change the signature of the delegate so that it accepts some input.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Ensure that you followed the recipe at the beginning of this chapter, which showed you how to create a <kbd>TriggerVolume</kbd> and the other infrastructure that we require for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Add a new delegate declaration to <kbd>GameMode</kbd>:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_DELEGATE(FStandardDelegateSignature)<br/><strong>DECLARE_DELEGATE_OneParam(FParamDelegateSignature, FLinearColor)<br/></strong><br/>UCLASS()<br/>class CHAPTER_05_API AChapter_05GameModeBase : public AGameModeBase</pre>
<ol start="2">
<li>Add a new member to <kbd>GameMode</kbd>:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_DELEGATE(FStandardDelegateSignature)<br/>DECLARE_DELEGATE_OneParam(FParamDelegateSignature, FLinearColor)<br/><br/>UCLASS()<br/>class CHAPTER_05_API AChapter_05GameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>    FStandardDelegateSignature MyStandardDelegate;<br/><br/>    <strong>FParamDelegateSignature MyParameterDelegate;</strong><br/><br/>};</pre>
<ol start="3">
<li>Create a new <kbd>Actor</kbd> class called <kbd>ParamDelegateListener</kbd>. Add the following to the declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/PointLightComponent.h"</strong><br/>#include "ParamDelegateListener.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_05_API AParamDelegateListener : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    AParamDelegateListener();<br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void SetLightColor(FLinearColor LightColor);</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UPointLightComponent* PointLight;</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<p class="mceNonEditable"/>
<ol start="4">
<li>In the class implementation, add the following to the constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AParamDelegateListener::AParamDelegateListener()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn this off <br/>    // to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    PointLight = CreateDefaultSubobject&lt;UPointLightComponent&gt;("PointLight");</strong><br/><strong>    RootComponent = PointLight;</strong><br/><br/>}</pre>
<ol start="5">
<li>In the <kbd>ParamDelegateListener.cpp</kbd> file, add the following <kbd>#includes</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "ParamDelegateListener.h"<br/><strong>#include "Chapter_05GameModeBase.h"</strong><br/><strong>#include "Kismet/GameplayStatics.h"</strong></pre>
<ol start="6">
<li>Inside the <kbd>AParamDelegateListener::BeginPlay</kbd> implementation, add the following code:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void AParamDelegateListener::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    UWorld* TheWorld = GetWorld();<br/><br/>    if (TheWorld != nullptr)<br/>    {<br/>        AGameModeBase* GameMode = <br/>                               UGameplayStatics::GetGameMode(TheWorld);<br/><br/>        AChapter_05GameModeBase * MyGameMode = <br/>                               Cast&lt;AChapter_05GameModeBase&gt;(GameMode);<br/><br/>        if (MyGameMode != nullptr)<br/>        {<br/>            MyGameMode-&gt;MyParameterDelegate.BindUObject(this, <br/>                               &amp;AParamDelegateListener::SetLightColor);<br/>        }<br/>    }<br/>    <br/>}</pre>
<ol start="7">
<li>Lastly, implement <kbd>SetLightColor</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AParamDelegateListener::SetLightColor(FLinearColor LightColor)<br/>{<br/>    PointLight-&gt;SetLightColor(LightColor);<br/>}</pre>
<ol start="8">
<li>Inside our <kbd>TriggerVolume</kbd>, in <kbd>NotifyActorBeginOverlap</kbd>, add the following new code: </li>
</ol>
<pre style="padding-left: 60px"> void AMyTriggerVolume::NotifyActorBeginOverlap(AActor* OtherActor) <br/>{ <br/>    auto Message = FString::Printf(TEXT("%s entered me"), <br/>                   *(OtherActor-&gt;GetName()));<br/><br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, Message); <br/><br/>    // Call our delegate<br/>    UWorld* TheWorld = GetWorld();<br/><br/>    if (TheWorld != nullptr)<br/>    {<br/>        AGameModeBase* GameMode = <br/>                               UGameplayStatics::GetGameMode(TheWorld); <br/>        AChapter_05GameModeBase * MyGameMode = <br/>                               Cast&lt;AChapter_05GameModeBase&gt;(GameMode);<br/><br/>        if(MyGameMode != nullptr)<br/>        {<br/>            MyGameMode-&gt;MyStandardDelegate.ExecuteIfBound();<br/><br/>            <strong>// Call the function using a parameter</strong><br/><strong>            auto Color = FLinearColor(1, 0, 0, 1);</strong><br/><strong>            MyGameMode-&gt;MyParameterDelegate.ExecuteIfBound(Color);</strong><br/>        }<br/>        <br/>    }<br/>}</pre>
<ol start="09">
<li>Save your script and then go back to the Unreal Editor and compile your code. Add the <kbd>MyTriggerVolume</kbd> and <kbd>ParamDelegateListener</kbd> objects to your scene and then run the game and confirm that the light starts off as white and, upon collision, changes to red:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/64fa8763-941d-4e56-8d7f-3ca69f499653.png" style="width:47.92em;height:22.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Our new delegate signature uses a slightly different macro for declaration. Note the <kbd>_OneParam</kbd> suffix at the end of <kbd>DECLARE_DELEGATE_OneParam</kbd>. As you'd expect, we also need to specify what type our parameter will be. Just like when we created a delegate without parameters, we can create an instance of the delegate as a member of our <kbd>GameMode</kbd> class.</p>
<p>Delegate signatures can have either a global or class scope, but not a function body (as the documentation states). You can find more information about this at <a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates">https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates</a>.</p>
<p>Then, we create a new type of <kbd>DelegateListener</kbd>: one that is expecting a parameter to be passed into the function that it binds to the delegate. When we call the <kbd>ExecuteIfBound()</kbd> method for the delegate, we need to pass in the value that will be inserted into the function parameter.</p>
<p>Inside the function that we have bound, we use the parameter to set the color of our light. This means that <kbd>TriggerVolume</kbd> doesn't need to know anything about <kbd>ParamDelegateListener</kbd> to call functions on it. The delegate has allowed us to minimize coupling between the two classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <em>Unregistering a delegate</em> recipe shows you how to safely unregister your delegate binding in the event of the Listener being destroyed before the delegate is called</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Passing payload data with a delegate binding</h1>
                
            
            
                
<p>With only minimal changes, parameters can be passed through to a delegate at creation time. This recipe shows you how to specify data to be always passed as parameters to a delegate invocation. The data is calculated when the binding is created, and doesn't change from that point forward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Ensure that you've followed the previous recipe. We will be extending the functionality of the previous recipe to pass additional creation-time parameters to our bound delegate function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Inside your <kbd>AParamDelegateListener::BeginPlay</kbd> function, change the call to <kbd>BindUObject</kbd> to the following:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void AParamDelegateListener::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    UWorld* TheWorld = GetWorld();<br/><br/>    if (TheWorld != nullptr)<br/>    {<br/>        AGameModeBase* GameMode = <br/>                               UGameplayStatics::GetGameMode(TheWorld);<br/><br/>        AChapter_05GameModeBase * MyGameMode = <br/>                               Cast&lt;AChapter_05GameModeBase&gt;<br/>                               (GameMode);<br/><br/>        if (MyGameMode != nullptr)<br/>        {<br/>            MyGameMode-&gt;MyParameterDelegate.BindUObject(this, <br/>                        &amp;AParamDelegateListener::SetLightColor<strong>, <br/>                        false</strong>);<br/>        }<br/>    }<br/>    <br/>}</pre>
<ol start="2">
<li>In the <kbd>ParamDelegateListener.h</kbd> file, change the declaration of <kbd>SetLightColor</kbd> to the following:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_05_API AParamDelegateListener : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    AParamDelegateListener();<br/><br/>    UFUNCTION()<br/>    void SetLightColor(FLinearColor LightColor<strong>, bool EnableLight</strong>);<br/><br/>    UPROPERTY()<br/>    UPointLightComponent* PointLight;<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Alter the implementation of <kbd>SetLightColor</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">void AParamDelegateListener::SetLightColor(FLinearColor LightColor<strong>, bool EnableLight</strong>)<br/>{<br/>    PointLight-&gt;SetLightColor(LightColor);<br/>    <strong>PointLight-&gt;SetVisibility(EnableLight);</strong><br/>}</pre>
<ol start="4">
<li>Compile and run your project. Verify that, when you walk into <kbd>TriggerVolume</kbd>, the light turns off because of the false payload parameter that was passed in when you bound the function.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When we bind the function to the delegate, we specify some additional data (in this case, a Boolean of value <kbd>false</kbd>). You can pass up to four "payload" variables in this fashion. They are applied to your function after any parameters are declared in the <kbd>DECLARE_DELEGATE_*</kbd> macro that you used.</p>
<p>We change the function signature of our delegate so that it can accept the extra argument.</p>
<p>Inside the function, we use the extra argument to turn the light on or off, depending on the value being <kbd>true</kbd> or <kbd>false</kbd> at compile time.</p>
<p>We don't need to change the call to <kbd>ExecuteIfBound</kbd>: the delegate system automatically applies the delegate parameters, which are passed in through <kbd>ExecuteIfBound</kbd> first. It then applies any payload parameters, which are always specified after the function reference in a call to <kbd>BindUObject</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <em>Unregistering a delegate</em> recipe shows you how to safely unregister your delegate binding in the event of the Listener being destroyed before the delegate is called</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a multicast delegate</h1>
                
            
            
                
<p>The standard delegates that we've used so far in this chapter are essentially function pointers : they allow you to call one particular function on one particular object instance. Multicast delegates are a collection of function pointers, each potentially on different objects, all of which will be invoked when the delegate is <strong>broadcast</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have followed the initial recipe in this chapter, <em>Handling events that have been implemented via virtual functions</em>, as it shows you how to create <kbd>TriggerVolume</kbd>, which is used to broadcast the multicast delegate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Add a new delegate declaration to the <kbd>GameMode</kbd> header:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_DELEGATE(FStandardDelegateSignature)<br/>DECLARE_DELEGATE_OneParam(FParamDelegateSignature, FLinearColor)<br/><strong>DECLARE_MULTICAST_DELEGATE(FMulticastDelegateSignature)<br/></strong><br/>UCLASS()<br/>class CHAPTER_05_API AChapter_05GameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>    FStandardDelegateSignature MyStandardDelegate;<br/><br/>    FParamDelegateSignature MyParameterDelegate;<br/><br/>    <strong>FMulticastDelegateSignature MyMulticastDelegate;</strong><br/><br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>Create a new <kbd>Actor</kbd> class called <kbd>MulticastDelegateListener</kbd>. Add the following to the declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/PointLightComponent.h"</strong><br/>#include "MulticastDelegateListener.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_05_API AMulticastDelegateListener : public AActor<br/>{<br/>  GENERATED_BODY()<br/>  <br/>public: <br/>  // Sets default values for this actor's properties<br/>  AMulticastDelegateListener();<br/><br/>   <strong> UFUNCTION()</strong><br/><strong>    void ToggleLight();</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) <br/>    override;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UPointLightComponent* PointLight;</strong><br/><br/><strong>    FDelegateHandle MyDelegateHandle;</strong><br/><br/>protected:<br/>  // Called when the game starts or when spawned<br/>  virtual void BeginPlay() override;<br/><br/>public: <br/>  // Called every frame<br/>  virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>In the class implementation, add the following code to the constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>AMulticastDelegateListener::AMulticastDelegateListener()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this <br/>   //off to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    PointLight = CreateDefaultSubobject&lt;UPointLightComponent&gt;<br/>    ("PointLight");</strong><br/><strong>    RootComponent = PointLight;</strong><br/>}</pre>
<ol start="4">
<li>In the <kbd>MulticastDelegateListener.cpp</kbd> file, add the following <kbd>#includes</kbd>:
<ol start="5"/>
</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">#include "MulticastDelegateListener.h"<br/><strong>#include "Chapter_05GameModeBase.h"</strong><br/><strong>#include "Kismet/GameplayStatics.h"</strong></pre>
<ol start="5">
<li>Inside the <kbd>MulticastDelegateListener::BeginPlay</kbd> implementation, add the following code:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void AMulticastDelegateListener::BeginPlay()<br/>{<br/>  Super::BeginPlay();<br/><strong>  </strong><br/><strong>    UWorld* TheWorld = GetWorld();</strong><br/><br/><strong>    if (TheWorld != nullptr)</strong><br/><strong>    {</strong><br/><strong>        AGameModeBase* GameMode = </strong><br/><strong>                               UGameplayStatics::GetGameMode(TheWorld);</strong><br/><br/><strong>        AChapter_05GameModeBase * MyGameMode = </strong><br/><strong>                               Cast&lt;AChapter_05GameModeBase&gt;<br/>                               (GameMode);</strong><br/><br/><strong>        if (MyGameMode != nullptr)</strong><br/><strong>        {</strong><br/><strong>            MyDelegateHandle = MyGameMode-<br/>            &gt;MyMulticastDelegate.AddUObject(this, <br/>            &amp;AMulticastDelegateListener::ToggleLight);</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/><br/>}</pre>
<ol start="6">
<li>Implement <kbd>ToggleLight</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AMulticastDelegateListener::ToggleLight() 
{ 
  PointLight-&gt;ToggleVisibility(); 
} </pre>
<ol start="7">
<li>Implement our <kbd>EndPlay</kbd> overridden function:</li>
</ol>
<pre style="padding-left: 60px">void AMulticastDelegateListener::EndPlay (const EEndPlayReason::Type EndPlayReason)<br/>{<br/>    Super::EndPlay(EndPlayReason);<br/><br/>    UWorld* TheWorld = GetWorld();<br/><br/>    if (TheWorld != nullptr)<br/>    {<br/>        AGameModeBase* GameMode = <br/>                               UGameplayStatics::GetGameMode(TheWorld);<br/><br/>        AChapter_05GameModeBase * MyGameMode = <br/>                               Cast&lt;AChapter_05GameModeBase&gt;<br/>                               (GameMode);<br/><br/>        if (MyGameMode != nullptr)<br/>        {<br/>            MyGameMode-<br/>            &gt;MyMulticastDelegate.Remove(MyDelegateHandle);<br/>        }<br/>    }<br/><br/>}</pre>
<ol start="8">
<li>Add the following line to <kbd>TriggerVolume::NotifyActorBeginOverlap()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">MyGameMode-&gt;MyMulticastDelegate.Broadcast(); </pre>
<ol start="9">
<li>Compile and load your project. Set the <kbd>GameMode</kbd> in your level as our cookbook game mode, and then drag four or five instances of <kbd>MulticastDelegateListener</kbd> into the scene.</li>
</ol>
<p> </p>
<ol start="10">
<li>Step into <kbd>TriggerVolume</kbd> to see all of the <kbd>MulticastDelegateListener</kbd> toggle their light's visibility:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f53635e5-ef24-4ad9-beaa-9c3c07556083.png" style="width:46.17em;height:21.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As you might expect, the delegate type needs to be explicitly declared as a multicast delegate rather than a standard single-binding one. Our new <kbd>Listener</kbd> class is very similar to our original <kbd>DelegateListener</kbd>. The primary difference is that we need to store a reference to our delegate instance in <kbd>FDelegateHandle</kbd>.</p>
<p>When the actor is destroyed, we safely remove ourselves from the list of functions that are bound to the delegate by using the stored <kbd>FDelegateHandle</kbd> as a parameter to <kbd>Remove()</kbd>.</p>
<p>The <kbd>Broadcast()</kbd> function is the multicast equivalent of <kbd>ExecuteIfBound()</kbd>. Unlike standard delegates, there is no need to check whether the delegate bound either in advance or with a call such as <kbd>ExecuteIfBound</kbd>. <kbd>Broadcast()</kbd> is safe to run, no matter how many functions are bound, or even if none are.</p>
<p>When we have multiple instances of our multicast listener in the scene, they each register themselves with the multicast delegate that's implemented in the <kbd>GameMode</kbd>. Then, when the <kbd>TriggerVolume</kbd> overlaps a player, it broadcasts the delegate, and each Listener is notified, causing it to toggle the visibility of its associated point light.</p>
<p>Multicast delegates can take parameters in exactly the same way that a standard delegate can.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a custom Event</h1>
                
            
            
                
<p>Custom delegates are quite useful, but one of their limitations is that they can be broadcast externally by some other third-party class; that is, their <kbd>Execute</kbd>/<kbd>Broadcast</kbd> methods are publically accessible.</p>
<p>At times, you may want a delegate that is externally assignable by other classes, but can only be broadcast by the class that contains them. This is the primary purpose of Events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you've followed the initial recipe in this chapter so that you have the <kbd>MyTriggerVolume</kbd> and <kbd>Chapter_05GameModeBase</kbd> implementations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Add the following event declaration macro to the header of your <kbd>MyTriggerVolume</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_EVENT(AMyTriggerVolume, FPlayerEntered) </pre>
<ol start="2">
<li>Add an instance of the declared event signature to the class:</li>
</ol>
<pre style="padding-left: 60px">FPlayerEntered OnPlayerEntered; </pre>
<ol start="3">
<li>In <kbd>AMyTriggerVolume::NotifyActorBeginOverlap</kbd>, add the following code:</li>
</ol>
<pre style="padding-left: 60px">OnPlayerEntered.Broadcast();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Create a new <kbd>Actor</kbd> class called <kbd>TriggerVolEventListener</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e1b64847-e6d5-4921-b15a-d3b256e83a55.png"/></p>
<ol start="5">
<li>Add the following class members to its declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Components/PointLightComponent.h"</strong><br/><strong>#include "MyTriggerVolume.h"</strong><br/>#include "TriggerVolEventListener.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_05_API ATriggerVolEventListener : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ATriggerVolEventListener();<br/><br/>    <strong>UPROPERTY()</strong><br/><strong>    UPointLightComponent* PointLight;</strong><br/><br/><strong>    UPROPERTY(EditAnywhere)</strong><br/><strong>    AMyTriggerVolume* TriggerEventSource;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void OnTriggerEvent();</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<ol start="6">
<li>Initialize <kbd>PointLight</kbd> in the class constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>ATriggerVolEventListener::ATriggerVolEventListener()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn this <br/>    //off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    PointLight = CreateDefaultSubobject&lt;UPointLightComponent&gt;<br/>    ("PointLight");</strong><br/><strong>    RootComponent = PointLight;</strong><br/>}</pre>
<ol start="7">
<li>Inside <kbd>BeginPlay</kbd>, add the following code:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void ATriggerVolEventListener::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/><strong>    if (TriggerEventSource != nullptr)</strong><br/><strong>    {</strong><br/><strong>        TriggerEventSource-&gt;OnPlayerEntered.AddUObject(this,            <br/>        &amp;ATriggerVolEventListener::OnTriggerEvent);</strong><br/><strong>    }</strong><br/>    <br/>}</pre>
<ol start="8">
<li>Lastly, implement <kbd>OnTriggerEvent()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void ATriggerVolEventListener::OnTriggerEvent() 
{ 
  PointLight-&gt;SetLightColor(FLinearColor(0, 1, 0, 1)); 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="9">
<li>Compile your project and launch the editor. Create a level with the game mode set to our <kbd>Chapter_05GameModeBase</kbd>, and then drag an instance of <kbd>ATriggerVolEventListener</kbd> and <kbd>AMyTriggerVolume</kbd> out into the level.</li>
<li>Select <kbd>TriggerVolEventListener</kbd>, and you'll see <kbd>TriggerVolEventListener</kbd> listed as a category in the Details panel, with the property as Trigger Event Source:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d6cf0cd5-d3c1-493a-82ef-d8d32cf5b8ba.png"/></p>
<p>The Trigger Vol Event Listener category</p>
<ol start="11">
<li>Use the drop-down menu to select your instance of <kbd>AMyTriggerVolume</kbd> so that the Listener knows which event to bind to:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b26436bd-dbff-45ea-a696-fe24e5d2b01a.png"/></p>
<p class="mce-root"/>
<ol start="12">
<li>Play your game and enter the trigger volume's zone of effect. Verify that the color of your <kbd>EventListener</kbd> changes to green:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/018dd943-a7f0-49a1-8002-9f0a09250bc2.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As with all of the other types of delegate, Events require their own special macro function. The first parameter is the class that the event will be implemented into. This will be the only class able to call <kbd>Broadcast()</kbd>, so make sure it is the right one. The second parameter is the type name for our new event function signature. We add an instance of this type to our class. The Unreal documentation suggests <kbd>On&lt;x&gt;</kbd> as a naming convention.</p>
<p>When something overlaps our <kbd>TriggerVolume</kbd>, we call <kbd>Broadcast()</kbd> on our own event instance. Inside the new class, we create a point light as a visual representation of the event being triggered.</p>
<p>We also create a pointer to <kbd>TriggerVolume</kbd> to listen to events. We mark the <kbd>UPROPERTY</kbd> as <kbd>EditAnywhere</kbd>, because this allows us to set it in the Editor rather than having to acquire the reference programmatically using <kbd>GetAllActorsOfClass</kbd> or something else.</p>
<p class="mce-root"/>
<p>Last is our event handler for when something enters the <kbd>TriggerVolume</kbd>. We create and initialize our point light in the constructor as usual. When the game starts, the Listener checks that our <kbd>TriggerVolume</kbd> reference is valid, and then binds our <kbd>OnTriggerEvent</kbd> function to the <kbd>TriggerVolume</kbd> event. Inside <kbd>OnTriggerEvent</kbd>, we change our light's color to green. When something enters <kbd>TriggerVolume</kbd>, it causes <kbd>TriggerVolume</kbd> to call a broadcast on its own event. Our <kbd>TriggerVolEventListener</kbd> then has its bound method invoked, changing our light's color.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Time of Day handler</h1>
                
            
            
                
<p>This recipe shows you how to use the concepts that were introduced in the previous recipes to create an actor that informs other actors of the passage of time within your game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>Actor</kbd> class called <kbd>TimeOfDayHandler</kbd>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/67f4437f-f3c4-481a-88de-3544020d0d69.png"/></p>
<p class="mce-root"/>
<ol start="2">
<li>Add a multicast delegate declaration to the header:</li>
</ol>
<pre style="padding-left: 60px"><strong>DECLARE_MULTICAST_DELEGATE_TwoParams(FOnTimeChangedSignature, int32, <br/>                                     int32)</strong><br/>UCLASS()<br/>class CHAPTER_05_API ATimeOfDayHandler : public AActor</pre>
<ol start="3">
<li>Add an instance of our delegate to the class declaration in the <kbd>public</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">FOnTimeChangedSignature OnTimeChanged; </pre>
<ol start="4">
<li>Add the following properties to the class:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY() 
int32 TimeScale; 
 
UPROPERTY() 
int32 Hours; <br/>UPROPERTY() 
int32 Minutes; 
 
UPROPERTY() 
float ElapsedSeconds; </pre>
<ol start="5">
<li>Add the initialization of these properties to the constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>ATimeOfDayHandler::ATimeOfDayHandler()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn this   <br/>   //  off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/><strong>    TimeScale = 60;</strong><br/><strong>    Hours = 0;</strong><br/><strong>    Minutes = 0;</strong><br/><strong>    ElapsedSeconds = 0;</strong><br/>}</pre>
<ol start="6">
<li>Inside <kbd>Tick</kbd>, add the following code:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void ATimeOfDayHandler::Tick(float DeltaTime)<br/>{<br/>    Super::Tick(DeltaTime);<br/><br/><strong>    ElapsedSeconds += (DeltaTime * TimeScale);</strong><br/><br/><strong>    if(ElapsedSeconds &gt; 60)</strong><br/><strong>    {</strong><br/><strong>        ElapsedSeconds -= 60;</strong><br/><strong>        Minutes++;</strong><br/><br/><strong>        if (Minutes &gt; 60)</strong><br/><strong>        {</strong><br/><strong>            Minutes -= 60;</strong><br/><strong>            Hours++;</strong><br/><strong>        }</strong><br/><br/><strong>        OnTimeChanged.Broadcast(Hours, Minutes);</strong><br/><strong>    }</strong><br/><br/>}</pre>
<ol start="7">
<li>Create a new <kbd>Actor</kbd> class called <kbd>Clock</kbd>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/45d5f742-3133-4c83-8c99-94081faaf7de.png"/></p>
<ol start="8">
<li>Add the following properties to the class header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "Clock.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_05_API AClock : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    AClock();<br/><br/><strong>    UPROPERTY()</strong><br/><strong>    USceneComponent* RootSceneComponent;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UStaticMeshComponent* ClockFace;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    USceneComponent* HourHandle;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UStaticMeshComponent* HourHand;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    USceneComponent* MinuteHandle;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UStaticMeshComponent* MinuteHand;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void TimeChanged(int32 Hours, int32 Minutes);</strong><br/><br/><strong>    FDelegateHandle MyDelegateHandle;</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<ol start="9">
<li>Initialize and transform the components in the constructor:</li>
</ol>
<pre style="padding-left: 60px">#include "TimeOfDayHandler.h"<br/>#include "Kismet/GameplayStatics.h"<br/><br/>// Sets default values<br/>AClock::AClock()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    RootSceneComponent = CreateDefaultSubobject&lt;USceneComponent&gt;("RootSceneComponent");<br/>    ClockFace = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("ClockFace"); <br/>    HourHand = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("HourHand"); <br/>    MinuteHand = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("MinuteHand"); <br/>    HourHandle = CreateDefaultSubobject&lt;USceneComponent&gt;("HourHandle"); <br/>    MinuteHandle = CreateDefaultSubobject&lt;USceneComponent&gt;("MinuteHandle"); <br/>    <br/>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Cylinder.Cylinder'")); <br/><br/>    if (MeshAsset.Object != nullptr)<br/>    {<br/>        ClockFace-&gt;SetStaticMesh(MeshAsset.Object);<br/>        HourHand-&gt;SetStaticMesh(MeshAsset.Object);<br/>        MinuteHand-&gt;SetStaticMesh(MeshAsset.Object);<br/>    }<br/><br/>    RootComponent = RootSceneComponent;<br/><br/>    HourHand-&gt;AttachToComponent(HourHandle, <br/>                     FAttachmentTransformRules::KeepRelativeTransform);<br/><br/>    MinuteHand-&gt;AttachToComponent(MinuteHandle, <br/>                     FAttachmentTransformRules::KeepRelativeTransform);<br/><br/>    HourHandle-&gt;AttachToComponent(RootSceneComponent, <br/>                     FAttachmentTransformRules::KeepRelativeTransform);<br/><br/>    MinuteHandle-&gt;AttachToComponent(RootSceneComponent, <br/>                     FAttachmentTransformRules::KeepRelativeTransform);<br/><br/>    ClockFace-&gt;AttachToComponent(RootSceneComponent, <br/>                     FAttachmentTransformRules::KeepRelativeTransform);<br/><br/>    ClockFace-&gt;SetRelativeTransform(FTransform(FRotator(90, 0, 0), <br/>                                    FVector(10, 0, 0), <br/>                                    FVector(2, 2, 0.1)));<br/><br/>    HourHand-&gt;SetRelativeTransform(FTransform(FRotator(0, 0, 0), <br/>                                   FVector(0, 0, 25), <br/>                                   FVector(0.1, 0.1, 0.5)));<br/><br/>    MinuteHand-&gt;SetRelativeTransform(FTransform(FRotator(0, 0, 0), <br/>                                     FVector(0, 0, 50), <br/>                                     FVector(0.1, 0.1, 1)));<br/><br/>}</pre>
<ol start="10">
<li>Add the following code to <kbd>BeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void AClock::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/><strong>    TArray&lt;AActor*&gt; TimeOfDayHandlers;<br/></strong><br/><strong>    UGameplayStatics::GetAllActorsOfClass(GetWorld(), <br/>                                      ATimeOfDayHandler::StaticClass(), <br/>                                          TimeOfDayHandlers);<br/></strong><br/><strong>    if (TimeOfDayHandlers.Num() != 0)</strong><br/><strong>    {</strong><br/><strong>        auto TimeOfDayHandler = Cast&lt;ATimeOfDayHandler&gt;<br/>        (TimeOfDayHandlers[0]);</strong><br/><strong>        MyDelegateHandle =  <br/>        TimeOfDayHandler-&gt;OnTimeChanged.AddUObject(this, <br/>        &amp;AClock::TimeChanged);</strong><br/><strong>    }</strong><br/><strong>    </strong><br/>}</pre>
<ol start="11">
<li>Lastly, implement <kbd>TimeChanged</kbd> as your event handler:</li>
</ol>
<pre style="padding-left: 60px">void AClock::TimeChanged(int32 Hours, int32 Minutes)<br/>{<br/>    HourHandle-&gt;SetRelativeRotation(FRotator(0, 0, 30 * Hours));<br/>    MinuteHandle-&gt;SetRelativeRotation(FRotator(0, 0, 6 * Minutes));<br/>}</pre>
<p class="mce-root"/>
<ol start="12">
<li>Place an instance of <kbd>TimeOfDayHandler</kbd> and the <kbd>AClock</kbd> into your level. Then, play it to see the hands on the clock rotate:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5441e608-52a9-4943-b354-09481e9006cb.png" style="width:32.92em;height:15.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>TimeOfDayHandler</kbd> contains a delegate that takes two parameters, hence the use of the <kbd>TwoParams</kbd> variant of the macro. Our class contains variables to store hours, minutes, and seconds, as well as <kbd>TimeScale</kbd>, which is an acceleration factor that's used to speed up time for testing purposes. Inside the handler's <kbd>Tick</kbd> function, we accumulate elapsed seconds based on the time elapsed since the last frame. We check if the elapsed seconds have gone over 60. If so, we subtract 60, and increment <kbd>Minutes</kbd>. The same happens with <kbd>Minutes</kbd>: if they go over 60, we subtract 60, and increment <kbd>Hours</kbd>. If <kbd>Minutes</kbd> or <kbd>Hours</kbd> was updated, we broadcast our delegate to let any object that has subscribed to the delegate know that the time has changed. </p>
<p class="mce-root">The <kbd>Clock</kbd> actor uses a series of Scene components and Static meshes to build a mesh hierarchy that resembles a clock face. In the <kbd>Clock</kbd> constructor, we parent the components in the hierarchy and set their initial scale and rotations. In <kbd>BeginPlay</kbd>, the clock uses <kbd>GetAllActorsOfClass()</kbd> to fetch all of the time of day handlers in the level. If there's at least one <kbd>TimeOfDayHandler</kbd> in the level, the <kbd>Clock</kbd> accesses the first one, and subscribes to its <kbd>TimeChanged</kbd> event. When the <kbd>TimeChanged</kbd> event fires, the clock rotates the hour and minute hands based on how many hours and minutes the time is currently set at.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a respawning pickup for a First Person Shooter</h1>
                
            
            
                
<p>This recipe shows you how to create a placeable pickup that will respawn after a certain amount of time, suitable as an ammo or other pickup for a <strong>First Person Shooter</strong> (<strong>FPS</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>Actor</kbd> class called <kbd>Pickup</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/228a0cbd-6875-46c2-b5e4-3a5a883b9a4a.png"/></p>
<ol start="2">
<li>Declare the following delegate type in <kbd>Pickup.h</kbd>:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_DELEGATE(FPickedupEventSignature) </pre>
<ol start="3">
<li>Add the following properties to the class header:</li>
</ol>
<pre style="padding-left: 60px">// Fill out your copyright notice in the Description page of Project Settings.<br/><br/>#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "GameFramework/RotatingMovementComponent.h"</strong><br/>#include "Pickup.generated.h"<br/><br/>DECLARE_DELEGATE(FPickedupEventSignature)<br/>UCLASS()<br/>class CHAPTER_05_API APickup : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    APickup();<br/><br/><strong>    virtual void NotifyActorBeginOverlap(AActor* OtherActor) <br/>    override;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UStaticMeshComponent* MyMesh;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    URotatingMovementComponent* RotatingComponent;</strong><br/><br/><strong>    FPickedupEventSignature OnPickedUp;</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};<br/><br/></pre>
<ol start="4">
<li>The class will be using the <kbd>ConstructorHelpers</kbd> struct, so we need to add the following <kbd>#include</kbd> to the <kbd>Pickup.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "ConstructorHelpers.h"</pre>
<ol start="5">
<li>Add the following code to the constructor:</li>
</ol>
<pre style="padding-left: 60px">// Sets default values<br/>APickup::APickup()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this  <br/>   // off to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>    <strong>MyMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("MyMesh");</strong><br/><br/><strong>    RotatingComponent = <br/>    CreateDefaultSubobject&lt;URotatingMovementComponent&gt;<br/>    ("RotatingComponent");</strong><br/><strong>    RootComponent = MyMesh;</strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));</strong><br/><br/><strong>    if (MeshAsset.Object != nullptr)</strong><br/><strong>    {</strong><br/><strong>        MyMesh-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>    }</strong><br/><br/><strong>    MyMesh-&gt;SetCollisionProfileName(TEXT("OverlapAllDynamic"));</strong><br/><strong>    RotatingComponent-&gt;RotationRate = FRotator(10, 0, 10);</strong><br/>}</pre>
<ol start="6">
<li>Implement the overridden <kbd>NotifyActorBeginOverlap</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void APickup::NotifyActorBeginOverlap(AActor* OtherActor)<br/>{<br/>    OnPickedUp.ExecuteIfBound();<br/>}</pre>
<ol start="7">
<li>Create a second <kbd>Actor</kbd> class called <kbd>PickupSpawner</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/033b1225-911b-43b4-aa47-c543e95f44b4.png"/></p>
<ol start="8">
<li>Add the following code to the class header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Pickup.h"</strong><br/>#include "PickupSpawner.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_05_API APickupSpawner : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    APickupSpawner();<br/><br/>   <strong> UPROPERTY() </strong><br/><strong>    USceneComponent* SpawnLocation; </strong><br/><strong>    </strong><br/><strong>    UFUNCTION() </strong><br/><strong>    void PickupCollected(); </strong><br/><strong>    </strong><br/><strong>    UFUNCTION() </strong><br/><strong>    void SpawnPickup(); </strong><br/><strong>    </strong><br/><strong>    UPROPERTY() </strong><br/><strong>    APickup* CurrentPickup; </strong><br/><strong>    </strong><br/><strong>    FTimerHandle MyTimer;</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};<br/><br/></pre>
<ol start="9">
<li>Initialize our root component in the constructor:</li>
</ol>
<pre style="padding-left: 60px">SpawnLocation = <br/> CreateDefaultSubobject&lt;USceneComponent&gt;("SpawnLocation");</pre>
<ol start="10">
<li>Spawn a pickup when gameplay starts with the <kbd>SpawnPickup</kbd> function in <kbd>BeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Called when the game starts or when spawned<br/>void APickupSpawner::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    SpawnPickup();<br/><br/>}</pre>
<ol start="11">
<li>Implement <kbd>PickupCollected</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void APickupSpawner::PickupCollected()<br/>{<br/>    GetWorld()-&gt;GetTimerManager().SetTimer(MyTimer, <br/>                                           this, <br/>                                          &amp;APickupSpawner::SpawnPickup, <br/>                                          10, <br/>                                          false);<br/><br/>    CurrentPickup-&gt;OnPickedUp.Unbind();<br/>    CurrentPickup-&gt;Destroy();<br/>}</pre>
<ol start="12">
<li>Create the following code for <kbd>SpawnPickup</kbd>:</li>
</ol>
<pre>void APickupSpawner::SpawnPickup()<br/>{<br/>    UWorld* MyWorld = GetWorld();<br/><br/>    if (MyWorld != nullptr) <br/>    {<br/>        CurrentPickup = MyWorld-&gt;SpawnActor&lt;APickup&gt;( <br/>                                                APickup::StaticClass(), <br/>                                                     GetTransform());<br/><br/>        CurrentPickup-&gt;OnPickedUp.BindUObject(this, <br/>                                     &amp;APickupSpawner::PickupCollected);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="13">
<li>Compile and launch the editor, and then drag an instance of <kbd>PickupSpawner</kbd> out into the level. Walk into the pickup that's represented by the spinning cube and verify that it spawns again 10 seconds later:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b42458a5-3e4d-4621-a7a9-c0b284280dff.png"/></p>
<p>The result of completing the recipe</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As usual, we need to create a delegate inside our <kbd>Pickup</kbd> that our Spawner can subscribe to so that it knows when the player collects the pickup. The <kbd>Pickup</kbd> also contains a Static mesh as a visual representation, and a <kbd>RotatingMovementComponent</kbd> so that the mesh will spin as a way to attract the attention of the players. Inside the <kbd>Pickup</kbd> constructor, we load one of the engine's inbuilt meshes as our visual representation. We specify that the mesh will overlap with other objects, then set the rotation rate of our mesh at 10 units per second in the <em>X</em> and <em>Z</em> axes. When the player overlaps the <kbd>Pickup</kbd>, it fires off its <kbd>PickedUp</kbd> delegate from the first step.</p>
<p>The <kbd>PickupSpawner</kbd> used</p>
<p>a Scene component to specify where to spawn the pickup actor. It has a function for doing so, and a tagged <kbd>UPROPERTY</kbd> reference to the currently spawned <kbd>Pickup</kbd>. In the <kbd>PickupSpawner</kbd> constructor, we initialize our components as always. When play begins, the Spawner runs its <kbd>SpawnPickup</kbd> function. This function spawns an instance of our <kbd>Pickup</kbd>, then binds <kbd>APickupSpawner::PickupCollected</kbd> to the <kbd>OnPickedUp</kbd> function on the new instance. It also stores a reference to that current instance.</p>
<p>When <kbd>PickupCollected</kbd> runs after the player has overlapped the <kbd>Pickup</kbd>, a timer is created to respawn the pickup after 10 seconds. The existing delegate binding to the collected pickup is removed, and then the pickup is destroyed. After 10 seconds, the timer fires, running <kbd>SpawnActor</kbd> again, which creates a new <kbd>Pickup</kbd>.</p>


            

            
        
    </body></html>