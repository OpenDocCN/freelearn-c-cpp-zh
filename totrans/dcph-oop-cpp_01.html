<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Understanding Basic C++ Assumptions</h1>
<p>This chapter will briefly identify the basic language syntax, constructs, and features of C++, which you are assumed to have from familiarity either with the basic syntax of C++, C, Java, or similar languages. These core language features will be reviewed concisely. If these basic syntax skills are not familiar to you after completing this chapter, please first take the time to explore a more basic syntax-driven C++ text before continuing with this book. The goal of this chapter is not to teach each of the assumed skills in detail but to briefly provide a synopsis of each basic language feature to allow you to quickly recall a skill that should already be in your programming repertoire.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Basic language syntax</li>
<li>Basic I/O</li>
<li>Control structures, statements, and looping</li>
<li>Operators</li>
<li>Function basics</li>
<li>User defined type basics</li>
<li>Namespace basics</li>
</ul>
<p>By the end of this chapter, you’ll have a succinct review of the very basic C++ language skills in which you’re assumed to be proficient. These skills will be necessary in order to move forward with the next chapter successfully. Because most of these features do not utilize OO features of C++, I will refrain from using OO terminology (as much as possible) and will instead introduce appropriate OO terminology when we move into the OO sections of this book.</p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>Please ensure that you have a current C++ compiler available; you’ll want to try many of the online code examples. Minimally, please download g++ from <a href="https://gcc.gnu.org">https://gcc.gnu.org</a>.</p>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in <a href="B19087_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Basic C++ Assumptions</em>, can be found in the subdirectory <code>Chapter01</code> in a file named <code>Chp1-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The <strong class="bold">Code in Action</strong> (<strong class="bold">CiA</strong>) video for this chapter can be viewed at: <a href="https://bit.ly/3PtOYjf">https://bit.ly/3PtOYjf</a><a href="https://bit.ly/3c6oQdK.%0D"/></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Reviewing basic C++ language syntax</h1>
<p>In this section, we <a id="_idIndexMarker000"/>will briefly review basic C++ syntax. We’ll assume that you are either a C++ programmer with non-OO programming skills, or that you’ve programmed in C, Java, or a similar strongly typed checked language with related syntax. You may also be a long-standing professional programmer who is able to pick up another language’s basics quickly. Let’s begin our brief review.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Comment styles</h2>
<p>Two styles<a id="_idIndexMarker001"/> of comments are available in C++:</p>
<ul>
<li>The <code>/*   */</code> style provides for comments spanning multiple lines of code. This style may not be nested with other comments of this same style.</li>
<li>The <code>//</code> style of comment provides for a simple comment to the end of the current line.</li>
</ul>
<p>Using the two comment styles together can allow for nested comments, which can be useful when debugging code<a id="_idTextAnchor021"/>.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Variable declarations and standard data types</h2>
<p>Variables <a id="_idIndexMarker002"/>may <a id="_idIndexMarker003"/>be of any length, and may consist of letters, digits, and underscores. Variables are case sensitive and must begin with a letter or an underscore. Standard data types in C++ include the following:</p>
<ul>
<li><code>int</code>: To store whole numbers</li>
<li><code>float</code>: To store floating point values</li>
<li><code>double</code>: To store double precision floating point values</li>
<li><code>char</code>: To store a single character</li>
<li><code>bool</code>: For boolean values of <code>true</code> or <code>false</code></li>
</ul>
<p>Here are a few straightforward examples using the aforementioned standard data types: </p>
<pre class="source-code">
int x = 5;
int a = x;
float y = 9.87; 
float y2 = 10.76f;  // optional 'f' suffix on float literal
float b = y;
double yy = 123456.78;
double c = yy;
char <a id="_idTextAnchor023"/>z = 'Z';
char d = z;
bool test = true;
bool e = test;
bool f = !test;</pre>
<p>Reviewing the previous fragment of code, note that a variable can be assigned a literal value, such as <code>int x = 5;</code> or that a variable may be assigned the value or contents of another variable, such as <code>int a = x;</code>. These examples illustrate this ability with various standard data types. Note that for the <code>bool</code> type, the value can be set to <code>true</code> or <code>false</code>, or to <a id="_idIndexMarker004"/>the <a id="_idIndexMarker005"/>opposite of one of those values using <code>!</code> (not).</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Variables and array basics</h2>
<p>Arrays can be<a id="_idIndexMarker006"/> declared <a id="_idIndexMarker007"/>of any data type. The array name represents the starting address of the contiguous memory associated with the array’s contents. Arrays are zero-based in C++, meaning they are indexed starting with array <code>element[0]</code> rather than array <code>element[1]</code>. Most importantly, range checking is not performed on arrays in C++; if you access an element outside the size of an array, you are accessing memory belonging to another variable, and your code will likely fault very soon. </p>
<p>Let’s review some simple array declarations (some with initialization), and an assignment: </p>
<pre class="source-code">
char name[10] = "Dorothy"; // size is larger than needed
float grades[20];  // array is not initialized; caution!
grades[0] = 4.0;  // assign a value to one element of array
float scores[] = {3.3, 4.3, 4.0, 3.7}; // initialized array</pre>
<p>Notice that the first array, <code>name</code>, contains 10 <code>char</code> elements, which are initialized to the seven characters in the string literal <a id="_idTextAnchor025"/><code>"Dorothy"</code>, followed by the null character (<code>'</code><code>\0'</code>). The array currently has two unused elements at the end. The elements in the array can be accessed individually using <code>name[0]</code> through <code>name[9]</code>, as arrays in C++ are zero-based. Similarly, the array above, which is identified by the variable <code>grades</code>, has 20 elements, none of which are initialized. Any array value accessed prior to initialization or assignment can contain any value; this is true for any uninitialized variable. Notice that just after the array <code>grades</code> is declared, its 0th element is assigned a value of <code>4.0</code>. Finally, notice that the array of <code>float</code>, <code>scores</code>, is declared and initialized with values. Though we could have specified an array size within the <code>[]</code> pair, we did not – the compiler is able to calculate the size based upon the number of elements in our initialization. Initializing an array when possible (even using zeros), is always the safest style to utilize.</p>
<p>Arrays of characters are often conceptualized as strings. Many standard string functions exist in libraries such as <code>&lt;cstring&gt;</code>. Arrays of characters should be null-terminated if they are to be treated as strings. When arrays of characters are initialized with a string of characters, the null character is added automatically. However, if characters are added one by one to the array via assignment, it would then be the programmer’s job to add the null character (<code>'\0'</code>) as the final element in the array. </p>
<p>In addition to strings implemented using arrays of characters (or a pointer to characters), there is a safer data type from the C++ Standard Library, <code>std::string</code>. We will understand the details of this type once we master classes in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>; however, let us introduce <code>string</code> now as an easier and less error-prone way to create strings of characters. You will need to understand both representations; the array of <code>char</code> (and pointer to <code>char</code>) implementations will inevitably <a id="_idIndexMarker008"/>appear in C++ library and other existing code. Yet you <a id="_idIndexMarker009"/>may prefer <code>string</code> in new code for its ease and safety.</p>
<p>Let’s see some basic examples:</p>
<pre class="source-code">
// size of array can be calculated by initializer
char book1[] = "C++ Programming"; 
char book2[25];  // this string is uninitialized; caution!
// use caution as to not overflow destination (book2)
strc<a id="_idTextAnchor026"/>py(book2, "OO Programming with C++"); 
strcmp(book1, book2);
length = strlen(book2);
strin<a id="_idTextAnchor027"/>g book3 = "Advanced C++ Programming";  // safer usage
string book4("OOP with C++"); // alt. way to init. string
string book5(book4); // create book5 using book4 as a basis</pre>
<p>Here, the first variable <code>book1</code> is declared and initialized to a string literal of <code>"C++ P<a id="_idTextAnchor028"/>rogramming"</code>; the size of the array will be calculated by the length of the quoted string value plus one for the null character (<code>'\0'</code>). Next, variable <code>book2</code> is declared to be an array of <code>25</code> characters in length, but is not initialized with a value. Next, the function <code>strcpy()</code> from <code>&lt;cstring&gt;</code> is used to copy the string literal <code>"OO Programming with C++"</code> into the variable <code>book2</code>. Note that <code>strcpy()</code> will automatically add the null-terminating character to the destination string. On the next line, <code>strcmp()</code>, also from <code>&lt;cstring&gt;</code>, is used to lexicographically compare the contents of variables <code>book1</code> and <code>book2</code>. This function returns an integer value, which can be captured in another variable or used in a comparison. Lastly, the function <code>strlen()</code> is used to count the number of characters in <code>book2</code> (excluding the null character).</p>
<p>Lastly, notice that <code>book3</code> and <code>book4</code> are each of type <code>string</code>, illustrating two different manners to initialize a string. Also notice that <code>book5</code> is initialized using <code>book4</code> as a basis. As we will soon discover, there are many safety features built into the <code>string</code> class to promote safe string usage. Though we have reviewed examples featuring two of several manners to represent strings (a native array of characters versus the string class), we will most often utilize <code>std::string</code> for its safety. Nonetheless, we have now seen various functions, such as <code>strcpy()</code> and <code>strlen()</code>, that operate on native C++ strings (as we will inevitably come across them in existing code). It is important to note that the C++ community is moving away from native C++ strings – that is, those implemented using an array of (or pointer to) characters.</p>
<p>Now that we have <a id="_idIndexMarker010"/>successfully reviewed basic C++ language features <a id="_idIndexMarker011"/>such as comment styles, variable declarations, standard data types, and array basics, let’s move forward to recap another fundamental language feature of C++: basic keyboard input and output using the <code>&lt;iostream&gt;</code> library.</p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor029"/>Recapping basic I/O</h1>
<p>In this<a id="_idIndexMarker012"/> section, we’ll briefly review simple character-based input and output with the keyboard and monitor. Simple manipulators will also be reviewed to both explain the underlying mechanics of I/O buffers and to provide basic enhancements and formatting.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>The iostream library</h2>
<p>One of the<a id="_idIndexMarker013"/> easiest<a id="_idIndexMarker014"/> mechanisms for input and output in C++ is the use of the <code>&lt;iostream&gt;</code> library. The header file <code>&lt;iostream&gt;</code> contains definitions of data <a id="_idIndexMarker015"/>types <code>cin</code>, <code>cout</code>, <code>cerr</code>, and <code>clog</code>, are incorporated by including the <code>std</code> namespace. The <code>&lt;iostream&gt;</code> library facilitates simple I/O and can be used as follows:</p>
<ul>
<li><code>cin</code> can be used in conjunction with the extraction operator <code>&gt;&gt;</code> for buffered input</li>
<li><code>cout</code> can be used in conjunction with the insertion operator <code>&lt;&lt;</code> for buffered output</li>
<li><code>cerr</code> (unbuffered) and <code>clog</code> (buffered) can also be used in conjunction with the insertion operator, but for errors</li>
</ul>
<p>Let’s review an example showca<a id="_idTextAnchor031"/>sing simple I/O: </p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using<a id="_idTextAnchor032"/> namespace std;  // we'll limit the namespace shortly
int main()
{
    char name[20];  // caution, uninitialized array of char
    int age = 0;
    <strong class="bold">cout</strong> &lt;&lt; "Please enter a name and an age: ";
    <strong class="bold">cin</strong> &gt;&gt; name &gt;&gt; age; // caution, may overflow name var.
    <strong class="bold">cout</strong> &lt;&lt; "Hello " &lt;&lt; name;
    <strong class="bold">cout</strong> &lt;&lt; ". You are " &lt;&lt; ag<a id="_idTextAnchor033"/>e &lt;&lt; " years old." &lt;&lt; endl;
    return 0;
}</pre>
<p>F<a id="_idTextAnchor034"/>irst, we include the <code>&lt;iostream&gt;</code> library and indicate that we’re using the <code>std</code> namespace to gain usage of <code>cin</code> and <code>cout</code> (more on namespaces later in this chapter). Next, we introduce the <code>main()</code> function, which is the entry point in our application. Here, we declare two variables, <code>name</code> and <code>age</code>, neither of which is initialized. Next, we prompt the user for input by placing the string <code>"Please enter a name and an age: "</code> in the buffer associated with <code>cout</code>. When the buffer associated with <code>cout</code> is flushed, the user will see this prompt on the screen. </p>
<p>The keyboard input string is then placed in the buffer associated with <code>cout</code> using the extraction operator <code>&lt;&lt;</code>. Conveniently, one mechanism that automatically flushes the buffer associated with <code>cout</code> is the use of <code>cin</code> to read keyboard input into variables, such as seen on the next line, where we read the user input into the variables <code>name</code> and <code>age</code>, respectively.</p>
<p>Next, we print out a greeting of <code>"Hello"</code> to the user, followed by the name entered, followed by an indication of their age, gathered from the second piece of user input. The <code>endl</code> at the end of this line both places a newline character <code>'\n'</code> into the output buffer and ensures that the output buffer is flushed – more of that next. The <code>return 0;</code> declaration<a id="_idIndexMarker017"/> simply <a id="_idIndexMarker018"/>returns a program exit status to the programming shell, in this case, the value <code>0</code>. Notice that the <code>main()</code> function indicates an <code>int</code> for a return value to ensure<a id="_idTextAnchor035"/> this is possible.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor036"/>Basic iostream manipulators</h2>
<p>Often, it is<a id="_idIndexMarker019"/> desirable <a id="_idIndexMarker020"/>to be able to manipulate the contents of the buffers associated with <code>cin</code>, <code>cout</code>, and <code>cerr</code>. Manipulators allow the internal state of these objects to be modified, which affects how their associated buffers are formatted and manipulated. Manipulators are defined in the <code>&lt;iomanip&gt;</code> header file. Common manipulator examples in<a id="_idTextAnchor037"/>clude the following:</p>
<ul>
<li><code>endl</code>: Places a newline character (<code>'\n'</code>) in the buffer associated with <code>cout</code> then flushes the buffer</li>
<li><code>flush</code>: Clears the contents of the output stream</li>
<li><code>setprecision(int)</code>: Defines the precision (number of digits) used to output floating point numbers</li>
<li><code>setw(int)</code>: Sets the width for input and output</li>
<li><code>ws</code>: Removes whitespace characters from the buffer</li>
</ul>
<p>Let’s see a simple example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    char name[20];     // caution; uninitialized array
    float gpa = 0.0;   // grade point average
    cout &lt;&lt; "Please enter a name and a gpa: "; 
    cin &gt;&gt; <strong class="bold">setw(20)</strong> &gt;&gt; name &gt;&gt; gpa;  // won't overflow nam<a id="_idTextAnchor038"/>e
    cout &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; <strong class="bold">flush</strong>;
    cout &lt;&lt; ". GPA is: " &lt;&lt; <strong class="bold">setprecision(3)</strong> &lt;&lt; gpa &lt;&lt; <strong class="bold">endl</strong>;
    return 0;
}</pre>
<p>In this example, first, notice <a id="_idIndexMarker021"/>the<a id="_idIndexMarker022"/> inclusion of the <code>&lt;iomanip&gt;</code> header file. Also, notice that <code>setw(20)</code> is used to ensure that we do not overflow the name variable, which is only 20 characters long; <code>setw()</code> will automatically deduct one from the size provided to ensure there is room for the null character. Notice that <code>flush</code> is used on the second output line – it’s not necessary here to flush the output buffer; this manipulator merely demonstrates how a <code>flush</code> may be applied. On the last output line with <code>cout</code>, notice that <code>setprecision(3)</code> is used to print the floating point <code>gpa</code>. Three points of precision account for the decimal point plus two places to the right of the decimal. Finally, notice that we add the <code>endl</code> manipulator to the buffer associated with <code>cout</code>. The <code>endl</code> manipulator will first insert a newline character (<code>'\n'</code>) into the buffer and then flush the buffer. For performance, if you don’t need a buffer flush to immediately see the output, using a newline character al<a id="_idTextAnchor039"/>one is more efficient.</p>
<p>Now that we <a id="_idIndexMarker023"/>have <a id="_idIndexMarker024"/>reviewed simple input and output using the <code>&lt;iostream&gt;</code> library, let’s move forward by briefly reviewing control structures, statements, and looping constructs.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor040"/>Revisiting control structures, statements, and looping</h1>
<p>C++ has a variety of control structures and looping constructs that allow for non-sequential program flow. Each can be coupled with simple or compound statements. Simple statements end with a semicolon; more compound statements are enclosed in a block of code using a pair of brackets <code>{}</code>. In this section, we will be revisiting various types of control structures (<code>if</code>, <code>else if</code>, and <code>else</code>), and looping constructs (<code>while</code>, <code>do while</code>, and <code>for</code>) to recap simple methods for non-sequential progr<a id="_idTextAnchor041"/>am flow within our code.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor042"/>Control structures – if, else if, and else</h2>
<p>Conditional<a id="_idIndexMarker025"/> statements <a id="_idIndexMarker026"/>using <code>if</code>, <code>else if</code>, and <code>else</code> can<a id="_idIndexMarker027"/> be<a id="_idIndexMarker028"/> used with simple statements or a block of statements. Note that an <code>if</code> clause can be used without a following <code>else if</code> or <code>else</code> clause. Actually, <code>else if</code> is real<a id="_idTextAnchor043"/>ly a condensed version of an <code>else</code> clause with a nested <code>if</code> clause inside of it. Practically speaking, developers flatten the nested use into <code>else if</code> format for readability <a id="_idTextAnchor044"/>and to save excess indenting. Let’s see an example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
<a id="_idTextAnchor045"/>{
    int x = 0;
    cout &lt;&lt; "Enter an integer: ";
    cin &gt;&gt; x;
    <strong class="bold">if (x == 0)</strong> 
        cout &lt;&lt; "x is 0" &lt;&lt; endl;
    <strong class="bold">else if (x &lt; 0)</strong>
 <a id="_idTextAnchor046"/>       cout &lt;&lt; "x is negative" &lt;&lt; endl;
    <strong class="bold">else</strong>
    {
        cout &lt;&lt; "x is positive";
      <a id="_idTextAnchor047"/>  cout &lt;&lt; "and ten times x is: " &lt;&lt; x * 10 &lt;&lt; endl;
    }  
    return 0;
}</pre>
<p>Notice that in<a id="_idIndexMarker029"/> the <a id="_idIndexMarker030"/>preceding <code>else</code> clause, multiple<a id="_idIndexMarker031"/> statements <a id="_idIndexMarker032"/>are bundled into a block of code, whereas in the <code>if</code> and <code>else if</code> conditions, only a single statement follows each condition. As a side note, in C++, any non-zero value is considered to be true. So, for example, testing <code>if (x)</code> would imply that <code>x</code> is not equal to zero – it would not be necessary to write <code>if (x !=0)</code>, except possibly for readability.</p>
<p>It is worth mentioning that in C++, it is wise to adopt a set of consistent coding conventions and practices (as do many teams and organizations). As a straightforward example, the placement of brackets may be specified in a coding standard (such as starting the <code>{</code> on the same line as the keyword <code>else</code>, or on the line below the keyword <code>else</code> with the number of spaces it should be indented). Another convention may be that even a single statement following an <code>else</code> keyword be included in a block using brackets. Following a consistent set of coding conventions will allow your code to be more easil<a id="_idTextAnchor048"/>y <a id="_idIndexMarker033"/>read<a id="_idIndexMarker034"/> and <a id="_idIndexMarker035"/>maintained <a id="_idIndexMarker036"/>by others.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor049"/>Looping constructs – while, do while, and for loops</h2>
<p>C++ has<a id="_idIndexMarker037"/> several<a id="_idIndexMarker038"/> looping constructs. Let’s<a id="_idIndexMarker039"/> take<a id="_idIndexMarker040"/> a moment to review a brief example for each style, starting wit<a id="_idTextAnchor050"/>h the <code>while</code> and <code>do while</code> loop constructs:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    int i = 0;
    <strong class="bold">while (i &lt; 10)</strong>
    {
        cout &lt;&lt; i &lt;&lt; endl;
        i++;
    }
    i = 0;
    <strong class="bold">do</strong> 
    {
        cout &lt;&lt; i &lt;&lt; endl;
        i++;
    } <strong class="bold">while (i &lt; 10);</strong>
    return 0;
}</pre>
<p>With the <code>while</code> loop, the condition to enter the loop must evaluate to true prior to each entry of the loop body. However, with the <code>do while</code> loop, the first entry to the loop body is guaranteed – the condition is then evaluated before another iteration through the loop body. In the preceding example, both the <code>while</code> and <code>do while</code> loops are executed 10 times, each printing values <code>0</code>-<code>9</code> for variable <code>i</code>.</p>
<p>Next, let’s review a typical <code>for</code> loop. The <code>for</code> loop has three parts within the <code>()</code>. First, there is a statement that is executed exactly once and is often used to initialize a loop control variable. Next, separated on both sides by semicolons in the center of the <code>()</code> is an expression. This expression is evaluated each time before entering the body of the loop. The body of the loop is only entered if this expression evaluates to <code>true</code>. Lastly, the third part within the <code>()</code> is a second statement. This statement is executed immediately after executing the body of the loop and is often used to modify a loop control variable. Following<a id="_idIndexMarker041"/> this<a id="_idIndexMarker042"/> second<a id="_idIndexMarker043"/> statement, the<a id="_idIndexMarker044"/> center expression is re-evaluated. Here is an example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    // though we'll prefer to declare i within the loop
    // construct, let's understand scope in both scenarios
    int i; 
    <strong class="bold">for (i = 0; i &lt; 10; i++)</strong> 
        cout &lt;&lt; i &lt;&lt; endl;
    <strong class="bold">for (int j = 0; j &lt; 10; j++)</strong>   // preferred declaration
        cout &lt;&lt; j &lt;&lt; endl;      // of loop contro<a id="_idTextAnchor051"/>l variable
    return 0;
}</pre>
<p>Here, we have two <code>for</code> loops. Prior to the first loop, variable <code>i</code> is declared. Variable <code>i</code> is then initialized with a value of <code>0</code> in statement 1 between the loop parentheses <code>()</code>. The loop condition is tested, and if <code>true</code>, the loop body is then entered and executed, followed by statement 2 being executed prior to the loop condition being retested. This loop is executed 10 times for <code>i</code> values <code>0</code> through <code>9</code>. The second <code>for</code> loop is similar, with the only difference being variable <code>j</code> is both declared and initialized within statement 1 of the loop construct. Note that variable <code>j</code> only has scope for the <code>for</code> loop itself, whereas variable <code>i</code> has scope of the entire block in which it is declared, from its declaration point forward.</p>
<p>Let’s quickly<a id="_idIndexMarker045"/> see <a id="_idIndexMarker046"/>an example using <a id="_idIndexMarker047"/>nested<a id="_idIndexMarker048"/> loops. The looping constructs can be of any type, but in the following, we’ll review nested <code>for</code> loops:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    <strong class="bold">for (int i = 0; i &lt; 10; i++)</strong> 
    {
        cout &lt;&lt; i &lt;&lt; endl;
        <strong class="bold">for (int j = 0; j &lt; 10; j++)</strong>
            cout &lt;&lt; j &lt;&lt; endl;
        cout &lt;&lt; "\n";
    }
    return 0;
}</pre>
<p>Here, the outer loop will execute ten times with <code>i</code> values of <code>0</code> through <code>9</code>. For each value of <code>i</code>, the inner loop will execute ten tim<a id="_idTextAnchor053"/>es, with <code>j</code> values of <code>0</code> through <code>9</code>. Remember, with <code>for</code> loops, the loop control variable is automatically incremented with the <code>i++</code> or <code>j++</code> within the loop construct. Had a <code>while</code> loop been used, the programmer would need to remember <a id="_idIndexMarker049"/>to<a id="_idIndexMarker050"/> increment the loop<a id="_idIndexMarker051"/> control<a id="_idIndexMarker052"/> variable in the last line of the body of each such loop. </p>
<p>Now that we have reviewed control structures, statements, and looping constructs in C++, we can move onward by briefly recalling C++’s operators.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor054"/>Reviewing C++ operators</h1>
<p>Unary, binary, and<a id="_idIndexMarker053"/> ternary operators exist in C++. C++ allows operators to have different meanings based on the context of usage. C++ also allows programmers to redefine the meaning of selected operators when used in the context of at least one user defined type. The operators are listed in the following concise list. We’ll see examples of these operators throughout the remainder of this section and throughout the course. Here is a synopsis of the binary, unary, and ternary operators in C++:</p>
<div><div><img alt="Figure 1.1 – C++ operators" height="1749" src="img/Figure_1.01_B19087.jpg" width="1261"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – C++ operators</p>
<p>In the aforementioned <a id="_idIndexMarker054"/>binary operator list, notice how many of the operators have “<em class="italic">shortcut</em>” versions when paired with the assignment operator <code>=</code>. For example, <code>a = a * b</code> can be written equivalently using a shortcut operator <code>a *= b</code>. Let’s take a look at an example that incorporates an assortment of operators, including the usage of a shortcut operator:</p>
<pre class="source-code">
score <strong class="bold">+=</strong> 5;
score<strong class="bold">++</strong>;
if (score <strong class="bold">==</strong> 100)
    cout &lt;&lt; "You have a perfect score!" &lt;&lt; endl;
else
    cout &lt;&lt; "Your score is: " &lt;&lt; score &lt;&lt; endl;
// equivalent to if - else above, but using ?: operator
(score == 100)<strong class="bold">?</strong> cout &lt;&lt; "You have a perfect score" &lt;&lt; endl<strong class="bold">:</strong>
                cout &lt;&lt; "Your score is: " &lt;&lt; score &lt;&lt; endl; </pre>
<p>In the previous code fragment, notice the use of the shortcut operator <code>+=</code>. Here, the statement <code>score += 5;</code> is equivalent to <code>score = score + 5;</code>. Next, the unary increment operator <code>++</code> is used to increment <code>score</code> by 1. Then we see the equality operator <code>==</code> to compare <code>score</code> with a value of <code>100</code>. Finally, we see an example of the ternary operator <code>?:</code> to replace a simple <code>if</code> - <code>else</code> statement. It is instructive to note that <code>?:</code> is not<a id="_idIndexMarker055"/> preferred by some programmers, yet it is always interesting to review an example of its use.</p>
<p>Now that we have very briefly recapped the operators in C++, let’s revisit function basics.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor055"/>Revisiting function basics</h1>
<p>A function identifier<a id="_idIndexMarker056"/> must begin with a letter or underscore and may also contain digits. The function’s return type, argument list, and return value are optional. The basic form of a C++ function is as follows: </p>
<pre class="source-code">
&lt;return type&gt; FunctionName (&lt;argumentType argument1, …&gt;)
{
    expression 1…N;
    &lt;return value/expression;&gt;
}</pre>
<p>Let’s review <a id="_idIndexMarker057"/>a simple function:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
<strong class="bold">int Minimum(int a, int b)</strong>
{
    if (a &lt; b)
        return a;
    else
        return b;
}
int main()
{
    int x = 0, y = 0;
    cout &lt;&lt; "Enter two integers: ";
    cin &gt;&gt; x &gt;&gt; y;
    cout &lt;&lt; "The minimum is: " &lt;&lt; <strong class="bold">Minimum(x, y)</strong> &lt;&lt; endl;
    return 0;
}</pre>
<p>In the preceding simple example, first, a function <code>Minimum()</code> is defined. It has a return type of <code>int</code> and it takes two integer arguments: formal parameters <code>a</code> and <code>b</code>. In the <code>main()</code> function, <code>Minimum()</code> is called with actual parameters <code>x</code> and <code>y</code>. The call to <code>Minimum()</code> is permitted within the <code>cout</code> statement because <code>Minimum()</code> returns an integer value; this value is passed along to the extraction operator (<code>&lt;&lt;</code>) in conjunction with printing. In fact, the string <code>"The minimum is: "</code> is first placed into the buffer associated with <code>cout</code>, followed by the return value from calling function <code>Minimum()</code>. The output buffer is then flushed by <code>endl</code> (which first places a newline character in the buffer before flushing).</p>
<p>Notice that the function is first defined in the file and then called later in the file in the <code>main()</code> function. Strong type checking is performed on the call to the function by comparing the parameter types and their usage in the call to the function’s definition. What happens, however, when the function call precedes its definition? Or if the call to the function is in a separate file from its definition?</p>
<p>In these cases, the default action is for the compiler to assume a certain <em class="italic">signature</em> to the function, such as an integer return type, and that the formal parameters will match the types of arguments in the function call. Often, the default assumptions are incorrect; when <a id="_idIndexMarker058"/>the compiler then encounters the function definition later in the file (or when another file is linked in), an error will be raised indicating that the function call and definition do not match.</p>
<p>These issues have historically been solved with a forward declaration of a function included at the top of a file where the function will be called. Forward declarations consist of the function return type, function name and types, and the number of parameters. In C++, a forward declaration has been improved upon and is instead known as a function prototype. Since there are many interesting details surrounding function prototyping, this topic will be covered in reasonable detail in the next chapter.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The specifier <code>[[nodiscard]]</code> can optionally be added to precede the return type of a function. This specifier is used to indicate that the return value from a function must not be ignored – that is, it must be captured in a variable or utilized in an expression. Should the function’s return value consequently be ignored, a compiler warning will be issued. Note that the <code>nodiscard</code> qualifier can be added to the function prototype and optionally to the definition (or required in a definition if there is no prototype). Ideally, <code>nodiscard</code> should appear in both locations.</p>
<p>As we move to the object-oriented sections in this book (<a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, and beyond), we will learn that there are many more details and quite interesting features relating to functions. Nonetheless, we have sufficiently recalled the basics <a id="_idIndexMarker059"/>needed to move forward. Next, let’s<a id="_idTextAnchor056"/> continue our C++ language review with user defined types.</p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor057"/>Reviewing user defined type basics</h1>
<p>C++ offers several <a id="_idIndexMarker060"/>mechanisms to create user defined types. Bundling together like characteristics into one data type (later, we’ll also add relevant behaviors) will form the basis for an object-oriented concept known as encapsulation explored in a later section of this text. For now, let’s review the basic mechanisms to bundle together only data in <code>struct</code>, <code>class</code>, and <code>typedef</code> (to a lesser extent). We will also review enumerated types to represent lists of integers more meaningfully.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor058"/>struct</h2>
<p>A C++ structure <a id="_idIndexMarker061"/>in<a id="_idIndexMarker062"/> its simplest form can be used to collect common data elements together in a single unit. Variables may then be declared of the composite data type. The dot operator is used to access specific members of each structure variable. Here is a structure used in its most simple fashion:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
<strong class="bold">struct student</strong>
<strong class="bold">{</strong>
    string name;
    float semesterGrades[5];
    float gpa;
<strong class="bold">};</strong>
int main()
{
    <strong class="bold">student s1;</strong>
    s1.name = "George Katz";
    s1.semesterGrades[0] = 3.0;
    s1.semesterGrades[1] = 4.0;
    s1.gpa = 3.5;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl;
    return 0;        
}</pre>
<p>Stylistically, type names are typically in lowercase when using structs. In the preceding example, we declare the user defined type <code>student</code> using a <code>struct</code>. Type <code>student</code> has three fields or data members: <code>name</code>, <code>semesterGrades</code>, and <code>gpa</code>. In the <code>main()</code> function, a variable <code>s1</code> of type <code>student</code> is declared; the dot operator is used to access each of the variable’s data members. Since structs are typically not used for OO programming<a id="_idIndexMarker063"/> in C++, we’re not going to yet introduce significant OO <a id="_idIndexMarker064"/>terminology relating to their use. It’s worthy to note that in C++, the tag <code>student</code> also becomes the type name (unlike in C, where a variable declaration would need the word <code>struct</code> to precede the type).</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor059"/>typedef and “using” alias declaration</h2>
<p>A <code>typedef</code> declaration<a id="_idIndexMarker065"/> can<a id="_idIndexMarker066"/> be<a id="_idIndexMarker067"/> used<a id="_idIndexMarker068"/> to provide a more mnemonic representation for data types. In C++, the relative need for a <code>typedef</code> has been eliminated in usage with a <code>struct</code>. Historically, a <code>typedef</code> in C allowed the bundling together of the keyword <code>struct</code> and the structure tag to create a user defined type. However, in C++, as the structure tag automatically becomes the type, a <code>typedef</code> then becomes wholly unnecessary for a <code>struct</code>. Typedefs can still be used with standard types for enhanced readability in code, but in this fashion, the <code>typedef</code> is not being used to bundle together like data elements, such as with a <code>struct</code>. As a related historical note, <code>#define</code> (a preprocessor directive and macro replacement) was once used to create more mnemonic types, but <code>typedef</code> (and <code>using</code>) are certainly preferred. It’s worthy to note when viewing older code.</p>
<p>A <code>using</code> statement can be used as an alternative to a simple <code>typedef</code> to create an alias for a type, known as an <code>using</code> statement can also be used to simplify more complex types (such as providing an alias for complex declarations when using the Standard Template Library or declaring function pointers). The current trend is to favor a <code>using</code> alias-declaration to a <code>typedef</code>.</p>
<p>Let’s take a look at a simple <code>typedef</code> compared to a simple <code>using</code> alias-declaration:</p>
<pre class="source-code">
typedef float dollars; 
using money = float;</pre>
<p>In the previous declaration, the new type <code>dollars</code> can be used interchangeably with the type <code>float</code>. Likewise, the <a id="_idIndexMarker069"/>new alias <code>money</code> can also be<a id="_idIndexMarker070"/> used interchangeably <a id="_idIndexMarker071"/>with <a id="_idIndexMarker072"/>type <code>float</code>. It is not productive to demonstrate the archaic use of <code>typedef</code> with a structure, so let’s move on to the most used user defined type in C++, the <code>class</code>.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor060"/>class</h2>
<p>A <code>class</code> in its simplest<a id="_idIndexMarker073"/> form<a id="_idIndexMarker074"/> can be used nearly like a <code>struct</code> to bundle together related data into a single data type. In <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, we’ll see that a <code>class</code> is typically also used to bundle related functions together with the new data type. Grouping together data and behaviors relevant to that data is the basis of encapsulation. For now, let’s see a <code>class</code> in its simplest form, much like a <code>struct</code>:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
<strong class="bold">class Student</strong>
<strong class="bold">{</strong>
public:
    string name;
    float semesterGrades[5];
    float gpa;
<strong class="bold">};</strong>
int main()
{
    <strong class="bold">Student s1;</strong>
    s1.name = "George Katz";
    s1.semesterGrades[0] = 3.0;
    s1.sem<a id="_idTextAnchor063"/>esterGrades[1] = 4.0;
    s1.gpa = 3.5;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl;
    return 0;      
}</pre>
<p>Notice that the<a id="_idIndexMarker075"/> previous<a id="_idIndexMarker076"/> code is very similar to that used in the <code>struct</code> example. The main difference is the keyword <code>class</code> instead of the keyword <code>struct</code> and the addition of the access label <code>public:</code> at the beginning of the class definition (more on that in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a><em class="italic">, Exploring Classes in Detail</em>). Stylistically, the capitalization of the first letter in the data type, such as <code>Student</code>, is typical for classes. We’ll see that classes have a wealth more features and are the building blocks for OO programming. We’ll introduce new terminology such as <em class="italic">instance</em>, to be used rather than <em class="italic">variable</em>. However, this section is only a review of skills assumed, so we’ll need to wait to get to the exciting OO features of the language. Spoiler alert: all the wonderful things classes will be able<a id="_idIndexMarker077"/> to do also applies to <a id="_idIndexMarker078"/>structs; however, we’ll see that structs stylistically won’t be used to exemplify OO programming.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor064"/>enum and strongly-typed enum</h2>
<p>Traditional<a id="_idIndexMarker079"/> enumerated <a id="_idIndexMarker080"/>types <a id="_idIndexMarker081"/>may be <a id="_idIndexMarker082"/>used to mnemonically represent lists of integers. Unless otherwise initialized, integer values in the enumeration begin with zero and increase by one throughout the list. Two enumerated types may not utilize the same enumerator names. </p>
<p>Strongly-typed enumerated types improve upon traditional enumerated types. Strongly-typed enums default to represent lists of integers, but may be used to represent any integral type, such as <code>int</code>, <code>short</code> <code>int</code>, <code>long</code> <code>int</code>, <code>char</code>, or <code>bool</code>. The enumerators are not exported to the surrounding scope, so enumerators may be reused between types. Strongly-typed enums allow forward declarations of their type (allowing such uses as these types as arguments to functions before the enumerator declaration).</p>
<p>Let’s now see an example of traditional enums and strongly-typed enums:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
// traditional enumerated types
<strong class="bold">enum day {Sunday, Monday, Tuesday, Wednesday, Thursday,</strong>
          <strong class="bold">Friday, Saturday};</strong>
<strong class="bold">enum workDay {Mon = 1, Tues, Wed, Thurs, Fri};</strong>
// strongly-typed enumerated types can be a struct or class
<strong class="bold">enum struct WinterHoliday {Diwali, Hanukkah, ThreeKings,</strong>
  <strong class="bold">WinterSolstice, StLucia, StNicholas, Christmas, Kwanzaa};</strong>
<strong class="bold">enum class Holiday : short int {NewYear = 1, MLK, Memorial,</strong>
  <strong class="bold">Independence, Labor, Thanksgiving};</strong>
int main()
{
    <strong class="bold">day birthday = Monday;</strong>
    <strong class="bold">workDay payday = Fri;</strong>
    <strong class="bold">WinterHoliday myTradition = WinterHoliday::StNicholas;</strong>
    <strong class="bold">Holiday favorite = Holiday::NewYear;</strong>
    cout &lt;&lt; "Birthday is " &lt;&lt; birthday &lt;&lt; endl;
    cout &lt;&lt; "Payday is " &lt;&lt; payday &lt;&lt; endl;
    cout &lt;&lt; "Traditional Winter holiday is " &lt;&lt; 
             static_cast&lt;int&gt; (myTradition) &lt;&lt; endl;
    cout &lt;&lt; "Favorite holiday is " &lt;&lt; 
             static_cast&lt;short int&gt; (favorite) &lt;&lt; endl;
    return 0;      
}</pre>
<p>In the previous <a id="_idIndexMarker083"/>example, the<a id="_idIndexMarker084"/> traditional<a id="_idIndexMarker085"/> enumerated<a id="_idIndexMarker086"/> type <code>day</code> has values of <code>0</code> through <code>6</code>, starting with <code>Sunday</code>. The traditional enumerated type <code>workDay</code> has values of <code>1</code> through <code>5</code>, starting with <code>Mon</code>. Notice the explicit use of <code>Mon = 1</code> as the first item in the enumerated type has been used to override the default starting value of <code>0</code>. Interestingly, we may not repeat enumerators between two enumerated types. For that reason, you will notice that <code>Mon</code> is used as an enumerator in <code>workDay</code> because <code>Monday</code> has already been used in the enumerated type <code>day</code>. Now, when we create variables such as <code>birthday</code> or <code>p<a id="_idTextAnchor065"/>ayday</code>, we can use meaningful enumerated types to initialize or assign values, such as <code>Monday</code> or <code>Fri</code>. As meaningful as the enumerators may be within the code, please note that the values when manipulated or printed will be their corresponding integer values.</p>
<p>Moving forward to consider the strongly-typed enumerated types in the previous example, the <code>enum</code> for <code>WinterHoliday</code> is defined using a struct. Default values for the enumerators are integers, starting with the value of <code>0</code> (as with the traditional enums). However, notice that the <code>enum</code> for <code>Holiday</code> specifies the enumerators to be of type <code>short int</code>. Additionally, we choose to start the first item in the enumerated type with value <code>1</code>, rather than <code>0</code>. Notice when we print out the strongly-typed enumerators that we must cast the type using a <code>static_cast</code> to the type of the enumerator. This is because the insertion operator knows how to handle selected types, but these types do not include strongly-typed enums; therefore, we cast our enumerated type to a type understood by the insertion operator.</p>
<p>Now that we<a id="_idIndexMarker087"/> have <a id="_idIndexMarker088"/>revisited <a id="_idIndexMarker089"/>simple user<a id="_idIndexMarker090"/> defined types in C++, including <code>struct</code>, <code>typedef</code> (and <code>using</code> an alias), <code>class</code>, and <code>enum</code>, we are ready to move onward to reviewing our next language necessity, the <code>namespace</code>.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor066"/>Recapping namespace basics</h1>
<p>The <code>namespace</code> utility<a id="_idIndexMarker091"/> was added to C++ to add a scoping level beyond global scope to applications. This feature can be used to allow two or more libraries to be utilized without concern that they may contain duplicative data types, functions, or identifiers. The programmer needs to activate the desired namespace in each relevant portion of their application with the keyword <code>using</code>. Programmers can also create their own namespaces (usually for creating reusable library code) and activate each namespace as applicable. In the previous examples, we’ve seen the simple use of the <code>std</code> namespace to include <code>cin</code> and <code>cout</code>, which are instances of <code>istream</code> and <code>ostream</code> (whose definitions are found in <code>&lt;iostream&gt;</code>). Let’s review how we can create namespaces<a id="_idIndexMarker092"/> ourselves:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
<strong class="bold">// using namespace std;</strong> // Do not open entire std namespace
<strong class="bold">using std::cout;</strong>   // Instead, activate individual elements
<strong class="bold">using std::endl;</strong>   // within the namespace as needed
<strong class="bold">namespace DataTypes</strong>
<strong class="bold">{</strong>
    int total;
    class LinkList
    {  // full class definition … 
    };
    class Stack
    {  // full class definition …
    };
<strong class="bold">};</strong>
<strong class="bold">namespace AbstractDataTypes</strong>
<strong class="bold">{</strong>
    class Stack
    {  // full class definition …
    };
    class Queue
    {  // full class description …
    };
<strong class="bold">};</strong>
// Add entries to the AbstractDataTypes namespace
<strong class="bold">namespace AbstractDataTypes   </strong>
<strong class="bold">{</strong>
    int total;
    class Tree
    {  // full class definition …
    };
<strong class="bold">};</strong>
int main()
{
    <strong class="bold">using namespace AbstractDataTypes;</strong> //activate namespace
    <strong class="bold">using DataTypes::LinkList;</strong>    // activate only LinkList 
    LinkList list1;     // LinkList is found in DataTypes
    Stack stack1;    // Stack is found in AbstractDataTypes
    total = 5;       // total from active AbstractDataTypes
    <a id="_idTextAnchor067"/><strong class="bold">DataTypes::total</strong> = 85;// specify non-active mbr., total
    cout &lt;&lt; "total " &lt;&lt; total &lt;&lt; "\n";
    cout &lt;&lt; "DataTypes::total " &lt;&lt; <strong class="bold">DataTypes::total</strong>;
    cout &lt;&lt; endl;
    return 0;        
}</pre>
<p>In the second line of the preceding code (which is commented out), we notice the keyword <code>using</code> applied to indicate that we’d like to use or activate the entire <code>std</code> namespace. Preferably, on the following two lines of code, we can instead activate only the elements in the standard namespace that we will be needing, such as <code>std::cout</code> or <code>std::endl</code>. We can utilize <code>using</code> to open existing libraries (or individual elements within those libraries) that may contain useful classes; the keyword <code>using</code> activates the namespace to which a given library may belong. Next in the code, a user specified namespace is created called <code>DataTypes</code>, using the <code>namespace</code> keyword. Within this namespace exists a variable <code>total</code>, and two class definitions: <code>LinkList</code> and <code>Stack</code>. Following this namespace, a second namespace, <code>AbstractDataTypes</code>, is created and includes two class definitions: <code>Stack</code> and <code>Queue</code>. Additionally, the namespace <code>AbstractDataTypes</code> is augmented by a second occurrence of the <em class="italic">namespace</em> definition in which a variable <code>total</code> and a class definition for <code>Tree</code> are added.</p>
<p>In the <code>main()</code> function, first, the <code>AbstractDataTypes</code> namespace is opened with the <code>using</code> keyword. This activates all names in this namespace. Next, the keyword <code>using</code> is combined <a id="_idIndexMarker093"/>with the scope resolution operator (<code>::</code>) to only activate the <code>LinkList</code> class definition from the <code>DataTypes</code> namespace. Had there also been a <code>LinkList</code> class within the <code>AbstractDataType</code> namespace, the initial visible <code>LinkList</code> would now be hidden by the activation of <code>DataTypes::LinkList</code>.</p>
<p>Next, a variable of type <code>LinkList</code> is declared, whose definition comes from the <code>DataTypes</code> namespace. A variable of type <code>Stack</code> is next declared; though both namespaces have a <code>Stack</code> c<a id="_idTextAnchor068"/>lass definition, there is no ambiguity since only one <code>Stack</code> has been activated. Next, we use <code>cin</code> to read into <code>total</code>, which is active from the <code>AbstractDataTypes</code> namespace. Lastly, we use the scope resolution operator to explicitly read into <code>DataTypes::total</code>, a variable that would otherwise be hidden. One caveat to note: should two or more namespaces contain the same identifier, the one last opened<a id="_idIndexMarker094"/> will preside, hiding all previous occurrences.</p>
<p>It is considered good practice to activate only the elements of a namespace we wish to utili<a id="_idTextAnchor069"/>ze. From the aforementioned example, we can see potential ambiguity that can otherwise arise.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor070"/>Summary</h1>
<p>In this chapter, we reviewed core C++ syntax and non-OO language features to refresh your existing skill set. These features include basic language syntax, basic I/O with <code>&lt;iostream&gt;</code>, control structures/statements/looping, operator basics, function basics, simple user defined types, and namespaces. Most importantly, you are now ready to move to the next chapter, in which we will expand on some of these ideas with additional language necessities such as <code>const</code> qualified variables, understanding and using prototypes (including with default values), and function overloading.</p>
<p>The ideas in the next chapter begin to move us closer to our goal for OO programming, as many of these aggregate skills are used often and matter of factly as we move deeper into the language. It is important to remember that in C++, you can do anything, whether you mean to do so or not. There is great power in the language, and having a solid base for its many nuances and features is crucial. Over the next couple of chapters, the solid groundwork will be laid with an arsenal of non-OO C++ skills, so that we may realistically engage OO programming in C++ with a high level of understanding and success.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor071"/>Questions</h1>
<ol>
<li>Describe a situation in which <code>flush</code>, rather than <code>endl</code>, may be useful for clearing the contents of the buffer associated with <code>cout</code>.</li>
<li>The unary operator <code>++</code> can be used as a pre- or post-increment operator, such as <code>i++</code> or <code>++i</code>. Can you describe a situation in which choosing a pre- versus post-increment for <code>++</code> would have different consequences in the code?</li>
<li>Create a simple program using a <code>struct</code> or <code>class</code> to make a user defined type for <code>Book</code>. Add data members for title, author, and number of pages. Create two variables of type <code>Book</code> and use the dot operator <code>.</code> to fill in the data members for each such instance. Use <code>iostreams</code> to both prompt the user for input values, and to print each <code>Book</code> instance when complete. Use only features covered in this chapter.</li>
</ol>
</div>
<div><div></div>
</div>
</div></body></html>