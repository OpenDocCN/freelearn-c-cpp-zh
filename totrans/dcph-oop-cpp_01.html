<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Understanding Basic C++ Assumptions</h1>
<p>This chapter will briefly identify the basic language syntax, constructs, and features of C++, which you are assumed to have from familiarity either with the basic syntax of C++, C, Java, or similar languages. These core language features will be reviewed concisely. If these basic syntax skills are not familiar to you after completing this chapter, please first take the time to explore a more basic syntax-driven C++ text before continuing with this book. The goal of this chapter is not to teach each of the assumed skills in detail but to briefly provide a synopsis of each basic language feature to allow you to quickly recall a skill that should already be in your programming repertoire.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Basic language syntax</li>
<li>Basic I/O</li>
<li>Control structures, statements, and looping</li>
<li>Operators</li>
<li>Function basics</li>
<li>User defined type basics</li>
<li>Namespace basics</li>
</ul>
<p>By the end of this chapter, you’ll have a succinct review of the very basic C++ language skills in which you’re assumed to be proficient. These skills will be necessary in order to move forward with the next chapter successfully. Because most of these features do not utilize OO features of C++, I will refrain from using OO terminology (as much as possible) and will instead introduce appropriate OO terminology when we move into the OO sections of this book.</p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>Please ensure that you have a current C++ compiler available; you’ll want to try many of the online code examples. Minimally, please download g++ from <a href="https://gcc.gnu.org">https://gcc.gnu.org</a>.</p>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in <a href="B19087_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Basic C++ Assumptions</em>, can be found in the subdirectory <strong class="source-inline">Chapter01</strong> in a file named <strong class="source-inline">Chp1-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The <strong class="bold">Code in Action</strong> (<strong class="bold">CiA</strong>) video for this chapter can be viewed at: <a href="https://bit.ly/3PtOYjf">https://bit.ly/3PtOYjf</a><a href="https://bit.ly/3c6oQdK.%0D"/></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Reviewing basic C++ language syntax</h1>
<p>In this section, we <a id="_idIndexMarker000"/>will briefly review basic C++ syntax. We’ll assume that you are either a C++ programmer with non-OO programming skills, or that you’ve programmed in C, Java, or a similar strongly typed checked language with related syntax. You may also be a long-standing professional programmer who is able to pick up another language’s basics quickly. Let’s begin our brief review.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Comment styles</h2>
<p>Two styles<a id="_idIndexMarker001"/> of comments are available in C++:</p>
<ul>
<li>The <strong class="source-inline">/*   */</strong> style provides for comments spanning multiple lines of code. This style may not be nested with other comments of this same style.</li>
<li>The <strong class="source-inline">//</strong> style of comment provides for a simple comment to the end of the current line.</li>
</ul>
<p>Using the two comment styles together can allow for nested comments, which can be useful when debugging code<a id="_idTextAnchor021"/>.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Variable declarations and standard data types</h2>
<p>Variables <a id="_idIndexMarker002"/>may <a id="_idIndexMarker003"/>be of any length, and may consist of letters, digits, and underscores. Variables are case sensitive and must begin with a letter or an underscore. Standard data types in C++ include the following:</p>
<ul>
<li><strong class="source-inline">int</strong>: To store whole numbers</li>
<li><strong class="source-inline">float</strong>: To store floating point values</li>
<li><strong class="source-inline">double</strong>: To store double precision floating point values</li>
<li><strong class="source-inline">char</strong>: To store a single character</li>
<li><strong class="source-inline">bool</strong>: For boolean values of <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong></li>
</ul>
<p>Here are a few straightforward examples using the aforementioned standard data types: </p>
<pre class="source-code">
int x = 5;
int a = x;
float y = 9.87; 
float y2 = 10.76f;  // optional 'f' suffix on float literal
float b = y;
double yy = 123456.78;
double c = yy;
char <a id="_idTextAnchor023"/>z = 'Z';
char d = z;
bool test = true;
bool e = test;
bool f = !test;</pre>
<p>Reviewing the previous fragment of code, note that a variable can be assigned a literal value, such as <strong class="source-inline">int x = 5;</strong> or that a variable may be assigned the value or contents of another variable, such as <strong class="source-inline">int a = x;</strong>. These examples illustrate this ability with various standard data types. Note that for the <strong class="source-inline">bool</strong> type, the value can be set to <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, or to <a id="_idIndexMarker004"/>the <a id="_idIndexMarker005"/>opposite of one of those values using <strong class="source-inline">!</strong> (not).</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Variables and array basics</h2>
<p>Arrays can be<a id="_idIndexMarker006"/> declared <a id="_idIndexMarker007"/>of any data type. The array name represents the starting address of the contiguous memory associated with the array’s contents. Arrays are zero-based in C++, meaning they are indexed starting with array <strong class="source-inline">element[0]</strong> rather than array <strong class="source-inline">element[1]</strong>. Most importantly, range checking is not performed on arrays in C++; if you access an element outside the size of an array, you are accessing memory belonging to another variable, and your code will likely fault very soon. </p>
<p>Let’s review some simple array declarations (some with initialization), and an assignment: </p>
<pre class="source-code">
char name[10] = "Dorothy"; // size is larger than needed
float grades[20];  // array is not initialized; caution!
grades[0] = 4.0;  // assign a value to one element of array
float scores[] = {3.3, 4.3, 4.0, 3.7}; // initialized array</pre>
<p>Notice that the first array, <strong class="source-inline">name</strong>, contains 10 <strong class="source-inline">char</strong> elements, which are initialized to the seven characters in the string literal <a id="_idTextAnchor025"/><strong class="source-inline">"Dorothy"</strong>, followed by the null character (<strong class="source-inline">'</strong><strong class="source-inline">\0'</strong>). The array currently has two unused elements at the end. The elements in the array can be accessed individually using <strong class="source-inline">name[0]</strong> through <strong class="source-inline">name[9]</strong>, as arrays in C++ are zero-based. Similarly, the array above, which is identified by the variable <strong class="source-inline">grades</strong>, has 20 elements, none of which are initialized. Any array value accessed prior to initialization or assignment can contain any value; this is true for any uninitialized variable. Notice that just after the array <strong class="source-inline">grades</strong> is declared, its 0th element is assigned a value of <strong class="source-inline">4.0</strong>. Finally, notice that the array of <strong class="source-inline">float</strong>, <strong class="source-inline">scores</strong>, is declared and initialized with values. Though we could have specified an array size within the <strong class="source-inline">[]</strong> pair, we did not – the compiler is able to calculate the size based upon the number of elements in our initialization. Initializing an array when possible (even using zeros), is always the safest style to utilize.</p>
<p>Arrays of characters are often conceptualized as strings. Many standard string functions exist in libraries such as <strong class="source-inline">&lt;cstring&gt;</strong>. Arrays of characters should be null-terminated if they are to be treated as strings. When arrays of characters are initialized with a string of characters, the null character is added automatically. However, if characters are added one by one to the array via assignment, it would then be the programmer’s job to add the null character (<strong class="source-inline">'\0'</strong>) as the final element in the array. </p>
<p>In addition to strings implemented using arrays of characters (or a pointer to characters), there is a safer data type from the C++ Standard Library, <strong class="source-inline">std::string</strong>. We will understand the details of this type once we master classes in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>; however, let us introduce <strong class="source-inline">string</strong> now as an easier and less error-prone way to create strings of characters. You will need to understand both representations; the array of <strong class="source-inline">char</strong> (and pointer to <strong class="source-inline">char</strong>) implementations will inevitably <a id="_idIndexMarker008"/>appear in C++ library and other existing code. Yet you <a id="_idIndexMarker009"/>may prefer <strong class="source-inline">string</strong> in new code for its ease and safety.</p>
<p>Let’s see some basic examples:</p>
<pre class="source-code">
// size of array can be calculated by initializer
char book1[] = "C++ Programming"; 
char book2[25];  // this string is uninitialized; caution!
// use caution as to not overflow destination (book2)
strc<a id="_idTextAnchor026"/>py(book2, "OO Programming with C++"); 
strcmp(book1, book2);
length = strlen(book2);
strin<a id="_idTextAnchor027"/>g book3 = "Advanced C++ Programming";  // safer usage
string book4("OOP with C++"); // alt. way to init. string
string book5(book4); // create book5 using book4 as a basis</pre>
<p>Here, the first variable <strong class="source-inline">book1</strong> is declared and initialized to a string literal of <strong class="source-inline">"C++ P<a id="_idTextAnchor028"/>rogramming"</strong>; the size of the array will be calculated by the length of the quoted string value plus one for the null character (<strong class="source-inline">'\0'</strong>). Next, variable <strong class="source-inline">book2</strong> is declared to be an array of <strong class="source-inline">25</strong> characters in length, but is not initialized with a value. Next, the function <strong class="source-inline">strcpy()</strong> from <strong class="source-inline">&lt;cstring&gt;</strong> is used to copy the string literal <strong class="source-inline">"OO Programming with C++"</strong> into the variable <strong class="source-inline">book2</strong>. Note that <strong class="source-inline">strcpy()</strong> will automatically add the null-terminating character to the destination string. On the next line, <strong class="source-inline">strcmp()</strong>, also from <strong class="source-inline">&lt;cstring&gt;</strong>, is used to lexicographically compare the contents of variables <strong class="source-inline">book1</strong> and <strong class="source-inline">book2</strong>. This function returns an integer value, which can be captured in another variable or used in a comparison. Lastly, the function <strong class="source-inline">strlen()</strong> is used to count the number of characters in <strong class="source-inline">book2</strong> (excluding the null character).</p>
<p>Lastly, notice that <strong class="source-inline">book3</strong> and <strong class="source-inline">book4</strong> are each of type <strong class="source-inline">string</strong>, illustrating two different manners to initialize a string. Also notice that <strong class="source-inline">book5</strong> is initialized using <strong class="source-inline">book4</strong> as a basis. As we will soon discover, there are many safety features built into the <strong class="source-inline">string</strong> class to promote safe string usage. Though we have reviewed examples featuring two of several manners to represent strings (a native array of characters versus the string class), we will most often utilize <strong class="source-inline">std::string</strong> for its safety. Nonetheless, we have now seen various functions, such as <strong class="source-inline">strcpy()</strong> and <strong class="source-inline">strlen()</strong>, that operate on native C++ strings (as we will inevitably come across them in existing code). It is important to note that the C++ community is moving away from native C++ strings – that is, those implemented using an array of (or pointer to) characters.</p>
<p>Now that we have <a id="_idIndexMarker010"/>successfully reviewed basic C++ language features <a id="_idIndexMarker011"/>such as comment styles, variable declarations, standard data types, and array basics, let’s move forward to recap another fundamental language feature of C++: basic keyboard input and output using the <strong class="source-inline">&lt;iostream&gt;</strong> library.</p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor029"/>Recapping basic I/O</h1>
<p>In this<a id="_idIndexMarker012"/> section, we’ll briefly review simple character-based input and output with the keyboard and monitor. Simple manipulators will also be reviewed to both explain the underlying mechanics of I/O buffers and to provide basic enhancements and formatting.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>The iostream library</h2>
<p>One of the<a id="_idIndexMarker013"/> easiest<a id="_idIndexMarker014"/> mechanisms for input and output in C++ is the use of the <strong class="source-inline">&lt;iostream&gt;</strong> library. The header file <strong class="source-inline">&lt;iostream&gt;</strong> contains definitions of data <a id="_idIndexMarker015"/>types <strong class="bold">istream</strong> and <strong class="bold">ostream</strong>. Instances <a id="_idIndexMarker016"/>of these data types, <strong class="source-inline">cin</strong>, <strong class="source-inline">cout</strong>, <strong class="source-inline">cerr</strong>, and <strong class="source-inline">clog</strong>, are incorporated by including the <strong class="source-inline">std</strong> namespace. The <strong class="source-inline">&lt;iostream&gt;</strong> library facilitates simple I/O and can be used as follows:</p>
<ul>
<li><strong class="source-inline">cin</strong> can be used in conjunction with the extraction operator <strong class="source-inline">&gt;&gt;</strong> for buffered input</li>
<li><strong class="source-inline">cout</strong> can be used in conjunction with the insertion operator <strong class="source-inline">&lt;&lt;</strong> for buffered output</li>
<li><strong class="source-inline">cerr</strong> (unbuffered) and <strong class="source-inline">clog</strong> (buffered) can also be used in conjunction with the insertion operator, but for errors</li>
</ul>
<p>Let’s review an example showca<a id="_idTextAnchor031"/>sing simple I/O: </p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using<a id="_idTextAnchor032"/> namespace std;  // we'll limit the namespace shortly
int main()
{
    char name[20];  // caution, uninitialized array of char
    int age = 0;
    <strong class="bold">cout</strong> &lt;&lt; "Please enter a name and an age: ";
    <strong class="bold">cin</strong> &gt;&gt; name &gt;&gt; age; // caution, may overflow name var.
    <strong class="bold">cout</strong> &lt;&lt; "Hello " &lt;&lt; name;
    <strong class="bold">cout</strong> &lt;&lt; ". You are " &lt;&lt; ag<a id="_idTextAnchor033"/>e &lt;&lt; " years old." &lt;&lt; endl;
    return 0;
}</pre>
<p>F<a id="_idTextAnchor034"/>irst, we include the <strong class="source-inline">&lt;iostream&gt;</strong> library and indicate that we’re using the <strong class="source-inline">std</strong> namespace to gain usage of <strong class="source-inline">cin</strong> and <strong class="source-inline">cout</strong> (more on namespaces later in this chapter). Next, we introduce the <strong class="source-inline">main()</strong> function, which is the entry point in our application. Here, we declare two variables, <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong>, neither of which is initialized. Next, we prompt the user for input by placing the string <strong class="source-inline">"Please enter a name and an age: "</strong> in the buffer associated with <strong class="source-inline">cout</strong>. When the buffer associated with <strong class="source-inline">cout</strong> is flushed, the user will see this prompt on the screen. </p>
<p>The keyboard input string is then placed in the buffer associated with <strong class="source-inline">cout</strong> using the extraction operator <strong class="source-inline">&lt;&lt;</strong>. Conveniently, one mechanism that automatically flushes the buffer associated with <strong class="source-inline">cout</strong> is the use of <strong class="source-inline">cin</strong> to read keyboard input into variables, such as seen on the next line, where we read the user input into the variables <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong>, respectively.</p>
<p>Next, we print out a greeting of <strong class="source-inline">"Hello"</strong> to the user, followed by the name entered, followed by an indication of their age, gathered from the second piece of user input. The <strong class="source-inline">endl</strong> at the end of this line both places a newline character <strong class="source-inline">'\n'</strong> into the output buffer and ensures that the output buffer is flushed – more of that next. The <strong class="source-inline">return 0;</strong> declaration<a id="_idIndexMarker017"/> simply <a id="_idIndexMarker018"/>returns a program exit status to the programming shell, in this case, the value <strong class="source-inline">0</strong>. Notice that the <strong class="source-inline">main()</strong> function indicates an <strong class="source-inline">int</strong> for a return value to ensure<a id="_idTextAnchor035"/> this is possible.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor036"/>Basic iostream manipulators</h2>
<p>Often, it is<a id="_idIndexMarker019"/> desirable <a id="_idIndexMarker020"/>to be able to manipulate the contents of the buffers associated with <strong class="source-inline">cin</strong>, <strong class="source-inline">cout</strong>, and <strong class="source-inline">cerr</strong>. Manipulators allow the internal state of these objects to be modified, which affects how their associated buffers are formatted and manipulated. Manipulators are defined in the <strong class="source-inline">&lt;iomanip&gt;</strong> header file. Common manipulator examples in<a id="_idTextAnchor037"/>clude the following:</p>
<ul>
<li><strong class="source-inline">endl</strong>: Places a newline character (<strong class="source-inline">'\n'</strong>) in the buffer associated with <strong class="source-inline">cout</strong> then flushes the buffer</li>
<li><strong class="source-inline">flush</strong>: Clears the contents of the output stream</li>
<li><strong class="source-inline">setprecision(int)</strong>: Defines the precision (number of digits) used to output floating point numbers</li>
<li><strong class="source-inline">setw(int)</strong>: Sets the width for input and output</li>
<li><strong class="source-inline">ws</strong>: Removes whitespace characters from the buffer</li>
</ul>
<p>Let’s see a simple example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    char name[20];     // caution; uninitialized array
    float gpa = 0.0;   // grade point average
    cout &lt;&lt; "Please enter a name and a gpa: "; 
    cin &gt;&gt; <strong class="bold">setw(20)</strong> &gt;&gt; name &gt;&gt; gpa;  // won't overflow nam<a id="_idTextAnchor038"/>e
    cout &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; <strong class="bold">flush</strong>;
    cout &lt;&lt; ". GPA is: " &lt;&lt; <strong class="bold">setprecision(3)</strong> &lt;&lt; gpa &lt;&lt; <strong class="bold">endl</strong>;
    return 0;
}</pre>
<p>In this example, first, notice <a id="_idIndexMarker021"/>the<a id="_idIndexMarker022"/> inclusion of the <strong class="source-inline">&lt;iomanip&gt;</strong> header file. Also, notice that <strong class="source-inline">setw(20)</strong> is used to ensure that we do not overflow the name variable, which is only 20 characters long; <strong class="source-inline">setw()</strong> will automatically deduct one from the size provided to ensure there is room for the null character. Notice that <strong class="source-inline">flush</strong> is used on the second output line – it’s not necessary here to flush the output buffer; this manipulator merely demonstrates how a <strong class="source-inline">flush</strong> may be applied. On the last output line with <strong class="source-inline">cout</strong>, notice that <strong class="source-inline">setprecision(3)</strong> is used to print the floating point <strong class="source-inline">gpa</strong>. Three points of precision account for the decimal point plus two places to the right of the decimal. Finally, notice that we add the <strong class="source-inline">endl</strong> manipulator to the buffer associated with <strong class="source-inline">cout</strong>. The <strong class="source-inline">endl</strong> manipulator will first insert a newline character (<strong class="source-inline">'\n'</strong>) into the buffer and then flush the buffer. For performance, if you don’t need a buffer flush to immediately see the output, using a newline character al<a id="_idTextAnchor039"/>one is more efficient.</p>
<p>Now that we <a id="_idIndexMarker023"/>have <a id="_idIndexMarker024"/>reviewed simple input and output using the <strong class="source-inline">&lt;iostream&gt;</strong> library, let’s move forward by briefly reviewing control structures, statements, and looping constructs.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor040"/>Revisiting control structures, statements, and looping</h1>
<p>C++ has a variety of control structures and looping constructs that allow for non-sequential program flow. Each can be coupled with simple or compound statements. Simple statements end with a semicolon; more compound statements are enclosed in a block of code using a pair of brackets <strong class="source-inline">{}</strong>. In this section, we will be revisiting various types of control structures (<strong class="source-inline">if</strong>, <strong class="source-inline">else if</strong>, and <strong class="source-inline">else</strong>), and looping constructs (<strong class="source-inline">while</strong>, <strong class="source-inline">do while</strong>, and <strong class="source-inline">for</strong>) to recap simple methods for non-sequential progr<a id="_idTextAnchor041"/>am flow within our code.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor042"/>Control structures – if, else if, and else</h2>
<p>Conditional<a id="_idIndexMarker025"/> statements <a id="_idIndexMarker026"/>using <strong class="source-inline">if</strong>, <strong class="source-inline">else if</strong>, and <strong class="source-inline">else</strong> can<a id="_idIndexMarker027"/> be<a id="_idIndexMarker028"/> used with simple statements or a block of statements. Note that an <strong class="source-inline">if</strong> clause can be used without a following <strong class="source-inline">else if</strong> or <strong class="source-inline">else</strong> clause. Actually, <strong class="source-inline">else if</strong> is real<a id="_idTextAnchor043"/>ly a condensed version of an <strong class="source-inline">else</strong> clause with a nested <strong class="source-inline">if</strong> clause inside of it. Practically speaking, developers flatten the nested use into <strong class="source-inline">else if</strong> format for readability <a id="_idTextAnchor044"/>and to save excess indenting. Let’s see an example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
<a id="_idTextAnchor045"/>{
    int x = 0;
    cout &lt;&lt; "Enter an integer: ";
    cin &gt;&gt; x;
    <strong class="bold">if (x == 0)</strong> 
        cout &lt;&lt; "x is 0" &lt;&lt; endl;
    <strong class="bold">else if (x &lt; 0)</strong>
 <a id="_idTextAnchor046"/>       cout &lt;&lt; "x is negative" &lt;&lt; endl;
    <strong class="bold">else</strong>
    {
        cout &lt;&lt; "x is positive";
      <a id="_idTextAnchor047"/>  cout &lt;&lt; "and ten times x is: " &lt;&lt; x * 10 &lt;&lt; endl;
    }  
    return 0;
}</pre>
<p>Notice that in<a id="_idIndexMarker029"/> the <a id="_idIndexMarker030"/>preceding <strong class="source-inline">else</strong> clause, multiple<a id="_idIndexMarker031"/> statements <a id="_idIndexMarker032"/>are bundled into a block of code, whereas in the <strong class="source-inline">if</strong> and <strong class="source-inline">else if</strong> conditions, only a single statement follows each condition. As a side note, in C++, any non-zero value is considered to be true. So, for example, testing <strong class="source-inline">if (x)</strong> would imply that <strong class="source-inline">x</strong> is not equal to zero – it would not be necessary to write <strong class="source-inline">if (x !=0)</strong>, except possibly for readability.</p>
<p>It is worth mentioning that in C++, it is wise to adopt a set of consistent coding conventions and practices (as do many teams and organizations). As a straightforward example, the placement of brackets may be specified in a coding standard (such as starting the <strong class="source-inline">{</strong> on the same line as the keyword <strong class="source-inline">else</strong>, or on the line below the keyword <strong class="source-inline">else</strong> with the number of spaces it should be indented). Another convention may be that even a single statement following an <strong class="source-inline">else</strong> keyword be included in a block using brackets. Following a consistent set of coding conventions will allow your code to be more easil<a id="_idTextAnchor048"/>y <a id="_idIndexMarker033"/>read<a id="_idIndexMarker034"/> and <a id="_idIndexMarker035"/>maintained <a id="_idIndexMarker036"/>by others.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor049"/>Looping constructs – while, do while, and for loops</h2>
<p>C++ has<a id="_idIndexMarker037"/> several<a id="_idIndexMarker038"/> looping constructs. Let’s<a id="_idIndexMarker039"/> take<a id="_idIndexMarker040"/> a moment to review a brief example for each style, starting wit<a id="_idTextAnchor050"/>h the <strong class="source-inline">while</strong> and <strong class="source-inline">do while</strong> loop constructs:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    int i = 0;
    <strong class="bold">while (i &lt; 10)</strong>
    {
        cout &lt;&lt; i &lt;&lt; endl;
        i++;
    }
    i = 0;
    <strong class="bold">do</strong> 
    {
        cout &lt;&lt; i &lt;&lt; endl;
        i++;
    } <strong class="bold">while (i &lt; 10);</strong>
    return 0;
}</pre>
<p>With the <strong class="source-inline">while</strong> loop, the condition to enter the loop must evaluate to true prior to each entry of the loop body. However, with the <strong class="source-inline">do while</strong> loop, the first entry to the loop body is guaranteed – the condition is then evaluated before another iteration through the loop body. In the preceding example, both the <strong class="source-inline">while</strong> and <strong class="source-inline">do while</strong> loops are executed 10 times, each printing values <strong class="source-inline">0</strong>-<strong class="source-inline">9</strong> for variable <strong class="source-inline">i</strong>.</p>
<p>Next, let’s review a typical <strong class="source-inline">for</strong> loop. The <strong class="source-inline">for</strong> loop has three parts within the <strong class="source-inline">()</strong>. First, there is a statement that is executed exactly once and is often used to initialize a loop control variable. Next, separated on both sides by semicolons in the center of the <strong class="source-inline">()</strong> is an expression. This expression is evaluated each time before entering the body of the loop. The body of the loop is only entered if this expression evaluates to <strong class="source-inline">true</strong>. Lastly, the third part within the <strong class="source-inline">()</strong> is a second statement. This statement is executed immediately after executing the body of the loop and is often used to modify a loop control variable. Following<a id="_idIndexMarker041"/> this<a id="_idIndexMarker042"/> second<a id="_idIndexMarker043"/> statement, the<a id="_idIndexMarker044"/> center expression is re-evaluated. Here is an example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    // though we'll prefer to declare i within the loop
    // construct, let's understand scope in both scenarios
    int i; 
    <strong class="bold">for (i = 0; i &lt; 10; i++)</strong> 
        cout &lt;&lt; i &lt;&lt; endl;
    <strong class="bold">for (int j = 0; j &lt; 10; j++)</strong>   // preferred declaration
        cout &lt;&lt; j &lt;&lt; endl;      // of loop contro<a id="_idTextAnchor051"/>l variable
    return 0;
}</pre>
<p>Here, we have two <strong class="source-inline">for</strong> loops. Prior to the first loop, variable <strong class="source-inline">i</strong> is declared. Variable <strong class="source-inline">i</strong> is then initialized with a value of <strong class="source-inline">0</strong> in statement 1 between the loop parentheses <strong class="source-inline">()</strong>. The loop condition is tested, and if <strong class="source-inline">true</strong>, the loop body is then entered and executed, followed by statement 2 being executed prior to the loop condition being retested. This loop is executed 10 times for <strong class="source-inline">i</strong> values <strong class="source-inline">0</strong> through <strong class="source-inline">9</strong>. The second <strong class="source-inline">for</strong> loop is similar, with the only difference being variable <strong class="source-inline">j</strong> is both declared and initialized within statement 1 of the loop construct. Note that variable <strong class="source-inline">j</strong> only has scope for the <strong class="source-inline">for</strong> loop itself, whereas variable <strong class="source-inline">i</strong> has scope of the entire block in which it is declared, from its declaration point forward.</p>
<p>Let’s quickly<a id="_idIndexMarker045"/> see <a id="_idIndexMarker046"/>an example using <a id="_idIndexMarker047"/>nested<a id="_idIndexMarker048"/> loops. The looping constructs can be of any type, but in the following, we’ll review nested <strong class="source-inline">for</strong> loops:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Progr<span id="_idTextAnchor052"/>amming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
int main()
{
    <strong class="bold">for (int i = 0; i &lt; 10; i++)</strong> 
    {
        cout &lt;&lt; i &lt;&lt; endl;
        <strong class="bold">for (int j = 0; j &lt; 10; j++)</strong>
            cout &lt;&lt; j &lt;&lt; endl;
        cout &lt;&lt; "\n";
    }
    return 0;
}</pre>
<p>Here, the outer loop will execute ten times with <strong class="source-inline">i</strong> values of <strong class="source-inline">0</strong> through <strong class="source-inline">9</strong>. For each value of <strong class="source-inline">i</strong>, the inner loop will execute ten tim<a id="_idTextAnchor053"/>es, with <strong class="source-inline">j</strong> values of <strong class="source-inline">0</strong> through <strong class="source-inline">9</strong>. Remember, with <strong class="source-inline">for</strong> loops, the loop control variable is automatically incremented with the <strong class="source-inline">i++</strong> or <strong class="source-inline">j++</strong> within the loop construct. Had a <strong class="source-inline">while</strong> loop been used, the programmer would need to remember <a id="_idIndexMarker049"/>to<a id="_idIndexMarker050"/> increment the loop<a id="_idIndexMarker051"/> control<a id="_idIndexMarker052"/> variable in the last line of the body of each such loop. </p>
<p>Now that we have reviewed control structures, statements, and looping constructs in C++, we can move onward by briefly recalling C++’s operators.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor054"/>Reviewing C++ operators</h1>
<p>Unary, binary, and<a id="_idIndexMarker053"/> ternary operators exist in C++. C++ allows operators to have different meanings based on the context of usage. C++ also allows programmers to redefine the meaning of selected operators when used in the context of at least one user defined type. The operators are listed in the following concise list. We’ll see examples of these operators throughout the remainder of this section and throughout the course. Here is a synopsis of the binary, unary, and ternary operators in C++:</p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 1.1 – C++ operators" height="1749" src="image/Figure_1.01_B19087.jpg" width="1261"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – C++ operators</p>
<p>In the aforementioned <a id="_idIndexMarker054"/>binary operator list, notice how many of the operators have “<em class="italic">shortcut</em>” versions when paired with the assignment operator <strong class="source-inline">=</strong>. For example, <strong class="source-inline">a = a * b</strong> can be written equivalently using a shortcut operator <strong class="source-inline">a *= b</strong>. Let’s take a look at an example that incorporates an assortment of operators, including the usage of a shortcut operator:</p>
<pre class="source-code">
score <strong class="bold">+=</strong> 5;
score<strong class="bold">++</strong>;
if (score <strong class="bold">==</strong> 100)
    cout &lt;&lt; "You have a perfect score!" &lt;&lt; endl;
else
    cout &lt;&lt; "Your score is: " &lt;&lt; score &lt;&lt; endl;
// equivalent to if - else above, but using ?: operator
(score == 100)<strong class="bold">?</strong> cout &lt;&lt; "You have a perfect score" &lt;&lt; endl<strong class="bold">:</strong>
                cout &lt;&lt; "Your score is: " &lt;&lt; score &lt;&lt; endl; </pre>
<p>In the previous code fragment, notice the use of the shortcut operator <strong class="source-inline">+=</strong>. Here, the statement <strong class="source-inline">score += 5;</strong> is equivalent to <strong class="source-inline">score = score + 5;</strong>. Next, the unary increment operator <strong class="source-inline">++</strong> is used to increment <strong class="source-inline">score</strong> by 1. Then we see the equality operator <strong class="source-inline">==</strong> to compare <strong class="source-inline">score</strong> with a value of <strong class="source-inline">100</strong>. Finally, we see an example of the ternary operator <strong class="source-inline">?:</strong> to replace a simple <strong class="source-inline">if</strong> - <strong class="source-inline">else</strong> statement. It is instructive to note that <strong class="source-inline">?:</strong> is not<a id="_idIndexMarker055"/> preferred by some programmers, yet it is always interesting to review an example of its use.</p>
<p>Now that we have very briefly recapped the operators in C++, let’s revisit function basics.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor055"/>Revisiting function basics</h1>
<p>A function identifier<a id="_idIndexMarker056"/> must begin with a letter or underscore and may also contain digits. The function’s return type, argument list, and return value are optional. The basic form of a C++ function is as follows: </p>
<pre class="source-code">
&lt;return type&gt; FunctionName (&lt;argumentType argument1, …&gt;)
{
    expression 1…N;
    &lt;return value/expression;&gt;
}</pre>
<p>Let’s review <a id="_idIndexMarker057"/>a simple function:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
<strong class="bold">int Minimum(int a, int b)</strong>
{
    if (a &lt; b)
        return a;
    else
        return b;
}
int main()
{
    int x = 0, y = 0;
    cout &lt;&lt; "Enter two integers: ";
    cin &gt;&gt; x &gt;&gt; y;
    cout &lt;&lt; "The minimum is: " &lt;&lt; <strong class="bold">Minimum(x, y)</strong> &lt;&lt; endl;
    return 0;
}</pre>
<p>In the preceding simple example, first, a function <strong class="source-inline">Minimum()</strong> is defined. It has a return type of <strong class="source-inline">int</strong> and it takes two integer arguments: formal parameters <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. In the <strong class="source-inline">main()</strong> function, <strong class="source-inline">Minimum()</strong> is called with actual parameters <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. The call to <strong class="source-inline">Minimum()</strong> is permitted within the <strong class="source-inline">cout</strong> statement because <strong class="source-inline">Minimum()</strong> returns an integer value; this value is passed along to the extraction operator (<strong class="source-inline">&lt;&lt;</strong>) in conjunction with printing. In fact, the string <strong class="source-inline">"The minimum is: "</strong> is first placed into the buffer associated with <strong class="source-inline">cout</strong>, followed by the return value from calling function <strong class="source-inline">Minimum()</strong>. The output buffer is then flushed by <strong class="source-inline">endl</strong> (which first places a newline character in the buffer before flushing).</p>
<p>Notice that the function is first defined in the file and then called later in the file in the <strong class="source-inline">main()</strong> function. Strong type checking is performed on the call to the function by comparing the parameter types and their usage in the call to the function’s definition. What happens, however, when the function call precedes its definition? Or if the call to the function is in a separate file from its definition?</p>
<p>In these cases, the default action is for the compiler to assume a certain <em class="italic">signature</em> to the function, such as an integer return type, and that the formal parameters will match the types of arguments in the function call. Often, the default assumptions are incorrect; when <a id="_idIndexMarker058"/>the compiler then encounters the function definition later in the file (or when another file is linked in), an error will be raised indicating that the function call and definition do not match.</p>
<p>These issues have historically been solved with a forward declaration of a function included at the top of a file where the function will be called. Forward declarations consist of the function return type, function name and types, and the number of parameters. In C++, a forward declaration has been improved upon and is instead known as a function prototype. Since there are many interesting details surrounding function prototyping, this topic will be covered in reasonable detail in the next chapter.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The specifier <strong class="source-inline">[[nodiscard]]</strong> can optionally be added to precede the return type of a function. This specifier is used to indicate that the return value from a function must not be ignored – that is, it must be captured in a variable or utilized in an expression. Should the function’s return value consequently be ignored, a compiler warning will be issued. Note that the <strong class="source-inline">nodiscard</strong> qualifier can be added to the function prototype and optionally to the definition (or required in a definition if there is no prototype). Ideally, <strong class="source-inline">nodiscard</strong> should appear in both locations.</p>
<p>As we move to the object-oriented sections in this book (<a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, and beyond), we will learn that there are many more details and quite interesting features relating to functions. Nonetheless, we have sufficiently recalled the basics <a id="_idIndexMarker059"/>needed to move forward. Next, let’s<a id="_idTextAnchor056"/> continue our C++ language review with user defined types.</p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor057"/>Reviewing user defined type basics</h1>
<p>C++ offers several <a id="_idIndexMarker060"/>mechanisms to create user defined types. Bundling together like characteristics into one data type (later, we’ll also add relevant behaviors) will form the basis for an object-oriented concept known as encapsulation explored in a later section of this text. For now, let’s review the basic mechanisms to bundle together only data in <strong class="source-inline">struct</strong>, <strong class="source-inline">class</strong>, and <strong class="source-inline">typedef</strong> (to a lesser extent). We will also review enumerated types to represent lists of integers more meaningfully.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor058"/>struct</h2>
<p>A C++ structure <a id="_idIndexMarker061"/>in<a id="_idIndexMarker062"/> its simplest form can be used to collect common data elements together in a single unit. Variables may then be declared of the composite data type. The dot operator is used to access specific members of each structure variable. Here is a structure used in its most simple fashion:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
<strong class="bold">struct student</strong>
<strong class="bold">{</strong>
    string name;
    float semesterGrades[5];
    float gpa;
<strong class="bold">};</strong>
int main()
{
    <strong class="bold">student s1;</strong>
    s1.name = "George Katz";
    s1.semesterGrades[0] = 3.0;
    s1.semesterGrades[1] = 4.0;
    s1.gpa = 3.5;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl;
    return 0;        
}</pre>
<p>Stylistically, type names are typically in lowercase when using structs. In the preceding example, we declare the user defined type <strong class="source-inline">student</strong> using a <strong class="source-inline">struct</strong>. Type <strong class="source-inline">student</strong> has three fields or data members: <strong class="source-inline">name</strong>, <strong class="source-inline">semesterGrades</strong>, and <strong class="source-inline">gpa</strong>. In the <strong class="source-inline">main()</strong> function, a variable <strong class="source-inline">s1</strong> of type <strong class="source-inline">student</strong> is declared; the dot operator is used to access each of the variable’s data members. Since structs are typically not used for OO programming<a id="_idIndexMarker063"/> in C++, we’re not going to yet introduce significant OO <a id="_idIndexMarker064"/>terminology relating to their use. It’s worthy to note that in C++, the tag <strong class="source-inline">student</strong> also becomes the type name (unlike in C, where a variable declaration would need the word <strong class="source-inline">struct</strong> to precede the type).</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor059"/>typedef and “using” alias declaration</h2>
<p>A <strong class="source-inline">typedef</strong> declaration<a id="_idIndexMarker065"/> can<a id="_idIndexMarker066"/> be<a id="_idIndexMarker067"/> used<a id="_idIndexMarker068"/> to provide a more mnemonic representation for data types. In C++, the relative need for a <strong class="source-inline">typedef</strong> has been eliminated in usage with a <strong class="source-inline">struct</strong>. Historically, a <strong class="source-inline">typedef</strong> in C allowed the bundling together of the keyword <strong class="source-inline">struct</strong> and the structure tag to create a user defined type. However, in C++, as the structure tag automatically becomes the type, a <strong class="source-inline">typedef</strong> then becomes wholly unnecessary for a <strong class="source-inline">struct</strong>. Typedefs can still be used with standard types for enhanced readability in code, but in this fashion, the <strong class="source-inline">typedef</strong> is not being used to bundle together like data elements, such as with a <strong class="source-inline">struct</strong>. As a related historical note, <strong class="source-inline">#define</strong> (a preprocessor directive and macro replacement) was once used to create more mnemonic types, but <strong class="source-inline">typedef</strong> (and <strong class="source-inline">using</strong>) are certainly preferred. It’s worthy to note when viewing older code.</p>
<p>A <strong class="source-inline">using</strong> statement can be used as an alternative to a simple <strong class="source-inline">typedef</strong> to create an alias for a type, known as an <strong class="bold">alias-declaration</strong>. The <strong class="source-inline">using</strong> statement can also be used to simplify more complex types (such as providing an alias for complex declarations when using the Standard Template Library or declaring function pointers). The current trend is to favor a <strong class="source-inline">using</strong> alias-declaration to a <strong class="source-inline">typedef</strong>.</p>
<p>Let’s take a look at a simple <strong class="source-inline">typedef</strong> compared to a simple <strong class="source-inline">using</strong> alias-declaration:</p>
<pre class="source-code">
typedef float dollars; 
using money = float;</pre>
<p>In the previous declaration, the new type <strong class="source-inline">dollars</strong> can be used interchangeably with the type <strong class="source-inline">float</strong>. Likewise, the <a id="_idIndexMarker069"/>new alias <strong class="source-inline">money</strong> can also be<a id="_idIndexMarker070"/> used interchangeably <a id="_idIndexMarker071"/>with <a id="_idIndexMarker072"/>type <strong class="source-inline">float</strong>. It is not productive to demonstrate the archaic use of <strong class="source-inline">typedef</strong> with a structure, so let’s move on to the most used user defined type in C++, the <strong class="source-inline">class</strong>.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor060"/>class</h2>
<p>A <strong class="source-inline">class</strong> in its simplest<a id="_idIndexMarker073"/> form<a id="_idIndexMarker074"/> can be used nearly like a <strong class="source-inline">struct</strong> to bundle together related data into a single data type. In <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>,<span class="Annotation-reference"> </span>we’ll see that a <strong class="source-inline">class</strong> is typically also used to bundle related functions together with the new data type. Grouping together data and behaviors relevant to that data is the basis of encapsulation. For now, let’s see a <strong class="source-inline">class</strong> in its simplest form, much like a <strong class="source-inline">struct</strong>:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp">https://github.com/PacktPublishing/Decipher<span id="_idTextAnchor061"/>ing-Object-Oriented-<span id="_idTextAnchor062"/>Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
<strong class="bold">class Student</strong>
<strong class="bold">{</strong>
public:
    string name;
    float semesterGrades[5];
    float gpa;
<strong class="bold">};</strong>
int main()
{
    <strong class="bold">Student s1;</strong>
    s1.name = "George Katz";
    s1.semesterGrades[0] = 3.0;
    s1.sem<a id="_idTextAnchor063"/>esterGrades[1] = 4.0;
    s1.gpa = 3.5;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl;
    return 0;      
}</pre>
<p>Notice that the<a id="_idIndexMarker075"/> previous<a id="_idIndexMarker076"/> code is very similar to that used in the <strong class="source-inline">struct</strong> example. The main difference is the keyword <strong class="source-inline">class</strong> instead of the keyword <strong class="source-inline">struct</strong> and the addition of the access label <strong class="source-inline">public:</strong> at the beginning of the class definition (more on that in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a><em class="italic">, Exploring Classes in Detail</em>). Stylistically, the capitalization of the first letter in the data type, such as <strong class="source-inline">Student</strong>, is typical for classes. We’ll see that classes have a wealth more features and are the building blocks for OO programming. We’ll introduce new terminology such as <em class="italic">instance</em>, to be used rather than <em class="italic">variable</em>. However, this section is only a review of skills assumed, so we’ll need to wait to get to the exciting OO features of the language. Spoiler alert: all the wonderful things classes will be able<a id="_idIndexMarker077"/> to do also applies to <a id="_idIndexMarker078"/>structs; however, we’ll see that structs stylistically won’t be used to exemplify OO programming.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor064"/>enum and strongly-typed enum</h2>
<p>Traditional<a id="_idIndexMarker079"/> enumerated <a id="_idIndexMarker080"/>types <a id="_idIndexMarker081"/>may be <a id="_idIndexMarker082"/>used to mnemonically represent lists of integers. Unless otherwise initialized, integer values in the enumeration begin with zero and increase by one throughout the list. Two enumerated types may not utilize the same enumerator names. </p>
<p>Strongly-typed enumerated types improve upon traditional enumerated types. Strongly-typed enums default to represent lists of integers, but may be used to represent any integral type, such as <strong class="source-inline">int</strong>, <strong class="source-inline">short</strong> <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong> <strong class="source-inline">int</strong>, <strong class="source-inline">char</strong>, or <strong class="source-inline">bool</strong>. The enumerators are not exported to the surrounding scope, so enumerators may be reused between types. Strongly-typed enums allow forward declarations of their type (allowing such uses as these types as arguments to functions before the enumerator declaration).</p>
<p>Let’s now see an example of traditional enums and strongly-typed enums:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using namespace std;   // we'll limit the namespace shortly
// traditional enumerated types
<strong class="bold">enum day {Sunday, Monday, Tuesday, Wednesday, Thursday,</strong>
          <strong class="bold">Friday, Saturday};</strong>
<strong class="bold">enum workDay {Mon = 1, Tues, Wed, Thurs, Fri};</strong>
// strongly-typed enumerated types can be a struct or class
<strong class="bold">enum struct WinterHoliday {Diwali, Hanukkah, ThreeKings,</strong>
  <strong class="bold">WinterSolstice, StLucia, StNicholas, Christmas, Kwanzaa};</strong>
<strong class="bold">enum class Holiday : short int {NewYear = 1, MLK, Memorial,</strong>
  <strong class="bold">Independence, Labor, Thanksgiving};</strong>
int main()
{
    <strong class="bold">day birthday = Monday;</strong>
    <strong class="bold">workDay payday = Fri;</strong>
    <strong class="bold">WinterHoliday myTradition = WinterHoliday::StNicholas;</strong>
    <strong class="bold">Holiday favorite = Holiday::NewYear;</strong>
    cout &lt;&lt; "Birthday is " &lt;&lt; birthday &lt;&lt; endl;
    cout &lt;&lt; "Payday is " &lt;&lt; payday &lt;&lt; endl;
    cout &lt;&lt; "Traditional Winter holiday is " &lt;&lt; 
             static_cast&lt;int&gt; (myTradition) &lt;&lt; endl;
    cout &lt;&lt; "Favorite holiday is " &lt;&lt; 
             static_cast&lt;short int&gt; (favorite) &lt;&lt; endl;
    return 0;      
}</pre>
<p>In the previous <a id="_idIndexMarker083"/>example, the<a id="_idIndexMarker084"/> traditional<a id="_idIndexMarker085"/> enumerated<a id="_idIndexMarker086"/> type <strong class="source-inline">day</strong> has values of <strong class="source-inline">0</strong> through <strong class="source-inline">6</strong>, starting with <strong class="source-inline">Sunday</strong>. The traditional enumerated type <strong class="source-inline">workDay</strong> has values of <strong class="source-inline">1</strong> through <strong class="source-inline">5</strong>, starting with <strong class="source-inline">Mon</strong>. Notice the explicit use of <strong class="source-inline">Mon = 1</strong> as the first item in the enumerated type has been used to override the default starting value of <strong class="source-inline">0</strong>. Interestingly, we may not repeat enumerators between two enumerated types. For that reason, you will notice that <strong class="source-inline">Mon</strong> is used as an enumerator in <strong class="source-inline">workDay</strong> because <strong class="source-inline">Monday</strong> has already been used in the enumerated type <strong class="source-inline">day</strong>. Now, when we create variables such as <strong class="source-inline">birthday</strong> or <strong class="source-inline">p<a id="_idTextAnchor065"/>ayday</strong>, we can use meaningful enumerated types to initialize or assign values, such as <strong class="source-inline">Monday</strong> or <strong class="source-inline">Fri</strong>. As meaningful as the enumerators may be within the code, please note that the values when manipulated or printed will be their corresponding integer values.</p>
<p>Moving forward to consider the strongly-typed enumerated types in the previous example, the <strong class="source-inline">enum</strong> for <strong class="source-inline">WinterHoliday</strong> is defined using a struct. Default values for the enumerators are integers, starting with the value of <strong class="source-inline">0</strong> (as with the traditional enums). However, notice that the <strong class="source-inline">enum</strong> for <strong class="source-inline">Holiday</strong> specifies the enumerators to be of type <strong class="source-inline">short int</strong>. Additionally, we choose to start the first item in the enumerated type with value <strong class="source-inline">1</strong>, rather than <strong class="source-inline">0</strong>. Notice when we print out the strongly-typed enumerators that we must cast the type using a <strong class="source-inline">static_cast</strong> to the type of the enumerator. This is because the insertion operator knows how to handle selected types, but these types do not include strongly-typed enums; therefore, we cast our enumerated type to a type understood by the insertion operator.</p>
<p>Now that we<a id="_idIndexMarker087"/> have <a id="_idIndexMarker088"/>revisited <a id="_idIndexMarker089"/>simple user<a id="_idIndexMarker090"/> defined types in C++, including <strong class="source-inline">struct</strong>, <strong class="source-inline">typedef</strong> (and <strong class="source-inline">using</strong> an alias), <strong class="source-inline">class</strong>, and <strong class="source-inline">enum</strong>, we are ready to move onward to reviewing our next language necessity, the <strong class="source-inline">namespace</strong>.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor066"/>Recapping namespace basics</h1>
<p>The <strong class="source-inline">namespace</strong> utility<a id="_idIndexMarker091"/> was added to C++ to add a scoping level beyond global scope to applications. This feature can be used to allow two or more libraries to be utilized without concern that they may contain duplicative data types, functions, or identifiers. The programmer needs to activate the desired namespace in each relevant portion of their application with the keyword <strong class="source-inline">using</strong>. Programmers can also create their own namespaces (usually for creating reusable library code) and activate each namespace as applicable. In the previous examples, we’ve seen the simple use of the <strong class="source-inline">std</strong> namespace to include <strong class="source-inline">cin</strong> and <strong class="source-inline">cout</strong>, which are instances of <strong class="source-inline">istream</strong> and <strong class="source-inline">ostream</strong> (whose definitions are found in <strong class="source-inline">&lt;iostream&gt;</strong>). Let’s review how we can create namespaces<a id="_idIndexMarker092"/> ourselves:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
<strong class="bold">// using namespace std;</strong> // Do not open entire std namespace
<strong class="bold">using std::cout;</strong>   // Instead, activate individual elements
<strong class="bold">using std::endl;</strong>   // within the namespace as needed
<strong class="bold">namespace DataTypes</strong>
<strong class="bold">{</strong>
    int total;
    class LinkList
    {  // full class definition … 
    };
    class Stack
    {  // full class definition …
    };
<strong class="bold">};</strong>
<strong class="bold">namespace AbstractDataTypes</strong>
<strong class="bold">{</strong>
    class Stack
    {  // full class definition …
    };
    class Queue
    {  // full class description …
    };
<strong class="bold">};</strong>
// Add entries to the AbstractDataTypes namespace
<strong class="bold">namespace AbstractDataTypes   </strong>
<strong class="bold">{</strong>
    int total;
    class Tree
    {  // full class definition …
    };
<strong class="bold">};</strong>
int main()
{
    <strong class="bold">using namespace AbstractDataTypes;</strong> //activate namespace
    <strong class="bold">using DataTypes::LinkList;</strong>    // activate only LinkList 
    LinkList list1;     // LinkList is found in DataTypes
    Stack stack1;    // Stack is found in AbstractDataTypes
    total = 5;       // total from active AbstractDataTypes
    <a id="_idTextAnchor067"/><strong class="bold">DataTypes::total</strong> = 85;// specify non-active mbr., total
    cout &lt;&lt; "total " &lt;&lt; total &lt;&lt; "\n";
    cout &lt;&lt; "DataTypes::total " &lt;&lt; <strong class="bold">DataTypes::total</strong>;
    cout &lt;&lt; endl;
    return 0;        
}</pre>
<p>In the second line of the preceding code (which is commented out), we notice the keyword <strong class="source-inline">using</strong> applied to indicate that we’d like to use or activate the entire <strong class="source-inline">std</strong> namespace. Preferably, on the following two lines of code, we can instead activate only the elements in the standard namespace that we will be needing, such as <strong class="source-inline">std::cout</strong> or <strong class="source-inline">std::endl</strong>. We can utilize <strong class="source-inline">using</strong> to open existing libraries (or individual elements within those libraries) that may contain useful classes; the keyword <strong class="source-inline">using</strong> activates the namespace to which a given library may belong. Next in the code, a user specified namespace is created called <strong class="source-inline">DataTypes</strong>, using the <strong class="source-inline">namespace</strong> keyword. Within this namespace exists a variable <strong class="source-inline">total</strong>, and two class definitions: <strong class="source-inline">LinkList</strong> and <strong class="source-inline">Stack</strong>. Following this namespace, a second namespace, <strong class="source-inline">AbstractDataTypes</strong>, is created and includes two class definitions: <strong class="source-inline">Stack</strong> and <strong class="source-inline">Queue</strong>. Additionally, the namespace <strong class="source-inline">AbstractDataTypes</strong> is augmented by a second occurrence of the <em class="italic">namespace</em> definition in which a variable <strong class="source-inline">total</strong> and a class definition for <strong class="source-inline">Tree</strong> are added.</p>
<p>In the <strong class="source-inline">main()</strong> function, first, the <strong class="source-inline">AbstractDataTypes</strong> namespace is opened with the <strong class="source-inline">using</strong> keyword. This activates all names in this namespace. Next, the keyword <strong class="source-inline">using</strong> is combined <a id="_idIndexMarker093"/>with the scope resolution operator (<strong class="source-inline">::</strong>) to only activate the <strong class="source-inline">LinkList</strong> class definition from the <strong class="source-inline">DataTypes</strong> namespace. Had there also been a <strong class="source-inline">LinkList</strong> class within the <strong class="source-inline">AbstractDataType</strong> namespace, the initial visible <strong class="source-inline">LinkList</strong> would now be hidden by the activation of <strong class="source-inline">DataTypes::LinkList</strong>.</p>
<p>Next, a variable of type <strong class="source-inline">LinkList</strong> is declared, whose definition comes from the <strong class="source-inline">DataTypes</strong> namespace. A variable of type <strong class="source-inline">Stack</strong> is next declared; though both namespaces have a <strong class="source-inline">Stack</strong> c<a id="_idTextAnchor068"/>lass definition, there is no ambiguity since only one <strong class="source-inline">Stack</strong> has been activated. Next, we use <strong class="source-inline">cin</strong> to read into <strong class="source-inline">total</strong>, which is active from the <strong class="source-inline">AbstractDataTypes</strong> namespace. Lastly, we use the scope resolution operator to explicitly read into <strong class="source-inline">DataTypes::total</strong>, a variable that would otherwise be hidden. One caveat to note: should two or more namespaces contain the same identifier, the one last opened<a id="_idIndexMarker094"/> will preside, hiding all previous occurrences.</p>
<p>It is considered good practice to activate only the elements of a namespace we wish to utili<a id="_idTextAnchor069"/>ze. From the aforementioned example, we can see potential ambiguity that can otherwise arise.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor070"/>Summary</h1>
<p>In this chapter, we reviewed core C++ syntax and non-OO language features to refresh your existing skill set. These features include basic language syntax, basic I/O with <strong class="source-inline">&lt;iostream&gt;</strong>, control structures/statements/looping, operator basics, function basics, simple user defined types, and namespaces. Most importantly, you are now ready to move to the next chapter, in which we will expand on some of these ideas with additional language necessities such as <strong class="source-inline">const</strong> qualified variables, understanding and using prototypes (including with default values), and function overloading.</p>
<p>The ideas in the next chapter begin to move us closer to our goal for OO programming, as many of these aggregate skills are used often and matter of factly as we move deeper into the language. It is important to remember that in C++, you can do anything, whether you mean to do so or not. There is great power in the language, and having a solid base for its many nuances and features is crucial. Over the next couple of chapters, the solid groundwork will be laid with an arsenal of non-OO C++ skills, so that we may realistically engage OO programming in C++ with a high level of understanding and success.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor071"/>Questions</h1>
<ol>
<li>Describe a situation in which <strong class="source-inline">flush</strong>, rather than <strong class="source-inline">endl</strong>, may be useful for clearing the contents of the buffer associated with <strong class="source-inline">cout</strong>.</li>
<li>The unary operator <strong class="source-inline">++</strong> can be used as a pre- or post-increment operator, such as <strong class="source-inline">i++</strong> or <strong class="source-inline">++i</strong>. Can you describe a situation in which choosing a pre- versus post-increment for <strong class="source-inline">++</strong> would have different consequences in the code?</li>
<li>Create a simple program using a <strong class="source-inline">struct</strong> or <strong class="source-inline">class</strong> to make a user defined type for <strong class="source-inline">Book</strong>. Add data members for title, author, and number of pages. Create two variables of type <strong class="source-inline">Book</strong> and use the dot operator <strong class="source-inline">.</strong> to fill in the data members for each such instance. Use <strong class="source-inline">iostreams</strong> to both prompt the user for input values, and to print each <strong class="source-inline">Book</strong> instance when complete. Use only features covered in this chapter.</li>
</ol>
</div>
<div>
<div id="_idContainer013">
</div>
</div>
</div></body></html>