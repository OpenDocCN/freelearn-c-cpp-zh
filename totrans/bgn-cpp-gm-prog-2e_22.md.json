["```cpp\n[START OBJECT]\n[NAME]invader[-NAME]\n[COMPONENT]Standard Graphics[-COMPONENT]\n[COMPONENT]Invader Update[-COMPONENT]\n[COMPONENT]Transform[-COMPONENT]\n[LOCATION X]0[-LOCATION X]\n[LOCATION Y]0[-LOCATION Y]\n[WIDTH]2[-WIDTH]\n[HEIGHT]2[-HEIGHT]\n[BITMAP NAME]invader1[-BITMAP NAME]\n[ENCOMPASSING RECT COLLIDER]invader[-ENCOMPASSING_RECT COLLIDER]\n[END OBJECT]\n```", "```cpp\n[START OBJECT]\n```", "```cpp\n[NAME]invader[-NAME]\n```", "```cpp\n[COMPONENT]Standard Graphics[-COMPONENT]\n[COMPONENT]Invader Update[-COMPONENT]\n[COMPONENT]Transform[-COMPONENT]\n```", "```cpp\n[LOCATION X]0[-LOCATION X]\n[LOCATION Y]0[-LOCATION Y]\n[WIDTH]2[-WIDTH]\n[HEIGHT]2[-HEIGHT]\n```", "```cpp\n[BITMAP NAME]invader1[-BITMAP NAME]\n```", "```cpp\n[ENCOMPASSING RECT COLLIDER]invader[-ENCOMPASSING_RECT COLLIDER]\n```", "```cpp\n[END OBJECT]\n```", "```cpp\n[START OBJECT]\n[NAME]bullet[-NAME]\n[COMPONENT]Standard Graphics[-COMPONENT]\n[COMPONENT]Transform[-COMPONENT]\n[COMPONENT]Bullet Update[-COMPONENT]\n[LOCATION X]-1[-LOCATION X]\n[LOCATION Y]-1[-LOCATION Y]\n[WIDTH]0.1[-WIDTH]\n[HEIGHT]2.0[-HEIGHT]\n[BITMAP NAME]bullet[-BITMAP NAME]\n[ENCOMPASSING RECT COLLIDER]bullet[-ENCOMPASSING_RECT COLLIDER]\n[SPEED]75.0[-SPEED]\n[END OBJECT]\n```", "```cpp\n[START OBJECT]\n[NAME]Player[-NAME]\n[COMPONENT]Standard Graphics[-COMPONENT]\n[COMPONENT]Transform[-COMPONENT]\n[COMPONENT]Player Update[-COMPONENT]\n[LOCATION X]50[-LOCATION X]\n[LOCATION Y]40[-LOCATION Y]\n[WIDTH]3.0[-WIDTH]\n[HEIGHT]2.0[-HEIGHT]\n[BITMAP NAME]playership[-BITMAP NAME]\n[ENCOMPASSING RECT COLLIDER]player[-ENCOMPASSING_RECT COLLIDER]\n[SPEED]10.0[-SPEED]\n[END OBJECT]\n```", "```cpp\n#pragma once\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nclass GameObjectBlueprint {\nprivate:\n    string m_Name = \"\";\n    vector<string> m_ComponentList;\n    string m_BitmapName = \"\";\n    float m_Width;\n    float m_Height;\n    float m_LocationX;\n    float m_LocationY;\n    float m_Speed;\n    bool m_EncompassingRectCollider = false;\n    string m_EncompassingRectColliderLabel = \"\";    \npublic:\n    float getWidth();\n    void setWidth(float width);\n    float getHeight();\n    void setHeight(float height);\n    float getLocationX();\n    void setLocationX(float locationX);\n    float getLocationY();\n    void setLocationY(float locationY);\n    void setName(string name);\n    string getName();\n    vector<string>& getComponentList();\n    void addToComponentList(string newComponent);\n    string getBitmapName();\n    void setBitmapName(string bitmapName);    \n    string getEncompassingRectColliderLabel();\n    bool getEncompassingRectCollider();\n    void setEncompassingRectCollider(string label);\n};\n```", "```cpp\n#include \"GameObjectBlueprint.h\"\nfloat GameObjectBlueprint::getWidth() \n{\n    return m_Width;\n}\nvoid GameObjectBlueprint::setWidth(float width) \n{\n    m_Width = width;\n}\nfloat GameObjectBlueprint::getHeight() \n{\n    return m_Height;\n}\nvoid GameObjectBlueprint::setHeight(float height) \n{\n    m_Height = height;\n}\nfloat GameObjectBlueprint::getLocationX() \n{\n    return m_LocationX;\n}\nvoid GameObjectBlueprint::setLocationX(float locationX) \n{\n    m_LocationX = locationX;\n}\nfloat GameObjectBlueprint::getLocationY() \n{\n    return m_LocationY;\n}\nvoid GameObjectBlueprint::setLocationY(float locationY) \n{\n    m_LocationY = locationY;\n}\nvoid GameObjectBlueprint::setName(string name)\n{\n    m_Name = \"\" + name;\n}\nstring GameObjectBlueprint::getName()\n{\n    return m_Name;\n}\nvector<string>& GameObjectBlueprint::getComponentList()\n{\n    return m_ComponentList;\n}\nvoid GameObjectBlueprint::addToComponentList(string newComponent)\n{\n    m_ComponentList.push_back(newComponent);\n}\nstring GameObjectBlueprint::getBitmapName()\n{\n    return m_BitmapName;\n}\nvoid GameObjectBlueprint::setBitmapName(string bitmapName)\n{\n    m_BitmapName = \"\" + bitmapName;\n}\nstring GameObjectBlueprint::getEncompassingRectColliderLabel() \n{\n    return m_EncompassingRectColliderLabel;\n}\nbool GameObjectBlueprint::getEncompassingRectCollider() \n{\n    return m_EncompassingRectCollider;\n}\nvoid GameObjectBlueprint::setEncompassingRectCollider(\n    string label) \n{\n    m_EncompassingRectCollider = true;\n    m_EncompassingRectColliderLabel = \"\" + label;\n}\n```", "```cpp\n#pragma once\n#include <string>\nusing namespace std;\nstatic class ObjectTags {\npublic:\n    static const string START_OF_OBJECT;\n    static const string END_OF_OBJECT;\n    static const string COMPONENT;\n    static const string COMPONENT_END;\n    static const string NAME;\n    static const string NAME_END;\n    static const string WIDTH;\n    static const string WIDTH_END;\n    static const string HEIGHT;\n    static const string HEIGHT_END;\n    static const string LOCATION_X;\n    static const string LOCATION_X_END;\n    static const string LOCATION_Y;\n    static const string LOCATION_Y_END;\n    static const string BITMAP_NAME;\n    static const string BITMAP_NAME_END;\n    static const string ENCOMPASSING_RECT_COLLIDER;\n    static const string ENCOMPASSING_RECT_COLLIDER_END;\n};\n```", "```cpp\n#include \"DevelopState.h\"\n#include \"objectTags.h\"\nconst string ObjectTags::START_OF_OBJECT = \"[START OBJECT]\";\nconst string ObjectTags::END_OF_OBJECT = \"[END OBJECT]\";\nconst string ObjectTags::COMPONENT = \"[COMPONENT]\";\nconst string ObjectTags::COMPONENT_END = \"[-COMPONENT]\";\nconst string ObjectTags::NAME = \"[NAME]\";\nconst string ObjectTags::NAME_END = \"[-NAME]\";\nconst string ObjectTags::WIDTH = \"[WIDTH]\";\nconst string ObjectTags::WIDTH_END = \"[-WIDTH]\";\nconst string ObjectTags::HEIGHT = \"[HEIGHT]\";\nconst string ObjectTags::HEIGHT_END = \"[-HEIGHT]\";\nconst string ObjectTags::LOCATION_X = \"[LOCATION X]\";\nconst string ObjectTags::LOCATION_X_END = \"[-LOCATION X]\";\nconst string ObjectTags::LOCATION_Y = \"[LOCATION Y]\";\nconst string ObjectTags::LOCATION_Y_END = \"[-LOCATION Y]\";\nconst string ObjectTags::BITMAP_NAME = \"[BITMAP NAME]\";\nconst string ObjectTags::BITMAP_NAME_END = \"[-BITMAP NAME]\";\nconst string ObjectTags::ENCOMPASSING_RECT_COLLIDER = \n    \"[ENCOMPASSING RECT COLLIDER]\";\n\nconst string ObjectTags::ENCOMPASSING_RECT_COLLIDER_END \n    = \"[-ENCOMPASSING_RECT COLLIDER]\";\n```", "```cpp\n#pragma once\n#include \"GameObjectBlueprint.h\"\n#include <string>\nusing namespace std;\nclass BlueprintObjectParser {\nprivate:\n    string extractStringBetweenTags(\n        string stringToSearch, string startTag, string endTag);\npublic:\n    void parseNextObjectForBlueprint(\n        ifstream& reader, GameObjectBlueprint& bp);\n};\n```", "```cpp\n#include \"BlueprintObjectParser.h\"\n#include \"ObjectTags.h\"\n#include <iostream>\n#include <fstream>\nvoid BlueprintObjectParser::parseNextObjectForBlueprint(\n    ifstream& reader, GameObjectBlueprint& bp)\n{\n    string lineFromFile;\n    string value = \"\";\n    while (getline(reader, lineFromFile)) \n    {\n        if (lineFromFile.find(ObjectTags::COMPONENT) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n                ObjectTags::COMPONENT, \n                ObjectTags::COMPONENT_END);\n            bp.addToComponentList(value);\n        }\n        else if (lineFromFile.find(ObjectTags::NAME) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n                ObjectTags::NAME, ObjectTags::NAME_END);\n            bp.setName(value);\n        }\n        else if (lineFromFile.find(ObjectTags::WIDTH) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n                ObjectTags::WIDTH, ObjectTags::WIDTH_END);\n            bp.setWidth(stof(value));\n        }\n        else if (lineFromFile.find(ObjectTags::HEIGHT) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n                ObjectTags::HEIGHT, ObjectTags::HEIGHT_END);\n            bp.setHeight(stof(value));\n        }\n        else if (lineFromFile.find(ObjectTags::LOCATION_X) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n                ObjectTags::LOCATION_X, \n                ObjectTags::LOCATION_X_END);\n            bp.setLocationX(stof(value));\n        }\n        else if (lineFromFile.find(ObjectTags::LOCATION_Y) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(\n                      lineFromFile, \n                      ObjectTags::LOCATION_Y, \n                      ObjectTags::LOCATION_Y_END);\n            bp.setLocationY(stof(value));\n        }\n        else if (lineFromFile.find(ObjectTags::BITMAP_NAME) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n             ObjectTags::BITMAP_NAME, \n             ObjectTags::BITMAP_NAME_END);\n            bp.setBitmapName(value);\n        }\n\n        else if (lineFromFile.find(\n            ObjectTags::ENCOMPASSING_RECT_COLLIDER) \n            != string::npos) \n          {\n            value = extractStringBetweenTags(lineFromFile, \n                ObjectTags::ENCOMPASSING_RECT_COLLIDER, \n                ObjectTags::ENCOMPASSING_RECT_COLLIDER_END);\n            bp.setEncompassingRectCollider(value);\n        }\n\n        else if (lineFromFile.find(ObjectTags::END_OF_OBJECT) \n            != string::npos) \n        {\n            return;\n        }\n    }\n}\nstring BlueprintObjectParser::extractStringBetweenTags(\n    string stringToSearch, string startTag, string endTag)\n{\n    int start = startTag.length();\n    int count = stringToSearch.length() - startTag.length() \n        - endTag.length();\n    string stringBetweenTags = stringToSearch.substr(\n        start, count);\n    return stringBetweenTags;\n}\n```", "```cpp\n#pragma once\n#include <vector>\n#include <string>\n#include \"GameObject.h\"\n#include \"BlueprintObjectParser.h\"\n#include \"GameObjectFactoryPlayMode.h\"\nusing namespace std;\nclass PlayModeObjectLoader {\nprivate:\n    BlueprintObjectParser m_BOP;\n    GameObjectFactoryPlayMode m_GameObjectFactoryPlayMode;\npublic:\n    void loadGameObjectsForPlayMode(\n        string pathToFile, vector<GameObject>& mGameObjects);\n};\n```", "```cpp\n#include \"PlayModeObjectLoader.h\"\n#include \"ObjectTags.h\"\n#include <iostream>\n#include <fstream>\nvoid PlayModeObjectLoader::\n    loadGameObjectsForPlayMode(\n        string pathToFile, vector<GameObject>& gameObjects)\n{\n    ifstream reader(pathToFile);\n    string lineFromFile;\n    float x = 0, y = 0, width = 0, height = 0;\n    string value = \"\";\n    while (getline(reader, lineFromFile)) {\n        if (lineFromFile.find(\n            ObjectTags::START_OF_OBJECT) != string::npos) {\n            GameObjectBlueprint bp;\n            m_BOP.parseNextObjectForBlueprint(reader, bp);\n            m_GameObjectFactoryPlayMode.buildGameObject(\n                bp, gameObjects);\n        }\n    }       \n}\n```", "```cpp\n#pragma once\n#include \"GameObjectBlueprint.h\"\n#include \"GameObject.h\"\n#include <vector>\nclass GameObjectFactoryPlayMode {\npublic:\n    void buildGameObject(GameObjectBlueprint& bp, \n        std::vector <GameObject>& gameObjects);\n};\n```", "```cpp\n#include \"GameObjectFactoryPlayMode.h\"\n#include <iostream>\n#include \"TransformComponent.h\"\n#include \"StandardGraphicsComponent.h\"\n#include \"PlayerUpdateComponent.h\"\n#include \"RectColliderComponent.h\"\n#include \"InvaderUpdateComponent.h\"\n#include \"BulletUpdateComponent.h\"\nvoid GameObjectFactoryPlayMode::buildGameObject(\n    GameObjectBlueprint& bp, \n    std::vector<GameObject>& gameObjects)\n{\n    GameObject gameObject;\n    gameObject.setTag(bp.getName());\n    auto it = bp.getComponentList().begin();\n    auto end = bp.getComponentList().end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        if (*it == \"Transform\")\n        {\n            gameObject.addComponent(\n                make_shared<TransformComponent>(\n                bp.getWidth(),\n                bp.getHeight(),\n                Vector2f(bp.getLocationX(),\n                 bp.getLocationY())));\n        }\n        else if (*it == \"Player Update\")\n        {\n            gameObject.addComponent(make_shared\n                <PlayerUpdateComponent>());\n        }\n        else if (*it == \"Invader Update\")\n        {\n            gameObject.addComponent(make_shared\n                <InvaderUpdateComponent>());\n        }\n        else if (*it == \"Bullet Update\")\n        {\n            gameObject.addComponent(make_shared\n                <BulletUpdateComponent>());\n        }\n        else if (*it == \"Standard Graphics\")\n        {\n            shared_ptr<StandardGraphicsComponent> sgp =\n                make_shared<StandardGraphicsComponent>();\n            gameObject.addComponent(sgp);\n            sgp->initializeGraphics(\n                bp.getBitmapName(),\n                Vector2f(bp.getWidth(), \n                    bp.getHeight()));\n        }        \n    }\n    if (bp.getEncompassingRectCollider()) {\n        shared_ptr<RectColliderComponent> rcc = \n            make_shared<RectColliderComponent>(\n            bp.getEncompassingRectColliderLabel());\n        gameObject.addComponent(rcc);\n        rcc->setOrMoveCollider(bp.getLocationX(),\n            bp.getLocationY(),\n            bp.getWidth(),\n            bp.getHeight());\n    }   \n\n    gameObjects.push_back(gameObject);\n}\n```", "```cpp\nGameObject gameObject;\ngameObject.setTag(bp.getName());\n```", "```cpp\nif (*it == \"Transform\")\n{\n    gameObject.addComponent(make_shared<TransformComponent>(\n        bp.getWidth(),\n        bp.getHeight(),\n        Vector2f(bp.getLocationX(), bp.getLocationY())));\n}\n```", "```cpp\nelse if (*it == \"Player Update\")\n{\n    gameObject.addComponent(make_shared\n        <PlayerUpdateComponent>());\n}\n```", "```cpp\nelse if (*it == \"Invader Update\")\n{\n    gameObject.addComponent(make_shared\n        <InvaderUpdateComponent>());\n}\nelse if (*it == \"Bullet Update\")\n{\n    gameObject.addComponent(make_shared\n        <BulletUpdateComponent>());\n}\nelse if (*it == \"Standard Graphics\")\n{\n    shared_ptr<StandardGraphicsComponent> sgp =\n        make_shared<StandardGraphicsComponent>();\n    gameObject.addComponent(sgp);\n    sgp->initializeGraphics(\n        bp.getBitmapName(),\n        Vector2f(bp.getWidth(), \n            bp.getHeight()));\n}\n```", "```cpp\nif (bp.getEncompassingRectCollider()) {\n        shared_ptr<RectColliderComponent> rcc = \n            make_shared<RectColliderComponent>(\n            bp.getEncompassingRectColliderLabel());\n        gameObject.addComponent(rcc);\n        rcc->setOrMoveCollider(bp.getLocationX(),\n            bp.getLocationY(),\n            bp.getWidth(),\n            bp.getHeight());\n}\n```", "```cpp\ngameObjects.push_back(gameObject);\n```", "```cpp\n#pragma once\n#include<vector>\n#include<string>\nclass GameObject;\nclass GameObjectSharer {\npublic:\n    virtual std::vector<GameObject>& getGameObjectsWithGOS() = 0;\n    virtual GameObject& findFirstObjectWithTag(\n             std::string tag) = 0;\n};\n```", "```cpp\n/*********************************\n******THIS IS AN INTERFACE********\n*********************************/\n```", "```cpp\n#pragma once\n#include \"GameObject.h\"\n#include <vector>\n#include <string>\n#include \"GameObjectSharer.h\"\nusing namespace std;\nclass LevelManager : public GameObjectSharer {\nprivate:\n    vector<GameObject> m_GameObjects;\n    const std::string WORLD_FOLDER = \"world\";\n    const std::string SLASH = \"/\";\n    void runStartPhase();\n    void activateAllGameObjects();\npublic:\n    vector<GameObject>& getGameObjects();\n    void loadGameObjectsForPlayMode(string screenToLoad);\n    /****************************************************\n    *****************************************************\n    From GameObjectSharer interface\n    *****************************************************\n    *****************************************************/\n    vector<GameObject>& GameObjectSharer::getGameObjectsWithGOS()\n    {\n        return m_GameObjects;\n    }\n    GameObject& GameObjectSharer::findFirstObjectWithTag(\n         string tag)\n    {\n        auto it = m_GameObjects.begin();\n        auto end = m_GameObjects.end();\n        for (it;\n            it != end;\n            ++it)\n        {\n            if ((*it).getTag() == tag)\n            {\n                return (*it);\n            }\n        }\n\n#ifdef debuggingErrors        \n    cout << \n        \"LevelManager.h findFirstGameObjectWithTag() \" \n        << \"- TAG NOT FOUND ERROR!\" \n        << endl;\n#endif    \n        return m_GameObjects[0];\n    }\n};\n```", "```cpp\n#include \"LevelManager.h\"\n#include \"PlayModeObjectLoader.h\"\n#include <iostream>\nvoid LevelManager::\n    loadGameObjectsForPlayMode(string screenToLoad)\n{\n    m_GameObjects.clear();\n    string levelToLoad = \"\" \n        + WORLD_FOLDER + SLASH + screenToLoad;\n    PlayModeObjectLoader pmol;\n    pmol.loadGameObjectsForPlayMode(\n        levelToLoad, m_GameObjects);\n    runStartPhase();\n}\nvector<GameObject>& LevelManager::getGameObjects()\n{\n    return m_GameObjects;\n}\nvoid LevelManager::runStartPhase()\n{\n    auto it = m_GameObjects.begin();\n    auto end = m_GameObjects.end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        (*it).start(this);\n    }\n    activateAllGameObjects();\n}\nvoid LevelManager::activateAllGameObjects()\n{\n    auto it = m_GameObjects.begin();\n    auto end = m_GameObjects.end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        (*it).setActive();\n    }\n}\n```", "```cpp\n#pragma once\n#include <string>\n#include <vector>\n#include \"GameObject.h\"\n#include \"GameObjectSharer.h\"\nusing namespace std;\nclass ScreenManagerRemoteControl\n{\npublic:\n    virtual void SwitchScreens(string screenToSwitchTo) = 0;\n    virtual void loadLevelInPlayMode(string screenToLoad) = 0;\n    virtual vector<GameObject>& getGameObjects() = 0;\n    virtual GameObjectSharer& shareGameObjectSharer() = 0;\n};\n```", "```cpp\n...\n#include \"SelectScreen.h\"\n//#include \"LevelManager.h\"\n#include \"BitmapStore.h\"\n...\n...\nprivate:\n    map <string, unique_ptr<Screen>> m_Screens;\n    //LevelManager m_LevelManager;\nprotected:\n    ...\n    ...\n/****************************************************\n*****************************************************\nFrom ScreenManagerRemoteControl interface\n*****************************************************\n*****************************************************/\n    ...\n    ...\n//vector<GameObject>& \n        //ScreenManagerRemoteControl::getGameObjects()\n    //{\n        //return m_LevelManager.getGameObjects();\n    //}\n    //GameObjectSharer& shareGameObjectSharer()\n    //{\n        //return m_LevelManager;\n    //}\n    ...\n    ...\n```", "```cpp\n//#include \"LevelManager.h\"\n```", "```cpp\n#include \"LevelManager.h\"\n```", "```cpp\nvoid ScreenManagerRemoteControl::\n        loadLevelInPlayMode(string screenToLoad)\n    {\n        //m_LevelManager.getGameObjects().clear();\n        //m_LevelManager.\n            //loadGameObjectsForPlayMode(screenToLoad);\n        SwitchScreens(\"Game\");\n    }\n//vector<GameObject>& \n    //ScreenManagerRemoteControl::getGameObjects()\n//{\n    //return m_LevelManager.getGameObjects();\n//}\n```", "```cpp\nvoid ScreenManagerRemoteControl::\n    loadLevelInPlayMode(string screenToLoad)\n{\n    m_LevelManager.getGameObjects().clear();\n    m_LevelManager.\n        loadGameObjectsForPlayMode(screenToLoad);\n    SwitchScreens(\"Game\");\n}\nvector<GameObject>& \n    ScreenManagerRemoteControl::getGameObjects()\n{\n    return m_LevelManager.getGameObjects();\n}\n```"]