- en: Qt Graphical Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](34ba2c98-98be-433d-b868-9aa7745dd6a6.xhtml), *Library Management
    System with Pointers*, we developed abstract datatypes and a library management
    system. However, those applications were text-based. In this chapter, we will
    look into three graphical applications that we will develop with the Qt graphical
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock**: We will develop an analog clock with hour, minute, and second hands,
    with lines to mark hours, minutes, and seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The drawing program**: A program that draws lines, rectangles, and ellipses
    in different colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The editor**: A program where the user can input and edit text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also learn about the Qt library:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows and widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus and toolbars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing figures and writing text in the window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to catch mouse and keyboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the clock application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the next chapter, we will work with Qt, which is an object-oriented
    class library for graphical applications. We will also work with Qt Creator, instead
    of Visual Studio, which is an integrated development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a new graphical project in Qt Creator, we select New File or Project in
    the File menu, which makes the New File or Project dialog window become visible.
    We select Qt Widgets Application, and click the Choose button.
  prefs: []
  type: TYPE_NORMAL
- en: Then the Introduction and Project Location dialog becomes visible. We name the
    project `Clock`, place it in an appropriate location, and click the Next button.
    In the KitSelection dialog, we select the latest version of the Qt library, and
    click Next. In the Class Information dialog, we name the base class of the application
    `clock`. Normally, the window of a graphical application inherits a `window` class.
    In this case, however, we are dealing with a relatively simple application. Therefore,
    we inherit the Qt class `QWidget`, even though a widget often refers to a smaller
    graphical object that is often embedded in the window. In Qt Creator, it is possible
    to add forms. However, we do not use that feature in this chapter. Therefore,
    we uncheck the Generate form option.
  prefs: []
  type: TYPE_NORMAL
- en: All class names in Qt start with the letter `Q`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the Project Management dialog, we simply accept the default values
    and click Finish to generate the project, with the files `Clock.h` and `Clock.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: The Clock class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project is made up by the files `Clock.h`, `Clock.cpp`, and `Main.cpp`.
    The class definition looks a little bit different compared to the classes of the
    previous chapters. We enclose the class definition with *include guards*. That
    is, we must enclose the class definition with the preprocessor directive `ifndef`,
    `define`, and `endif`. The preprocessor performs text substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: The `ifndef` and `endif` directives work as the `if` statement in C++. If the
    condition is not true, the code between the directives is omitted. In this case,
    the code is included only if the `CLOCK_H` macro has not previously been defined.
    If the code is included, the macro becomes defined at the next line with the `define`
    directive. In this way, the class definition is included in the project only once.
    Moreover, we also include the system header files `QWidget` and `QTimer` in the
    `Clock.h` header file rather than the `Clock.cpp` definition file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Clock` is a subclass of the Qt `QWidget` class, the `Q_OBJECT` macro
    must be included, which includes certain code from the Qt library. We need it
    to use the `SIGNAL` and `SLOT` macros shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes a pointer to its parent widget, for which the default
    is `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called by the framework every time the window needs
    to be repainted. It takes a pointer to a `QPaintEvent` object as parameter, which
    can be used to determine in which way the repainting shall be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`QTimer` is a Qt system class that handles a timer. We will use that to move
    the hands of the clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The definition file is mainly made up of the `paintEvent` method, which handles
    the painting of the clock.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we call the base class `QWidget` with the `parentWidgetPtr`
    parameter (which may be `nullptr`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the title of the window to `Clock`. In Qt, we always use the `tr` function
    for literal text, which in turn calls the Qt method `translate` in the Qt `QCoreApplication`
    class that makes sure the text is translated into a form suitable to be displayed.
    We also resize the size of the window to 1000 x 500 pixels, which is appropriate
    for most screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a way to connect the timer with the clock widget: when the timer has
    finished its countdown, the clock shall be updated. For that purpose, Qt provides
    us with the Signal and Slot system. When the timer reaches its countdown, it calls
    its method `timeout`. We use the `connect` method together with the `SIGNAL` and
    `SLOT` macros to connect the call to `timeout` with the call to the `update` method
    in the Qt `QWidget` class, which updates the drawing of the clock. The `SIGNAL` macro
    registers that the call to timeout shall raise a signal, the `SLOT` macro registers
    that the update method shall be called when the signal is raised, and the `connect` method
    connects the signal with the slot. We have set up a connection between the timer''s
    timeout and the update of the clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `paintEvent` method is called every time the window needs to be repainted.
    It may be due to some external cause, such as the user resizes the window. It
    may also be due to a call to the `update` method of the `QMainWindow` class, which
    in turn eventually calls `paintEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we do not need any information about the event, so we enclose
    the `eventPtr` parameter in comments. The `width` and `height` methods give the
    width and height of the paintable part of the window, in pixels. We call the `qMin`
    method to decide the minimum side of the window, and the `currentTime` method
    of the `QTime` class to find the current time for the clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QPainter` class can be viewed as a painting canvas. We start by initializing
    it to appropriate aliasing. We then call the `translate` and `scale` methods to
    transform the physical size in pixels to the logical size of `200` * `200` units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We paint 60 lines for the minutes. Every fifth line shall be a little bit longer
    to mark the current hours. For each minute, we draw a line, and then we call the
    Qt `rotate` method, which rotates the drawing by `6` degrees. In this way, we
    rotate the drawing by 6 degrees 60 times, which sums up to 360 degrees, a whole
    lap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A complete leap is 360 degrees. For each line we rotate by `6` degrees, since
    360 divided by 60 is `6` degrees. When we are finished with the rotations, the
    drawing is reset to its original settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the current hour, minute, second, and millisecond from the `QTime`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the pen color to black and the background color to gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the endpoints of the hour hand. The hour hand is a little bit thicker
    and shorter than the minute and second hands. We define three points that constitute
    the endpoint of the hour hand. The base of the hour hand is 16 units long and
    located 8 units from the origin. Therefore, we set the x coordinate of the base
    points to `8` and `-8`, and the y coordinate to `8`. Finally, we define the length
    of the hour hand to `60` units. The value is negative in order to correspond with
    current rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save` method saves the current settings of the `QPointer` object. The
    settings are later restored by the `restore` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We find out the exact angle of the current hour hand by calculating the hours,
    minutes, seconds, and milliseconds. We then rotate to set the hour hand. Each
    hour corresponds to 30 degrees, since we have 12 hours, and 360 degrees divided
    by 12 is 30 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `drawConvexPloygon` method with the three points of the hour hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We draw the minute hand in the same way. It is a little bit thinner and longer
    than the hour hand. Another difference is that while we had 12 hours, we now have
    60 minutes. This gives that each minute corresponds to `6` degrees, since 360
    degrees divided by 60 is 6 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When calculating the current minute angle, we use the minutes, seconds, and
    milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawing of the second hand is almost identical to the drawing of the previous
    minute hand. The only difference is that we only use seconds and milliseconds
    to calculate the second angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `main` function, we initialize and start the Qt application. The `main`
    function can take the parameters `argc` and `argv`. It holds the command-line
    arguments of the applications; `argc` holds the number of arguments and the `argv`
    array holds the arguments themselves. The first entry of `argv` always holds the
    path to the execution file, and the last entry is always `nullptr`. The `QApplication`
    class takes `argc` and `argv` and initializes the Qt application. We create an
    object of our `Clock` class, and call `show` to make it visible. Finally, we call
    `exec` of the `QApplication` object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the application, we select the Run option on the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8a7f8f-c0bc-4cfb-b4b7-8aa2fa5e81f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The execution will continue until the user closes the `Clock` window by pressing
    the close button in the top-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f489094c-a214-400d-bdb7-32e03e57e385.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up reusable classes for windows and widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In graphical applications, there are windows and widgets. A window is often
    a complete window with a frame holding title, menu bar, and buttons for closing
    and resizing the window. A widget is often a smaller graphical object, often embedded
    in a window. In the *Clock* project, we used only a `widget` class that inherits
    the `QWidget` class. However, in this section we will leave the *Clock* project
    and look into more advanced applications with both a window and a widget. The
    window holds the frame with the menu bar and toolbar, while the widget is located
    in the window and takes care of the graphical content.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections of this chapter, we will look into a drawing program
    and an editor. Those applications are typical document applications, where we
    open and save documents, as well as also cut, copy, paste, and delete elements
    of the document. In order to add menus and toolbars to the window, we need to
    inherit the two Qt classes, `QMainWindow` and `QWidget`. We need `QMainWindow`
    to add menus and toolbars to the window frame, and `QWidget` to draw images in
    the window's area.
  prefs: []
  type: TYPE_NORMAL
- en: In order to reuse the document code in the applications introduced in the remaining
    part of this chapter and in the next chapter, in this section, we define the classes
    `MainWindow` and `DocumentWidget`. Those classes will then be used by the drawing
    program and the editor later in the following sections of this chapter. `MainWindow`
    sets up a window with the `File` and `Edit` menus and toolbars, while `DocumentWidget`
    provides a framework that sets up skeleton code for the `New`, `Open`, `Save`,
    `SaveAs`, `Cut`, `Copy`, `Paste`, `Delete`, and `Exit` items. In this section,
    we will not create a new Qt project, we will just write the classes `MainWindow` and
    `DocumentWidget`, which are used as base classes in the drawing program and editor
    later in this chapter, and the `LISTENER` macro, which is used to set up menu
    and toolbar items.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A listener is a method that is called when the user selects a menu item or a
    toolbar item. The `Listener` macro adds a listener to the class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listener.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Due to Qt rules regarding menus and toolbars, the listener called by the Qt
    Framework in response to a user action must be a function rather than a method.
  prefs: []
  type: TYPE_NORMAL
- en: A method belongs to a class, while a function is free-standing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DefineListener` macro defines both a friendly function and a method. The
    Qt Framework calls the function, which in turns calls the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Listener` macro is defined as a pointer to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The listener method takes an `QObject` pointer as a parameter and returns a
    Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The base window class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MainWindow` class sets up a document window with the `File` and `Edit`
    menus and toolbars. It also provides the `addAction` method, which is intended
    for subclasses to add application-specific menus and toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: '**MainWindow.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addAction` method adds a menu item, with a potential accelerator key,
    toolbar icon, and listeners to mark the item with a checkbox or a radio button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `DefineListener` macro to add a listener to decide whether a menu
    item shall be enabled. The listeners return `true` if the item shall be enabled.
    `DocumentWidget` is a sub class of the Qt class `QWidget`, which we will define
    in the next section. With the `DEFINE_LISTENER` macro, we add the `isSaveEnabled`,
    `isCutEnabled`, `isCopyEnabled`, `isPasteEnabled`, and `isDeleteEnabled` methods
    to the `MainWindow` class. They will be called when the user selects a menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onMenuShow` method is called before a menu becomes visible; it calls the
    listener of the items of the menu to decide whether they shall be disabled or
    annotated by a checkbox or a radio button. It is also called by the framework
    in order to disable toolbar icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_enableMap` and `m_checkMap` fields hold maps of listeners for the menu
    items. The preceding `onMenuShow` method uses them to decide whether to disable
    the item, or annotate it with a checkbox or a radio button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**MainWindow.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the constructor of the Qt `QMainWindow` class, with the
    parent widget pointer as its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When a menu item is added, it is connected to an action. The destructor deallocates
    all actions of the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addFileMenu` method adds the standard `File` menu to the menu bar; `menubar`
    is a Qt method that returns a pointer to the menu bar of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `connect` method which connects the menu item with the `onMenuShow`
    method in the following code snippet. The Qt macros `SIGNAL` and `SLOT` ensure
    that `onMenuShow` is called before the menu becomes visible. The `onMenuShow`
    method sets the enable, checkbox, and radio bottom status for each item of the
    menu before the menu becomes visible. It also sets the enable status of toolbars
    images. The `aboutToShow` method is called before each menu becomes visible in
    order to enable or disable the items, and to possibly mark them with check boxes
    or radio buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The Qt `addToolBar` method adds a toolbar to the window''s frame. When we call
    `addAction` here, the menu item will be added to the menu and, if present, to
    the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addAction` method adds the `New`, `Open`, `Save`, `SaveAs`, and `Exit`
    menu items. It takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the menu the item shall belong to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The item text. The ampersand (`&`) before the text (`&New`) indicates that the
    next letter (`N`) will be underlined, and that the user can select that item by
    pressing *Alt*-*N*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerator information. `QKeySequence` is a Qt enumeration holding accelerator
    key combinations. `QKeySequence::New` indicates that the user can select the item
    by pressing *Ctrl*-*N*. The text `Ctrl+N` will also be added to the item text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of an icon file (`new`). The icon of the file is displayed both to
    the left of the item text and on the toolbar. The icon file itself is added to
    the project in Qt Creator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the toolbar, `nullptr` if the item is not connected to a toolbar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text displayed when the user hovers with the mouse over the toolbar item.
    Ignored if the item is not connected to a toolbar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listeners (default `nullptr`) that are called before the menu and toolbar become
    visible, and deciding whether the item is enabled or marked with a checkbox or
    a radio button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When there are no changes in the document since it was last saved, the document
    does not need to be saved and the `Save` item shall be disabled. Therefore, we
    add an extra parameter, indicating that the `isSaveEnabled` method shall be called
    to enable or disable the menu and toolbar item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SaveAs` menu item has no key sequence. Moreover, it does not have a toolbar
    entry. Therefore, the name of the icon file and the toolbar text are default `QString`
    objects and the toolbar pointer is `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addSeparator` method adds a horizontal line between two items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addEditMenu` method adds the `Edit` menu to the window''s menu bar in
    the same way as the preceding `File` menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addAction` method adds a menu item to the menu bar and a toolbar icon
    to the toolbar. It also connects the item with the `onSelectPtr` method that is
    called when the user selects the item, and methods that enable the item and annotate
    it with a checkbox or radio button. An accelerator is added to the action, unless
    it is zero. The `groupPtr` parameter defines whether the item is part of a group.
    If `checkListener` is not `nullptr`, the item is annotated with a checkbox if
    `groupPtr` is `nullptr`, and with a radio button if it is not. In the case of
    radio buttons, only one radio button in the group will be marked at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If `iconName` is not empty, we load the icon from the file in the project resource
    and then create a new `QAction` object with the icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If `iconName` is empty, we create a new `QAction` object without the icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We connect the menu item to the selection method. When the user selects the
    item, or clicks on the toolbar icon, `onSelectPtr` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If the accelerator key is not zero, we add it to the action pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the action pointer to the menu pointer in order for it to process
    the user''s item selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If `toolBarPtr` is not `nullptr`, we add the action to the toolbar of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the status tip is not empty, we add it to the tooltip and status tip of
    the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the enable listener is not null, we add to `m_enableMap` a pair made up
    of a pointer to the central widget of the window and the listener. We also call
    the listener to initialize the enable status of the menu item and toolbar icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, if the check listener is not null, we add a pointer to the
    central widget of the window and the listener to `m_checkMap`. Both `m_enableMap`
    and `m_checkMap` are used by `onMenuShow`, as follows. We also call the listener
    to initialize the check status of the menu item (toolbar icons are not checked):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the group pointer is not null, we add the action to it. In that
    way, the menu item will be annotated by a radio button rather than a checkbox.
    The framework does also keep track of the groups and makes sure only one of the
    radio buttons of each group is marked at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `onMenuShow` method is called before a menu or toolbar icon becomes visible.
    It makes sure each item is enabled or disabled, and that the items are annotated
    with checkboxes or radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by iterating through the enable map. For each entry in the map, we
    look up the widget and the enable function. We call the function, which returns
    `true` or `false`, and use the result to enable or disable the item by calling
    `setEnabled` on the action object pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we iterate through the check map. For each entry in the map,
    we look up the widget and the check function. We call the function and use the
    result to check the item by calling `setCheckable` and `setChecked` on the action
    object pointer. The Qt Framework makes sure the item is annotated by radio buttons
    if it belongs to a group, and a checkbox if it does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The base widget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DocumentWidget` is a skeleton framework for applications that handle documents.
    It handles the loading and saving of the document, and provides methods to be
    overridden by subclasses for the `Cut`, `Copy`, `Paste`, and `Delete` menu items.'
  prefs: []
  type: TYPE_NORMAL
- en: While the preceding `MainWindow` class handles the window frame, with its menus
    and toolbars, the `DocumentWidget` class handles the drawing of the window's content.
    The idea is that the subclass of `MainWindow` creates an object of a subclass
    to `DocumentWidget` that it puts at the centrum of the window. See the constructors
    of `DrawingWindow` and `EditorWindow` in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**DocumentWidget.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes the name of the application, to be displayed at the top
    banner of the window, the filename mask to be used when loading and storing documents
    with the standard file dialogs, and a pointer to a potential parent widget (normally
    the enclosing main window):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setFilePath` method sets the path of the current document. The path is
    displayed at the top banner of the window and is given as a default path in the
    standard load and save dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When a document has been changed, the modified flag (sometimes called the dirty
    flag) is set. This causes an asterisk (`*`) to appear next to the file path at
    the top banner of the window, and the `Save` and `SaveAs` menu items to be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setMainWindowTitle` method is an auxiliary method that puts together the
    title of the window. It is made up by the file path and a potential asterisk (`*`)
    to indicate whether the modified flag is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `closeEvent` method is overridden from `QWidget` and is called when the
    user closes the window. By setting fields of the `eventPtr` parameter, the closing
    can be prevented. For example, if the document has not been saved, the user can
    be asked if they want to save the document or cancel the closing of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClearOk` method is an auxiliary method that displays a message box if
    the user tries to close the window or exit the application without saving the
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are called by the framework when the user selects a menu
    item or clicks a toolbar icon. In order for that to work, we mark the methods
    as slots, which is necessary for the `SLOT` macro in the `connect` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When a document has not been changed, it is not necessary to save it. In that
    case, the `Save` and `SaveAs` menu items and toolbars images shall be disabled.
    The `isSaveEnabled` method is called by `onMenuShow` before the `File` menu becomes
    visible. It returns true only when the document has been changed and needs to
    be saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tryWriteFile` method is an auxiliary method that tries to write the file.
    If it fails, a message box displays an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are virtual methods intended to be overridden by subclasses.
    They are called when the user selects the `New`, `Save`, `SaveAs`, and `Open`
    menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are called before the edit menu becomes visible, and
    they decide whether the `Cut`, `Copy`, `Paste`, and `Delete` items shall be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are called when the user selects the `Cut`, `Copy`, `Paste`,
    and `Delete` items or toolbar icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `m_applicationName` field holds the name of the application, not the document.
    In the next sections, the names will be *Drawing* and *Editor*. The `m_fileMask`
    field holds the mask that is used when loading and saving the document with the
    standard dialogs. For instance, let us say that we have documents with the ending
    `.abc`. Then the mask could be `Abc files (.abc)`. The `m_filePath` field holds
    the path of the current document. When the document is new and not yet saved,
    the field holds the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `m_modifiedFlag` is true when the document has been modified and needs
    to be saved before the application quits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there are some overloaded auxiliary operators. The addition and subtraction
    operators add and subtract a point with a size, and a rectangle with a size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writePoint` and `readPoint` methods write and read a point from an input
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeColor` and `readColor` methods write and read a color from an input
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeRect` method creates a rectangle with `point` as its center and `size`
    as its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '**DocumentWidget.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the name of the application, the file mask for the save
    and load standard dialogs, and a pointer to the enclosing parent widget (usually
    the enclosing main window):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor does nothing, it is included for completeness only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setFilePath` method calls `setMainWindowTitle` to update the text on the
    top banner of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setModifiedFlag` method also calls `setMainWindowTitle` to update the
    text on the top banner of the window. Moreover, it calls `onMenuShow` on the parent
    widget to update the icons of the toolbars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The title displayed at the top banner of the toolbar is the application name,
    the document file path (if not empty), and an asterisk if the document has been
    modified without being saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClearOk` method displays a message box if the document has been modified
    without being saved. The user can select one of the following buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes: The document is saved, and the application quits. However, if the saving
    fails, an error message is displayed and the application does not quit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No: The application quits without saving the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cancel: The closing of the application is cancelled. The document is not saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If the document is cleared, `newDocument` is called, which is intended to be
    overridden by a subclass to perform application-specific initialization. Moreover,
    the modified flag and the file path are cleared. Finally, the Qt `update` method
    is called to force a repainting of the window''s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If the document is cleared, `onOpen` uses the standard open dialog to obtain
    the file path of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file was successfully read, the modified flag is cleared, the file path
    is set, and `update` is called to force a repainting of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the reading was not successful, a message box with an error message
    is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ifSaveEnabled` method simply returns the value of `m_modifiedFlag`. However,
    we need the method for the listener to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onSave` method is called when the user selects the `Save` or `SaveAs`
    menu item or toolbar icon. If the document has already been given a name, we simply
    try to write the file. However, if it has not yet been given a name we call `OnSaveAs`,
    which displays the standard Save dialog for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onSaveAs` method is called when the user selects the `SaveAs` menu item
    (there is no toolbar icon for this item). It opens the standard open dialog and
    tries to write the file. If the writing was not successful, `false` is returned.
    The reason for this is that `isClearOk` closes the window only if the writing
    was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tryWriteFile` method tries to write the file by calling write, which is
    intended to be overridden by a subclass. If it succeeded, the modified flag and
    the file path are set. If the file was not successfully written, a message box
    with an error message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onExit` method is called when the user selects the `Exit` menu item. It
    checks whether it is clear to close the window, and exits the application if it
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The default behavior of `isCutEnabled` and `isDeleteEnabled` is to call `isCopyEnabled`,
    since they often are enabled on the same conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The default behavior of `onCut` is to simply call `onCopy` and `onDelete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The default behavior of the rest of the cut-and-copy methods is to return `false`
    and do nothing, which will leave the menu items disabled unless the subclass overrides
    the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `closeEvent` is called when the user tries to close the window. If
    the window is ready to be cleared, `accept` is called on `eventPtr`, which causes
    the window to be closed, and `exit` is called on the global `qApp` object, which
    causes the application to quit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the window is not ready to be cleared, `ignore` is called on `eventPtr`,
    which causes the window to remain open (and the application to continue):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, there are also the set of auxiliary functions for handling points,
    sizes, rectangles, and color. The following operators add and subtract a point
    with a size, and return the resulting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following operators add and subtract an integer from a rectangle, and return
    the resulting rectangle. The addition operator expands the size of the rectangle
    in every direction, while the subtraction operator shrinks the rectangle in every
    direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writePoint` and `readPoint` functions write and read a point from a file.
    They write and read the *x* and *y* coordinates separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeColor` and `readColor` functions write and read a color from a file.
    A color is made up of the `red`, `green`, and `blue` components. Each component
    is an integer value between `0` and `255` inclusive. The methods write and read
    the components from a file stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'When the components have been read, we create a `QColor` object that we assign
    the `color` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeRect` function creates a rectangle centered around the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Building the drawing program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now start a new project, where we take advantage of the main window and
    document widget classes of the previous section—*The drawing program*. We will
    start with a basic version in this chapter, and we will continue to build a more
    advanced version in the next chapter. With the drawing program of this chapter
    we can draw lines, rectangles, and ellipses in different colors. We can also save
    and load our drawings. Note that in this project the window and widget classes
    inherit from the `MainWindow` and `DocumentWidget` classes of the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The Figure base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The figures of the application constitute a class hierarchy where the `Figure`
    is the base class. Its subclasses are `Line`, `RectangleX`, and `EllipseX`, which
    are described later on. We cannot use the names *Rectangle* and *Ellipse* for
    our classes, since that would clash with Qt methods with the same names. I have
    chosen to simply add an '`X`' to the names.
  prefs: []
  type: TYPE_NORMAL
- en: The `Figure` class is abstract, which means that we cannot create an object
    of the class. We can only use it as a base class, which sub classes inherit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The following methods are pure virtual, which means that they do not need to
    be defined. A class with at least one pure virtual method becomes abstract. The
    sub classes must define all the pure virtual methods of all its base classes,
    or become abstract themselves. In this way, it is guaranteed that all methods
    of all non-abstract classes are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each sub class defines `getId` and returns the identity enumeration of its
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Each figure has a first and last point, and it is up to each sub class to define
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClick` method returns `true` if the figure is hit by the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` method moves the figures a certain distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` method draws the figure on the painter area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` and `read` methods write and read the figure from a file; `write`
    is constant since it does not change the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The `color` method returns the color of the figure. It comes in two versions,
    where the first version is constant and returns a reference to a constant `QColor`
    object, while the second version is non-constant and returns a reference to a
    non-constant object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filled` methods apply to two-dimensional figures (rectangles and ellipses)
    only. They return `true` if the figure is filled. Note that the second version
    returns a reference to the `m_filled` field, which allows the caller of the method
    to modify the value of `m_filled`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'When a figure is marked, it is drawn with small squares at its corners. The
    side of the squares are defined by the static field `Tolerance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeColor` and `readColor` methods are auxiliary methods that read and
    write a color. They are static since they are called by methods outside the `Figure`
    class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Each figure has a color, and it could be marked or filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The `Figure.cpp` file holds the definitions of the `Figure` class. It defines
    the `Tolerance` field as well as the `write` and `read` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '`Tolerance` must be defined and initialized in global space since it is static.
    We define the size of the mark squares to be `6` pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor is called only when figures are read from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` and `read` methods write and read the color of the figure, and
    whether the figure is filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The Line sub class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Line` class is a sub class of `Figure`. It becomes non-abstract by defining
    each pure virtual method of `Figure`. A line is drawn between two end-points,
    represented by the `m_firstPoint` to `m_lastPoint` fields in `Line`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4723c801-7788-48b8-8399-9bc2e7f4d2b2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Line.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor is called only when reading `Line` objects from a file;
    `getId` simply returns the identity enumeration of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'A line has two endpoints. Both points are set when the line is created, the
    second point is then modified when the user moves it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClick` method returns `true` if the mouse click is located on the line
    (with some tolerance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` method moves the line (both its end-points) the given distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` method draws the line on the `QPainter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` and `read` methods write and read the end-points of the line from
    a file stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The first and last points of the line are stored in the `Line` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The `Line.cpp` file defines the methods of the `Line` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Line.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initializePoints` method is called when the user adds a new line to the
    drawing. It sets both its end-points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setLastPoint` method is called when the user has added the line and modifies
    its shape. It sets the last point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClick` method tests whether the user has clicked with the mouse on the
    line. We have two cases to consider. The first case is a special case that occurs
    when the line is completely vertical, when the *x*-coordinates of the end-points
    are equal. We use the Qt `QRect` class to create a rectangle surrounding the line,
    and test whether the point is enclosed in the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9377e8e-8a2a-4fdf-8c0f-3e6f23276884.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In a general case, where the line is not vertical, we start by creating an enclosing
    rectangle and test if the mouse point is in it. If it is, we set `leftPoint` to
    the leftmost point of `firstPoint` and `lastPoint`, and `rightPoint` to the rightmost
    point. We then calculate the width (`lineWidth`) and height (`lineHeight`) of
    the enclosing rectangle, as well as the distance between `rightPoint` and `mousePoint`
    in the *x* and *y* directions (`diffWidth` and `diffHeight`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f051abb6-3200-45a4-bd8e-1ce97c0443a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Due to uniformity, the following equation is true if the mouse pointer hits
    the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94c97888-f928-420d-9f23-9f7308d283d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, in order for the left-hand expression to become exactly zero, the
    user has to click exactly on the line. Therefore, let us allow for a small tolerance.
    Let''s use the `Tolerance` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb006091-e45c-4af5-9ac4-13234e8b1bfe.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We must convert `lineHeight` to a double in order to perform non-integer division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse point is located outside the rectangle enclosing the line, we
    simply return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` method simply moves both the endpoints of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'When drawing the line, we set the pen color and draw the line. The `color`
    method of the `Figure` class returns the color of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing the line, we first call `write` in `Figure` to write the color
    of the figure. We then write the endpoints of the line. Finally, we return the
    Boolean value of the output stream, which is `true` if the writing was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, when reading the line, we first call `read` in `Figure` to
    read the color of the line. We then read the endpoints of the line and return
    the Boolean value of the input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The Rectangle sub class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RectangleX` is a sub class of `Figure` that handles a rectangle. Similar to
    `Line`, it holds two points, which holds opposite corners of the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rectangle.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding `Line` class, `RectangleX` has a default constructor
    that is used when reading the object from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '**Rectangle.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initializePoints` and `setLastPoint` methods work in a way similar to
    their counterparts in `Line`: `initializePoints` sets both the corner points,
    while `setLastPoint` sets the last corner point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClick` method is simpler than its counterpart in `Line`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rectangle is filled, we simply check whether the mouse click hit the
    rectangle by calling `contains` in `QRect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rectangle is not filled, we need to check whether the mouse clicked
    on the border of the rectangle. To do so, we create two slightly smaller and larger
    rectangles. If the mouse click hit the larger rectangle, but not the smaller one,
    we consider the rectangle border to be hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'When moving the rectangle, we simply move the first and last corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'When drawing a rectangle, we first set the pen color by calling `color` in
    `Figure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rectangle is filled, we simply call `fillRect` on the `QPainter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rectangle is unfilled, we disable the brush to make the rectangle hollow,
    and we then call `drawRect` on the `QPainter` object to draw the border of the
    rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` method first calls `write` in `Figure`, and it then writes the
    first and last corners of the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, `read` first calls `read` in `Figure`, and then reads the
    first and last corners of the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: The Ellipse sub class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EllipseX` is a sub class of `RectangleX` that handles an ellipse. Part of
    the functionality of `RectangleX` is reused in `EllipseX`. More specifically,
    `initializePoints`, `setLastPoint`, `move`, `write`, and `read` are overridden
    from `RectangleX`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ellipse.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '**Ellipse.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClick` method of `EllipseX` is similar to its counterpart in `RectangleX`.
    We use the Qt `QRegion` class to create elliptic objects that we compare to the
    mouse click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'If the ellipse is filled, we create an elliptic region and test whether the
    mouse click hit the region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'If the ellipse in unfilled, we create slightly smaller and larger elliptic
    regions. If the mouse click hit the smaller region, but not the smaller one, we
    consider the border of the ellipse to be hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'When drawing an ellipse, we first set the pen color by calling `color` in `Figure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'If the ellipse is filled, we set the brush and draw the ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'If the ellipse is unfilled, we set the brush to hollow and draw the ellipse
    border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DrawingWindow` class is a sub class to the `MainWindow` class of the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '**DrawingWindow.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '**DrawingWindow.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the size of the window to `1000` * `500` pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_drawingWidgetPtr` field is initialized to point at an object of the
    `DrawingWidget` class, which is then set to the center part of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard file menu is added to the window menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the application-specific format menu. It is connected to the `onMenuShow`
    method of the `DocumentWidget` class of the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The format menu holds the color and fill items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The fill item will be enabled when the next figure of the drawing program is
    a two-dimensional figure (rectangle or ellipse):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'For the figure menu, we create a new action group for the line, rectangle,
    and ellipse item. Only one of them shall be marked at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The currently selected item shall be marked with a radio button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor deallocates the figure group that was dynamically allocated
    in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DrawingWidget` is a sub class of `DocumentWidget` in the previous section.
    It handles mouse input, painting of the figures, as well as saving and loading
    of the drawing. It also provides methods for deciding when the menu items shall
    be marked and enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DrawingWidget.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent`, `mouseReleaseEvent`, and `mouseMoveEvent` are overridden
    methods that are called when the user presses or releases one of the mouse keys
    or moves the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called when the window needs to be repainted. That
    can happen for several reasons. For instance, the user can modify the size of
    the window. The repainting can also be forced by a call to the `update` method,
    which causes `paintEvent` to be called eventually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newDocument` method is called when the user selects the new menu item,
    `writeFile` is called when the user selects the save or save as item, and `readFile`
    is called when the user selects the open item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onColor` and `onFill` methods are called when the user selects the color
    and fill menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isFillEnabled` method is called before the user selects the format menu.
    If it returns `true`, the fill item becomes enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isLineChecked`, `isRectangleChecked`, and `isEllipseChecked` methods are
    also called before the figure menu becomes visible. The items become marked with
    a radio button if the methods return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onLine`, `onRectangle`, and `isEllipse` methods are called when the user
    selects the line, rectangle, and ellipse menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'When running, the application can hold the `Idle`, `Create`, or `Move` modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Idle`: When the application is waiting for input from the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create`: When the user is adding a new figure to the drawing. Occurs when
    the user presses the left mouse button without hitting a figure. A new figure
    is added and its end-point is modified until the user releases the mouse button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Move`: When the user is moving a figure. Occurs when the user presses the
    left mouse button and hitting a figure. The figure is moved until the user releases
    the mouse button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_currColor` field holds the color of the next figure to be added by the
    user; `m_currFilled` decides whether the next figure (if it is a rectangle or
    an ellipse) shall be filled. The `m_addFigureId` method holds the identity integer
    of the next type of figure (line, rectangle, or ellipse) to be added by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user presses a mouse button and moves a figure, we need to store the
    previous mouse point in order to calculate the distance the figure has been moved
    since the last mouse events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `m_figurePtrList` holds pointers to the figures of the drawing. The
    top-most figure in the drawing is placed at the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '**DrawingWidget.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the constructor the base class `DocumentWidget` with
    the title `Drawing`. It also sets the save and load mask to `Drawing files (*.drw)`,
    which means that the default files selected by the standard save and load dialogs
    have the suffix `drw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor deallocates the figure pointers of the figure pointer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setApplicationMode` method sets the application mode and calls `onMenuShow`
    in the main window for the toolbar icons to be correctly enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user selects the new menu item, `newDocument` is called. The figures
    of the figure pointer list are deallocated, and the list itself is cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The next figure to be added by the user is a black line, and the filled status
    is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeFile` method is called when the user selects the save or save as
    menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by writing the current color and fill status. We then continue by
    writing the size of the figure pointer list, and the figures themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'For each figure, we first write its identity number, and we then write the
    figure itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file was not possible to open, `false` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readFile` method is called when the user selects the open menu item. In
    the same way as in `writeFile` previously, we read the color and fill status,
    the size of the figure pointer list, and then the figures themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'When reading the figure, we first read its identity number, and call `createFigure`
    to create an object of the class corresponding to the figure''s identity number.
    We then read the fields of the figure by calling `read` on its pointer. Note that
    we do not really know (or care) what kind of figure it is. We simply call read
    to the figure pointer, which in fact points to an object of `Line`, `RectangleX`,
    or `EllipseX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createFigure` method dynamically creates an object of the `Line`, `RectangleX`,
    or `EllipseX` class, depending on the value of the `figureId` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onColor` method is called when the user selects the color menu item. It
    sets the color of the next figure to be added by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isFillEnabled` method is called before the format menu becomes visible,
    and returns `true` if the next figure to be added by the user is a rectangle or
    an ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onFill` method is called when the user selects fill menu item. It inverts
    the `m_currFilled` field. It also sets the modified flag since the document has
    been affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isLineChecked`, `isRectangleChecked`, and `isEllipseChecked` methods are
    called before the figure menu becomes visible. If they return `true`, the items
    become checked with a radio button if the next figure to be added is the figure
    in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onLine`, `onRectangle`, and `onEllipse` methods are called when the user
    selects the items in the figure menu. They set the next figure to be added by
    the user to the figure in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` method is called every time the user presses one of the
    mouse keys. First, we need to check if they have pressed the left mouse key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'In the call to `mouseMoveEvent` in the following snippet, we need to keep track
    of the latest mouse point in order to calculate the distance between mouse movements.
    Therefore, we set `m_mousePoint` to the mouse point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the figure pointer list and, for each figure, we check if
    the figure has been hit by the mouse click by calling `isClick`. We need to iterate
    backwards in a rather awkward manner in order to find the top-most figure first.
    We use the `reverse_iterator` class and the `rbegin` and `rend` methods in order
    to iterate backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the dereference operator (`*`) to obtain the figure pointer in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'If the figure has been hit by the mouse click, we set the application mode
    to move. We also place the figure at the end of the list, so that it appears to
    be top-most in the drawing, by calling `removeOne` and `push_back` on the list.
    Finally, we break the loop since we have found the figure we are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application mode is still idle (has not moved), we have not found a
    figure hit by the mouse click. In that case, we set the application mode to create
    and call `createFigure` to find a figure to copy. We then set the color and filled
    status as well as the points of the figure. Finally, we add the figure pointer
    to the figure pointer list by calling `push_back` (which is added at the end of
    the list in order for it to appear at the top of the drawing) and set the modified
    flag to `true`, since the drawing has been modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMoveEvent` is called every time the user moves the mouse. First,
    we need to check that the user presses the left mouse key when they move the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check the application mode. If we are in the process of adding a new
    figure to the drawing, we modify its last point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are in the process of moving a figure, we calculate the distance since
    the last mouse event and move the figure placed at the end of the figure pointer
    list. Remember that the figure hit by the mouse click was placed at the end of
    the figure pointer list in the preceding `mousePressEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the current mouse point for the next call to `mouseMoveEvent`.
    We also call the update method to force a repainting of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseReleaseEvent` method is called when the user releases one of the
    mouse buttons. We set the application mode to idle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The `paintEvent` method is called every time the window needs to be repainted.
    It may happen for several reasons. For instance, the user may have changed the
    size of the window. It may also be a result of a call to `update` in the Qt `QWidget`
    class, which forces a repainting of the window and an eventual call to `paintEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a `QPainter` object, which can be regarded as canvas to
    paint on, and set suitable rendering. We then iterate through the figure pointer
    list, and draw each figure. In this way, the last figure in the list is drawn
    at the top of the drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we start the application in the `main` function by creating an application
    object, showing the main window and executing the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25b6b2a9-d07d-4e9e-b8c8-28b2475353a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Building an editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next application is an editor, where the user can input and edit text. The
    current input position is indicated by a caret. It is possible to move the caret
    with the arrow keys and by clicking with the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The Caret class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Caret` class handles the caret; that is, the blinking vertical line marking
    the position of the next character to be input.
  prefs: []
  type: TYPE_NORMAL
- en: '**Caret.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show` and `hide` methods show and hide the caret. In this application,
    the caret is never hidden. However, in the advanced version in the next chapter,
    the caret will be hidden on some occasions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set` method sets the current size and position of the caret, and `paint`
    paints it on the `QPainter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onTimer` method is called every time the caret blinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_visible` field is true when the caret is visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_rect` field handles the timer that makes the caret blink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_timer` field handles the timer that makes the caret blink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: The `Caret.cpp` file holds the definitions of the methods of the `Caret` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Caret.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor connects the timer signal to `onTimer`, with the result that
    `onTimer` is called for every timeout. The timer is then initialized to `500`
    milliseconds. That is, `onTimer` will be called every `500` milliseconds, and
    the caret becomes shown and hidden every 500 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show` and `hide` methods set the `m_visible` field and force a repainting
    of the caret area by calling `update` on the parent window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set` method sets the size and position of the caret. However, the width
    of the caret is always set to one, which makes it appear as a thin vertical line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onTimer` method is called every 500 milliseconds. It inverts `m_blink`
    and forces a repaint of the caret. This gives the result that the caret blinks
    at an interval of one second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paint` method is called every time the caret needs to be repainted. The
    caret is drawn if both `m_visible` and `m_blink` are true, which they are if the
    caret is set to be visible and the caret is blinking; that is, that the caret
    is visible in the blinking interval. The area of the caret is cleared before the
    call to paint, so that if no drawing occurs, the caret is cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the editor window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EditorWindow` is a sub class of `MainWindow` in the previous section. It handles
    the closing of the window. Moreover, it also handles the key press event.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorWindow.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyPressEvent` method is called every time the user presses a key, and
    `closeEvent` is called when the user tries closing the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: The `EditorWindow` class is in fact rather small. It only defines the constructor
    and the destructor, as well as the `keyPressEvent` and `closePressEvent` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorWindow.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the size of the window to `1000` * `500` pixels and adds
    the standard file menu to the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyPressEvent` and `closeEvent` methods just pass the message to their
    counterpart methods in the editor widget, which is located at the center of the
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the editor widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EditorWidget` class is a sub class of `DocumentWidget` of the previous
    section. It catches the key, mouse, resizing, and closing events. It also overrides
    the methods for saving and loading documents.
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorWidget.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyPressEvent` is called when the user presses a key, and `mousePressEvent`
    is called when the user clicks with the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseToIndex` method is an auxiliary method that calculates the index
    of the character the user clicks at with the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called when the window needs to be repainted, and
    `resizeEvent` is called when the user resizes the window. We catch the resize
    event in this application because we want to recalculate the number of characters
    that fits on each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the drawing program in the previous section, `newDocument` is called
    when the user selects the New menu item, `writeFile` is called when the user selects
    the save or save as items, and `readFile` is called when the user selects the
    open item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setCaret` method is called to set the caret as a response to user input
    or a mouse click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user moves the caret up or down, we need to find the index of character
    over or under the caret. The easiest way to do that is to simulate a mouse click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculate` method is an auxiliary method that calculates the number of
    lines, and the position of each character on each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_editIndex` field holds the index of the position for the user to input
    text. That position is also where the caret is visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_caret` field holds the caret of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'The text of the editor is stored in `m_editorText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'The text of the editor may be distributed over several lines; `m_lineList`
    keeps track of the first and last index of each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `calculate` method calculates the rectangle of each character
    in the editor text, and places them in `m_rectList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'In the application of this chapter, all characters hold the same font, which
    is stored in `TextFont`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '`FontWidth` and `FontHeight` hold the width and height of a character in `TextFont`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The `EditorWidget` class is rather large. It defines the functionality of the
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorWidget.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the text font to 12-point `Courier New`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the title to `Editor` and the file suffix for the standard
    Load and Save dialogs to `edi`. The height and average width, in pixels, of a
    character in the text font are set with the Qt `QMetrics` class. The rectangle
    of each character is calculated, and the caret is set to the first character in
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newDocument` method is called when the user selects the new menu item.
    It clears the text, sets the caret, and recalculates the character rectangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeFile` method is called when the user selects the save or save as
    menu items. It simply writes the current text of the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Ok` field of the input stream to decide if the writing was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'If it was not possible to open the file for writing, `false` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readFile` method is called when the user selects the load menu item. It
    reads all the text of the editor by calling `readAll` on the input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'When the text has been read, the character rectangles are calculated, and the
    caret is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Ok` field of the input stream to decide if the reading was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'If it was not possible to open the file for reading, `false` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` is called when the user presses one of the mouse buttons.
    If the user presses the left button, we call `mouseToIndex` to calculate the index
    of the character clicked at, and set the caret to that index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyPressEvent` is called when the user presses a key. First, we check
    if it is an arrow key, the delete, backspace, or return key. If it is not, we
    insert the character at the position indicated by the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is the left-arrow key, and if the edit caret is not already located
    at the beginning of the text, we decrease the edit index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is the right-arrow key, and if the edit caret is not already located
    at the end of the text, we increase the edit index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is the up-arrow key, and if the edit caret is not already located
    at the top of the editor, we call `similateMouseClick` to simulate that the user
    clicks with the mouse at a point slightly over the current index. In that way,
    the new edit index will at the line over the current line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is the down-arrow key, we call `similateMouseClick` to simulate
    that the user clicks with the mouse at a point slightly under the current index.
    In that way, we the edit carat will be located at the character directly beneath
    the current character. Note that if the index is already at the bottom line, nothing
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user presses the delete key, and the edit index is not already beyond
    the end of the text, the current character is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user presses the backspace key, and the edit index is not already at
    the beginning of the text, the character before the current character is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user presses the return key, the newline character (`n`) is inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user presses a readable character, it is given by the `text` method,
    and we insert its first character at the edit index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'When the text has been modified, we need to calculate the character rectangles,
    set the caret, and force a repaint by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'The `similateMouseClick` method simulates a mouse click by calling `mousePressEvent`
    and `mousePressRelease` with the given point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setCaret` method creates a rectangle holding the size and position of
    the caret, and then hides, sets, and shows the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseToIndex` method calculates the edit index of the given mouse point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set the `y` coordinate to the text, in case it is below the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the line of the mouse point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'We find the index on that line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resizeEvent` method is called when the user changes the size of the window.
    The character rectangles are recalculated since the lines may be shorter or longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculate` method is called every time there has been a change in the
    text or when the window size has been changed. It iterates through the text and
    calculates the rectangle for each character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to divide the text into lines. Each line continues until it
    does not fit in the window, until we reach a new line, or until the text ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'We then iterate through the lines and, for each line, calculate the rectangle
    of each character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called when the window needs to be repainted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the text of the editor and, for each character except the
    new line, we write in its appropriate position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the `main` function works in a way similar to the previous applications
    of this chapter—we create an application, create an editor window, and execute
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a562a9ab-9bc0-4cbc-99f8-d3d7382a9605.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed three graphical applications with the Qt
    library—an analog clock, a drawing program, and an editor. The clock shows the
    current hour, minute, and second. In the drawing program we can draw lines, rectangles,
    and ellipses, and in the editor, we can input and edit text.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to work with the applications, and develop
    more advanced versions.
  prefs: []
  type: TYPE_NORMAL
