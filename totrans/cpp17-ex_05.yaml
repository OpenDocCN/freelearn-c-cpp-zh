- en: Qt Graphical Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 图形应用程序
- en: 'In [Chapter 4](34ba2c98-98be-433d-b868-9aa7745dd6a6.xhtml), *Library Management
    System with Pointers*, we developed abstract datatypes and a library management
    system. However, those applications were text-based. In this chapter, we will
    look into three graphical applications that we will develop with the Qt graphical
    library:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](34ba2c98-98be-433d-b868-9aa7745dd6a6.xhtml)，*指针库管理系统* 中，我们开发了抽象数据类型和库管理系统。然而，那些应用程序是基于文本的。在本章中，我们将探讨我们将使用
    Qt 图形库开发的三个图形应用程序：
- en: '**Clock**: We will develop an analog clock with hour, minute, and second hands,
    with lines to mark hours, minutes, and seconds'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟**：我们将开发一个带有时针、分针和秒针的模拟时钟，以及标记小时、分钟和秒的线条'
- en: '**The drawing program**: A program that draws lines, rectangles, and ellipses
    in different colors'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图程序**：一个可以以不同颜色绘制线条、矩形和椭圆的程序'
- en: '**The editor**: A program where the user can input and edit text'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器**：一个用户可以输入和编辑文本的程序'
- en: 'We will also learn about the Qt library:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解 Qt 库：
- en: Windows and widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口和小部件
- en: Menus and toolbars
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单和工具栏
- en: Drawing figures and writing text in the window
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口中绘制图形和写入文本
- en: How to catch mouse and keyboard events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何捕获鼠标和键盘事件
- en: Creating the clock application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建时钟应用程序
- en: In this chapter and the next chapter, we will work with Qt, which is an object-oriented
    class library for graphical applications. We will also work with Qt Creator, instead
    of Visual Studio, which is an integrated development environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将使用 Qt，它是一个面向对象的类库，用于图形应用程序。我们还将使用 Qt Creator，而不是 Visual Studio，它是一个集成开发环境。
- en: Setting up the environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: When creating a new graphical project in Qt Creator, we select New File or Project in
    the File menu, which makes the New File or Project dialog window become visible.
    We select Qt Widgets Application, and click the Choose button.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 中创建新的图形项目时，我们在文件菜单中选择新建文件或项目，这将使新建文件或项目对话框窗口可见。我们选择 Qt Widgets
    应用程序，并点击选择按钮。
- en: Then the Introduction and Project Location dialog becomes visible. We name the
    project `Clock`, place it in an appropriate location, and click the Next button.
    In the KitSelection dialog, we select the latest version of the Qt library, and
    click Next. In the Class Information dialog, we name the base class of the application
    `clock`. Normally, the window of a graphical application inherits a `window` class.
    In this case, however, we are dealing with a relatively simple application. Therefore,
    we inherit the Qt class `QWidget`, even though a widget often refers to a smaller
    graphical object that is often embedded in the window. In Qt Creator, it is possible
    to add forms. However, we do not use that feature in this chapter. Therefore,
    we uncheck the Generate form option.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现简介和项目位置对话框。我们命名项目为 `Clock`，将其放置在适当的位置，并点击下一步按钮。在 KitSelection 对话框中，我们选择
    Qt 库的最新版本，并点击下一步。在类信息对话框中，我们命名应用程序的基类为 `clock`。通常，图形应用程序的窗口继承自 `window` 类。然而，在这种情况下，我们处理的是一个相对简单的应用程序。因此，我们继承
    Qt 类 `QWidget`，尽管小部件通常指的是经常嵌入窗口中的较小的图形对象。在 Qt Creator 中，可以添加表单。然而，我们本章不使用该功能。因此，我们取消选中生成表单选项。
- en: All class names in Qt start with the letter `Q`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 中的所有类名都以字母 `Q` 开头。
- en: Finally, in the Project Management dialog, we simply accept the default values
    and click Finish to generate the project, with the files `Clock.h` and `Clock.cpp`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在项目管理对话框中，我们简单地接受默认值并点击完成以生成项目，包括文件 `Clock.h` 和 `Clock.cpp`。
- en: The Clock class
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Clock` 类'
- en: The project is made up by the files `Clock.h`, `Clock.cpp`, and `Main.cpp`.
    The class definition looks a little bit different compared to the classes of the
    previous chapters. We enclose the class definition with *include guards*. That
    is, we must enclose the class definition with the preprocessor directive `ifndef`,
    `define`, and `endif`. The preprocessor performs text substitutions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 项目由文件 `Clock.h`、`Clock.cpp` 和 `Main.cpp` 组成。与前面章节中的类相比，类的定义看起来略有不同。我们使用 *include
    guards* 来包围类的定义。也就是说，我们必须使用预处理指令 `ifndef`、`define` 和 `endif` 来包围类的定义。预处理程序执行文本替换。
- en: The `ifndef` and `endif` directives work as the `if` statement in C++. If the
    condition is not true, the code between the directives is omitted. In this case,
    the code is included only if the `CLOCK_H` macro has not previously been defined.
    If the code is included, the macro becomes defined at the next line with the `define`
    directive. In this way, the class definition is included in the project only once.
    Moreover, we also include the system header files `QWidget` and `QTimer` in the
    `Clock.h` header file rather than the `Clock.cpp` definition file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifndef` 和 `endif` 指令在 C++ 中工作方式类似于 `if` 语句。如果条件不成立，则省略指令之间的代码。在这种情况下，只有当 `CLOCK_H`
    宏之前未定义时，才会包含代码。如果包含代码，则使用 `define` 指令在下一行定义宏。这样，类定义只包含在项目中一次。此外，我们还在 `Clock.h`
    头文件中而不是 `Clock.cpp` 定义文件中包含系统头文件 `QWidget` 和 `QTimer`。'
- en: '**Clock.h:**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clock.h:** '
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since `Clock` is a subclass of the Qt `QWidget` class, the `Q_OBJECT` macro
    must be included, which includes certain code from the Qt library. We need it
    to use the `SIGNAL` and `SLOT` macros shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Clock` 是 Qt `QWidget` 类的子类，必须包含 `Q_OBJECT` 宏，它包含来自 Qt 库的某些代码。我们需要它来使用这里显示的
    `SIGNAL` 和 `SLOT` 宏：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The constructor takes a pointer to its parent widget, for which the default
    is `nullptr`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受对其父小部件的指针，默认为 `nullptr`：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `paintEvent` method is called by the framework every time the window needs
    to be repainted. It takes a pointer to a `QPaintEvent` object as parameter, which
    can be used to determine in which way the repainting shall be performed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每当窗口需要重新绘制时，框架都会调用 `paintEvent` 方法。它接受一个指向 `QPaintEvent` 对象的指针作为参数，可以用来确定以何种方式执行重新绘制：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`QTimer` is a Qt system class that handles a timer. We will use that to move
    the hands of the clock:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer` 是一个 Qt 系统类，用于处理计时器。我们将使用它来移动时钟的指针：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The definition file is mainly made up of the `paintEvent` method, which handles
    the painting of the clock.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义文件主要由 `paintEvent` 方法组成，该方法处理时钟的绘制。
- en: '**Clock.cpp:**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clock.cpp:** '
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the constructor, we call the base class `QWidget` with the `parentWidgetPtr`
    parameter (which may be `nullptr`):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用 `parentWidgetPtr` 参数（可能为 `nullptr`）调用基类 `QWidget`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We set the title of the window to `Clock`. In Qt, we always use the `tr` function
    for literal text, which in turn calls the Qt method `translate` in the Qt `QCoreApplication`
    class that makes sure the text is translated into a form suitable to be displayed.
    We also resize the size of the window to 1000 x 500 pixels, which is appropriate
    for most screens:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将窗口标题设置为 `Clock`。在 Qt 中，我们始终使用 `tr` 函数用于文本字面量，它反过来调用 Qt `QCoreApplication`
    类中的 `translate` 方法，确保文本被转换为适合显示的形式。我们还调整窗口大小为 1000 x 500 像素，这对于大多数屏幕来说都是合适的：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need a way to connect the timer with the clock widget: when the timer has
    finished its countdown, the clock shall be updated. For that purpose, Qt provides
    us with the Signal and Slot system. When the timer reaches its countdown, it calls
    its method `timeout`. We use the `connect` method together with the `SIGNAL` and
    `SLOT` macros to connect the call to `timeout` with the call to the `update` method
    in the Qt `QWidget` class, which updates the drawing of the clock. The `SIGNAL` macro
    registers that the call to timeout shall raise a signal, the `SLOT` macro registers
    that the update method shall be called when the signal is raised, and the `connect` method
    connects the signal with the slot. We have set up a connection between the timer''s
    timeout and the update of the clock:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法将计时器与时钟小部件连接起来：当计时器完成倒计时后，时钟应该更新。为此，Qt 为我们提供了信号和槽系统。当计时器达到倒计时结束时，它调用其
    `timeout` 方法。我们使用 `connect` 方法以及 `SIGNAL` 和 `SLOT` 宏将 `timeout` 的调用与 Qt `QWidget`
    类中的 `update` 方法的调用连接起来，该调用更新时钟的绘制。`SIGNAL` 宏注册了调用 `timeout` 将引发一个信号，`SLOT` 宏注册了当信号被引发时将调用更新方法，`connect`
    方法将信号与槽连接起来。我们已经设置了计时器的超时与时钟更新的连接：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `paintEvent` method is called every time the window needs to be repainted.
    It may be due to some external cause, such as the user resizes the window. It
    may also be due to a call to the `update` method of the `QMainWindow` class, which
    in turn eventually calls `paintEvent`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当窗口需要重新绘制时，都会调用 `paintEvent` 方法。这可能是由于某些外部原因，例如用户调整窗口大小。也可能是由于对 `QMainWindow`
    类的 `update` 方法的调用，这最终会调用 `paintEvent`。
- en: 'In this case, we do not need any information about the event, so we enclose
    the `eventPtr` parameter in comments. The `width` and `height` methods give the
    width and height of the paintable part of the window, in pixels. We call the `qMin`
    method to decide the minimum side of the window, and the `currentTime` method
    of the `QTime` class to find the current time for the clock:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要任何关于事件的信息，所以我们用注释包围了 `eventPtr` 参数。`width` 和 `height` 方法给出窗口可绘制部分的宽度和高度，以像素为单位。我们调用
    `qMin` 方法来决定窗口的最小边长，并调用 `QTime` 类的 `currentTime` 方法来找到时钟的当前时间：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `QPainter` class can be viewed as a painting canvas. We start by initializing
    it to appropriate aliasing. We then call the `translate` and `scale` methods to
    transform the physical size in pixels to the logical size of `200` * `200` units:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter` 类可以被视为一个绘图画布。我们首先将其初始化为适当的抗锯齿。然后我们调用 `translate` 和 `scale` 方法将像素中的物理大小转换为
    `200` * `200` 单位的逻辑大小：'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We paint 60 lines for the minutes. Every fifth line shall be a little bit longer
    to mark the current hours. For each minute, we draw a line, and then we call the
    Qt `rotate` method, which rotates the drawing by `6` degrees. In this way, we
    rotate the drawing by 6 degrees 60 times, which sums up to 360 degrees, a whole
    lap:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为分钟绘制 60 条线。每隔第五条线会稍微长一些，以标记当前的小时。对于每一分钟，我们绘制一条线，然后调用 Qt 的 `rotate` 方法，该方法将绘图旋转
    `6` 度。这样，我们每次旋转绘图 `6` 度，总共旋转 `60` 次，累计达到 `360` 度，即一整圈：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A complete leap is 360 degrees. For each line we rotate by `6` degrees, since
    360 divided by 60 is `6` degrees. When we are finished with the rotations, the
    drawing is reset to its original settings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的跳跃是 `360` 度。对于每条线我们旋转 `6` 度，因为 `360` 除以 `60` 等于 `6` 度。当我们完成旋转后，绘图将重置到其原始设置：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We obtain the current hour, minute, second, and millisecond from the `QTime`
    object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `QTime` 对象中获取当前的小时、分钟、秒和毫秒：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We set the pen color to black and the background color to gray:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将画笔颜色设置为黑色，背景颜色设置为灰色：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We define the endpoints of the hour hand. The hour hand is a little bit thicker
    and shorter than the minute and second hands. We define three points that constitute
    the endpoint of the hour hand. The base of the hour hand is 16 units long and
    located 8 units from the origin. Therefore, we set the x coordinate of the base
    points to `8` and `-8`, and the y coordinate to `8`. Finally, we define the length
    of the hour hand to `60` units. The value is negative in order to correspond with
    current rotation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义时针的端点。时针比分针和秒针略粗短。我们定义构成时针端点的三个点。时针的底部长度为 `16` 单位，位于原点 `8` 单位处。因此，我们将底部点的
    x 坐标设置为 `8` 和 `-8`，y 坐标为 `8`。最后，我们定义时针的长度为 `60` 单位。这个值是负的，以便与当前旋转相对应：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `save` method saves the current settings of the `QPointer` object. The
    settings are later restored by the `restore` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`save` 方法用于保存 `QPointer` 对象的当前设置。这些设置稍后可以通过 `restore` 方法恢复：'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We find out the exact angle of the current hour hand by calculating the hours,
    minutes, seconds, and milliseconds. We then rotate to set the hour hand. Each
    hour corresponds to 30 degrees, since we have 12 hours, and 360 degrees divided
    by 12 is 30 degrees:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过计算小时、分钟、秒和毫秒来找出当前时针的确切角度。然后我们旋转以设置时针。每个小时对应 `30` 度，因为我们有 `12` 个小时，`360`
    度除以 `12` 等于 `30` 度：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We call the `drawConvexPloygon` method with the three points of the hour hand:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用时针的三个点调用 `drawConvexPloygon` 方法：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We draw the minute hand in the same way. It is a little bit thinner and longer
    than the hour hand. Another difference is that while we had 12 hours, we now have
    60 minutes. This gives that each minute corresponds to `6` degrees, since 360
    degrees divided by 60 is 6 degrees:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式绘制分针。它比时针细长一些。另一个区别是，我们之前有 12 个小时，而现在有 60 分钟。这导致每一分钟对应 `6` 度，因为 `360`
    度除以 `60` 等于 `6` 度：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When calculating the current minute angle, we use the minutes, seconds, and
    milliseconds:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算当前分钟角度时，我们使用分钟、秒和毫秒：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The drawing of the second hand is almost identical to the drawing of the previous
    minute hand. The only difference is that we only use seconds and milliseconds
    to calculate the second angle:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 秒针的绘制几乎与上一分钟针的绘制相同。唯一的区别是我们只使用秒和毫秒来计算秒的角度：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main function
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: In the `main` function, we initialize and start the Qt application. The `main`
    function can take the parameters `argc` and `argv`. It holds the command-line
    arguments of the applications; `argc` holds the number of arguments and the `argv`
    array holds the arguments themselves. The first entry of `argv` always holds the
    path to the execution file, and the last entry is always `nullptr`. The `QApplication`
    class takes `argc` and `argv` and initializes the Qt application. We create an
    object of our `Clock` class, and call `show` to make it visible. Finally, we call
    `exec` of the `QApplication` object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们初始化并启动 Qt 应用程序。`main` 函数可以接受 `argc` 和 `argv` 参数。它包含应用程序的命令行参数；`argc`
    包含参数的数量，而 `argv` 数组包含参数本身。`argv` 的第一个条目始终包含执行文件的路径，最后一个条目始终是 `nullptr`。`QApplication`
    类接受 `argc` 和 `argv` 并初始化 Qt 应用程序。我们创建了一个 `Clock` 类的对象，并调用 `show` 使其可见。最后，我们调用
    `QApplication` 对象的 `exec`。
- en: '**Main.cpp:**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To execute the application, we select the Run option on the project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行应用程序，我们选择项目的运行选项：
- en: '![](img/4e8a7f8f-c0bc-4cfb-b4b7-8aa2fa5e81f1.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e8a7f8f-c0bc-4cfb-b4b7-8aa2fa5e81f1.png)'
- en: 'The execution will continue until the user closes the `Clock` window by pressing
    the close button in the top-right corner:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行将继续，直到用户通过按下右上角的关闭按钮关闭 `Clock` 窗口：
- en: '![](img/f489094c-a214-400d-bdb7-32e03e57e385.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f489094c-a214-400d-bdb7-32e03e57e385.png)'
- en: Setting up reusable classes for windows and widgets
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置窗口和控件的可重用类
- en: In graphical applications, there are windows and widgets. A window is often
    a complete window with a frame holding title, menu bar, and buttons for closing
    and resizing the window. A widget is often a smaller graphical object, often embedded
    in a window. In the *Clock* project, we used only a `widget` class that inherits
    the `QWidget` class. However, in this section we will leave the *Clock* project
    and look into more advanced applications with both a window and a widget. The
    window holds the frame with the menu bar and toolbar, while the widget is located
    in the window and takes care of the graphical content.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形应用中，有窗口和控件。窗口通常是一个完整的窗口，包含一个带有标题、菜单栏和关闭及调整窗口大小的按钮的框架。控件通常是一个较小的图形对象，通常嵌入在窗口中。在
    *Clock* 项目中，我们只使用了继承自 `QWidget` 类的 `widget` 类。然而，在本节中，我们将离开 *Clock* 项目，探讨带有窗口和控件的更高级应用。窗口包含带有菜单栏和工具栏的框架，而控件位于窗口内，负责图形内容。
- en: In the following sections of this chapter, we will look into a drawing program
    and an editor. Those applications are typical document applications, where we
    open and save documents, as well as also cut, copy, paste, and delete elements
    of the document. In order to add menus and toolbars to the window, we need to
    inherit the two Qt classes, `QMainWindow` and `QWidget`. We need `QMainWindow`
    to add menus and toolbars to the window frame, and `QWidget` to draw images in
    the window's area.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将探讨绘图程序和编辑器。这些应用是典型的文档应用，其中我们打开和保存文档，以及剪切、复制、粘贴和删除文档元素。为了向窗口添加菜单和工具栏，我们需要继承两个
    Qt 类，`QMainWindow` 和 `QWidget`。我们需要 `QMainWindow` 来向窗口框架添加菜单和工具栏，以及 `QWidget`
    来在窗口区域绘制图像。
- en: In order to reuse the document code in the applications introduced in the remaining
    part of this chapter and in the next chapter, in this section, we define the classes
    `MainWindow` and `DocumentWidget`. Those classes will then be used by the drawing
    program and the editor later in the following sections of this chapter. `MainWindow`
    sets up a window with the `File` and `Edit` menus and toolbars, while `DocumentWidget`
    provides a framework that sets up skeleton code for the `New`, `Open`, `Save`,
    `SaveAs`, `Cut`, `Copy`, `Paste`, `Delete`, and `Exit` items. In this section,
    we will not create a new Qt project, we will just write the classes `MainWindow` and
    `DocumentWidget`, which are used as base classes in the drawing program and editor
    later in this chapter, and the `LISTENER` macro, which is used to set up menu
    and toolbar items.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本书剩余部分和下一章介绍的应用程序中重用文档代码，在本节中，我们定义了 `MainWindow` 和 `DocumentWidget` 类。这些类将在本章后续部分中的绘图程序和编辑器中使用。`MainWindow`
    设置了一个带有 `文件` 和 `编辑` 菜单和工具栏的窗口，而 `DocumentWidget` 提供了一个框架，为 `新建`、`打开`、`保存`、`另存为`、`剪切`、`复制`、`粘贴`、`删除`
    和 `退出` 项目设置了基本代码。在本节中，我们不会创建一个新的 Qt 项目，我们只会编写 `MainWindow` 和 `DocumentWidget`
    类，这些类将在本章后续部分的绘图程序和编辑器中作为基类使用，以及 `LISTENER` 宏，它用于设置菜单和工具栏项。
- en: Adding a listener
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加监听器
- en: A listener is a method that is called when the user selects a menu item or a
    toolbar item. The `Listener` macro adds a listener to the class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器是在用户选择菜单项或工具栏项时被调用的方法。`Listener` 宏将监听器添加到类中。
- en: '**Listener.h:**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Listener.h:**'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Due to Qt rules regarding menus and toolbars, the listener called by the Qt
    Framework in response to a user action must be a function rather than a method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Qt 关于菜单和工具栏的规则，Qt 框架在响应用户操作时调用的监听器必须是一个函数而不是一个方法。
- en: A method belongs to a class, while a function is free-standing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 方法属于一个类，而函数是独立的。
- en: 'The `DefineListener` macro defines both a friendly function and a method. The
    Qt Framework calls the function, which in turns calls the method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefineListener` 宏定义了一个友好的函数和一个方法。Qt 框架调用该函数，该函数随后调用该方法：'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Listener` macro is defined as a pointer to the method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listener` 宏定义为指向方法的指针：'
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The listener method takes an `QObject` pointer as a parameter and returns a
    Boolean value:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器方法接受一个 `QObject` 指针作为参数，并返回一个布尔值：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The base window class
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础窗口类
- en: The `MainWindow` class sets up a document window with the `File` and `Edit`
    menus and toolbars. It also provides the `addAction` method, which is intended
    for subclasses to add application-specific menus and toolbars.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow` 类使用 `File` 和 `Edit` 菜单和工具栏设置文档窗口。它还提供了 `addAction` 方法，该方法旨在供子类添加特定于应用程序的菜单和工具栏。'
- en: '**MainWindow.h:**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.h:**'
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `addAction` method adds a menu item, with a potential accelerator key,
    toolbar icon, and listeners to mark the item with a checkbox or a radio button:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAction` 方法添加一个带有潜在快捷键、工具栏图标和监听器的菜单项，用于标记该项为复选框或单选按钮：'
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We use the `DefineListener` macro to add a listener to decide whether a menu
    item shall be enabled. The listeners return `true` if the item shall be enabled.
    `DocumentWidget` is a sub class of the Qt class `QWidget`, which we will define
    in the next section. With the `DEFINE_LISTENER` macro, we add the `isSaveEnabled`,
    `isCutEnabled`, `isCopyEnabled`, `isPasteEnabled`, and `isDeleteEnabled` methods
    to the `MainWindow` class. They will be called when the user selects a menu item:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `DefineListener` 宏添加一个监听器来决定菜单项是否应该启用。如果项应该启用，监听器返回 `true`。`DocumentWidget`
    是 Qt 类 `QWidget` 的子类，我们将在下一节中定义它。使用 `DEFINE_LISTENER` 宏，我们将 `isSaveEnabled`、`isCutEnabled`、`isCopyEnabled`、`isPasteEnabled`
    和 `isDeleteEnabled` 方法添加到 `MainWindow` 类中。当用户选择菜单项时，它们将被调用：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `onMenuShow` method is called before a menu becomes visible; it calls the
    listener of the items of the menu to decide whether they shall be disabled or
    annotated by a checkbox or a radio button. It is also called by the framework
    in order to disable toolbar icons:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMenuShow` 方法在菜单变得可见之前被调用；它调用菜单项的监听器来决定它们是否应该被禁用或用复选框或单选按钮进行注释。它还由框架调用以禁用工具栏图标：'
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `m_enableMap` and `m_checkMap` fields hold maps of listeners for the menu
    items. The preceding `onMenuShow` method uses them to decide whether to disable
    the item, or annotate it with a checkbox or a radio button:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_enableMap` 和 `m_checkMap` 字段包含菜单项的监听器映射。前面的 `onMenuShow` 方法使用它们来决定是否禁用项，或用复选框或单选按钮对其进行注释：'
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**MainWindow.cpp:**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.cpp:**'
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The constructor calls the constructor of the Qt `QMainWindow` class, with the
    parent widget pointer as its parameter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用 Qt `QMainWindow` 类的构造函数，将父小部件指针作为其参数：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a menu item is added, it is connected to an action. The destructor deallocates
    all actions of the menu bar:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加菜单项时，它连接到一个动作。析构函数释放菜单栏的所有动作：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `addFileMenu` method adds the standard `File` menu to the menu bar; `menubar`
    is a Qt method that returns a pointer to the menu bar of the window:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`addFileMenu` 方法将标准 `File` 菜单添加到菜单栏；`menubar` 是 Qt 方法，它返回窗口菜单栏的指针：'
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similar to the `connect` method which connects the menu item with the `onMenuShow`
    method in the following code snippet. The Qt macros `SIGNAL` and `SLOT` ensure
    that `onMenuShow` is called before the menu becomes visible. The `onMenuShow`
    method sets the enable, checkbox, and radio bottom status for each item of the
    menu before the menu becomes visible. It also sets the enable status of toolbars
    images. The `aboutToShow` method is called before each menu becomes visible in
    order to enable or disable the items, and to possibly mark them with check boxes
    or radio buttons:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与下面的代码片段中的`connect`方法类似，该方法将菜单项与`onMenuShow`方法连接。Qt宏`SIGNAL`和`SLOT`确保在菜单变得可见之前调用`onMenuShow`。`onMenuShow`方法在菜单变得可见之前为菜单中的每个项设置启用、复选框和单选按钮状态。它还设置工具栏图像的启用状态。`aboutToShow`方法在每次菜单变得可见之前被调用，以启用或禁用项，并可能用复选框或单选按钮标记它们：
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Qt `addToolBar` method adds a toolbar to the window''s frame. When we call
    `addAction` here, the menu item will be added to the menu and, if present, to
    the toolbar:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的`addToolBar`方法将工具栏添加到窗口的框架中。当我们在这里调用`addAction`时，菜单项将被添加到菜单中，如果存在，也将添加到工具栏中：
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `addAction` method adds the `New`, `Open`, `Save`, `SaveAs`, and `Exit`
    menu items. It takes the following parameters:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAction`方法添加`New`、`Open`、`Save`、`SaveAs`和`Exit`菜单项。它接受以下参数：'
- en: A pointer to the menu the item shall belong to.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向该项应属于的菜单的指针。
- en: The item text. The ampersand (`&`) before the text (`&New`) indicates that the
    next letter (`N`) will be underlined, and that the user can select that item by
    pressing *Alt*-*N*.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项文本。文本前的符号“&”（例如“&New”）表示下一个字母（“N”）将被下划线标记，并且用户可以通过按下 *Alt*-*N* 来选择该项。
- en: Accelerator information. `QKeySequence` is a Qt enumeration holding accelerator
    key combinations. `QKeySequence::New` indicates that the user can select the item
    by pressing *Ctrl*-*N*. The text `Ctrl+N` will also be added to the item text.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速器信息。`QKeySequence`是Qt枚举，包含加速键组合。`QKeySequence::New`表示用户可以通过按下 *Ctrl*-*N* 来选择该项。文本`Ctrl+N`也将添加到项文本中。
- en: The name of an icon file (`new`). The icon of the file is displayed both to
    the left of the item text and on the toolbar. The icon file itself is added to
    the project in Qt Creator.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标文件的名称（`new`）。文件图标既显示在项文本的左侧，也显示在工具栏上。图标文件本身是在Qt Creator中添加到项目中的。
- en: A pointer to the toolbar, `nullptr` if the item is not connected to a toolbar.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向工具栏的指针，如果该项未连接到工具栏则为`nullptr`。
- en: The text displayed when the user hovers with the mouse over the toolbar item.
    Ignored if the item is not connected to a toolbar.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户将鼠标悬停在工具栏项上时显示的文本。如果该项未连接到工具栏，则忽略。
- en: 'Listeners (default `nullptr`) that are called before the menu and toolbar become
    visible, and deciding whether the item is enabled or marked with a checkbox or
    a radio button:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单和工具栏变得可见之前被调用的监听器（默认`nullptr`），并决定该项是否启用或用复选框或单选按钮标记：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When there are no changes in the document since it was last saved, the document
    does not need to be saved and the `Save` item shall be disabled. Therefore, we
    add an extra parameter, indicating that the `isSaveEnabled` method shall be called
    to enable or disable the menu and toolbar item:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自上次保存以来文档没有变化，则不需要保存文档，并且应禁用“保存”项。因此，我们添加了一个额外的参数，表示应调用`isSaveEnabled`方法来启用或禁用菜单和工具栏项：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `SaveAs` menu item has no key sequence. Moreover, it does not have a toolbar
    entry. Therefore, the name of the icon file and the toolbar text are default `QString`
    objects and the toolbar pointer is `nullptr`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveAs`菜单项没有快捷键序列。此外，它没有工具栏条目。因此，图标文件名和工具栏文本是默认的`QString`对象，工具栏指针是`nullptr`：'
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `addSeparator` method adds a horizontal line between two items:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSeparator`方法在两个项之间添加一条水平线：'
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `addEditMenu` method adds the `Edit` menu to the window''s menu bar in
    the same way as the preceding `File` menu:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEditMenu`方法以与前面的`File`菜单相同的方式将`Edit`菜单添加到窗口的菜单栏中：'
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `addAction` method adds a menu item to the menu bar and a toolbar icon
    to the toolbar. It also connects the item with the `onSelectPtr` method that is
    called when the user selects the item, and methods that enable the item and annotate
    it with a checkbox or radio button. An accelerator is added to the action, unless
    it is zero. The `groupPtr` parameter defines whether the item is part of a group.
    If `checkListener` is not `nullptr`, the item is annotated with a checkbox if
    `groupPtr` is `nullptr`, and with a radio button if it is not. In the case of
    radio buttons, only one radio button in the group will be marked at the same time:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAction`方法将菜单项添加到菜单栏，并将工具栏图标添加到工具栏。它还将项目与当用户选择项目时被调用的`onSelectPtr`方法连接起来，以及启用项目并使用复选框或单选按钮进行标注的方法。除非为零，否则将添加一个加速器到动作中。`groupPtr`参数定义了项目是否是组的一部分。如果`checkListener`不为`nullptr`，则如果`groupPtr`为`nullptr`，项目将用复选框标注，如果不是，则用单选按钮标注。在单选按钮的情况下，组中只有一个单选按钮会被同时标记：'
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If `iconName` is not empty, we load the icon from the file in the project resource
    and then create a new `QAction` object with the icon:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`iconName`不为空，我们从项目资源中的文件加载图标，然后创建一个新的带有图标的`QAction`对象：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If `iconName` is empty, we create a new `QAction` object without the icon:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`iconName`为空，我们创建一个新的不带图标的`QAction`对象：
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We connect the menu item to the selection method. When the user selects the
    item, or clicks on the toolbar icon, `onSelectPtr` is called:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将菜单项连接到选择方法。当用户选择项目或点击工具栏图标时，会调用`onSelectPtr`：
- en: '[PRE46]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the accelerator key is not zero, we add it to the action pointer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速键不是零，我们将它添加到动作指针中：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we add the action pointer to the menu pointer in order for it to process
    the user''s item selection:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将动作指针添加到菜单指针中，以便它能够处理用户的项选择：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If `toolBarPtr` is not `nullptr`, we add the action to the toolbar of the window:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`toolBarPtr`不是`nullptr`，我们将动作添加到窗口的工具栏中：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the status tip is not empty, we add it to the tooltip and status tip of
    the toolbar:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态提示不为空，我们将它添加到工具栏的提示和状态提示中：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the enable listener is not null, we add to `m_enableMap` a pair made up
    of a pointer to the central widget of the window and the listener. We also call
    the listener to initialize the enable status of the menu item and toolbar icon:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用监听器不为空，我们将一个由窗口中心部件的指针和监听器组成的对添加到`m_enableMap`中。同时，我们调用监听器以初始化菜单项和工具栏图标的启用状态：
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the same way, if the check listener is not null, we add a pointer to the
    central widget of the window and the listener to `m_checkMap`. Both `m_enableMap`
    and `m_checkMap` are used by `onMenuShow`, as follows. We also call the listener
    to initialize the check status of the menu item (toolbar icons are not checked):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果检查监听器不为空，我们将窗口中心小部件的指针和监听器添加到`m_checkMap`中。`m_enableMap`和`m_checkMap`都由`onMenuShow`使用，如下所示。我们还调用监听器以初始化菜单项的检查状态（工具栏图标不会被勾选）：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, if the group pointer is not null, we add the action to it. In that
    way, the menu item will be annotated by a radio button rather than a checkbox.
    The framework does also keep track of the groups and makes sure only one of the
    radio buttons of each group is marked at the same time:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果组指针不为空，我们将动作添加到其中。这样，菜单项将通过单选按钮而不是复选框进行标注。框架也会跟踪组，并确保每个组中只有一个单选按钮被同时标记：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `onMenuShow` method is called before a menu or toolbar icon becomes visible.
    It makes sure each item is enabled or disabled, and that the items are annotated
    with checkboxes or radio buttons.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMenuShow`方法在菜单或工具栏图标变得可见之前被调用。它确保每个项目都被启用或禁用，并且项目被标注为复选框或单选按钮。'
- en: 'We start by iterating through the enable map. For each entry in the map, we
    look up the widget and the enable function. We call the function, which returns
    `true` or `false`, and use the result to enable or disable the item by calling
    `setEnabled` on the action object pointer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历启用映射。对于映射中的每个条目，我们查找小部件和启用函数。我们调用该函数，它返回`true`或`false`，然后通过在动作对象指针上调用`setEnabled`来使用结果启用或禁用项目：
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the same way, we iterate through the check map. For each entry in the map,
    we look up the widget and the check function. We call the function and use the
    result to check the item by calling `setCheckable` and `setChecked` on the action
    object pointer. The Qt Framework makes sure the item is annotated by radio buttons
    if it belongs to a group, and a checkbox if it does not:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们遍历检查映射。对于映射中的每个条目，我们查找小部件和检查函数。我们调用该函数，并使用结果通过在动作对象指针上调用 `setCheckable`
    和 `setChecked` 来检查项目。Qt 框架确保如果项目属于一个组，则通过单选按钮进行注释，如果不属于，则通过复选框进行注释：
- en: '[PRE55]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The base widget class
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础小部件类
- en: '`DocumentWidget` is a skeleton framework for applications that handle documents.
    It handles the loading and saving of the document, and provides methods to be
    overridden by subclasses for the `Cut`, `Copy`, `Paste`, and `Delete` menu items.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocumentWidget` 是处理文档的应用程序的骨架框架。它处理文档的加载和保存，并为子类提供覆盖 `Cut`、`Copy`、`Paste`
    和 `Delete` 菜单项的方法。'
- en: While the preceding `MainWindow` class handles the window frame, with its menus
    and toolbars, the `DocumentWidget` class handles the drawing of the window's content.
    The idea is that the subclass of `MainWindow` creates an object of a subclass
    to `DocumentWidget` that it puts at the centrum of the window. See the constructors
    of `DrawingWindow` and `EditorWindow` in the following sections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 `MainWindow` 类处理窗口框架，包括其菜单和工具栏，而 `DocumentWidget` 类则负责绘制窗口内容。其理念是 `MainWindow`
    的子类创建一个 `DocumentWidget` 子类的对象，并将其放置在窗口的中心。请参阅下一节中 `DrawingWindow` 和 `EditorWindow`
    的构造函数。
- en: '**DocumentWidget.h:**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**DocumentWidget.h:**'
- en: '[PRE56]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The constructor takes the name of the application, to be displayed at the top
    banner of the window, the filename mask to be used when loading and storing documents
    with the standard file dialogs, and a pointer to a potential parent widget (normally
    the enclosing main window):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受要显示在窗口顶部横幅中的应用程序名称，用于加载和存储文档的标准文件对话框的文件名掩码，以及指向潜在父小部件的指针（通常是包含的主窗口）：
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `setFilePath` method sets the path of the current document. The path is
    displayed at the top banner of the window and is given as a default path in the
    standard load and save dialogs:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFilePath` 方法设置当前文档的路径。路径在窗口的顶部横幅中显示，并在标准加载和保存对话框中作为默认路径给出：'
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When a document has been changed, the modified flag (sometimes called the dirty
    flag) is set. This causes an asterisk (`*`) to appear next to the file path at
    the top banner of the window, and the `Save` and `SaveAs` menu items to be enabled:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档被修改时，会设置修改标志（有时称为脏标志）。这会导致在窗口顶部横幅的文件路径旁边出现一个星号（`*`），并启用 `Save` 和 `SaveAs`
    菜单项：
- en: '[PRE59]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `setMainWindowTitle` method is an auxiliary method that puts together the
    title of the window. It is made up by the file path and a potential asterisk (`*`)
    to indicate whether the modified flag is set:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMainWindowTitle` 方法是一个辅助方法，用于组合窗口的标题。它由文件路径和一个潜在的星号（`*`）组成，以指示是否设置了修改标志：'
- en: '[PRE60]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `closeEvent` method is overridden from `QWidget` and is called when the
    user closes the window. By setting fields of the `eventPtr` parameter, the closing
    can be prevented. For example, if the document has not been saved, the user can
    be asked if they want to save the document or cancel the closing of the window:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`closeEvent` 方法是从 `QWidget` 重写的，当用户关闭窗口时被调用。通过设置 `eventPtr` 参数的字段，可以阻止关闭。例如，如果文档尚未保存，可以询问用户是否要保存文档或取消窗口的关闭：'
- en: '[PRE61]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `isClearOk` method is an auxiliary method that displays a message box if
    the user tries to close the window or exit the application without saving the
    document:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClearOk` 方法是一个辅助方法，如果用户尝试在不保存文档的情况下关闭窗口或退出应用程序，则会显示消息框：'
- en: '[PRE62]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following methods are called by the framework when the user selects a menu
    item or clicks a toolbar icon. In order for that to work, we mark the methods
    as slots, which is necessary for the `SLOT` macro in the `connect` call:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择菜单项或点击工具栏图标时，框架会调用以下方法。为了使其工作，我们将这些方法标记为槽，这是在 `connect` 调用中的 `SLOT` 宏所必需的：
- en: '[PRE63]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When a document has not been changed, it is not necessary to save it. In that
    case, the `Save` and `SaveAs` menu items and toolbars images shall be disabled.
    The `isSaveEnabled` method is called by `onMenuShow` before the `File` menu becomes
    visible. It returns true only when the document has been changed and needs to
    be saved:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档没有更改时，没有必要保存它。在这种情况下，`Save` 和 `SaveAs` 菜单项和工具栏图像应禁用。`isSaveEnabled` 方法在 `File`
    菜单可见之前由 `onMenuShow` 调用。它仅在文档已更改且需要保存时返回 true：
- en: '[PRE64]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `tryWriteFile` method is an auxiliary method that tries to write the file.
    If it fails, a message box displays an error message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`tryWriteFile` 方法是一个辅助方法，它尝试写入文件。如果失败，将显示一个消息框显示错误信息：'
- en: '[PRE65]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following methods are virtual methods intended to be overridden by subclasses.
    They are called when the user selects the `New`, `Save`, `SaveAs`, and `Open`
    menu items:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法是虚拟方法，旨在由子类重写。当用户选择 `New`、`Save`、`SaveAs` 和 `Open` 菜单项时，会调用这些方法：
- en: '[PRE66]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following methods are called before the edit menu becomes visible, and
    they decide whether the `Cut`, `Copy`, `Paste`, and `Delete` items shall be enabled:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑菜单可见之前，会调用以下方法，并决定是否启用 `Cut`、`Copy`、`Paste` 和 `Delete` 项目：
- en: '[PRE67]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following methods are called when the user selects the `Cut`, `Copy`, `Paste`,
    and `Delete` items or toolbar icons:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Cut`、`Copy`、`Paste` 和 `Delete` 项目或工具栏图标时，会调用以下方法：
- en: '[PRE68]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `m_applicationName` field holds the name of the application, not the document.
    In the next sections, the names will be *Drawing* and *Editor*. The `m_fileMask`
    field holds the mask that is used when loading and saving the document with the
    standard dialogs. For instance, let us say that we have documents with the ending
    `.abc`. Then the mask could be `Abc files (.abc)`. The `m_filePath` field holds
    the path of the current document. When the document is new and not yet saved,
    the field holds the empty string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_applicationName` 字段包含应用程序的名称，而不是文档的名称。在下一节中，名称将是 *Drawing* 和 *Editor*。`m_fileMask`
    字段包含在标准对话框中加载和保存文档时使用的掩码。例如，假设我们有以 `.abc` 结尾的文档。那么掩码可以是 `Abc files (.abc)`。`m_filePath`
    字段包含当前文档的路径。当文档是新的且尚未保存时，该字段包含空字符串。'
- en: 'Finally, `m_modifiedFlag` is true when the document has been modified and needs
    to be saved before the application quits:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当文档已被修改且在应用程序退出之前需要保存时，`m_modifiedFlag` 为真：
- en: '[PRE69]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, there are some overloaded auxiliary operators. The addition and subtraction
    operators add and subtract a point with a size, and a rectangle with a size:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些重载的辅助运算符。加法和减法运算符将一个点与一个大小相加或相减，以及一个具有大小的矩形：
- en: '[PRE70]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `writePoint` and `readPoint` methods write and read a point from an input
    stream:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`writePoint` 和 `readPoint` 方法从输入流中写入和读取一个点：'
- en: '[PRE71]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `writeColor` and `readColor` methods write and read a color from an input
    stream:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeColor` 和 `readColor` 方法从输入流中写入和读取一个颜色：'
- en: '[PRE72]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `makeRect` method creates a rectangle with `point` as its center and `size`
    as its size:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRect` 方法创建一个以 `point` 为中心，`size` 为大小的矩形：'
- en: '[PRE73]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**DocumentWidget.cpp:**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**DocumentWidget.cpp:**'
- en: '[PRE74]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The constructor sets the name of the application, the file mask for the save
    and load standard dialogs, and a pointer to the enclosing parent widget (usually
    the enclosing main window):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数设置应用程序的名称、保存和加载标准对话框的文件掩码，以及指向封装父小部件的指针（通常是封装的主窗口）：
- en: '[PRE75]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The destructor does nothing, it is included for completeness only:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数不执行任何操作，仅为了完整性而包含：
- en: '[PRE76]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `setFilePath` method calls `setMainWindowTitle` to update the text on the
    top banner of the window:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFilePath` 方法调用 `setMainWindowTitle` 来更新窗口顶部横幅上的文本：'
- en: '[PRE77]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `setModifiedFlag` method also calls `setMainWindowTitle` to update the
    text on the top banner of the window. Moreover, it calls `onMenuShow` on the parent
    widget to update the icons of the toolbars:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`setModifiedFlag` 方法还会调用 `setMainWindowTitle` 来更新窗口顶部横幅上的文本。此外，它还会在父小部件上调用
    `onMenuShow` 以更新工具栏的图标：'
- en: '[PRE78]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The title displayed at the top banner of the toolbar is the application name,
    the document file path (if not empty), and an asterisk if the document has been
    modified without being saved:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏顶部横幅上显示的标题是应用程序名称、文档文件路径（如果非空），以及如果文档未经保存而修改，则显示一个星号：
- en: '[PRE79]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `isClearOk` method displays a message box if the document has been modified
    without being saved. The user can select one of the following buttons:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClearOk` 方法会在文档未经保存而修改时显示一个消息框。用户可以选择以下按钮之一：'
- en: 'Yes: The document is saved, and the application quits. However, if the saving
    fails, an error message is displayed and the application does not quit.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是：保存文档并退出应用程序。但是，如果保存失败，将显示错误消息，并且应用程序不会退出。
- en: 'No: The application quits without saving the document.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否：应用程序退出而不保存文档。
- en: 'Cancel: The closing of the application is cancelled. The document is not saved.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消：取消应用程序的关闭。文档不会被保存。
- en: '[PRE80]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the document is cleared, `newDocument` is called, which is intended to be
    overridden by a subclass to perform application-specific initialization. Moreover,
    the modified flag and the file path are cleared. Finally, the Qt `update` method
    is called to force a repainting of the window''s content:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档被清除，则会调用`newDocument`，该函数旨在被子类覆盖以执行特定于应用程序的初始化。此外，修改标志和文件路径也会被清除。最后，调用 Qt
    的 `update` 方法来强制重绘窗口内容：
- en: '[PRE81]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If the document is cleared, `onOpen` uses the standard open dialog to obtain
    the file path of the document:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档被清除，`onOpen` 会使用标准打开对话框来获取文档的文件路径：
- en: '[PRE82]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If the file was successfully read, the modified flag is cleared, the file path
    is set, and `update` is called to force a repainting of the window:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件成功读取，则清除修改标志，设置文件路径，并调用 `update` 来强制重绘窗口内容：
- en: '[PRE83]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, if the reading was not successful, a message box with an error message
    is displayed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果读取不成功，将显示一个包含错误信息的消息框：
- en: '[PRE84]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `ifSaveEnabled` method simply returns the value of `m_modifiedFlag`. However,
    we need the method for the listener to work:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifSaveEnabled` 方法简单地返回 `m_modifiedFlag` 的值。但是，我们需要这个方法以便监听器可以工作：'
- en: '[PRE85]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `onSave` method is called when the user selects the `Save` or `SaveAs`
    menu item or toolbar icon. If the document has already been given a name, we simply
    try to write the file. However, if it has not yet been given a name we call `OnSaveAs`,
    which displays the standard Save dialog for the user:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Save` 或 `SaveAs` 菜单项或工具栏图标时，会调用 `onSave` 方法。如果文档已经有一个名称，我们只需尝试写入文件。但是，如果没有给出名称，我们则调用
    `OnSaveAs`，这会为用户显示标准的保存对话框：
- en: '[PRE86]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `onSaveAs` method is called when the user selects the `SaveAs` menu item
    (there is no toolbar icon for this item). It opens the standard open dialog and
    tries to write the file. If the writing was not successful, `false` is returned.
    The reason for this is that `isClearOk` closes the window only if the writing
    was successful:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `SaveAs` 菜单项（此项目没有工具栏图标）时，会调用 `onSaveAs` 方法。它打开标准打开对话框并尝试写入文件。如果写入不成功，则返回
    `false`。这是因为 `isClearOk` 只在写入成功时关闭窗口：
- en: '[PRE87]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `tryWriteFile` method tries to write the file by calling write, which is
    intended to be overridden by a subclass. If it succeeded, the modified flag and
    the file path are set. If the file was not successfully written, a message box
    with an error message is displayed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`tryWriteFile` 方法尝试通过调用 `write` 来写入文件，该函数旨在被子类覆盖。如果成功，则设置修改标志和文件路径。如果文件未能成功写入，将显示一个包含错误信息的消息框：'
- en: '[PRE88]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `onExit` method is called when the user selects the `Exit` menu item. It
    checks whether it is clear to close the window, and exits the application if it
    is:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Exit` 菜单项时，会调用 `onExit` 方法。它会检查是否可以关闭窗口，如果可以，则退出应用程序：
- en: '[PRE89]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The default behavior of `isCutEnabled` and `isDeleteEnabled` is to call `isCopyEnabled`,
    since they often are enabled on the same conditions:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCutEnabled` 和 `isDeleteEnabled` 的默认行为是调用 `isCopyEnabled`，因为它们通常在相同的条件下被启用：'
- en: '[PRE90]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The default behavior of `onCut` is to simply call `onCopy` and `onDelete`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCut` 的默认行为是简单地调用 `onCopy` 和 `onDelete`：'
- en: '[PRE91]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The default behavior of the rest of the cut-and-copy methods is to return `false`
    and do nothing, which will leave the menu items disabled unless the subclass overrides
    the methods:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其他剪切和复制方法的默认行为是返回 `false` 并不执行任何操作，这将使菜单项处于禁用状态，除非子类覆盖这些方法：
- en: '[PRE92]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, `closeEvent` is called when the user tries to close the window. If
    the window is ready to be cleared, `accept` is called on `eventPtr`, which causes
    the window to be closed, and `exit` is called on the global `qApp` object, which
    causes the application to quit:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户尝试关闭窗口时，会调用 `closeEvent`。如果窗口准备就绪可以清除，则会在 `eventPtr` 上调用 `accept`，这将导致窗口关闭，并在全局
    `qApp` 对象上调用 `exit`，导致应用程序退出：
- en: '[PRE93]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'However, if the window is not ready to be cleared, `ignore` is called on `eventPtr`,
    which causes the window to remain open (and the application to continue):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果窗口尚未准备好清除，则会在 `eventPtr` 上调用 `ignore`，这将导致窗口保持打开状态（并且应用程序继续运行）：
- en: '[PRE94]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Moreover, there are also the set of auxiliary functions for handling points,
    sizes, rectangles, and color. The following operators add and subtract a point
    with a size, and return the resulting point:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一组处理点、大小、矩形和颜色的辅助函数。以下运算符将一个点与一个大小相加或相减，并返回结果点：
- en: '[PRE95]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following operators add and subtract an integer from a rectangle, and return
    the resulting rectangle. The addition operator expands the size of the rectangle
    in every direction, while the subtraction operator shrinks the rectangle in every
    direction:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符将一个整数加到或从矩形中减去，并返回结果矩形。加法运算符在所有方向上扩展矩形的大小，而减法运算符在所有方向上缩小矩形的大小：
- en: '[PRE96]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `writePoint` and `readPoint` functions write and read a point from a file.
    They write and read the *x* and *y* coordinates separately:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`writePoint` 和 `readPoint` 函数用于从文件写入和读取一个点。它们分别写入和读取 *x* 和 *y* 坐标：'
- en: '[PRE97]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `writeColor` and `readColor` functions write and read a color from a file.
    A color is made up of the `red`, `green`, and `blue` components. Each component
    is an integer value between `0` and `255` inclusive. The methods write and read
    the components from a file stream:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeColor` 和 `readColor` 函数用于从文件写入和读取一个颜色。一个颜色由 `red`（红色）、`green`（绿色）和 `blue`（蓝色）三个分量组成。每个分量是一个介于
    `0` 和 `255`（包含）之间的整数。这些方法从文件流中写入和读取分量：'
- en: '[PRE98]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When the components have been read, we create a `QColor` object that we assign
    the `color` parameter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被读取后，我们创建一个 `QColor` 对象，并将其分配给 `color` 参数：
- en: '[PRE99]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `makeRect` function creates a rectangle centered around the point:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRect` 函数创建一个以点为中心的矩形：'
- en: '[PRE100]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Building the drawing program
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建绘图程序
- en: Let's now start a new project, where we take advantage of the main window and
    document widget classes of the previous section—*The drawing program*. We will
    start with a basic version in this chapter, and we will continue to build a more
    advanced version in the next chapter. With the drawing program of this chapter
    we can draw lines, rectangles, and ellipses in different colors. We can also save
    and load our drawings. Note that in this project the window and widget classes
    inherit from the `MainWindow` and `DocumentWidget` classes of the previous section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始一个新的项目，利用上一节中提到的主窗口和文档小部件类——*绘图程序*。我们将在本章中从基本版本开始，并在下一章中继续构建更高级的版本。使用本章的绘图程序，我们可以用不同的颜色绘制线条、矩形和椭圆。我们还可以保存和加载我们的绘图。请注意，在这个项目中，窗口和小部件类继承自上一节中的
    `MainWindow` 和 `DocumentWidget` 类。
- en: The Figure base class
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形基类
- en: The figures of the application constitute a class hierarchy where the `Figure`
    is the base class. Its subclasses are `Line`, `RectangleX`, and `EllipseX`, which
    are described later on. We cannot use the names *Rectangle* and *Ellipse* for
    our classes, since that would clash with Qt methods with the same names. I have
    chosen to simply add an '`X`' to the names.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的图形构成一个类层次结构，其中 `Figure` 是基类。其子类是 `Line`、`RectangleX` 和 `EllipseX`，这些将在后面进行描述。我们不能使用
    *Rectangle* 和 *Ellipse* 作为我们类的名称，因为这会与具有相同名称的 Qt 方法冲突。我选择简单地在名称中添加一个 '`X`'。
- en: The `Figure` class is abstract, which means that we cannot create an object
    of the class. We can only use it as a base class, which sub classes inherit.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Figure` 类是抽象的，这意味着我们不能创建该类的对象。我们只能将其用作基类，子类从中继承。'
- en: '**Figure.h:**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure.h:** '
- en: '[PRE101]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The following methods are pure virtual, which means that they do not need to
    be defined. A class with at least one pure virtual method becomes abstract. The
    sub classes must define all the pure virtual methods of all its base classes,
    or become abstract themselves. In this way, it is guaranteed that all methods
    of all non-abstract classes are defined.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法都是纯虚的，这意味着它们不需要被定义。包含至少一个纯虚方法的一个类变成抽象类。子类必须定义其所有基类的所有纯虚方法，或者它们自己也成为抽象类。这样，可以保证所有非抽象类的所有方法都被定义。
- en: 'Each sub class defines `getId` and returns the identity enumeration of its
    class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子类定义 `getId` 并返回其类的身份枚举：
- en: '[PRE102]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Each figure has a first and last point, and it is up to each sub class to define
    them:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形都有一个起始点和结束点，具体由每个子类来定义：
- en: '[PRE103]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `isClick` method returns `true` if the figure is hit by the point:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClick` 方法如果图形被点击则返回 `true`：'
- en: '[PRE104]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `move` method moves the figures a certain distance:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法将图形移动一定距离：'
- en: '[PRE105]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `draw` method draws the figure on the painter area:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法在绘图区域上绘制图形：'
- en: '[PRE106]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `write` and `read` methods write and read the figure from a file; `write`
    is constant since it does not change the figure:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 方法将图形从文件中写入和读取；`write` 是常量，因为它不会改变图形：'
- en: '[PRE107]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `color` method returns the color of the figure. It comes in two versions,
    where the first version is constant and returns a reference to a constant `QColor`
    object, while the second version is non-constant and returns a reference to a
    non-constant object:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`color` 方法返回图形的颜色。它有两种版本，其中第一种是常量版本，返回一个常量 `QColor` 对象的引用，而第二种是非常量版本，返回一个非常量对象的引用：'
- en: '[PRE108]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `filled` methods apply to two-dimensional figures (rectangles and ellipses)
    only. They return `true` if the figure is filled. Note that the second version
    returns a reference to the `m_filled` field, which allows the caller of the method
    to modify the value of `m_filled`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`filled` 方法仅适用于二维图形（矩形和椭圆）。如果图形被填充，则返回 `true`。请注意，第二个版本返回 `m_filled` 字段的引用，允许方法调用者修改
    `m_filled` 的值：'
- en: '[PRE109]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When a figure is marked, it is drawn with small squares at its corners. The
    side of the squares are defined by the static field `Tolerance`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当图形被标记时，它会在其角落绘制小正方形。正方形的边长由静态字段 `Tolerance` 定义：
- en: '[PRE110]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `writeColor` and `readColor` methods are auxiliary methods that read and
    write a color. They are static since they are called by methods outside the `Figure`
    class hierarchy:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeColor` 和 `readColor` 方法是辅助方法，用于读取和写入颜色。由于它们由 `Figure` 类层次结构之外的方法调用，因此它们是静态的：'
- en: '[PRE111]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Each figure has a color, and it could be marked or filled:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形都有一个颜色，它可以被标记或填充：
- en: '[PRE112]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `Figure.cpp` file holds the definitions of the `Figure` class. It defines
    the `Tolerance` field as well as the `write` and `read` methods.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Figure.cpp` 文件包含了 `Figure` 类的定义。它定义了 `Tolerance` 字段以及 `write` 和 `read` 方法。'
- en: '**Figure.cpp:**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure.cpp:**'
- en: '[PRE113]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '`Tolerance` must be defined and initialized in global space since it is static.
    We define the size of the mark squares to be `6` pixels:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Tolerance` 是静态的，必须在全局空间中定义和初始化。我们定义标记正方形的尺寸为 `6` 像素：
- en: '[PRE114]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The default constructor is called only when figures are read from a file:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当从文件读取图形时才调用默认构造函数：
- en: '[PRE115]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `write` and `read` methods write and read the color of the figure, and
    whether the figure is filled:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 方法写入和读取图形的颜色以及图形是否被填充：'
- en: '[PRE116]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The Line sub class
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Line` 子类'
- en: 'The `Line` class is a sub class of `Figure`. It becomes non-abstract by defining
    each pure virtual method of `Figure`. A line is drawn between two end-points,
    represented by the `m_firstPoint` to `m_lastPoint` fields in `Line`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Line` 类是 `Figure` 的子类。通过定义 `Figure` 的每个纯虚方法，它变得非抽象。一条线通过 `Line` 中的 `m_firstPoint`
    到 `m_lastPoint` 字段在两个端点之间绘制：'
- en: '![](img/4723c801-7788-48b8-8399-9bc2e7f4d2b2.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4723c801-7788-48b8-8399-9bc2e7f4d2b2.png)'
- en: '**Line.h:**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**Line.h:**'
- en: '[PRE117]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The default constructor is called only when reading `Line` objects from a file;
    `getId` simply returns the identity enumeration of the line:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数仅在从文件读取 `Line` 对象时调用；`getId` 简单地返回线的身份枚举：
- en: '[PRE118]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'A line has two endpoints. Both points are set when the line is created, the
    second point is then modified when the user moves it:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线有两个端点。当创建线时，这两个点都被设置，当用户移动它时，第二个点被修改：
- en: '[PRE119]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `isClick` method returns `true` if the mouse click is located on the line
    (with some tolerance):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClick` 方法如果鼠标点击位于线上（带有一些容差），则返回 `true`：'
- en: '[PRE120]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `move` method moves the line (both its end-points) the given distance:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法将线（及其两个端点）移动给定的距离：'
- en: '[PRE121]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `draw` method draws the line on the `QPainter` object:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法在 `QPainter` 对象上绘制线：'
- en: '[PRE122]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `write` and `read` methods write and read the end-points of the line from
    a file stream:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 方法将线的端点从文件流中写入和读取：'
- en: '[PRE123]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The first and last points of the line are stored in the `Line` object:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 线的第一个和最后一个点存储在 `Line` 对象中：
- en: '[PRE124]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The `Line.cpp` file defines the methods of the `Line` class.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Line.cpp` 文件定义了 `Line` 类的方法。'
- en: '**Line.cpp:**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**Line.cpp:**'
- en: '[PRE125]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `initializePoints` method is called when the user adds a new line to the
    drawing. It sets both its end-points:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向绘图添加新线时，会调用 `initializePoints` 方法。它设置其两个端点：
- en: '[PRE126]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `setLastPoint` method is called when the user has added the line and modifies
    its shape. It sets the last point:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户添加线并修改其形状时，会调用 `setLastPoint` 方法。它设置最后一个点：
- en: '[PRE127]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The `isClick` method tests whether the user has clicked with the mouse on the
    line. We have two cases to consider. The first case is a special case that occurs
    when the line is completely vertical, when the *x*-coordinates of the end-points
    are equal. We use the Qt `QRect` class to create a rectangle surrounding the line,
    and test whether the point is enclosed in the rectangle:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClick`方法测试用户是否在线条上用鼠标点击。我们需要考虑两种情况。第一种情况是当线条完全垂直时发生的特殊情况，此时端点的`x`坐标相等。我们使用Qt的`QRect`类创建一个围绕线条的矩形，并测试该点是否在矩形内：'
- en: '![](img/d9377e8e-8a2a-4fdf-8c0f-3e6f23276884.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9377e8e-8a2a-4fdf-8c0f-3e6f23276884.png)'
- en: '[PRE128]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In a general case, where the line is not vertical, we start by creating an enclosing
    rectangle and test if the mouse point is in it. If it is, we set `leftPoint` to
    the leftmost point of `firstPoint` and `lastPoint`, and `rightPoint` to the rightmost
    point. We then calculate the width (`lineWidth`) and height (`lineHeight`) of
    the enclosing rectangle, as well as the distance between `rightPoint` and `mousePoint`
    in the *x* and *y* directions (`diffWidth` and `diffHeight`).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况中，即线条不是垂直的情况下，我们首先创建一个包含的矩形并测试鼠标指针是否在其中。如果是，我们将`leftPoint`设置为`firstPoint`和`lastPoint`的最左端点，将`rightPoint`设置为最右端点。然后我们计算包含矩形的宽度（`lineWidth`）和高度（`lineHeight`），以及`rightPoint`和`mousePoint`在`x`和`y`方向上的距离（`diffWidth`和`diffHeight`）。
- en: '![](img/f051abb6-3200-45a4-bd8e-1ce97c0443a2.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f051abb6-3200-45a4-bd8e-1ce97c0443a2.png)'
- en: 'Due to uniformity, the following equation is true if the mouse pointer hits
    the line:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一致性，如果鼠标指针击中线条，以下等式是正确的：
- en: '![](img/94c97888-f928-420d-9f23-9f7308d283d9.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94c97888-f928-420d-9f23-9f7308d283d9.png)'
- en: 'However, in order for the left-hand expression to become exactly zero, the
    user has to click exactly on the line. Therefore, let us allow for a small tolerance.
    Let''s use the `Tolerance` field:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使左手表达式正好为零，用户必须精确地点击在线条上。因此，我们可以允许有一定的容差。让我们使用`Tolerance`字段：
- en: '![](img/fb006091-e45c-4af5-9ac4-13234e8b1bfe.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb006091-e45c-4af5-9ac4-13234e8b1bfe.png)'
- en: '[PRE129]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We must convert `lineHeight` to a double in order to perform non-integer division:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`lineHeight`转换为双精度浮点数，以便执行非整数除法：
- en: '[PRE130]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If the mouse point is located outside the rectangle enclosing the line, we
    simply return `false`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标指针位于包含线条的矩形外部，我们直接返回`false`：
- en: '[PRE131]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The `move` method simply moves both the endpoints of the line:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`方法简单地移动线条的两个端点：'
- en: '[PRE132]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'When drawing the line, we set the pen color and draw the line. The `color`
    method of the `Figure` class returns the color of the line:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制线条时，我们设置画笔颜色并绘制线条。`Figure`类的`color`方法返回线条的颜色：
- en: '[PRE133]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'When writing the line, we first call `write` in `Figure` to write the color
    of the figure. We then write the endpoints of the line. Finally, we return the
    Boolean value of the output stream, which is `true` if the writing was successful:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制线条时，我们首先在`Figure`中调用`write`来绘制图形的颜色。然后我们写入线条的端点。最后，我们返回输出流的布尔值，如果写入成功则为`true`：
- en: '[PRE134]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In the same way, when reading the line, we first call `read` in `Figure` to
    read the color of the line. We then read the endpoints of the line and return
    the Boolean value of the input stream:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，当读取线条时，我们首先在`Figure`中调用`read`来读取线条的颜色。然后我们读取线条的端点并返回输入流的布尔值：
- en: '[PRE135]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The Rectangle sub class
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Rectangle`子类'
- en: '`RectangleX` is a sub class of `Figure` that handles a rectangle. Similar to
    `Line`, it holds two points, which holds opposite corners of the rectangle:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`RectangleX`是`Figure`的子类，用于处理矩形。与`Line`类似，它持有两个点，这两个点持有矩形的对角线：'
- en: '**Rectangle.h**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rectangle.h**'
- en: '[PRE136]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Similar to the preceding `Line` class, `RectangleX` has a default constructor
    that is used when reading the object from a file:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的`Line`类类似，`RectangleX`有一个默认构造函数，用于从文件中读取对象时使用：
- en: '[PRE137]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '**Rectangle.cpp**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rectangle.cpp**'
- en: '[PRE138]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `initializePoints` and `setLastPoint` methods work in a way similar to
    their counterparts in `Line`: `initializePoints` sets both the corner points,
    while `setLastPoint` sets the last corner point:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializePoints`和`setLastPoint`方法的工作方式与`Line`中的对应方法类似：`initializePoints`设置两个角点，而`setLastPoint`设置最后一个角点：'
- en: '[PRE139]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `isClick` method is simpler than its counterpart in `Line`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`isClick`方法比其在`Line`中的对应方法简单：'
- en: '[PRE140]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'If the rectangle is filled, we simply check whether the mouse click hit the
    rectangle by calling `contains` in `QRect`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形被填充，我们简单地通过在`QRect`中调用`contains`来检查鼠标点击是否击中了矩形：
- en: '[PRE141]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If the rectangle is not filled, we need to check whether the mouse clicked
    on the border of the rectangle. To do so, we create two slightly smaller and larger
    rectangles. If the mouse click hit the larger rectangle, but not the smaller one,
    we consider the rectangle border to be hit:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形没有被填充，我们需要检查鼠标是否点击了矩形的边界。为此，我们创建两个稍微小一些和大一些的矩形。如果鼠标点击击中了较大的矩形，但没有击中较小的矩形，我们认为矩形边界被击中：
- en: '[PRE142]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When moving the rectangle, we simply move the first and last corners:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动矩形时，我们只需移动第一个和最后一个角：
- en: '[PRE143]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'When drawing a rectangle, we first set the pen color by calling `color` in
    `Figure`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制矩形时，我们首先通过调用`Figure`中的`color`来设置笔的颜色：
- en: '[PRE144]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'If the rectangle is filled, we simply call `fillRect` on the `QPainter` object:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形被填充，我们只需在`QPainter`对象上调用`fillRect`：
- en: '[PRE145]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'If the rectangle is unfilled, we disable the brush to make the rectangle hollow,
    and we then call `drawRect` on the `QPainter` object to draw the border of the
    rectangle:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形没有被填充，我们禁用画笔使矩形空心，然后调用`QPainter`对象的`drawRect`来绘制矩形的边界：
- en: '[PRE146]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The `write` method first calls `write` in `Figure`, and it then writes the
    first and last corners of the rectangle:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法首先在`Figure`中调用`write`，然后写入矩形的第一个和最后一个角：'
- en: '[PRE147]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'In the same way, `read` first calls `read` in `Figure`, and then reads the
    first and last corners of the rectangle:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`read`首先在`Figure`中调用`read`，然后读取矩形的第一个和最后一个角：
- en: '[PRE148]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The Ellipse sub class
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 椭圆子类
- en: '`EllipseX` is a sub class of `RectangleX` that handles an ellipse. Part of
    the functionality of `RectangleX` is reused in `EllipseX`. More specifically,
    `initializePoints`, `setLastPoint`, `move`, `write`, and `read` are overridden
    from `RectangleX`.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`EllipseX`是处理椭圆的`RectangleX`子类。`RectangleX`的部分功能在`EllipseX`中被重用。更具体地说，`initializePoints`、`setLastPoint`、`move`、`write`和`read`是从`RectangleX`中重写的。'
- en: '**Ellipse.h:**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ellipse.h:**'
- en: '[PRE149]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '**Ellipse.cpp:**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ellipse.cpp:**'
- en: '[PRE150]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The `isClick` method of `EllipseX` is similar to its counterpart in `RectangleX`.
    We use the Qt `QRegion` class to create elliptic objects that we compare to the
    mouse click:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`EllipseX`类的`isClick`方法与其在`RectangleX`中的对应方法类似。我们使用Qt的`QRegion`类创建椭圆对象，并将其与鼠标点击进行比较：'
- en: '[PRE151]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If the ellipse is filled, we create an elliptic region and test whether the
    mouse click hit the region:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果椭圆被填充，我们创建一个椭圆区域并测试鼠标点击是否击中了该区域：
- en: '[PRE152]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'If the ellipse in unfilled, we create slightly smaller and larger elliptic
    regions. If the mouse click hit the smaller region, but not the smaller one, we
    consider the border of the ellipse to be hit:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果椭圆没有被填充，我们创建稍微小一些和大一些的椭圆区域。如果鼠标点击击中了较小的区域，但没有击中较大的区域，我们认为椭圆的边界被击中：
- en: '[PRE153]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'When drawing an ellipse, we first set the pen color by calling `color` in `Figure`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制椭圆时，我们首先通过调用`Figure`中的`color`来设置笔的颜色：
- en: '[PRE154]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'If the ellipse is filled, we set the brush and draw the ellipse:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果椭圆被填充，我们设置画笔并绘制椭圆：
- en: '[PRE155]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'If the ellipse is unfilled, we set the brush to hollow and draw the ellipse
    border:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果椭圆没有被填充，我们设置画笔为空心并绘制椭圆边界：
- en: '[PRE156]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Drawing the window
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制窗口
- en: The `DrawingWindow` class is a sub class to the `MainWindow` class of the previous
    section.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingWindow`类是上一节中`MainWindow`类的子类。'
- en: '**DrawingWindow.h:**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWindow.h:**'
- en: '[PRE157]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '**DrawingWindow.cpp:**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWindow.cpp:**'
- en: '[PRE158]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The constructor sets the size of the window to `1000` * `500` pixels:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将窗口的大小设置为`1000` * `500`像素：
- en: '[PRE159]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The `m_drawingWidgetPtr` field is initialized to point at an object of the
    `DrawingWidget` class, which is then set to the center part of the window:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_drawingWidgetPtr`字段被初始化为指向`DrawingWidget`类的一个对象，然后将其设置为窗口的中心部分：'
- en: '[PRE160]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The standard file menu is added to the window menu bar:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 标准文件菜单被添加到窗口菜单栏：
- en: '[PRE161]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'We then add the application-specific format menu. It is connected to the `onMenuShow`
    method of the `DocumentWidget` class of the previous section:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加应用程序特定的格式菜单。它连接到上一节中`DocumentWidget`类的`onMenuShow`方法：
- en: '[PRE162]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The format menu holds the color and fill items:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 格式菜单包含颜色和填充项：
- en: '[PRE163]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The fill item will be enabled when the next figure of the drawing program is
    a two-dimensional figure (rectangle or ellipse):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘图程序的下一个图形是一个二维图形（矩形或椭圆）时，填充项将被启用：
- en: '[PRE164]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'For the figure menu, we create a new action group for the line, rectangle,
    and ellipse item. Only one of them shall be marked at the same time:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图形菜单，我们为线、矩形和椭圆项创建一个新的动作组。它们中只能同时标记一个：
- en: '[PRE165]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The currently selected item shall be marked with a radio button:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选中的项应使用单选按钮标记：
- en: '[PRE166]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The destructor deallocates the figure group that was dynamically allocated
    in the constructor:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数释放了在构造函数中动态分配的图形组：
- en: '[PRE167]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Drawing the widget
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制小部件
- en: '`DrawingWidget` is a sub class of `DocumentWidget` in the previous section.
    It handles mouse input, painting of the figures, as well as saving and loading
    of the drawing. It also provides methods for deciding when the menu items shall
    be marked and enabled.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingWidget`是上一节中`DocumentWidget`的子类。它处理鼠标输入、图形的绘制以及绘图的保存和加载。它还提供了决定何时标记和启用菜单项的方法。'
- en: '**DrawingWidget.h:**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWidget.h:**'
- en: '[PRE168]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The `mousePressEvent`, `mouseReleaseEvent`, and `mouseMoveEvent` are overridden
    methods that are called when the user presses or releases one of the mouse keys
    or moves the mouse:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下或释放鼠标键或移动鼠标时，会调用重写的`mousePressEvent`、`mouseReleaseEvent`和`mouseMoveEvent`方法：
- en: '[PRE169]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `paintEvent` method is called when the window needs to be repainted. That
    can happen for several reasons. For instance, the user can modify the size of
    the window. The repainting can also be forced by a call to the `update` method,
    which causes `paintEvent` to be called eventually:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口需要重新绘制时，会调用`paintEvent`方法。这可以由几个原因引起。例如，用户可以修改窗口的大小。重新绘制也可以通过调用`update`方法强制执行，这最终会导致调用`paintEvent`：
- en: '[PRE170]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The `newDocument` method is called when the user selects the new menu item,
    `writeFile` is called when the user selects the save or save as item, and `readFile`
    is called when the user selects the open item:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择新菜单项时，会调用`newDocument`方法，当用户选择保存或另存为项时，会调用`writeFile`，当用户选择打开项时，会调用`readFile`：
- en: '[PRE171]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The `onColor` and `onFill` methods are called when the user selects the color
    and fill menu items:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择颜色和填充菜单项时，会调用`onColor`和`onFill`方法：
- en: '[PRE172]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `isFillEnabled` method is called before the user selects the format menu.
    If it returns `true`, the fill item becomes enabled:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户选择格式菜单之前会调用`isFillEnabled`方法。如果它返回`true`，则填充项变为启用：
- en: '[PRE173]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `isLineChecked`, `isRectangleChecked`, and `isEllipseChecked` methods are
    also called before the figure menu becomes visible. The items become marked with
    a radio button if the methods return `true`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形菜单可见之前也会调用`isLineChecked`、`isRectangleChecked`和`isEllipseChecked`方法。如果方法返回`true`，则项目会带有单选按钮：
- en: '[PRE174]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The `onLine`, `onRectangle`, and `isEllipse` methods are called when the user
    selects the line, rectangle, and ellipse menu items:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择线条、矩形和椭圆菜单项时，会调用`onLine`、`onRectangle`和`isEllipse`方法：
- en: '[PRE175]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'When running, the application can hold the `Idle`, `Create`, or `Move` modes:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，它可以保持`Idle`、`Create`或`Move`模式：
- en: '`Idle`: When the application is waiting for input from the user.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Idle`：当应用程序等待用户输入时。'
- en: '`Create`: When the user is adding a new figure to the drawing. Occurs when
    the user presses the left mouse button without hitting a figure. A new figure
    is added and its end-point is modified until the user releases the mouse button.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create`：当用户向绘图添加新图形时。发生在用户按下左鼠标按钮而没有击中图形时。添加一个新图形，并修改其端点，直到用户释放鼠标按钮。'
- en: '`Move`: When the user is moving a figure. Occurs when the user presses the
    left mouse button and hitting a figure. The figure is moved until the user releases
    the mouse button.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Move`：当用户移动图形时。发生在用户按下左鼠标按钮并击中图形时。图形被移动，直到用户释放鼠标按钮。'
- en: '[PRE176]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The `m_currColor` field holds the color of the next figure to be added by the
    user; `m_currFilled` decides whether the next figure (if it is a rectangle or
    an ellipse) shall be filled. The `m_addFigureId` method holds the identity integer
    of the next type of figure (line, rectangle, or ellipse) to be added by the user:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_currColor`字段保存用户将要添加的下一个图形的颜色；`m_currFilled`决定下一个图形（如果是矩形或椭圆）是否应该填充。`m_addFigureId`方法保存用户将要添加的下一个图形类型（线条、矩形或椭圆）的标识整数：'
- en: '[PRE177]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'When the user presses a mouse button and moves a figure, we need to store the
    previous mouse point in order to calculate the distance the figure has been moved
    since the last mouse events:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮并移动图形时，我们需要存储上一个鼠标点，以便计算图形自上次鼠标事件以来移动的距离：
- en: '[PRE178]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Finally, `m_figurePtrList` holds pointers to the figures of the drawing. The
    top-most figure in the drawing is placed at the end of the list:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`m_figurePtrList`保存指向绘图图形的指针。绘图中最顶层的图形位于列表的末尾：
- en: '[PRE179]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '**DrawingWidget.cpp:**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWidget.cpp:**'
- en: '[PRE180]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The constructor calls the constructor the base class `DocumentWidget` with
    the title `Drawing`. It also sets the save and load mask to `Drawing files (*.drw)`,
    which means that the default files selected by the standard save and load dialogs
    have the suffix `drw`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用基类`DocumentWidget`的构造函数，标题为`Drawing`。它还将保存和加载掩码设置为`Drawing files (*.drw)`，这意味着标准保存和加载对话框中默认选择的文件具有`drw`后缀：
- en: '[PRE181]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The destructor deallocates the figure pointers of the figure pointer list:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数释放图形指针列表中的图形指针：
- en: '[PRE182]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The `setApplicationMode` method sets the application mode and calls `onMenuShow`
    in the main window for the toolbar icons to be correctly enabled:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`setApplicationMode`方法设置应用程序模式，并在主窗口中调用`onMenuShow`以正确启用工具栏图标：'
- en: '[PRE183]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'When the user selects the new menu item, `newDocument` is called. The figures
    of the figure pointer list are deallocated, and the list itself is cleared:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择新菜单项时，会调用`newDocument`。图形指针列表中的图形被释放，列表本身被清除：
- en: '[PRE184]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The next figure to be added by the user is a black line, and the filled status
    is `false`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将要添加的下一个图形是一条黑色线条，并且填充状态为`false`：
- en: '[PRE185]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The `writeFile` method is called when the user selects the save or save as
    menu items:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择保存或另存为菜单项时，会调用`writeFile`方法：
- en: '[PRE186]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'We start by writing the current color and fill status. We then continue by
    writing the size of the figure pointer list, and the figures themselves:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先写入当前颜色和填充状态。然后继续写入图形指针列表的大小，以及图形本身：
- en: '[PRE187]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'For each figure, we first write its identity number, and we then write the
    figure itself:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个图形，我们首先写入其身份编号，然后写入图形本身：
- en: '[PRE188]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'If the file was not possible to open, `false` is returned:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件无法打开，则返回`false`：
- en: '[PRE189]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The `readFile` method is called when the user selects the open menu item. In
    the same way as in `writeFile` previously, we read the color and fill status,
    the size of the figure pointer list, and then the figures themselves:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择打开菜单项时，会调用`readFile`方法。与之前的`writeFile`方法相同，我们读取颜色和填充状态，图形指针列表的大小，然后是图形本身：
- en: '[PRE190]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'When reading the figure, we first read its identity number, and call `createFigure`
    to create an object of the class corresponding to the figure''s identity number.
    We then read the fields of the figure by calling `read` on its pointer. Note that
    we do not really know (or care) what kind of figure it is. We simply call read
    to the figure pointer, which in fact points to an object of `Line`, `RectangleX`,
    or `EllipseX`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取图形时，我们首先读取其身份编号，并调用`createFigure`来创建与图形身份编号对应的类的对象。然后通过调用其指针上的`read`来读取图形的字段。请注意，我们实际上并不真正知道（或关心）它是哪种图形。我们只是调用图形指针的`read`，该指针实际上指向`Line`、`RectangleX`或`EllipseX`类的对象：
- en: '[PRE191]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The `createFigure` method dynamically creates an object of the `Line`, `RectangleX`,
    or `EllipseX` class, depending on the value of the `figureId` parameter:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`figureId`参数的值，`createFigure`方法动态创建`Line`、`RectangleX`或`EllipseX`类的对象：
- en: '[PRE192]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The `onColor` method is called when the user selects the color menu item. It
    sets the color of the next figure to be added by the user:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择颜色菜单项时，会调用`onColor`方法。它设置用户将要添加的下一个图形的颜色：
- en: '[PRE193]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The `isFillEnabled` method is called before the format menu becomes visible,
    and returns `true` if the next figure to be added by the user is a rectangle or
    an ellipse:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式菜单可见之前，会调用`isFillEnabled`方法，如果用户将要添加的下一个图形是矩形或椭圆，则返回`true`：
- en: '[PRE194]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'The `onFill` method is called when the user selects fill menu item. It inverts
    the `m_currFilled` field. It also sets the modified flag since the document has
    been affected:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择填充菜单项时，会调用`onFill`方法。它反转`m_currFilled`字段。它还设置修改标志，因为文档已被影响：
- en: '[PRE195]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The `isLineChecked`, `isRectangleChecked`, and `isEllipseChecked` methods are
    called before the figure menu becomes visible. If they return `true`, the items
    become checked with a radio button if the next figure to be added is the figure
    in question:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形菜单可见之前，会调用`isLineChecked`、`isRectangleChecked`和`isEllipseChecked`方法。如果它们返回`true`，则如果下一个要添加的图形是所涉及的图形，则项目会通过单选按钮被选中：
- en: '[PRE196]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The `onLine`, `onRectangle`, and `onEllipse` methods are called when the user
    selects the items in the figure menu. They set the next figure to be added by
    the user to the figure in question:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择图形菜单中的项目时，会调用`onLine`、`onRectangle`和`onEllipse`方法。它们将用户将要添加的下一个图形设置为所涉及的图形：
- en: '[PRE197]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The `mousePressEvent` method is called every time the user presses one of the
    mouse keys. First, we need to check if they have pressed the left mouse key:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户按下鼠标键时，都会调用`mousePressEvent`方法。首先，我们需要检查他们是否按下了左鼠标键：
- en: '[PRE198]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'In the call to `mouseMoveEvent` in the following snippet, we need to keep track
    of the latest mouse point in order to calculate the distance between mouse movements.
    Therefore, we set `m_mousePoint` to the mouse point:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中对`mouseMoveEvent`的调用中，我们需要跟踪最新的鼠标点，以便计算鼠标移动之间的距离。因此，我们将`m_mousePoint`设置为鼠标点：
- en: '[PRE199]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'We iterate through the figure pointer list and, for each figure, we check if
    the figure has been hit by the mouse click by calling `isClick`. We need to iterate
    backwards in a rather awkward manner in order to find the top-most figure first.
    We use the `reverse_iterator` class and the `rbegin` and `rend` methods in order
    to iterate backwards:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历图形指针列表，并对每个图形，我们通过调用`isClick`来检查图形是否被鼠标点击。我们需要以相当尴尬的方式反向迭代，以便首先找到最顶部的图形。我们使用`reverse_iterator`类和`rbegin`和`rend`方法来反向迭代：
- en: '[PRE200]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We use the dereference operator (`*`) to obtain the figure pointer in the list:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用解引用运算符（`*`）来获取列表中的图形指针：
- en: '[PRE201]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'If the figure has been hit by the mouse click, we set the application mode
    to move. We also place the figure at the end of the list, so that it appears to
    be top-most in the drawing, by calling `removeOne` and `push_back` on the list.
    Finally, we break the loop since we have found the figure we are looking for:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图形被鼠标点击，我们将应用程序模式设置为移动。我们还通过在列表上调用`removeOne`和`push_back`来将图形放置在列表的末尾，使其看起来是绘图的顶层。最后，我们中断循环，因为我们已经找到了我们正在寻找的图形：
- en: '[PRE202]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'If the application mode is still idle (has not moved), we have not found a
    figure hit by the mouse click. In that case, we set the application mode to create
    and call `createFigure` to find a figure to copy. We then set the color and filled
    status as well as the points of the figure. Finally, we add the figure pointer
    to the figure pointer list by calling `push_back` (which is added at the end of
    the list in order for it to appear at the top of the drawing) and set the modified
    flag to `true`, since the drawing has been modified:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序模式仍然是空闲状态（没有移动），我们没有找到被鼠标点击的图形。在这种情况下，我们将应用程序模式设置为创建，并调用`createFigure`来找到一个要复制的图形。然后，我们设置图形的颜色和填充状态以及图形的点。最后，通过调用`push_back`（为了使其出现在绘图的顶部，将其添加到列表的末尾）并将修改标志设置为`true`，因为绘图已被修改：
- en: '[PRE203]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'The `mouseMoveEvent` is called every time the user moves the mouse. First,
    we need to check that the user presses the left mouse key when they move the mouse:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户移动鼠标时，都会调用`mouseMoveEvent`。首先，我们需要检查用户在移动鼠标时是否按下了鼠标左键：
- en: '[PRE204]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'We then check the application mode. If we are in the process of adding a new
    figure to the drawing, we modify its last point:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查应用程序模式。如果我们正在将新图形添加到绘图的过程中，我们修改其最后一个点：
- en: '[PRE205]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'If we are in the process of moving a figure, we calculate the distance since
    the last mouse event and move the figure placed at the end of the figure pointer
    list. Remember that the figure hit by the mouse click was placed at the end of
    the figure pointer list in the preceding `mousePressEvent`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在移动一个图形的过程中，我们将计算自上次鼠标事件以来的距离，并将位于图形指针列表末尾的图形移动。记住，被鼠标点击的图形是在前一个`mousePressEvent`中放置在图形指针列表末尾的：
- en: '[PRE206]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Finally, we update the current mouse point for the next call to `mouseMoveEvent`.
    We also call the update method to force a repainting of the window:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新当前鼠标点，以便下一次调用`mouseMoveEvent`。我们还调用更新方法来强制窗口重新绘制：
- en: '[PRE207]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The `mouseReleaseEvent` method is called when the user releases one of the
    mouse buttons. We set the application mode to idle:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放鼠标按钮之一时，会调用`mouseReleaseEvent`方法。我们将应用程序模式设置为空闲：
- en: '[PRE208]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The `paintEvent` method is called every time the window needs to be repainted.
    It may happen for several reasons. For instance, the user may have changed the
    size of the window. It may also be a result of a call to `update` in the Qt `QWidget`
    class, which forces a repainting of the window and an eventual call to `paintEvent`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 每当窗口需要重新绘制时，都会调用`paintEvent`方法。这可能是由于几个原因。例如，用户可能已经改变了窗口的大小。这也可能是由于在Qt的`QWidget`类中调用`update`的结果，这强制窗口重新绘制，并最终调用`paintEvent`。
- en: 'We start by creating a `QPainter` object, which can be regarded as canvas to
    paint on, and set suitable rendering. We then iterate through the figure pointer
    list, and draw each figure. In this way, the last figure in the list is drawn
    at the top of the drawing:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`QPainter`对象，这可以被视为绘画的画布，并设置合适的渲染。然后，我们遍历图形指针列表，并绘制每个图形。这样，列表中的最后一个图形就会绘制在绘图的顶部：
- en: '[PRE209]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: The main function
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: Finally, we start the application in the `main` function by creating an application
    object, showing the main window and executing the application.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `main` 函数中通过创建应用程序对象、显示主窗口并执行应用程序来启动应用程序。
- en: '**Main.cpp:**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE210]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The following output is received:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的输出如下：
- en: '![](img/25b6b2a9-d07d-4e9e-b8c8-28b2475353a8.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25b6b2a9-d07d-4e9e-b8c8-28b2475353a8.png)'
- en: Building an editor
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建编辑器
- en: The next application is an editor, where the user can input and edit text. The
    current input position is indicated by a caret. It is possible to move the caret
    with the arrow keys and by clicking with the mouse.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个应用程序是一个编辑器，用户可以在其中输入和编辑文本。当前输入位置由光标指示。可以使用箭头键和鼠标点击来移动光标。
- en: The Caret class
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光标类
- en: The `Caret` class handles the caret; that is, the blinking vertical line marking
    the position of the next character to be input.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caret` 类处理光标；即标记下一个要输入的字符位置的闪烁垂直线。'
- en: '**Caret.h:**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**Caret.h:**'
- en: '[PRE211]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'The `show` and `hide` methods show and hide the caret. In this application,
    the caret is never hidden. However, in the advanced version in the next chapter,
    the caret will be hidden on some occasions:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 和 `hide` 方法用于显示和隐藏光标。在本应用中，光标永远不会被隐藏。然而，在下一章的高级版本中，在某些情况下光标将被隐藏：'
- en: '[PRE212]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'The `set` method sets the current size and position of the caret, and `paint`
    paints it on the `QPainter` object:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 方法设置光标的当前尺寸和位置，而 `paint` 方法将其绘制在 `QPainter` 对象上：'
- en: '[PRE213]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'The `onTimer` method is called every time the caret blinks:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 每次光标闪烁时都会调用 `onTimer` 方法：
- en: '[PRE214]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'The `m_visible` field is true when the caret is visible:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当光标可见时，`m_visible` 字段为真：
- en: '[PRE215]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The `m_rect` field handles the timer that makes the caret blink:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_rect` 字段处理使光标闪烁的计时器：'
- en: '[PRE216]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The `m_timer` field handles the timer that makes the caret blink:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_timer` 字段处理使光标闪烁的计时器：'
- en: '[PRE217]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The `Caret.cpp` file holds the definitions of the methods of the `Caret` class.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caret.cpp` 文件包含 `Caret` 类方法的定义。'
- en: '**Caret.cpp:**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**Caret.cpp:**'
- en: '[PRE218]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The constructor connects the timer signal to `onTimer`, with the result that
    `onTimer` is called for every timeout. The timer is then initialized to `500`
    milliseconds. That is, `onTimer` will be called every `500` milliseconds, and
    the caret becomes shown and hidden every 500 milliseconds:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将计时器信号连接到 `onTimer`，结果为每次超时都会调用 `onTimer`。然后计时器初始化为 `500` 毫秒。也就是说，`onTimer`
    将每 `500` 毫秒被调用一次，光标每 `500` 毫秒显示和隐藏：
- en: '[PRE219]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The `show` and `hide` methods set the `m_visible` field and force a repainting
    of the caret area by calling `update` on the parent window:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 和 `hide` 方法设置 `m_visible` 字段并通过在父窗口上调用 `update` 强制重绘光标区域：'
- en: '[PRE220]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'The `set` method sets the size and position of the caret. However, the width
    of the caret is always set to one, which makes it appear as a thin vertical line:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 方法设置光标的尺寸和位置。然而，光标的宽度始终设置为1，这使得它看起来像一条细长的垂直线：'
- en: '[PRE221]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The `onTimer` method is called every 500 milliseconds. It inverts `m_blink`
    and forces a repaint of the caret. This gives the result that the caret blinks
    at an interval of one second:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTimer` 方法每500毫秒被调用一次。它反转 `m_blink` 并强制重绘光标。这导致光标以一秒的间隔闪烁：'
- en: '[PRE222]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The `paint` method is called every time the caret needs to be repainted. The
    caret is drawn if both `m_visible` and `m_blink` are true, which they are if the
    caret is set to be visible and the caret is blinking; that is, that the caret
    is visible in the blinking interval. The area of the caret is cleared before the
    call to paint, so that if no drawing occurs, the caret is cleared:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要重绘光标时都会调用 `paint` 方法。如果 `m_visible` 和 `m_blink` 都为真，则绘制光标；如果光标被设置为可见且光标正在闪烁，即光标在闪烁间隔内可见，则它们为真。在调用
    `paint` 之前清除光标区域，以便如果没有发生绘制，则清除光标：
- en: '[PRE223]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Drawing the editor window
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制编辑器窗口
- en: '`EditorWindow` is a sub class of `MainWindow` in the previous section. It handles
    the closing of the window. Moreover, it also handles the key press event.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditorWindow` 是上一节中 `MainWindow` 的子类。它处理窗口的关闭操作。此外，它还处理按键事件。'
- en: '**EditorWindow.h:**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWindow.h:**'
- en: '[PRE224]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'The `keyPressEvent` method is called every time the user presses a key, and
    `closeEvent` is called when the user tries closing the window:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户按下键时都会调用 `keyPressEvent` 方法，当用户尝试关闭窗口时调用 `closeEvent`：
- en: '[PRE225]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: The `EditorWindow` class is in fact rather small. It only defines the constructor
    and the destructor, as well as the `keyPressEvent` and `closePressEvent` methods.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditorWindow` 类实际上相当小。它只定义了构造函数和析构函数，以及 `keyPressEvent` 和 `closePressEvent`
    方法。'
- en: '**EditorWindow.cpp:**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWindow.cpp:**'
- en: '[PRE226]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'The constructor sets the size of the window to `1000` * `500` pixels and adds
    the standard file menu to the menu bar:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将窗口大小设置为 `1000` * `500` 像素，并将标准文件菜单添加到菜单栏：
- en: '[PRE227]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'The `keyPressEvent` and `closeEvent` methods just pass the message to their
    counterpart methods in the editor widget, which is located at the center of the
    window:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyPressEvent` 和 `closeEvent` 方法只是将消息传递给编辑器小部件中的对应方法，该小部件位于窗口中心：'
- en: '[PRE228]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Drawing the editor widget
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制编辑器小部件
- en: The `EditorWidget` class is a sub class of `DocumentWidget` of the previous
    section. It catches the key, mouse, resizing, and closing events. It also overrides
    the methods for saving and loading documents.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditorWidget` 类是上一节中 `DocumentWidget` 的子类。它捕获键、鼠标、调整大小和关闭事件。它还重写了保存和加载文档的方法。'
- en: '**EditorWidget.h:**'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWidget.h:** '
- en: '[PRE229]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'The `keyPressEvent` is called when the user presses a key, and `mousePressEvent`
    is called when the user clicks with the mouse:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下键时调用 `keyPressEvent`，当用户用鼠标点击时调用 `mousePressEvent`：
- en: '[PRE230]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The `mouseToIndex` method is an auxiliary method that calculates the index
    of the character the user clicks at with the mouse:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseToIndex` 方法是一个辅助方法，用于计算用户用鼠标点击的字符的索引：'
- en: '[PRE231]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'The `paintEvent` method is called when the window needs to be repainted, and
    `resizeEvent` is called when the user resizes the window. We catch the resize
    event in this application because we want to recalculate the number of characters
    that fits on each line:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口需要重绘时调用 `paintEvent` 方法，当用户调整窗口大小时调用 `resizeEvent`。我们在此应用程序中捕获调整大小事件，因为我们想要重新计算每行可以容纳的字符数：
- en: '[PRE232]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Similar to the drawing program in the previous section, `newDocument` is called
    when the user selects the New menu item, `writeFile` is called when the user selects
    the save or save as items, and `readFile` is called when the user selects the
    open item:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中的绘图程序类似，当用户选择“新建”菜单项时调用 `newDocument`，当用户选择“保存”或“另存为”项时调用 `writeFile`，当用户选择“打开”项时调用
    `readFile`：
- en: '[PRE233]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The `setCaret` method is called to set the caret as a response to user input
    or a mouse click:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `setCaret` 方法以响应用户输入或鼠标点击来设置光标：
- en: '[PRE234]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'When the user moves the caret up or down, we need to find the index of character
    over or under the caret. The easiest way to do that is to simulate a mouse click:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动光标上下时，我们需要找到光标上方或下方的字符索引。完成此操作的最简单方法是模拟鼠标点击：
- en: '[PRE235]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The `calculate` method is an auxiliary method that calculates the number of
    lines, and the position of each character on each line:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate` 方法是一个辅助方法，用于计算行数以及每行中每个字符的位置：'
- en: '[PRE236]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The `m_editIndex` field holds the index of the position for the user to input
    text. That position is also where the caret is visible:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_editIndex` 字段持有用户输入文本的位置索引。该位置也是光标可见的位置：'
- en: '[PRE237]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'The `m_caret` field holds the caret of the application:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_caret` 字段持有应用程序的光标：'
- en: '[PRE238]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The text of the editor is stored in `m_editorText`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的文本存储在 `m_editorText` 中：
- en: '[PRE239]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'The text of the editor may be distributed over several lines; `m_lineList`
    keeps track of the first and last index of each line:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的文本可能分布在多行；`m_lineList` 跟踪每行的第一个和最后一个索引：
- en: '[PRE240]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The preceding `calculate` method calculates the rectangle of each character
    in the editor text, and places them in `m_rectList`:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `calculate` 方法计算编辑器文本中每个字符的矩形，并将它们放置在 `m_rectList` 中：
- en: '[PRE241]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'In the application of this chapter, all characters hold the same font, which
    is stored in `TextFont`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的应用中，所有字符都使用相同的字体，该字体存储在 `TextFont` 中：
- en: '[PRE242]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '`FontWidth` and `FontHeight` hold the width and height of a character in `TextFont`:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`FontWidth` 和 `FontHeight` 持有 `TextFont` 中字符的宽度和高度：'
- en: '[PRE243]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The `EditorWidget` class is rather large. It defines the functionality of the
    editor.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditorWidget` 类相当大。它定义了编辑器的功能。'
- en: '**EditorWidget.cpp:**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWidget.cpp:** '
- en: '[PRE244]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'We initialize the text font to 12-point `Courier New`:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文本字体初始化为12点的 `Courier New`：
- en: '[PRE245]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'The constructor sets the title to `Editor` and the file suffix for the standard
    Load and Save dialogs to `edi`. The height and average width, in pixels, of a
    character in the text font are set with the Qt `QMetrics` class. The rectangle
    of each character is calculated, and the caret is set to the first character in
    the text:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将标题设置为 `Editor`，并将标准加载和保存对话框的文件后缀设置为 `edi`。使用 Qt `QMetrics` 类设置文本字体中字符的高度和平均宽度（以像素为单位）。计算每个字符的矩形，并将光标设置为文本中的第一个字符：
- en: '[PRE246]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'The `newDocument` method is called when the user selects the new menu item.
    It clears the text, sets the caret, and recalculates the character rectangles:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择新菜单项时，会调用`newDocument`方法。它会清除文本，设置光标，并重新计算字符矩形：
- en: '[PRE247]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'The `writeFile` method is called when the user selects the save or save as
    menu items. It simply writes the current text of the editor:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择保存或另存为菜单项时，会调用`writeFile`方法。它简单地写入编辑器的当前文本：
- en: '[PRE248]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'We use the `Ok` field of the input stream to decide if the writing was successful:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用输入流的`Ok`字段来决定写入是否成功：
- en: '[PRE249]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'If it was not possible to open the file for writing, `false` is returned:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法打开文件进行写入，则返回`false`：
- en: '[PRE250]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The `readFile` method is called when the user selects the load menu item. It
    reads all the text of the editor by calling `readAll` on the input stream:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择加载菜单项时，会调用`readFile`方法。它通过在输入流上调用`readAll`来读取编辑器的所有文本：
- en: '[PRE251]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'When the text has been read, the character rectangles are calculated, and the
    caret is set:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本被读取后，计算字符矩形，并设置光标：
- en: '[PRE252]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'We use the `Ok` field of the input stream to decide if the reading was successful:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用输入流的`Ok`字段来决定读取是否成功：
- en: '[PRE253]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'If it was not possible to open the file for reading, `false` is returned:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法打开文件进行读取，则返回`false`：
- en: '[PRE254]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'The `mousePressEvent` is called when the user presses one of the mouse buttons.
    If the user presses the left button, we call `mouseToIndex` to calculate the index
    of the character clicked at, and set the caret to that index:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮之一时，会调用`mousePressEvent`。如果用户按下左键，我们调用`mouseToIndex`来计算点击的字符索引，并将光标设置到该索引：
- en: '[PRE255]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'The `keyPressEvent` is called when the user presses a key. First, we check
    if it is an arrow key, the delete, backspace, or return key. If it is not, we
    insert the character at the position indicated by the caret:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下键时，会调用`keyPressEvent`。首先，我们检查它是否是箭头键、删除键、退格键或回车键。如果不是，我们将在光标指示的位置插入字符：
- en: '[PRE256]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'If the key is the left-arrow key, and if the edit caret is not already located
    at the beginning of the text, we decrease the edit index:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是向左箭头键，并且如果编辑光标尚未位于文本开头，我们减少编辑索引：
- en: '[PRE257]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'If the key is the right-arrow key, and if the edit caret is not already located
    at the end of the text, we increase the edit index:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是向右箭头键，并且如果编辑光标尚未位于文本末尾，我们增加编辑索引：
- en: '[PRE258]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'If the key is the up-arrow key, and if the edit caret is not already located
    at the top of the editor, we call `similateMouseClick` to simulate that the user
    clicks with the mouse at a point slightly over the current index. In that way,
    the new edit index will at the line over the current line:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是向上箭头键，并且如果编辑光标尚未位于编辑器的顶部，我们调用`similateMouseClick`来模拟用户在当前索引稍上方点击鼠标。这样，新的编辑索引将位于当前行的上方行：
- en: '[PRE259]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'If the key is the down-arrow key, we call `similateMouseClick` to simulate
    that the user clicks with the mouse at a point slightly under the current index.
    In that way, we the edit carat will be located at the character directly beneath
    the current character. Note that if the index is already at the bottom line, nothing
    happens:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是向下箭头键，我们调用`similateMouseClick`来模拟用户在当前索引稍下方点击鼠标。这样，编辑光标将位于当前字符直接下方的字符。注意，如果索引已经在底部行，则不会发生任何操作：
- en: '[PRE260]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'If the user presses the delete key, and the edit index is not already beyond
    the end of the text, the current character is removed:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下删除键，并且编辑索引尚未超出文本末尾，则移除当前字符：
- en: '[PRE261]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'If the user presses the backspace key, and the edit index is not already at
    the beginning of the text, the character before the current character is removed:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下退格键，并且编辑索引尚未位于文本开头，则移除当前字符之前的字符：
- en: '[PRE262]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'If the user presses the return key, the newline character (`n`) is inserted:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下回车键，则插入换行字符（`n`）：
- en: '[PRE263]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'If the user presses a readable character, it is given by the `text` method,
    and we insert its first character at the edit index:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下可读字符，它由`text`方法提供，我们将它的第一个字符插入到编辑索引处：
- en: '[PRE264]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'When the text has been modified, we need to calculate the character rectangles,
    set the caret, and force a repaint by calling `update`:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本被修改后，我们需要计算字符矩形，设置光标，并通过调用`update`强制重绘：
- en: '[PRE265]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'The `similateMouseClick` method simulates a mouse click by calling `mousePressEvent`
    and `mousePressRelease` with the given point:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`similateMouseClick`方法通过调用`mousePressEvent`和`mousePressRelease`以及给定的点来模拟鼠标点击：'
- en: '[PRE266]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The `setCaret` method creates a rectangle holding the size and position of
    the caret, and then hides, sets, and shows the caret:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`setCaret` 方法创建一个包含光标大小和位置的矩形，然后隐藏、设置并显示光标：'
- en: '[PRE267]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'The `mouseToIndex` method calculates the edit index of the given mouse point:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseToIndex` 方法计算给定鼠标点的编辑索引：'
- en: '[PRE268]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'First, we set the `y` coordinate to the text, in case it is below the text:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `y` 坐标设置为文本，以防它在文本下方：
- en: '[PRE269]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'We calculate the line of the mouse point:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算鼠标点的行：
- en: '[PRE270]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'We find the index on that line:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在该行找到索引：
- en: '[PRE271]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'The `resizeEvent` method is called when the user changes the size of the window.
    The character rectangles are recalculated since the lines may be shorter or longer:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改窗口大小时，会调用 `resizeEvent` 方法。由于线条可能变短或变长，因此会重新计算字符矩形：
- en: '[PRE272]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'The `calculate` method is called every time there has been a change in the
    text or when the window size has been changed. It iterates through the text and
    calculates the rectangle for each character:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 每当文本发生变化或窗口大小发生变化时，都会调用 `calculate` 方法。它会遍历文本并为每个字符计算矩形：
- en: '[PRE273]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'First, we need to divide the text into lines. Each line continues until it
    does not fit in the window, until we reach a new line, or until the text ends:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将文本分成行。每行继续直到它不适合窗口，直到我们达到一个新行，或者直到文本结束：
- en: '[PRE274]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'We then iterate through the lines and, for each line, calculate the rectangle
    of each character:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历这些行，并对每一行计算每个字符的矩形：
- en: '[PRE275]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'The `paintEvent` method is called when the window needs to be repainted:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口需要重绘时，会调用 `paintEvent` 方法：
- en: '[PRE276]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'We iterate through the text of the editor and, for each character except the
    new line, we write in its appropriate position:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历编辑器的文本，并对每个字符（除了换行符）在其适当的位置写入：
- en: '[PRE277]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: The main function
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main` 函数'
- en: Finally, the `main` function works in a way similar to the previous applications
    of this chapter—we create an application, create an editor window, and execute
    the application.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数的工作方式与本章之前的应用类似——我们创建一个应用程序，创建一个编辑窗口，并执行该应用程序。
- en: '**Main.cpp:**'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE278]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'The following output is obtained:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 得到以下输出：
- en: '![](img/a562a9ab-9bc0-4cbc-99f8-d3d7382a9605.png)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a562a9ab-9bc0-4cbc-99f8-d3d7382a9605.png)'
- en: Summary
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have developed three graphical applications with the Qt
    library—an analog clock, a drawing program, and an editor. The clock shows the
    current hour, minute, and second. In the drawing program we can draw lines, rectangles,
    and ellipses, and in the editor, we can input and edit text.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Qt 库开发了三个图形应用程序——一个模拟时钟、一个绘图程序和一个编辑器。时钟显示当前的小时、分钟和秒。在绘图程序中，我们可以绘制线条、矩形和椭圆，在编辑器中，我们可以输入和编辑文本。
- en: In the next chapter, we will continue to work with the applications, and develop
    more advanced versions.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续与这些应用程序一起工作，并开发更高级的版本。
