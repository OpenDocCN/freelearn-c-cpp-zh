<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-183" class="chapter-number"><a id="_idTextAnchor193"/>12</h1>&#13;
			<h1 id="_idParaDest-184"><a id="_idTextAnchor194"/>Instruction Selection</h1>&#13;
			<p>The heart of any backend is instruction selection. LLVM implements several approaches; in this chapter, we will <a id="_idIndexMarker806"/>implement instruction selection via the selection <strong class="bold">directed acyclic graph</strong> (<strong class="bold">DAG</strong>) and with global instruction selection.</p>&#13;
			<p>In this chapter, you will learn about the following topics:</p>&#13;
			<ul>&#13;
				<li><em class="italic">Defining the rules of the calling convention</em>: This section shows you how to describe the rules of a calling convention in the target description</li>&#13;
				<li><em class="italic">Instruction selection via the selection DAG</em>: This section teaches you how to implement instruction selection with a graph data structure</li>&#13;
				<li><em class="italic">Adding register and instruction information</em>: This section explains how to access information in the target description, and what additional information you need to provide</li>&#13;
				<li><em class="italic">Putting an empty frame lowering in place</em>: This section introduces you to the stack layout and the prologue of a function</li>&#13;
				<li><em class="italic">Emitting machine instructions</em>: This section tells you how machine instructions are finally written into an object file or as assembly text</li>&#13;
				<li><em class="italic">Creating the target machine and the sub-target</em>: This section shows you how a backend is configured</li>&#13;
				<li><em class="italic">Global instruction selection</em>: This section demonstrates a different approach to instruction selection</li>&#13;
				<li><em class="italic">How to further evolve the backend</em>: This section gives you some guidance about possible next steps</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to create an LLVM backend that can translate simple instructions. You will also acquire the knowledge to develop instruction selection via the selection DAG and with global instruction selection, and you will become familiar with all the important support classes you have to implement to get instruction selection working.</p>&#13;
			<h1 id="_idParaDest-185"><a id="_idTextAnchor195"/>Defining the rules of the calling convention</h1>&#13;
			<p>Implementing the rules of the calling convention is an important part of lowering the LLVM <strong class="bold">intermediate representation</strong> (<strong class="bold">IR</strong>) to machine code. The basic rules can be defined in <a id="_idIndexMarker807"/>the target description. Let’s have a look.</p>&#13;
			<p>Most calling <a id="_idIndexMarker808"/>conventions follow a basic pattern: they define a subset of registers for parameter passing. If this subset is not exhausted, the next parameter is passed in the next free register. If there is no free register, then the value is passed on the stack. This can be realized by looping over the parameters and deciding how to pass each parameter to the called function while keeping track of the used registers. In LLVM, this loop is implemented inside the framework, and the state is held <a id="_idIndexMarker809"/>in a class called <code>CCState</code>. Furthermore, the rules are defined in the target description.</p>&#13;
			<p>The rules are given as a sequence of conditions. If the condition holds, then an action is executed. Depending on the outcome of that action, either a place for the parameter is found, or the next condition is evaluated. For example, 32-bit integers are passed in a register. The condition is the type check, and the action is the assignment of a register to this parameter. In the target description, this is written as follows:</p>&#13;
			<pre class="source-code">&#13;
CCIfType&lt;[i32],&#13;
         CCAssignToReg&lt;[R2, R3, R4, R5, R6, R7, R8, R9]&gt;&gt;,</pre>			<p>Of course, if the called function has more than eight parameters, then the register list will be exhausted, and the action will fail. The remaining parameters are passed on the stack, and we can specify this as the next action:</p>&#13;
			<pre class="source-code">&#13;
CCAssignToStack&lt;4, 4&gt;</pre>			<p>The first parameter is the size of a stack slot in bytes, while the second is the alignment. Since it is a catch-all rule, no condition is used.</p>&#13;
			<h2 id="_idParaDest-186"><a id="_idTextAnchor196"/>Implementing the rules of the calling convention</h2>&#13;
			<p>For a calling convention, there are also more predefined conditions and actions to note. For example, <code>CCIfInReg</code> checks if the argument is marked with the <code>inreg</code> attribute, and <code>CCIfVarArg</code> evaluates to <code>true</code> if the function has a variable argument list. The <code>CCPromoteToType</code> action promotes the type of the argument to a larger one, and the <code>CCPassIndirect</code> action indicates that the parameter value should be stored on the stack and <a id="_idIndexMarker810"/>that a pointer to that storage is passed as a normal argument. All of the predefined conditions and actions can be referenced within <code>llvm/include/llvm/Target/TargetCallingConv.td</code>.</p>&#13;
			<p>Both the parameters and the return value are defined in this way. We will put the definition into the <code>M88kCallingConv.td</code> file:</p>&#13;
			<ol>&#13;
				<li>First, we must define the rules for the parameters. To simplify the coding, we’ll only consider 32-bit values:<pre class="source-code">&#13;
def CC_M88k : CallingConv&lt;[&#13;
  CCIfType&lt;[i8, i16], CCPromoteToType&lt;i32&gt;&gt;,&#13;
  CCIfType&lt;[i32,f32],&#13;
        CCAssignToReg&lt;[R2, R3, R4, R5, R6, R7, R8, R9]&gt;&gt;,&#13;
  CCAssignToStack&lt;4, 4&gt;&#13;
]&gt;;</pre></li>				<li>After that, we must define the rules for return values:<pre class="source-code">&#13;
def RetCC_M88k : CallingConv&lt;[&#13;
  CCIfType&lt;[i32], CCAssignToReg&lt;[R2]&gt;&gt;&#13;
]&gt;;</pre></li>				<li>Finally, the sequence of callee saved registers must be defined. Note that we use the <code>sequence</code> operator to generate a sequence of registers, instead of writing them down:<pre class="source-code">&#13;
def CSR_M88k :&#13;
    CalleeSavedRegs&lt;(add R1, R30,&#13;
                         (sequence "R%d", 25,  14))&gt;;</pre></li>			</ol>&#13;
			<p>The benefit of defining the rules for the calling convention in the target description is that they can <a id="_idIndexMarker811"/>be reused for various instruction selection methods. We’ll look at instruction selection via the selection DAG next.</p>&#13;
			<h1 id="_idParaDest-187"><a id="_idTextAnchor197"/>Instruction selection via the selection DAG</h1>&#13;
			<p>Creating <a id="_idIndexMarker812"/>machine instructions from the IR is a very important <a id="_idIndexMarker813"/>task in the backend. One common way to implement it is to utilize a DAG:</p>&#13;
			<ol>&#13;
				<li>First, we must create a DAG from the IR. A node of the DAG represents an operation and the edges model control and data flow dependencies.</li>&#13;
				<li>Next, we must loop over the DAG and legalize the types and operations. Legalization means that we only use types and operations that are supported by the hardware. This requires us to create a configuration that tells the framework how to deal with non-legal types and operations. For instance, a 64-bit value could be split into two 32-bit values, the multiplication of two 64-bit values could be changed to a library call, and a complex operation such as count population could be expanded into a sequence of simpler operations for calculating this value.</li>&#13;
				<li>After, pattern matching is utilized to match nodes in the DAG and replace them with machine instructions. We encountered such a pattern in the previous chapter.</li>&#13;
				<li>Finally, an instruction scheduler reorders the machine instructions into a more performant order.</li>&#13;
			</ol>&#13;
			<p>This is just a high-level description of the instruction selection process via the selection DAG. If you are interested in more details, you can find it in the <em class="italic">The LLVM Target-Independent Code Generator</em> user guide at <a href="https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process">https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process</a>.</p>&#13;
			<p>Furthermore, all backends in LLVM implement the selection DAG. The main advantage is that it generates performant code. However, this comes at a cost: creating the DAG is expensive, and it slows down compilation speed. Therefore, this has prompted LLVM developers to look for alternative and more desirable approaches. Some targets implement instruction selection via FastISel, which is only used for non-optimized code. It can quickly generate code, but the generated code is inferior to the one generated by the selection DAG method. In addition, it adds a whole new instruction selection method, which doubles <a id="_idIndexMarker814"/>the testing effort. Another <a id="_idIndexMarker815"/>method is also used for instruction selection called global instruction selection, which we’ll examine later in the <em class="italic">Global instruction </em><em class="italic">selection</em> section.</p>&#13;
			<p>In this chapter, we aim to implement enough of the backend to lower a simple IR function, like this:</p>&#13;
			<pre class="source-code">&#13;
define i32 @f1(i32 %a, i32 %b) {&#13;
  %res = and i32 %a, %b&#13;
  ret i32 %res&#13;
}</pre>			<p>Moreover, for a real backend, much more code is needed, and we must point out what needs to be added for greater functionality.</p>&#13;
			<p>To implement instruction selection via the selection DAG, we need to create two new classes: <code>M88kISelLowering</code> and <code>M88kDAGToDAGISel</code>. The former class is used to customize the DAG, for example, by defining which types are legal. It also contains the code to support the lowering of functions and function calls. The latter class performs DAG transformations, and the implementation is mostly generated from the target description.</p>&#13;
			<p>There are several classes within the backend that we will be adding implementation to, and <em class="italic">Figure 12</em><em class="italic">.1</em> depicts the high-level relationship between the primary classes that we will be developing further:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B19561_12_1.jpg" alt="Figure 12.1 – Relationship between the main classes" width="970" height="794"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Relationship between the main classes</p>&#13;
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Implementing DAG lowering – handling legal types and setting operations</h2>&#13;
			<p>Let’s <a id="_idIndexMarker816"/>implement the <code>M88kISelLowering</code> class, which is stored in <code>M88kISelLowering.cpp</code> file, first. The constructor configures the legal types and operations:</p>&#13;
			<ol>&#13;
				<li>The constructor takes references to the <code>TargetMachine</code> and <code>M88kSubtarget</code> classes as parameters. The <code>TargetMachine</code> class is responsible for the general configuration of the target, for example, which passes need to run. An LLVM backend usually targets a CPU family, and the <code>M88kSubtarget</code> class describes the characteristics of the chosen CPU. We’ll look at both classes later in this chapter:<pre class="source-code">&#13;
M88kTargetLowering::M88kTargetLowering(&#13;
    const TargetMachine &amp;TM, const M88kSubtarget &amp;STI)&#13;
    : TargetLowering(TM), Subtarget(STI) {</pre></li>				<li>The first action is to declare which machine value type uses which register class. Remember that the register classes are generated from the target description. Here, we only handle 32-bit values:<pre class="source-code">&#13;
  addRegisterClass(MVT::i32, &amp;M88k::GPRRegClass);</pre></li>				<li>After adding all register classes, we must compute the derived properties of those <a id="_idIndexMarker817"/>register classes. We need to query the sub-target for register information, which is mostly generated from the target description:<pre class="source-code">&#13;
computeRegisterProperties(Subtarget.getRegisterInfo());</pre></li>				<li>Next, we must declare which register contains the stack pointer:<pre class="source-code">&#13;
  setStackPointerRegisterToSaveRestore(M88k::R31);</pre></li>				<li>Boolean values are represented differently on different platforms. For our target, we will declare that a Boolean value is stored in bit <code>0</code>; the other bits are cleared:<pre class="source-code">&#13;
  setBooleanContents(ZeroOrOneBooleanContent);</pre></li>				<li>After, we set the alignment of functions. The minimal function alignment is the alignment that is required for correct execution. In addition, we give the preferred alignment:<pre class="source-code">&#13;
  setMinFunctionAlignment(Align(4));&#13;
  setPrefFunctionAlignment(Align(4));</pre></li>				<li>Finally, we declare which operations are legal. In the previous chapter, we only defined three logical instructions, and they are legal for 32-bit values:<pre class="source-code">&#13;
  setOperationAction(ISD::AND, MVT::i32, Legal);&#13;
  setOperationAction(ISD::OR, MVT::i32, Legal);&#13;
  setOperationAction(ISD::XOR, MVT::i32, Legal);</pre></li>				<li>There are a couple of other actions we can use besides <code>Legal</code>. <code>Promote</code> widens the type, <code>Expand</code> replaces the operation with other operations, <code>LibCall</code> lowers the operation to a library call, and <code>Custom</code> calls the <code>LowerOperation()</code> hook method, which lets you implement your own custom handling. For example, in the M88k architecture, there is no count population instruction, so we request that this operation be expanded into other operations:<pre class="source-code">&#13;
  setOperationAction(ISD::CTPOP, MVT::i32, Expand);&#13;
}</pre></li>			</ol>&#13;
			<p>Now, let’s review some points to emphasize the connection between the definitions we made so far. In the target description mentioned in the <code>M88kInstrInfo.td</code> file, we defined a <a id="_idIndexMarker818"/>machine instruction with the <code>and</code> mnemonic, and we also attached a pattern to it. If we expand the <code>AND</code> multiclass record, and only look at the instruction using three registers, we get the TableGen definition:</p>&#13;
			<pre class="source-code">&#13;
let isCommutable = 1 in&#13;
  def ANDrr : F_LR&lt;0b01000, Func, /*comp=*/0b0, "and",&#13;
                   [(set i32:$rd,&#13;
                       (and GPROpnd:$rs1, GPROpnd:$rs2))]&gt;;</pre>			<p>The <code>"and"</code> string is the mnemonic of the instruction. In C++ source code, we use <code>M88k::ANDrr</code> to refer to this instruction. Inside the pattern, the DAG <code>and</code> node type is used. In C++, it is named <code>ISD::AND</code>, and we used it in the call to the <code>setOperationAction()</code> method. During instruction selection, a DAG node of the <code>and</code> type is replaced by the <code>M88k::ANDrr</code> instruction if the pattern matches, which includes the input operands. Thus, when we develop instruction selection, the most important task is for us to define the correct legalization actions and attach the patterns to the instruction definitions.</p>&#13;
			<h2 id="_idParaDest-189"><a id="_idTextAnchor199"/>Implementing DAG lowering – lowering formal arguments</h2>&#13;
			<p>Let’s turn to another important task performed by the <code>M88kISelLowering</code> class. We defined <a id="_idIndexMarker819"/>the rules for the calling convention in the previous section, but we also need to map the physical registers and memory locations to virtual registers used in the DAG. For arguments, this is done in the <code>LowerFormalArguments()</code> method; return values are handled in the <code>LowerReturn()</code> method. First, we must handle the arguments:</p>&#13;
			<ol>&#13;
				<li>We’ll begin by including the generated source:<pre class="source-code">&#13;
#include "M88kGenCallingConv.inc"</pre></li>				<li>The <code>LowerFormalArguments()</code> method takes several parameters. The <code>SDValue</code> class denotes a value associated with a DAG node and is often used when dealing with the DAG. The first parameter, <code>Chain</code>, represents the control flow, and the possible updated <code>Chain</code> is also the return value of the method. The <code>CallConv</code> parameter identifies the used calling convention, and <code>IsVarArg</code> is set to <code>true</code> if a variable argument list is part of the parameters. The arguments that need to be handled are passed in the <code>Ins</code> parameter, together with their location in the <code>DL</code> parameter. The <code>DAG</code> parameter gives us access to the <code>SelectionDAG</code> class. Lastly, the result of the mapping will be stored in the <code>InVals</code> vector argument:<pre class="source-code">&#13;
SDValue M88kTargetLowering::LowerFormalArguments(&#13;
    SDValue Chain, CallingConv::ID CallConv,&#13;
    bool IsVarArg,&#13;
    const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins,&#13;
    const SDLoc &amp;DL, SelectionDAG &amp;DAG,&#13;
    SmallVectorImpl&lt;SDValue&gt; &amp;InVals) const {</pre></li>				<li>Our first action is to retrieve references to the machine function and the machine register information:<pre class="source-code">&#13;
  MachineFunction &amp;MF = DAG.getMachineFunction();&#13;
  MachineRegisterInfo &amp;MRI = MF.getRegInfo();</pre></li>				<li>Next, we must call the generated code. We need to instantiate an object of the <code>CCState</code> class. The <code>CC_M88k</code> parameter value that’s used in the call to the <code>AnalyzeFormalArguments()</code> method is the name of the calling convention we used in the target description. The result is stored in the <code>ArgLocs</code> vector:<pre class="source-code">&#13;
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;&#13;
  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs,&#13;
                 *DAG.getContext());&#13;
  CCInfo.AnalyzeFormalArguments(Ins, CC_M88k);</pre></li>				<li>Once the <a id="_idIndexMarker820"/>locations of the arguments have been determined, we need to map them to the DAG. Therefore, we must loop over all locations:<pre class="source-code">&#13;
  for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {&#13;
    SDValue ArgValue;&#13;
    CCValAssign &amp;VA = ArgLocs[I];&#13;
    EVT LocVT = VA.getLocVT();</pre></li>				<li>The mapping depends on the determined location. First, we handle arguments assigned to registers. The goal is to copy the physical register to a virtual register. To do so, we need to determine the correct register class. Since we’re only handling 32-bit values, it is easy to do this:<pre class="source-code">&#13;
    if (VA.isRegLoc()) {&#13;
      const TargetRegisterClass *RC;&#13;
      switch (LocVT.getSimpleVT().SimpleTy) {&#13;
      default:&#13;
        llvm_unreachable("Unexpected argument type");&#13;
      case MVT::i32:&#13;
        RC = &amp;M88k::GPRRegClass;&#13;
        break;&#13;
      }</pre></li>				<li>With the register class stored in the <code>RC</code> variable, we can create the virtual register and <a id="_idIndexMarker821"/>copy the value. We also need to declare the physical register as a live-in:<pre class="source-code">&#13;
      Register VReg = MRI.createVirtualRegister(RC);&#13;
      MRI.addLiveIn(VA.getLocReg(), VReg);&#13;
      ArgValue =&#13;
          DAG.getCopyFromReg(Chain, DL, VReg, LocVT);</pre></li>				<li>In the definition of the calling convention, we added the rule that 8-bit and 16-bit values should be promoted to 32-bit, and we need to ensure the promotion here. To do so, a DAG node must be inserted, which makes sure that the value is promoted. After, the value is truncated to the right size. Note that we pass the value of <code>ArgValue</code> as an operand to the DAG node and store the result in the same variable:<pre class="source-code">&#13;
      if (VA.getLocInfo() == CCValAssign::SExt)&#13;
        ArgValue = DAG.getNode(&#13;
            ISD::AssertSext, DL, LocVT, ArgValue,&#13;
            DAG.getValueType(VA.getValVT()));&#13;
      else if (VA.getLocInfo() == CCValAssign::ZExt)&#13;
        ArgValue = DAG.getNode(&#13;
            ISD::AssertZext, DL, LocVT, ArgValue,&#13;
            DAG.getValueType(VA.getValVT()));&#13;
      if (VA.getLocInfo() != CCValAssign::Full)&#13;
        ArgValue = DAG.getNode(ISD::TRUNCATE, DL,&#13;
                               VA.getValVT(), ArgValue);</pre></li>				<li>Lastly, we finish handling the register arguments by adding the DAG node to the result vector:<pre class="source-code">&#13;
      InVals.push_back(ArgValue);&#13;
    }</pre></li>				<li>The other <a id="_idIndexMarker822"/>possible location for a parameter is on the stack. However, we didn’t define any load and store instructions, so we cannot handle this case yet. This ends the loop over all argument locations:<pre class="source-code">&#13;
    } else {&#13;
      llvm_unreachable("Not implemented");&#13;
    }&#13;
  }</pre></li>				<li>After that, we may need to add code to handle variable argument lists. Again, we have added some code to remind us that we have not implemented it:<pre class="source-code">&#13;
  assert(!IsVarArg &amp;&amp; "No<a id="_idTextAnchor200"/>t implemented");</pre></li>				<li>Finally, we must return the <code>Chain</code> argument:<pre class="source-code">&#13;
  return Chain;&#13;
}</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-190"><a id="_idTextAnchor201"/>Implementing DAG lowering – lowering return values</h2>&#13;
			<p>The return <a id="_idIndexMarker823"/>values are handled similarly. However, we must extend the target description for them. First, we need to define a new DAG node type called <code>RET_GLUE</code>. This DAG node type is used to glue the return values together, which prevents them from being rearranged, for example, by the instruction scheduler. The definition in <code>M88kInstrInfo.td</code> is as follows:</p>&#13;
			<pre class="source-code">&#13;
def retglue : SDNode&lt;"M88kISD::RET_GLUE", SDTNone,&#13;
                 [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]&gt;;</pre>			<p>In the same file, we also define a pseudo-instruction to represent a return from a function call, which will be selected for a <code>RET_GLUE</code> node:</p>&#13;
			<pre class="source-code">&#13;
let isReturn = 1, isTerminator = 1, isBarrier = 1,&#13;
    AsmString = "RET" in&#13;
  def RET : Pseudo&lt;(outs), (ins), [(retglue)]&gt;;</pre>			<p>We will <a id="_idIndexMarker824"/>expand this pseudo-instruction when we generate the output.</p>&#13;
			<p>With these definitions in place, we can implement the <code>LowerReturn()</code> method:</p>&#13;
			<ol>&#13;
				<li>The parameters are the same as for <code>LowerFormalArguments()</code>, only the order is slightly different:<pre class="source-code">&#13;
SDValue M88kTargetLowering::LowerReturn(&#13;
    SDValue Chain, CallingConv::ID CallConv,&#13;
    bool IsVarArg,&#13;
    const SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs,&#13;
    const SmallVectorImpl&lt;SDValue&gt; &amp;OutVals,&#13;
    const SDLoc &amp;DL, SelectionDAG &amp;DAG) const {</pre></li>				<li>First, we call the generated code, this time using the <code>RetCC_M88k</code> calling convention:<pre class="source-code">&#13;
  SmallVector&lt;CCValAssign, 16&gt; RetLocs;&#13;
  CCState RetCCInfo(CallConv, IsVarArg,&#13;
                    DAG.getMachineFunction(), RetLocs,&#13;
                    *DAG.getContext());&#13;
  RetCCInfo.AnalyzeReturn(Outs, RetCC_M88k);</pre></li>				<li>Then, we loop over the locations again. With the simple definition of the calling convention we currently have, this loop will be executed once at most. However, this would change if we would add support for returning 64-bit values, which need to be returned in two registers:<pre class="source-code">&#13;
  SDValue Glue;&#13;
  SmallVector&lt;SDValue, 4&gt; RetOps(1, Chain);&#13;
  for (unsigned I = 0, E = RetLocs.size(); I != E; ++I) {&#13;
    CCValAssign &amp;VA = RetLocs[I];</pre></li>				<li>After, we copy <a id="_idIndexMarker825"/>the return values into the physical registers assigned to the return value. This is mostly similar to handling the arguments, with the exception that the values are glued together using the <code>Glue</code> variable:<pre class="source-code">&#13;
    Register Reg = VA.getLocReg();&#13;
    Chain = DAG.getCopyToReg(Chain, DL, Reg, OutVals[I],&#13;
                             Glue);&#13;
    Glue = Chain.getValue(1);&#13;
    RetOps.push_back(&#13;
        DAG.getRegister(Reg, VA.getLocVT()));&#13;
  }</pre></li>				<li>The return value is the chain and the glued register copy operations. The latter is only returned if there is a value to return:<pre class="source-code">&#13;
  RetOps[0] = Chain;&#13;
  if (Glue.getNode())&#13;
    RetOps.push_back(Glue);</pre></li>				<li>Finally, we construct a DAG node of the <code>RET_GLUE</code> type, passing in the necessary values:<pre class="source-code">&#13;
  return DAG.getNode(M88kISD::RET_GLUE, DL, MVT::Other,&#13;
                     RetOps);&#13;
}</pre></li>			</ol>&#13;
			<p>Congratulations! With these <a id="_idIndexMarker826"/>definitions, the foundation has been laid for instruction selection.</p>&#13;
			<h2 id="_idParaDest-191"><a id="_idTextAnchor202"/>Implementing DAG-to-DAG transformations within instruction selection</h2>&#13;
			<p>One crucial <a id="_idIndexMarker827"/>part is still missing: we need to define the pass that performs the DAG transformations defined in the target descriptions. The class is called <code>M88kDAGToDAGISel</code> and is stored in the <code>M88kISelDAGToDAG.cpp</code> file. Most of the class is generated, but we still need to add some code:</p>&#13;
			<ol>&#13;
				<li>We’ll begin by defining the debug type and providing a descriptive name for the pass:<pre class="source-code">&#13;
#define DEBUG_TYPE "m88k-isel"&#13;
#define PASS_NAME&#13;
            "M88k DAG-&gt;DAG Pattern Instruction Selection"</pre></li>				<li>Then, we must declare the class inside an anonymous namespace. We will only override the <code>Select()</code> method; the other code is generated and included in the body of the class:<pre class="source-code">&#13;
class M88kDAGToDAGISel : public SelectionDAGISel {&#13;
public:&#13;
  static char ID;&#13;
  M88kDAGToDAGISel(M88kTargetMachine &amp;TM,&#13;
                   CodeGenOpt::Level OptLevel)&#13;
      : SelectionDAGISel(ID, TM, OptLevel) {}&#13;
  void Select(SDNode *Node) override;&#13;
#include "M88kGenDAGISel.inc"&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>After, we must add the code to initialize the pass. The LLVM backends still use the legacy pass manager, and the setup differs from the pass manager used for IR transformations. The static member <code>ID</code> value is used to identify the pass. Initializing <a id="_idIndexMarker828"/>the pass can be implemented using the <code>INITIALIZE_PASS</code> macro, which expands to C++ code. We must also add a factory method to create an instance of the pass:<pre class="source-code">&#13;
char M88kDAGToDAGISel::ID = 0;&#13;
INITIALIZE_PASS(M88kDAGToDAGISel, DEBUG_TYPE, PASS_NAME,&#13;
                false, false)&#13;
FunctionPass *&#13;
llvm::createM88kISelDag(M88kTargetMachine &amp;TM,&#13;
                        CodeGenOpt::Level OptLevel) {&#13;
  return new M88kDAGToDAGISel(TM, OptLevel);&#13;
}</pre></li>				<li>Finally, we must implement the <code>Select()</code> method. For now, we only call the generated code. However, if we encounter a complex transformation that we cannot express as a DAG pattern, then we can add our own code to perform the transformation before calling the generated code:<pre class="source-code">&#13;
void M88kDAGToDAGISel::Select(SDNode *Node) {&#13;
  SelectCode(Node);&#13;
}</pre></li>			</ol>&#13;
			<p>With that, we have implemented the instruction selection. However, we still need to add some <a id="_idIndexMarker829"/>support classes before we can do the first test. We’ll look at those classes in the next few sections.</p>&#13;
			<h1 id="_idParaDest-192"><a id="_idTextAnchor203"/>Adding register and instruction information</h1>&#13;
			<p>The target description captures most information about registers and instructions. To access <a id="_idIndexMarker830"/>that information, we must implement the <code>M88kRegisterInfo</code> and <code>M88kInstrInfo</code> classes. These classes also contain hooks that we can override to accomplish tasks that are too complex to express in the target description. Let’s begin with the <code>M88kRegisterInfo</code> class, which is declared in the <code>M88kRegisterInfo.h</code> file:</p>&#13;
			<ol>&#13;
				<li>The header file begins by including the code generated from the target description:<pre class="source-code">&#13;
#define GET_REGINFO_HEADER&#13;
#include "M88kGenRegisterInfo.inc"</pre></li>				<li>After that, we must declare the <code>M88kRegisterInfo</code> class in the <code>llvm</code> namespace. We only override a couple of methods:<pre class="source-code">&#13;
namespace llvm {&#13;
struct M88kRegisterInfo : public M88kGenRegisterInfo {&#13;
  M88kRegisterInfo();&#13;
  const MCPhysReg *getCalleeSavedRegs(&#13;
      const MachineFunction *MF) const override;&#13;
  BitVector getReservedRegs(&#13;
      const MachineFunction &amp;MF) const override;&#13;
  bool eliminateFrameIndex(&#13;
      MachineBasicBlock::iterator II, int SPAdj,&#13;
      unsigned FIOperandNum,&#13;
      RegScavenger *RS = nullptr) const override;&#13;
  Register getFrameRegister(&#13;
      const MachineFunction &amp;MF) const override;&#13;
};&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<p>The definition <a id="_idIndexMarker831"/>of the class is stored in the <code>M88kRegisterInfo.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>Again, the film begins with including the code generated from the target description:<pre class="source-code">&#13;
#define GET_REGINFO_TARGET_DESC&#13;
#include "M88kGenRegisterInfo.inc"</pre></li>				<li>The constructor initializes the superclass, passing the register holding the return address as a parameter:<pre class="source-code">&#13;
M88kRegisterInfo::M88kRegisterInfo()&#13;
    : M88kGenRegisterInfo(M88k::R1) {}</pre></li>				<li>Then, we implement the method that returns the list of callee-saved registers. We defined the list in the target description, and we only return that list:<pre class="source-code">&#13;
const MCPhysReg *M88kRegisterInfo::getCalleeSavedRegs(&#13;
    const MachineFunction *MF) const {&#13;
  return CSR_M88k_SaveList;&#13;
}</pre></li>				<li>After, we deal with the reserved registers. The reserved registers depend on the platform and the hardware. The <code>r0</code> register contains a constant value of <code>0</code>, so we treat it <a id="_idIndexMarker832"/>as a reserved register. The <code>r28</code> and <code>r29</code> registers are always reserved for use by a linker. Lastly, the <code>r31</code> register is used as a stack pointer. This list may depend on the function, and it cannot be generated due to this dynamic behavior:<pre class="source-code">&#13;
BitVector M88kRegisterInfo::getReservedRegs(&#13;
    const MachineFunction &amp;MF) const {&#13;
  BitVector Reserved(getNumRegs());&#13;
  Reserved.set(M88k::R0);&#13;
  Reserved.set(M88k::R28);&#13;
  Reserved.set(M88k::R29);&#13;
  Reserved.set(M88k::R31);&#13;
  return Reserved;&#13;
}</pre></li>				<li>If a frame register is required, then <code>r30</code> is used. Please note that our code does not support creating a frame yet. If the function requires a frame, then <code>r30</code> must also be marked as reserved in the <code>getReservedRegs()</code> method. However, we must implement this method because it is declared pure virtual in the superclass:<pre class="source-code">&#13;
Register M88kRegisterInfo::getFrameRegister(&#13;
    const MachineFunction &amp;MF) const {&#13;
  return M88k::R30;&#13;
}</pre></li>				<li>Similarly, we need to implement the <code>eliminateFrameIndex()</code> method because it <a id="_idIndexMarker833"/>is declared <em class="italic">pure virtual</em>. It is called to replace a frame index in an operand with the correct value to use to address the value on the stack:<pre class="source-code">&#13;
bool M88kRegisterInfo::eliminateFrameIndex(&#13;
    MachineBasicBlock::iterator MI, int SPAdj,&#13;
    unsigned FIOperandNum, RegScavenger *RS) const {&#13;
  return false;&#13;
}</pre></li>			</ol>&#13;
			<p>The <code>M88kInstrInfo</code> class has <a id="_idIndexMarker834"/>many hook methods we can override to accomplish special tasks, for example, for branch analysis and rematerialization. For now, we’re only overriding the <code>expandPostRAPseudo()</code> method, in which we expand the pseudo-instruction RET. Let’s begin with the header file, <code>M88kInstrInfo.h</code>:</p>&#13;
			<ol>&#13;
				<li>The header file begins with including the generated code:<pre class="source-code">&#13;
#define GET_INSTRINFO_HEADER&#13;
#include "M88kGenInstrInfo.inc"</pre></li>				<li>The <code>M88kInstrInfo</code> class derives from the generated <code>M88kGenInstrInfo</code> class. Besides overriding the <code>expandPostRAPseudo()</code> method, the only other addition is that this class owns an instance of the previously defined class, <code>M88kRegisterInfo</code>:<pre class="source-code">&#13;
namespace llvm {&#13;
class M88kInstrInfo : public M88kGenInstrInfo {&#13;
  const M88kRegisterInfo RI;&#13;
  [[maybe_unused]] M88kSubtarget &amp;STI;&#13;
  virtual void anchor();&#13;
public:&#13;
  explicit M88kInstrInfo(M88kSubtarget &amp;STI);&#13;
  const M88kRegisterInfo &amp;getRegisterInfo() const {&#13;
    return RI;&#13;
  }&#13;
  bool&#13;
  expandPostRAPseudo(MachineInstr &amp;MI) const override;&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<p>The implementation <a id="_idIndexMarker835"/>is stored in the <code>M88kInstrInfo.cpp</code> class:</p>&#13;
			<ol>&#13;
				<li>Like the header file, the implementation begins with including the generated code:<pre class="source-code">&#13;
#define GET_INSTRINFO_CTOR_DTOR&#13;
#define GET_INSTRMAP_INFO&#13;
#include "M88kGenInstrInfo.inc"</pre></li>				<li>Then, we define the <code>anchor()</code> method, which is used to pin the vtable to this file:<pre class="source-code">&#13;
void M88kInstrInfo::anchor() {}</pre></li>				<li>Finally, we expand <code>RET</code> in the <code>expandPostRAPseudo()</code> method. As its name suggests, this method is invoked after the register allocator runs and is intended to expand the pseudo-instruction, which may still be mixed with the machine code. If the opcode of the machine instruction, <code>MI</code>, is the pseudo-instruction, <code>RET</code>, we must insert the <code>jmp %r1</code> jump instruction, which is the instruction to exit a function. Then, we copy all implicit operands that represent the values to return and we delete the pseudo instruction. If we need other pseudo-instructions <a id="_idIndexMarker836"/>during code generation, then we can extend this function to expand them here too:<pre class="source-code">&#13;
bool M88kInstrInfo::expandPostRAPseudo(&#13;
    MachineInstr &amp;MI) const {&#13;
  MachineBasicBlock &amp;MBB = *MI.getParent();&#13;
  switch (MI.getOpcode()) {&#13;
  default:&#13;
    return false;&#13;
  case M88k::RET: {&#13;
    MachineInstrBuilder MIB =&#13;
        BuildMI(MBB, &amp;MI, MI.getDebugLoc(),&#13;
                get(M88k::JMP))&#13;
            .addReg(M88k::R1, RegState::Undef);&#13;
    for (auto &amp;MO : MI.operands()) {&#13;
      if (MO.isImplicit())&#13;
        MIB.add(MO);&#13;
    }&#13;
    break;&#13;
  }&#13;
  }&#13;
  MBB.erase(MI);&#13;
  return true;&#13;
}</pre></li>			</ol>&#13;
			<p>Both classes <a id="_idIndexMarker837"/>have minimal implementations. If you continue to develop the target, then many more methods need to be overridden. It is worth reading the comments in the <code>TargetInstrInfo</code> and <code>TargetRegisterInfo</code> base classes, which you can find in the <code>llvm/include/llvm/CodeGen</code> directory.</p>&#13;
			<p>We still need more classes to get the instruction selection running. Next, we’ll look at frame lowering.</p>&#13;
			<h1 id="_idParaDest-193"><a id="_idTextAnchor204"/>Putting an empty frame lowering in place</h1>&#13;
			<p>The binary interface of a platform not only defines how parameters are passed. It also includes how <a id="_idIndexMarker838"/>a stack frame is laid out: in which places are local variables stored, where registers are spilled to, and so on. Often, a special instruction sequence is <a id="_idIndexMarker839"/>required at the beginning and end of a function, called the <code>TargetFrameLowering</code> is available. The easy solution is to provide the <code>M88kFrameLowering</code> class with an empty implementation.</p>&#13;
			<p>The declaration of the class is in the <code>M88kFrameLowering.h</code> file. All we must do here is override the pure virtual functions:</p>&#13;
			<pre class="source-code">&#13;
namespace llvm {&#13;
class M88kFrameLowering : public TargetFrameLowering {&#13;
public:&#13;
  M88kFrameLowering();&#13;
  void&#13;
  emitPrologue(MachineFunction &amp;MF,&#13;
               MachineBasicBlock &amp;MBB) const override;&#13;
  void&#13;
  emitEpilogue(MachineFunction &amp;MF,&#13;
               MachineBasicBlock &amp;MBB) const override;&#13;
  bool hasFP(const MachineFunction &amp;MF) const override;&#13;
};&#13;
}</pre>			<p>The implementation, which is stored in the <code>M88kFrameLowering.cpp</code> file, provides some basic details about stack frames in the constructor. The stack grows downwards, to smaller addresses, and is aligned on 8-byte boundaries. When a function is called, the local variables <a id="_idIndexMarker841"/>are stored directly below the stack pointer of the calling function, so the offset of the local area is <code>0</code>. Even during a function call, the stack should remain aligned at an 8-byte boundary. The last parameter implies that the stack cannot be realigned. The other functions just have an empty implementation:</p>&#13;
			<pre class="source-code">&#13;
M88kFrameLowering::M88kFrameLowering()&#13;
    : TargetFrameLowering(&#13;
          TargetFrameLowering::StackGrowsDown, Align(8),&#13;
          0, Align(8), false /* StackRealignable */) {}&#13;
void M88kFrameLowering::emitPrologue(&#13;
    MachineFunction &amp;MF, MachineBasicBlock &amp;MBB) const {}&#13;
void M88kFrameLowering::emitEpilogue(&#13;
    MachineFunction &amp;MF, MachineBasicBlock &amp;MBB) const {}&#13;
bool M88kFrameLowering::hasFP(&#13;
    const MachineFunction &amp;MF) const { return false; }</pre>			<p>Of course, as soon <a id="_idIndexMarker842"/>as our implementation grows, this class will be one of the first that needs to be fully implemented.</p>&#13;
			<p>Before we can put all the pieces together, we need to implement the assembly printer, which is used to emit machine instructions.</p>&#13;
			<h1 id="_idParaDest-194"><a id="_idTextAnchor205"/>Emitting machine instructions</h1>&#13;
			<p>The instruction <a id="_idIndexMarker843"/>selection creates machine instructions, represented by the <code>MachineInstr</code> class, from LLVM IR. But this is not the end. An instance of the <code>MachineInstr</code> class still carries additional information, such as labels or flags. To emit an instruction via the machine code component, we need to lower the instances of <code>MachineInstr</code> to instances of <code>MCInst</code>. By doing this, the machine code component provides the functionality to write instructions into object files or print them as assembler text. The <code>M88kAsmPrinter</code> class is responsible for emitting a whole compilation unit. Lowering an instruction is delegated to the <code>M88kMCInstLower</code> class.</p>&#13;
			<p>The assembly printer is the last pass to run in a backend. Its implementation is stored in the <code>M88kAsmPrinter.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>The declaration of the <code>M88kAsmPrinter</code> class is in an anonymous namespace. Besides the constructor, we only override the <code>getPassName()</code> function, which returns the name of the pass as a human-readable string, and the <code>emitInstruction()</code> function:<pre class="source-code">&#13;
namespace {&#13;
class M88kAsmPrinter : public AsmPrinter {&#13;
public:&#13;
  explicit M88kAsmPrinter(&#13;
      TargetMachine &amp;TM,&#13;
      std::unique_ptr&lt;MCStreamer&gt; Streamer)&#13;
      : AsmPrinter(TM, std::move(Streamer)) {}&#13;
  StringRef getPassName() const override {&#13;
    return "M88k Assembly Printer";&#13;
  }&#13;
  void emitInstruction(const MachineInstr *MI) override;&#13;
};&#13;
} // end of anonymous namespace</pre></li>				<li>Like many <a id="_idIndexMarker844"/>other classes, we have to register our assembly printer in the target registry:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kAsmPrinter() {&#13;
  RegisterAsmPrinter&lt;M88kAsmPrinter&gt; X(&#13;
      getTheM88kTarget());&#13;
}</pre></li>				<li>The <code>emitInstruction()</code> method is responsible for emitting the machine instruction, <code>MI</code>, to the output stream. In our implementation, we delegate the lowering of the instruction to the <code>M88kMCInstLower</code> class:<pre class="source-code">&#13;
void M88kAsmPrinter::emitInstruction(&#13;
    const MachineInstr *MI) {&#13;
  MCInst LoweredMI;&#13;
  M88kMCInstLower Lower(MF-&gt;getContext(), *this);&#13;
  Lower.lower(MI, LoweredMI);&#13;
  EmitToStreamer(*OutStreamer, LoweredMI);&#13;
}</pre></li>			</ol>&#13;
			<p>This is already the full implementation. The base class, <code>AsmPrinter</code>, provides many useful hooks you can override. For example, the <code>emitStartOfAsmFile()</code> method is called before <a id="_idIndexMarker845"/>anything is emitted, and <code>emitEndOfAsmFile()</code> is called after everything is emitted. These methods can emit target-specific data or code at the beginning and the end of a file. Similarly, the <code>emitFunctionBodyStart()</code> and <code>emitFunctionBodyEnd()</code> methods are called before and after a function body is emitted. Read the comments in the <code>llvm/include/llvm/CodeGen/AsmPrinter.h</code> file to understand what can be customized.</p>&#13;
			<p>The <code>M88kMCInstLower</code> class lowers operands and instructions, and our implementation contains two methods for that purpose. The declaration is in the <code>M88kMCInstLower.h</code> file:</p>&#13;
			<pre class="source-code">&#13;
class LLVM_LIBRARY_VISIBILITY M88kMCInstLower {&#13;
public:&#13;
  void lower(const MachineInstr *MI, MCInst &amp;OutMI) const;&#13;
  MCOperand lowerOperand(const MachineOperand &amp;MO) const;&#13;
};</pre>			<p>The definition goes into the <code>M88kMCInstLower.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>To lower <code>MachineOperand</code> to <code>MCOperand</code>, we need to check the operand type. Here, we only handle registers and immediates by creating <code>MCOperand</code>-equivalent register and immediate values by supplying the original <code>MachineOperand</code> values. As soon as expressions are introduced as operands, this method needs to be enhanced:<pre class="source-code">&#13;
MCOperand M88kMCInstLower::lowerOperand(&#13;
    const MachineOperand &amp;MO) const {&#13;
  switch (MO.getType()) {&#13;
  case MachineOperand::MO_Register:&#13;
    return MCOperand::createReg(MO.getReg());&#13;
  case MachineOperand::MO_Immediate:&#13;
    return MCOperand::createImm(MO.getImm());&#13;
  default:&#13;
    llvm_unreachable("Operand type not handled");&#13;
  }&#13;
}</pre></li>				<li>The lowering <a id="_idIndexMarker846"/>of an instruction is similar. First, the opcode is copied, and then the operands are handled. An instance of <code>MachineInstr</code> can have implicit operands attached, which are not lowered, and we need to filter them:<pre class="source-code">&#13;
void M88kMCInstLower::lower(const MachineInstr *MI,&#13;
                            MCInst &amp;OutMI) const {&#13;
  OutMI.setOpcode(MI-&gt;getOpcode());&#13;
  for (auto &amp;MO : MI-&gt;operands()) {&#13;
    if (!MO.isReg() || !MO.isImplicit())&#13;
      OutMI.addOperand(lowerOperand(MO));&#13;
  }&#13;
}</pre></li>			</ol>&#13;
			<p>With that, we’ve implemented the assembly printer. Now, we need to bring all the pieces toget<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/>her. We’ll do this in the next section.</p>&#13;
			<h1 id="_idParaDest-195"><a id="_idTextAnchor208"/>Creating the target machine and the sub-target</h1>&#13;
			<p>So far, we’ve implemented the instruction selection classes and a couple of other classes. Now, we need <a id="_idIndexMarker847"/>to set up how our backend will work. Like the optimization pipeline, a backend is divided into passes. Configuring those passes is the main task of the <code>M88kTargetMachine</code> class. In addition, we need to specify which <a id="_idIndexMarker848"/>features are available for instruction selection. Usually, a platform is a family of CPUs, which all have a common set of instructions but differ by specific extensions. For example, some CPUs have vector instructions, while others do not. In LLVM IR, a function can have attributes attached that specify for which CPU this function should be compiled, or what features are available. In other words, each function could have a different configuration, which is captured in the <code>M88kSubTarget</code> class.</p>&#13;
			<h2 id="_idParaDest-196"><a id="_idTextAnchor209"/>Implementing M88kSubtarget</h2>&#13;
			<p>Let’s <a id="_idIndexMarker849"/>implement the <code>M88kSubtarget</code> class first. The declaration is stored in the <code>M88kSubtarget.h</code> class:</p>&#13;
			<ol>&#13;
				<li>Parts of <a id="_idIndexMarker850"/>the sub-target are generated from the target description, and we include those codes first:<pre class="source-code">&#13;
#define GET_SUBTARGETINFO_HEADER&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>				<li>Then, we declare the class, deriving it from the generated <code>M88kGenSubtargetInfo</code> class. The class owns a couple of previously defined classes – the instruction information, the target lowering class, and the frame lowering class:<pre class="source-code">&#13;
namespace llvm {&#13;
class StringRef;&#13;
class TargetMachine;&#13;
class M88kSubtarget : public M88kGenSubtargetInfo {&#13;
  virtual void anchor();&#13;
  Triple TargetTriple;&#13;
  M88kInstrInfo InstrInfo;&#13;
  M88kTargetLowering TLInfo;&#13;
  M88kFrameLowering FrameLowering;</pre></li>				<li>The sub-target <a id="_idIndexMarker851"/>is initialized with the target triple, the name of the CPU, and a feature string, as well as with the target <a id="_idIndexMarker852"/>machine. All these parameters describe the hardware for which our backend will generate code:<pre class="source-code">&#13;
public:&#13;
  M88kSubtarget(const Triple &amp;TT,&#13;
                const std::string &amp;CPU,&#13;
                const std::string &amp;FS,&#13;
                const TargetMachine &amp;TM);</pre></li>				<li>Next, we include the generated file again, this time for automatically defining getter methods for features defined in the target description:<pre class="source-code">&#13;
#define GET_SUBTARGETINFO_MACRO(ATTRIBUTE, DEFAULT,    \&#13;
                                GETTER)                \&#13;
  bool GETTER() const { return ATTRIBUTE; }&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>				<li>In addition, we need to declare the <code>ParseSubtargetFeatures()</code> method. The method itself is generated from the target description:<pre class="source-code">&#13;
  void ParseSubtargetFeatures(StringRef CPU,&#13;
                              StringRef TuneCPU,&#13;
                              StringRef FS);</pre></li>				<li>Next, we must <a id="_idIndexMarker853"/>add getter methods for the <a id="_idIndexMarker854"/>member variables:<pre class="source-code">&#13;
  const TargetFrameLowering *&#13;
  getFrameLowering() const override {&#13;
    return &amp;FrameLowering;&#13;
  }&#13;
  const M88kInstrInfo *getInstrInfo() const override {&#13;
    return &amp;InstrInfo;&#13;
  }&#13;
  const M88kTargetLowering *&#13;
  getTargetLowering() const override {&#13;
    return &amp;TLInfo;&#13;
  }</pre></li>				<li>Finally, we must add a getter method for the register information, which is owned by the instruction information class. This finishes the declaration:<pre class="source-code">&#13;
  const M88kRegisterInfo *&#13;
  getRegisterInfo() const override {&#13;
    return &amp;InstrInfo.getRegisterInfo();&#13;
  }&#13;
};&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<p>Next, we must implement the actual subtarget class. The implementation is stored in the <code>M88kSubtarget.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>Again, we begin the file by including the generated source:<pre class="source-code">&#13;
#define GET_SUBTARGETINFO_TARGET_DESC&#13;
#define GET_SUBTARGETINFO_CTOR&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>				<li>Then, we define the anchor method, which pins the vtable to this file:<pre class="source-code">&#13;
void M88kSubtarget::anchor() {}</pre></li>				<li>Finally, we define <a id="_idIndexMarker855"/>the constructor. Note that <a id="_idIndexMarker856"/>the generated class expected two CPU parameters: the first one for the instruction set, and the second one for scheduling. The use case here is that you want to optimize the code for the latest CPU but still be able to run the code on an older CPU. We do not support this feature and use the same CPU name for both parameters:<pre class="source-code">&#13;
M88kSubtarget::M88kSubtarget(const Triple &amp;TT,&#13;
                             const std::string &amp;CPU,&#13;
                             const std::string &amp;FS,&#13;
                             const TargetMachine &amp;TM)&#13;
    : M88kGenSubtargetInfo(TT, CPU, /*TuneCPU*/ CPU, FS),&#13;
      TargetTriple(TT), InstrInfo(*this),&#13;
      TLInfo(TM, *this), FrameLowering() {}</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-197"><a id="_idTextAnchor210"/>Implementing M88kTargetMachine – defining the definitions</h2>&#13;
			<p>Finally, we <a id="_idIndexMarker857"/>can implement the <code>M88kTargetMachine</code> class. This <a id="_idIndexMarker858"/>class holds all used sub-target instances. It also owns a subclass of <code>TargetLoweringObjectFile</code>, which provides details such as section names to the lowering process. Lastly, it creates the configuration of the passes that runs in this backend.</p>&#13;
			<p>The declaration in the <code>M88kTargetMachine.h</code> file is as follows:</p>&#13;
			<ol>&#13;
				<li>The <code>M88kTargetMachine</code> class derives from the <code>LLVMTargetMachine</code> class. The only members are an instance of <code>TargetLoweringObjectFile</code> and the sub-target map:<pre class="source-code">&#13;
namespace llvm {&#13;
class M88kTargetMachine : public LLVMTargetMachine {&#13;
  std::unique_ptr&lt;TargetLoweringObjectFile&gt; TLOF;&#13;
  mutable StringMap&lt;std::unique_ptr&lt;M88kSubtarget&gt;&gt;&#13;
      SubtargetMap;</pre></li>				<li>The parameters of the constructor completely describe the target configuration for which <a id="_idIndexMarker859"/>we will generate code. With the <code>TargetOptions</code> class, many details of the code generations <a id="_idIndexMarker860"/>can be controlled – for example, if floating-point multiply-and-add instructions can be used or not. Also, the relocation model, the code model, and the optimization level are passed to the constructor. Notably, the <code>JIT</code> parameter is set to true if the target machine is used for just-in-time compilation.<pre class="source-code">&#13;
public:&#13;
  M88kTargetMachine(const Target &amp;T, const Triple &amp;TT,&#13;
                    StringRef CPU, StringRef FS,&#13;
                    const TargetOptions &amp;Options,&#13;
                    std::optional&lt;Reloc::Model&gt; RM,&#13;
                    std::optional&lt;CodeModel::Model&gt; CM,&#13;
                    CodeGenOpt::Level OL, bool JIT);</pre></li>				<li>We also need to override some methods. The <code>getSubtargetImpl()</code> method <a id="_idIndexMarker861"/>returns the sub-target <a id="_idIndexMarker862"/>instance to use for the given function, and the <code>getObjFileLowering()</code> method just returns the member variable. In addition, we override the <code>createPassConfig()</code> method, which returns our configuration for the backend passes:<pre class="source-code">&#13;
  ~M88kTargetMachine() override;&#13;
  const M88kSubtarget *&#13;
  getSubtargetImpl(const Function &amp;) const override;&#13;
  TargetPassConfig *&#13;
  createPassConfig(PassManagerBase &amp;PM) override;&#13;
  TargetLoweringObjectFile *&#13;
  getObjFileLowering() const override {&#13;
    return TLOF.get();&#13;
  }&#13;
};&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-198"><a id="_idTextAnchor211"/>Implementing M88kTargetMachine – adding the implementation</h2>&#13;
			<p>The implementation of the class is stored in the <code>M88kTargetMachine.cpp</code> file. Please note <a id="_idIndexMarker863"/>that we created this file in <a href="B19561_11.xhtml#_idTextAnchor177"><em class="italic">Chapter 11</em></a>. Now, we <a id="_idIndexMarker864"/>will replace this file with a complete implementation:</p>&#13;
			<ol>&#13;
				<li>First, we must register the target machine. In addition, we must initialize the DAG-to-DAG pass via the initialization function we defined earlier:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTarget() {&#13;
  RegisterTargetMachine&lt;M88kTargetMachine&gt; X(&#13;
      getTheM88kTarget());&#13;
  auto &amp;PR = *PassRegistry::getPassRegistry();&#13;
  initializeM88kDAGToDAGISelPass(PR);&#13;
}</pre></li>				<li>Next, we must define the support function, <code>computeDataLayout()</code>. We talked about <a id="_idIndexMarker865"/>the data layout string in <a href="B19561_04.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Basics of IR Code Generation</em>. In this function, the data layout, as the backend, expects it to be defined. Since the data layout depends <a id="_idIndexMarker866"/>on hardware features, the triple, the name of the CPU, and the feature set string are passed to this function. We create the data layout string with the following components. The target is big-endian (<code>E</code>) and uses the <code>ELF</code> symbol mangling.<p class="list-inset">Pointers are 32-bit wide and 32-bit aligned. All scalar types are naturally aligned. The <code>MC88110</code> CPU has an extended register set and supports 80-bit wide floating points. If we were to support this special feature, then we’d need to add a check of the CPU name here and extend the string with the floating-point values accordingly. Next, we must state that all globals have a preferred alignment of 16-bit and that the <a id="_idTextAnchor212"/>hardware has only 32-bit registers:</p><pre class="source-code">&#13;
namespace {&#13;
std::string computeDataLayout(const Triple &amp;TT,&#13;
                              StringRef CPU,&#13;
                              StringRef FS) {&#13;
  std::string Ret;&#13;
  Ret += "E";&#13;
  Ret += DataLayout::getManglingComponent(TT);&#13;
  Ret += "-p:32:32:32";&#13;
  Ret += "-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64";&#13;
  Ret += "-f32:32:32-f64:64:64";&#13;
  Ret += "-a:8:16";&#13;
  Ret += "-n32";&#13;
  return Ret;&#13;
}&#13;
} // namespace</pre></li>				<li>Now, we can define the constructor and destructor. Many of the parameters are just passed <a id="_idIndexMarker867"/>to the superclass constructor. Note that our <code>computeDataLayout()</code> function is called here. In addition, the <code>TLOF</code> member is initialized with an instance of <code>TargetLoweringObjectFileELF</code>, since we are using the ELF file format. In the <a id="_idIndexMarker868"/>body of the constructor, we must call the <code>initAsmInfo()</code> method, which initializes many data members of the superclass:<pre class="source-code">&#13;
M88kTargetMachine::M88kTargetMachine(&#13;
    const Target &amp;T, const Triple &amp;TT, StringRef CPU,&#13;
    StringRef FS, const TargetOptions &amp;Options,&#13;
    std::optional&lt;Reloc::Model&gt; RM,&#13;
    std::optional&lt;CodeModel::Model&gt; CM,&#13;
    CodeGenOpt::Level OL, bool JIT)&#13;
    : LLVMTargetMachine(&#13;
          T, computeDataLayout(TT, CPU, FS), TT, CPU,&#13;
          FS, Options, !RM ? Reloc::Static : *RM,&#13;
          getEffectiveCodeModel(CM, CodeModel::Medium),&#13;
          OL),&#13;
      TLOF(std::make_unique&lt;&#13;
           TargetLoweringObjectFileELF&gt;()) {&#13;
  initAsmInfo();&#13;
}&#13;
M88kTargetMachine::~M88kTargetMachine() {}</pre></li>				<li>After, we define the <code>getSubtargetImpl()</code> method. The sub-target instance to use <a id="_idIndexMarker869"/>depends on the <code>target-cpu</code> and <code>target-features</code> function attributes. For example, the <code>target-cpu</code> attribute <a id="_idIndexMarker870"/>could be set to <code>MC88110</code>, thus targeting the second-generation CPU. However, the attribute target feature could describe that we should not use the graphics instructions of that CPU. We have not defined the CPUs and their features in the target description yet, so we are doing a bit more than what’s necessary here. However, the implementation is simple enough: we query the function attributes and use either the returned strings or the default values. With this information, we can query the <code>SubtargetMap</code> member, and if it’s not found, we create the sub-target:<pre class="source-code">&#13;
const M88kSubtarget *&#13;
M88kTargetMachine::getSubtargetImpl(&#13;
    const Function &amp;F) const {&#13;
  Attribute CPUAttr = F.getFnAttribute("target-cpu");&#13;
  Attribute FSAttr =&#13;
      F.getFnAttribute("target-features");&#13;
  std::string CPU =&#13;
      !CPUAttr.hasAttribute(Attribute::None)&#13;
          ? CPUAttr.getValueAsString().str()&#13;
          : TargetCPU;&#13;
  std::string FS = !FSAttr.hasAttribute(Attribute::None)&#13;
                       ? FSAttr.getValueAsString().str()&#13;
                       : TargetFS;&#13;
  auto &amp;I = SubtargetMap[CPU + FS];&#13;
  if (!I) {&#13;
    resetTargetOptions(F);&#13;
    I = std::make_unique&lt;M88kSubtarget&gt;(TargetTriple,&#13;
                                        CPU, FS, *this);&#13;
  }&#13;
  return I.get();&#13;
}</pre></li>				<li>Finally, we <a id="_idIndexMarker871"/>create the pass configuration. For this, we need our own class, <code>M88kPassConfig</code>, which derives <a id="_idIndexMarker872"/>from the <code>TargetPassConfig</code> class. We only override the <code>addInstSelector</code> method:<pre class="source-code">&#13;
namespace {&#13;
class M88kPassConfig : public TargetPassConfig {&#13;
public:&#13;
  M88kPassConfig(M88kTargetMachine &amp;TM,&#13;
                 PassManagerBase &amp;PM)&#13;
      : TargetPassConfig(TM, PM) {}&#13;
  bool addInstSelector() override;&#13;
};&#13;
} // namespace</pre></li>				<li>With <a id="_idIndexMarker873"/>this definition, we can implement the <code>createPassConfig</code> factory method:<pre class="source-code">&#13;
TargetPassConfig *M88kTargetMachine::createPassConfig(&#13;
    PassManagerBase &amp;PM) {&#13;
  return new M88kPassConfig(*this, PM);&#13;
}</pre></li>				<li>Lastly, we <a id="_idIndexMarker874"/>must add our instruction selection class to the pass pipeline in the <code>addInstSelector()</code> method. The return value, <code>false</code>, indicates that we have added a pass that converts LLVM IR into machine instructions:<pre class="source-code">&#13;
bool M88kPassConfig::addInstSelector() {&#13;
  addPass(createM88kISelDag(getTM&lt;M88kTargetMachine&gt;(),&#13;
                            getOptLevel()));&#13;
  return false;&#13;
}</pre></li>			</ol>&#13;
			<p>That was a long journey to finish the implementation! Now that we’ve built the <code>llc</code> tool, we can run an example. Save the following simple IR in the <code>and.ll</code> file:</p>&#13;
			<pre class="source-code">&#13;
define i32 @f1(i32 %a, i32 %b) {&#13;
  %res = and i32 %a, %b&#13;
  ret i32 %res&#13;
}</pre>			<p>Now, we <a id="_idIndexMarker875"/>can run <code>llc</code> and verify that the generated <a id="_idIndexMarker876"/>assembly looks reasonable:</p>&#13;
			<pre class="console">&#13;
$ llc -mtriple m88k-openbsd &lt; and.ll&#13;
        .text&#13;
        .file   "&lt;stdin&gt;"&#13;
        .globl  f1                              | -- Begin function f1&#13;
        .align  2&#13;
        .type   f1,@function&#13;
f1:                                     | @f1&#13;
| %bb.0:&#13;
        and %r2, %r2, %r3&#13;
        jmp %r1&#13;
.Lfunc_end0:&#13;
        .size   f1, .Lfunc_end0-f1&#13;
                                        | -- End function&#13;
        .section        ".note.GNU-stack","",@progbits</pre>			<p>To compile for the <code>m88k</code> target, we must specify the triple on the command line, as in this example, or in the IR file.</p>&#13;
			<p>Enjoy your success for a bit before we look at global instruction selection.</p>&#13;
			<h1 id="_idParaDest-199"><a id="_idTextAnchor213"/>Global instruction selection</h1>&#13;
			<p>Instruction selection via the selection DAG produces fast code, but it takes time to do so. The speed <a id="_idIndexMarker877"/>of the compiler is often critical for developers, who want to quickly try out the changes they’ve made. Usually, the compiler should be very fast at optimization level <code>0</code>, but it can take more time with increased optimization levels. However, constructing the selection DAG costs so much time that this approach does not scale as required. The first solution was to create another instruction selection algorithm called <code>FastISel</code>, which is fast but does not generate good code. It also does not share code with the selection DAG implementation, which is an obvious problem. Because of this, not all targets support <code>FastISel</code>.</p>&#13;
			<p>The selection DAG approach does not scale because it is a large, monolithic algorithm. If we can avoid creating a new data structure such as the selection DAG, then we should be able to perform the instruction selection using small components. The backend already has a pass pipeline, so using passes is a natural choice. Based on these thoughts, GlobalISel performs the following steps:</p>&#13;
			<ol>&#13;
				<li>First, the LLVM IR is lowered into generic machine instructions. Generic machine instructions represent the most common operation found in real hardware. Note that this translation uses the machine functions and machine basic blocks, which means it directly translates into the data structures used by the other parts of the backend.</li>&#13;
				<li>The generic machine instructions are then legalized.</li>&#13;
				<li>After, the operands of generic machine instructions are mapped to register banks.</li>&#13;
				<li>Finally, the generic instructions are replaced with real machine instructions, using the patterns defined in the target description.</li>&#13;
			</ol>&#13;
			<p>Since these are all passes, we can insert as many passes as we want in between. For example, a combiner pass could be used to replace a sequence of generic machine instructions with another generic machine instruction, or with a real machine instruction. Turning these additional passes off increases the compilation speed while turning them on improves the quality of the generated code. Hence, we can scale as we need.</p>&#13;
			<p>There is another advantage in this approach. The selection DAG translates basic block by basic block, but a machine pass works on a machine function, which enables us to consider all <a id="_idIndexMarker878"/>basic blocks of a function during instruction selections. Therefore, this instruction selection method is called global instruction selection (GlobalISel). Let’s have a look at how this approach works, starting with the transformation of calls.</p>&#13;
			<h2 id="_idParaDest-200"><a id="_idTextAnchor214"/>Lowering arguments and return values</h2>&#13;
			<p>For translating the LLVM IR to generic machine instructions, we only need to implement how <a id="_idIndexMarker879"/>arguments and return values are handled. Again, the implementation can be simplified by using the generated code from the target description. The class we’ll create is called <code>M88kCallLowering</code>, and the declaration is in the <code>GISel/M88kCallLowering.h</code> header file:</p>&#13;
			<pre class="source-code">&#13;
class M88kCallLowering : public CallLowering {&#13;
public:&#13;
  M88kCallLowering(const M88kTargetLowering &amp;TLI);&#13;
  bool&#13;
  lowerReturn(MachineIRBuilder &amp;MIRBuilder,&#13;
              const Value *Val,&#13;
              ArrayRef&lt;Register&gt; VRegs,&#13;
              FunctionLoweringInfo &amp;FLI,&#13;
              Register SwiftErrorVReg) const override;&#13;
  bool lowerFormalArguments(&#13;
      MachineIRBuilder &amp;MIRBuilder, const Function &amp;F,&#13;
      ArrayRef&lt;ArrayRef&lt;Register&gt;&gt; VRegs,&#13;
      FunctionLoweringInfo &amp;FLI) const override;&#13;
  bool enableBigEndian() const override { return true; }&#13;
};</pre>			<p>The GlobalISel framework will call the <code>lowerReturn()</code> and <code>lowerFormalArguments()</code> methods when a function is translated. To translate a function call, you would need to override and implement the <code>lowerCall()</code> method as well. Please note that we also need to override <code>enableBigEndian()</code>. Without it, the wrong machine code would be generated.</p>&#13;
			<p>For <a id="_idIndexMarker880"/>the implementation in the <code>GISel/M88kCallLowering.cpp</code> file, we need to define to support classes. The generated code from the target description tells us how a parameter is passed – for example, in a register. We need to create a subclass of <code>ValueHandler</code> to generate the machine instructions for it. For incoming parameters, we need to derive our class from <code>IncomingValueHandler</code>, as well as for the return value from <code>OutgoingValueHandler</code>. Both are very similar, so we’ll only look at the handler for incoming arguments:</p>&#13;
			<pre class="source-code">&#13;
namespace {&#13;
struct FormalArgHandler&#13;
    : public CallLowering::IncomingValueHandler {&#13;
  FormalArgHandler(MachineIRBuilder &amp;MIRBuilder,&#13;
                   MachineRegisterInfo &amp;MRI)&#13;
      : CallLowering::IncomingValueHandler(MIRBuilder,&#13;
                                           MRI) {}&#13;
  void assignValueToReg(Register ValVReg,&#13;
                        Register PhysReg,&#13;
                        CCValAssign VA) override;&#13;
  void assignValueToAddress(Register ValVReg,&#13;
                            Register Addr, LLT MemTy,&#13;
                            MachinePointerInfo &amp;MPO,&#13;
                            CCValAssign &amp;VA) override{};&#13;
  Register&#13;
  getStackAddress(uint64_t Size, int64_t Offset,&#13;
                  MachinePointerInfo &amp;MPO,&#13;
                  ISD::ArgFlagsTy Flags) override {&#13;
    return Register();&#13;
  };&#13;
};&#13;
} // namespace</pre>			<p>So far, we can only handle parameters passed in registers, so we must provide a dummy implementation for the other methods. The <code>assignValueToReg()</code> method copies the <a id="_idIndexMarker881"/>value of the incoming physical register to a virtual register, performing a truncation if necessary. All we have to do here is mark the physical register as live-in to the function, and call the superclass implementation:</p>&#13;
			<pre class="source-code">&#13;
void FormalArgHandler::assignValueToReg(&#13;
    Register ValVReg, Register PhysReg,&#13;
    CCValAssign VA) {&#13;
  MIRBuilder.getMRI()-&gt;addLiveIn(PhysReg);&#13;
  MIRBuilder.getMBB().addLiveIn(PhysReg);&#13;
  CallLowering::IncomingValueHandler::assignValueToReg(&#13;
      ValVReg, PhysReg, VA);&#13;
}</pre>			<p>Now, we can implement the <code>lowerFormalArgument()</code> method:</p>&#13;
			<ol>&#13;
				<li>First, the parameters of the <code>IR</code> function are translated into instances of the <code>ArgInfo</code> class. The <code>setArgFlags()</code> and <code>splitToValueTypes()</code> framework <a id="_idIndexMarker882"/>methods help with copying the parameter attributes and splitting the value type in case an incoming argument needs more than one virtual register:<pre class="source-code">&#13;
bool M88kCallLowering::lowerFormalArguments(&#13;
    MachineIRBuilder &amp;MIRBuilder, const Function &amp;F,&#13;
    ArrayRef&lt;ArrayRef&lt;Register&gt;&gt; VRegs,&#13;
    FunctionLoweringInfo &amp;FLI) const {&#13;
  MachineFunction &amp;MF = MIRBuilder.getMF();&#13;
  MachineRegisterInfo &amp;MRI = MF.getRegInfo();&#13;
  const auto &amp;DL = F.getParent()-&gt;getDataLayout();&#13;
  SmallVector&lt;ArgInfo, 8&gt; SplitArgs;&#13;
  for (const auto &amp;[I, Arg] :&#13;
       llvm::enumerate(F.args())) {&#13;
    ArgInfo OrigArg{VRegs[I], Arg.getType(),&#13;
                    static_cast&lt;unsigned&gt;(I)};&#13;
    setArgFlags(OrigArg,&#13;
                I + AttributeList::FirstArgIndex, DL,&#13;
                F);&#13;
    splitToValueTypes(OrigArg, SplitArgs, DL,&#13;
                      F.getCallingConv());&#13;
  }</pre></li>				<li>With the arguments prepared in the <code>SplitArgs</code> variable, we are ready to generate <a id="_idIndexMarker883"/>the machine code. This is all done by the framework code, with the help of the generated calling convention, <code>CC_M88k</code>, and our helper class, <code>FormalArghandler</code>:<pre class="source-code">&#13;
  IncomingValueAssigner ArgAssigner(CC_M88k);&#13;
  FormalArgHandler ArgHandler(MIRBuilder, MRI);&#13;
  return determineAndHandleAssignments(&#13;
      ArgHandler, ArgAssigner, SplitArgs, MIRBuilder,&#13;
      F.getCallingConv(), F.isVarArg());&#13;
}</pre></li>			</ol>&#13;
			<p>Return values are handled similarly, with the main difference being that one value is returned at most. The next task is to legalize the generic machine instructions.</p>&#13;
			<h2 id="_idParaDest-201"><a id="_idTextAnchor215"/>Legalizing the generic machine instructions</h2>&#13;
			<p>The translation from LLVM IR to generic machine code is mostly fixed. As a result, instructions can be generated that use unsupported data types, among other challenges. The task of the legalizer pass is to define which operations and instructions are legal. With this information, the GlobalISel framework tries to transform the instructions <a id="_idIndexMarker884"/>into a legal form. For example, the m88k architecture only has 32-bit registers, so a bitwise <code>and</code> operation with 64-bit values is not legal. However, if we split the 64-bit value into two 32-bit values, and use two bitwise <code>and</code> operations instead, then we have legal code. This can be translated into a legalization rule:</p>&#13;
			<pre class="source-code">&#13;
  getActionDefinitionsBuilder({G_AND, G_OR, G_XOR})&#13;
      .legalFor({S32})&#13;
      .clampScalar(0, S32, S32);</pre>			<p>Whenever the legalizer pass processes a <code>G_AND</code> instruction, then it is legal if all operands are 32-bit wide. Otherwise, the operands are clamped to 32-bit, effectively splitting larger values into multiple 32-bit values, and the rule is applied again. If an instruction cannot be legalized, then the backend terminates with an error message.</p>&#13;
			<p>All <a id="_idIndexMarker885"/>legalization rules are defined in the constructor of the <code>M88kLegalizerInfo</code> class, which makes the class very simple.</p>&#13;
			<p class="callout-heading">What does legal mean?</p>&#13;
			<p class="callout">In GlobalISel, a generic instruction is legal if it can be translated by the instruction selector. This gives us more freedom in the implementation. For example, we can state that an instruction works on a bit value, even if the hardware only operates on 32-bit values, so long as the instruction selector can handle the type correctly.</p>&#13;
			<p>The next pass we need to look at is the register bank selector.</p>&#13;
			<h2 id="_idParaDest-202"><a id="_idTextAnchor216"/>Selecting a register bank for operands</h2>&#13;
			<p>Many architectures define several register banks. A register bank is a set of registers. Typical <a id="_idIndexMarker886"/>register banks are general-purpose register banks and floating-point register banks. Why is this information important? Moving a value from one register to another is usually cheap inside a register bank, but copying the value to another register bank can be costly or impossible. Thus, we must select a good register bank for each operand.</p>&#13;
			<p>The implementation of this class involves an addition to the target description. In the <code>GISel/M88lRegisterbanks.td</code> file, we define our single register bank, referencing the register classes we have defined:</p>&#13;
			<pre class="source-code">&#13;
def GRRegBank : RegisterBank&lt;"GRRB", [GPR, GPR64]&gt;;</pre>			<p>From this line, some support code is generated. However, we still need to add some code that could be potentially generated. First, we need to define partial mappings. This tells the framework at which bit index a value begins, how wide it is, and to which register bank it maps. We have two entries, one for each register class:</p>&#13;
			<pre class="source-code">&#13;
RegisterBankInfo::PartialMapping&#13;
    M88kGenRegisterBankInfo::PartMappings[]{&#13;
        {0, 32, M88k::GRRegBank},&#13;
        {0, 64, M88k::GRRegBank},&#13;
    };</pre>			<p>To index this array, we must define an enumeration:</p>&#13;
			<pre class="source-code">&#13;
enum PartialMappingIdx { PMI_GR32 = 0, PMI_GR64, };</pre>			<p>Since we <a id="_idIndexMarker887"/>have only three address instructions, we need three partial mappings, one for each operand. We must create an array with all those pointers, with the first entry denoting an invalid mapping:</p>&#13;
			<pre class="source-code">&#13;
RegisterBankInfo::ValueMapping&#13;
    M88kGenRegisterBankInfo::ValMappings[]{&#13;
        {nullptr, 0},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},&#13;
    };</pre>			<p>To access that array, we must define a function:</p>&#13;
			<pre class="source-code">&#13;
const RegisterBankInfo::ValueMapping *&#13;
M88kGenRegisterBankInfo::getValueMapping(&#13;
    PartialMappingIdx RBIdx) {&#13;
  return &amp;ValMappings[1 + 3*RBIdx];&#13;
}</pre>			<p>When creating these tables, it is easy to make errors. At first glance, all this information can be <a id="_idIndexMarker888"/>derived from the target description, and a comment in the source states that this code should be generated by TableGen! However, this hasn’t been implemented yet, so we have to create the code manually.</p>&#13;
			<p>The most important function we have to implement in the <code>M88kRegisterBankInfo</code> class is <code>getInstrMapping()</code>, which returns the mapped register banks for each operand of the instruction. This now becomes easy because we can look up the array of partial mappings, which we can then pass to the <code>getInstructionMapping()</code> method, which constructs the full instruction mapping:</p>&#13;
			<pre class="source-code">&#13;
const RegisterBankInfo::InstructionMapping &amp;&#13;
M88kRegisterBankInfo::getInstrMapping(&#13;
    const MachineInstr &amp;MI) const {&#13;
  const ValueMapping *OperandsMapping = nullptr;&#13;
  switch (MI.getOpcode()) {&#13;
  case TargetOpcode::G_AND:&#13;
  case TargetOpcode::G_OR:&#13;
  case TargetOpcode::G_XOR:&#13;
    OperandsMapping = getValueMapping(PMI_GR32);&#13;
    break;&#13;
  default:&#13;
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)&#13;
    MI.dump();&#13;
#endif&#13;
    return getInvalidInstructionMapping();&#13;
  }&#13;
  return getInstructionMapping(DefaultMappingID, /*Cost=*/1,&#13;
                               OperandsMapping,&#13;
                               MI.getNumOperands());&#13;
}</pre>			<p>During development, it is common to forget the register bank mapping for a generic instruction. Unfortunately, the error message that’s generated at runtime does not mention <a id="_idIndexMarker889"/>for which instruction the mapping failed. The easy fix is to dump the instruction before returning the invalid mapping. However, we need to be careful here because the <code>dump()</code> method is not available in all build types.</p>&#13;
			<p>After mapping the register banks, we must translate the generic machine instructions into real machine instructions.</p>&#13;
			<h2 id="_idParaDest-203"><a id="_idTextAnchor217"/>Translating generic machine instructions</h2>&#13;
			<p>For instruction selection via the selection DAG, we added patterns to the target description, which use DAG operations and operands. To reuse those patterns, a mapping <a id="_idIndexMarker890"/>from DAG node types to generic machine instructions was introduced. For example, the DAG <code>and</code> operation maps to the generic <code>G_AND</code> machine instruction. Not all DAG operations have an equivalent generic machine instruction; however, the most common cases are covered. Therefore, it is beneficial to define all code selection patterns in the target description.</p>&#13;
			<p>Most of the implementation of the <code>M88kInstructionSelector</code> class, which can be found in the <code>GISel/M88kInstructionSelector.cpp</code> file, is generated from the target description. However, we need to override the <code>select()</code> method, which allows us to translate generic machine instructions that are not covered by the patterns in the target description. Since we only support a very small subset of generic instructions, we can simply call the generated pattern matcher:</p>&#13;
			<pre class="source-code">&#13;
bool M88kInstructionSelector::select(MachineInstr &amp;I) {&#13;
  if (selectImpl(I, *CoverageInfo))&#13;
    return true;&#13;
  return false;&#13;
}</pre>			<p>With <a id="_idIndexMarker891"/>the instruction selection implemented, we can translate LLVM IR using GlobalISel!</p>&#13;
			<h2 id="_idParaDest-204"><a id="_idTextAnchor218"/>Running an example</h2>&#13;
			<p>To translate LLVM IR using GlobalISel, we need to add the <code>-global-isel</code> option to the command <a id="_idIndexMarker892"/>line of <code>llc</code>. For example, you can use the previously defined IR file, <code>and.ll</code>:</p>&#13;
			<pre class="console">&#13;
$ llc -mtriple m88k-openbsd -global-isel &lt; and.ll</pre>			<p>The printed assembly text is the same. To convince ourselves that the translation uses GlobalISel, we must take advantage of the fact that we can stop the translation after a specified pass is run with the <code>-stop-after=</code> option. For example, to see the generic instructions after legalization, you would run the following command:</p>&#13;
			<pre class="console">&#13;
$ llc -mtriple m88k-openbsd -global-isel &lt; and.ll \&#13;
  -stop-after=legalizer</pre>			<p>The ability to stop after (or before) a pass is run is another advantage of GlobalISel because it makes it easy to debug and test the implementation.</p>&#13;
			<p>At this point, we have a working backend that can translate some LLVM IR into machine code for the m<a id="_idTextAnchor219"/>88k architecture. Let’s think about how to move from here to a more complete backend.</p>&#13;
			<h1 id="_idParaDest-205"><a id="_idTextAnchor220"/>How to further evolve the backend</h1>&#13;
			<p>With the code from this and the previous chapter, we have created a backend that can translate <a id="_idIndexMarker893"/>some LLVM IR into machine code. It is very satisfying to see the backend working, but it is far from being usable for serious tasks. Much more coding is needed. Here is a recipe for how you can further evolve the backend:</p>&#13;
			<ul>&#13;
				<li>The first decision you should make is if you want to use GlobalISel or the selection DAG. In our experience, GlobalISel is easier to understand and develop, but all targets in the LLVM source tree implement the selection DAG, and you may already have experience in using it.</li>&#13;
				<li>Next, you should define the instructions for adding and subtracting integer values, which can be done similarly to the bitwise <code>and</code> instruction.</li>&#13;
				<li>After, you should implement the load and store instructions. This is more involved since you need to translate the different addressing modes. Most likely, you will deal with indexing, for example, to address an element of an array, which most likely requires the previously defined instruction for addition.</li>&#13;
				<li>Finally, you can fully implement frame lowering and call lowering. At this point, you can translate a simple “Hello, world!” style application into a running program.</li>&#13;
				<li>The next logical step is to implement branch instructions, which enable the translation of loops. To generate optimal code, you need to implement the branch analyzing methods in the instruction information class.</li>&#13;
			</ul>&#13;
			<p>When you reach this point, your backend can already translate simple algorithms. You should also have gained enough experience to develop the missing parts based on your priorities.</p>&#13;
			<h1 id="_idParaDest-206"><a id="_idTextAnchor221"/>Summary</h1>&#13;
			<p> In this chapter, you added two different instruction selections to your backend: instruction selection via the selection DAG, and global instruction selection. For this, you had to define the calling convention in the target description. In addition, you needed to implement register and instruction information classes, which give you access to information generated from the target description but which you also needed to enhance with additional information. You learned that the stack frame layout and prolog generation are needed later. To translate an example, you added a class to emit machine instructions, and you created the configuration of the backend. You also learned how global instruction selection works. Finally, you gained some guidance on how you can develop the backend on your own.</p>&#13;
			<p>In the next chapter, we will look at some tasks that can be done after instruction selection – we will add a new pass in the pipeline of the backend, look at how to integrate the backend into the clang compiler, and how to cross-compile to a different architecture.</p>&#13;
		</div>&#13;
	</div></body></html>