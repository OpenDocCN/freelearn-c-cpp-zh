<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer036">&#13;
			<h1 id="_idParaDest-183" class="chapter-number"><a id="_idTextAnchor193"/>12</h1>&#13;
			<h1 id="_idParaDest-184"><a id="_idTextAnchor194"/>Instruction Selection</h1>&#13;
			<p>The heart of any backend is instruction selection. LLVM implements several approaches; in this chapter, we will <a id="_idIndexMarker806"/>implement instruction selection via the selection <strong class="bold">directed acyclic graph</strong> (<strong class="bold">DAG</strong>) and with global <span class="No-Break">instruction selection.</span></p>&#13;
			<p>In this chapter, you will learn about the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li><em class="italic">Defining the rules of the calling convention</em>: This section shows you how to describe the rules of a calling convention in the <span class="No-Break">target description</span></li>&#13;
				<li><em class="italic">Instruction selection via the selection DAG</em>: This section teaches you how to implement instruction selection with a graph <span class="No-Break">data structure</span></li>&#13;
				<li><em class="italic">Adding register and instruction information</em>: This section explains how to access information in the target description, and what additional information you need <span class="No-Break">to provide</span></li>&#13;
				<li><em class="italic">Putting an empty frame lowering in place</em>: This section introduces you to the stack layout and the prologue of <span class="No-Break">a function</span></li>&#13;
				<li><em class="italic">Emitting machine instructions</em>: This section tells you how machine instructions are finally written into an object file or as <span class="No-Break">assembly text</span></li>&#13;
				<li><em class="italic">Creating the target machine and the sub-target</em>: This section shows you how a backend <span class="No-Break">is configured</span></li>&#13;
				<li><em class="italic">Global instruction selection</em>: This section demonstrates a different approach to <span class="No-Break">instruction selection</span></li>&#13;
				<li><em class="italic">How to further evolve the backend</em>: This section gives you some guidance about possible <span class="No-Break">next steps</span></li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to create an LLVM backend that can translate simple instructions. You will also acquire the knowledge to develop instruction selection via the selection DAG and with global instruction selection, and you will become familiar with all the important support classes you have to implement to get instruction <span class="No-Break">selection working.</span></p>&#13;
			<h1 id="_idParaDest-185"><a id="_idTextAnchor195"/>Defining the rules of the calling convention</h1>&#13;
			<p>Implementing the rules of the calling convention is an important part of lowering the LLVM <strong class="bold">intermediate representation</strong> (<strong class="bold">IR</strong>) to machine code. The basic rules can be defined in <a id="_idIndexMarker807"/>the target description. Let’s have <span class="No-Break">a look.</span></p>&#13;
			<p>Most calling <a id="_idIndexMarker808"/>conventions follow a basic pattern: they define a subset of registers for parameter passing. If this subset is not exhausted, the next parameter is passed in the next free register. If there is no free register, then the value is passed on the stack. This can be realized by looping over the parameters and deciding how to pass each parameter to the called function while keeping track of the used registers. In LLVM, this loop is implemented inside the framework, and the state is held <a id="_idIndexMarker809"/>in a class called <strong class="source-inline">CCState</strong>. Furthermore, the rules are defined in the <span class="No-Break">target description.</span></p>&#13;
			<p>The rules are given as a sequence of conditions. If the condition holds, then an action is executed. Depending on the outcome of that action, either a place for the parameter is found, or the next condition is evaluated. For example, 32-bit integers are passed in a register. The condition is the type check, and the action is the assignment of a register to this parameter. In the target description, this is written <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
CCIfType&lt;[i32],&#13;
         CCAssignToReg&lt;[R2, R3, R4, R5, R6, R7, R8, R9]&gt;&gt;,</pre>			<p>Of course, if the called function has more than eight parameters, then the register list will be exhausted, and the action will fail. The remaining parameters are passed on the stack, and we can specify this as the <span class="No-Break">next action:</span></p>&#13;
			<pre class="source-code">&#13;
CCAssignToStack&lt;4, 4&gt;</pre>			<p>The first parameter is the size of a stack slot in bytes, while the second is the alignment. Since it is a catch-all rule, no condition <span class="No-Break">is used.</span></p>&#13;
			<h2 id="_idParaDest-186"><a id="_idTextAnchor196"/>Implementing the rules of the calling convention</h2>&#13;
			<p>For a calling convention, there are also more predefined conditions and actions to note. For example, <strong class="source-inline">CCIfInReg</strong> checks if the argument is marked with the <strong class="source-inline">inreg</strong> attribute, and <strong class="source-inline">CCIfVarArg</strong> evaluates to <strong class="source-inline">true</strong> if the function has a variable argument list. The <strong class="source-inline">CCPromoteToType</strong> action promotes the type of the argument to a larger one, and the <strong class="source-inline">CCPassIndirect</strong> action indicates that the parameter value should be stored on the stack and <a id="_idIndexMarker810"/>that a pointer to that storage is passed as a normal argument. All of the predefined conditions and actions can be referenced <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">llvm/include/llvm/Target/TargetCallingConv.td</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Both the parameters and the return value are defined in this way. We will put the definition into the <span class="No-Break"><strong class="source-inline">M88kCallingConv.td</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>First, we must define the rules for the parameters. To simplify the coding, we’ll only consider <span class="No-Break">32-bit values:</span><pre class="source-code">&#13;
def CC_M88k : CallingConv&lt;[&#13;
  CCIfType&lt;[i8, i16], CCPromoteToType&lt;i32&gt;&gt;,&#13;
  CCIfType&lt;[i32,f32],&#13;
        CCAssignToReg&lt;[R2, R3, R4, R5, R6, R7, R8, R9]&gt;&gt;,&#13;
  CCAssignToStack&lt;4, 4&gt;&#13;
]&gt;;</pre></li>				<li>After that, we must define the rules for <span class="No-Break">return values:</span><pre class="source-code">&#13;
def RetCC_M88k : CallingConv&lt;[&#13;
  CCIfType&lt;[i32], CCAssignToReg&lt;[R2]&gt;&gt;&#13;
]&gt;;</pre></li>				<li>Finally, the sequence of callee saved registers must be defined. Note that we use the <strong class="source-inline">sequence</strong> operator to generate a sequence of registers, instead of writing <span class="No-Break">them down:</span><pre class="source-code">&#13;
def CSR_M88k :&#13;
    CalleeSavedRegs&lt;(add R1, R30,&#13;
                         (sequence "R%d", 25,  14))&gt;;</pre></li>			</ol>&#13;
			<p>The benefit of defining the rules for the calling convention in the target description is that they can <a id="_idIndexMarker811"/>be reused for various instruction selection methods. We’ll look at instruction selection via the selection <span class="No-Break">DAG next.</span></p>&#13;
			<h1 id="_idParaDest-187"><a id="_idTextAnchor197"/>Instruction selection via the selection DAG</h1>&#13;
			<p>Creating <a id="_idIndexMarker812"/>machine instructions from the IR is a very important <a id="_idIndexMarker813"/>task in the backend. One common way to implement it is to utilize <span class="No-Break">a DAG:</span></p>&#13;
			<ol>&#13;
				<li>First, we must create a DAG from the IR. A node of the DAG represents an operation and the edges model control and data <span class="No-Break">flow dependencies.</span></li>&#13;
				<li>Next, we must loop over the DAG and legalize the types and operations. Legalization means that we only use types and operations that are supported by the hardware. This requires us to create a configuration that tells the framework how to deal with non-legal types and operations. For instance, a 64-bit value could be split into two 32-bit values, the multiplication of two 64-bit values could be changed to a library call, and a complex operation such as count population could be expanded into a sequence of simpler operations for calculating <span class="No-Break">this value.</span></li>&#13;
				<li>After, pattern matching is utilized to match nodes in the DAG and replace them with machine instructions. We encountered such a pattern in the <span class="No-Break">previous chapter.</span></li>&#13;
				<li>Finally, an instruction scheduler reorders the machine instructions into a more <span class="No-Break">performant order.</span></li>&#13;
			</ol>&#13;
			<p>This is just a high-level description of the instruction selection process via the selection DAG. If you are interested in more details, you can find it in the <em class="italic">The LLVM Target-Independent Code Generator</em> user guide <span class="No-Break">at </span><a href="https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process"><span class="No-Break">https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process</span></a><span class="No-Break">.</span></p>&#13;
			<p>Furthermore, all backends in LLVM implement the selection DAG. The main advantage is that it generates performant code. However, this comes at a cost: creating the DAG is expensive, and it slows down compilation speed. Therefore, this has prompted LLVM developers to look for alternative and more desirable approaches. Some targets implement instruction selection via FastISel, which is only used for non-optimized code. It can quickly generate code, but the generated code is inferior to the one generated by the selection DAG method. In addition, it adds a whole new instruction selection method, which doubles <a id="_idIndexMarker814"/>the testing effort. Another <a id="_idIndexMarker815"/>method is also used for instruction selection called global instruction selection, which we’ll examine later in the <em class="italic">Global instruction </em><span class="No-Break"><em class="italic">selection</em></span><span class="No-Break"> section.</span></p>&#13;
			<p>In this chapter, we aim to implement enough of the backend to lower a simple IR function, <span class="No-Break">like this:</span></p>&#13;
			<pre class="source-code">&#13;
define i32 @f1(i32 %a, i32 %b) {&#13;
  %res = and i32 %a, %b&#13;
  ret i32 %res&#13;
}</pre>			<p>Moreover, for a real backend, much more code is needed, and we must point out what needs to be added for <span class="No-Break">greater functionality.</span></p>&#13;
			<p>To implement instruction selection via the selection DAG, we need to create two new classes: <strong class="source-inline">M88kISelLowering</strong> and <strong class="source-inline">M88kDAGToDAGISel</strong>. The former class is used to customize the DAG, for example, by defining which types are legal. It also contains the code to support the lowering of functions and function calls. The latter class performs DAG transformations, and the implementation is mostly generated from the <span class="No-Break">target description.</span></p>&#13;
			<p>There are several classes within the backend that we will be adding implementation to, and <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.1</em> depicts the high-level relationship between the primary classes that we will be <span class="No-Break">developing further:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer035" class="IMG---Figure">&#13;
					<img src="Images/B19561_12_1.jpg" alt="Figure 12.1 – Relationship between the main classes" width="970" height="794"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Relationship between the main classes</p>&#13;
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Implementing DAG lowering – handling legal types and setting operations</h2>&#13;
			<p>Let’s <a id="_idIndexMarker816"/>implement the <strong class="source-inline">M88kISelLowering</strong> class, which is stored in <strong class="source-inline">M88kISelLowering.cpp</strong> file, first. The constructor configures the legal types <span class="No-Break">and operations:</span></p>&#13;
			<ol>&#13;
				<li>The constructor takes references to the <strong class="source-inline">TargetMachine</strong> and <strong class="source-inline">M88kSubtarget</strong> classes as parameters. The <strong class="source-inline">TargetMachine</strong> class is responsible for the general configuration of the target, for example, which passes need to run. An LLVM backend usually targets a CPU family, and the <strong class="source-inline">M88kSubtarget</strong> class describes the characteristics of the chosen CPU. We’ll look at both classes later in <span class="No-Break">this chapter:</span><pre class="source-code">&#13;
M88kTargetLowering::M88kTargetLowering(&#13;
    const TargetMachine &amp;TM, const M88kSubtarget &amp;STI)&#13;
    : TargetLowering(TM), Subtarget(STI) {</pre></li>				<li>The first action is to declare which machine value type uses which register class. Remember that the register classes are generated from the target description. Here, we only handle <span class="No-Break">32-bit values:</span><pre class="source-code">&#13;
  addRegisterClass(MVT::i32, &amp;M88k::GPRRegClass);</pre></li>				<li>After adding all register classes, we must compute the derived properties of those <a id="_idIndexMarker817"/>register classes. We need to query the sub-target for register information, which is mostly generated from the <span class="No-Break">target description:</span><pre class="source-code">&#13;
computeRegisterProperties(Subtarget.getRegisterInfo());</pre></li>				<li>Next, we must declare which register contains the <span class="No-Break">stack pointer:</span><pre class="source-code">&#13;
  setStackPointerRegisterToSaveRestore(M88k::R31);</pre></li>				<li>Boolean values are represented differently on different platforms. For our target, we will declare that a Boolean value is stored in bit <strong class="source-inline">0</strong>; the other bits <span class="No-Break">are cleared:</span><pre class="source-code">&#13;
  setBooleanContents(ZeroOrOneBooleanContent);</pre></li>				<li>After, we set the alignment of functions. The minimal function alignment is the alignment that is required for correct execution. In addition, we give the <span class="No-Break">preferred alignment:</span><pre class="source-code">&#13;
  setMinFunctionAlignment(Align(4));&#13;
  setPrefFunctionAlignment(Align(4));</pre></li>				<li>Finally, we declare which operations are legal. In the previous chapter, we only defined three logical instructions, and they are legal for <span class="No-Break">32-bit values:</span><pre class="source-code">&#13;
  setOperationAction(ISD::AND, MVT::i32, Legal);&#13;
  setOperationAction(ISD::OR, MVT::i32, Legal);&#13;
  setOperationAction(ISD::XOR, MVT::i32, Legal);</pre></li>				<li>There are a couple of other actions we can use besides <strong class="source-inline">Legal</strong>. <strong class="source-inline">Promote</strong> widens the type, <strong class="source-inline">Expand</strong> replaces the operation with other operations, <strong class="source-inline">LibCall</strong> lowers the operation to a library call, and <strong class="source-inline">Custom</strong> calls the <strong class="source-inline">LowerOperation()</strong> hook method, which lets you implement your own custom handling. For example, in the M88k architecture, there is no count population instruction, so we request that this operation be expanded into <span class="No-Break">other operations:</span><pre class="source-code">&#13;
  setOperationAction(ISD::CTPOP, MVT::i32, Expand);&#13;
}</pre></li>			</ol>&#13;
			<p>Now, let’s review some points to emphasize the connection between the definitions we made so far. In the target description mentioned in the <strong class="source-inline">M88kInstrInfo.td</strong> file, we defined a <a id="_idIndexMarker818"/>machine instruction with the <strong class="source-inline">and</strong> mnemonic, and we also attached a pattern to it. If we expand the <strong class="source-inline">AND</strong> multiclass record, and only look at the instruction using three registers, we get the <span class="No-Break">TableGen definition:</span></p>&#13;
			<pre class="source-code">&#13;
let isCommutable = 1 in&#13;
  def ANDrr : F_LR&lt;0b01000, Func, /*comp=*/0b0, "and",&#13;
                   [(set i32:$rd,&#13;
                       (and GPROpnd:$rs1, GPROpnd:$rs2))]&gt;;</pre>			<p>The <strong class="source-inline">"and"</strong> string is the mnemonic of the instruction. In C++ source code, we use <strong class="source-inline">M88k::ANDrr</strong> to refer to this instruction. Inside the pattern, the DAG <strong class="source-inline">and</strong> node type is used. In C++, it is named <strong class="source-inline">ISD::AND</strong>, and we used it in the call to the <strong class="source-inline">setOperationAction()</strong> method. During instruction selection, a DAG node of the <strong class="source-inline">and</strong> type is replaced by the <strong class="source-inline">M88k::ANDrr</strong> instruction if the pattern matches, which includes the input operands. Thus, when we develop instruction selection, the most important task is for us to define the correct legalization actions and attach the patterns to the <span class="No-Break">instruction definitions.</span></p>&#13;
			<h2 id="_idParaDest-189"><a id="_idTextAnchor199"/>Implementing DAG lowering – lowering formal arguments</h2>&#13;
			<p>Let’s turn to another important task performed by the <strong class="source-inline">M88kISelLowering</strong> class. We defined <a id="_idIndexMarker819"/>the rules for the calling convention in the previous section, but we also need to map the physical registers and memory locations to virtual registers used in the DAG. For arguments, this is done in the <strong class="source-inline">LowerFormalArguments()</strong> method; return values are handled in the <strong class="source-inline">LowerReturn()</strong> method. First, we must handle <span class="No-Break">the arguments:</span></p>&#13;
			<ol>&#13;
				<li>We’ll begin by including the <span class="No-Break">generated source:</span><pre class="source-code">&#13;
#include "M88kGenCallingConv.inc"</pre></li>				<li>The <strong class="source-inline">LowerFormalArguments()</strong> method takes several parameters. The <strong class="source-inline">SDValue</strong> class denotes a value associated with a DAG node and is often used when dealing with the DAG. The first parameter, <strong class="source-inline">Chain</strong>, represents the control flow, and the possible updated <strong class="source-inline">Chain</strong> is also the return value of the method. The <strong class="source-inline">CallConv</strong> parameter identifies the used calling convention, and <strong class="source-inline">IsVarArg</strong> is set to <strong class="source-inline">true</strong> if a variable argument list is part of the parameters. The arguments that need to be handled are passed in the <strong class="source-inline">Ins</strong> parameter, together with their location in the <strong class="source-inline">DL</strong> parameter. The <strong class="source-inline">DAG</strong> parameter gives us access to the <strong class="source-inline">SelectionDAG</strong> class. Lastly, the result of the mapping will be stored in the <strong class="source-inline">InVals</strong> <span class="No-Break">vector argument:</span><pre class="source-code">&#13;
SDValue M88kTargetLowering::LowerFormalArguments(&#13;
    SDValue Chain, CallingConv::ID CallConv,&#13;
    bool IsVarArg,&#13;
    const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins,&#13;
    const SDLoc &amp;DL, SelectionDAG &amp;DAG,&#13;
    SmallVectorImpl&lt;SDValue&gt; &amp;InVals) const {</pre></li>				<li>Our first action is to retrieve references to the machine function and the machine <span class="No-Break">register information:</span><pre class="source-code">&#13;
  MachineFunction &amp;MF = DAG.getMachineFunction();&#13;
  MachineRegisterInfo &amp;MRI = MF.getRegInfo();</pre></li>				<li>Next, we must call the generated code. We need to instantiate an object of the <strong class="source-inline">CCState</strong> class. The <strong class="source-inline">CC_M88k</strong> parameter value that’s used in the call to the <strong class="source-inline">AnalyzeFormalArguments()</strong> method is the name of the calling convention we used in the target description. The result is stored in the <span class="No-Break"><strong class="source-inline">ArgLocs</strong></span><span class="No-Break"> vector:</span><pre class="source-code">&#13;
  SmallVector&lt;CCValAssign, 16&gt; ArgLocs;&#13;
  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs,&#13;
                 *DAG.getContext());&#13;
  CCInfo.AnalyzeFormalArguments(Ins, CC_M88k);</pre></li>				<li>Once the <a id="_idIndexMarker820"/>locations of the arguments have been determined, we need to map them to the DAG. Therefore, we must loop over <span class="No-Break">all locations:</span><pre class="source-code">&#13;
  for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {&#13;
    SDValue ArgValue;&#13;
    CCValAssign &amp;VA = ArgLocs[I];&#13;
    EVT LocVT = VA.getLocVT();</pre></li>				<li>The mapping depends on the determined location. First, we handle arguments assigned to registers. The goal is to copy the physical register to a virtual register. To do so, we need to determine the correct register class. Since we’re only handling 32-bit values, it is easy to <span class="No-Break">do this:</span><pre class="source-code">&#13;
    if (VA.isRegLoc()) {&#13;
      const TargetRegisterClass *RC;&#13;
      switch (LocVT.getSimpleVT().SimpleTy) {&#13;
      default:&#13;
        llvm_unreachable("Unexpected argument type");&#13;
      case MVT::i32:&#13;
        RC = &amp;M88k::GPRRegClass;&#13;
        break;&#13;
      }</pre></li>				<li>With the register class stored in the <strong class="source-inline">RC</strong> variable, we can create the virtual register and <a id="_idIndexMarker821"/>copy the value. We also need to declare the physical register as <span class="No-Break">a live-in:</span><pre class="source-code">&#13;
      Register VReg = MRI.createVirtualRegister(RC);&#13;
      MRI.addLiveIn(VA.getLocReg(), VReg);&#13;
      ArgValue =&#13;
          DAG.getCopyFromReg(Chain, DL, VReg, LocVT);</pre></li>				<li>In the definition of the calling convention, we added the rule that 8-bit and 16-bit values should be promoted to 32-bit, and we need to ensure the promotion here. To do so, a DAG node must be inserted, which makes sure that the value is promoted. After, the value is truncated to the right size. Note that we pass the value of <strong class="source-inline">ArgValue</strong> as an operand to the DAG node and store the result in the <span class="No-Break">same variable:</span><pre class="source-code">&#13;
      if (VA.getLocInfo() == CCValAssign::SExt)&#13;
        ArgValue = DAG.getNode(&#13;
            ISD::AssertSext, DL, LocVT, ArgValue,&#13;
            DAG.getValueType(VA.getValVT()));&#13;
      else if (VA.getLocInfo() == CCValAssign::ZExt)&#13;
        ArgValue = DAG.getNode(&#13;
            ISD::AssertZext, DL, LocVT, ArgValue,&#13;
            DAG.getValueType(VA.getValVT()));&#13;
      if (VA.getLocInfo() != CCValAssign::Full)&#13;
        ArgValue = DAG.getNode(ISD::TRUNCATE, DL,&#13;
                               VA.getValVT(), ArgValue);</pre></li>				<li>Lastly, we finish handling the register arguments by adding the DAG node to the <span class="No-Break">result vector:</span><pre class="source-code">&#13;
      InVals.push_back(ArgValue);&#13;
    }</pre></li>				<li>The other <a id="_idIndexMarker822"/>possible location for a parameter is on the stack. However, we didn’t define any load and store instructions, so we cannot handle this case yet. This ends the loop over all <span class="No-Break">argument locations:</span><pre class="source-code">&#13;
    } else {&#13;
      llvm_unreachable("Not implemented");&#13;
    }&#13;
  }</pre></li>				<li>After that, we may need to add code to handle variable argument lists. Again, we have added some code to remind us that we have not <span class="No-Break">implemented it:</span><pre class="source-code">&#13;
  assert(!IsVarArg &amp;&amp; "No<a id="_idTextAnchor200"/>t implemented");</pre></li>				<li>Finally, we must return the <span class="No-Break"><strong class="source-inline">Chain</strong></span><span class="No-Break"> argument:</span><pre class="source-code">&#13;
  return Chain;&#13;
}</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-190"><a id="_idTextAnchor201"/>Implementing DAG lowering – lowering return values</h2>&#13;
			<p>The return <a id="_idIndexMarker823"/>values are handled similarly. However, we must extend the target description for them. First, we need to define a new DAG node type called <strong class="source-inline">RET_GLUE</strong>. This DAG node type is used to glue the return values together, which prevents them from being rearranged, for example, by the instruction scheduler. The definition in <strong class="source-inline">M88kInstrInfo.td</strong> is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
def retglue : SDNode&lt;"M88kISD::RET_GLUE", SDTNone,&#13;
                 [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]&gt;;</pre>			<p>In the same file, we also define a pseudo-instruction to represent a return from a function call, which will be selected for a <span class="No-Break"><strong class="source-inline">RET_GLUE</strong></span><span class="No-Break"> node:</span></p>&#13;
			<pre class="source-code">&#13;
let isReturn = 1, isTerminator = 1, isBarrier = 1,&#13;
    AsmString = "RET" in&#13;
  def RET : Pseudo&lt;(outs), (ins), [(retglue)]&gt;;</pre>			<p>We will <a id="_idIndexMarker824"/>expand this pseudo-instruction when we generate <span class="No-Break">the output.</span></p>&#13;
			<p>With these definitions in place, we can implement the <span class="No-Break"><strong class="source-inline">LowerReturn()</strong></span><span class="No-Break"> method:</span></p>&#13;
			<ol>&#13;
				<li>The parameters are the same as for <strong class="source-inline">LowerFormalArguments()</strong>, only the order is <span class="No-Break">slightly different:</span><pre class="source-code">&#13;
SDValue M88kTargetLowering::LowerReturn(&#13;
    SDValue Chain, CallingConv::ID CallConv,&#13;
    bool IsVarArg,&#13;
    const SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs,&#13;
    const SmallVectorImpl&lt;SDValue&gt; &amp;OutVals,&#13;
    const SDLoc &amp;DL, SelectionDAG &amp;DAG) const {</pre></li>				<li>First, we call the generated code, this time using the <strong class="source-inline">RetCC_M88k</strong> <span class="No-Break">calling convention:</span><pre class="source-code">&#13;
  SmallVector&lt;CCValAssign, 16&gt; RetLocs;&#13;
  CCState RetCCInfo(CallConv, IsVarArg,&#13;
                    DAG.getMachineFunction(), RetLocs,&#13;
                    *DAG.getContext());&#13;
  RetCCInfo.AnalyzeReturn(Outs, RetCC_M88k);</pre></li>				<li>Then, we loop over the locations again. With the simple definition of the calling convention we currently have, this loop will be executed once at most. However, this would change if we would add support for returning 64-bit values, which need to be returned in <span class="No-Break">two registers:</span><pre class="source-code">&#13;
  SDValue Glue;&#13;
  SmallVector&lt;SDValue, 4&gt; RetOps(1, Chain);&#13;
  for (unsigned I = 0, E = RetLocs.size(); I != E; ++I) {&#13;
    CCValAssign &amp;VA = RetLocs[I];</pre></li>				<li>After, we copy <a id="_idIndexMarker825"/>the return values into the physical registers assigned to the return value. This is mostly similar to handling the arguments, with the exception that the values are glued together using the <span class="No-Break"><strong class="source-inline">Glue</strong></span><span class="No-Break"> variable:</span><pre class="source-code">&#13;
    Register Reg = VA.getLocReg();&#13;
    Chain = DAG.getCopyToReg(Chain, DL, Reg, OutVals[I],&#13;
                             Glue);&#13;
    Glue = Chain.getValue(1);&#13;
    RetOps.push_back(&#13;
        DAG.getRegister(Reg, VA.getLocVT()));&#13;
  }</pre></li>				<li>The return value is the chain and the glued register copy operations. The latter is only returned if there is a value <span class="No-Break">to return:</span><pre class="source-code">&#13;
  RetOps[0] = Chain;&#13;
  if (Glue.getNode())&#13;
    RetOps.push_back(Glue);</pre></li>				<li>Finally, we construct a DAG node of the <strong class="source-inline">RET_GLUE</strong> type, passing in the <span class="No-Break">necessary values:</span><pre class="source-code">&#13;
  return DAG.getNode(M88kISD::RET_GLUE, DL, MVT::Other,&#13;
                     RetOps);&#13;
}</pre></li>			</ol>&#13;
			<p>Congratulations! With these <a id="_idIndexMarker826"/>definitions, the foundation has been laid for <span class="No-Break">instruction selection.</span></p>&#13;
			<h2 id="_idParaDest-191"><a id="_idTextAnchor202"/>Implementing DAG-to-DAG transformations within instruction selection</h2>&#13;
			<p>One crucial <a id="_idIndexMarker827"/>part is still missing: we need to define the pass that performs the DAG transformations defined in the target descriptions. The class is called <strong class="source-inline">M88kDAGToDAGISel</strong> and is stored in the <strong class="source-inline">M88kISelDAGToDAG.cpp</strong> file. Most of the class is generated, but we still need to add <span class="No-Break">some code:</span></p>&#13;
			<ol>&#13;
				<li>We’ll begin by defining the debug type and providing a descriptive name for <span class="No-Break">the pass:</span><pre class="source-code">&#13;
#define DEBUG_TYPE "m88k-isel"&#13;
#define PASS_NAME&#13;
            "M88k DAG-&gt;DAG Pattern Instruction Selection"</pre></li>				<li>Then, we must declare the class inside an anonymous namespace. We will only override the <strong class="source-inline">Select()</strong> method; the other code is generated and included in the body of <span class="No-Break">the class:</span><pre class="source-code">&#13;
class M88kDAGToDAGISel : public SelectionDAGISel {&#13;
public:&#13;
  static char ID;&#13;
  M88kDAGToDAGISel(M88kTargetMachine &amp;TM,&#13;
                   CodeGenOpt::Level OptLevel)&#13;
      : SelectionDAGISel(ID, TM, OptLevel) {}&#13;
  void Select(SDNode *Node) override;&#13;
#include "M88kGenDAGISel.inc"&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>After, we must add the code to initialize the pass. The LLVM backends still use the legacy pass manager, and the setup differs from the pass manager used for IR transformations. The static member <strong class="source-inline">ID</strong> value is used to identify the pass. Initializing <a id="_idIndexMarker828"/>the pass can be implemented using the <strong class="source-inline">INITIALIZE_PASS</strong> macro, which expands to C++ code. We must also add a factory method to create an instance of <span class="No-Break">the pass:</span><pre class="source-code">&#13;
char M88kDAGToDAGISel::ID = 0;&#13;
INITIALIZE_PASS(M88kDAGToDAGISel, DEBUG_TYPE, PASS_NAME,&#13;
                false, false)&#13;
FunctionPass *&#13;
llvm::createM88kISelDag(M88kTargetMachine &amp;TM,&#13;
                        CodeGenOpt::Level OptLevel) {&#13;
  return new M88kDAGToDAGISel(TM, OptLevel);&#13;
}</pre></li>				<li>Finally, we must implement the <strong class="source-inline">Select()</strong> method. For now, we only call the generated code. However, if we encounter a complex transformation that we cannot express as a DAG pattern, then we can add our own code to perform the transformation before calling the <span class="No-Break">generated code:</span><pre class="source-code">&#13;
void M88kDAGToDAGISel::Select(SDNode *Node) {&#13;
  SelectCode(Node);&#13;
}</pre></li>			</ol>&#13;
			<p>With that, we have implemented the instruction selection. However, we still need to add some <a id="_idIndexMarker829"/>support classes before we can do the first test. We’ll look at those classes in the next <span class="No-Break">few sections.</span></p>&#13;
			<h1 id="_idParaDest-192"><a id="_idTextAnchor203"/>Adding register and instruction information</h1>&#13;
			<p>The target description captures most information about registers and instructions. To access <a id="_idIndexMarker830"/>that information, we must implement the <strong class="source-inline">M88kRegisterInfo</strong> and <strong class="source-inline">M88kInstrInfo</strong> classes. These classes also contain hooks that we can override to accomplish tasks that are too complex to express in the target description. Let’s begin with the <strong class="source-inline">M88kRegisterInfo</strong> class, which is declared in the <span class="No-Break"><strong class="source-inline">M88kRegisterInfo.h</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>The header file begins by including the code generated from the <span class="No-Break">target description:</span><pre class="source-code">&#13;
#define GET_REGINFO_HEADER&#13;
#include "M88kGenRegisterInfo.inc"</pre></li>				<li>After that, we must declare the <strong class="source-inline">M88kRegisterInfo</strong> class in the <strong class="source-inline">llvm</strong> namespace. We only override a couple <span class="No-Break">of methods:</span><pre class="source-code">&#13;
namespace llvm {&#13;
struct M88kRegisterInfo : public M88kGenRegisterInfo {&#13;
  M88kRegisterInfo();&#13;
  const MCPhysReg *getCalleeSavedRegs(&#13;
      const MachineFunction *MF) const override;&#13;
  BitVector getReservedRegs(&#13;
      const MachineFunction &amp;MF) const override;&#13;
  bool eliminateFrameIndex(&#13;
      MachineBasicBlock::iterator II, int SPAdj,&#13;
      unsigned FIOperandNum,&#13;
      RegScavenger *RS = nullptr) const override;&#13;
  Register getFrameRegister(&#13;
      const MachineFunction &amp;MF) const override;&#13;
};&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<p>The definition <a id="_idIndexMarker831"/>of the class is stored in the <span class="No-Break"><strong class="source-inline">M88kRegisterInfo.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>Again, the film begins with including the code generated from the <span class="No-Break">target description:</span><pre class="source-code">&#13;
#define GET_REGINFO_TARGET_DESC&#13;
#include "M88kGenRegisterInfo.inc"</pre></li>				<li>The constructor initializes the superclass, passing the register holding the return address as <span class="No-Break">a parameter:</span><pre class="source-code">&#13;
M88kRegisterInfo::M88kRegisterInfo()&#13;
    : M88kGenRegisterInfo(M88k::R1) {}</pre></li>				<li>Then, we implement the method that returns the list of callee-saved registers. We defined the list in the target description, and we only return <span class="No-Break">that list:</span><pre class="source-code">&#13;
const MCPhysReg *M88kRegisterInfo::getCalleeSavedRegs(&#13;
    const MachineFunction *MF) const {&#13;
  return CSR_M88k_SaveList;&#13;
}</pre></li>				<li>After, we deal with the reserved registers. The reserved registers depend on the platform and the hardware. The <strong class="source-inline">r0</strong> register contains a constant value of <strong class="source-inline">0</strong>, so we treat it <a id="_idIndexMarker832"/>as a reserved register. The <strong class="source-inline">r28</strong> and <strong class="source-inline">r29</strong> registers are always reserved for use by a linker. Lastly, the <strong class="source-inline">r31</strong> register is used as a stack pointer. This list may depend on the function, and it cannot be generated due to this <span class="No-Break">dynamic behavior:</span><pre class="source-code">&#13;
BitVector M88kRegisterInfo::getReservedRegs(&#13;
    const MachineFunction &amp;MF) const {&#13;
  BitVector Reserved(getNumRegs());&#13;
  Reserved.set(M88k::R0);&#13;
  Reserved.set(M88k::R28);&#13;
  Reserved.set(M88k::R29);&#13;
  Reserved.set(M88k::R31);&#13;
  return Reserved;&#13;
}</pre></li>				<li>If a frame register is required, then <strong class="source-inline">r30</strong> is used. Please note that our code does not support creating a frame yet. If the function requires a frame, then <strong class="source-inline">r30</strong> must also be marked as reserved in the <strong class="source-inline">getReservedRegs()</strong> method. However, we must implement this method because it is declared pure virtual in <span class="No-Break">the superclass:</span><pre class="source-code">&#13;
Register M88kRegisterInfo::getFrameRegister(&#13;
    const MachineFunction &amp;MF) const {&#13;
  return M88k::R30;&#13;
}</pre></li>				<li>Similarly, we need to implement the <strong class="source-inline">eliminateFrameIndex()</strong> method because it <a id="_idIndexMarker833"/>is declared <em class="italic">pure virtual</em>. It is called to replace a frame index in an operand with the correct value to use to address the value on <span class="No-Break">the stack:</span><pre class="source-code">&#13;
bool M88kRegisterInfo::eliminateFrameIndex(&#13;
    MachineBasicBlock::iterator MI, int SPAdj,&#13;
    unsigned FIOperandNum, RegScavenger *RS) const {&#13;
  return false;&#13;
}</pre></li>			</ol>&#13;
			<p>The <strong class="source-inline">M88kInstrInfo</strong> class has <a id="_idIndexMarker834"/>many hook methods we can override to accomplish special tasks, for example, for branch analysis and rematerialization. For now, we’re only overriding the <strong class="source-inline">expandPostRAPseudo()</strong> method, in which we expand the pseudo-instruction RET. Let’s begin with the header <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">M88kInstrInfo.h</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>The header file begins with including the <span class="No-Break">generated code:</span><pre class="source-code">&#13;
#define GET_INSTRINFO_HEADER&#13;
#include "M88kGenInstrInfo.inc"</pre></li>				<li>The <strong class="source-inline">M88kInstrInfo</strong> class derives from the generated <strong class="source-inline">M88kGenInstrInfo</strong> class. Besides overriding the <strong class="source-inline">expandPostRAPseudo()</strong> method, the only other addition is that this class owns an instance of the previously defined <span class="No-Break">class, </span><span class="No-Break"><strong class="source-inline">M88kRegisterInfo</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
namespace llvm {&#13;
class M88kInstrInfo : public M88kGenInstrInfo {&#13;
  const M88kRegisterInfo RI;&#13;
  [[maybe_unused]] M88kSubtarget &amp;STI;&#13;
  virtual void anchor();&#13;
public:&#13;
  explicit M88kInstrInfo(M88kSubtarget &amp;STI);&#13;
  const M88kRegisterInfo &amp;getRegisterInfo() const {&#13;
    return RI;&#13;
  }&#13;
  bool&#13;
  expandPostRAPseudo(MachineInstr &amp;MI) const override;&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<p>The implementation <a id="_idIndexMarker835"/>is stored in the <span class="No-Break"><strong class="source-inline">M88kInstrInfo.cpp</strong></span><span class="No-Break"> class:</span></p>&#13;
			<ol>&#13;
				<li>Like the header file, the implementation begins with including the <span class="No-Break">generated code:</span><pre class="source-code">&#13;
#define GET_INSTRINFO_CTOR_DTOR&#13;
#define GET_INSTRMAP_INFO&#13;
#include "M88kGenInstrInfo.inc"</pre></li>				<li>Then, we define the <strong class="source-inline">anchor()</strong> method, which is used to pin the vtable to <span class="No-Break">this file:</span><pre class="source-code">&#13;
void M88kInstrInfo::anchor() {}</pre></li>				<li>Finally, we expand <strong class="source-inline">RET</strong> in the <strong class="source-inline">expandPostRAPseudo()</strong> method. As its name suggests, this method is invoked after the register allocator runs and is intended to expand the pseudo-instruction, which may still be mixed with the machine code. If the opcode of the machine instruction, <strong class="source-inline">MI</strong>, is the pseudo-instruction, <strong class="source-inline">RET</strong>, we must insert the <strong class="source-inline">jmp %r1</strong> jump instruction, which is the instruction to exit a function. Then, we copy all implicit operands that represent the values to return and we delete the pseudo instruction. If we need other pseudo-instructions <a id="_idIndexMarker836"/>during code generation, then we can extend this function to expand them <span class="No-Break">here too:</span><pre class="source-code">&#13;
bool M88kInstrInfo::expandPostRAPseudo(&#13;
    MachineInstr &amp;MI) const {&#13;
  MachineBasicBlock &amp;MBB = *MI.getParent();&#13;
  switch (MI.getOpcode()) {&#13;
  default:&#13;
    return false;&#13;
  case M88k::RET: {&#13;
    MachineInstrBuilder MIB =&#13;
        BuildMI(MBB, &amp;MI, MI.getDebugLoc(),&#13;
                get(M88k::JMP))&#13;
            .addReg(M88k::R1, RegState::Undef);&#13;
    for (auto &amp;MO : MI.operands()) {&#13;
      if (MO.isImplicit())&#13;
        MIB.add(MO);&#13;
    }&#13;
    break;&#13;
  }&#13;
  }&#13;
  MBB.erase(MI);&#13;
  return true;&#13;
}</pre></li>			</ol>&#13;
			<p>Both classes <a id="_idIndexMarker837"/>have minimal implementations. If you continue to develop the target, then many more methods need to be overridden. It is worth reading the comments in the <strong class="source-inline">TargetInstrInfo</strong> and <strong class="source-inline">TargetRegisterInfo</strong> base classes, which you can find in the <span class="No-Break"><strong class="source-inline">llvm/include/llvm/CodeGen</strong></span><span class="No-Break"> directory.</span></p>&#13;
			<p>We still need more classes to get the instruction selection running. Next, we’ll look at <span class="No-Break">frame lowering.</span></p>&#13;
			<h1 id="_idParaDest-193"><a id="_idTextAnchor204"/>Putting an empty frame lowering in place</h1>&#13;
			<p>The binary interface of a platform not only defines how parameters are passed. It also includes how <a id="_idIndexMarker838"/>a stack frame is laid out: in which places are local variables stored, where registers are spilled to, and so on. Often, a special instruction sequence is <a id="_idIndexMarker839"/>required at the beginning and end of a function, called the <strong class="bold">prolog</strong> and the <strong class="bold">epilog</strong>. At the current <a id="_idIndexMarker840"/>development state, our target does not support the required machine instructions to create the prolog and the epilog. However, the framework code for instruction selection requires that a subclass of <strong class="source-inline">TargetFrameLowering</strong> is available. The easy solution is to provide the <strong class="source-inline">M88kFrameLowering</strong> class with an <span class="No-Break">empty implementation.</span></p>&#13;
			<p>The declaration of the class is in the <strong class="source-inline">M88kFrameLowering.h</strong> file. All we must do here is override the pure <span class="No-Break">virtual functions:</span></p>&#13;
			<pre class="source-code">&#13;
namespace llvm {&#13;
class M88kFrameLowering : public TargetFrameLowering {&#13;
public:&#13;
  M88kFrameLowering();&#13;
  void&#13;
  emitPrologue(MachineFunction &amp;MF,&#13;
               MachineBasicBlock &amp;MBB) const override;&#13;
  void&#13;
  emitEpilogue(MachineFunction &amp;MF,&#13;
               MachineBasicBlock &amp;MBB) const override;&#13;
  bool hasFP(const MachineFunction &amp;MF) const override;&#13;
};&#13;
}</pre>			<p>The implementation, which is stored in the <strong class="source-inline">M88kFrameLowering.cpp</strong> file, provides some basic details about stack frames in the constructor. The stack grows downwards, to smaller addresses, and is aligned on 8-byte boundaries. When a function is called, the local variables <a id="_idIndexMarker841"/>are stored directly below the stack pointer of the calling function, so the offset of the local area is <strong class="source-inline">0</strong>. Even during a function call, the stack should remain aligned at an 8-byte boundary. The last parameter implies that the stack cannot be realigned. The other functions just have an <span class="No-Break">empty implementation:</span></p>&#13;
			<pre class="source-code">&#13;
M88kFrameLowering::M88kFrameLowering()&#13;
    : TargetFrameLowering(&#13;
          TargetFrameLowering::StackGrowsDown, Align(8),&#13;
          0, Align(8), false /* StackRealignable */) {}&#13;
void M88kFrameLowering::emitPrologue(&#13;
    MachineFunction &amp;MF, MachineBasicBlock &amp;MBB) const {}&#13;
void M88kFrameLowering::emitEpilogue(&#13;
    MachineFunction &amp;MF, MachineBasicBlock &amp;MBB) const {}&#13;
bool M88kFrameLowering::hasFP(&#13;
    const MachineFunction &amp;MF) const { return false; }</pre>			<p>Of course, as soon <a id="_idIndexMarker842"/>as our implementation grows, this class will be one of the first that needs to be <span class="No-Break">fully implemented.</span></p>&#13;
			<p>Before we can put all the pieces together, we need to implement the assembly printer, which is used to emit <span class="No-Break">machine instructions.</span></p>&#13;
			<h1 id="_idParaDest-194"><a id="_idTextAnchor205"/>Emitting machine instructions</h1>&#13;
			<p>The instruction <a id="_idIndexMarker843"/>selection creates machine instructions, represented by the <strong class="source-inline">MachineInstr</strong> class, from LLVM IR. But this is not the end. An instance of the <strong class="source-inline">MachineInstr</strong> class still carries additional information, such as labels or flags. To emit an instruction via the machine code component, we need to lower the instances of <strong class="source-inline">MachineInstr</strong> to instances of <strong class="source-inline">MCInst</strong>. By doing this, the machine code component provides the functionality to write instructions into object files or print them as assembler text. The <strong class="source-inline">M88kAsmPrinter</strong> class is responsible for emitting a whole compilation unit. Lowering an instruction is delegated to the <span class="No-Break"><strong class="source-inline">M88kMCInstLower</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p>The assembly printer is the last pass to run in a backend. Its implementation is stored in the <span class="No-Break"><strong class="source-inline">M88kAsmPrinter.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>The declaration of the <strong class="source-inline">M88kAsmPrinter</strong> class is in an anonymous namespace. Besides the constructor, we only override the <strong class="source-inline">getPassName()</strong> function, which returns the name of the pass as a human-readable string, and the <span class="No-Break"><strong class="source-inline">emitInstruction()</strong></span><span class="No-Break"> function:</span><pre class="source-code">&#13;
namespace {&#13;
class M88kAsmPrinter : public AsmPrinter {&#13;
public:&#13;
  explicit M88kAsmPrinter(&#13;
      TargetMachine &amp;TM,&#13;
      std::unique_ptr&lt;MCStreamer&gt; Streamer)&#13;
      : AsmPrinter(TM, std::move(Streamer)) {}&#13;
  StringRef getPassName() const override {&#13;
    return "M88k Assembly Printer";&#13;
  }&#13;
  void emitInstruction(const MachineInstr *MI) override;&#13;
};&#13;
} // end of anonymous namespace</pre></li>				<li>Like many <a id="_idIndexMarker844"/>other classes, we have to register our assembly printer in the <span class="No-Break">target registry:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kAsmPrinter() {&#13;
  RegisterAsmPrinter&lt;M88kAsmPrinter&gt; X(&#13;
      getTheM88kTarget());&#13;
}</pre></li>				<li>The <strong class="source-inline">emitInstruction()</strong> method is responsible for emitting the machine instruction, <strong class="source-inline">MI</strong>, to the output stream. In our implementation, we delegate the lowering of the instruction to the <span class="No-Break"><strong class="source-inline">M88kMCInstLower</strong></span><span class="No-Break"> class:</span><pre class="source-code">&#13;
void M88kAsmPrinter::emitInstruction(&#13;
    const MachineInstr *MI) {&#13;
  MCInst LoweredMI;&#13;
  M88kMCInstLower Lower(MF-&gt;getContext(), *this);&#13;
  Lower.lower(MI, LoweredMI);&#13;
  EmitToStreamer(*OutStreamer, LoweredMI);&#13;
}</pre></li>			</ol>&#13;
			<p>This is already the full implementation. The base class, <strong class="source-inline">AsmPrinter</strong>, provides many useful hooks you can override. For example, the <strong class="source-inline">emitStartOfAsmFile()</strong> method is called before <a id="_idIndexMarker845"/>anything is emitted, and <strong class="source-inline">emitEndOfAsmFile()</strong> is called after everything is emitted. These methods can emit target-specific data or code at the beginning and the end of a file. Similarly, the <strong class="source-inline">emitFunctionBodyStart()</strong> and <strong class="source-inline">emitFunctionBodyEnd()</strong> methods are called before and after a function body is emitted. Read the comments in the <strong class="source-inline">llvm/include/llvm/CodeGen/AsmPrinter.h</strong> file to understand what can <span class="No-Break">be customized.</span></p>&#13;
			<p>The <strong class="source-inline">M88kMCInstLower</strong> class lowers operands and instructions, and our implementation contains two methods for that purpose. The declaration is in the <span class="No-Break"><strong class="source-inline">M88kMCInstLower.h</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
class LLVM_LIBRARY_VISIBILITY M88kMCInstLower {&#13;
public:&#13;
  void lower(const MachineInstr *MI, MCInst &amp;OutMI) const;&#13;
  MCOperand lowerOperand(const MachineOperand &amp;MO) const;&#13;
};</pre>			<p>The definition goes into the <span class="No-Break"><strong class="source-inline">M88kMCInstLower.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>To lower <strong class="source-inline">MachineOperand</strong> to <strong class="source-inline">MCOperand</strong>, we need to check the operand type. Here, we only handle registers and immediates by creating <strong class="source-inline">MCOperand</strong>-equivalent register and immediate values by supplying the original <strong class="source-inline">MachineOperand</strong> values. As soon as expressions are introduced as operands, this method needs to <span class="No-Break">be enhanced:</span><pre class="source-code">&#13;
MCOperand M88kMCInstLower::lowerOperand(&#13;
    const MachineOperand &amp;MO) const {&#13;
  switch (MO.getType()) {&#13;
  case MachineOperand::MO_Register:&#13;
    return MCOperand::createReg(MO.getReg());&#13;
  case MachineOperand::MO_Immediate:&#13;
    return MCOperand::createImm(MO.getImm());&#13;
  default:&#13;
    llvm_unreachable("Operand type not handled");&#13;
  }&#13;
}</pre></li>				<li>The lowering <a id="_idIndexMarker846"/>of an instruction is similar. First, the opcode is copied, and then the operands are handled. An instance of <strong class="source-inline">MachineInstr</strong> can have implicit operands attached, which are not lowered, and we need to <span class="No-Break">filter them:</span><pre class="source-code">&#13;
void M88kMCInstLower::lower(const MachineInstr *MI,&#13;
                            MCInst &amp;OutMI) const {&#13;
  OutMI.setOpcode(MI-&gt;getOpcode());&#13;
  for (auto &amp;MO : MI-&gt;operands()) {&#13;
    if (!MO.isReg() || !MO.isImplicit())&#13;
      OutMI.addOperand(lowerOperand(MO));&#13;
  }&#13;
}</pre></li>			</ol>&#13;
			<p>With that, we’ve implemented the assembly printer. Now, we need to bring all the pieces toget<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/>her. We’ll do this in the <span class="No-Break">next section.</span></p>&#13;
			<h1 id="_idParaDest-195"><a id="_idTextAnchor208"/>Creating the target machine and the sub-target</h1>&#13;
			<p>So far, we’ve implemented the instruction selection classes and a couple of other classes. Now, we need <a id="_idIndexMarker847"/>to set up how our backend will work. Like the optimization pipeline, a backend is divided into passes. Configuring those passes is the main task of the <strong class="source-inline">M88kTargetMachine</strong> class. In addition, we need to specify which <a id="_idIndexMarker848"/>features are available for instruction selection. Usually, a platform is a family of CPUs, which all have a common set of instructions but differ by specific extensions. For example, some CPUs have vector instructions, while others do not. In LLVM IR, a function can have attributes attached that specify for which CPU this function should be compiled, or what features are available. In other words, each function could have a different configuration, which is captured in the <span class="No-Break"><strong class="source-inline">M88kSubTarget</strong></span><span class="No-Break"> class.</span></p>&#13;
			<h2 id="_idParaDest-196"><a id="_idTextAnchor209"/>Implementing M88kSubtarget</h2>&#13;
			<p>Let’s <a id="_idIndexMarker849"/>implement the <strong class="source-inline">M88kSubtarget</strong> class first. The declaration is stored in the <span class="No-Break"><strong class="source-inline">M88kSubtarget.h</strong></span><span class="No-Break"> class:</span></p>&#13;
			<ol>&#13;
				<li>Parts of <a id="_idIndexMarker850"/>the sub-target are generated from the target description, and we include those <span class="No-Break">codes first:</span><pre class="source-code">&#13;
#define GET_SUBTARGETINFO_HEADER&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>				<li>Then, we declare the class, deriving it from the generated <strong class="source-inline">M88kGenSubtargetInfo</strong> class. The class owns a couple of previously defined classes – the instruction information, the target lowering class, and the frame <span class="No-Break">lowering class:</span><pre class="source-code">&#13;
namespace llvm {&#13;
class StringRef;&#13;
class TargetMachine;&#13;
class M88kSubtarget : public M88kGenSubtargetInfo {&#13;
  virtual void anchor();&#13;
  Triple TargetTriple;&#13;
  M88kInstrInfo InstrInfo;&#13;
  M88kTargetLowering TLInfo;&#13;
  M88kFrameLowering FrameLowering;</pre></li>				<li>The sub-target <a id="_idIndexMarker851"/>is initialized with the target triple, the name of the CPU, and a feature string, as well as with the target <a id="_idIndexMarker852"/>machine. All these parameters describe the hardware for which our backend will <span class="No-Break">generate code:</span><pre class="source-code">&#13;
public:&#13;
  M88kSubtarget(const Triple &amp;TT,&#13;
                const std::string &amp;CPU,&#13;
                const std::string &amp;FS,&#13;
                const TargetMachine &amp;TM);</pre></li>				<li>Next, we include the generated file again, this time for automatically defining getter methods for features defined in the <span class="No-Break">target description:</span><pre class="source-code">&#13;
#define GET_SUBTARGETINFO_MACRO(ATTRIBUTE, DEFAULT,    \&#13;
                                GETTER)                \&#13;
  bool GETTER() const { return ATTRIBUTE; }&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>				<li>In addition, we need to declare the <strong class="source-inline">ParseSubtargetFeatures()</strong> method. The method itself is generated from the <span class="No-Break">target description:</span><pre class="source-code">&#13;
  void ParseSubtargetFeatures(StringRef CPU,&#13;
                              StringRef TuneCPU,&#13;
                              StringRef FS);</pre></li>				<li>Next, we must <a id="_idIndexMarker853"/>add getter methods for the <a id="_idIndexMarker854"/><span class="No-Break">member variables:</span><pre class="source-code">&#13;
  const TargetFrameLowering *&#13;
  getFrameLowering() const override {&#13;
    return &amp;FrameLowering;&#13;
  }&#13;
  const M88kInstrInfo *getInstrInfo() const override {&#13;
    return &amp;InstrInfo;&#13;
  }&#13;
  const M88kTargetLowering *&#13;
  getTargetLowering() const override {&#13;
    return &amp;TLInfo;&#13;
  }</pre></li>				<li>Finally, we must add a getter method for the register information, which is owned by the instruction information class. This finishes <span class="No-Break">the declaration:</span><pre class="source-code">&#13;
  const M88kRegisterInfo *&#13;
  getRegisterInfo() const override {&#13;
    return &amp;InstrInfo.getRegisterInfo();&#13;
  }&#13;
};&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<p>Next, we must implement the actual subtarget class. The implementation is stored in the <span class="No-Break"><strong class="source-inline">M88kSubtarget.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>Again, we begin the file by including the <span class="No-Break">generated source:</span><pre class="source-code">&#13;
#define GET_SUBTARGETINFO_TARGET_DESC&#13;
#define GET_SUBTARGETINFO_CTOR&#13;
#include "M88kGenSubtargetInfo.inc"</pre></li>				<li>Then, we define the anchor method, which pins the vtable to <span class="No-Break">this file:</span><pre class="source-code">&#13;
void M88kSubtarget::anchor() {}</pre></li>				<li>Finally, we define <a id="_idIndexMarker855"/>the constructor. Note that <a id="_idIndexMarker856"/>the generated class expected two CPU parameters: the first one for the instruction set, and the second one for scheduling. The use case here is that you want to optimize the code for the latest CPU but still be able to run the code on an older CPU. We do not support this feature and use the same CPU name for <span class="No-Break">both parameters:</span><pre class="source-code">&#13;
M88kSubtarget::M88kSubtarget(const Triple &amp;TT,&#13;
                             const std::string &amp;CPU,&#13;
                             const std::string &amp;FS,&#13;
                             const TargetMachine &amp;TM)&#13;
    : M88kGenSubtargetInfo(TT, CPU, /*TuneCPU*/ CPU, FS),&#13;
      TargetTriple(TT), InstrInfo(*this),&#13;
      TLInfo(TM, *this), FrameLowering() {}</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-197"><a id="_idTextAnchor210"/>Implementing M88kTargetMachine – defining the definitions</h2>&#13;
			<p>Finally, we <a id="_idIndexMarker857"/>can implement the <strong class="source-inline">M88kTargetMachine</strong> class. This <a id="_idIndexMarker858"/>class holds all used sub-target instances. It also owns a subclass of <strong class="source-inline">TargetLoweringObjectFile</strong>, which provides details such as section names to the lowering process. Lastly, it creates the configuration of the passes that runs in <span class="No-Break">this backend.</span></p>&#13;
			<p>The declaration in the <strong class="source-inline">M88kTargetMachine.h</strong> file is <span class="No-Break">as follows:</span></p>&#13;
			<ol>&#13;
				<li>The <strong class="source-inline">M88kTargetMachine</strong> class derives from the <strong class="source-inline">LLVMTargetMachine</strong> class. The only members are an instance of <strong class="source-inline">TargetLoweringObjectFile</strong> and the <span class="No-Break">sub-target map:</span><pre class="source-code">&#13;
namespace llvm {&#13;
class M88kTargetMachine : public LLVMTargetMachine {&#13;
  std::unique_ptr&lt;TargetLoweringObjectFile&gt; TLOF;&#13;
  mutable StringMap&lt;std::unique_ptr&lt;M88kSubtarget&gt;&gt;&#13;
      SubtargetMap;</pre></li>				<li>The parameters of the constructor completely describe the target configuration for which <a id="_idIndexMarker859"/>we will generate code. With the <strong class="source-inline">TargetOptions</strong> class, many details of the code generations <a id="_idIndexMarker860"/>can be controlled – for example, if floating-point multiply-and-add instructions can be used or not. Also, the relocation model, the code model, and the optimization level are passed to the constructor. Notably, the <strong class="source-inline">JIT</strong> parameter is set to true if the target machine is used for <span class="No-Break">just-in-time compilation.</span><pre class="source-code">&#13;
public:&#13;
  M88kTargetMachine(const Target &amp;T, const Triple &amp;TT,&#13;
                    StringRef CPU, StringRef FS,&#13;
                    const TargetOptions &amp;Options,&#13;
                    std::optional&lt;Reloc::Model&gt; RM,&#13;
                    std::optional&lt;CodeModel::Model&gt; CM,&#13;
                    CodeGenOpt::Level OL, bool JIT);</pre></li>				<li>We also need to override some methods. The <strong class="source-inline">getSubtargetImpl()</strong> method <a id="_idIndexMarker861"/>returns the sub-target <a id="_idIndexMarker862"/>instance to use for the given function, and the <strong class="source-inline">getObjFileLowering()</strong> method just returns the member variable. In addition, we override the <strong class="source-inline">createPassConfig()</strong> method, which returns our configuration for the <span class="No-Break">backend passes:</span><pre class="source-code">&#13;
  ~M88kTargetMachine() override;&#13;
  const M88kSubtarget *&#13;
  getSubtargetImpl(const Function &amp;) const override;&#13;
  TargetPassConfig *&#13;
  createPassConfig(PassManagerBase &amp;PM) override;&#13;
  TargetLoweringObjectFile *&#13;
  getObjFileLowering() const override {&#13;
    return TLOF.get();&#13;
  }&#13;
};&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-198"><a id="_idTextAnchor211"/>Implementing M88kTargetMachine – adding the implementation</h2>&#13;
			<p>The implementation of the class is stored in the <strong class="source-inline">M88kTargetMachine.cpp</strong> file. Please note <a id="_idIndexMarker863"/>that we created this file in <a href="B19561_11.xhtml#_idTextAnchor177"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. Now, we <a id="_idIndexMarker864"/>will replace this file with a <span class="No-Break">complete implementation:</span></p>&#13;
			<ol>&#13;
				<li>First, we must register the target machine. In addition, we must initialize the DAG-to-DAG pass via the initialization function we <span class="No-Break">defined earlier:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void&#13;
LLVMInitializeM88kTarget() {&#13;
  RegisterTargetMachine&lt;M88kTargetMachine&gt; X(&#13;
      getTheM88kTarget());&#13;
  auto &amp;PR = *PassRegistry::getPassRegistry();&#13;
  initializeM88kDAGToDAGISelPass(PR);&#13;
}</pre></li>				<li>Next, we must define the support function, <strong class="source-inline">computeDataLayout()</strong>. We talked about <a id="_idIndexMarker865"/>the data layout string in <a href="B19561_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Basics of IR Code Generation</em>. In this function, the data layout, as the backend, expects it to be defined. Since the data layout depends <a id="_idIndexMarker866"/>on hardware features, the triple, the name of the CPU, and the feature set string are passed to this function. We create the data layout string with the following components. The target is big-endian (<strong class="source-inline">E</strong>) and uses the <strong class="source-inline">ELF</strong> <span class="No-Break">symbol mangling.</span><p class="list-inset">Pointers are 32-bit wide and 32-bit aligned. All scalar types are naturally aligned. The <strong class="source-inline">MC88110</strong> CPU has an extended register set and supports 80-bit wide floating points. If we were to support this special feature, then we’d need to add a check of the CPU name here and extend the string with the floating-point values accordingly. Next, we must state that all globals have a preferred alignment of 16-bit and that the <a id="_idTextAnchor212"/>hardware has only <span class="No-Break">32-bit registers:</span></p><pre class="source-code">&#13;
namespace {&#13;
std::string computeDataLayout(const Triple &amp;TT,&#13;
                              StringRef CPU,&#13;
                              StringRef FS) {&#13;
  std::string Ret;&#13;
  Ret += "E";&#13;
  Ret += DataLayout::getManglingComponent(TT);&#13;
  Ret += "-p:32:32:32";&#13;
  Ret += "-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64";&#13;
  Ret += "-f32:32:32-f64:64:64";&#13;
  Ret += "-a:8:16";&#13;
  Ret += "-n32";&#13;
  return Ret;&#13;
}&#13;
} // namespace</pre></li>				<li>Now, we can define the constructor and destructor. Many of the parameters are just passed <a id="_idIndexMarker867"/>to the superclass constructor. Note that our <strong class="source-inline">computeDataLayout()</strong> function is called here. In addition, the <strong class="source-inline">TLOF</strong> member is initialized with an instance of <strong class="source-inline">TargetLoweringObjectFileELF</strong>, since we are using the ELF file format. In the <a id="_idIndexMarker868"/>body of the constructor, we must call the <strong class="source-inline">initAsmInfo()</strong> method, which initializes many data members of <span class="No-Break">the superclass:</span><pre class="source-code">&#13;
M88kTargetMachine::M88kTargetMachine(&#13;
    const Target &amp;T, const Triple &amp;TT, StringRef CPU,&#13;
    StringRef FS, const TargetOptions &amp;Options,&#13;
    std::optional&lt;Reloc::Model&gt; RM,&#13;
    std::optional&lt;CodeModel::Model&gt; CM,&#13;
    CodeGenOpt::Level OL, bool JIT)&#13;
    : LLVMTargetMachine(&#13;
          T, computeDataLayout(TT, CPU, FS), TT, CPU,&#13;
          FS, Options, !RM ? Reloc::Static : *RM,&#13;
          getEffectiveCodeModel(CM, CodeModel::Medium),&#13;
          OL),&#13;
      TLOF(std::make_unique&lt;&#13;
           TargetLoweringObjectFileELF&gt;()) {&#13;
  initAsmInfo();&#13;
}&#13;
M88kTargetMachine::~M88kTargetMachine() {}</pre></li>				<li>After, we define the <strong class="source-inline">getSubtargetImpl()</strong> method. The sub-target instance to use <a id="_idIndexMarker869"/>depends on the <strong class="source-inline">target-cpu</strong> and <strong class="source-inline">target-features</strong> function attributes. For example, the <strong class="source-inline">target-cpu</strong> attribute <a id="_idIndexMarker870"/>could be set to <strong class="source-inline">MC88110</strong>, thus targeting the second-generation CPU. However, the attribute target feature could describe that we should not use the graphics instructions of that CPU. We have not defined the CPUs and their features in the target description yet, so we are doing a bit more than what’s necessary here. However, the implementation is simple enough: we query the function attributes and use either the returned strings or the default values. With this information, we can query the <strong class="source-inline">SubtargetMap</strong> member, and if it’s not found, we create <span class="No-Break">the sub-target:</span><pre class="source-code">&#13;
const M88kSubtarget *&#13;
M88kTargetMachine::getSubtargetImpl(&#13;
    const Function &amp;F) const {&#13;
  Attribute CPUAttr = F.getFnAttribute("target-cpu");&#13;
  Attribute FSAttr =&#13;
      F.getFnAttribute("target-features");&#13;
  std::string CPU =&#13;
      !CPUAttr.hasAttribute(Attribute::None)&#13;
          ? CPUAttr.getValueAsString().str()&#13;
          : TargetCPU;&#13;
  std::string FS = !FSAttr.hasAttribute(Attribute::None)&#13;
                       ? FSAttr.getValueAsString().str()&#13;
                       : TargetFS;&#13;
  auto &amp;I = SubtargetMap[CPU + FS];&#13;
  if (!I) {&#13;
    resetTargetOptions(F);&#13;
    I = std::make_unique&lt;M88kSubtarget&gt;(TargetTriple,&#13;
                                        CPU, FS, *this);&#13;
  }&#13;
  return I.get();&#13;
}</pre></li>				<li>Finally, we <a id="_idIndexMarker871"/>create the pass configuration. For this, we need our own class, <strong class="source-inline">M88kPassConfig</strong>, which derives <a id="_idIndexMarker872"/>from the <strong class="source-inline">TargetPassConfig</strong> class. We only override the <span class="No-Break"><strong class="source-inline">addInstSelector</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
namespace {&#13;
class M88kPassConfig : public TargetPassConfig {&#13;
public:&#13;
  M88kPassConfig(M88kTargetMachine &amp;TM,&#13;
                 PassManagerBase &amp;PM)&#13;
      : TargetPassConfig(TM, PM) {}&#13;
  bool addInstSelector() override;&#13;
};&#13;
} // namespace</pre></li>				<li>With <a id="_idIndexMarker873"/>this definition, we can implement the <strong class="source-inline">createPassConfig</strong> <span class="No-Break">factory method:</span><pre class="source-code">&#13;
TargetPassConfig *M88kTargetMachine::createPassConfig(&#13;
    PassManagerBase &amp;PM) {&#13;
  return new M88kPassConfig(*this, PM);&#13;
}</pre></li>				<li>Lastly, we <a id="_idIndexMarker874"/>must add our instruction selection class to the pass pipeline in the <strong class="source-inline">addInstSelector()</strong> method. The return value, <strong class="source-inline">false</strong>, indicates that we have added a pass that converts LLVM IR into <span class="No-Break">machine instructions:</span><pre class="source-code">&#13;
bool M88kPassConfig::addInstSelector() {&#13;
  addPass(createM88kISelDag(getTM&lt;M88kTargetMachine&gt;(),&#13;
                            getOptLevel()));&#13;
  return false;&#13;
}</pre></li>			</ol>&#13;
			<p>That was a long journey to finish the implementation! Now that we’ve built the <strong class="source-inline">llc</strong> tool, we can run an example. Save the following simple IR in the <span class="No-Break"><strong class="source-inline">and.ll</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
define i32 @f1(i32 %a, i32 %b) {&#13;
  %res = and i32 %a, %b&#13;
  ret i32 %res&#13;
}</pre>			<p>Now, we <a id="_idIndexMarker875"/>can run <strong class="source-inline">llc</strong> and verify that the generated <a id="_idIndexMarker876"/>assembly <span class="No-Break">looks reasonable:</span></p>&#13;
			<pre class="console">&#13;
$ llc -mtriple m88k-openbsd &lt; and.ll&#13;
        .text&#13;
        .file   "&lt;stdin&gt;"&#13;
        .globl  f1                              | -- Begin function f1&#13;
        .align  2&#13;
        .type   f1,@function&#13;
f1:                                     | @f1&#13;
| %bb.0:&#13;
        and %r2, %r2, %r3&#13;
        jmp %r1&#13;
.Lfunc_end0:&#13;
        .size   f1, .Lfunc_end0-f1&#13;
                                        | -- End function&#13;
        .section        ".note.GNU-stack","",@progbits</pre>			<p>To compile for the <strong class="source-inline">m88k</strong> target, we must specify the triple on the command line, as in this example, or in the <span class="No-Break">IR file.</span></p>&#13;
			<p>Enjoy your success for a bit before we look at global <span class="No-Break">instruction selection.</span></p>&#13;
			<h1 id="_idParaDest-199"><a id="_idTextAnchor213"/>Global instruction selection</h1>&#13;
			<p>Instruction selection via the selection DAG produces fast code, but it takes time to do so. The speed <a id="_idIndexMarker877"/>of the compiler is often critical for developers, who want to quickly try out the changes they’ve made. Usually, the compiler should be very fast at optimization level <strong class="source-inline">0</strong>, but it can take more time with increased optimization levels. However, constructing the selection DAG costs so much time that this approach does not scale as required. The first solution was to create another instruction selection algorithm called <strong class="source-inline">FastISel</strong>, which is fast but does not generate good code. It also does not share code with the selection DAG implementation, which is an obvious problem. Because of this, not all targets <span class="No-Break">support </span><span class="No-Break"><strong class="source-inline">FastISel</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The selection DAG approach does not scale because it is a large, monolithic algorithm. If we can avoid creating a new data structure such as the selection DAG, then we should be able to perform the instruction selection using small components. The backend already has a pass pipeline, so using passes is a natural choice. Based on these thoughts, GlobalISel performs the <span class="No-Break">following steps:</span></p>&#13;
			<ol>&#13;
				<li>First, the LLVM IR is lowered into generic machine instructions. Generic machine instructions represent the most common operation found in real hardware. Note that this translation uses the machine functions and machine basic blocks, which means it directly translates into the data structures used by the other parts of <span class="No-Break">the backend.</span></li>&#13;
				<li>The generic machine instructions are <span class="No-Break">then legalized.</span></li>&#13;
				<li>After, the operands of generic machine instructions are mapped to <span class="No-Break">register banks.</span></li>&#13;
				<li>Finally, the generic instructions are replaced with real machine instructions, using the patterns defined in the <span class="No-Break">target description.</span></li>&#13;
			</ol>&#13;
			<p>Since these are all passes, we can insert as many passes as we want in between. For example, a combiner pass could be used to replace a sequence of generic machine instructions with another generic machine instruction, or with a real machine instruction. Turning these additional passes off increases the compilation speed while turning them on improves the quality of the generated code. Hence, we can scale as <span class="No-Break">we need.</span></p>&#13;
			<p>There is another advantage in this approach. The selection DAG translates basic block by basic block, but a machine pass works on a machine function, which enables us to consider all <a id="_idIndexMarker878"/>basic blocks of a function during instruction selections. Therefore, this instruction selection method is called global instruction selection (GlobalISel). Let’s have a look at how this approach works, starting with the transformation <span class="No-Break">of calls.</span></p>&#13;
			<h2 id="_idParaDest-200"><a id="_idTextAnchor214"/>Lowering arguments and return values</h2>&#13;
			<p>For translating the LLVM IR to generic machine instructions, we only need to implement how <a id="_idIndexMarker879"/>arguments and return values are handled. Again, the implementation can be simplified by using the generated code from the target description. The class we’ll create is called <strong class="source-inline">M88kCallLowering</strong>, and the declaration is in the <strong class="source-inline">GISel/M88kCallLowering.h</strong> <span class="No-Break">header file:</span></p>&#13;
			<pre class="source-code">&#13;
class M88kCallLowering : public CallLowering {&#13;
public:&#13;
  M88kCallLowering(const M88kTargetLowering &amp;TLI);&#13;
  bool&#13;
  lowerReturn(MachineIRBuilder &amp;MIRBuilder,&#13;
              const Value *Val,&#13;
              ArrayRef&lt;Register&gt; VRegs,&#13;
              FunctionLoweringInfo &amp;FLI,&#13;
              Register SwiftErrorVReg) const override;&#13;
  bool lowerFormalArguments(&#13;
      MachineIRBuilder &amp;MIRBuilder, const Function &amp;F,&#13;
      ArrayRef&lt;ArrayRef&lt;Register&gt;&gt; VRegs,&#13;
      FunctionLoweringInfo &amp;FLI) const override;&#13;
  bool enableBigEndian() const override { return true; }&#13;
};</pre>			<p>The GlobalISel framework will call the <strong class="source-inline">lowerReturn()</strong> and <strong class="source-inline">lowerFormalArguments()</strong> methods when a function is translated. To translate a function call, you would need to override and implement the <strong class="source-inline">lowerCall()</strong> method as well. Please note that we also need to override <strong class="source-inline">enableBigEndian()</strong>. Without it, the wrong machine code would <span class="No-Break">be generated.</span></p>&#13;
			<p>For <a id="_idIndexMarker880"/>the implementation in the <strong class="source-inline">GISel/M88kCallLowering.cpp</strong> file, we need to define to support classes. The generated code from the target description tells us how a parameter is passed – for example, in a register. We need to create a subclass of <strong class="source-inline">ValueHandler</strong> to generate the machine instructions for it. For incoming parameters, we need to derive our class from <strong class="source-inline">IncomingValueHandler</strong>, as well as for the return value from <strong class="source-inline">OutgoingValueHandler</strong>. Both are very similar, so we’ll only look at the handler for <span class="No-Break">incoming arguments:</span></p>&#13;
			<pre class="source-code">&#13;
namespace {&#13;
struct FormalArgHandler&#13;
    : public CallLowering::IncomingValueHandler {&#13;
  FormalArgHandler(MachineIRBuilder &amp;MIRBuilder,&#13;
                   MachineRegisterInfo &amp;MRI)&#13;
      : CallLowering::IncomingValueHandler(MIRBuilder,&#13;
                                           MRI) {}&#13;
  void assignValueToReg(Register ValVReg,&#13;
                        Register PhysReg,&#13;
                        CCValAssign VA) override;&#13;
  void assignValueToAddress(Register ValVReg,&#13;
                            Register Addr, LLT MemTy,&#13;
                            MachinePointerInfo &amp;MPO,&#13;
                            CCValAssign &amp;VA) override{};&#13;
  Register&#13;
  getStackAddress(uint64_t Size, int64_t Offset,&#13;
                  MachinePointerInfo &amp;MPO,&#13;
                  ISD::ArgFlagsTy Flags) override {&#13;
    return Register();&#13;
  };&#13;
};&#13;
} // namespace</pre>			<p>So far, we can only handle parameters passed in registers, so we must provide a dummy implementation for the other methods. The <strong class="source-inline">assignValueToReg()</strong> method copies the <a id="_idIndexMarker881"/>value of the incoming physical register to a virtual register, performing a truncation if necessary. All we have to do here is mark the physical register as live-in to the function, and call the <span class="No-Break">superclass implementation:</span></p>&#13;
			<pre class="source-code">&#13;
void FormalArgHandler::assignValueToReg(&#13;
    Register ValVReg, Register PhysReg,&#13;
    CCValAssign VA) {&#13;
  MIRBuilder.getMRI()-&gt;addLiveIn(PhysReg);&#13;
  MIRBuilder.getMBB().addLiveIn(PhysReg);&#13;
  CallLowering::IncomingValueHandler::assignValueToReg(&#13;
      ValVReg, PhysReg, VA);&#13;
}</pre>			<p>Now, we can implement the <span class="No-Break"><strong class="source-inline">lowerFormalArgument()</strong></span><span class="No-Break"> method:</span></p>&#13;
			<ol>&#13;
				<li>First, the parameters of the <strong class="source-inline">IR</strong> function are translated into instances of the <strong class="source-inline">ArgInfo</strong> class. The <strong class="source-inline">setArgFlags()</strong> and <strong class="source-inline">splitToValueTypes()</strong> framework <a id="_idIndexMarker882"/>methods help with copying the parameter attributes and splitting the value type in case an incoming argument needs more than one <span class="No-Break">virtual register:</span><pre class="source-code">&#13;
bool M88kCallLowering::lowerFormalArguments(&#13;
    MachineIRBuilder &amp;MIRBuilder, const Function &amp;F,&#13;
    ArrayRef&lt;ArrayRef&lt;Register&gt;&gt; VRegs,&#13;
    FunctionLoweringInfo &amp;FLI) const {&#13;
  MachineFunction &amp;MF = MIRBuilder.getMF();&#13;
  MachineRegisterInfo &amp;MRI = MF.getRegInfo();&#13;
  const auto &amp;DL = F.getParent()-&gt;getDataLayout();&#13;
  SmallVector&lt;ArgInfo, 8&gt; SplitArgs;&#13;
  for (const auto &amp;[I, Arg] :&#13;
       llvm::enumerate(F.args())) {&#13;
    ArgInfo OrigArg{VRegs[I], Arg.getType(),&#13;
                    static_cast&lt;unsigned&gt;(I)};&#13;
    setArgFlags(OrigArg,&#13;
                I + AttributeList::FirstArgIndex, DL,&#13;
                F);&#13;
    splitToValueTypes(OrigArg, SplitArgs, DL,&#13;
                      F.getCallingConv());&#13;
  }</pre></li>				<li>With the arguments prepared in the <strong class="source-inline">SplitArgs</strong> variable, we are ready to generate <a id="_idIndexMarker883"/>the machine code. This is all done by the framework code, with the help of the generated calling convention, <strong class="source-inline">CC_M88k</strong>, and our helper <span class="No-Break">class, </span><span class="No-Break"><strong class="source-inline">FormalArghandler</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
  IncomingValueAssigner ArgAssigner(CC_M88k);&#13;
  FormalArgHandler ArgHandler(MIRBuilder, MRI);&#13;
  return determineAndHandleAssignments(&#13;
      ArgHandler, ArgAssigner, SplitArgs, MIRBuilder,&#13;
      F.getCallingConv(), F.isVarArg());&#13;
}</pre></li>			</ol>&#13;
			<p>Return values are handled similarly, with the main difference being that one value is returned at most. The next task is to legalize the generic <span class="No-Break">machine instructions.</span></p>&#13;
			<h2 id="_idParaDest-201"><a id="_idTextAnchor215"/>Legalizing the generic machine instructions</h2>&#13;
			<p>The translation from LLVM IR to generic machine code is mostly fixed. As a result, instructions can be generated that use unsupported data types, among other challenges. The task of the legalizer pass is to define which operations and instructions are legal. With this information, the GlobalISel framework tries to transform the instructions <a id="_idIndexMarker884"/>into a legal form. For example, the m88k architecture only has 32-bit registers, so a bitwise <strong class="source-inline">and</strong> operation with 64-bit values is not legal. However, if we split the 64-bit value into two 32-bit values, and use two bitwise <strong class="source-inline">and</strong> operations instead, then we have legal code. This can be translated into a <span class="No-Break">legalization rule:</span></p>&#13;
			<pre class="source-code">&#13;
  getActionDefinitionsBuilder({G_AND, G_OR, G_XOR})&#13;
      .legalFor({S32})&#13;
      .clampScalar(0, S32, S32);</pre>			<p>Whenever the legalizer pass processes a <strong class="source-inline">G_AND</strong> instruction, then it is legal if all operands are 32-bit wide. Otherwise, the operands are clamped to 32-bit, effectively splitting larger values into multiple 32-bit values, and the rule is applied again. If an instruction cannot be legalized, then the backend terminates with an <span class="No-Break">error message.</span></p>&#13;
			<p>All <a id="_idIndexMarker885"/>legalization rules are defined in the constructor of the <strong class="source-inline">M88kLegalizerInfo</strong> class, which makes the class <span class="No-Break">very simple.</span></p>&#13;
			<p class="callout-heading">What does legal mean?</p>&#13;
			<p class="callout">In GlobalISel, a generic instruction is legal if it can be translated by the instruction selector. This gives us more freedom in the implementation. For example, we can state that an instruction works on a bit value, even if the hardware only operates on 32-bit values, so long as the instruction selector can handle the <span class="No-Break">type correctly.</span></p>&#13;
			<p>The next pass we need to look at is the register <span class="No-Break">bank selector.</span></p>&#13;
			<h2 id="_idParaDest-202"><a id="_idTextAnchor216"/>Selecting a register bank for operands</h2>&#13;
			<p>Many architectures define several register banks. A register bank is a set of registers. Typical <a id="_idIndexMarker886"/>register banks are general-purpose register banks and floating-point register banks. Why is this information important? Moving a value from one register to another is usually cheap inside a register bank, but copying the value to another register bank can be costly or impossible. Thus, we must select a good register bank for <span class="No-Break">each operand.</span></p>&#13;
			<p>The implementation of this class involves an addition to the target description. In the <strong class="source-inline">GISel/M88lRegisterbanks.td</strong> file, we define our single register bank, referencing the register classes we <span class="No-Break">have defined:</span></p>&#13;
			<pre class="source-code">&#13;
def GRRegBank : RegisterBank&lt;"GRRB", [GPR, GPR64]&gt;;</pre>			<p>From this line, some support code is generated. However, we still need to add some code that could be potentially generated. First, we need to define partial mappings. This tells the framework at which bit index a value begins, how wide it is, and to which register bank it maps. We have two entries, one for each <span class="No-Break">register class:</span></p>&#13;
			<pre class="source-code">&#13;
RegisterBankInfo::PartialMapping&#13;
    M88kGenRegisterBankInfo::PartMappings[]{&#13;
        {0, 32, M88k::GRRegBank},&#13;
        {0, 64, M88k::GRRegBank},&#13;
    };</pre>			<p>To index this array, we must define <span class="No-Break">an enumeration:</span></p>&#13;
			<pre class="source-code">&#13;
enum PartialMappingIdx { PMI_GR32 = 0, PMI_GR64, };</pre>			<p>Since we <a id="_idIndexMarker887"/>have only three address instructions, we need three partial mappings, one for each operand. We must create an array with all those pointers, with the first entry denoting an <span class="No-Break">invalid mapping:</span></p>&#13;
			<pre class="source-code">&#13;
RegisterBankInfo::ValueMapping&#13;
    M88kGenRegisterBankInfo::ValMappings[]{&#13;
        {nullptr, 0},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},&#13;
        {&amp;M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},&#13;
    };</pre>			<p>To access that array, we must define <span class="No-Break">a function:</span></p>&#13;
			<pre class="source-code">&#13;
const RegisterBankInfo::ValueMapping *&#13;
M88kGenRegisterBankInfo::getValueMapping(&#13;
    PartialMappingIdx RBIdx) {&#13;
  return &amp;ValMappings[1 + 3*RBIdx];&#13;
}</pre>			<p>When creating these tables, it is easy to make errors. At first glance, all this information can be <a id="_idIndexMarker888"/>derived from the target description, and a comment in the source states that this code should be generated by TableGen! However, this hasn’t been implemented yet, so we have to create the <span class="No-Break">code manually.</span></p>&#13;
			<p>The most important function we have to implement in the <strong class="source-inline">M88kRegisterBankInfo</strong> class is <strong class="source-inline">getInstrMapping()</strong>, which returns the mapped register banks for each operand of the instruction. This now becomes easy because we can look up the array of partial mappings, which we can then pass to the <strong class="source-inline">getInstructionMapping()</strong> method, which constructs the full <span class="No-Break">instruction mapping:</span></p>&#13;
			<pre class="source-code">&#13;
const RegisterBankInfo::InstructionMapping &amp;&#13;
M88kRegisterBankInfo::getInstrMapping(&#13;
    const MachineInstr &amp;MI) const {&#13;
  const ValueMapping *OperandsMapping = nullptr;&#13;
  switch (MI.getOpcode()) {&#13;
  case TargetOpcode::G_AND:&#13;
  case TargetOpcode::G_OR:&#13;
  case TargetOpcode::G_XOR:&#13;
    OperandsMapping = getValueMapping(PMI_GR32);&#13;
    break;&#13;
  default:&#13;
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)&#13;
    MI.dump();&#13;
#endif&#13;
    return getInvalidInstructionMapping();&#13;
  }&#13;
  return getInstructionMapping(DefaultMappingID, /*Cost=*/1,&#13;
                               OperandsMapping,&#13;
                               MI.getNumOperands());&#13;
}</pre>			<p>During development, it is common to forget the register bank mapping for a generic instruction. Unfortunately, the error message that’s generated at runtime does not mention <a id="_idIndexMarker889"/>for which instruction the mapping failed. The easy fix is to dump the instruction before returning the invalid mapping. However, we need to be careful here because the <strong class="source-inline">dump()</strong> method is not available in all <span class="No-Break">build types.</span></p>&#13;
			<p>After mapping the register banks, we must translate the generic machine instructions into real <span class="No-Break">machine instructions.</span></p>&#13;
			<h2 id="_idParaDest-203"><a id="_idTextAnchor217"/>Translating generic machine instructions</h2>&#13;
			<p>For instruction selection via the selection DAG, we added patterns to the target description, which use DAG operations and operands. To reuse those patterns, a mapping <a id="_idIndexMarker890"/>from DAG node types to generic machine instructions was introduced. For example, the DAG <strong class="source-inline">and</strong> operation maps to the generic <strong class="source-inline">G_AND</strong> machine instruction. Not all DAG operations have an equivalent generic machine instruction; however, the most common cases are covered. Therefore, it is beneficial to define all code selection patterns in the <span class="No-Break">target description.</span></p>&#13;
			<p>Most of the implementation of the <strong class="source-inline">M88kInstructionSelector</strong> class, which can be found in the <strong class="source-inline">GISel/M88kInstructionSelector.cpp</strong> file, is generated from the target description. However, we need to override the <strong class="source-inline">select()</strong> method, which allows us to translate generic machine instructions that are not covered by the patterns in the target description. Since we only support a very small subset of generic instructions, we can simply call the generated <span class="No-Break">pattern matcher:</span></p>&#13;
			<pre class="source-code">&#13;
bool M88kInstructionSelector::select(MachineInstr &amp;I) {&#13;
  if (selectImpl(I, *CoverageInfo))&#13;
    return true;&#13;
  return false;&#13;
}</pre>			<p>With <a id="_idIndexMarker891"/>the instruction selection implemented, we can translate LLVM IR <span class="No-Break">using GlobalISel!</span></p>&#13;
			<h2 id="_idParaDest-204"><a id="_idTextAnchor218"/>Running an example</h2>&#13;
			<p>To translate LLVM IR using GlobalISel, we need to add the <strong class="source-inline">-global-isel</strong> option to the command <a id="_idIndexMarker892"/>line of <strong class="source-inline">llc</strong>. For example, you can use the previously defined IR <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">and.ll</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="console">&#13;
$ llc -mtriple m88k-openbsd -global-isel &lt; and.ll</pre>			<p>The printed assembly text is the same. To convince ourselves that the translation uses GlobalISel, we must take advantage of the fact that we can stop the translation after a specified pass is run with the <strong class="source-inline">-stop-after=</strong> option. For example, to see the generic instructions after legalization, you would run the <span class="No-Break">following command:</span></p>&#13;
			<pre class="console">&#13;
$ llc -mtriple m88k-openbsd -global-isel &lt; and.ll \&#13;
  -stop-after=legalizer</pre>			<p>The ability to stop after (or before) a pass is run is another advantage of GlobalISel because it makes it easy to debug and test <span class="No-Break">the implementation.</span></p>&#13;
			<p>At this point, we have a working backend that can translate some LLVM IR into machine code for the m<a id="_idTextAnchor219"/>88k architecture. Let’s think about how to move from here to a more <span class="No-Break">complete backend.</span></p>&#13;
			<h1 id="_idParaDest-205"><a id="_idTextAnchor220"/>How to further evolve the backend</h1>&#13;
			<p>With the code from this and the previous chapter, we have created a backend that can translate <a id="_idIndexMarker893"/>some LLVM IR into machine code. It is very satisfying to see the backend working, but it is far from being usable for serious tasks. Much more coding is needed. Here is a recipe for how you can further evolve <span class="No-Break">the backend:</span></p>&#13;
			<ul>&#13;
				<li>The first decision you should make is if you want to use GlobalISel or the selection DAG. In our experience, GlobalISel is easier to understand and develop, but all targets in the LLVM source tree implement the selection DAG, and you may already have experience in <span class="No-Break">using it.</span></li>&#13;
				<li>Next, you should define the instructions for adding and subtracting integer values, which can be done similarly to the bitwise <span class="No-Break"><strong class="source-inline">and</strong></span><span class="No-Break"> instruction.</span></li>&#13;
				<li>After, you should implement the load and store instructions. This is more involved since you need to translate the different addressing modes. Most likely, you will deal with indexing, for example, to address an element of an array, which most likely requires the previously defined instruction <span class="No-Break">for addition.</span></li>&#13;
				<li>Finally, you can fully implement frame lowering and call lowering. At this point, you can translate a simple “Hello, world!” style application into a <span class="No-Break">running program.</span></li>&#13;
				<li>The next logical step is to implement branch instructions, which enable the translation of loops. To generate optimal code, you need to implement the branch analyzing methods in the instruction <span class="No-Break">information class.</span></li>&#13;
			</ul>&#13;
			<p>When you reach this point, your backend can already translate simple algorithms. You should also have gained enough experience to develop the missing parts based on <span class="No-Break">your priorities.</span></p>&#13;
			<h1 id="_idParaDest-206"><a id="_idTextAnchor221"/>Summary</h1>&#13;
			<p> In this chapter, you added two different instruction selections to your backend: instruction selection via the selection DAG, and global instruction selection. For this, you had to define the calling convention in the target description. In addition, you needed to implement register and instruction information classes, which give you access to information generated from the target description but which you also needed to enhance with additional information. You learned that the stack frame layout and prolog generation are needed later. To translate an example, you added a class to emit machine instructions, and you created the configuration of the backend. You also learned how global instruction selection works. Finally, you gained some guidance on how you can develop the backend on <span class="No-Break">your own.</span></p>&#13;
			<p>In the next chapter, we will look at some tasks that can be done after instruction selection – we will add a new pass in the pipeline of the backend, look at how to integrate the backend into the clang compiler, and how to cross-compile to a <span class="No-Break">different architecture.</span></p>&#13;
		</div>&#13;
	</div></body></html>