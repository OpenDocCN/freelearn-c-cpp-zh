["```cpp\ncmake . && cmake —build .\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\nusing namespace std::chrono_literals;\nboost::asio::io_context io_context;\nboost::asio::steady_timer timer(io_context, 3s);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\nvoid on_timeout(const boost::system::error_code& ec) {\n    if (!ec) {\n        std::cout << \"Timer expired.\\n\" << std::endl;\n    } else {\n        std::cerr << \"Error: \" << ec.message() << '\\n';\n    }\n}\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context,\n                              std::chrono::seconds(3));\n    timer.async_wait(&on_timeout);\n    io_context.run();\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid background_task(boost::asio::io_context& io_context) {\n    std::this_thread::sleep_for(2s);\n    std::cout << \"Posting a background task.\\n\";\n    io_context.post([]() {\n        std::cout << \"Background task completed!\\n\";\n    });\n}\n```", "```cpp\nint main() {\n    boost::asio::io_context io_context;\n    auto work_guard = boost::asio::make_work_guard(\n                      io_context);\n    std::thread io_thread([&io_context]() {\n        std::cout << \"Running io_context.\\n\";\n        io_context.run();\n        std::cout << \"io_context stopped.\\n\";\n    });\n    std::thread worker(background_task,\n                       std::ref(io_context));\n    // Main thread doing some work.\n    std::this_thread::sleep_for(5s);\n    std::cout << \"Removing work_guard.\" << std::endl;\n    work_guard.reset();\n    worker.join();\n    io_thread.join();\n    return 0;\n}\n```", "```cpp\nRunning io_context.\nPosting a background task.\nBackground task completed!\nRemoving work_guard.\nio_context stopped.\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <functional>\n#include <iostream>\nusing namespace std::chrono_literals;\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context, 3s);\n    std::function<void(const boost::system::error_code&)>\n                  timer_handler;\n    timer_handler = [&timer, &timer_handler](\n                     const boost::system::error_code& ec) {\n        if (!ec) {\n            std::cout << \"Handler: Timer expired.\\n\";\n            timer.expires_after(1s);\n            timer.async_wait(timer_handler);\n        } else {\n            std::cerr << \"Handler error: \"\n                      << ec.message() << std::endl;\n        }\n    };\n    timer.async_wait(timer_handler);\n    io_context.run();\n    return 0;\n}\n```", "```cpp\nboost::asio::io_context io_context;\nio_context.post([] {\n    std::cout << \"This will always run asynchronously.\\n\";\n});\n```", "```cpp\nboost::asio::io_context io_context;\nio_context.dispatch([] {\n    std::cout << \"This might run immediately or be queued.\\n\";\n});\n```", "```cpp\nboost::asio::io_context io_context;\nboost::asio::steady_timer timer(io_context, 3s);\ntimer.wait();\n```", "```cpp\nboost::system::error_code ec;\nTimer.wait(server_endpoint, ec);\n```", "```cpp\nvoid completion_handler(\n     const boost::system::error_code& ec);\n```", "```cpp\nsocket.async_wait(completion_handler);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <future>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context, 1s);\n    auto fut = timer.async_wait(\n                     boost::asio::use_future);\n    std::thread io_thread([&io_context]() {\n                        io_context.run();\n    });\n    std::this_thread::sleep_for(3s);\n    timer.cancel();\n    try {\n        fut.get();\n        std::cout << \"Timer expired successfully!\\n\";\n    } catch (const boost::system::system_error& e) {\n        std::cout << \"Timer failed: \"\n                  << e.code().message() << '\\n';\n    }\n    io_thread.join();\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\nusing namespace std::chrono_literals;\nvoid handle_timer_expiry(\n            const boost::system::error_code& ec) {\n    if (!ec) {\n        std::cout << \"Timer expired!\\n\";\n    } else {\n        std::cerr << \"Error in timer: \"\n                  << ec.message() << std::endl;\n    }\n}\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context,\n                              std::chrono::seconds(1));\n    timer.async_wait(&handle_timer_expiry);\n    io_context.run();\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <thread>\nvoid long_running_task(boost::asio::io_context& io_context,\n                       int task_duration) {\n    std::cout << \"Background task started: Duration = \"\n              << task_duration << \" seconds.\\n\";\n    std::this_thread::sleep_for(\n                      std::chrono::seconds(task_duration));\n    io_context.post([&io_context]() {\n        std::cout << \"Background task completed.\\n\";\n        io_context.stop();\n    });\n}\nint main() {\n    boost::asio::io_context io_context;\n    auto work_guard = boost::asio::make_work_guard\n                                        (io_context);\n    io_context.post([&io_context]() {\n        std::thread t(long_running_task,\n                      std::ref(io_context), 2);\n        std::cout << \"Detaching thread\" << std::endl;\n        t.detach();\n    });\n    std::cout << \"Running io_context...\\n\";\n    io_context.run();\n    std::cout << \"io_context exit.\\n\";\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nvoid background_task(int i) {\n    sync_cout << \"Thread \" << i << \": Starting...\\n\";\n    boost::asio::io_context io_context;\n    auto work_guard =\n              boost::asio::make_work_guard(io_context);\n    sync_cout << \"Thread \" << i << \": Setup timer...\\n\";\n    boost::asio::steady_timer timer(io_context, 1s);\n    timer.async_wait(\n        [&](const boost::system::error_code& ec) {\n            if (!ec) {\n                sync_cout << \"Timer expired successfully!\"\n                          << std::endl;\n            } else {\n                sync_cout << \"Timer error: \"\n                          << ec.message() << ‚\\n';\n        }\n        work_guard.reset();\n    });\n    sync_cout << \"Thread \" << i << \": Running\n                      io_context...\\n\";\n    io_context.run();\n}\nint main() {\n    const int num_threads = 4;\n    std::vector<std::jthread> threads;\n    for (auto i = 0; i < num_threads; ++i) {\n        threads.emplace_back(background_task, i);\n    }\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\n#include <syncstream>\n#include <thread>\n#include <vector>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nvoid background_task(int task_id) {\n    boost::asio::post([task_id]() {\n        sync_cout << \"Task \" << task_id\n                  << \" is being handled in thread \"\n                  << std::this_thread::get_id()\n                  << std::endl;\n        std::this_thread::sleep_for(2s);\n        sync_cout << \"Task \" << task_id\n                  << \" complete.\\n\";\n    });\n}\nint main() {\n    boost::asio::io_context io_context;\n    auto work_guard = boost::asio::make_work_guard(\n                                   io_context);\n    std::jthread io_context_thread([&io_context]() {\n        io_context.run();\n    });\n    const int num_threads = 4;\n    std::vector<std::jthread> threads;\n    for (int i = 0; i < num_threads; ++i) {\n        background_task(i);\n    }\n    std::this_thread::sleep_for(5s);\n    work_guard.reset();\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <thread>\n#include <vector>\nusing namespace std::chrono_literals;\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context, 2s);\n    timer.async_wait(\n        [](const boost::system::error_code& /*ec*/) {\n            std::cout << \"Timer expired!\\n\";\n    });\n    const std::size_t num_threads =\n                std::thread::hardware_concurrency();\n    std::vector<std::thread> threads;\n    for (std::size_t i = 0;\n         i < std::thread::hardware_concurrency(); ++i) {\n            threads.emplace_back([&io_context]() {\n                io_context.run();\n            });\n    }\n    for (auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <memory>\nconstexpr int port = 1234;\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        EchoServer server(io_context, port);\n        io_context.run();\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n    return 0;\n}\n```", "```cpp\nusing boost::asio::ip::tcp;\nclass EchoServer {\n   public:\n    EchoServer(boost::asio::io_context& io_context,\n               short port)\n        : acceptor_(io_context,\n                    tcp::endpoint(tcp::v4(),\n                    port)) {\n        do_accept();\n    }\n   private:\n    void do_accept() {\n        acceptor_.async_accept([this](\n                    boost::system::error_code ec,\n                    tcp::socket socket) {\n            if (!ec) {\n                std::make_shared<Session>(\n                    std::move(socket))->start();\n            }\n            do_accept();\n        });\n    }\n    tcp::acceptor acceptor_;\n};\n```", "```cpp\nclass Session\n    : public std::enable_shared_from_this<Session>\n{\n   public:\n    Session(tcp::socket socket)\n        : socket_(std::move(socket)) {}\n    void start() { do_read(); }\n   private:\n    static const size_t max_length = 1024;\n    void do_read();\n    void do_write(std::size_t length);\n    tcp::socket socket_;\n    char data_[max_length];\n};\n```", "```cpp\nvoid Session::do_read() {\n    auto self(shared_from_this());\n    socket_.async_read_some(boost::asio::buffer(data_,\n                                          max_length),\n        [this, self](boost::system::error_code ec,\n                     std::size_t length) {\n            if (!ec) {\n                do_write(length);\n            }\n        });\n}\n```", "```cpp\nvoid Session::do_write(std::size_t length) {\n    auto self(shared_from_this());\n    boost::asio::async_write(socket_,\n                             boost::asio::buffer(data_,\n                                                length),\n        [this, self](boost::system::error_code ec,\n                     std::size_t length) {\n            if (!ec) {\n                do_read();\n            }\n        });\n}\n```", "```cpp\n$ telnet localhost 1234\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nHello world!\nHello world!\ntelnet> quit\nConnection closed.\n```", "```cpp\nchar data[1024];\nmutable_buffer buffer = buffer(data, sizeof(data));\n```", "```cpp\nstd::array<char, 128> buf1, buf2;\nstd::vector<boost::asio::mutable_buffer> buffers = {\n    boost::asio::buffer(buf1),\n    boost::asio::buffer(buf2)\n};\nsocket.async_read_some(buffers, handler);\n```", "```cpp\nstd::array<char, 128> buf1, buf2;\nstd::vector<boost::asio::const_buffer> buffers = {\n    boost::asio::buffer(buf1),\n    boost::asio::buffer(buf2)\n};\nsocket.async_write_some(buffers, handler);\n```", "```cpp\n#include <array>\n#include <iostream>\n#include <boost/asio.hpp>\n#include <boost/asio/streambuf.hpp>\nusing boost::asio::ip::tcp;\nconstexpr int port = 1234;\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        tcp::acceptor acceptor(io_context,\n                      tcp::endpoint(tcp::v4(), port));\n        std::cout << \"Server is running on port \"\n                  << port << \"...\\n\";\n        while (true) {\n            tcp::socket socket(io_context);\n            acceptor.accept(socket);\n            std::cout << \"Client connected...\\n\";\n            handle_client(socket);\n            std::cout << \"Client disconnected...\\n\";\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << '\\n';\n    }\n    return 0;\n}\n```", "```cpp\nvoid handle_client(tcp::socket& socket) {\n    const size_t size_buffer = 5;\n    boost::asio::streambuf buf1, buf2;\n    std::array<boost::asio::mutable_buffer, 2> buffers = {\n        buf1.prepare(size_buffer),\n        buf2.prepare(size_buffer)\n    };\n    boost::system::error_code ec;\n    size_t bytes_recv = socket.read_some(buffers, ec);\n    if (ec) {\n        std::cerr << \"Error on receive: \"\n                  << ec.message() << '\\n';\n        return;\n    }\n    std::cout << \"Received \" << bytes_recv << \" bytes\\n\";\n    buf1.commit(5);\n    buf2.commit(5);\n    std::istream is1(&buf1);\n    std::istream is2(&buf2);\n    std::string data1, data2;\n    is1 >> data1;\n    is2 >> data2;\n    std::cout << \"Buffer 1: \" << data1 << std::endl;\n    std::cout << \"Buffer 2: \" << data2 << std::endl;\n}\n```", "```cpp\nServer is running on port 1234...\nClient connected...\nReceived 10 bytes\nBuffer 1: Hello\nBuffer 2: Worl\nClient disconnected...\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::signal_set signals(io_context,\n                                  SIGINT, SIGTERM);\n        auto handle_signal = [&](\n                const boost::system::error_code& ec,\n                int signal) {\n            if (!ec) {\n                std::cout << \"Signal received: \"\n                          << signal << std::endl;\n                // Code to perform cleanup or shutdown.\n                io_context.stop();\n            }\n        };\n        signals.async_wait(handle_signal);\n        std::cout << \"Application is running. \"\n                  << \"Press Ctrl+C to stop...\\n\";\n        io_context.run();\n        std::cout << \"Application has exited cleanly.\\n\";\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << '\\n';\n    }\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid handle_timeout(const boost::system::error_code& ec) {\n    if (ec == boost::asio::error::operation_aborted) {\n        std::cout << \"Timer canceled.\\n\";\n    } else if (!ec) {\n        std::cout << \"Timer expired.\\n\";\n    } else {\n        std::cout << \"Error: \" << ec.message()\n                  << std::endl;\n    }\n}\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context, 5s);\n    timer.async_wait(handle_timeout);\n    std::this_thread::sleep_for(2s);\n    timer.cancel();\n    io_context.run();\n    return 0;\n}\n```", "```cpp\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context, 5s);\n    boost::asio::cancellation_signal cancel_signal;\n    timer.async_wait(boost::asio::bind_cancellation_slot(\n        cancel_signal.slot(),\n        handle_timeout\n    ));\n    std::this_thread::sleep_for(2s);\n    cancel_signal.emit(\n        boost::asio::cancellation_type::all);\n    io_context.run();\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <iostream>\nusing namespace std::chrono_literals;\nvoid handle_timer_expiry(boost::asio::steady_timer& timer,\n                        int count) {\n    std::cout << \"Timer expired. Count: \" << count\n              << std::endl;\n    timer.expires_after(1s);\n    timer.async_wait([&timer, count](\n                const boost::system::error_code& ec) {\n        if (!ec) {\n            handle_timer_expiry(timer, count + 1);\n        } else {\n            std::cerr << „Error: „ << ec.message()\n                      << std::endl;\n        }\n    });\n}\nint main() {\n    boost::asio::io_context io_context;\n    boost::asio::steady_timer timer(io_context, 1s);\n    int count = 0;\n    timer.async_wait([&](\n                const boost::system::error_code& ec) {\n        if (!ec) {\n            handle_timer_expiry(timer, count);\n        } else {\n            std::cerr << \"Error: \" << ec.message()\n                      << std::endl;\n        }\n    });\n    io_context.run();\n    return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <chrono>\n#include <fstream>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <thread>\n#include <vector>\nusing namespace std::chrono_literals;\nclass Logger {\n   public:\n    Logger(boost::asio::io_context& io_context,\n           const std::string& filename)\n        : strand_(io_context), file_(filename\n        , std::ios::out | std::ios::app)\n    {\n        if (!file_.is_open()) {\n            throw std::runtime_error(\n                      \"Failed to open log file\");\n        }\n    }\n    void log(const std::string message) {\n        strand_.post([this, message](){\n            do_log(message);\n        });\n    }\n   private:\n    void do_log(const std::string message) {\n        file_ << message << std::endl;\n    }\n    boost::asio::io_context::strand strand_;\n    std::ofstream file_;\n};\n```", "```cpp\nvoid worker(std::shared_ptr<Logger> logger, int id) {\n    for (unsigned i=0; i < num_messages_per_thread; ++i) {\n        std::ostringstream oss;\n        oss << \"Thread \" << id << \" logging message \" << i;\n        logger->log(oss.str());\n        std::this_thread::sleep_for(100ms);\n    }\n}\n```", "```cpp\nconst std::string log_filename = \"log.txt\";\nconst unsigned num_threads = 4;\nconst unsigned num_messages_per_thread = 5;\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        auto work_guard = boost::asio::make_work_guard(\n                                 io_context);\n        std::shared_ptr<Logger> logger =\n             std::make_shared<Logger>(\n                  io_context, log_filename);\n        std::cout << \"Logging \"\n                  << num_messages_per_thread\n                  << \" messages from \" << num_threads\n                  << \" threads\\n\";\n        std::vector<std::jthread> threads;\n        for (unsigned i = 0; i < num_threads; ++i) {\n            threads.emplace_back(worker, logger, i);\n        }\n        threads.emplace_back([&]() {\n            io_context.run_for(2s);\n        });\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << '\\n';\n    }\n    std::cout << \"Done!\" << std::endl;\n    return 0;\n}\n```", "```cpp\nLogging 5 messages from 4 threads\nDone!\n```", "```cpp\nThread 0 logging message 0\nThread 1 logging message 0\nThread 2 logging message 0\nThread 3 logging message 0\nThread 0 logging message 1\nThread 1 logging message 1\nThread 2 logging message 1\nThread 3 logging message 1\nThread 0 logging message 2\nThread 1 logging message 2\nThread 2 logging message 2\nThread 3 logging message 2\nThread 0 logging message 3\nThread 1 logging message 3\nThread 2 logging message 3\nThread 3 logging message 3\nThread 0 logging message 4\nThread 1 logging message 4\nThread 2 logging message 4\nThread 3 logging message 4\n```", "```cpp\nThread 0 logging message 0\nThread 1 logging message 0\nThread 2 logging message 0\nThread 3 logging message 0\n```", "```cpp\nThread 0 logging message 0\nThread 0 logging message 1\nThread 0 logging message 2\nThread 0 logging message 3\nThread 0 logging message 4\nThread 1 logging message 0\nThread 1 logging message 1\nThread 1 logging message 2\nThread 1 logging message 3\nThread 1 logging message 4\nThread 2 logging message 0\nThread 2 logging message 1\nThread 2 logging message 2\nThread 2 logging message 3\nThread 2 logging message 4\nThread 3 logging message 0\nThread 3 logging message 1\nThread 3 logging message 2\nThread 3 logging message 3\nThread 3 logging message 4\n```", "```cpp\nstrand_.post([this, message]() { do_log(message); });\n```", "```cpp\nstrand_.post([&]() { do_log(message); });\n```", "```cpp\nstrand_.post(std::bind(&Logger::do_log, this, message));\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <sstream>\n#include <string>\nusing boost::asio::ip::tcp;\nint main() {\n    boost::asio::io_context io_context;\n    try {\n        boost::asio::co_spawn(io_context,\n                    listener(io_context, 12345),\n                    boost::asio::detached);\n        io_context.run();\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        io_context.stop();\n    }\n    return 0;\n}\n```", "```cpp\nboost::asio::awaitable<void> listener(boost::asio::io_context& io_context, unsigned short port) {\n    tcp::acceptor acceptor(io_context,\n                           tcp::endpoint(tcp::v4(), port));\n    while (true) {\n        std::cout << \"Accepting connections...\\n\";\n        tcp::socket socket = co_await\n                acceptor.async_accept(\n                    boost::asio::use_awaitable);\n        std::cout << \"Starting an Echo \"\n                  << \"connection handler...\\n\";\n        boost::asio::co_spawn(io_context,\n                              echo(std::move(socket)),\n                              boost::asio::detached);\n    }\n}\n```", "```cpp\nboost::asio::awaitable<void> echo(tcp::socket socket) {\n    char data[1024];\n    while (true) {\n        std::cout << \"Reading data from socket...\\n\";\n        std::size_t bytes_read = co_await\n                 socket.async_read_some(\n                        boost::asio::buffer(data),\n                        boost::asio::use_awaitable);\n        if (bytes_read == 0) {\n            std::cout << \"No data. Exiting loop...\\n\";\n            break;\n        }\n        std::string str(data, bytes_read);\n        if (!str.empty() && str.back() == '\\n') {\n            str.pop_back();\n        }\n        if (!str.empty() && str.back() == '\\r') {\n            str.pop_back();\n        }\n        if (str == \"QUIT\") {\n            std::string bye(\"Good bye!\\n\");\n            co_await boost::asio::async_write(socket,\n                         boost::asio::buffer(bye),\n                         boost::asio::use_awaitable);\n            break;\n        }\n        std::cout << \"Writing '\" << str\n                  << \"' back into the socket...\\n\";\n        co_await boost::asio::async_write(socket,\n                     boost::asio::buffer(data,\n                                         bytes_read),\n                     boost::asio::use_awaitable);\n    }\n}\n```"]