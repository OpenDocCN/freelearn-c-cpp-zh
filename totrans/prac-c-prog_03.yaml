- en: Exploring Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you need to create a large application, it is a wise decision to divide
    it into manageable chunks, called **functions**. Functions are small modules that
    represent tasks that can be executed independently. The code written inside a
    function can be invoked several times, which helps to avoid repetitive statements.
  prefs: []
  type: TYPE_NORMAL
- en: Functions help in the teamwork, debugging, and scaling of any application. Whenever
    you want to add more features to an application, simply add a few functions to
    it. When calling functions, the caller function may pass certain arguments, called
    **actual arguments**; these are then assigned to the parameters of the function.
    The parameters are also known as formal parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipes will help you understand how functions can be used to
    make complex applications easier and more manageable. Normally, a function can
    return only a single value. But in this chapter, we will learn a technique to
    return more than one value from a function. We will also learn how to apply recursion
    in functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes on strings:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether a number is an Armstrong number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning the maximum and minimum values of an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding GCD using recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a binary number into a hexadecimal number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining whether a number is a palindrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I will be using a stack structure in the recipes in this chapter, let's have
    a quick introduction to stack.
  prefs: []
  type: TYPE_NORMAL
- en: What is a stack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Stack is a structure that can be implemented with arrays as well as linked
    lists. It is a sort of a bucket where the value you enter will be added at the
    bottom. The next item that you add to a stack will be kept just above the item
    that was added previously. The procedure of adding a value to the stack is called
    a `push` operation and the procedure of getting a value out of the stack is called
    a `pop` operation. The location where the value can be added or taken out of the
    stack is pointed at by a pointer called **top**. The value of the **top** pointer
    is **-1** when the stack is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9115e2a-afc7-4a7f-b3c6-7f6c516d3b41.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `push` operation is executed, the value of **top** is incremented
    by **1**, so that it can point to the location in the stack where the value can
    be pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb346f60-7242-4b87-898c-eab896ff0922.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the next value that will be pushed will be kept above value 1\. More precisely,
    the value of the **top** pointer will be incremented by **1**, making its value
    1, and the next value will be pushed to the **stack[1]** location, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7609b6c-07e6-46e7-815c-6a2844cdf688.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3
  prefs: []
  type: TYPE_NORMAL
- en: So, you can see that the stack is a **Last In First Out** (**LIFO**) structure;
    that is, the last value that was pushed sits at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we execute a `pop` operation, the value at the top, that is, value
    **2**, will be popped out first, followed by the popping out of value **1**. Basically,
    in the `pop` operation, the value pointed at by the **top** pointer is taken out,
    and then the value of **top** is decremented by 1 so that it can point at the
    next value to be popped out.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we've understood stacks, let's begin with the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Finding whether a number is an Armstrong number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Armstrong number is a three-digit integer that is the sum of the cubes of
    its digits. This simply means that if *xyz = x³+y³+z³*, it is an Armstrong number.
    For example, 153 is an Armstrong number because *1³+5³+3³ = 153*.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a number that comprises four digits is an Armstrong number if the
    sum of its digits raised to the power of four results in that number. For example, *pqrs
    = p⁴+q ⁴+r ⁴+s⁴.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter a number to assign to the `n` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `findarmstrong` function. The value assigned to `n` will get passed
    to this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function, the passed argument, n, is assigned to the `numb` parameter.
    Execute a `while` loop to separate out all the digits in the `numb` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `while` loop, apply the mod 10 (`%10`) operator on the number assigned
    to the `numb` variable. The mod operator divides a number and returns the remainder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the remainder to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the last digit of the number in the `numb` variable by dividing the
    `numb` variable by `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat steps 4 to 6 until the number in the `numb` variable becomes 0\. In
    addition, create a `count` counter to count the number of digits in the number.
    Initialize the counter to `0` and it will get incremented during the `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Pop all the digits from the stack and raise it to the given power. To pop all
    the digits from the stack, execute a `while` loop that will execute until `top`
    is greater than or equal to `0`, that is, until the stack is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `while` loop, pop off a digit from the stack and raise it to the
    power of `count`, which is the count of the number of digits in the selected number.
    Then, add all the digits to the `value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the number in the `value` variable with the number in the `numb` variable,
    and code it to return the value of `1` if both the compared numbers match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the numbers in the `numb` and `value` variables are the same, returning the
    Boolean value of `1`, that means the number is an Armstrong number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `armstrong.c` program for finding out whether the specified number
    is an Armstrong number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will apply the mod **10** operator to separate our digits. Assuming
    the number entered by us is **153**, you can see that **153** is divided by **10**
    and the remaining **3** is pushed to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a269523c-aabf-4c0f-9f7f-cabf252efea4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4
  prefs: []
  type: TYPE_NORMAL
- en: The value in the stack is pushed at the index location indicated by **top**. Initially, the
    value of **top** is -1. It is so because before the `push` operation, the value
    of **top** is incremented by 1, and the array is zero-based, that is, the first
    element in the array is placed at the 0 index location. Consequently, the value
    of **top** has to be initialized to -1\. As mentioned, the value of **top** is
    incremented by 1 before pushing, that is, the value of **top** will become **0**, and
    the remainder of **3** is pushed to **stack[0]**.
  prefs: []
  type: TYPE_NORMAL
- en: In the stack, the value of `top` is incremented by 1 to indicate the location
    in the stack where the value will be pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again apply the mod **10** operator to the **15** quotient. The remainder
    that we will get is **5**, which will be pushed to the stack. Again, before pushing
    to the stack, the value of **top**, which was 0, is incremented to 1\. At **stack[1]**,
    the remainder is pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2db6f661-3591-427c-95b7-b7e47c64a4af.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5
  prefs: []
  type: TYPE_NORMAL
- en: 'To the **1** quotient, we will again apply the mod **10** operator. But because
    1 is not divisible by **10**, **1** itself will be considered as the remainder
    and will be pushed to the stack. The value of **top** will again be incremented
    by 1 and **1** will be pushed to **stack[2]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81cafda1-260c-4760-a1ca-ba14b7aa9fee.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6
  prefs: []
  type: TYPE_NORMAL
- en: Once all the digits are separated and placed in the stack, we will pop them
    out one by one. Then, we will raise each digit to the power equal to the count
    of the digits. Because the number **153** consists of three digits, each digit
    is raised to the power of **3**.
  prefs: []
  type: TYPE_NORMAL
- en: 'While popping values out of the stack, the value indicated by the **top** pointer
    is popped out. The value of **top** is **2**, hence the value at **stack[2]**,
    that is, **1**, is popped out and raised to the power of **3**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55702938-82c0-4ea2-a7fc-f2e9bf8c4c73.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `pop` operation, the value of **top** will be decremented to 1 to
    indicate the next location to be popped out. Next, the value at **stack[1]** will
    be popped out and raised to the power of **3**. We will then add this value to
    our previous popped-out one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab9def09-a4f3-4726-8a9d-bd0650aa55da.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8
  prefs: []
  type: TYPE_NORMAL
- en: 'After the popping-out operation, the value of **top** is decremented by 1,
    now making its value **0**. So, the value at **stack[0]** is popped out and raised
    to the power of **3**. The result is added to our earlier computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/918d90c8-cc32-435e-8900-c487dcf13295.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9
  prefs: []
  type: TYPE_NORMAL
- en: The result after computing **1³ + 5³ + 3³** is **153**, which is the same as
    the original number. This proves that **153** is an Armstrong number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `armstrong.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether `127` is an Armstrong number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether `153` is an Armstrong number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether `1634` is an Armstrong number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully made a function to find whether a specified number
    is an Armstrong number or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Returning maximum and minimum values in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C functions cannot return more than one value. But what if you want a function
    to return more than one value? The solution is to store the values to be returned
    in an array and make the function return the array instead.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will make a function return two values, the maximum and minimum
    values, and store them in another array. Thereafter, the array containing the
    maximum and minimum values will be returned from the function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The size of the array whose maximum and minimum values have to be found out
    is not fixed, hence we will define a macro called `max` of size `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define an `arr` array of the max size, that is, `100` elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted to specify the number of elements in the array; the length
    you enter will be assigned to the `n` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute a `for` loop for `n` number of times to accept `n` values for the `arr` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `maxmin` function to pass the `arr` array and its length, `n`, to
    it. The array that will be returned by the `maxmin` function will be assigned
    to the integer pointer, `*p`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you look at the function definition, `int *maxmin(int ar[], int v){ }`,
    the `arr` and `n` arguments passed to the `maxmin` function are assigned to the
    `ar` and `v` parameters, respectively. In the `maxmin` function, define an `mm` array
    of two elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare it with the rest of the elements, the first element of `ar` array
    is stored at `mm[0]` and `mm[1]`. A loop is executed from the `1` value till the
    end of the length of the array and within the loop, the following two formulas
    are applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use `mm[0]` to store the minimum value of the `arr` array. The value
    in `mm[0]` is compared with the rest of the elements. If the value in `mm[0]`
    is greater than any of the array elements, we will assign the smaller element
    to `mm[0]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `mm[1]` to store the maximum value of the `arr` array. If the value
    at `mm[1]` is found to be smaller than any of the rest of the array element, we
    will assign the larger array element to `mm[1]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After the execution of the `for` loop, the `mm` array will have the minimum
    and maximum values of the `arr` array at `mm[0]` and `mm[1]`, respectively. We
    will return this `mm` array to the `main` function where the `*p` pointer is set
    to point at the returned array, `mm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*p` pointer will first point to the memory address of the first index
    location, that is, `mm[0]`. Then, the content of that memory address, that is,
    the minimum value of the array, is displayed. After that, the value of the `*p` pointer
    is incremented by 1 to make it point to the memory address of the next element
    in the array, that is, the `mm[1]` location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mm[1]` index location contains the maximum value of the array. Finally,
    the maximum value pointed to by the `*p` pointer is displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `returnarray.c` program explains how an array can be returned from a function.
    Basically, the program returns the minimum and maximum values of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use two arrays in this recipe. The first array will contain the values
    from which the maximum and minimum values have to be found. The second array will
    be used to store the minimum and maximum values of the first array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the first array **arr** and define it to contain five elements
    with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c29ca51-8a40-44ba-8357-e2a34a557976.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call our second array **mm**. The first location, **mm[0]**, of the **mm** array
    will be used for storing the minimum value and the second location, **mm[1]**,
    for storing the maximum value of the **arr** array. To enable comparison of the
    elements of the **mm** array with the elements of the **arr** array, copy the
    first element of the **arr** array at **arr[0]** to both **mm[0]** and **mm[1]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25c20abe-6c08-4119-9004-ed53ede25b11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compare the rest of the elements of the **arr** array with **mm[0]**
    and **mm[1]**. To keep the minimum value at **mm[0]**, any element smaller than
    the value at **mm[0]** will be assigned to **mm[0]**. Values larger than **mm[0]** are
    simply ignored. For example, the value at **arr[1]** is smaller than that at **mm[0]**,
    that is, 8 < 30\. So, the smaller value will be assigned to **mm[0]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/488c6af4-7ba1-4bab-9d74-348181d6eb36.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12
  prefs: []
  type: TYPE_NORMAL
- en: We will apply reverse logic to the element at **mm[1]**. Because we want the maximum
    value of the **arr** array at **mm[1]**, any element found larger than the value
    at **mm[1]** will be assigned to **mm[1]**. All smaller values will be simply
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue this process with the next element in the **arr** array, which
    is **arr[2].** Because 77 > 8, it will be ignored when compared with **mm[0]**.
    But 77 > 30, so it will be assigned to **mm[1]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b11e4329-e2c3-479a-b0a7-0a5a4e44a898.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13
  prefs: []
  type: TYPE_NORMAL
- en: 'We will repeat this procedure with the rest of the elements of the **arr** array.
    Once all the elements of the **arr** array are compared with both the elements
    of the **mm** array, we will have the minimum and maximum values at **mm[0]**
    and **mm[1]**, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a9a0f3f-28a2-4f56-9df2-aabc41096ff4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `returnarray.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully returned the maximum and minimum values in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding the greatest common divisor using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use recursive functions to find the **greatest common
    divisor** (**GCD)**, also known as the highest common factor) of two or more integers.
    The GCD is the largest positive integer that divides each of the integers. For
    example, the GCD of 8 and 12 is 4, and the GCD of 9 and 18 is 9.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `int gcd(int x, int y)` recursive function finds the GCD of two integers,
    x and y, using the following three rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If y=0, the GCD of `x` and `y` is `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If x mod y is 0, the GCD of x and y is y.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the GCD of x and y is `gcd(y, (x mod y))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow the given steps to find the GCD of two integers recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be prompted to enter two integers. Assign the integers entered to
    two variables, `u` and `v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `gcd` function and pass the `x` and `y` values to it. The `x` and
    `y` values will be assigned to the `a` and `b` parameters, respectively. Assign
    the GCD value returned by the `gcd` function to the `g` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `gcd` function, `a % b` is executed. The `%` (mod) operator divides
    the number and returns the remainder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the remainder is non-zero, call the `gcd` function again, but this time
    the arguments will be `gcd(b,a % b)`, that is, `gcd(b,m)`, where `m` stands for
    the mod operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If this again results in a non-zero remainder, that is, if `b % m` is non-zero,
    repeat the `gcd` function with the new values obtained from the previous execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the result of `b % m` is zero, `b` is the GCD of the supplied arguments
    and is returned back to the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, `b`, that is returned back to the `main` function is assigned to
    the `g` variable, which is then displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gcd.c` program explains how the greatest common divisor of two integers
    is computed through the recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume we want to find the GCD of two integers, **18** and **24**. To
    do so, we will invoke the `gcd(x,y)` function, which in this case is `gcd(18,24)`.
    Because **24**, that is, y, is not zero, Rule 1 is not applicable here. Next,
    we will use Rule 2 to check whether `18%24` (`x % y`) is equal to **0**. Because
    **18** cannot be divided by **24**, **18** will be the remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/598bcb06-abd6-4411-8b89-ca85e21e6f48.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the parameters of Rule 2 were also not met, we will use Rule 3\. We will
    invoke the `gcd` function with the `gcd(b,m)` argument, which is `gcd(24,18%24)`.
    Now, m stands for the mod operation. At this stage, we will again apply Rule 2
    and collect the remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb993a6e-656b-482d-acaf-891d92beadb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the result of `24%18` is a non-zero value, we will invoke the `gcd`
    function again with the `gcd(b, m)` argument, which is now `gcd(18, 24%18)`, since
    we were left with **18** and **6** from the previous execution. We will again
    apply Rule 2 to this execution. When **18** is divided by **6**, the remainder
    is **0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3bb494-bca2-4159-89af-2875b1360cdb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have finally fulfilled the requirements of one of the rules,
    Rule 2\. If you recall, Rule 2 says that if x mod y is **0**, the GCD is y. Because
    the result of **18** mod **6** is **0**, the GCD of **18** and **24** is **6**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `gcd.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully found the GCD using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Converting a binary number into a hexadecimal number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to convert a binary number into a hexadecimal
    number. A binary number comprises two bits, 0 and 1\. To convert a binary number
    into a hexadecimal number, we first need to convert the binary number into a decimal
    number and then convert the resulting decimal number to hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter a binary number and assign it to the `b` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `intodecimal` function to convert the binary number into a decimal
    number, and pass the `b` variable to it as an argument. Assign the decimal number
    returned by the `intodecimal` function to the `d` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: On looking at the `intodecimal` definition, `int intodecimal(int bin) { }`,
    we can see that the `b` argument is assigned to the `bin` parameter of the `intodecimal`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Separate all the binary digits and multiply them by 2 raised to the power of
    their position in the binary number. Sum the results to get the decimal equivalent.
    To separate each binary digit, we need to execute a `while` loop until the binary
    number is greater than `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `while` loop, apply the mod 10 operator on the binary number and
    push the remainder to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute another `while` loop to get the decimal number of all the binary digits
    from the stack. The `while` loop will execute until the stack becomes empty (that
    is, until the value of `top` is greater than or equal to `0`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `while` loop, pop off all the binary digits from the stack and multiply
    each one by `2` raised to the power of `top`. Sum the results to get the decimal
    equivalent of the entered binary number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `intohexa` function and pass the binary number and the decimal number
    to it to get the hexadecimal number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the mod `16` operator in the `intohexa` function on the decimal number
    to get its hexadecimal. Push the remainder that you get to the stack. Apply mod
    `16` to the quotient again and repeat the process until the quotient becomes smaller
    than `16`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Pop off the remainders that are pushed to the stack to display the hexadecimal
    number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the remainder that is popped off from the stack is less than 10, it is displayed
    as such. Otherwise, it is converted to its equivalent letter, as mentioned in
    the following table, and the resulting letter is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Hexadecimal** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | D |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | E |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | F |'
  prefs: []
  type: TYPE_TB
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `binarytohexa.c` program explains how a binary number can be converted
    into a hexadecimal number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to convert the binary number into a decimal number. To do
    so, we will separate all the binary digits and multiply each by **2** raised to
    the power of their position in the binary number. We will then apply the mod **10** operator
    in order to separate the binary number into individual digits. Every time mod
    **10** is applied to the binary number, its last digit is separated and then pushed
    to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the binary number that we need to convert into a hexadecimal
    format is **110001**. We will apply the mod **10** operator to this binary number.
    The mod operator divides the number and returns the remainder. On application
    of the mod **10** operator, the last binary digit—in other words the rightmost
    digit will be returned as the remainder (as is the case with all divisions by
    **10**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The operation is pushed in the stack at the location indicated by the **top**
    pointer. The value of **top** is initially -1\. Before pushing to the stack, the
    value of **top** is incremented by 1\. So, the value of **top** increments to
    0 and the binary digit that appeared as the remainder (in this case, 1) is pushed
    to **stack[0]** (see *Figure 3.18*), and**11000** is returned as the quotient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ac21bf6-eb3d-4eda-89ac-509a35205b6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again apply the mod **10** operator to the quotient to separate the
    last digit of the present binary number. This time, **0** will be returned as
    the remainder and **1100** as the quotient on the application of the mod **10**
    operator. The remainder is again pushed to the stack. As mentioned before, the
    value of **top** is incremented before applying the `push` operation. As the value
    of **top** was **0**, it is incremented to **1** and our new remainder, **0**,
    is pushed to **stack[1]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c579654-ae4a-4983-8944-280c41504e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19
  prefs: []
  type: TYPE_NORMAL
- en: 'We will repeat this procedure until all the digits of the binary number are
    separated and pushed to the stack, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1674e0f-e8c5-4a58-827d-a4c989295a86.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20
  prefs: []
  type: TYPE_NORMAL
- en: Once that's done, the next step is to pop the digits out one by one and multiply
    every digit by **2** raised to the power of **top**. For example, **2** raised
    to the power of top means **2** will be raised to the value of the index location
    from where the binary digit was popped off. The value from the stack is popped
    out from the location indicated by **top**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of **top** is currently **5**, hence the element at **stack[5]** will
    be popped out and multiplied by **2** raised to the power **5**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5163bb4-bdb2-4fd2-97cb-949f6965eb03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21
  prefs: []
  type: TYPE_NORMAL
- en: 'After popping a value from the stack, the value of **top** is decremented by
    1 to point at the next element to be popped out. The procedure is repeated until
    every digit is popped out and multiplied by **2** raised to the power of its top
    location value. *Figure 3.19* shows how all the binary digits are popped from
    the stack and multiplied by **2** raised to the power of **top**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f8007e3-574f-40b8-90e4-1e57d475714e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22
  prefs: []
  type: TYPE_NORMAL
- en: The resulting number we get is the decimal equivalent of the binary number that
    was entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to convert a decimal number into a hexadecimal format, we will divide it
    by 16\. We need to keep dividing the number until the quotient becomes smaller
    than `16`. The remainders of the division are displayed in LIFO order. If the
    remainder is below 10, it is displayed as is; otherwise, its equivalent letter
    is displayed. You can use the preceding table to find the equivalent letter if
    you get a remainder between 10 and 15.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see that the decimal number **49** is divided
    by **16**. The remainders are displayed in LIFO order to display the hexadecimal,
    hence 31 is the hexadecimal of the binary number **110001**. You don’t need to
    apply the preceding table as both the remainders are less than 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3507920-6015-401d-ab09-e679e11144d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `binaryintohexa.c` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully converted a binary number into a hexadecimal number.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding whether a number is a palindrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A palindrome number is one that appears the same when read forward and backward.
    For example, 123 is not a palindrome but 737 is. To find out whether a number
    is a palindrome, we need to split it into separate digits and convert the unit
    of the original number to hundred and the hundred to unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `pqr` number will be called a **palindrome** **number** if `pqr=rqp`.
    And `pqr` will be equal to `rqp` only if the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '*p x 100 + q x 10 + r = r x 100 + q x 10 + p*'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we will have to multiply the digit in the unit place by 10²
    to convert it into the hundreds and convert the digit in the hundreds place to unit by
    multiplying it by 1\. If the result matches the original number, it is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter a number to assign to the `n` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the `findpalindrome` function and pass the number in the `n` variable
    to it as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `n` argument is assigned to the `numb` parameter in the `findpalindrome`
    function. We need to separate each digit of the number; to do so, we will execute
    a `while` loop for the time the value in the `numb` variable is greater than `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `while` loop, we will apply mod 10 on the number. On application
    of the mod `10` operator, we will get the remainder, which is basically the last
    digit of the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Push that remainder to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the last digit of the number is separated, we need to remove the last
    digit from the existing number. That is done by dividing the number by 10 and
    truncating the fraction. The `while` loop will terminate when the number is individually
    divided into separate digits and all the digits are pushed to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The number at the top of the stack will be the hundred and the one at the bottom
    of the stack will be the unit of the original number. Recall that we need to convert
    the hundred of the original number to the unit and vice versa. Pop all the digits
    out from the stack one by one and multiply each of them by `10` raised to a power.
    The power will be 0 for the first digit that is popped off. The power will be
    incremented with every value that is popped off. After being multiplied by `10`
    raised to the respective power, the digits are added into a separate variable,
    called `value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the numbers in the `numb` and `value` variables match, that means the number
    is a palindrome. If the number is a palindrome, the `findpalindrome` function
    will return a value of `1`, otherwise it will return a value of `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findpalindrome.c` program determines whether the entered number is a palindrome
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that the number we entered is **737**. Now, we want to know whether **737**
    is a palindrome. We will start by applying the mod **10** operator on **737**.
    On application, we will receive the remainder, **7**, and the quotient, **73**.
    The remainder, **7**, will be pushed to the stack. Before pushing to the stack,
    however, the value of the **top** pointer is incremented by 1\. The value of **top**
    is -1 initially; it is incremented to **0** and the remainder of **7** is pushed to **stack[0]** (see
    *Figure 3.21* ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The mod **10** operator returns the last digit of the number as the remainder.
    The quotient that we get on the application of the mod **10** operator is the
    original number with its last digit removed. That is, the quotient that we will
    get on the application of mod **10** operator on **737** is **73**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cb4f884-3189-42da-acd2-9c455563b686.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24
  prefs: []
  type: TYPE_NORMAL
- en: 'To the quotient, **73**, we will apply the mod **10** operator again. The remainder
    will be the last digit, which is **3**, and the quotient will be **7**. The value
    of **top** is incremented by 1, making its value 1, and the remainder is pushed
    to **stack[1]**. To the quotient, **7**, we will again apply the mod **10** operator.
    Because **7** cannot be divided by **10**, **7** itself is returned and is pushed
    to the stack. Again, before the `push` operation, the value of **top** is incremented
    by 1, making its value **2**. The value of **7** will be pushed to **stack[2]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/635dc95a-959c-4989-908d-95ebb8e7d639.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25
  prefs: []
  type: TYPE_NORMAL
- en: 'After separating the number into individual digits, we need to pop each digit
    from the stack one by one and multiply each one by **10** raised to a power. The
    power will be **0** for the topmost digit on the stack and will increment by 1
    after every `pop` operation. The digit that will be popped from the stack will
    be the one indicated to by the top pointer. The value of **top** is **2**, so
    the digit on **stack[2]** is popped out and is multiplied by **10** raised to
    power of **0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adf2c256-f0e7-42a0-aa34-8427c85cf653.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26
  prefs: []
  type: TYPE_NORMAL
- en: 'After every `pop` operation, the value of **top** is decremented by 1 and the
    value of the power is incremented by 1\. The next digit that will be popped out
    from the stack is the one on **stack[1]**. That is, **3** will be popped out and
    multiplied by **10** raised to the power of **1**. Thereafter, the value of **top**
    will be decremented by 1, that is, the value of **top** will become **0**, and
    the value of the power will be incremented by 1, that is, the value of the power
    that was **1** will be incremented to **2**. The digit on **stack[0] **will be
    popped out and multiplied by **10** raised to the power of **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13702f79-5d93-4e65-a7a8-b89fe26c7f61.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27
  prefs: []
  type: TYPE_NORMAL
- en: All the digits that are multiplied by **10** raised to the respective power
    are then summed. Because the result of the computation matches the original number,
    **737** is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `findpalindrome.c` program, as shown in the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether `123` is a palindrome number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether `737` is a palindrome number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully determined whether a number was a palindrome.
  prefs: []
  type: TYPE_NORMAL
