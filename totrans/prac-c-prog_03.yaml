- en: Exploring Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数
- en: Whenever you need to create a large application, it is a wise decision to divide
    it into manageable chunks, called **functions**. Functions are small modules that
    represent tasks that can be executed independently. The code written inside a
    function can be invoked several times, which helps to avoid repetitive statements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你需要创建一个大型应用程序，将其划分为可管理的块，称为**函数**，都是一个明智的决定。函数是代表可以独立执行的任务的小模块。函数内部编写的代码可以被多次调用，这有助于避免重复的语句。
- en: Functions help in the teamwork, debugging, and scaling of any application. Whenever
    you want to add more features to an application, simply add a few functions to
    it. When calling functions, the caller function may pass certain arguments, called
    **actual arguments**; these are then assigned to the parameters of the function.
    The parameters are also known as formal parameters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有助于任何应用程序的团队合作、调试和扩展。当你想要向应用程序添加更多功能时，只需向其中添加几个函数即可。在调用函数时，调用函数可能会传递某些参数，称为**实际参数**；这些参数随后被分配给函数的参数。参数也被称为形式参数。
- en: The following recipes will help you understand how functions can be used to
    make complex applications easier and more manageable. Normally, a function can
    return only a single value. But in this chapter, we will learn a technique to
    return more than one value from a function. We will also learn how to apply recursion
    in functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱将帮助您了解如何使用函数使复杂的应用程序更容易管理和使用。通常，一个函数只能返回一个值。但在这章中，我们将学习一种从函数中返回多个值的技术。我们还将学习如何在函数中应用递归。
- en: 'In this chapter, we will cover the following recipes on strings:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下关于字符串的食谱：
- en: Determining whether a number is an Armstrong number
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断一个数是否是阿姆斯特朗数
- en: Returning the maximum and minimum values of an array
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数组的最大和最小值
- en: Finding GCD using recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归寻找最大公约数
- en: Converting a binary number into a hexadecimal number
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制数
- en: Determining whether a number is a palindrome
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断一个数是否是回文数
- en: As I will be using a stack structure in the recipes in this chapter, let's have
    a quick introduction to stack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将在本章的食谱中使用栈结构，让我们快速介绍一下栈。
- en: What is a stack?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是栈？
- en: 'A Stack is a structure that can be implemented with arrays as well as linked
    lists. It is a sort of a bucket where the value you enter will be added at the
    bottom. The next item that you add to a stack will be kept just above the item
    that was added previously. The procedure of adding a value to the stack is called
    a `push` operation and the procedure of getting a value out of the stack is called
    a `pop` operation. The location where the value can be added or taken out of the
    stack is pointed at by a pointer called **top**. The value of the **top** pointer
    is **-1** when the stack is empty:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种可以用数组以及链表实现的构造。它是一种桶，你输入的值将被添加到底部。你添加到栈中的下一个项目将位于之前添加的项目之上。将值添加到栈中的过程称为`push`操作，从栈中获取值的过程称为`pop`操作。可以添加或取出值的栈的位置由一个称为**top**的指针指向。当栈为空时，**top**指针的值是**-1**：
- en: '![](img/d9115e2a-afc7-4a7f-b3c6-7f6c516d3b41.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9115e2a-afc7-4a7f-b3c6-7f6c516d3b41.png)'
- en: Figure 3.1
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1
- en: 'When the `push` operation is executed, the value of **top** is incremented
    by **1**, so that it can point to the location in the stack where the value can
    be pushed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`push`操作时，**top**的值增加**1**，以便它能够指向可以推入值的栈中的位置：
- en: '![](img/eb346f60-7242-4b87-898c-eab896ff0922.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb346f60-7242-4b87-898c-eab896ff0922.png)'
- en: Figure 3.2
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2
- en: 'Now, the next value that will be pushed will be kept above value 1\. More precisely,
    the value of the **top** pointer will be incremented by **1**, making its value
    1, and the next value will be pushed to the **stack[1]** location, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一个将被推入的值将位于值1之上。更确切地说，**top**指针的值将增加**1**，使其值为1，下一个值将被推入**stack[1]**位置，如下所示：
- en: '![](img/f7609b6c-07e6-46e7-815c-6a2844cdf688.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7609b6c-07e6-46e7-815c-6a2844cdf688.png)'
- en: Figure 3.3
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3
- en: So, you can see that the stack is a **Last In First Out** (**LIFO**) structure;
    that is, the last value that was pushed sits at the top.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到栈是一种**后进先出**（**LIFO**）结构；也就是说，最后推入的值位于顶部。
- en: Now, when we execute a `pop` operation, the value at the top, that is, value
    **2**, will be popped out first, followed by the popping out of value **1**. Basically,
    in the `pop` operation, the value pointed at by the **top** pointer is taken out,
    and then the value of **top** is decremented by 1 so that it can point at the
    next value to be popped out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we've understood stacks, let's begin with the first recipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Finding whether a number is an Armstrong number
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Armstrong number is a three-digit integer that is the sum of the cubes of
    its digits. This simply means that if *xyz = x³+y³+z³*, it is an Armstrong number.
    For example, 153 is an Armstrong number because *1³+5³+3³ = 153*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a number that comprises four digits is an Armstrong number if the
    sum of its digits raised to the power of four results in that number. For example, *pqrs
    = p⁴+q ⁴+r ⁴+s⁴.*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter a number to assign to the `n` variable:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Invoke the `findarmstrong` function. The value assigned to `n` will get passed
    to this function:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the function, the passed argument, n, is assigned to the `numb` parameter.
    Execute a `while` loop to separate out all the digits in the `numb` parameter:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `while` loop, apply the mod 10 (`%10`) operator on the number assigned
    to the `numb` variable. The mod operator divides a number and returns the remainder:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Push the remainder to the stack:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remove the last digit of the number in the `numb` variable by dividing the
    `numb` variable by `10`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Repeat steps 4 to 6 until the number in the `numb` variable becomes 0\. In
    addition, create a `count` counter to count the number of digits in the number.
    Initialize the counter to `0` and it will get incremented during the `while` loop:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pop all the digits from the stack and raise it to the given power. To pop all
    the digits from the stack, execute a `while` loop that will execute until `top`
    is greater than or equal to `0`, that is, until the stack is empty:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `while` loop, pop off a digit from the stack and raise it to the
    power of `count`, which is the count of the number of digits in the selected number.
    Then, add all the digits to the `value`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compare the number in the `value` variable with the number in the `numb` variable,
    and code it to return the value of `1` if both the compared numbers match:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the numbers in the `numb` and `value` variables are the same, returning the
    Boolean value of `1`, that means the number is an Armstrong number.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `armstrong.c` program for finding out whether the specified number
    is an Armstrong number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's go behind the scenes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will apply the mod **10** operator to separate our digits. Assuming
    the number entered by us is **153**, you can see that **153** is divided by **10**
    and the remaining **3** is pushed to the stack:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a269523c-aabf-4c0f-9f7f-cabf252efea4.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The value in the stack is pushed at the index location indicated by **top**. Initially, the
    value of **top** is -1. It is so because before the `push` operation, the value
    of **top** is incremented by 1, and the array is zero-based, that is, the first
    element in the array is placed at the 0 index location. Consequently, the value
    of **top** has to be initialized to -1\. As mentioned, the value of **top** is
    incremented by 1 before pushing, that is, the value of **top** will become **0**, and
    the remainder of **3** is pushed to **stack[0]**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 栈中的值将被推入由 **top** 指示的索引位置。最初，**top** 的值是 -1。这是因为在进行 `push` 操作之前，**top** 的值增加了
    1，而数组是基于零的，也就是说，数组的第一个元素放置在 0 索引位置。因此，**top** 的值必须初始化为 -1。如前所述，在推入之前，**top** 的值增加
    1，即 **top** 的值将变为 **0**，余数 **3** 被推入 **stack[0]**。
- en: In the stack, the value of `top` is incremented by 1 to indicate the location
    in the stack where the value will be pushed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈中，`top` 的值增加 1 以指示栈中将要推入值的位置。
- en: 'We will again apply the mod **10** operator to the **15** quotient. The remainder
    that we will get is **5**, which will be pushed to the stack. Again, before pushing
    to the stack, the value of **top**, which was 0, is incremented to 1\. At **stack[1]**,
    the remainder is pushed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次应用模 **10** 运算符到 **15** 的商上。我们将得到的余数是 **5**，它将被推入栈中。同样，在推入栈之前，**top** 的值，原本是
    0，被增加到 1。在 **stack[1]**，余数被推入：
- en: '![](img/2db6f661-3591-427c-95b7-b7e47c64a4af.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2db6f661-3591-427c-95b7-b7e47c64a4af.png)'
- en: Figure 3.5
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5
- en: 'To the **1** quotient, we will again apply the mod **10** operator. But because
    1 is not divisible by **10**, **1** itself will be considered as the remainder
    and will be pushed to the stack. The value of **top** will again be incremented
    by 1 and **1** will be pushed to **stack[2]**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **1** 的商，我们将再次应用模 **10** 运算符。但是因为 1 不能被 **10** 整除，所以 **1** 本身将被视为余数并推入栈中。**top**
    的值将再次增加 1，**1** 将被推入 **stack[2]**：
- en: '![](img/81cafda1-260c-4760-a1ca-ba14b7aa9fee.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81cafda1-260c-4760-a1ca-ba14b7aa9fee.png)'
- en: Figure 3.6
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6
- en: Once all the digits are separated and placed in the stack, we will pop them
    out one by one. Then, we will raise each digit to the power equal to the count
    of the digits. Because the number **153** consists of three digits, each digit
    is raised to the power of **3**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有数字都被分离并放置在栈中，我们将逐个弹出它们。然后，我们将每个数字提升到等于数字个数的幂。因为数字 **153** 由三个数字组成，每个数字都被提升到
    **3** 的幂。
- en: 'While popping values out of the stack, the value indicated by the **top** pointer
    is popped out. The value of **top** is **2**, hence the value at **stack[2]**,
    that is, **1**, is popped out and raised to the power of **3**, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当从栈中弹出值时，由 **top** 指针指示的值将被弹出。**top** 的值是 **2**，因此 **stack[2]** 中的值，即 **1**，被弹出并提升到
    **3** 的幂，如下所示：
- en: '![](img/55702938-82c0-4ea2-a7fc-f2e9bf8c4c73.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55702938-82c0-4ea2-a7fc-f2e9bf8c4c73.png)'
- en: Figure 3.7
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7
- en: 'After the `pop` operation, the value of **top** will be decremented to 1 to
    indicate the next location to be popped out. Next, the value at **stack[1]** will
    be popped out and raised to the power of **3**. We will then add this value to
    our previous popped-out one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出操作后，**top** 的值将减少到 1，以指示下一个要弹出的位置。接下来，**stack[1]** 中的值将被弹出并提升到 **3** 的幂。然后我们将这个值添加到之前弹出的值中：
- en: '![](img/ab9def09-a4f3-4726-8a9d-bd0650aa55da.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab9def09-a4f3-4726-8a9d-bd0650aa55da.png)'
- en: Figure 3.8
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8
- en: 'After the popping-out operation, the value of **top** is decremented by 1,
    now making its value **0**. So, the value at **stack[0]** is popped out and raised
    to the power of **3**. The result is added to our earlier computation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出操作后，**top** 的值减少 1，现在其值为 **0**。因此，**stack[0]** 中的值被弹出并提升到 **3** 的幂。这个结果被添加到我们之前的计算中：
- en: '![](img/918d90c8-cc32-435e-8900-c487dcf13295.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/918d90c8-cc32-435e-8900-c487dcf13295.png)'
- en: Figure 3.9
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9
- en: The result after computing **1³ + 5³ + 3³** is **153**, which is the same as
    the original number. This proves that **153** is an Armstrong number.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 **1³ + 5³ + 3³** 后的结果是 **153**，这与原始数字相同。这证明了 **153** 是一个阿姆斯特朗数。
- en: 'Let''s use GCC to compile the `armstrong.c` program, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `armstrong.c` 程序，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s check whether `127` is an Armstrong number:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `127` 是否是阿姆斯特朗数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s check whether `153` is an Armstrong number:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `153` 是否是阿姆斯特朗数：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s check whether `1634` is an Armstrong number:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `1634` 是否是阿姆斯特朗数：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Voilà! We've successfully made a function to find whether a specified number
    is an Armstrong number or not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功创建了一个函数，用于判断指定的数字是否是阿姆斯特朗数。
- en: Now, let's move on to the next recipe!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Returning maximum and minimum values in an array
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组中返回最大和最小值
- en: C functions cannot return more than one value. But what if you want a function
    to return more than one value? The solution is to store the values to be returned
    in an array and make the function return the array instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C函数不能返回超过一个值。但如果你想让函数返回超过一个值怎么办？解决方案是将要返回的值存储在数组中，并让函数返回该数组。
- en: In this recipe, we will make a function return two values, the maximum and minimum
    values, and store them in another array. Thereafter, the array containing the
    maximum and minimum values will be returned from the function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个函数返回两个值，即最大值和最小值，并将它们存储在另一个数组中。之后，包含最大值和最小值的数组将从函数返回。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The size of the array whose maximum and minimum values have to be found out
    is not fixed, hence we will define a macro called `max` of size `100`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要找出最大和最小值的数组的尺寸不是固定的，因此我们将定义一个名为`max`的宏，其大小为`100`：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will define an `arr` array of the max size, that is, `100` elements:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个最大大小为`100`个元素的`arr`数组：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will be prompted to specify the number of elements in the array; the length
    you enter will be assigned to the `n` variable:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被提示指定数组中的元素数量；你输入的长度将被分配给`n`变量：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Execute a `for` loop for `n` number of times to accept `n` values for the `arr` array:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个`for`循环`n`次，以接受`arr`数组的`n`个值：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Invoke the `maxmin` function to pass the `arr` array and its length, `n`, to
    it. The array that will be returned by the `maxmin` function will be assigned
    to the integer pointer, `*p`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`maxmin`函数，将`arr`数组和它的长度`n`传递给它。`maxmin`函数将返回的数组将被分配给整数指针`*p`：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you look at the function definition, `int *maxmin(int ar[], int v){ }`,
    the `arr` and `n` arguments passed to the `maxmin` function are assigned to the
    `ar` and `v` parameters, respectively. In the `maxmin` function, define an `mm` array
    of two elements:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你查看函数定义时，`int *maxmin(int ar[], int v){ }`，传递给`maxmin`函数的`arr`和`n`参数分别被分配给`ar`和`v`参数。在`maxmin`函数中，定义一个包含两个元素的`mm`数组：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To compare it with the rest of the elements, the first element of `ar` array
    is stored at `mm[0]` and `mm[1]`. A loop is executed from the `1` value till the
    end of the length of the array and within the loop, the following two formulas
    are applied:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与数组中的其余元素进行比较，`ar`数组的第一元素被存储在`mm[0]`和`mm[1]`中。执行一个从`1`值到数组长度末尾的循环，并在循环中应用以下两个公式：
- en: 'We will use `mm[0]` to store the minimum value of the `arr` array. The value
    in `mm[0]` is compared with the rest of the elements. If the value in `mm[0]`
    is greater than any of the array elements, we will assign the smaller element
    to `mm[0]`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`mm[0]`来存储`arr`数组的最低值。`mm[0]`中的值将与数组中的其余元素进行比较。如果`mm[0]`中的值大于数组中的任何元素，我们将较小的元素分配给`mm[0]`：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will use `mm[1]` to store the maximum value of the `arr` array. If the value
    at `mm[1]` is found to be smaller than any of the rest of the array element, we
    will assign the larger array element to `mm[1]`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`mm[1]`来存储`arr`数组的最高值。如果发现`mm[1]`中的值小于数组中的其余元素，我们将较大的数组元素分配给`mm[1]`：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After the execution of the `for` loop, the `mm` array will have the minimum
    and maximum values of the `arr` array at `mm[0]` and `mm[1]`, respectively. We
    will return this `mm` array to the `main` function where the `*p` pointer is set
    to point at the returned array, `mm`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`for`循环后，`mm`数组将包含`arr`数组的最大和最小值，分别位于`mm[0]`和`mm[1]`。我们将返回这个`mm`数组到`main`函数，其中`*p`指针被设置为指向返回的数组`mm`：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `*p` pointer will first point to the memory address of the first index
    location, that is, `mm[0]`. Then, the content of that memory address, that is,
    the minimum value of the array, is displayed. After that, the value of the `*p` pointer
    is incremented by 1 to make it point to the memory address of the next element
    in the array, that is, the `mm[1]` location:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*p`指针将首先指向第一个索引位置的内存地址，即`mm[0]`。然后，显示该内存地址的内容，即数组的最低值。之后，将`*p`指针的值增加1，使其指向数组中下一个元素的内存地址，即`mm[1]`位置：'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `mm[1]` index location contains the maximum value of the array. Finally,
    the maximum value pointed to by the `*p` pointer is displayed on the screen:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**mm[1]** 索引位置包含数组的最大值。最后，通过 `*p` 指针指向的最大值显示在屏幕上：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `returnarray.c` program explains how an array can be returned from a function.
    Basically, the program returns the minimum and maximum values of an array:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnarray.c` 程序解释了如何从一个函数中返回一个数组。基本上，该程序返回数组的最大值和最小值：'
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's go behind the scenes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解。
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will use two arrays in this recipe. The first array will contain the values
    from which the maximum and minimum values have to be found. The second array will
    be used to store the minimum and maximum values of the first array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将使用两个数组。第一个数组将包含需要找到最大值和最小值的值。第二个数组将用于存储第一个数组的最大值和最小值。
- en: 'Let''s call the first array **arr** and define it to contain five elements
    with the following values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第一个数组称为 **arr** 并定义它包含五个元素，其值如下：
- en: '![](img/5c29ca51-8a40-44ba-8357-e2a34a557976.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c29ca51-8a40-44ba-8357-e2a34a557976.png)'
- en: Figure 3.10
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10
- en: 'Let''s call our second array **mm**. The first location, **mm[0]**, of the **mm** array
    will be used for storing the minimum value and the second location, **mm[1]**,
    for storing the maximum value of the **arr** array. To enable comparison of the
    elements of the **mm** array with the elements of the **arr** array, copy the
    first element of the **arr** array at **arr[0]** to both **mm[0]** and **mm[1]**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第二个数组称为 **mm**。**mm** 数组的第一个位置，即 **mm[0]**，将用于存储最小值，第二个位置，即 **mm[1]**，将用于存储
    **arr** 数组的最大值。为了能够比较 **mm** 数组的元素与 **arr** 数组的元素，将 **arr** 数组的第一个元素 **arr[0]**
    复制到 **mm[0]** 和 **mm[1]**：
- en: '![](img/25c20abe-6c08-4119-9004-ed53ede25b11.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25c20abe-6c08-4119-9004-ed53ede25b11.png)'
- en: Figure 3.11
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11
- en: 'Now, we will compare the rest of the elements of the **arr** array with **mm[0]**
    and **mm[1]**. To keep the minimum value at **mm[0]**, any element smaller than
    the value at **mm[0]** will be assigned to **mm[0]**. Values larger than **mm[0]** are
    simply ignored. For example, the value at **arr[1]** is smaller than that at **mm[0]**,
    that is, 8 < 30\. So, the smaller value will be assigned to **mm[0]**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将比较 **arr** 数组的其余元素与 **mm[0]** 和 **mm[1]**。为了保持 **mm[0]** 中的最小值，任何小于 **mm[0]**
    值的元素将被分配给 **mm[0]**。大于 **mm[0]** 的值将被简单地忽略。例如，**arr[1]** 中的值小于 **mm[0]**，即 8 <
    30。因此，较小的值将被分配给 **mm[0]**：
- en: '![](img/488c6af4-7ba1-4bab-9d74-348181d6eb36.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/488c6af4-7ba1-4bab-9d74-348181d6eb36.png)'
- en: Figure 3.12
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12
- en: We will apply reverse logic to the element at **mm[1]**. Because we want the maximum
    value of the **arr** array at **mm[1]**, any element found larger than the value
    at **mm[1]** will be assigned to **mm[1]**. All smaller values will be simply
    ignored.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 **mm[1]** 中的元素应用反向逻辑。因为我们想要 **arr** 数组的最大值在 **mm[1]** 中，所以任何找到的比 **mm[1]**
    值大的元素将被分配给 **mm[1]**。所有较小的值将被简单地忽略。
- en: 'We will continue this process with the next element in the **arr** array, which
    is **arr[2].** Because 77 > 8, it will be ignored when compared with **mm[0]**.
    But 77 > 30, so it will be assigned to **mm[1]**:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 **arr** 数组中的下一个元素，即 **arr[2]**。因为 77 > 8，所以当与 **mm[0]** 比较时将被忽略。但 77
    > 30，所以它将被分配给 **mm[1]**：
- en: '![](img/b11e4329-e2c3-479a-b0a7-0a5a4e44a898.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11e4329-e2c3-479a-b0a7-0a5a4e44a898.png)'
- en: Figure 3.13
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13
- en: 'We will repeat this procedure with the rest of the elements of the **arr** array.
    Once all the elements of the **arr** array are compared with both the elements
    of the **mm** array, we will have the minimum and maximum values at **mm[0]**
    and **mm[1]**, respectively:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复此过程，与 **arr** 数组的其余元素。一旦 **arr** 数组的所有元素都与 **mm** 数组的元素进行比较，我们将在 **mm[0]**
    和 **mm[1]** 中分别得到最小值和最大值：
- en: '![](img/4a9a0f3f-28a2-4f56-9df2-aabc41096ff4.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a9a0f3f-28a2-4f56-9df2-aabc41096ff4.png)'
- en: Figure 3.14
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14
- en: 'Let''s use GCC to compile the `returnarray.c` program, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `returnarray.c` 程序，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is the output of the program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Voilà! We've successfully returned the maximum and minimum values in an array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功地在数组中返回了最大值和最小值。
- en: Now, let's move on to the next recipe!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Finding the greatest common divisor using recursion
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归查找最大公约数
- en: In this recipe, we will use recursive functions to find the **greatest common
    divisor** (**GCD)**, also known as the highest common factor) of two or more integers.
    The GCD is the largest positive integer that divides each of the integers. For
    example, the GCD of 8 and 12 is 4, and the GCD of 9 and 18 is 9.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将使用递归函数来找到两个或多个整数的**最大公约数**（**GCD**），也称为最大公因数。GCD是能够整除每个整数的最大正整数。例如，8和12的最大公约数是4，9和18的最大公约数是9。
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The `int gcd(int x, int y)` recursive function finds the GCD of two integers,
    x and y, using the following three rules:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`int gcd(int x, int y)`递归函数使用以下三个规则来找到两个整数x和y的最大公约数：'
- en: If y=0, the GCD of `x` and `y` is `x`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果y=0，则`x`和`y`的最大公约数是`x`。
- en: If x mod y is 0, the GCD of x and y is y.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果x mod y为0，则x和y的最大公约数是y。
- en: Otherwise, the GCD of x and y is `gcd(y, (x mod y))`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，x和y的最大公约数是`gcd(y, (x mod y))`。
- en: 'Follow the given steps to find the GCD of two integers recursively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤递归地找到两个整数的最大公约数（GCD）：
- en: 'You will be prompted to enter two integers. Assign the integers entered to
    two variables, `u` and `v`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被提示输入两个整数。将输入的整数分配给两个变量，`u`和`v`：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Invoke the `gcd` function and pass the `x` and `y` values to it. The `x` and
    `y` values will be assigned to the `a` and `b` parameters, respectively. Assign
    the GCD value returned by the `gcd` function to the `g` variable:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`gcd`函数并将`x`和`y`值传递给它。`x`和`y`值将被分别分配给`a`和`b`参数。将`gcd`函数返回的GCD值分配给`g`变量：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `gcd` function, `a % b` is executed. The `%` (mod) operator divides
    the number and returns the remainder:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gcd`函数中，执行`a % b`。`%`（模）运算符将数字除以并返回余数：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the remainder is non-zero, call the `gcd` function again, but this time
    the arguments will be `gcd(b,a % b)`, that is, `gcd(b,m)`, where `m` stands for
    the mod operation:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果余数非零，则再次调用`gcd`函数，但这次参数将是`gcd(b,a % b)`，即`gcd(b,m)`，其中m代表模运算：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If this again results in a non-zero remainder, that is, if `b % m` is non-zero,
    repeat the `gcd` function with the new values obtained from the previous execution:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这又得到一个非零余数，即如果`b % m`是非零的，则使用上一次执行中获得的新值重复`gcd`函数：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the result of `b % m` is zero, `b` is the GCD of the supplied arguments
    and is returned back to the `main` function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`b % m`的结果为零，则`b`是提供的参数的最大公约数，并将其返回到`main`函数：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result, `b`, that is returned back to the `main` function is assigned to
    the `g` variable, which is then displayed on the screen:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回给`main`函数的结果`b`被分配给`g`变量，然后显示在屏幕上：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `gcd.c` program explains how the greatest common divisor of two integers
    is computed through the recursive function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcd.c`程序解释了如何通过递归函数计算两个整数的最大公约数：'
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let's go behind the scenes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s assume we want to find the GCD of two integers, **18** and **24**. To
    do so, we will invoke the `gcd(x,y)` function, which in this case is `gcd(18,24)`.
    Because **24**, that is, y, is not zero, Rule 1 is not applicable here. Next,
    we will use Rule 2 to check whether `18%24` (`x % y`) is equal to **0**. Because
    **18** cannot be divided by **24**, **18** will be the remainder:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到两个整数**18**和**24**的最大公约数。为此，我们将调用`gcd(x,y)`函数，在这种情况下是`gcd(18,24)`。因为**24**，即y，不为零，所以规则1不适用。接下来，我们将使用规则2检查`18%24`（`x
    % y`）是否等于**0**。因为**18**不能被**24**整除，所以**18**将是余数：
- en: '![](img/598bcb06-abd6-4411-8b89-ca85e21e6f48.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/598bcb06-abd6-4411-8b89-ca85e21e6f48.png)'
- en: Figure 3.15
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15
- en: 'Since the parameters of Rule 2 were also not met, we will use Rule 3\. We will
    invoke the `gcd` function with the `gcd(b,m)` argument, which is `gcd(24,18%24)`.
    Now, m stands for the mod operation. At this stage, we will again apply Rule 2
    and collect the remainder:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规则2的参数也没有满足，我们将使用规则3。我们将使用`gcd(b,m)`参数调用`gcd`函数，即`gcd(24,18%24)`。现在，m代表模运算。在这个阶段，我们将再次应用规则2并收集余数：
- en: '![](img/fb993a6e-656b-482d-acaf-891d92beadb8.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb993a6e-656b-482d-acaf-891d92beadb8.png)'
- en: Figure 3.16
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16
- en: 'Because the result of `24%18` is a non-zero value, we will invoke the `gcd`
    function again with the `gcd(b, m)` argument, which is now `gcd(18, 24%18)`, since
    we were left with **18** and **6** from the previous execution. We will again
    apply Rule 2 to this execution. When **18** is divided by **6**, the remainder
    is **0**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`24%18`的结果是一个非零值，我们将再次调用`gcd`函数，使用`gcd(b, m)`参数，现在`gcd(18, 24%18)`，因为我们从上一次执行中留下了**18**和**6**。我们将再次应用规则2到这次执行。当**18**除以**6**时，余数是**0**：
- en: '![](img/6e3bb494-bca2-4159-89af-2875b1360cdb.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e3bb494-bca2-4159-89af-2875b1360cdb.png)'
- en: Figure 3.17
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17
- en: At this stage, we have finally fulfilled the requirements of one of the rules,
    Rule 2\. If you recall, Rule 2 says that if x mod y is **0**, the GCD is y. Because
    the result of **18** mod **6** is **0**, the GCD of **18** and **24** is **6**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们最终满足了规则之一的要求，即规则2。如果你还记得，规则2说的是如果x mod y为**0**，则最大公约数是y。因为**18** mod
    **6**的结果是**0**，所以**18**和**24**的最大公约数是**6**。
- en: 'Let''s use GCC to compile the `gcd.c` program, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`gcd.c`程序，如下所示：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output of the program:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Voilà! We've successfully found the GCD using recursion.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用递归找到了最大公约数（GCD）。
- en: Now, let's move on to the next recipe!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Converting a binary number into a hexadecimal number
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制数
- en: In this recipe, we will learn how to convert a binary number into a hexadecimal
    number. A binary number comprises two bits, 0 and 1\. To convert a binary number
    into a hexadecimal number, we first need to convert the binary number into a decimal
    number and then convert the resulting decimal number to hexadecimal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将二进制数转换为十六进制数。二进制数由两个位组成，0和1。要将二进制数转换为十六进制数，我们首先需要将二进制数转换为十进制数，然后将得到的十进制数转换为十六进制。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Enter a binary number and assign it to the `b` variable:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个二进制数并将其赋值给变量`b`：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Invoke the `intodecimal` function to convert the binary number into a decimal
    number, and pass the `b` variable to it as an argument. Assign the decimal number
    returned by the `intodecimal` function to the `d` variable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`intodecimal`函数将二进制数转换为十进制数，并将变量`b`作为参数传递给它。将`intodecimal`函数返回的十进制数赋值给变量`d`：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On looking at the `intodecimal` definition, `int intodecimal(int bin) { }`,
    we can see that the `b` argument is assigned to the `bin` parameter of the `intodecimal`
    function.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察到`intodecimal`的定义`int intodecimal(int bin) { }`，我们可以看到`b`参数被分配给`intodecimal`函数的`bin`参数。
- en: 'Separate all the binary digits and multiply them by 2 raised to the power of
    their position in the binary number. Sum the results to get the decimal equivalent.
    To separate each binary digit, we need to execute a `while` loop until the binary
    number is greater than `0`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有二进制位分开，并将它们乘以2的幂，幂的值等于它们在二进制数中的位置。将结果相加以得到十进制等效值。为了分离每个二进制位，我们需要执行一个`while`循环，直到二进制数大于0：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within the `while` loop, apply the mod 10 operator on the binary number and
    push the remainder to the stack:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，对二进制数应用模10运算符并将余数推入栈中：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Execute another `while` loop to get the decimal number of all the binary digits
    from the stack. The `while` loop will execute until the stack becomes empty (that
    is, until the value of `top` is greater than or equal to `0`):'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行另一个`while`循环以获取栈中所有二进制位的十进制数。`while`循环将执行，直到栈为空（即，直到`top`的值大于或等于0）：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `while` loop, pop off all the binary digits from the stack and multiply
    each one by `2` raised to the power of `top`. Sum the results to get the decimal
    equivalent of the entered binary number:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，弹出栈中的所有二进制位，并将每个位乘以2的`top`次幂。将结果相加以得到输入二进制数的十进制等效值：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Invoke the `intohexa` function and pass the binary number and the decimal number
    to it to get the hexadecimal number:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`intohexa`函数并将二进制数和十进制数传递给它以获取十六进制数：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Apply the mod `16` operator in the `intohexa` function on the decimal number
    to get its hexadecimal. Push the remainder that you get to the stack. Apply mod
    `16` to the quotient again and repeat the process until the quotient becomes smaller
    than `16`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`intohexa`函数中对十进制数应用模16运算符以获取其十六进制数。将得到的余数推入栈中。再次对商应用模16并重复此过程，直到商小于16：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Pop off the remainders that are pushed to the stack to display the hexadecimal
    number:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出推入栈中以显示十六进制数的余数：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the remainder that is popped off from the stack is less than 10, it is displayed
    as such. Otherwise, it is converted to its equivalent letter, as mentioned in
    the following table, and the resulting letter is displayed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从栈中弹出的余数小于10，则直接显示。否则，将其转换为以下表中提到的等效字母，并将结果字母显示出来：
- en: '| **Decimal** | **Hexadecimal** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **十进制** | **十六进制** |'
- en: '| 10 | A |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 10 | A |'
- en: '| 11 | B |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 11 | B |'
- en: '| 12 | C |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 12 | C |'
- en: '| 13 | D |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 13 | D |'
- en: '| 14 | E |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 14 | E |'
- en: '| 15 | F |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 15 | F |'
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `binarytohexa.c` program explains how a binary number can be converted
    into a hexadecimal number:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`binarytohexa.c`程序解释了如何将二进制数转换为十六进制数：'
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, let's go behind the scenes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step is to convert the binary number into a decimal number. To do
    so, we will separate all the binary digits and multiply each by **2** raised to
    the power of their position in the binary number. We will then apply the mod **10** operator
    in order to separate the binary number into individual digits. Every time mod
    **10** is applied to the binary number, its last digit is separated and then pushed
    to the stack.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将二进制数转换为十进制数。为此，我们将分离所有二进制数字，并将每个数字乘以二进制数中其位置的**2**的次方。然后，我们将应用mod **10**运算符，以便将二进制数分离成单独的数字。每次对二进制数应用mod
    **10**时，其最后一位数字就会被分离并推入栈中。
- en: Let's assume that the binary number that we need to convert into a hexadecimal
    format is **110001**. We will apply the mod **10** operator to this binary number.
    The mod operator divides the number and returns the remainder. On application
    of the mod **10** operator, the last binary digit—in other words the rightmost
    digit will be returned as the remainder (as is the case with all divisions by
    **10**).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将二进制数转换为十六进制格式的是**110001**。我们将对此二进制数应用mod **10**运算符。mod运算符将除以数字并返回余数。在应用mod
    **10**运算符时，最后一个二进制数字——换句话说，最右边的数字将被作为余数返回（这与所有除以**10**的情况相同）。
- en: 'The operation is pushed in the stack at the location indicated by the **top**
    pointer. The value of **top** is initially -1\. Before pushing to the stack, the
    value of **top** is incremented by 1\. So, the value of **top** increments to
    0 and the binary digit that appeared as the remainder (in this case, 1) is pushed
    to **stack[0]** (see *Figure 3.18*), and**11000** is returned as the quotient:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 操作被推入由**top**指针指示的栈位置。**top**的初始值是-1。在推入栈之前，**top**的值增加1。因此，**top**的值增加到0，作为余数出现的二进制数字（在这种情况下，是1）被推入**stack[0]**（见*图3.18*），并且**11000**作为商返回：
- en: '![](img/9ac21bf6-eb3d-4eda-89ac-509a35205b6c.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ac21bf6-eb3d-4eda-89ac-509a35205b6c.png)'
- en: Figure 3.18
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18
- en: 'We will again apply the mod **10** operator to the quotient to separate the
    last digit of the present binary number. This time, **0** will be returned as
    the remainder and **1100** as the quotient on the application of the mod **10**
    operator. The remainder is again pushed to the stack. As mentioned before, the
    value of **top** is incremented before applying the `push` operation. As the value
    of **top** was **0**, it is incremented to **1** and our new remainder, **0**,
    is pushed to **stack[1]**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次应用mod **10**运算符到商上，以分离当前二进制数的最后一位数字。这次，mod **10**运算符将返回**0**作为余数，**1100**作为商。余数再次推入栈中。如前所述，在应用`push`操作之前，**top**的值会增加。由于**top**的值是**0**，它增加到**1**，我们的新余数**0**被推入**stack[1]**：
- en: '![](img/5c579654-ae4a-4983-8944-280c41504e0c.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c579654-ae4a-4983-8944-280c41504e0c.png)'
- en: Figure 3.19
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19
- en: 'We will repeat this procedure until all the digits of the binary number are
    separated and pushed to the stack, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复此过程，直到将二进制数的所有数字分离并推入栈中，如下所示：
- en: '![](img/e1674e0f-e8c5-4a58-827d-a4c989295a86.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1674e0f-e8c5-4a58-827d-a4c989295a86.png)'
- en: Figure 3.20
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20
- en: Once that's done, the next step is to pop the digits out one by one and multiply
    every digit by **2** raised to the power of **top**. For example, **2** raised
    to the power of top means **2** will be raised to the value of the index location
    from where the binary digit was popped off. The value from the stack is popped
    out from the location indicated by **top**.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，下一步就是逐个弹出数字，并将每个数字乘以**2**的**top**次方。例如，**2**的**top**次方意味着**2**将提升到从二进制数字被弹出位置开始的索引值。从栈中弹出的值将从**top**指示的位置弹出。
- en: 'The value of **top** is currently **5**, hence the element at **stack[5]** will
    be popped out and multiplied by **2** raised to the power **5**, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**top**的当前值是**5**，因此**stack[5]**中的元素将被弹出，并乘以**2**的**5**次方，如下所示：'
- en: '![](img/e5163bb4-bdb2-4fd2-97cb-949f6965eb03.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5163bb4-bdb2-4fd2-97cb-949f6965eb03.png)'
- en: Figure 3.21
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21
- en: 'After popping a value from the stack, the value of **top** is decremented by
    1 to point at the next element to be popped out. The procedure is repeated until
    every digit is popped out and multiplied by **2** raised to the power of its top
    location value. *Figure 3.19* shows how all the binary digits are popped from
    the stack and multiplied by **2** raised to the power of **top**:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从栈中弹出一个值后，**top** 的值减少 1，以指向下一个要弹出的元素。这个过程会一直重复，直到所有数字都被弹出并乘以 **2** 的 **top**
    位置值的幂。*图 3.19* 展示了如何从栈中弹出所有二进制位并乘以 **2** 的 **top** 次幂：
- en: '![](img/2f8007e3-574f-40b8-90e4-1e57d475714e.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f8007e3-574f-40b8-90e4-1e57d475714e.png)'
- en: Figure 3.22
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22
- en: The resulting number we get is the decimal equivalent of the binary number that
    was entered by the user.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果是用户输入的二进制数的十进制等价数。
- en: Now, to convert a decimal number into a hexadecimal format, we will divide it
    by 16\. We need to keep dividing the number until the quotient becomes smaller
    than `16`. The remainders of the division are displayed in LIFO order. If the
    remainder is below 10, it is displayed as is; otherwise, its equivalent letter
    is displayed. You can use the preceding table to find the equivalent letter if
    you get a remainder between 10 and 15.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将十进制数转换为十六进制格式，我们将它除以 16。我们需要继续除以数字，直到商小于 `16`。除法的余数以 LIFO 顺序显示。如果余数小于 10，则直接显示；否则，显示其等效字母。如果你得到
    10 到 15 之间的余数，可以使用前面的表格找到等效字母。
- en: 'In the following figure, you can see that the decimal number **49** is divided
    by **16**. The remainders are displayed in LIFO order to display the hexadecimal,
    hence 31 is the hexadecimal of the binary number **110001**. You don’t need to
    apply the preceding table as both the remainders are less than 10:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到十进制数 **49** 被除以 **16**。余数以 LIFO 顺序显示，以显示十六进制，因此 31 是二进制数 **110001**
    的十六进制表示。由于余数都小于 10，你不需要应用前面的表格：
- en: '![](img/f3507920-6015-401d-ab09-e679e11144d0.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3507920-6015-401d-ab09-e679e11144d0.png)'
- en: Figure 3.23
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23
- en: 'Let''s use GCC to compile the `binaryintohexa.c` program, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `binaryintohexa.c` 程序，如下所示：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is one output of the program:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序的另一个输出：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is another output of the program:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序的另一个输出：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Voilà! We've successfully converted a binary number into a hexadecimal number.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功将二进制数转换为十六进制数。
- en: Now, let's move on to the next recipe!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Finding whether a number is a palindrome
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找一个数字是否是回文数
- en: A palindrome number is one that appears the same when read forward and backward.
    For example, 123 is not a palindrome but 737 is. To find out whether a number
    is a palindrome, we need to split it into separate digits and convert the unit
    of the original number to hundred and the hundred to unit.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 回文数是指正向和反向读取时都相同的数。例如，123 不是回文数，但 737 是。要判断一个数是否是回文数，我们需要将其分解成单独的数字，并将原始数的个位转换为百位，百位转换为个位。
- en: 'For example, a `pqr` number will be called a **palindrome** **number** if `pqr=rqp`.
    And `pqr` will be equal to `rqp` only if the following is true:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 `pqr` 数字如果 `pqr=rqp`，则被称为**回文** **数**。只有当以下条件成立时，`pqr` 才会等于 `rqp`：
- en: '*p x 100 + q x 10 + r = r x 100 + q x 10 + p*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*p x 100 + q x 10 + r = r x 100 + q x 10 + p*'
- en: In other words, we will have to multiply the digit in the unit place by 10²
    to convert it into the hundreds and convert the digit in the hundreds place to unit by
    multiplying it by 1\. If the result matches the original number, it is a palindrome.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们将个位上的数字乘以 10²，将其转换为百位，并将百位上的数字通过乘以 1\ 转换为个位。如果结果与原始数字匹配，则它是回文数。
- en: How to do it…
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Enter a number to assign to the `n` variable:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个数字以分配给 `n` 变量：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Invoke the `findpalindrome` function and pass the number in the `n` variable
    to it as an argument:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `findpalindrome` 函数并将 `n` 变量中的数字作为参数传递给它：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `n` argument is assigned to the `numb` parameter in the `findpalindrome`
    function. We need to separate each digit of the number; to do so, we will execute
    a `while` loop for the time the value in the `numb` variable is greater than `0`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`n` 参数被分配给 `findpalindrome` 函数中的 `numb` 参数。我们需要分离数字的每一位；为此，我们将执行一个 `while`
    循环，直到 `numb` 变量的值大于 `0`：'
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Within the `while` loop, we will apply mod 10 on the number. On application
    of the mod `10` operator, we will get the remainder, which is basically the last
    digit of the number:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，我们将对数字应用模 10。应用模 `10` 运算符后，我们将得到余数，这基本上是数字的最后一位：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Push that remainder to the stack:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将那个余数推入栈中：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Because the last digit of the number is separated, we need to remove the last
    digit from the existing number. That is done by dividing the number by 10 and
    truncating the fraction. The `while` loop will terminate when the number is individually
    divided into separate digits and all the digits are pushed to the stack:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为数字的最后一位被分离出来，我们需要从现有的数字中移除最后一位。这是通过将数字除以 10 并截断分数来完成的。`while` 循环将在数字被单独分成各个数字并将所有数字推入栈中时终止：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The number at the top of the stack will be the hundred and the one at the bottom
    of the stack will be the unit of the original number. Recall that we need to convert
    the hundred of the original number to the unit and vice versa. Pop all the digits
    out from the stack one by one and multiply each of them by `10` raised to a power.
    The power will be 0 for the first digit that is popped off. The power will be
    incremented with every value that is popped off. After being multiplied by `10`
    raised to the respective power, the digits are added into a separate variable,
    called `value`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈顶的数字将是原数的百位，而栈底的数字将是原数的个位。回想一下，我们需要将原数的百位转换为个位，反之亦然。逐个弹出栈中的所有数字，并将每个数字乘以 `10`
    的幂。对于第一个弹出的数字，幂将是 0。每次弹出值时，幂都会增加。在乘以相应的 `10` 幂之后，数字被添加到一个单独的变量中，该变量称为 `value`：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the numbers in the `numb` and `value` variables match, that means the number
    is a palindrome. If the number is a palindrome, the `findpalindrome` function
    will return a value of `1`, otherwise it will return a value of `0`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `numb` 和 `value` 变量中的数字匹配，这意味着数字是一个回文数。如果数字是回文数，`findpalindrome` 函数将返回值 `1`，否则它将返回值
    `0`：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `findpalindrome.c` program determines whether the entered number is a palindrome
    number:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`findpalindrome.c` 程序确定输入的数字是否是回文数：'
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, let's go behind the scenes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assume that the number we entered is **737**. Now, we want to know whether **737**
    is a palindrome. We will start by applying the mod **10** operator on **737**.
    On application, we will receive the remainder, **7**, and the quotient, **73**.
    The remainder, **7**, will be pushed to the stack. Before pushing to the stack,
    however, the value of the **top** pointer is incremented by 1\. The value of **top**
    is -1 initially; it is incremented to **0** and the remainder of **7** is pushed to **stack[0]** (see
    *Figure 3.21* ).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们输入的数字是 **737**。现在，我们想知道 **737** 是否是回文数。我们将从对 **737** 应用模 **10** 操作符开始。应用后，我们将收到余数
    **7** 和商数 **73**。余数 **7** 将被推入栈中。然而，在推入栈之前，**top** 指针的值增加 1。**top** 的初始值是 -1；它增加到
    **0**，余数 **7** 被推入 **stack[0]**（见 *图 3.21*）。
- en: 'The mod **10** operator returns the last digit of the number as the remainder.
    The quotient that we get on the application of the mod **10** operator is the
    original number with its last digit removed. That is, the quotient that we will
    get on the application of mod **10** operator on **737** is **73**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 模 **10** 操作符返回数字的最后一位作为余数。应用模 **10** 操作符后得到的商数是移除最后一位后的原始数字。也就是说，在将 **737**
    应用模 **10** 操作符时，我们将得到的商数是 **73**：
- en: '![](img/0cb4f884-3189-42da-acd2-9c455563b686.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cb4f884-3189-42da-acd2-9c455563b686.png)'
- en: Figure 3.24
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24
- en: 'To the quotient, **73**, we will apply the mod **10** operator again. The remainder
    will be the last digit, which is **3**, and the quotient will be **7**. The value
    of **top** is incremented by 1, making its value 1, and the remainder is pushed
    to **stack[1]**. To the quotient, **7**, we will again apply the mod **10** operator.
    Because **7** cannot be divided by **10**, **7** itself is returned and is pushed
    to the stack. Again, before the `push` operation, the value of **top** is incremented
    by 1, making its value **2**. The value of **7** will be pushed to **stack[2]**:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于商数 **73**，我们将再次应用模 **10** 操作符。余数将是最后一位数字，即 **3**，而商数将是 **7**。**top** 的值增加
    1，使其变为 1，余数被推入 **stack[1]**。对于商数 **7**，我们再次应用模 **10** 操作符。因为 **7** 不能被 **10**
    整除，所以 **7** 本身被返回并推入栈中。在 `push` 操作之前，**top** 的值再次增加 1，使其变为 **2**。**7** 的值将被推入
    **stack[2]**：
- en: '![](img/635dc95a-959c-4989-908d-95ebb8e7d639.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/635dc95a-959c-4989-908d-95ebb8e7d639.png)'
- en: Figure 3.25
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25
- en: 'After separating the number into individual digits, we need to pop each digit
    from the stack one by one and multiply each one by **10** raised to a power. The
    power will be **0** for the topmost digit on the stack and will increment by 1
    after every `pop` operation. The digit that will be popped from the stack will
    be the one indicated to by the top pointer. The value of **top** is **2**, so
    the digit on **stack[2]** is popped out and is multiplied by **10** raised to
    power of **0**:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数字分解成单个数字后，我们需要逐个弹出栈中的每个数字，并将每个数字乘以**10**的幂次。对于栈顶的数字，幂次为**0**，每次弹出操作后增加1。要从栈中弹出的数字将由栈顶指针指示。**top**的值为**2**，因此**stack[2]**上的数字被弹出，并乘以**10**的**0**次幂：
- en: '![](img/adf2c256-f0e7-42a0-aa34-8427c85cf653.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adf2c256-f0e7-42a0-aa34-8427c85cf653.png)'
- en: Figure 3.26
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26
- en: 'After every `pop` operation, the value of **top** is decremented by 1 and the
    value of the power is incremented by 1\. The next digit that will be popped out
    from the stack is the one on **stack[1]**. That is, **3** will be popped out and
    multiplied by **10** raised to the power of **1**. Thereafter, the value of **top**
    will be decremented by 1, that is, the value of **top** will become **0**, and
    the value of the power will be incremented by 1, that is, the value of the power
    that was **1** will be incremented to **2**. The digit on **stack[0] **will be
    popped out and multiplied by **10** raised to the power of **2**:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每次弹出操作后，**top**的值减少1，幂次的值增加1。下一个将被弹出的数字是**stack[1]**上的数字。也就是说，**3**将被弹出，并乘以**10**的**1**次幂。之后，**top**的值将减少1，即**top**的值变为**0**，幂次的值增加1，即幂次的值从**1**增加到**2**。**stack[0]**上的数字将被弹出，并乘以**10**的**2**次幂：
- en: '![](img/13702f79-5d93-4e65-a7a8-b89fe26c7f61.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13702f79-5d93-4e65-a7a8-b89fe26c7f61.png)'
- en: Figure 3.27
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.27
- en: All the digits that are multiplied by **10** raised to the respective power
    are then summed. Because the result of the computation matches the original number,
    **737** is a palindrome.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所有乘以**10**的相应幂次的数字相加。因为计算结果与原始数字相同，**737**是一个回文数。
- en: 'Let''s use GCC to compile the `findpalindrome.c` program, as shown in the following
    statement:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`findpalindrome.c`程序，如下所示：
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s check whether `123` is a palindrome number:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`123`是否是一个回文数：
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s check whether `737` is a palindrome number:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`737`是否是一个回文数：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Voilà! We've successfully determined whether a number was a palindrome.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功确定了数字是否是回文数。
