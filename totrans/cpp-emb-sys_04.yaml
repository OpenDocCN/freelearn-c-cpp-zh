- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Embedded C++ Ecosystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式C++生态系统
- en: At the heart of every embedded system sits a microcontroller. The transition
    from basic cores to more modern ones mirrors the evolution of technology. The
    microcontroller landscape is vast, ranging from cost-effective 8-bit cores and
    16-bit cores to modern 32-bit Arm and RISC-V® based microcontrollers. This variety
    of architecture has impacted the development of tools and compilers. While some
    manufacturers have opted to focus on C support, many have recognized the importance
    of C++ and provided good support for C++ development within their toolchains.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌入式系统的核心都有一块微控制器。从基本核心到更现代核心的转变反映了技术的演变。微控制器领域非常广泛，从经济实惠的8位和16位核心到基于现代32位Arm和RISC-V®的微控制器。这种多样的架构影响了工具和编译器的开发。虽然一些制造商选择专注于C语言支持，但许多制造商已经认识到C++的重要性，并在他们的工具链中提供了良好的C++开发支持。
- en: As the embedded system is vast and it is impossible to cover all of the available
    architectures and vendors, we will focus on Arm® Cortex®-M as one of the dominant
    architectures for modern microcontrollers and **Systems on a Chip** (**SoCs**).
    We will go through the available development environments and toolchains that
    provide support for development in C++ for the Arm Cortex-M. We will also go through
    tools such as static analyzers, learn how to profile an embedded target, and cover
    methodologies such as unit testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌入式系统非常广泛，不可能涵盖所有可用的架构和供应商，我们将重点关注Arm® Cortex®-M作为现代微控制器和**片上系统**（**SoCs**）的主要架构之一。我们将探讨提供对Arm
    Cortex-M C++开发支持的可用开发环境和工具链。我们还将探讨诸如静态分析器等工具，学习如何对嵌入式目标进行性能分析，并介绍单元测试等方法。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Compilers and development environments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器和开发环境
- en: Static analyzers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析器
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Profiling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features, make sure to select C++23 standard,
    by adding `-std=c++23` in compiler options box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议在阅读示例时使用编译器探索器（[https://godbolt.org/](https://godbolt.org/)）。选择GCC作为编译器，并针对x86架构。这将允许您查看标准输出（stdio）结果，并更好地观察代码的行为。由于我们使用了大量的现代C++特性，请确保选择C++23标准，通过在编译器选项框中添加`-std=c++23`来实现。
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03)）。
- en: Compilers and development environments
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器和开发环境
- en: The adoption of C++ in embedded systems was influenced by compiler support.
    While most compilers supported C, the support for C++ was slower. Nowadays, there
    is a variety of compilers and toolchains available for C++ depending on the target
    architecture and functional safety requirements. Support for 32-bit architecture
    such as Arm Cortex-M is generally good, but the level of support depends on the
    toolchain vendor and functional safety requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++在嵌入式系统中的采用受到编译器支持的影响。虽然大多数编译器支持C语言，但C++的支持较慢。如今，根据目标架构和功能安全要求，有各种编译器和工具链可供选择。对32位架构如Arm
    Cortex-M的支持通常很好，但支持水平取决于工具链供应商和功能安全要求。
- en: 'Many vendors offer functional safety versions of their tools that include certified
    compilers according to the safety standards for different industries. Functional
    safety standards are designed to ensure that software operates correctly and safely,
    even in the event of hardware failures or operational errors. IEC 61508 is the
    international umbrella safety standard for functional safety, and the following
    are safety standards for some industries:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多供应商提供符合不同行业安全标准的认证编译器的工具功能安全版本。功能安全标准旨在确保软件即使在硬件故障或操作错误的情况下也能正确且安全地运行。IEC
    61508是功能安全国际伞形安全标准，以下是一些行业的标准：
- en: '**ISO 26262**: Automotive safety standard'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISO 26262**：汽车安全标准'
- en: '**EN 50128**: European railways safety standard'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EN 50128**：欧洲铁路安全标准'
- en: '**IEC 62304**: International standard for medical software'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IEC 62304**：医疗软件的国际标准'
- en: '**IEC 60730-1**: Automatic electrical control for household appliances'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IEC 60730-1**：家用电器自动电气控制'
- en: Functional safety requirements are one of the first items on our checklist when
    selecting a compiler for a new project. If they call for qualified compilers,
    then we are limited to commercial versions of compilers that provide qualified
    compilers according to the exact standard in question.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择新项目的编译器时，功能性安全要求是我们清单上的首要事项之一。如果需要合格的编译器，那么我们将局限于提供符合特定标准合格编译器的商业版本。
- en: While many vendors providing tools for embedded development provide functional
    safety versions of their tools and compilers, there are also free development
    environments and open source compilers for embedded system development that can
    be used in non-critical applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多为嵌入式开发提供工具的供应商提供其工具和编译器的功能性安全版本，但也有用于嵌入式系统开发的免费开发环境和开源编译器，可用于非关键应用。
- en: 'Development environments pack different tools to make the development process
    seamless and allow you to focus on the development. These tools can also be used
    individually and tailored according to individual or organizational preferences.
    Tools used for embedded development, either individually or integrated into a
    development environment, are listed as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境打包了不同的工具，以使开发过程无缝，并允许您专注于开发。这些工具也可以单独使用，并根据个人或组织偏好进行定制。用于嵌入式开发的工具，无论是单独使用还是集成到开发环境中，如下列出：
- en: '**Code editor**: This can be as basic as a text editor or a more advanced tool
    such as Vim or Visual Studio Code supporting plugins for features such as syntax
    highlighting, autocompletion, code navigation across different source files, and
    refactoring.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编辑器**：这可以是一个基本的文本编辑器，也可以是一个更高级的工具，如 Vim 或支持语法高亮、自动完成、跨不同源文件进行代码导航和重构等插件的
    Visual Studio Code。'
- en: '**Compiler and linker**: These are used to transform code into object files
    and link them to executable and binary files that can be flashed to a target.
    Some of the most popular C++ compilers are GCC, Clang, Arm Compiler for Embedded,
    and IAR C/C++ Compiler.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器和链接器**：这些用于将代码转换为目标文件并将它们链接到可烧录到目标的可执行和二进制文件。一些最受欢迎的 C++ 编译器是 GCC、Clang、Arm
    Compiler for Embedded 和 IAR C/C++ Compiler。'
- en: '**Debugger**: It is used to flash and debug a target. Parts of the debugging
    system are a debugger probe and software that communicates with a probe to debug
    the connected target.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器**：用于烧录和调试目标。调试系统的一部分是调试器探头和与探头通信以调试连接目标的软件。'
- en: '**Build system**: Tools such as GNU Make and Ninja are used to control the
    process of compiling and linking. CMake and Bazel are used for build automation
    and dependency management.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建系统**：使用诸如 GNU Make 和 Ninja 等工具来控制编译和链接的过程。CMake 和 Bazel 用于构建自动化和依赖管理。'
- en: '**Static analysis tools**: These are used to analyze source code. Depending
    on capability, they can detect some forms of undefined behavior such as out-of-bound
    access, uninitialized variables, null pointer dereferences, and so on. Dedicated
    static analysis tools can check whether the code is MISRA or AUTOSAR-compliant.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态分析工具**：这些工具用于分析源代码。根据功能，它们可以检测一些未定义的行为，例如越界访问、未初始化的变量、空指针解引用等。专门的静态分析工具可以检查代码是否符合
    MISRA 或 AUTOSAR 标准。'
- en: '**Runtime profilers**: These are a combination of target capabilities, software
    instrumentation, and debugger probes used to measure function execution time and
    analyze the performance of your software.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时分析器**：这些是目标功能、软件仪器和调试器探头组合，用于测量函数执行时间并分析软件的性能。'
- en: 'Most embedded **integrated development environments** (**IDEs**) provide the
    following capabilities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式**集成开发环境**（**IDE**）提供以下功能：
- en: Project creation and organization
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目创建和组织
- en: Build automation
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自动化
- en: Debugging
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: 'Some development environments integrate more advanced features for code analysis,
    such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发环境集成了更高级的代码分析功能，如下所示：
- en: Static analysis
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析
- en: Profiling and performance analysis
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析和性能分析
- en: We will cover some of the most used development environments and compilers in
    the industry on the next pages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一页介绍一些行业中最常用的开发环境和编译器。
- en: Arm Keil MDK and Arm Compiler for Embedded
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arm Keil MDK 和 Arm Compiler for Embedded
- en: '**Arm® Keil® MDK** is a set of tools for embedded development on (mostly) Arm
    Cortex-M microcontrollers and it includes the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arm® Keil® MDK**是一套用于在（主要是）Arm Cortex-M微控制器上进行嵌入式开发的工具集，它包括以下内容：'
- en: Keil Studio, a set of extensions for VS Code
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keil Studio，一套VS Code的扩展
- en: Keil μVision, a legacy Windows®-based IDE
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keil μVision，一个基于传统Windows®的IDE
- en: Arm Compiler for Embedded, a C and C++ compiler
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arm编译器嵌入式版，一个C和C++编译器
- en: Arm Virtual Hardware
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arm虚拟硬件
- en: Both **Keil Studio** and **Keil μVision** provide all the IDE features needed
    for embedded development, including project configuration for different targets,
    build, and debugging on target.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Keil Studio**和**Keil μVision**都提供了嵌入式开发所需的IDE功能，包括针对不同目标的配置、构建和目标调试。'
- en: Keil μVision provides support for the integration of PC-Lint, a static C and
    C++ analyzer, while VS Code (Keil Studio) can be configured to use `clang-tidy`
    or `cppcheck`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Keil μVision提供了对PC-Lint的支持，这是一个静态的C和C++分析器，而VS Code（Keil Studio）可以配置为使用`clang-tidy`或`cppcheck`。
- en: Keil μVision is packed with Keil Simulator, allowing running firmware on simulated
    targets on your PC, and it also has an integrated profiler as a part of the μVision
    debugger.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Keil μVision集成了Keil模拟器，允许在PC上的模拟目标上运行固件，并且它还包含了一个作为μVision调试器一部分的集成分析器。
- en: Arm Keil MDK comes with Arm Virtual Hardware Fixed Virtual Platforms, which
    is Arm’s cloud platform that allows you to run binaries on simulated targets providing
    infrastructure for CI/CD in a simulated environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Arm Keil MDK附带Arm虚拟硬件固定虚拟平台，这是Arm的云平台，允许你在模拟目标上运行二进制文件，并为模拟环境中的CI/CD提供基础设施。
- en: There is a basic version of Keil MDK available for non-commercial use (Community),
    and two commercial versions (Essential and Professional), depending on the features
    available. Only the Professional commercial version comes with functional safety
    support and extended maintenance. Next, we will cover Arm Compiler for Embedded,
    a C and C++ compiler that comes with MDK. It also includes linker and standard
    libraries.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非商业用途（社区版），Keil MDK有一个基本版本，以及两个商业版本（基本版和专业版），具体取决于可用的功能。只有专业商业版提供了功能安全支持和扩展维护。接下来，我们将介绍Arm编译器嵌入式版，这是一个与MDK一起提供的C和C++编译器，它还包括链接器和标准库。
- en: '**Arm Compiler for Embedded** is a C and C++ compiler provided by Arm. Arm
    also provides a **functional safety** (**FuSa**) version of the compiler that
    is certified according to IEC 61508, ISO 26262, EN 50128, and IEC 62304 safety
    standards.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arm编译器嵌入式版**是Arm提供的一个C和C++编译器。Arm还提供了一个根据IEC 61508、ISO 26262、EN 50128和IEC
    62304安全标准认证的**功能安全**（**FuSa**）版本的编译器。'
- en: The FuSa version is available only in the highest edition of MDK – Professional.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: FuSa版本仅在MDK的最高版——专业版中提供。
- en: 'Arm Compiler for Embedded consists of the following toolchain components:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Arm编译器嵌入式版包括以下工具链组件：
- en: '`armclang`, a **low-level virtual machine** (**LLVM**)-based compiler'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`armclang`，一个基于**低级虚拟机**（**LLVM**）的编译器'
- en: '`armlink`, a linker that combines objects and libraries to produce an executable'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`armlink`，一个将对象和库组合起来生成可执行文件的工具'
- en: Arm C libraries
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arm C库
- en: Arm C++ libraries based on the LLVM `libc++` project
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于LLVM `libc++`项目的Arm C++库
- en: Arm Compiler supports C++17 standard, while the latest version of Arm Compiler
    for Embedded FuSa 6.16 supports C++ 14\. Even though we are in 2024 at the time
    of writing this book, the support for the latest version of the C++ standard is
    slow. After C++17, C++20 and C++23 were released.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Arm编译器支持C++17标准，而最新版本的Arm编译器嵌入式FuSa 6.16支持C++14。尽管我们撰写这本书的时候是2024年，但最新版本的C++标准的支持速度仍然很慢。在C++17之后，C++20和C++23也相继发布。
- en: Support of the latest C++ standard in commercial compilers is still rather slow,
    which makes the latest language features in these environments unavailable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 商业编译器对最新C++标准的支持仍然相当缓慢，这使得这些环境中最新的语言特性不可用。
- en: IAR C/C++ Compiler and IAR Embedded Workbench for Arm
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IAR C/C++编译器和IAR嵌入式工作台Arm
- en: '**IAR Embedded Workbench®** is a development environment for Arm Cortex-M,
    Cortex-R, and Cortex-A cores (IAR stands for Ingenjörsfirma Anders Rundgren).
    It integrates the following tools:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAR嵌入式工作台®**是用于Arm Cortex-M、Cortex-R和Cortex-A核心的开发环境（IAR代表Ingenjörsfirma
    Anders Rundgren）。它集成了以下工具：'
- en: IDE, including a debugger and profiler
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE，包括调试器和分析器
- en: IAR C/C++ Compiler
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAR C/C++编译器
- en: IAR C-STAT®, a static analyzer
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAR C-STAT®，一个静态分析器
- en: IAR C-RUN®, a tool for runtime analysis
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAR C-RUN®，一个运行时分析工具
- en: IAR Embedded Workbench is a well-rounded solution for the development of Arm
    Cortex-M cores. The IDE is packed with standard tools, such as a debugger, but
    also provides more advanced embedded tools, such as a profiler and running firmware
    in the simulator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: IAR嵌入式工作台是用于Arm Cortex-M核心开发的全面解决方案。IDE中包含标准工具，如调试器，但也提供了更高级的嵌入式工具，如性能分析器和在模拟器中运行固件。
- en: IAR offers C-STAT, a tool for static analysis that can run static analysis against
    safety coding standards such as MISRAC++2008.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: IAR提供C-STAT，这是一种静态分析工具，可以对MISRAC++2008等安全编码标准进行静态分析。
- en: IAR also provides C-RUN, a tool for runtime analysis that covers heap checks,
    bounds checking, buffer overrun, integer overflow, and other runtime checks by
    instrumenting your code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: IAR还提供了C-RUN，这是一种运行时分析工具，通过对你的代码进行仪器化，涵盖了堆检查、边界检查、缓冲区溢出、整数溢出和其他运行时检查。
- en: IAR C/C++ Compiler supports C++17 from 9.30.1\. The FuSa version of IAR Embedded
    Workbench for Arm, version 9.50.3 (February 2024), also provides C++17 support.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: IAR C/C++编译器从9.30.1版本开始支持C++17。IAR嵌入式工作台（针对Arm）的FuSa版本，版本9.50.3（2024年2月），也提供了C++17支持。
- en: IAR C/C++ Compiler and Arm Compiler for Embedded are commercial options for
    embedded development. Besides the support you can expect from a commercial project,
    the strength of these tools is that they provide safety-qualified versions for
    safety-critical projects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: IAR C/C++编译器和Arm编译器是嵌入式开发的商业选项。除了可以期望的商业项目支持外，这些工具的优势在于它们为安全关键项目提供了安全认证版本。
- en: Some microcontroller vendors provide their own versions of development environments,
    usually based on Eclipse®, providing additional support for their own products.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些微控制器供应商提供他们自己的开发环境版本，通常基于 Eclipse®，为他们的产品提供额外的支持。
- en: Vendor-supported IDEs and GCC
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商支持的IDE和GCC
- en: Alternatives to commercial development environments are vendor-supported environments,
    which are based mostly on Eclipse and **GNU Compiler Collection** (**GCC**) tools
    and **GNU Project Debugger (GDB**) for debugging. Examples are STM32CubeIDE by
    ST® and MCUXpresso by NXP®.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 商业开发环境的替代方案是供应商支持的环境，这些环境主要基于Eclipse和**GNU编译器集合**（**GCC**）工具以及**GNU项目调试器（GDB**）进行调试。例如，ST®的STM32CubeIDE和NXP®的MCUXpresso。
- en: These tools are packed with code configurator UIs that can generate C code used
    for GPIO configuration, clock setup, and peripheral drivers’ initialization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具包含代码配置器用户界面，可以生成用于GPIO配置、时钟设置和外设驱动程序初始化的C代码。
- en: Some vendors, such as Nordic Semiconductor®, opted for VS Code as the basis
    of their IDE solution. They provide plugins for GPIO configuration and debugging.
    VS Code is a modern code editor that allows developers to use plugins such as
    IntelliSense for code completion, parameter information, syntax highlighting,
    and many others to enhance the development experience.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商，如Nordic Semiconductor®，选择了VS Code作为其IDE解决方案的基础。他们提供了GPIO配置和调试的插件。VS Code是一个现代代码编辑器，允许开发者使用IntelliSense等插件进行代码补全、参数信息、语法高亮等功能，以增强开发体验。
- en: GCC
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GCC
- en: GCC is one of the most used C and C++ compilers in general. It is free software,
    and it is also the most popular compiler for non-critical applications that do
    not require a qualified compiler. However, even GCC can be qualified. The process
    of qualification includes compiling and running test programs and comparing outputs
    against expected results. All the issues that are found must be documented and
    a process must be put in place to mitigate them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GCC是通用中最常用的C和C++编译器之一。它是免费软件，也是非关键应用中最受欢迎的编译器，这些应用不需要合格的编译器。然而，即使是GCC也可以是合格的。认证过程包括编译和运行测试程序，并将输出与预期结果进行比较。所有发现的问题都必须记录下来，并必须建立一种流程来减轻这些问题。
- en: 'Besides the compiler, GCC also includes an assembler and linker, providing
    users with a so-called driver program (`gcc` for C and `g++` for C++). When invoked,
    the driver program runs preprocessing, compilation, assembly, and linking. The
    following figure visualizes the GCC compilation process:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译器外，GCC还包括汇编器和链接器，为用户提供所谓的驱动程序（C语言的`gcc`和C++的`g++`）。当调用时，驱动程序运行预处理、编译、汇编和链接。以下图示展示了GCC编译过程：
- en: '![Figure 3.1 – GCC compilation process](img/B22402_3_01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – GCC编译过程](img/B22402_3_01.png)'
- en: Figure 3.1 – GCC compilation process
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – GCC编译过程
- en: 'In *Figure 3**.1*, we see what happens when GCC is used to compile a single
    file, `main.cpp`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图3.1**中，我们看到当使用GCC编译单个文件`main.cpp`时会发生什么：
- en: GCC first runs the preprocessor, adding all header files specified with the
    `#include` directive and expanding macros in the translation unit.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GCC 首先运行预处理器，添加所有由 `#include` 指令指定的头文件，并在翻译单元中展开宏。
- en: The result from the preprocessor stage is run through the compiler, generating
    assembly.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预处理器阶段的输出将通过编译器运行，生成汇编代码。
- en: The output of the assembly stage is an object file.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编阶段的输出是一个目标文件。
- en: Finally, the linker links the object file with C and C++ standard libraries
    and generates an ELF file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，链接器将目标文件与 C 和 C++ 标准库链接，并生成 ELF 文件。
- en: 'The GCC driver program can be supplied with additional arguments to provide
    outputs from intermediate phases. To redirect preprocessor output to standard
    output, one can use the `-E` flag:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 驱动程序可以通过提供额外的参数来提供中间阶段的输出。要将预处理器输出重定向到标准输出，可以使用 `-E` 标志：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command will result in a lengthy output if `main.cpp` includes
    the **C Standard Input and Output** (**cstdio**) library. You can write a simple
    `hello world` program and see it for yourself by running the preceding command,
    or you can use Compiler Explorer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `main.cpp` 包含了 **C 标准输入输出** (**cstdio**) 库，前面的命令将产生一个冗长的输出。您可以编写一个简单的 `hello
    world` 程序，并通过运行前面的命令亲自查看，或者您可以使用编译器探索器。
- en: Compiler Explorer
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译器探索器
- en: '**Compiler Explorer** ([https://github.com/compiler-explorer/compiler-explorer](https://github.com/compiler-explorer/compiler-explorer))
    is an interactive online compiler that shows the assembly output of compiled C++,
    Rust, Go, and other code. You can try it online ([https://godbolt.org/](https://godbolt.org/)).
    It is a great tool that, by default, shows the assembly output and can be used
    to explore different language features with different compilers and compiler flags.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器探索器** ([https://github.com/compiler-explorer/compiler-explorer](https://github.com/compiler-explorer/compiler-explorer))
    是一个交互式在线编译器，它显示了编译的 C++、Rust、Go 和其他代码的汇编输出。您可以在网上尝试它 ([https://godbolt.org/](https://godbolt.org/))。这是一个非常棒的工具，默认情况下显示汇编输出，并且可以用来探索不同编译器和编译器标志下的不同语言特性。'
- en: 'Let’s use Compiler Explorer to explore the GCC compilation process. We will
    select **ARM GCC 11.2.1 (none)** as our compiler and provide it with an `-E` flag.
    **ARM GCC 11.2.1 (none)**, or **arm-none-eabi-gcc**, is the GCC used for Cortex-M
    architecture. In the following figure, we can see the preprocessor output in Compiler
    Explorer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用编译器探索器来探索 GCC 编译过程。我们将选择 **ARM GCC 11.2.1 (none)** 作为我们的编译器，并为其提供 `-E`
    标志。**ARM GCC 11.2.1 (none)**，或 **arm-none-eabi-gcc**，是用于 Cortex-M 架构的 GCC。在下面的图中，我们可以看到编译器探索器中的预处理器输出：
- en: '![Figure 3.2 – Compiler Explorer: preprocessor output](img/B22402_3_02.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 编译器探索器：预处理器输出](img/B22402_3_02.png)'
- en: 'Figure 3.2 – Compiler Explorer: preprocessor output'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 编译器探索器：预处理器输出
- en: In *Figure 3**.2*, we can see that the preprocessor adds exactly 800 lines to
    our simple `hello world` example. The preprocessor goes through the `cstdio` file,
    resolves all preprocessor directives, and pastes the result in the translation
    unit, resulting in 808 lines of code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3*.2 中，我们可以看到预处理器为我们简单的 `hello world` 示例增加了正好 800 行。预处理器遍历 `cstdio` 文件，解析所有预处理器指令，并将结果粘贴到翻译单元中，从而产生了
    808 行代码。
- en: 'The default view of Compiler Explorer is the assembly output, which we can
    get by simply removing the `–E` flag from the previous example, as shown in the
    following figure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器探索器的默认视图是汇编输出，我们可以通过简单地从上一个示例中移除 `–E` 标志来获取它，如下面的图所示：
- en: '![Figure 3.3 – Compiler Explorer: assembly output](img/B22402_3_03.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 编译器探索器：汇编输出](img/B22402_3_03.png)'
- en: 'Figure 3.3 – Compiler Explorer: assembly output'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 编译器探索器：汇编输出
- en: 'In *Figure 3**.3*, we can see the generated assembly output of GCC’s compilation
    process. We can see that the optimization process replaced the `printf` function
    with `puts`. Also, we don’t see the body of the `puts` function because this function
    is part of the C standard library that we link against. The next steps of the
    process are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3*.3 中，我们可以看到 GCC 编译过程的生成汇编输出。我们可以看到优化过程用 `puts` 函数替换了 `printf` 函数。我们也看不到
    `puts` 函数的主体，因为这个函数是我们链接的 C 标准库的一部分。该过程的下一步如下：
- en: The assembler will generate object code from the assembly code.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器将生成汇编代码的目标代码。
- en: The linker will link the generated object code with the C standard library that
    contains the `puts` implementation (among other functions).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接器将生成的目标代码与包含 `puts` 实现的 C 标准库链接（以及其他函数）。
- en: 'In this simple example, we went through GCC’s compilation process, which will
    not result in the code that we can run on a microcontroller, as we also need to
    do the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Add clock and hardware peripheral initialization code.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set compiler flags for the architecture and instruction set for our target.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a startup assembly script containing a reset handler and C and C++ runtime
    initialization.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a linker script defining different memory regions for a target, including
    RAM and Flash regions.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add instructions for the linker to link against specific C and C++ standard
    libraries.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output from the last stage of the GCC compilation process, the linking stage,
    is an **Executable and Linkable Format** (**ELF**) file. The ELF file is converted
    into binary or hex format using the `objdump` tool, as binary and hex formats
    are usually used by the flashing process to be loaded on the target.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: From version 10, GCC has an integrated static analyzer, which can be enabled
    with the `–fanalyzer` compiler flag.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Static analyzers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static analyzers** are tools that go through source code and detect potential
    issues with the code such as undefined behavior, or they check whether the code
    is compliant with a safety standard such as MISRA® or AUTOSAR®. Not all static
    analyzers have the same capabilities, and only commercial versions support safety
    standards checks. Some of the issues that can be detected with static analyzers
    are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Use of uninitialized data
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds array access
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null pointers dereference
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Division by zero
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use after delete, double delete, and other memory management issues
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can enable GCC’s static analyzer by providing the GCC driver program with
    the `–fanalyzer` flag. Let us take an example of a simple sum function that takes
    a `std::array<int, 4>` constant reference and returns the sum shown in the following
    example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The issue with the preceding example is that we are not initializing the `ret`
    variable to zero. During the stack allocation of variables in the `sum` function,
    the value of the `ret` variable will be populated with anything on the allocated
    location, leading to undefined behavior. We can add the `-fanalyzer` flag in Compiler
    Explorer and open the compiler output, as shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value](img/B22402_3_04.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.4*, we can see compiler output in a new plane, which we enabled
    by clicking on **Output (0/42)**. We can see that the static analyzer recognized
    that we were using an uninitialized variable and issued the warning. GCC, like
    many other compilers, can issue compiler warnings, and can also detect different
    issues with code, including uninitialized variables. We can enable regular compiler
    warnings using flags such as `-Wall`, `-Wextra,` `-Wpedantic`, but in this case,
    they wouldn’t catch uninitialized variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中看到这一点：
- en: '![Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value](img/B22402_3_05.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – Compiler Explorer：GCC警告，未初始化值](img/B22402_3_05.png)'
- en: 'Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – Compiler Explorer：GCC警告，未初始化值
- en: In *Figure 3**.5*, we can see that GCC didn’t issue a warning for uninitialized
    data using regular compiler warnings. Enabling a static analyzer using the `–fanalyzer`
    flag will help detect the issue, but also keep in mind that static analysis takes
    more time, which might be an issue with larger code bases. There is also a GCC
    flag, `–Wuninitialized`, which should generate a warning for uninitialized variables.
    In this particular example, it will generate a warning only if a program is compiled
    with an optimization flag different from 0 (e.g., `-O2`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图3.5**中，我们可以看到GCC在常规编译器警告中并未对未初始化的数据发出警告。使用`–fanalyzer`标志启用静态分析器可以帮助检测问题，但也要记住静态分析需要更多时间，这可能在大型代码库中成为一个问题。还有一个GCC标志`–Wuninitialized`，它应该会对未初始化的变量生成警告。在这个特定的例子中，它只会在程序使用不同于0的优化标志（例如，`-O2`）编译时生成警告。
- en: Different compilers have different capabilities, including detecting issues
    with code. If we were to compile this example using the `clang` compiler (switch
    the compiler to **armv7-a clang 11.0.1** in Compiler Explorer), we would see that
    the `clang` compiler would detect this uninitialized variable issue and emit a
    warning. Also, static analyzers have different capabilities, so it is a good practice
    to run your code through several static analyzers, as one may detect issues that
    the others can’t, and vice versa.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编译器有不同的功能，包括检测代码中的问题。如果我们使用`clang`编译器编译这个例子（在Compiler Explorer中将编译器切换到**armv7-a
    clang 11.0.1**），我们会看到`clang`编译器会检测到这个未初始化变量的问题并发出警告。此外，静态分析器有不同的功能，因此运行代码通过几个静态分析器是一个好习惯，因为一个可能检测到其他分析器无法检测到的问题，反之亦然。
- en: 'Here is another example of a static analyzer in action, detecting out-of-bounds
    access:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是静态分析器在检测越界访问时的另一个示例：
- en: '![Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access](img/B22402_3_06.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – Compiler Explorer：静态分析器，越界访问](img/B22402_3_06.png)'
- en: 'Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – Compiler Explorer：静态分析器，越界访问
- en: In *Figure 3**.6*, we are trying to access the fifth element of an array that
    has four elements, which will result in undefined behavior. This was caught by
    the GCC’s static analyzer, which issued a descriptive warning. In GCC, warnings
    can be treated as errors that will result in failed compilation and no ELF file
    generated. To treat warnings as errors, just add the `-Werror` compiler flag to
    the GCC driver program invocation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图3.6**中，我们正在尝试访问一个有四个元素的数组的第五个元素，这将导致未定义的行为。这个问题被GCC的静态分析器捕获，并发出描述性的警告。在GCC中，警告可以被当作错误处理，这将导致编译失败并且不会生成ELF文件。要将警告当作错误处理，只需在GCC驱动程序调用中添加`-Werror`编译器标志。
- en: There are other commonly used static analyzers, most notably `clang-tidy` and
    `cppcheck`. `clang-tidy` can be enabled in Compiler Explorer using the **Add tool**
    option. Both `clang-tidy` ([https://clang.llvm.org/extra/clang-tidy/](https://clang.llvm.org/extra/clang-tidy/))
    and `cppcheck` ([https://cppcheck.sourceforge.io/](https://cppcheck.sourceforge.io/))
    are easy to install and use, and as previously stated, it is usually a good idea
    to use several static analyzers to catch different issues with the code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他常用的静态分析器，最著名的是`clang-tidy`和`cppcheck`。`clang-tidy`可以通过Compiler Explorer中的**添加工具**选项启用。`clang-tidy`([https://clang.llvm.org/extra/clang-tidy/](https://clang.llvm.org/extra/clang-tidy/))和`cppcheck`([https://cppcheck.sourceforge.io/](https://cppcheck.sourceforge.io/))都易于安装和使用，如前所述，通常使用几个静态分析器来捕捉代码的不同问题是一个好主意。
- en: Static analyzers are great for catching common programming errors and potential
    issues with your code or making sure that code is compliant according to a safety
    standard, but they don’t guarantee that the code does what it is supposed to do.
    To validate the actual functionality of our firmware, we can run manual tests
    on a target or we can use unit testing to write test cases for individual pieces
    of our code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器非常适合捕捉常见的编程错误和代码中可能的问题，或者确保代码符合安全标准，但它们不能保证代码确实做了它应该做的事情。为了验证我们固件的实际功能，我们可以在目标上手动测试，或者我们可以使用单元测试为我们的代码的各个部分编写测试用例。
- en: Unit testing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit testing** is the process of testing units of code by using a test framework
    that provides infrastructure for setting up tests, running them, and reporting
    them. So, what is a unit of code? It depends on what we want to test; it can be
    a function or a software module, or we can reason about unit testing as testing
    a unit of work. What does the firmware need to do if a user presses a button,
    or what does it need to do if we receive a specific packet over a **Bluetooth®
    Low Energy** (**BLE**) connection?'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是通过使用提供测试设置、运行和报告基础设施的测试框架来测试代码单元的过程。那么，什么是代码单元呢？这取决于我们想要测试什么；它可以是函数或软件模块，或者我们可以将单元测试视为对工作单元的测试。当用户按下按钮时，固件需要做什么，或者如果我们通过**蓝牙低功耗**（**BLE**）连接接收到特定的数据包时，它需要做什么？'
- en: Depending on the granularity of unit testing, we can test different components
    of firmware on the individual level and their interaction to ensure proper functionality.
    Unit tests test the units of code or units of work in isolation from other software
    components. This forces us to focus on the functionality of said units during
    the development and split the responsibilities between components more easily,
    leading to more robust software.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据单元测试的粒度，我们可以在个体层面上测试固件的各个组件及其交互，以确保其正常功能。单元测试在与其他软件组件隔离的情况下测试代码单元或工作单元。这迫使我们关注这些单元的功能，并在开发过程中更容易地分配组件之间的责任，从而产生更健壮的软件。
- en: Most of the C++ testing frameworks are not well suited for running on small,
    embedded targets due to the resulting binary size, most notably, due to the usage
    of `ostream` from the standard library. This leaves us with the option to run
    our unit tests on the host machine instead of the embedded target. This is not
    to say that unit tests can’t be run on embedded targets. Running tests on a target
    takes more time, as all tests would need to be compiled for the target and flashed
    to it, and we’d need a report-catching mechanism on the host machine to read test
    results.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的二进制文件大小，大多数C++测试框架不适合在小型、嵌入式目标上运行，尤其是由于标准库中`ostream`的使用。这使我们有了在主机机器上而不是在嵌入式目标上运行单元测试的选择。这并不是说单元测试不能在嵌入式目标上运行。在目标上运行测试需要更多时间，因为所有测试都需要为目标编译并闪存到目标中，我们还需要在主机机器上有一个捕获报告的机制来读取测试结果。
- en: Running tests off the target on a host machine is a common practice. However,
    there are concerns about this approach, as tests are run on a different architecture
    where even data types can have different sizes. To address this, one can enforce
    the use of fixed-width data types (e.g., `uint8_t` or `int32_t`). Additionally,
    there may be differences between the compilers used for the host and target machines,
    so it is advisable to use the same versions of compilers. Running tests on a host
    machine is faster and easier, but the differences between architectures and setups
    can potentially have an impact on test results. There are manual target tests
    and system and integration tests that can discover potential issues with code
    functionality and serve as an additional layer of functionality validation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机机器上运行目标外的测试是一种常见做法。然而，这种方法存在一些担忧，因为测试是在不同的架构上运行的，甚至数据类型的大小也可能不同。为了解决这个问题，可以强制使用固定宽度的数据类型（例如，`uint8_t`或`int32_t`）。此外，主机和目标机器使用的编译器之间可能存在差异，因此建议使用相同的编译器版本。在主机机器上运行测试更快、更简单，但架构和设置之间的差异可能会对测试结果产生影响。存在手动目标测试、系统和集成测试，这些测试可以发现代码功能中的潜在问题，并作为功能验证的额外层。
- en: 'There are different testing frameworks for C++, and some of the most used are
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++，存在不同的测试框架，以下是一些最常用的：
- en: Google Test
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Test
- en: Catch2
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Catch2
- en: Boost.Test
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Test
- en: CppUTest
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CppUTest
- en: 'We can easily try them in Compiler Explorer by adding the relevant libraries.
    The first thing to do is to add an **Execution Only** pane, as shown in the following
    figure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在编译器探索器中轻松尝试它们，通过添加相关的库。首先要做的是添加一个**仅执行**面板，如图所示：
- en: '![Figure 3.7 – Compiler Explorer: execution pane](img/B22402_3_07.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 编译器探索器：执行面板](img/B22402_3_07.png)'
- en: 'Figure 3.7 – Compiler Explorer: execution pane'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 编译器探索器：执行面板
- en: 'In *Figure 3**.7*, we added an execution pane and selected **x86-64 gcc 13.2**
    as the compiler. Now, we need to add the Google Test library by clicking on the
    **Libraries** button in the execution pane. It will open a new window in which
    we can search for a library and include it, as shown in the following figure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.7*中，我们添加了一个执行面板，并选择**x86-64 gcc 13.2**作为编译器。现在，我们需要通过在执行面板中点击**库**按钮来添加Google
    Test库。它将打开一个新窗口，我们可以在此搜索库并将其包含在内，如图所示：
- en: '![Figure 3.8 – Compiler Explorer: including a library](img/B22402_3_08.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 编译器探索器：包含库](img/B22402_3_08.png)'
- en: 'Figure 3.8 – Compiler Explorer: including a library'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 编译器探索器：包含库
- en: 'In *Figure 3**.8*, we search for the Google Test library and we add it to the
    project by selecting the version in the drop-down menu. Let’s see how we can test
    our generic ring buffer implementation from the first chapter using Google Test.
    The following is the code with ring buffer implementation and a couple of simple
    tests:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.8*中，我们搜索Google Test库，并通过在下拉菜单中选择版本将其添加到项目中。让我们看看如何使用Google Test测试第一章中提到的通用环形缓冲区实现。以下是与环形缓冲区实现和几个简单测试相关的代码：
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the ring buffer implementation is the same as in the
    first chapter with the addition of the `get_count` method, which returns the number
    of elements currently held by the buffer. We defined a test suite, `RingBufferInt`,
    using the `TEST` macro. We specified two tests named `PushPop` and `GetCount`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，环形缓冲区实现与第一章相同，增加了`get_count`方法，该方法返回缓冲区当前持有的元素数量。我们使用`TEST`宏定义了一个测试套件，名为`RingBufferInt`。我们指定了两个测试，分别命名为`PushPop`和`GetCount`。
- en: In the `PushPop` test, we are testing the `push` and `pop` functionality of
    the ring buffer, making sure that `pop` will return pushed values in the correct
    order using the `EXPECT_EQ` macro.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PushPop`测试中，我们正在测试环形缓冲区的`push`和`pop`功能，确保`pop`将使用`EXPECT_EQ`宏按正确顺序返回推送的值。
- en: 'In the `GetCount` test, we are checking whether the number of elements held
    by the buffer matches the intended functionality using the following scenario:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetCount`测试中，我们通过以下场景检查缓冲区持有的元素数量是否与预期功能匹配：
- en: We first push 50 values to the buffer, which can hold a maximum of 20 values,
    making sure that `get_count` will return `20`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先向缓冲区推送50个值，该缓冲区最多可以容纳20个值，确保`get_count`将返回`20`。
- en: We then pop 10 values from the buffer and check whether the count will be equal
    to `10`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从缓冲区中弹出10个值，并检查计数是否等于`10`。
- en: 'Running the preceding program will result in Google Test generating a report
    on standard output, as in the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序将在标准输出上生成Google Test的报告，如图所示：
- en: '![Figure 3.9 – Compiler Explorer: Google Test execution](img/B22402_3_09.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 编译器探索器：Google Test执行](img/B22402_3_09.png)'
- en: 'Figure 3.9 – Compiler Explorer: Google Test execution'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 编译器探索器：Google Test执行
- en: In *Figure 3**.9*, we see the results of our tests in the execution pane. The
    `TEST` macro will ensure that tests are automatically registered in the framework
    so we don’t need to add them manually. This allows us to focus on writing tests
    utilizing the infrastructure provided by the framework. Google Test offers a lot
    more, and this example is just a glimpse into its capabilities.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.9*中，我们可以在执行面板中看到测试的结果。`TEST`宏将确保测试自动注册到框架中，因此我们不需要手动添加。这使我们能够专注于编写利用框架提供的基础设施的测试。Google
    Test提供了更多功能，这个例子只是对其能力的一瞥。
- en: Writing unit tests makes us think about how our code interacts with other software
    modules in the system. By focusing on units of code, we can write code that is
    loosely coupled, making our software more flexible and robust. Unit tests are
    crucial for development techniques such as **Test-Driven Development** (**TDD**),
    which requires us to write tests before we write the code. After we write a unit
    test, we write the actual code just to pass the test, and then we add more tests,
    refactor the implementation, and iterate on the process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试让我们思考我们的代码如何与系统中的其他软件模块交互。通过关注代码单元，我们可以编写松散耦合的代码，使我们的软件更加灵活和健壮。单元测试对于像**测试驱动开发**（**TDD**）这样的开发技术至关重要，它要求我们在编写代码之前编写测试。在编写单元测试后，我们编写实际代码只是为了通过测试，然后添加更多测试，重构实现，并迭代这个过程。
- en: Unit tests are a powerful tool for validating the functionality of our code,
    whether we run them on the target or the host platform. Still, they don’t tell
    us a lot about the performance of our firmware. For that, we need to run the production
    firmware on the target and measure the performance using profiler tools.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是验证我们代码功能的有效工具，无论我们在目标设备还是主机平台上运行它们。然而，它们并没有告诉我们很多关于固件性能的信息。为了做到这一点，我们需要在目标设备上运行生产固件，并使用性能分析工具来测量性能。
- en: Profiling
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: Running code on the target and profiling is the best way to ensure the **Worst-Case
    Execution Time** (**WCET**) for critical functionality and make necessary optimizations
    if needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标设备上运行代码并进行性能分析是确保关键功能**最坏情况执行时间**（**WCET**）的最佳方法，并在必要时进行必要的优化。
- en: The challenge with profiling is that it is an intrusive operation, as the code
    source needs to be modified or instrumented to enable traces that can tell us
    more about what is happening internally on the target.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析的挑战在于它是一种侵入性操作，因为代码源需要修改或插桩以启用可以告诉我们更多关于目标内部发生情况的跟踪。
- en: 'Profiling depends on target capabilities. Some cores have integrated units
    for tracing, as we saw in the previous chapter, providing profiling that is minimally
    invasive. Also, some targets have special interfaces that allow high-speed trace
    data transfer using advanced debugging and tracing probes connected to the host
    machine. We can see an example of profiling infrastructure used for some Cortex-M
    targets in the following figure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析依赖于目标设备的能力。一些核心集成了用于跟踪的单元，正如我们在上一章中看到的，这提供了最小侵入性的性能分析。此外，一些目标设备具有特殊的接口，允许通过连接到主机的高级调试和跟踪探针进行高速跟踪数据传输。以下图示展示了用于某些Cortex-M目标设备的性能分析基础设施示例：
- en: "![Figure 3.10 – \uFEFFArm target connected to host machine over a debug probe](img/B22402_3_10.png)"
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – Arm目标设备通过调试探针连接到主机机](img/B22402_3_10.png)'
- en: Figure 3.10 – Arm target connected to host machine over a debug probe
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 通过调试探针连接到主机机的Arm目标设备
- en: 'In *Figure 3**.10*, we can see an Arm target connected over a debugging probe
    to a host machine. Profiling, or trace data flow, can be described through the
    next steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图3.10**中，我们可以看到一个通过调试探针连接到主机机的Arm目标设备。性能分析或跟踪数据流可以通过以下步骤进行描述：
- en: A **Program Counter** (**PC**) is sampled using DWT and generates an event.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用DWT对**程序计数器**（**PC**）进行采样并生成一个事件。
- en: ITM sends events generated by DWT and instrumented code over **Single Wire Output
    SWO** to a debugging probe.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ITM通过**单线输出SWO**将DWT生成的事件和插桩代码发送到调试探针。
- en: The debugging probe transfers trace data to capturing software on the host machine
    over USB.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试探针将跟踪数据通过USB传输到主机上的捕获软件。
- en: Capturing software is usually a part of a larger software package that can analyze
    and visualize captured received data.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获软件通常是更大软件包的一部分，可以分析和可视化捕获到的接收数据。
- en: In order to have precise information about function execution times, the source
    code needs to be instrumented by adding instructions that will generate trace
    data. We saw how this can be achieved in the previous chapter using GCC’s compiler
    features for adding instructions to the entry and exit of every function. This
    data can be sent using ITM to profiler software running on the host machine. This
    approach has good accuracy, but by adding instructions to code, we are degrading
    performances for the sake of measurement.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得关于函数执行时间的精确信息，源代码需要通过添加生成跟踪数据的指令来进行**代码插桩**。我们在上一章中看到了如何使用GCC编译器的功能为每个函数的入口和退出添加指令来实现这一点。这些数据可以通过ITM发送到在主机上运行的性能分析软件。这种方法具有很好的准确性，但通过向代码中添加指令，我们为了测量目的而降低了性能。
- en: PC sampling can be less intrusive than code instrumentation, but it is less
    accurate and can serve only to detect bottlenecks in the firmware without precise
    timing information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PC采样可能比代码插桩更不侵入，但它的准确性较低，只能用于检测固件中的瓶颈，而无需精确的计时信息。
- en: Some Arm cores have an integrated **Embedded Trace Macrocell** (**ETM**). ETM
    records instruction execution, generates trace data, and sends it to the connected
    probe. With the instruction trace data, a profiler can measure the execution time
    of functions accurately and create a call graph of each function call, the same
    as code instrumentation. ETM enables code profiling without the instrumentation
    cost.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Arm核心集成了**嵌入式跟踪宏单元**（**ETM**）。ETM记录指令执行，生成跟踪数据，并将其发送到连接的探头。有了指令跟踪数据，性能分析器可以精确测量函数的执行时间，并为每个函数调用创建调用图，就像代码仪器化一样。ETM使得在不产生仪器化成本的情况下进行代码性能分析成为可能。
- en: '**Code instrumentation** is still a very common approach as it depends less
    on the target’s integrated tracing capabilities. SEGGER’s SystemView is an example
    of a profiler for embedded targets. As we briefly discussed in the previous chapter,
    we need to use SEGGER’s SystemView and RTT libraries on the target to enable trace
    generation. In the following, you can see data generated by SystemView:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码仪器化**仍然是一个非常常见的方法，因为它对目标集成的跟踪能力依赖较少。SEGGER的SystemView是嵌入式目标性能分析器的一个例子。正如我们在上一章中简要讨论的，我们需要在目标上使用SEGGER的SystemView和RTT库来启用跟踪生成。在下面的内容中，您可以看到SystemView生成的数据：'
- en: '![Figure 3.11 – SystemView](img/B22402_3_11.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – SystemView](img/B22402_3_11.png)'
- en: Figure 3.11 – SystemView
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – SystemView
- en: In *Figure 3**.11*, we see the names of functions from instrumented firmware,
    including minimum and maximum running time. Profiling code can help with the optimization
    of time-critical sections of firmware, enabling us to ensure the system’s timing
    requirements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.11*中，我们可以看到来自仪器化固件的功能名称，包括最小和最大运行时间。性能分析代码可以帮助优化固件中时间关键部分，从而确保系统的时序要求。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered the available tools for C++ development in the
    *Embedded* domain. There is a variety of available development environments and
    compilers. While commercial solutions come with guaranteed support and have functional
    safety editions of their tools, free tools are also common and can even be qualified
    if needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了嵌入式领域C++开发的可用工具。有各种各样的开发环境和编译器。虽然商业解决方案提供保证支持，并且有工具的功能安全版本，但免费工具也很常见，如果需要甚至可以合格。
- en: Static analyzers can help in avoiding common programming issues and ensure safety
    guidelines compliances. By using unit tests, we can validate the functionality
    of our firmware, and profilers can help with detecting bottlenecks, measuring
    WCET, and ensuring timing requirements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器可以帮助避免常见的编程问题，并确保符合安全指南。通过使用单元测试，我们可以验证我们固件的功能，而性能分析器可以帮助检测瓶颈、测量WCET以及确保时序要求。
- en: In the next chapter, we will create a development environment for C++ for embedded
    applications using selected free tools.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用选定的免费工具为嵌入式应用创建C++的开发环境。
- en: Join our community on Discord
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_code_Discord.png)'
