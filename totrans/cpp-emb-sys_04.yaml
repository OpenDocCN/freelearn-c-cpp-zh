- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embedded C++ Ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of every embedded system sits a microcontroller. The transition
    from basic cores to more modern ones mirrors the evolution of technology. The
    microcontroller landscape is vast, ranging from cost-effective 8-bit cores and
    16-bit cores to modern 32-bit Arm and RISC-V® based microcontrollers. This variety
    of architecture has impacted the development of tools and compilers. While some
    manufacturers have opted to focus on C support, many have recognized the importance
    of C++ and provided good support for C++ development within their toolchains.
  prefs: []
  type: TYPE_NORMAL
- en: As the embedded system is vast and it is impossible to cover all of the available
    architectures and vendors, we will focus on Arm® Cortex®-M as one of the dominant
    architectures for modern microcontrollers and **Systems on a Chip** (**SoCs**).
    We will go through the available development environments and toolchains that
    provide support for development in C++ for the Arm Cortex-M. We will also go through
    tools such as static analyzers, learn how to profile an embedded target, and cover
    methodologies such as unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compilers and development environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analyzers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features, make sure to select C++23 standard,
    by adding `-std=c++23` in compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03)).
  prefs: []
  type: TYPE_NORMAL
- en: Compilers and development environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adoption of C++ in embedded systems was influenced by compiler support.
    While most compilers supported C, the support for C++ was slower. Nowadays, there
    is a variety of compilers and toolchains available for C++ depending on the target
    architecture and functional safety requirements. Support for 32-bit architecture
    such as Arm Cortex-M is generally good, but the level of support depends on the
    toolchain vendor and functional safety requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many vendors offer functional safety versions of their tools that include certified
    compilers according to the safety standards for different industries. Functional
    safety standards are designed to ensure that software operates correctly and safely,
    even in the event of hardware failures or operational errors. IEC 61508 is the
    international umbrella safety standard for functional safety, and the following
    are safety standards for some industries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ISO 26262**: Automotive safety standard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EN 50128**: European railways safety standard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IEC 62304**: International standard for medical software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IEC 60730-1**: Automatic electrical control for household appliances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional safety requirements are one of the first items on our checklist when
    selecting a compiler for a new project. If they call for qualified compilers,
    then we are limited to commercial versions of compilers that provide qualified
    compilers according to the exact standard in question.
  prefs: []
  type: TYPE_NORMAL
- en: While many vendors providing tools for embedded development provide functional
    safety versions of their tools and compilers, there are also free development
    environments and open source compilers for embedded system development that can
    be used in non-critical applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Development environments pack different tools to make the development process
    seamless and allow you to focus on the development. These tools can also be used
    individually and tailored according to individual or organizational preferences.
    Tools used for embedded development, either individually or integrated into a
    development environment, are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code editor**: This can be as basic as a text editor or a more advanced tool
    such as Vim or Visual Studio Code supporting plugins for features such as syntax
    highlighting, autocompletion, code navigation across different source files, and
    refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiler and linker**: These are used to transform code into object files
    and link them to executable and binary files that can be flashed to a target.
    Some of the most popular C++ compilers are GCC, Clang, Arm Compiler for Embedded,
    and IAR C/C++ Compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugger**: It is used to flash and debug a target. Parts of the debugging
    system are a debugger probe and software that communicates with a probe to debug
    the connected target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build system**: Tools such as GNU Make and Ninja are used to control the
    process of compiling and linking. CMake and Bazel are used for build automation
    and dependency management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static analysis tools**: These are used to analyze source code. Depending
    on capability, they can detect some forms of undefined behavior such as out-of-bound
    access, uninitialized variables, null pointer dereferences, and so on. Dedicated
    static analysis tools can check whether the code is MISRA or AUTOSAR-compliant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime profilers**: These are a combination of target capabilities, software
    instrumentation, and debugger probes used to measure function execution time and
    analyze the performance of your software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most embedded **integrated development environments** (**IDEs**) provide the
    following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Project creation and organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some development environments integrate more advanced features for code analysis,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling and performance analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover some of the most used development environments and compilers in
    the industry on the next pages.
  prefs: []
  type: TYPE_NORMAL
- en: Arm Keil MDK and Arm Compiler for Embedded
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Arm® Keil® MDK** is a set of tools for embedded development on (mostly) Arm
    Cortex-M microcontrollers and it includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Keil Studio, a set of extensions for VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keil μVision, a legacy Windows®-based IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm Compiler for Embedded, a C and C++ compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm Virtual Hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both **Keil Studio** and **Keil μVision** provide all the IDE features needed
    for embedded development, including project configuration for different targets,
    build, and debugging on target.
  prefs: []
  type: TYPE_NORMAL
- en: Keil μVision provides support for the integration of PC-Lint, a static C and
    C++ analyzer, while VS Code (Keil Studio) can be configured to use `clang-tidy`
    or `cppcheck`.
  prefs: []
  type: TYPE_NORMAL
- en: Keil μVision is packed with Keil Simulator, allowing running firmware on simulated
    targets on your PC, and it also has an integrated profiler as a part of the μVision
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Arm Keil MDK comes with Arm Virtual Hardware Fixed Virtual Platforms, which
    is Arm’s cloud platform that allows you to run binaries on simulated targets providing
    infrastructure for CI/CD in a simulated environment.
  prefs: []
  type: TYPE_NORMAL
- en: There is a basic version of Keil MDK available for non-commercial use (Community),
    and two commercial versions (Essential and Professional), depending on the features
    available. Only the Professional commercial version comes with functional safety
    support and extended maintenance. Next, we will cover Arm Compiler for Embedded,
    a C and C++ compiler that comes with MDK. It also includes linker and standard
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arm Compiler for Embedded** is a C and C++ compiler provided by Arm. Arm
    also provides a **functional safety** (**FuSa**) version of the compiler that
    is certified according to IEC 61508, ISO 26262, EN 50128, and IEC 62304 safety
    standards.'
  prefs: []
  type: TYPE_NORMAL
- en: The FuSa version is available only in the highest edition of MDK – Professional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arm Compiler for Embedded consists of the following toolchain components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`armclang`, a **low-level virtual machine** (**LLVM**)-based compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`armlink`, a linker that combines objects and libraries to produce an executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm C libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm C++ libraries based on the LLVM `libc++` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm Compiler supports C++17 standard, while the latest version of Arm Compiler
    for Embedded FuSa 6.16 supports C++ 14\. Even though we are in 2024 at the time
    of writing this book, the support for the latest version of the C++ standard is
    slow. After C++17, C++20 and C++23 were released.
  prefs: []
  type: TYPE_NORMAL
- en: Support of the latest C++ standard in commercial compilers is still rather slow,
    which makes the latest language features in these environments unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: IAR C/C++ Compiler and IAR Embedded Workbench for Arm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IAR Embedded Workbench®** is a development environment for Arm Cortex-M,
    Cortex-R, and Cortex-A cores (IAR stands for Ingenjörsfirma Anders Rundgren).
    It integrates the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: IDE, including a debugger and profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAR C/C++ Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAR C-STAT®, a static analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAR C-RUN®, a tool for runtime analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAR Embedded Workbench is a well-rounded solution for the development of Arm
    Cortex-M cores. The IDE is packed with standard tools, such as a debugger, but
    also provides more advanced embedded tools, such as a profiler and running firmware
    in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: IAR offers C-STAT, a tool for static analysis that can run static analysis against
    safety coding standards such as MISRAC++2008.
  prefs: []
  type: TYPE_NORMAL
- en: IAR also provides C-RUN, a tool for runtime analysis that covers heap checks,
    bounds checking, buffer overrun, integer overflow, and other runtime checks by
    instrumenting your code.
  prefs: []
  type: TYPE_NORMAL
- en: IAR C/C++ Compiler supports C++17 from 9.30.1\. The FuSa version of IAR Embedded
    Workbench for Arm, version 9.50.3 (February 2024), also provides C++17 support.
  prefs: []
  type: TYPE_NORMAL
- en: IAR C/C++ Compiler and Arm Compiler for Embedded are commercial options for
    embedded development. Besides the support you can expect from a commercial project,
    the strength of these tools is that they provide safety-qualified versions for
    safety-critical projects.
  prefs: []
  type: TYPE_NORMAL
- en: Some microcontroller vendors provide their own versions of development environments,
    usually based on Eclipse®, providing additional support for their own products.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor-supported IDEs and GCC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternatives to commercial development environments are vendor-supported environments,
    which are based mostly on Eclipse and **GNU Compiler Collection** (**GCC**) tools
    and **GNU Project Debugger (GDB**) for debugging. Examples are STM32CubeIDE by
    ST® and MCUXpresso by NXP®.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are packed with code configurator UIs that can generate C code used
    for GPIO configuration, clock setup, and peripheral drivers’ initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Some vendors, such as Nordic Semiconductor®, opted for VS Code as the basis
    of their IDE solution. They provide plugins for GPIO configuration and debugging.
    VS Code is a modern code editor that allows developers to use plugins such as
    IntelliSense for code completion, parameter information, syntax highlighting,
    and many others to enhance the development experience.
  prefs: []
  type: TYPE_NORMAL
- en: GCC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GCC is one of the most used C and C++ compilers in general. It is free software,
    and it is also the most popular compiler for non-critical applications that do
    not require a qualified compiler. However, even GCC can be qualified. The process
    of qualification includes compiling and running test programs and comparing outputs
    against expected results. All the issues that are found must be documented and
    a process must be put in place to mitigate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the compiler, GCC also includes an assembler and linker, providing
    users with a so-called driver program (`gcc` for C and `g++` for C++). When invoked,
    the driver program runs preprocessing, compilation, assembly, and linking. The
    following figure visualizes the GCC compilation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – GCC compilation process](img/B22402_3_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – GCC compilation process
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.1*, we see what happens when GCC is used to compile a single
    file, `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: GCC first runs the preprocessor, adding all header files specified with the
    `#include` directive and expanding macros in the translation unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result from the preprocessor stage is run through the compiler, generating
    assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output of the assembly stage is an object file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the linker links the object file with C and C++ standard libraries
    and generates an ELF file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The GCC driver program can be supplied with additional arguments to provide
    outputs from intermediate phases. To redirect preprocessor output to standard
    output, one can use the `-E` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will result in a lengthy output if `main.cpp` includes
    the **C Standard Input and Output** (**cstdio**) library. You can write a simple
    `hello world` program and see it for yourself by running the preceding command,
    or you can use Compiler Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Compiler Explorer** ([https://github.com/compiler-explorer/compiler-explorer](https://github.com/compiler-explorer/compiler-explorer))
    is an interactive online compiler that shows the assembly output of compiled C++,
    Rust, Go, and other code. You can try it online ([https://godbolt.org/](https://godbolt.org/)).
    It is a great tool that, by default, shows the assembly output and can be used
    to explore different language features with different compilers and compiler flags.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Compiler Explorer to explore the GCC compilation process. We will
    select **ARM GCC 11.2.1 (none)** as our compiler and provide it with an `-E` flag.
    **ARM GCC 11.2.1 (none)**, or **arm-none-eabi-gcc**, is the GCC used for Cortex-M
    architecture. In the following figure, we can see the preprocessor output in Compiler
    Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Compiler Explorer: preprocessor output](img/B22402_3_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2 – Compiler Explorer: preprocessor output'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.2*, we can see that the preprocessor adds exactly 800 lines to
    our simple `hello world` example. The preprocessor goes through the `cstdio` file,
    resolves all preprocessor directives, and pastes the result in the translation
    unit, resulting in 808 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default view of Compiler Explorer is the assembly output, which we can
    get by simply removing the `–E` flag from the previous example, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Compiler Explorer: assembly output](img/B22402_3_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3 – Compiler Explorer: assembly output'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.3*, we can see the generated assembly output of GCC’s compilation
    process. We can see that the optimization process replaced the `printf` function
    with `puts`. Also, we don’t see the body of the `puts` function because this function
    is part of the C standard library that we link against. The next steps of the
    process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The assembler will generate object code from the assembly code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linker will link the generated object code with the C standard library that
    contains the `puts` implementation (among other functions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this simple example, we went through GCC’s compilation process, which will
    not result in the code that we can run on a microcontroller, as we also need to
    do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add clock and hardware peripheral initialization code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set compiler flags for the architecture and instruction set for our target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a startup assembly script containing a reset handler and C and C++ runtime
    initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a linker script defining different memory regions for a target, including
    RAM and Flash regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add instructions for the linker to link against specific C and C++ standard
    libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output from the last stage of the GCC compilation process, the linking stage,
    is an **Executable and Linkable Format** (**ELF**) file. The ELF file is converted
    into binary or hex format using the `objdump` tool, as binary and hex formats
    are usually used by the flashing process to be loaded on the target.
  prefs: []
  type: TYPE_NORMAL
- en: From version 10, GCC has an integrated static analyzer, which can be enabled
    with the `–fanalyzer` compiler flag.
  prefs: []
  type: TYPE_NORMAL
- en: Static analyzers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static analyzers** are tools that go through source code and detect potential
    issues with the code such as undefined behavior, or they check whether the code
    is compliant with a safety standard such as MISRA® or AUTOSAR®. Not all static
    analyzers have the same capabilities, and only commercial versions support safety
    standards checks. Some of the issues that can be detected with static analyzers
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of uninitialized data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds array access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null pointers dereference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Division by zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use after delete, double delete, and other memory management issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can enable GCC’s static analyzer by providing the GCC driver program with
    the `–fanalyzer` flag. Let us take an example of a simple sum function that takes
    a `std::array<int, 4>` constant reference and returns the sum shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue with the preceding example is that we are not initializing the `ret`
    variable to zero. During the stack allocation of variables in the `sum` function,
    the value of the `ret` variable will be populated with anything on the allocated
    location, leading to undefined behavior. We can add the `-fanalyzer` flag in Compiler
    Explorer and open the compiler output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value](img/B22402_3_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.4*, we can see compiler output in a new plane, which we enabled
    by clicking on **Output (0/42)**. We can see that the static analyzer recognized
    that we were using an uninitialized variable and issued the warning. GCC, like
    many other compilers, can issue compiler warnings, and can also detect different
    issues with code, including uninitialized variables. We can enable regular compiler
    warnings using flags such as `-Wall`, `-Wextra,` `-Wpedantic`, but in this case,
    they wouldn’t catch uninitialized variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value](img/B22402_3_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.5*, we can see that GCC didn’t issue a warning for uninitialized
    data using regular compiler warnings. Enabling a static analyzer using the `–fanalyzer`
    flag will help detect the issue, but also keep in mind that static analysis takes
    more time, which might be an issue with larger code bases. There is also a GCC
    flag, `–Wuninitialized`, which should generate a warning for uninitialized variables.
    In this particular example, it will generate a warning only if a program is compiled
    with an optimization flag different from 0 (e.g., `-O2`).
  prefs: []
  type: TYPE_NORMAL
- en: Different compilers have different capabilities, including detecting issues
    with code. If we were to compile this example using the `clang` compiler (switch
    the compiler to **armv7-a clang 11.0.1** in Compiler Explorer), we would see that
    the `clang` compiler would detect this uninitialized variable issue and emit a
    warning. Also, static analyzers have different capabilities, so it is a good practice
    to run your code through several static analyzers, as one may detect issues that
    the others can’t, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a static analyzer in action, detecting out-of-bounds
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access](img/B22402_3_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.6*, we are trying to access the fifth element of an array that
    has four elements, which will result in undefined behavior. This was caught by
    the GCC’s static analyzer, which issued a descriptive warning. In GCC, warnings
    can be treated as errors that will result in failed compilation and no ELF file
    generated. To treat warnings as errors, just add the `-Werror` compiler flag to
    the GCC driver program invocation.
  prefs: []
  type: TYPE_NORMAL
- en: There are other commonly used static analyzers, most notably `clang-tidy` and
    `cppcheck`. `clang-tidy` can be enabled in Compiler Explorer using the **Add tool**
    option. Both `clang-tidy` ([https://clang.llvm.org/extra/clang-tidy/](https://clang.llvm.org/extra/clang-tidy/))
    and `cppcheck` ([https://cppcheck.sourceforge.io/](https://cppcheck.sourceforge.io/))
    are easy to install and use, and as previously stated, it is usually a good idea
    to use several static analyzers to catch different issues with the code.
  prefs: []
  type: TYPE_NORMAL
- en: Static analyzers are great for catching common programming errors and potential
    issues with your code or making sure that code is compliant according to a safety
    standard, but they don’t guarantee that the code does what it is supposed to do.
    To validate the actual functionality of our firmware, we can run manual tests
    on a target or we can use unit testing to write test cases for individual pieces
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** is the process of testing units of code by using a test framework
    that provides infrastructure for setting up tests, running them, and reporting
    them. So, what is a unit of code? It depends on what we want to test; it can be
    a function or a software module, or we can reason about unit testing as testing
    a unit of work. What does the firmware need to do if a user presses a button,
    or what does it need to do if we receive a specific packet over a **Bluetooth®
    Low Energy** (**BLE**) connection?'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the granularity of unit testing, we can test different components
    of firmware on the individual level and their interaction to ensure proper functionality.
    Unit tests test the units of code or units of work in isolation from other software
    components. This forces us to focus on the functionality of said units during
    the development and split the responsibilities between components more easily,
    leading to more robust software.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the C++ testing frameworks are not well suited for running on small,
    embedded targets due to the resulting binary size, most notably, due to the usage
    of `ostream` from the standard library. This leaves us with the option to run
    our unit tests on the host machine instead of the embedded target. This is not
    to say that unit tests can’t be run on embedded targets. Running tests on a target
    takes more time, as all tests would need to be compiled for the target and flashed
    to it, and we’d need a report-catching mechanism on the host machine to read test
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests off the target on a host machine is a common practice. However,
    there are concerns about this approach, as tests are run on a different architecture
    where even data types can have different sizes. To address this, one can enforce
    the use of fixed-width data types (e.g., `uint8_t` or `int32_t`). Additionally,
    there may be differences between the compilers used for the host and target machines,
    so it is advisable to use the same versions of compilers. Running tests on a host
    machine is faster and easier, but the differences between architectures and setups
    can potentially have an impact on test results. There are manual target tests
    and system and integration tests that can discover potential issues with code
    functionality and serve as an additional layer of functionality validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different testing frameworks for C++, and some of the most used are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost.Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CppUTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can easily try them in Compiler Explorer by adding the relevant libraries.
    The first thing to do is to add an **Execution Only** pane, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Compiler Explorer: execution pane](img/B22402_3_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7 – Compiler Explorer: execution pane'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.7*, we added an execution pane and selected **x86-64 gcc 13.2**
    as the compiler. Now, we need to add the Google Test library by clicking on the
    **Libraries** button in the execution pane. It will open a new window in which
    we can search for a library and include it, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Compiler Explorer: including a library](img/B22402_3_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8 – Compiler Explorer: including a library'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.8*, we search for the Google Test library and we add it to the
    project by selecting the version in the drop-down menu. Let’s see how we can test
    our generic ring buffer implementation from the first chapter using Google Test.
    The following is the code with ring buffer implementation and a couple of simple
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the ring buffer implementation is the same as in the
    first chapter with the addition of the `get_count` method, which returns the number
    of elements currently held by the buffer. We defined a test suite, `RingBufferInt`,
    using the `TEST` macro. We specified two tests named `PushPop` and `GetCount`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PushPop` test, we are testing the `push` and `pop` functionality of
    the ring buffer, making sure that `pop` will return pushed values in the correct
    order using the `EXPECT_EQ` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GetCount` test, we are checking whether the number of elements held
    by the buffer matches the intended functionality using the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: We first push 50 values to the buffer, which can hold a maximum of 20 values,
    making sure that `get_count` will return `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then pop 10 values from the buffer and check whether the count will be equal
    to `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running the preceding program will result in Google Test generating a report
    on standard output, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Compiler Explorer: Google Test execution](img/B22402_3_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9 – Compiler Explorer: Google Test execution'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.9*, we see the results of our tests in the execution pane. The
    `TEST` macro will ensure that tests are automatically registered in the framework
    so we don’t need to add them manually. This allows us to focus on writing tests
    utilizing the infrastructure provided by the framework. Google Test offers a lot
    more, and this example is just a glimpse into its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests makes us think about how our code interacts with other software
    modules in the system. By focusing on units of code, we can write code that is
    loosely coupled, making our software more flexible and robust. Unit tests are
    crucial for development techniques such as **Test-Driven Development** (**TDD**),
    which requires us to write tests before we write the code. After we write a unit
    test, we write the actual code just to pass the test, and then we add more tests,
    refactor the implementation, and iterate on the process.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are a powerful tool for validating the functionality of our code,
    whether we run them on the target or the host platform. Still, they don’t tell
    us a lot about the performance of our firmware. For that, we need to run the production
    firmware on the target and measure the performance using profiler tools.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running code on the target and profiling is the best way to ensure the **Worst-Case
    Execution Time** (**WCET**) for critical functionality and make necessary optimizations
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with profiling is that it is an intrusive operation, as the code
    source needs to be modified or instrumented to enable traces that can tell us
    more about what is happening internally on the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiling depends on target capabilities. Some cores have integrated units
    for tracing, as we saw in the previous chapter, providing profiling that is minimally
    invasive. Also, some targets have special interfaces that allow high-speed trace
    data transfer using advanced debugging and tracing probes connected to the host
    machine. We can see an example of profiling infrastructure used for some Cortex-M
    targets in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.10 – \uFEFFArm target connected to host machine over a debug probe](img/B22402_3_10.png)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Arm target connected to host machine over a debug probe
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.10*, we can see an Arm target connected over a debugging probe
    to a host machine. Profiling, or trace data flow, can be described through the
    next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Program Counter** (**PC**) is sampled using DWT and generates an event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ITM sends events generated by DWT and instrumented code over **Single Wire Output
    SWO** to a debugging probe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The debugging probe transfers trace data to capturing software on the host machine
    over USB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capturing software is usually a part of a larger software package that can analyze
    and visualize captured received data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to have precise information about function execution times, the source
    code needs to be instrumented by adding instructions that will generate trace
    data. We saw how this can be achieved in the previous chapter using GCC’s compiler
    features for adding instructions to the entry and exit of every function. This
    data can be sent using ITM to profiler software running on the host machine. This
    approach has good accuracy, but by adding instructions to code, we are degrading
    performances for the sake of measurement.
  prefs: []
  type: TYPE_NORMAL
- en: PC sampling can be less intrusive than code instrumentation, but it is less
    accurate and can serve only to detect bottlenecks in the firmware without precise
    timing information.
  prefs: []
  type: TYPE_NORMAL
- en: Some Arm cores have an integrated **Embedded Trace Macrocell** (**ETM**). ETM
    records instruction execution, generates trace data, and sends it to the connected
    probe. With the instruction trace data, a profiler can measure the execution time
    of functions accurately and create a call graph of each function call, the same
    as code instrumentation. ETM enables code profiling without the instrumentation
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code instrumentation** is still a very common approach as it depends less
    on the target’s integrated tracing capabilities. SEGGER’s SystemView is an example
    of a profiler for embedded targets. As we briefly discussed in the previous chapter,
    we need to use SEGGER’s SystemView and RTT libraries on the target to enable trace
    generation. In the following, you can see data generated by SystemView:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – SystemView](img/B22402_3_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – SystemView
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.11*, we see the names of functions from instrumented firmware,
    including minimum and maximum running time. Profiling code can help with the optimization
    of time-critical sections of firmware, enabling us to ensure the system’s timing
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the available tools for C++ development in the
    *Embedded* domain. There is a variety of available development environments and
    compilers. While commercial solutions come with guaranteed support and have functional
    safety editions of their tools, free tools are also common and can even be qualified
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Static analyzers can help in avoiding common programming issues and ensure safety
    guidelines compliances. By using unit tests, we can validate the functionality
    of our firmware, and profilers can help with detecting bottlenecks, measuring
    WCET, and ensuring timing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a development environment for C++ for embedded
    applications using selected free tools.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
