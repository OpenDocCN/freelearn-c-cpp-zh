- en: Chapter 3. Collision
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 碰撞
- en: 'In this chapter, we will analyze collision in Unreal Engine 4, what it is,
    the different types of collision that exist in the engine, how to use it, and
    how to apply it to both static meshes and blueprints. To start with, we will first
    take an overview look of the different collisions that exist in Unreal Engine
    4, but we will also cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析Unreal Engine 4中的碰撞，它是什么，引擎中存在的不同类型的碰撞，如何使用它，以及如何将其应用于静态网格和蓝图。首先，我们将首先概述Unreal
    Engine 4中存在的不同碰撞，但也会涵盖以下主题：
- en: Simple versus complex collision
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单与复杂碰撞
- en: Generating simple collision
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成简单碰撞
- en: Creating complex and custom collision hulls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复杂和定制的碰撞外壳
- en: Collision interactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞交互
- en: Custom object and trace channels
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义对象和跟踪通道
- en: In-depth collision presets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入的碰撞预设
- en: For the purposes of this chapter, we will continue to work with Unreal Engine
    4 using the **Unreal_PhyProject** that we created in the first chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将继续使用我们在第一章中创建的**Unreal_PhyProject**在Unreal Engine 4中工作。
- en: Collision and Trace Responses – an overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞和跟踪响应 - 概述
- en: In the real world and in Unreal Engine 4, we define collision as an overlap
    of two or more objects. In the context of Unreal Engine 4, **Collision** and **Trace
    Responses** lay the groundwork for how Unreal Engine 4 handles collision and ray
    casting during the game. Every object that is given collision gets an **Object
    Type** and a series of responses that describe how it interacts with the other
    object types. In the event of either a collision or an overlap of two or more
    objects, all objects involved can be set to affect or to be affected by blocking,
    overlapping, or ignoring one another.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界和Unreal Engine 4中，我们定义碰撞为两个或更多对象的重叠。在Unreal Engine 4的上下文中，**碰撞**和**跟踪响应**为Unreal
    Engine 4在游戏过程中处理碰撞和光线投射奠定了基础。每个被赋予碰撞的对象都会得到一个**对象类型**和一系列描述它如何与其他对象类型交互的响应。在发生碰撞或两个或更多对象重叠的情况下，所有涉及的对象都可以设置为影响或被影响，通过阻止、重叠或忽略彼此。
- en: '**Trace Responses** describe how an object should react when you interact with
    a trace, which is done with a ray cast. An object can choose to block, overlap,
    or even ignore a trace from a particular source. By default, there are two different
    **Trace Responses**:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪响应**描述了当您与跟踪交互时，对象应该如何反应，这是通过光线投射完成的。对象可以选择阻止、重叠或甚至忽略来自特定来源的跟踪。默认情况下，有两种不同的**跟踪响应**：'
- en: '**Visibility**: This specifies a trace from one position to another'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**：这指定了一个从某个位置到另一个位置的跟踪'
- en: '**Camera**: This is exactly similar to the **Visibility** trace response, but
    it should be used when you use a ray cast from the camera'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**：这与**可见性**跟踪响应完全相同，但应在使用来自相机的光线投射时使用。'
- en: '**Object Responses** describe how an object should respond when you interact
    with other objects in our game world. Similar to **Trace Responses**, **Object
    Responses** offer the ability to choose whether or not an object will block, overlap,
    or ignore other objects when a collision occurs. By default, there are six different
    types of **Object Responses**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象响应**描述了当您与游戏世界中的其他对象交互时，对象应该如何响应。类似于**跟踪响应**，**对象响应**提供了选择对象在发生碰撞时是否阻止、重叠或忽略其他对象的能力。默认情况下，有六种不同的**对象响应**类型：'
- en: '**WorldStatic**: This object response is for objects in our game world that
    are static, meaning that they do not and cannot be moved by any means. Objects
    such as volumes, world geometry, or any other meshes in the game world are associated
    to this object response.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WorldStatic**: 这个对象响应适用于我们游戏世界中静止的对象，意味着它们不能也不能通过任何方式移动。例如，体积、世界几何形状或游戏世界中的任何其他网格都与这个对象响应相关联。'
- en: '**WorldDynamic**: This object response is for objects in our game world that
    are moving actors, outside of player pawns, physics bodies, vehicles, and destructible
    actors. Examples of **WorldDynamic** objects would be an elevator, a door that
    can open and close, or a wheel that a player can turn.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WorldDynamic**: 这个对象响应适用于我们游戏世界中移动的演员，除了玩家骰子、物理体、车辆和可破坏演员。**WorldDynamic**对象的例子包括电梯、可以开关的门或玩家可以旋转的轮子。'
- en: '**Pawn**: This object response is for player characters in our game or any
    other character that can be possessed by the player.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pawn**: 这个对象响应适用于我们游戏中的玩家角色或任何可以被玩家操控的角色。'
- en: '**PhysicsBody**: This object response is for any physics body or object that
    can be simulated with physics in our game world. An example of a **PhysicsBody**
    object would be a basketball that the player can pick up and throw; *Half-Life
    2* is a great example of how physics body object collisions are used in games.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PhysicsBody**：这个物体响应适用于任何可以在我们的游戏世界中用物理模拟的物理体或物体。一个**PhysicsBody**物体的例子是玩家可以捡起并投掷的篮球；“半条命2”是一个很好的例子，说明了如何在游戏中使用物理体物体碰撞。'
- en: '**Vehicle**: Although this object response is labeled as **Vehicle**, what
    this response is useful for is to have player pawns jump into them, such as a
    vehicle.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**车辆**：尽管这个物体响应被标记为**车辆**，但这个响应有用的地方是让玩家角色跳入其中，例如一辆车。'
- en: '**Destructible**: This object response is for any actors that are destructible,
    meaning that they can break apart using the destructible mesh editor.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Destructible**：这个物体响应适用于任何可破坏的演员，这意味着它们可以使用可破坏网格编辑器分解。'
- en: 'When you work on setting up collisions on an object or a component in Unreal
    Engine 4 blueprints, you will see the following properties:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Unreal Engine 4 蓝图中设置对象或组件的碰撞时，你会看到以下属性：
- en: '![Collision and Trace Responses – an overview](img/image00235.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞和轨迹响应 – 概览](img/image00235.jpeg)'
- en: It is important to note that we want to make sure that our static mesh or blueprint
    component has collision generated before setting any collision presets to that
    object; otherwise, we will not receive any responses once a collision occurs.
    Later in this chapter, we will go into more detail on how to generate simple and
    complex collisions for our objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在设置任何碰撞预设到该物体之前，我们想要确保我们的静态网格或蓝图组件已经生成了碰撞；否则，一旦发生碰撞，我们将不会收到任何响应。在本章后面，我们将详细介绍如何为我们对象生成简单和复杂的碰撞。
- en: 'When it comes to setting up **Collisions** to an object, there are numerous
    collision presets that default to Unreal Engine 4 that either ignores, overlaps,
    or blocks a combination of trace and object responses. In addition to these presets,
    we do have the option to create a custom collision preset for certain circumstances
    in our blueprint. Feel free to explore some of the collision presets and how they
    differentiate from one another, but for the sake of this text, let''s take a look
    at some of the more common presets. We will take an in-depth look at the following
    presets later on in this chapter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将**碰撞**设置到物体上时，Unreal Engine 4 默认提供了许多碰撞预设，这些预设可以忽略、重叠或阻止组合的轨迹和物体响应。除了这些预设之外，我们还有在蓝图中的特定情况下创建自定义碰撞预设的选项。请随意探索一些碰撞预设以及它们之间的区别，但为了本文的目的，让我们先看看一些更常见的预设。我们将在本章后面更深入地探讨以下预设：
- en: '**No Collision**: As the name suggests, this collision preset eliminates any
    collision responses by setting the **Visibility** trace response and the **Camera**
    trace response to ignore and sets **Collision Enabled** to **No Collision**. Typically,
    we would use this for blueprint components that we don''t want to react to any
    collisions that may occur.![Collision and Trace Responses – an overview](img/image00236.jpeg)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**No Collision**：正如其名所示，这个碰撞预设通过将**可见性**轨迹响应和**相机**轨迹响应设置为忽略，并将**碰撞启用**设置为**无碰撞**来消除任何碰撞响应。通常，我们会使用这个预设来处理我们不想对其可能发生的任何碰撞做出反应的蓝图组件。![碰撞和轨迹响应
    – 概览](img/image00236.jpeg)'
- en: '**Block All**: This collision preset causes all the collisions with the associated
    component to result in a block. Alternatively, it causes all the objects involved
    in this collision to hit and bounce off one another if physics are applied. This
    is done by setting all the responses, including the trace and object responses,
    to **Block** under their **Collision Responses**, as shown in the following screenshot:![Collision
    and Trace Responses – an overview](img/image00237.jpeg)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Block All**：这个碰撞预设导致与相关组件的所有碰撞都导致阻塞。或者，如果应用了物理，它会导致所有参与碰撞的物体相互碰撞并弹开。这是通过将所有响应（包括轨迹和物体响应）设置为**Block**在它们的**碰撞响应**下完成的，如下面的截图所示：![碰撞和轨迹响应
    – 概览](img/image00237.jpeg)'
- en: '**Overlap All**: This collision preset results in all the collisions to generate
    an overlap between all the objects involved in the collision. As long as the **Generate
    Overlap Events** property is checked, we can use the blueprint collision events
    to enable behaviors or events to occur once this type is involved in a collision.![Collision
    and Trace Responses – an overview](img/image00238.jpeg)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全部重叠**：这个碰撞预设会导致所有碰撞在所有参与碰撞的对象之间产生重叠。只要 **生成重叠事件** 属性被勾选，我们就可以使用蓝图碰撞事件来启用行为或事件，一旦这种类型参与碰撞就会发生。![碰撞和跟踪响应
    – 概览](img/image00238.jpeg)'
- en: '**Pawn**: This collision preset is useful if it is used for a player pawn or
    character in our game. By default, it is set to block **Object Responses**, block
    the **Camera** trace response, and ignore the **Visibility** trace response:![Collision
    and Trace Responses – an overview](img/image00239.jpeg)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pawn**：如果这个碰撞预设用于我们的游戏中的玩家 pawn 或角色，那么它是有用的。默认情况下，它设置为阻止 **对象响应**，阻止 **相机**
    跟踪响应，并忽略 **可见性** 跟踪响应：![碰撞和跟踪响应 – 概览](img/image00239.jpeg)'
- en: '**Physics Actor**: This collision preset is used for any actor or component
    that is a physics-based actor, meaning that the object has in-game physics (such
    as gravity) applied to it. In order for this preset to work properly, we want
    to make sure that the **Simulate Physics** property in the **Physics Tab** is
    checked. By default, all the **Trace Responses** and **Object Responses** are
    set to **Block**:![Collision and Trace Responses – an overview](img/image00240.jpeg)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理演员**：这个碰撞预设用于任何基于物理的演员或组件，这意味着对象在游戏中应用了物理（例如重力）。为了确保这个预设能够正常工作，我们想要确保在
    **物理选项卡** 中的 **模拟物理** 属性被勾选。默认情况下，所有的 **跟踪响应** 和 **对象响应** 都设置为 **阻止**：![碰撞和跟踪响应
    – 概览](img/image00240.jpeg)'
- en: 'These are just a few of the different options that Unreal Engine 4 offers by
    default for collision, and we will cover the other options in more detail later
    on in this chapter. Although there are a handful of options when it comes to collision
    presets offered in Unreal Engine 4 by default, a really nice feature that is in
    place is the ability to create your own trace, object channels, and collision
    presets. To do this, we need to navigate to the **Edit** window and select **Project
    Settings**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Unreal Engine 4 默认提供的碰撞选项中的一部分，我们将在本章的后面更详细地介绍其他选项。尽管 Unreal Engine 4 默认提供的碰撞预设选项有限，但有一个非常棒的功能是能够创建自己的跟踪、对象通道和碰撞预设。为此，我们需要导航到
    **编辑** 窗口并选择 **项目设置**：
- en: '![Collision and Trace Responses – an overview](img/image00241.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞和跟踪响应 – 概览](img/image00241.jpeg)'
- en: 'From here, we need to navigate to the **Collision** option in the **Engine**
    category:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们需要导航到 **引擎** 类别中的 **碰撞** 选项：
- en: '![Collision and Trace Responses – an overview](img/image00242.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞和跟踪响应 – 概览](img/image00242.jpeg)'
- en: In this menu, we can create custom collision presets, specify which object and
    trace channels to either ignore, overlap, or block, give it a specific name, and
    save it to the project file. For advanced needs, we can also create custom object
    and trace channels in this window. Later in this chapter, we will create our own
    custom collision preset and apply it to an object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜单中，我们可以创建自定义的碰撞预设，指定哪些对象和跟踪通道要忽略、重叠或阻止，给它一个特定的名称，并将其保存到项目文件中。对于高级需求，我们也可以在这个窗口中创建自定义的对象和跟踪通道。在本章的后面，我们将创建我们自己的自定义碰撞预设并将其应用于对象。
- en: Collision and Trace Responses – a section review
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞和跟踪响应 – 概述
- en: In this section, we briefly looked at the different **Collision** and **Trace
    Responses** that exist in Unreal Engine 4 and defined a handful of these responses.
    We analyzed the different **Trace Responses** and **Object Responses** that default
    to Unreal Engine 4, and we also defined a limited number of collision presets
    that are provided. Now that we have a basic understanding of **Collision** and
    **Trace Responses**, we can move forward and learn more about simple and complex
    collision in Unreal Engine 4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要地探讨了 Unreal Engine 4 中存在的不同 **碰撞** 和 **跟踪响应**，并定义了一些这些响应。我们分析了 Unreal
    Engine 4 默认的不同的 **跟踪响应** 和 **对象响应**，以及提供的一些有限的碰撞预设。现在，我们已经对 **碰撞** 和 **跟踪响应**
    有了一个基本的理解，我们可以继续前进，学习更多关于 Unreal Engine 4 中的简单和复杂碰撞的知识。
- en: Simple versus complex collision
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单与复杂碰撞
- en: 'In Unreal Engine 4, we will be able to autogenerate collisions for our meshes
    that can be used in our game. There are two different types of collision that
    exist in Unreal Engine 4: simple and complex collision. Each type of collision
    serves its own unique purpose, and in this section, we will simply define each
    collision type and provide examples of each. Later on in this chapter, we will
    work on how to apply these collisions to our objects. We will also test these
    collisions in our game. Let''s begin with simple collision.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，我们将能够自动生成可用于游戏中的网格碰撞。虚幻引擎4中存在两种不同的碰撞类型：简单碰撞和复杂碰撞。每种碰撞类型都有其独特的用途，在本节中，我们将简单地定义每种碰撞类型并提供每个类型的示例。稍后在本章中，我们将探讨如何将这些碰撞应用到我们的对象上。我们还将测试这些碰撞在游戏中的效果。让我们从简单碰撞开始。
- en: 'A simple collision is a collision mesh that uses basic shapes, such as boxes,
    spheres, capsules, and convex shapes, to define the bounds of our object. Convex
    shapes are ones that have one or more interior angles that are less than 180 degrees,
    whereas concave shapes are ones that possess one or more interior angles that
    are more than 180 degrees, as shown in the following image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简单碰撞是一种使用基本形状（如盒子、球体、胶囊体和凸形状）来定义我们对象边界的碰撞网格。凸形状是那些具有一个或多个小于180度的内角的形状，而凹形状是那些具有一个或多个大于180度的内角的形状，如下面的图像所示：
- en: '![Simple versus complex collision](img/image00243.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![简单与复杂碰撞](img/image00243.jpeg)'
- en: 'In addition to these basic shapes, we can generate a form of simple collision
    called **KDOP** or **K Discrete Oriented Polytope** (where K is the number of
    axis-aligned planes). What this option essentially does is that it takes the *K*
    axis-aligned planes and moves them as close as possible to the selected mesh.
    We will go into more detail on how to generate these different types of simple
    collision later on. Now, let''s define the different types of simple collision
    here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本形状之外，我们还可以生成一种称为**KDOP**或**K离散定向多面体**（其中K是轴对齐平面的数量）的简单碰撞形式。这个选项本质上所做的就是将*K*轴对齐平面移动到尽可能接近选定的网格。稍后我们将详细介绍如何生成这些不同类型的简单碰撞。现在，让我们定义简单碰撞的不同类型：
- en: '**Sphere**: This creates a spherical bound mesh around the selected object.
    It can be used in physics objects and to apply collision to objects that are round.![Simple
    versus complex collision](img/image00244.jpeg)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**球体**: 这将在选定的对象周围创建一个球形边界网格。它可以用于物理对象，并将碰撞应用到圆形对象上：![简单与复杂碰撞](img/image00244.jpeg)'
- en: '**Capsule**: This creates a capsule bound mesh around the selected object and
    is typically used for character or pawn meshes:![Simple versus complex collision](img/image00245.jpeg)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胶囊体**: 这将在选定的对象周围创建一个胶囊边界网格，通常用于角色或兵网格：![简单与复杂碰撞](img/image00245.jpeg)'
- en: '**Box**: This creates a box bound mesh around the selected object. This type
    of simple collision is most commonly used for environment meshes:![Simple versus
    complex collision](img/image00246.jpeg)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**盒子**: 这将在选定的对象周围创建一个盒子边界网格。这种简单碰撞类型最常用于环境网格：![简单与复杂碰撞](img/image00246.jpeg)'
- en: '**10DOP X**: This creates a box with four edges beveled in the *X*-aligned
    edges:![Simple versus complex collision](img/image00247.jpeg)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10DOP X**: 这将在与X对齐的边缘上创建一个带有四个边缘倒角的盒子：![简单与复杂碰撞](img/image00247.jpeg)'
- en: '**10DOP Y**: This creates a box with four edges beveled in the *Y*-aligned
    edges:![Simple versus complex collision](img/image00248.jpeg)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10DOP Y**: 这将在与Y对齐的边缘上创建一个带有四个边缘倒角的盒子：![简单与复杂碰撞](img/image00248.jpeg)'
- en: '**10DOP Z**: This creates a box with four edges beveled in the *Z*-aligned
    edges:![Simple versus complex collision](img/image00249.jpeg)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10DOP Z**: 这将在与Z对齐的边缘上创建一个带有四个边缘倒角的盒子：![简单与复杂碰撞](img/image00249.jpeg)'
- en: '**18DOP**: This creates a box with all of its edges beveled:![Simple versus
    complex collision](img/image00250.jpeg)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**18DOP**: 这将创建一个带有所有边缘倒角的盒子：![简单与复杂碰撞](img/image00250.jpeg)'
- en: '**26DOP**: This creates a box with all of its edges and corners beveled:![Simple
    versus complex collision](img/image00251.jpeg)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**26DOP**: 这将创建一个带有所有边缘和角落倒角的盒子：![简单与复杂碰撞](img/image00251.jpeg)'
- en: The main advantage of simple collision is that it almost eliminates the possibility
    of an object getting stuck to a player or vice versa. An additional advantage
    is that the collision mesh is of a basic shape, which is less expensive to use
    in the game at runtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简单碰撞的主要优势是几乎消除了对象粘附到玩家或反之亦然的可能。另一个优势是碰撞网格是基本形状，在游戏运行时使用成本较低。
- en: 'Complex collision is done for each polygon and is very expensive in Unreal
    Engine 4 as compared to simple collision. Moreover, complex collision is never
    used for an actor that is simulating physics, and it will just fall through the
    game world. In order to enable complex collision in the **Static Mesh** editor,
    we need to navigate to **Details Panel** and then to the **Static Mesh Settings**
    section. It is here that we can change the **Collision Complexity** parameter
    to **Use Simple Collision As Complex** or **Use Complex Collision As Simple**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂碰撞是对每个多边形进行的，与简单碰撞相比，在虚幻引擎4中非常昂贵。此外，复杂碰撞永远不会用于模拟物理的actor，它将直接穿过游戏世界。为了在**静态网格**编辑器中启用复杂碰撞，我们需要导航到**详细信息面板**然后到**静态网格设置**部分。在这里，我们可以将**碰撞复杂性**参数更改为**使用简单碰撞作为复杂**或**使用复杂碰撞作为简单**：
- en: '![Simple versus complex collision](img/image00252.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![简单与复杂碰撞对比](img/image00252.jpeg)'
- en: Simple versus complex collision – a section review
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单与复杂碰撞 – 一节回顾
- en: In this section, we looked at the different simple collisions offered by default
    in the **Static Mesh** editor in Unreal Engine 4\. We also discussed the advantages
    and disadvantages of the simple and complex collision when it comes to game development
    and engine performance. Lastly, we briefly looked at how to create both these
    types of collision. With a basic understanding of simple and complex collision
    under our belts, we can now discuss how to create simple collision, and how to
    create collision hulls in Unreal Engine 4 later on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了虚幻引擎4的**静态网格**编辑器默认提供的不同简单碰撞。我们还讨论了简单和复杂碰撞在游戏开发和引擎性能方面的优缺点。最后，我们简要地看了如何创建这两种类型的碰撞。在掌握了简单和复杂碰撞的基本理解之后，我们现在可以讨论如何创建简单碰撞，以及如何在虚幻引擎4中创建碰撞外壳。
- en: Creating simple collisions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单碰撞
- en: When it comes to creating collisions, there are many options that we can take
    advantage of to properly utilize collision and optimize game performance. As we
    discussed in the previous section, we have the option to create simple and complex
    collisions in the **Static Mesh** editor in Unreal Engine 4, but we can also use
    third-party art programs to create custom collision hulls. Let's first discuss
    how to create simple collisions in Unreal Engine 4, and in the next section, we
    will discuss how to create complex and custom collisions for our assets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建碰撞时，我们有多种选择可以利用，以正确利用碰撞并优化游戏性能。正如我们在上一节中讨论的，我们可以在虚幻引擎4的**静态网格**编辑器中创建简单和复杂的碰撞，但我们也可以使用第三方艺术程序来创建自定义碰撞外壳。让我们首先讨论如何在虚幻引擎4中创建简单碰撞，在下一节中，我们将讨论如何为我们的资产创建复杂和自定义碰撞。
- en: Let's begin by opening `StarterContent` and navigating to **Content Browser**.
    From here, let's go to the `StarterContent` folder and select the `Shapes` folder
    that contains multiple simple-shaped static meshes to select from. For this set
    of examples, we will choose the `Shape_Trim` mesh because it is a more complicated
    shape as compared to a sphere or box; this way, we can see the effects of different
    collision options. Double-click on the `Shape_Trim` asset to open the **Static
    Mesh** editor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`StarterContent`并导航到**内容浏览器**开始。从这里，让我们进入`StarterContent`文件夹，选择包含多个简单形状静态网格的`Shapes`文件夹。对于这组示例，我们将选择`Shape_Trim`网格，因为它与球体或盒子相比形状更复杂；这样，我们可以看到不同碰撞选项的效果。双击`Shape_Trim`资产以打开**静态网格**编辑器。
- en: '![Creating simple collisions](img/image00253.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00253.jpeg)'
- en: Navigating to the **Static Mesh** editor is very similar to moving around in
    the **Perspective** view mode in the main game editor of Unreal Engine 4\. At
    the top of the **Static Mesh** editor is the main toolbar that provides a handful
    of useful options when you view your mesh and its collision.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在**静态网格**编辑器中导航与在虚幻引擎4主游戏编辑器的**透视**视图模式中移动非常相似。在**静态网格**编辑器的顶部是主工具栏，它提供了当你查看你的网格及其碰撞时的一组有用的选项。
- en: '![Creating simple collisions](img/image00254.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00254.jpeg)'
- en: The toolbar provides us the options to save our mesh and its properties, to
    view the mesh in real time, which is useful if the mesh has an animated material
    applied to it, to view any applied **Sockets**, to toggle the **Wireframe** of
    the mesh, to view any **Vertex Colors** applied to the mesh, to toggle a background
    **Grid**, to toggle the **Bounds** of the mesh, and (most importantly) to toggle
    the **Collision** applied to the mesh. Additionally, we can view the mesh's **Pivot
    Point**, its **Normals**, **Tangents**, **Bi-Normals**, and **UV** sheet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏为我们提供了保存网格及其属性、实时查看网格的选项，这对于网格应用了动画材质时非常有用，可以查看任何应用的**插座**，切换网格的**线框**，查看应用在网格上的任何**顶点颜色**，切换背景**网格**，切换网格的**边界**，以及（最重要的是）切换应用在网格上的**碰撞**。此外，我们还可以查看网格的**中心点**、其**法线**、**切线**、**双法线**和**UV**图。
- en: As we will work primarily with collisions, we will want to make sure that the
    **Collision** option is toggled on so that we can see the bounds of the bounding
    collision mesh. To do this, we can left-click on the **Collision** button to make
    sure that it's highlighted in orange, and if the mesh has any collision applied
    to it, we will see it in a light blue-colored wireframe around our object. By
    default, `Shape_Trim` does have a collision applied to it, so we first want to
    remove this collision so that we are able to apply only one collision mesh to
    the object at once for demonstration purposes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将主要使用碰撞，我们希望确保**碰撞**选项已开启，以便我们可以看到边界碰撞网格的范围。为此，我们可以左键单击**碰撞**按钮，确保它以橙色突出显示，如果网格有任何碰撞应用，我们将在围绕对象的浅蓝色线框中看到它。默认情况下，`Shape_Trim`已经应用了碰撞，因此我们首先想要移除这个碰撞，以便我们能够一次性将一个碰撞网格应用到对象上，以便进行演示。
- en: First, navigate to the **Collision** drop-down window at the very top of the
    **Static Mesh** editor located alongside the **File**, **Edit**, **Asset** window
    options.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到位于**文件**、**编辑**、**资产**窗口选项旁边的**静态网格**编辑器顶部的**碰撞**下拉窗口。
- en: Then, select **Remove Collision**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**移除碰撞**。
- en: Now, the light blue-colored wireframe outline mesh will disappear from our mesh,
    meaning that this asset no longer has any collision applied to it. It is also
    very important to keep in mind that we do not want more than one collision-bounding
    mesh applied to an object at once in order to keep our assets as optimized as
    possible, unless the shape of the mesh demands more than one collision mesh.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浅蓝色的线框轮廓网格将从我们的网格中消失，这意味着这个资产不再有任何碰撞应用。同时，我们也必须牢记，我们不想一次性将超过一个碰撞边界网格应用到对象上，以使我们的资产尽可能优化，除非网格的形状需要超过一个碰撞网格。
- en: 'When it comes to generating simple collision in the **Static Mesh** editor,
    it is as easy as clicking on a few buttons in its interface. Let''s start by creating
    a **Sphere** collision in our `Shape_Trim` mesh by clicking on the **Collision**
    drop-down menu and selecting **Add Sphere Simplified Collision**. Once complete,
    we should see a collision-bounding mesh that looks similar to the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当在**静态网格**编辑器中生成简单碰撞时，只需在其界面中点击几个按钮即可。让我们先通过点击**碰撞**下拉菜单并选择**添加简化球体碰撞**来在我们的`Shape_Trim`网格中创建一个**球体**碰撞。完成后，我们应该看到一个类似于以下截图的碰撞边界网格：
- en: '![Creating simple collisions](img/image00255.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00255.jpeg)'
- en: The **Sphere Simplified Collision** option sets the radius of the sphere that
    best matches the size and shape of the mesh that it is applied to. We should also
    note that the collision wireframe changed from light blue to green; this means
    that the collision will use a simple shape. Once a collision is generated, the
    shape can be moved, rotated, and scaled to the desired size and shape. For this
    shape, a sphere collision does not seem to work as we would like it to work, so
    let's select the **Remove Collision** option from the **Collision** drop-down
    list and then the **Add Capsule Simplified Collision** option.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化球体碰撞**选项设置了与它应用的网格大小和形状最匹配的球体半径。我们还应该注意，碰撞线框从浅蓝色变为绿色；这意味着碰撞将使用简单形状。一旦生成碰撞，形状可以移动、旋转和缩放到所需的大小和形状。对于这个形状，球体碰撞似乎并不像我们希望的那样工作，因此让我们从**碰撞**下拉列表中选择**移除碰撞**选项，然后选择**添加简化胶囊碰撞**选项。'
- en: '![Creating simple collisions](img/image00256.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00256.jpeg)'
- en: As we can see, the **Capsule Simplified Collision** option does a much better
    job of matching the size and shape of our mesh than the **Sphere Simplified Collision**
    option because it sets the capsule's height and radius as opposed to just setting
    the radius. We can still see that the collision-bounding mesh does not fit this
    shape as closely as we would like, so let's continue to add differently shaped
    collision meshes in order to find the best one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**胶囊简化碰撞**选项比**球体简化碰撞**选项更好地匹配我们的网格的大小和形状，因为它设置了胶囊的高度和半径，而不仅仅是设置半径。我们仍然可以看到，碰撞边界网格并没有像我们希望的那样紧密地适应这个形状，所以让我们继续添加不同形状的碰撞网格，以找到最佳的一个。
- en: Let's remove the capsule collision-bounding mesh and instead select the **Add
    Box Simplified Collision** option to `Shape_Trim`. Here, we can see that the box
    shape does a really good job of matching the size and shape of the mesh, and in
    most situations, we would use this option for this asset for use in our game.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除胶囊碰撞边界网格，并选择**添加箱形简化碰撞**选项到`Shape_Trim`。在这里，我们可以看到，箱形形状很好地匹配了网格的大小和形状，并且在大多数情况下，我们会为这个资产使用这个选项在我们的游戏中使用。
- en: '![Creating simple collisions](img/image00257.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00257.jpeg)'
- en: 'For the purposes of this chapter, we will continue to apply the **KDOP Collision**
    options to this mesh so that we have a better understanding of their purposes
    and the results that we can get from these options. Now, let''s remove the **Box
    Simplified Collision** option and use the **Add 10DOP-X Simplified Collision**
    option. If you remember from the previous section, the **10DOP-X Simplified Collision**
    creates a box with four edges beveled in the *X*-aligned edges. Then, we get the
    following result:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将继续应用**KDOP碰撞**选项到这个网格上，以便我们更好地理解它们的目的以及我们可以从这些选项中获得的结果。现在，让我们移除**箱形简化碰撞**选项，并使用**添加10DOP-X简化碰撞**选项。如果你还记得上一节，**10DOP-X简化碰撞**会在*X*对齐的边缘上创建一个带有四个斜边的盒子。然后，我们得到以下结果：
- en: '![Creating simple collisions](img/image00258.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00258.jpeg)'
- en: 'As we can see, the **10DOP-X Simplified Collision** option generates a collision-bounding
    mesh identical to the **Box Simplified Collision** option. Now, let''s try applying
    the **10DOP-Y Simplified Collision** option, which creates a box with four edges
    beveled in the *Y*-aligned edges by first removing the **10DOP-X Simplified Collision**
    option and then selecting the **Add 10DOP-Y Simplified Collision** option to obtain
    the following collision mesh:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**10DOP-X简化碰撞**选项生成的碰撞边界网格与**箱形简化碰撞**选项完全相同。现在，让我们尝试应用**10DOP-Y简化碰撞**选项，它通过首先移除**10DOP-X简化碰撞**选项，然后选择**添加10DOP-Y简化碰撞**选项来创建一个在*Y*对齐边缘上有四个斜边的盒子，得到以下碰撞网格：
- en: '![Creating simple collisions](img/image00259.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00259.jpeg)'
- en: 'As we can see here, the **10DOP-Y Simplified Collision** option does an excellent
    job of almost exactly matching the size and shape of our `Shape_Trim` static mesh.
    This is definitely a viable option to select when you generate a collision for
    this asset. Lastly, let''s apply the **10DOP-Z Simplified Collision** option to
    view how it generates a collision mesh around our asset. First, let''s remove
    the **10DOP-Y Simplified Collision** option and then navigate to the **Collision**
    drop-down menu and select **Add 10DOP-Z Simplified Collision**, which creates
    a box with four edges beveled in the *Z*-aligned axis to obtain the following
    result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，**10DOP-Y简化碰撞**选项几乎完美地匹配了我们的`Shape_Trim`静态网格的大小和形状。这绝对是在为这个资产生成碰撞时可以选择的一个可行的选项。最后，让我们应用**10DOP-Z简化碰撞**选项来查看它如何在我们资产周围生成碰撞网格。首先，让我们移除**10DOP-Y简化碰撞**选项，然后导航到**碰撞**下拉菜单并选择**添加10DOP-Z简化碰撞**，这将创建一个在*Z*对齐轴上有四个斜边的盒子，得到以下结果：
- en: '![Creating simple collisions](img/image00260.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00260.jpeg)'
- en: The result is identical to what we obtained when we applied the **Box Simplified
    Collision** and **10DOP-X Simplified Collision** options. Based on the results
    we received from these options, the best choices for this asset would either be
    **Box Simplified Collision** or **10DOP-Y Simplified Collision**. Due to the simplicity
    of this asset, the **18DOP** and **26DOP Simplified Collision** options won't
    produce unique options, so to properly demonstrate these choices, we need to choose
    a different asset.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们应用**盒子简化碰撞**和**10DOP-X简化碰撞**选项时获得的结果相同。根据我们从这些选项中获得的结果，对于这个资产的最佳选择将是**盒子简化碰撞**或**10DOP-Y简化碰撞**。由于这个资产很简单，**18DOP**和**26DOP简化碰撞**选项不会产生独特的选择，因此为了正确展示这些选择，我们需要选择一个不同的资产。
- en: 'To demonstrate this, let''s close **Static Mesh** editor for the `Shape_Trim`
    asset and navigate to **Content Browser**. Here, under the `Starter Content` folder
    in the `Props` folder, we will double-click on the `SM_Chair` asset to open this
    mesh in **Static Mesh** editor. The `SM_Chair` asset does have the default collision
    applied to it, so before we apply our own, let''s first remove its collision.
    Then, let''s go ahead and select the **18DOP** **Simplified Collision** option
    and view how it generates a collision-bounding mesh for our chair:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们关闭`Shape_Trim`资产的**静态网格**编辑器，并导航到**内容浏览器**。在这里，在`Props`文件夹下的`Starter
    Content`文件夹中，我们将双击`SM_Chair`资产以在**静态网格**编辑器中打开此网格。`SM_Chair`资产已经应用了默认的碰撞，所以在应用我们自己的之前，让我们首先移除它的碰撞。然后，让我们选择**18DOP**
    **简化碰撞**选项并查看它如何为我们的椅子生成一个碰撞边界网格：
- en: '![Creating simple collisions](img/image00261.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00261.jpeg)'
- en: 'If you remember, the **18DOP Simplified Collision** option creates a collision-bounding
    box with all of its edges beveled, creating a nice collision around our chair.
    Here, let''s apply the **26DOP Simplified Collision** option by first removing
    our collision and then selecting the **Add 26DOP Simplified Collision** option:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，**18DOP简化碰撞**选项创建了一个所有边缘都被倒角的碰撞边界框，为我们的椅子周围创建了一个良好的碰撞。在这里，让我们通过首先移除我们的碰撞然后选择**添加26DOP简化碰撞**选项来应用**26DOP简化碰撞**选项：
- en: '![Creating simple collisions](img/image00262.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单碰撞](img/image00262.jpeg)'
- en: As you can see, the **26DOP Simplified Collision** option creates a box that
    has all of its edges and corners beveled, creating a smoother and more rounded
    collision mesh around our asset.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**26DOP简化碰撞**选项创建了一个所有边缘和角落都被倒角的盒子，为我们的资产周围创建了一个更平滑、更圆润的碰撞网格。
- en: Creating simple collisions – a section review
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单碰撞 - 小节回顾
- en: In this section, we took a more in-depth look at the different types of simple
    collision that can be generated in the **Static Mesh** editor in Unreal Engine
    4 and the pros and cons of each type. Using starter content assets as examples,
    we applied each type of simple collision to view how they are generated based
    on the size and shape of our asset to better understand how they work. Now that
    we have taken a deeper look at how to generate simple collisions in Unreal Engine
    4, let's now move on and take a look at how to generate complex and custom collision
    hulls using Unreal Engine 4.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了在虚幻引擎4的**静态网格**编辑器中可以生成的不同类型的简单碰撞，以及每种类型的优缺点。以起始内容资产为例，我们将每种类型的简单碰撞应用于查看它们如何根据我们的资产的大小和形状生成，以便更好地理解它们的工作原理。现在我们已经深入了解了如何在虚幻引擎4中生成简单碰撞，让我们继续前进，看看如何使用虚幻引擎4生成复杂和定制的碰撞外壳。
- en: Creating complex and custom collision hulls
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建复杂和定制的碰撞外壳
- en: When it comes to creating complex collision in the **Static Mesh** editor, we
    can use the **Auto Convex Collision** tool to customize the number of hulls and
    hull vertices that the collision mesh will have. For the purposes of this section,
    we will need to continue using `Unreal_PhyProject` that we created, and we will
    use the `SM_Lamp_Wall` asset as an example of how to generate custom and complex
    collision hulls. To navigate to this asset, we need to go to **Content Browser**
    and then to the `Starter Content` folder. Now, under props, we will find the `SM_Lamp_Wall`
    asset. Double-click on this asset to open the **Static Mesh** editor. If this
    static mesh has any default collisions applied to it, make sure to remove the
    said collision by navigating to the **Collision** drop-down menu and selecting
    remove collision. Make sure that the **Collision Toggle** option is set to on
    so that we can view the collision mesh in the **Static Mesh** editor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 **Static Mesh** 编辑器中创建复杂碰撞时，我们可以使用 **Auto Convex Collision** 工具来自定义碰撞网格将具有的壳体和壳体顶点数量。在本节中，我们需要继续使用我们创建的
    `Unreal_PhyProject`，并将 `SM_Lamp_Wall` 资产作为生成自定义和复杂碰撞壳体的示例。要导航到此资产，我们需要转到 **Content
    Browser**，然后转到 `Starter Content` 文件夹。现在，在道具下，我们将找到 `SM_Lamp_Wall` 资产。双击此资产以打开
    **Static Mesh** 编辑器。如果此静态网格有任何默认碰撞应用，请确保通过导航到 **Collision** 下拉菜单并选择移除碰撞来移除该碰撞。确保将
    **Collision Toggle** 选项设置为开启，以便我们可以在 **Static Mesh** 编辑器中查看碰撞网格。
- en: 'For this asset, we will use the **Auto Convex Collision** tool that provides
    us with a set of parameters to generate **Complex Collision**. To use this tool,
    we need to navigate to the **Collision** drop-down menu and select the **Auto
    Convex Collision** option. Once done, we will be provided with a submenu on the
    right-hand side under **Details Panel** labeled as **Convex Decomposition** with
    the following parameters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此资产，我们将使用提供我们生成 **Complex Collision** 参数集的 **Auto Convex Collision** 工具。要使用此工具，我们需要导航到
    **Collision** 下拉菜单并选择 **Auto Convex Collision** 选项。完成后，我们将在 **Details Panel**
    右侧提供一个子菜单，标签为 **Convex Decomposition**，包含以下参数：
- en: '![Creating complex and custom collision hulls](img/image00263.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![创建复杂和自定义碰撞壳体](img/image00263.jpeg)'
- en: '**Max Hulls**: This parameter determines the number of hulls that are created
    to best match the size and shape of the mesh.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Hulls**: 此参数确定创建的壳体数量，以最佳匹配网格的大小和形状。'
- en: '**Max Hull Verts**: This parameter sets the maximum number of collision hull
    vertices. By increasing this value, we can see how complex the collision hulls
    can be.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Hull Verts**: 此参数设置碰撞壳体的最大顶点数。通过增加此值，我们可以看到碰撞壳体可以有多复杂。'
- en: '**Apply**: This parameter generates a collision mesh based on the **Max Hulls**
    and **Max Hull Verts** parameters.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apply**: 此参数根据 **Max Hulls** 和 **Max Hull Verts** 参数生成碰撞网格。'
- en: '**Defaults**: This parameter resets the **Max Hulls** and **Max Hull Verts**
    parameters back to their default values of `4` and `12` respectively (as seen
    in the previous image).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Defaults**: 此参数将 **Max Hulls** 和 **Max Hull Verts** 参数重置为其默认值 `4` 和 `12`（如前图所示）。'
- en: 'For the sake of providing examples, let''s apply **Auto Convex Collision**
    to our `SM_Lamp_Wall` mesh and set the **Max Hulls** and **Max Hull Verts** parameters
    to their default values of `4` and `12` respectively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供示例，让我们将 **Auto Convex Collision** 应用到我们的 `SM_Lamp_Wall` 网格，并将 **Max Hulls**
    和 **Max Hull Verts** 参数分别设置为默认值 `4` 和 `12`：
- en: '![Creating complex and custom collision hulls](img/image00264.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![创建复杂和自定义碰撞壳体](img/image00264.jpeg)'
- en: 'To really view the power of this tool, let''s try applying **Auto Convex Collision**
    to the following parameters:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正查看此工具的威力，让我们尝试将 **Auto Convex Collision** 应用到以下参数：
- en: '**Max Hulls**: Set this parameter to `1`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Hulls**: 将此参数设置为 `1`'
- en: '**Max** **Hull Verts**: Set this parameter to `6`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Hull Verts**: 将此参数设置为 `6`'
- en: 'Then, we should see the following result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该看到以下结果：
- en: '![Creating complex and custom collision hulls](img/image00265.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![创建复杂和自定义碰撞壳体](img/image00265.jpeg)'
- en: 'As we can see, setting these parameters to the lowest values possible will
    result in a collision mesh that does the bare minimum and does not fit the size
    and shape of our lamp. Now, let''s try applying **Auto Convex Collision** to the
    following parameters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，将这些参数设置为可能的最小值将导致一个仅做基本工作的碰撞网格，并且不符合我们灯的大小和形状。现在，让我们尝试将 **Auto Convex
    Collision** 应用到以下参数：
- en: '**Max Hulls**: Set this paramerter to 24'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Hulls**: 将此参数设置为 24'
- en: '**Max Hull Verts**: Set this paramerter to 32'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Hull Verts**: 将此参数设置为 32'
- en: '![Creating complex and custom collision hulls](img/image00266.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![创建复杂和自定义碰撞外壳](img/image00266.jpeg)'
- en: With the maximum settings applied to the convex collision mesh, we can see that
    it does a much better job of covering the lamp in terms of its size and shape.
    In the end, we would want to choose a setting somewhere between the lowest and
    highest values for the **Max Hulls** and **Max Hull Verts** parameters in order
    to create the most optimized collision possible for our assets.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用最大设置到凸碰撞网格后，我们可以看到它在覆盖灯的大小和形状方面做得更好。最后，我们希望选择一个介于最低和最高值之间的设置，用于**最大外壳**和**最大外壳顶点**参数，以创建最适合我们的资产的最优碰撞。
- en: Now that we have covered the methods of how to create collisions with the tools
    offered in the **Static Mesh** editor of Unreal Engine 4, we will now briefly
    discuss how to create and import collisions created in third-party art programs
    (such as 3ds Max or Maya).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何使用虚幻引擎4的**静态网格**编辑器中提供的工具创建碰撞的方法，我们将简要讨论如何创建和导入在第三方艺术程序（如3ds Max或Maya）中创建的碰撞。
- en: 'The idea behind creating customized collision geometry is to make it as simple
    as possible in order to optimize collision detection when you play the game. The
    more complicated the collision geometry for an object, the more calculations are
    required by the engine to ensure that the collision is done correctly on that
    object. When you import the `.FBX` file to Unreal Engine 4, the collision meshes
    included in this file are identified by the importer based on their name. Here
    is the collision-naming syntax required to ensure proper collision when you import
    your assets to Unreal Engine 4:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义碰撞几何形状背后的想法是使其尽可能简单，以便在游戏播放时优化碰撞检测。一个对象的碰撞几何形状越复杂，引擎就需要进行更多的计算以确保在该对象上正确完成碰撞。当你将`.FBX`文件导入到虚幻引擎4中时，该文件中包含的碰撞网格将根据其名称由导入器识别。以下是导入你的资产到虚幻引擎4时确保正确碰撞所需的碰撞命名语法：
- en: '**UBX_[Mesh Name]**: This naming syntax is required when you import collision
    meshes that are box shaped, using either the box object type in 3ds Max or the
    cube primitive in Maya. Keep in mind that if you move any of the vertices of the
    box collision in the third-party art program or deform the shape in any way to
    make it anything other than a rectangular prism, the import will not work.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UBX_[网格名称]**：当你使用3ds Max中的箱体对象类型或Maya中的立方体原语导入形状为箱体的碰撞网格时，需要使用这种命名语法。请注意，如果你在第三方艺术程序中移动箱体碰撞的任何顶点或以任何方式变形形状以使其不再是矩形棱柱，导入将不会工作。'
- en: '**USP_[Mesh Name]**: This naming syntax is required when you import collision
    meshes that are sphere shaped, using the sphere object type in 3ds Max and Maya.
    The sphere itself in the third-party art program does not need to have a specific
    number of segments because it is converted to a true sphere for collision once
    it is imported to Unreal Engine 4.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USP_[网格名称]**：当你使用3ds Max和Maya中的球体对象类型导入形状为球体的碰撞网格时，需要使用这种命名语法。在第三方艺术程序中，球体本身不需要有特定的段数，因为一旦导入到虚幻引擎4中，它就会被转换为真正的球体用于碰撞。'
- en: '**UCX_[Mesh Name]**: This naming syntax is required when you import collision
    meshes that are convex shaped or a shape that is completely closed and does not
    have an interior angle of more than 180 degrees.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UCX_[网格名称]**：当你导入形状为凸形或完全封闭且没有超过180度内角的形状的碰撞网格时，需要使用这种命名语法。'
- en: 'When you import the `.FBX` files that contain collision meshes, there are a
    few concepts that we have to keep in mind:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入包含碰撞网格的`.FBX`文件时，有几个概念我们必须牢记：
- en: At the time of writing this book, spheres are only used for rigid-body collisions
    and Unreal's zero-extent traces, such as weapons, and not for instances (such
    as player movements).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本书时，球体仅用于刚体碰撞和虚幻引擎的零长度痕迹，例如武器，而不用于实例（例如玩家移动）。
- en: In the naming syntax mentioned earlier, the **Mesh Name** component must be
    identical to the name of the mesh that the collision is associated with in the
    third- party art program. An example would be a box collision mesh for an object
    named `Chair_01` would be labeled as `UBX_Chair_01`, or if there are multiple
    collision meshes for this object, an additional collision mesh could be named
    `UBX_Chair_01_02`, and so on.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面提到的命名语法中，**网格名称**组件必须与第三方艺术程序中碰撞关联的网格名称完全相同。例如，一个名为`Chair_01`的对象的箱体碰撞网格将标记为`UBX_Chair_01`，如果有多个碰撞网格用于此对象，则额外的碰撞网格可以命名为`UBX_Chair_01_02`，依此类推。
- en: Once the collision meshes are created and named properly, we can export both
    the collision and the mesh that the collision is associated with in the `.FBX`
    file. Once imported, Unreal Engine 4 will find the collision, separate it from
    the actual mesh, and transform it into a collision model.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了碰撞网格并正确命名，我们就可以在`.FBX`文件中导出碰撞以及与碰撞关联的网格。一旦导入，虚幻引擎4将找到碰撞，将其从实际网格中分离出来，并将其转换为碰撞模型。
- en: In the instance that an object has a collision composed of multiple shapes,
    the best results are found when the collision hulls do not intersect with one
    another.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个物体由多个形状组成的碰撞体，当碰撞壳体之间不相互交叉时，可以得到最佳结果。
- en: Creating complex and custom collision hulls – a section review
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建复杂和自定义碰撞壳体——章节回顾
- en: In this section, we took an in-depth look at how to create more complex collisions.
    We also looked at how to create custom collision hulls in third-party art programs
    (such as 3ds Max and Maya). Moreover, we analyzed the **Auto Convex Collision**
    tool in the **Static Mesh** editor of Unreal Engine 4\. We also discussed how
    the **Max Hulls** and **Max Hull Verts** parameters affect the collision that
    is generated around our asset. Lastly, we looked at all the necessary naming conventions
    required in our art applications that ensure proper exporting and importing of
    our meshes and collisions to Unreal Engine 4\. Now that we have a very strong
    understanding of how to generate collisions in Unreal Engine 4 and third-party
    art applications, we can now talk about about the different collision interactions
    that exist in Unreal Engine 4 in detail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了如何创建更复杂的碰撞。我们还探讨了如何在第三方艺术程序（如3ds Max和Maya）中创建自定义碰撞壳体。此外，我们分析了虚幻引擎4的**静态网格**编辑器中的**自动凸碰撞**工具。我们还讨论了**最大壳体**和**最大壳体顶点**参数如何影响围绕我们的资产生成的碰撞。最后，我们查看在艺术应用程序中确保网格和碰撞正确导出和导入虚幻引擎4所需的所有必要命名约定。现在，我们已经对如何在虚幻引擎4和第三方艺术应用程序中生成碰撞有了非常深入的了解，我们可以详细讨论虚幻引擎4中存在的不同碰撞交互。
- en: Collision interactions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞交互
- en: After discussing a lot about what collision is and how to generate different
    types of collision, let's now talk about how the different collision responses
    function when you interact with the player and other objects in our game world.
    For the purposes of this section, we will want to have `Unreal_PhyProject` open,
    and we will work with the `FirstPersonExampleMap` level and use the default starter
    content to analyze these interactions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了很多关于碰撞是什么以及如何生成不同类型的碰撞之后，现在让我们谈谈当与游戏世界中的玩家和其他物体交互时，不同的碰撞响应是如何工作的。为了本节的目的，我们希望打开`Unreal_PhyProject`，我们将使用`FirstPersonExampleMap`关卡和默认启动内容来分析这些交互。
- en: 'In `FirstPersonExampleMap`, we will find numerous cube physics actors spread
    across the surface of the level (each starting awake and active at game time).
    If we select any of these cube actors in the editor by left-clicking on it, we
    will see the following **Collision** settings in its **Details Panel**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FirstPersonExampleMap`中，我们将找到许多散布在关卡表面的立方体物理演员（每个在游戏时间开始时都是清醒和活跃的）。如果我们通过左键单击编辑器中的任何这些立方体演员来选择它，我们将在其**详细信息面板**中看到以下**碰撞**设置：
- en: '![Collision interactions](img/image00267.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00267.jpeg)'
- en: 'As we can see, these actors will use **Physics Actor** collision preset and
    have an **Object Type** of **PhysicsBody**. If we were to jump to the level with
    the first person project example (which we have in place) by pressing *Alt* +
    *P*, we can shoot these cubes with the **First-Person Projectile** blueprint by
    left-clicking on it. We can see that on colliding, there is an impulse created
    that causes the boxes to be pushed, and the collision itself causes the projectile
    to bounce off because it is also a physics object that has **Physics Body Object
    Response** set to **Block**. To get a better idea of what is happening, let''s
    open the **First Person Projectile** blueprint by navigating to **Content Browser**
    and then to the `First Person BP` folder. In the `Blueprints` folder, we will
    find the **First Person Projectile** blueprint. Double-click on this asset to
    open its blueprint. It will bring us to the main **Event Graph**, as shown in
    the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这些演员将使用**物理演员**碰撞预设，并且具有**物理体**的**对象类型**。如果我们通过按*Alt* + *P*跳转到包含第一人称投射物示例（我们已设置）的水平，我们可以通过左键单击它来用**第一人称投射物**蓝图射击这些立方体。我们可以看到，在碰撞时，会产生一个脉冲，导致盒子被推动，并且由于它也是一个设置了**物理体对象响应**为**阻止**的物理对象，碰撞本身会导致投射物弹跳。为了更好地了解正在发生的事情，让我们通过导航到**内容浏览器**然后到`First
    Person BP`文件夹来打开**第一人称投射物**蓝图。在`Blueprints`文件夹中，我们将找到**第一人称投射物**蓝图。双击此资产以打开其蓝图。它将带我们到主**事件图**，如下面的截图所示：
- en: '![Collision interactions](img/image00268.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00268.jpeg)'
- en: If we are viewing the blueprint graph for the first time, this may be a little
    confusing, but we can easily break down the logic flow and understand exactly
    what the projectile will do once it's spawned and collides with an actor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们第一次查看蓝图图，这可能会有些令人困惑，但我们可以轻松地分解逻辑流程，并确切地了解投射物一旦生成并与其他演员发生碰撞将执行的操作。
- en: 'Let''s first look at the main event of this graph: the **Event Hit** event
    node. What this event node checks for is whether or not the main root component
    of the blueprint is hit in a collision. In this case, the main root of this blueprint
    is the **Sphere Collision Component** option, labeled as **Collision Component**.
    Let''s select this component by left-clicking on **Collision Component** in the
    **Components** tab in the top-left corner of the blueprint screen and then view
    its collision in **Details Panel**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个图的主要事件：**事件击中**事件节点。这个事件节点检查的是蓝图的主要根组件是否在碰撞中被击中。在这种情况下，这个蓝图的主要根是**球体碰撞组件**选项，标记为**碰撞组件**。让我们通过在蓝图屏幕左上角的**组件**选项卡中左键单击**碰撞组件**来选择此组件，然后在其**详细信息面板**中查看其碰撞：
- en: '![Collision interactions](img/image00269.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00269.jpeg)'
- en: When you view its collision, you will see that it is set exactly similar to
    the physics cube actors in the level, possessing a **Physics Actor** collision
    preset and an **Object Type** set to **Physics Body**. What this means in terms
    of collision is that this projectile will act similar to a normal physics ball,
    such as a baseball or a basketball, when spawned into our game world. A ball in
    both the real world and our game world will more than likely end up hitting something,
    and when it does, our **Event Hit** node will be called.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看其碰撞时，你会看到它被设置为与关卡中物理立方体演员完全相同，拥有一个**物理演员**碰撞预设和一个设置为**物理体**的**对象类型**。这在碰撞方面的含义是，当这个投射物被生成到我们的游戏世界中时，它将表现得类似于一个正常的物理球体，比如棒球或篮球。在现实世界和我们的游戏世界中，球体更有可能最终撞到某个东西，当它这样做时，我们的**事件击中**节点将被调用。
- en: What happens next in the **First Person Projectile** blueprint is that it checks
    whether or not the other component that hits our projectile is a box, a wall,
    a player, or the floor. In particular, this blueprint will check whether the other
    hit component of any collision to this projectile is **Simulating Physics** or
    a physics actor. The **Is Simulating Physics** function node returns a **Boolean**
    value (**True** or **False**), irrespective of whether or not the other hit component
    is a physics actor. We then use a **Branch** node that uses this **True** or **False**
    condition from the **Is Simulating Physics** function to perform actions based
    on whether or not the hit component is a physics actor. We can see that from the
    **True** execution pin, we can add an impulse at the location of the projectile
    and use the **Other Component** of the **Hit** collision as our target to apply
    this impulse to. To determine the force of this impulse, we can perform a simple
    multiplication between the velocity vector of the projectile. We multiply it by
    a constant **Float** value. In addition to **Add Impulse at Location**, this math
    is what causes the physics cube to bounce or react to the projectile on collision,
    and **Is Simulating Physics** checks to ensure that no impulses are created when
    hitting the walls, the floor, or even the player. To have some fun with this blueprint,
    let's change the constant Float value from `100` to `1000` and see how it drastically
    changes the results when the projectile hits a physics object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第一人称投射物**蓝图中的下一步是检查撞击我们的投射物的其他组件是否是盒子、墙壁、玩家或地板。特别是，这个蓝图将检查任何撞击到这个投射物的碰撞的其他击中组件是否是**模拟物理**或物理演员。**模拟物理**函数节点返回一个**布尔值**（**真**或**假**），无论其他击中组件是否是物理演员。然后我们使用一个**分支**节点，该节点使用来自**模拟物理**函数的**真**或**假**条件来根据击中组件是否是物理演员执行动作。我们可以看到，从**真**执行引脚，我们可以在投射物的位置添加一个冲量，并使用**击中**碰撞的**其他组件**作为我们的目标来应用这个冲量。为了确定这个冲量的力量，我们可以对投射物的速度向量进行简单的乘法运算。我们将其乘以一个常数的**浮点**值。除了**在位置添加冲量**之外，这个数学运算导致物理立方体在碰撞时弹跳或对投射物做出反应，**模拟物理**检查确保在撞击墙壁、地板甚至玩家时不会创建任何冲量。为了使这个蓝图更有趣，让我们将常数的浮点值从`100`更改为`1000`，看看它如何极大地改变投射物撞击物理对象时的结果。
- en: To change the way this projectile behaves in the game, we can change its collision
    preset from **Physics Actor** to **Custom** so that we can individually set how
    the collision interacts with the different object responses. For example, let's
    set the **Physics Body** object response from **Block** to **Overlap** and then
    compile the blueprint so that we can see the changes in the game. The result is
    that the projectile goes straight through the physics cube. However, it still
    reacts normally to the **World Static** object type (such as the floor and the
    walls). This is because we changed the object response to **Physics Body** from
    **Block** to **Overlap**. This causes the **Event Hit** event node to never get
    called.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这个投射物在游戏中的行为方式，我们可以将其碰撞预设从**物理演员**更改为**自定义**，这样我们就可以单独设置碰撞如何与不同的对象响应交互。例如，让我们将**物理体**对象响应从**阻挡**更改为**重叠**，然后编译蓝图，以便我们可以看到游戏中的变化。结果是投射物直接穿过物理立方体。然而，它仍然对**世界静态**对象类型（如地板和墙壁）做出正常反应。这是因为我们将对象响应从**阻挡**更改为**重叠**。这导致**事件击中**事件节点永远不会被调用。
- en: In the blueprints of Unreal Engine 4, there are event nodes we can use when
    objects overlap. This is called the **On Component Begin** overlap. As we made
    our projectile use the **Custom Collision** preset that overlaps the physics bodies
    in the game, we can use the **On Component Begin Overlap** event node to have
    any number of actions to take place during this collision. To set up a basic example
    in our projectile blueprint, select the **Collision Component** option in the
    **Components** tab so that it is highlighted. Next, right-click on an empty space
    of **Event Graph** and navigate to **Add Event** for **Collision Component** and
    then to **Collision**. Finally, select the **Add On Component Begin Overlap**
    event node.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4的蓝图设计中，当物体重叠时，我们可以使用事件节点。这被称为**组件开始重叠**。由于我们让我们的投射物使用**自定义碰撞**预设，该预设与游戏中的物理体重叠，因此我们可以使用**组件开始重叠**事件节点来在碰撞期间执行任意数量的动作。为了在我们的投射物蓝图设置一个基本示例，在**组件**选项卡中选择**碰撞组件**选项，使其高亮显示。接下来，在**事件图**的空白区域右键单击，导航到**添加事件**，然后选择**碰撞组件**，再选择**碰撞**。最后，选择**添加组件开始重叠**事件节点。
- en: '![Collision interactions](img/image00270.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00270.jpeg)'
- en: 'To have a similar behavior to what we had in the **Event Hit** node checking
    for objects that are physics actors, let''s copy and paste the **Is Simulating
    Physics** function node and **Branch** that was used in the original blueprint
    logic and connect the nodes, as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让行为与我们在**Event Hit**节点中检查物理演员对象时的行为相似，让我们复制并粘贴原始蓝图逻辑中使用的**Is Simulating Physics**函数节点和**Branch**，并连接节点，如下面的截图所示：
- en: '![Collision interactions](img/image00271.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00271.jpeg)'
- en: 'So far, we had our projectile check for objects in our world that are physics
    actors once the collision is overlapped, but we have no actions taking place if
    this check is **True** or **False**. Instead of performing any kind of complicated
    actions, we will simply use the **Print String** function to print the dialogue
    to our console so that we know that the check is working. Let''s right-click on
    the empty space of **Event Graph** and search for the **Print String** function
    node. In the **In String** parameter, enter `Overlapped Physics Body`, and connect
    it to the **True** executional output pin, as shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在物体与我们的世界中的物理演员发生碰撞重叠时检查了我们的抛体对象，但如果这个检查结果是**True**或**False**，则不会执行任何操作。我们不会执行任何复杂的动作，而是简单地使用**Print
    String**函数将对话框打印到我们的控制台，以便我们知道检查正在工作。让我们在**Event Graph**的空白区域右键单击并搜索**Print String**函数节点。在**In
    String**参数中输入`Overlapped Physics Body`，并将其连接到**True**执行输出引脚，如下面的截图所示：
- en: '![Collision interactions](img/image00272.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00272.jpeg)'
- en: If we click on the **Compile** button at the top of the blueprint and play the
    game, we can see that the projectile goes right through our physics objects, but
    we do not see our **Print String** outputted to the console. This is because both
    the physics cubes in the level and our projectile collision don't have the **Generate
    Overlap Events** parameter set to **True** by default, so let's select one or
    more of the cubes and navigate to their **Collision Settings** in **Details Panel**
    and make sure that **Generate Overlap Events** is set to **True**. Let's perform
    the same function to **Collision Component** in our projectile blueprint. Now,
    if we play again and shoot the physics cubes that we customized, we will now see
    our **Print String** outputted to the console.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在蓝图顶部的**Compile**按钮上单击并播放游戏，我们可以看到抛体会直接穿过我们的物理对象，但我们没有看到我们的**Print String**输出到控制台。这是因为关卡中的物理立方体和我们的抛体碰撞都没有将**Generate
    Overlap Events**参数默认设置为**True**，所以让我们选择一个或多个立方体，并导航到它们的**Collision Settings**在**Details
    Panel**中，确保**Generate Overlap Events**设置为**True**。让我们在我们的抛体蓝图中也执行相同的操作。现在，如果我们再次播放并射击我们自定义的物理立方体，我们现在将看到我们的**Print
    String**输出到控制台。
- en: '![Collision interactions](img/image00273.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞交互](img/image00273.jpeg)'
- en: From here, feel free to experiment and customize the collision presets that
    the projectile has, see how it changes and reacts in our game world, and add more
    blueprint functionalities to see what else is possible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以自由地实验和自定义抛体具有的碰撞预设，看看它在我们的游戏世界中的变化和反应，并添加更多蓝图功能以查看其他可能的功能。
- en: The last collision interaction that can exist between objects, apart from **Block**
    and **Overlap**, is the **Ignore** option. There is not much to this type of **Collision
    Response** because it will ignore the different **Object Responses** completely
    if it is set to **Ignore**. For the purpose of our example, in our **First Person
    Projectile** blueprint, let's change the **Physics Body** object response from
    **Overlap** to **Ignore**. If we play now, we can shoot at the physics cubes,
    but it will go completely through the object, and neither the **On Component Begin
    Overlap** nor the **Event Hit** event nodes will be called.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**Block**和**Overlap**之外，物体之间可以存在的最后一个碰撞交互是**Ignore**选项。这种类型的**碰撞响应**没有太多内容，因为它如果设置为**Ignore**，将完全忽略不同的**对象响应**。为了我们的示例，在我们的**First
    Person Projectile**蓝图里，让我们将**Physics Body**对象响应从**Overlap**更改为**Ignore**。如果我们现在播放，我们可以射击物理立方体，但它会完全穿过对象，并且**On
    Component Begin Overlap**和**Event Hit**事件节点都不会被调用。
- en: Collision interactions – a section review
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞交互 - 部分回顾
- en: In this section, we got our hands dirty by applying the different combinations
    of collision presets to the **First Person Projectile** blueprint to see how it
    interacts with the physics actors in our game world. By setting the **Physics
    Body** object response to **Block**, the **Event Hit** event node will be called.
    Also, an impulse will be created at the projectiles' location, resulting in a
    small push force applied to the physics actor the projectile collides with. By
    setting the **Physics Body** object response to **Overlap**, we can use the **On
    Component Begin Overlap Event** node to call different actions once the projectile
    overlaps with a physics actor. We just need to make sure that the physics actors
    in our level and our projectile have the **Generate Overlap Events** set to **True**.
    Lastly, we briefly discussed the results of when our projectile has the **Physics
    Body** object response set to **Ignore**. Like the name suggests, it ignores the
    object response, and no events are fired. Now that we talked more about collision
    interactions, let's move on and discuss how to create and use custom object and
    trace channel responses in Unreal Engine 4.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过将不同的碰撞预设组合应用到**第一人称投射物**蓝图上，来亲身体验它如何与游戏世界中的物理演员互动。通过将**物理体**对象响应设置为**阻挡**，将调用**事件击中**事件节点。同时，在投射物的位置将产生一个脉冲，导致对投射物碰撞的物理演员施加一个小的推力。将**物理体**对象响应设置为**重叠**，我们可以使用**组件开始重叠事件**节点，在投射物与物理演员重叠时调用不同的动作。我们只需确保我们关卡中的物理演员和我们的投射物都将**生成重叠事件**设置为**True**。最后，我们简要讨论了当我们的投射物将**物理体**对象响应设置为**忽略**时的结果。正如其名所示，它忽略了对象响应，不会触发任何事件。现在，我们更多地讨论了碰撞交互，接下来让我们讨论如何在虚幻引擎4中创建和使用自定义对象和追踪通道响应。
- en: Custom object and trace channel responses
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义对象和追踪通道响应
- en: Sometimes, the default object and trace channel responses are not enough for
    what we want to do in our games. So, it may be necessary to create customized
    object and trace channel responses for certain assets and scenarios. To accomplish
    this, we can navigate to the **Edit** drop-down window at the top of the Unreal
    Engine 4 editor and select **Project Settings**. From here, select the **Collision**
    option under the **Engine** section. Here, we can create custom **Objects**, **Trace
    Channels**, and **Presets** that we can use when we apply collisions to our assets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，默认的对象和追踪通道响应不足以满足我们在游戏中想要实现的功能。因此，可能需要为某些资产和场景创建自定义对象和追踪通道响应。为了完成这个任务，我们可以导航到虚幻引擎4编辑器顶部的**编辑**下拉菜单并选择**项目设置**。从这里，选择**引擎**部分下的**碰撞**选项。在这里，我们可以创建自定义**对象**、**追踪通道**和**预设**，以便我们在对资产应用碰撞时使用。
- en: Let's start with creating a new **Object Channel** by selecting this option
    and clicking on the **New Object Channel** button. Here, a dialogue window pops
    up. Then, we can customize how **Object Channel** responds by default.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的**对象通道**开始，选择此选项并点击**新建对象通道**按钮。在这里，一个对话框窗口会弹出。然后，我们可以自定义**对象通道**的默认响应方式。
- en: '![Custom object and trace channel responses](img/image00274.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![自定义对象和追踪通道响应](img/image00274.jpeg)'
- en: 'Name the **Object Channel** `Projectile`, and set its **Default Response**
    to **Block**. Now, let''s create a custom **Collision Preset** by selecting this
    option and selecting the **New** button so that a dialogue window appears. Here,
    we can set the presets default values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将**对象通道**命名为`投射物`，并将其**默认响应**设置为**阻挡**。现在，让我们通过选择此选项并点击**新建**按钮来创建一个自定义**碰撞预设**，以便出现一个对话框窗口。在这里，我们可以设置预设的默认值：
- en: '![Custom object and trace channel responses](img/image00275.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![自定义对象和追踪通道响应](img/image00275.jpeg)'
- en: We can also name this new **Collision Preset Profile**, `Projectile`, set the
    **Collision Enabled** property to **Collision Enabled**, **Object Type** to `Projectile`,
    (the one that we have just created), and the **Description** property to anything
    that will remind us of what this **Collision Preset** is used for. Lastly, we
    can set all the **Trace** and **Object Channels** for this preset to **Block**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将这个新的**碰撞预设配置文件**命名为`投射物`，将**碰撞启用**属性设置为**碰撞启用**，**对象类型**设置为`投射物`（即我们刚刚创建的那个），并将**描述**属性设置为任何能让我们记住这个**碰撞预设**用途的内容。最后，我们可以将此预设的所有**追踪**和**对象通道**设置为**阻挡**。
- en: For the purposes of this section's demonstration, we won't create a custom **Trace
    Channel**, but if we ever needed to, it works exactly similar to creating a custom
    **Object Channel**; select the **Trace Channels** option, left-click on the **New
    Trace Channel** button, name the channel, and set the **Default Response** to
    either **Block**, **Overlap**, or **Ignore**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本节演示的目的，我们不会创建一个自定义的**追踪通道**，但如果我们需要，它的工作方式与创建自定义**对象通道**完全相同；选择**追踪通道**选项，左键单击**新建追踪通道**按钮，命名通道，并将**默认响应**设置为**阻止**、**重叠**或**忽略**。
- en: 'Now that we have created a custom **Object Channel** and a custom **Collision
    Preset**, let''s apply these to the **Collision Component** of the **First Person
    Projectile** blueprint. Once you are in the **First Person Projectile** blueprint,
    select the **Collision** component from the **Components** tab in the top-left
    corner and navigate to the **Collision** section of the **Details Panel** in the
    bottom-right corner of the blueprint window. If we look at the **Collision Presets**
    drop-down menu, we will see our `Projectile` **Collision Preset** available, and
    when we select this option, we will see the default values that we set:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个自定义的**对象通道**和一个自定义的**碰撞预设**，让我们将这些应用到**第一人称投射物**蓝图中的**碰撞组件**。一旦你进入**第一人称投射物**蓝图，从左上角的**组件**选项卡中选择**碰撞**组件，并导航到蓝图窗口右下角的**详情面板**中的**碰撞**部分。如果我们查看**碰撞预设**下拉菜单，我们会看到我们的`投射物`**碰撞预设**可用，当我们选择此选项时，我们会看到我们设置的默认值：
- en: '![Custom object and trace channel responses](img/image00276.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![自定义对象和追踪通道响应](img/image00276.jpeg)'
- en: We can also see our `Projectile` **Object Channel Response** that we created
    earlier in the **Object Responses** section of the **Collision Component**. Now,
    if we ever need to, we can set all of our projectile assets to have the **Projectile
    Collision Preset** so that all of our projectiles behave the same during collisions.
    In addition to this, we can have other assets collide in a specific way to projectiles
    by setting the **Projectile** object response to **Block**, **Overlap**, or **Ignore**
    projectiles on colliding. Now, when we play the game, we can see that the **First
    Person Projectile** blueprint behaves exactly as intended when you fire the projectile.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到我们在**碰撞组件**的**对象响应**部分中创建的`投射物`**对象通道响应**。现在，如果我们需要，我们可以将所有投射物资产设置为具有**投射物碰撞预设**，这样所有投射物在碰撞时都会表现出相同的行为。除此之外，我们可以通过将**投射物**对象响应设置为**阻止**、**重叠**或**忽略**投射物来使其他资产以特定方式与投射物碰撞。现在，当我们玩游戏时，我们可以看到当发射投射物时，**第一人称投射物**蓝图的行为完全符合预期。
- en: Just as a reminder, we can only have up to 18 custom **Object Channels** and
    **Trace Channels**, and if we ever delete an **Object Type** that has been used
    in our game, it will revert back to **WorldStatic**, and if we delete a trace
    channel that has been used in our game, the behavior of the trace is undefined.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就作为一个提醒，我们只能有最多18个自定义的**对象通道**和**追踪通道**，如果我们删除了在游戏中使用过的**对象类型**，它将恢复到**世界静态**，如果我们删除了在游戏中使用过的追踪通道，追踪的行为将是未定义的。
- en: Custom object and trace channel responses – a section review
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义对象和追踪通道响应 - 章节回顾
- en: In this section, we took a deeper look at how to create and implement custom
    objects, trace channels, and custom collision presets. We then applied these customized
    channels and presets to the **First Person Projectile** blueprint and found that
    we can have the same collision behavior exist for the projectile when we use custom
    collision presets and **Object** channels. Now that we have created our very own
    custom object and trace channels and created our own collision preset, we can
    now move on and take an in-depth look at the additional default collision presets
    that exist in Unreal Engine 4.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了如何创建和实现自定义对象、追踪通道和自定义碰撞预设。然后我们将这些自定义通道和预设应用到**第一人称投射物**蓝图，并发现我们可以在使用自定义碰撞预设和**对象**通道时为投射物实现相同的碰撞行为。现在我们已经创建了我们的自定义对象和追踪通道，并创建了我们的碰撞预设，我们可以继续深入探讨Unreal
    Engine 4中存在的其他默认碰撞预设。
- en: In-depth collision presets
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入的碰撞预设
- en: 'To conclude this chapter, let''s briefly discuss the remaining collision presets
    available in Unreal Engine 4 that we have not gone through at this point:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，让我们简要讨论一下在这一点上我们尚未讨论过的Unreal Engine 4中可用的剩余碰撞预设：
- en: '**Custom**: This collision preset allows you to fully customize how you want
    the collision to behave by selecting the **Collision Enabled** property, setting
    the **Object Type** property, and fully customizing how the **Trace** and **Object
    Responses** react to different types of collisions. This type of collision preset
    is useful when we need to customize an assets collision, and where the default
    collision presets does not fit the type of collision we need.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：此碰撞预设允许您通过选择**碰撞启用**属性、设置**对象类型**属性以及完全自定义**跟踪**和**对象响应**如何对不同类型的碰撞做出反应来完全自定义您希望碰撞如何行为。这种类型的碰撞预设在我们需要自定义资产碰撞，并且默认碰撞预设不适合我们需要的碰撞类型时非常有用。'
- en: '**Block All Dynamic**: This collision preset blocks all the actors by default
    and makes the collision itself a **WorldDynamic** object. This type of collision
    preset is useful for dynamic objects or objects that can move in your game world
    that you want to block when you collide with other objects. Lastly, the **Collision
    Enabled** property is set to **Collision Enabled**.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻止所有动态对象**：此碰撞预设默认阻止所有演员，并将碰撞本身设置为**WorldDynamic**对象。这种类型的碰撞预设对于动态对象或你希望在游戏中与其他对象碰撞时阻止移动的对象非常有用。最后，**碰撞启用**属性设置为**碰撞启用**。'
- en: '**Overlap All Dynamic**: This collision preset overlaps all the actors by default
    and makes the collision itself a **WorldDynamic** object. This type of collision
    preset is useful for dynamic objects that you want to overlap when you collide
    with other objects. Lastly, the **Collision Enabled** property is set to **No
    Physics Collision**, meaning that the assets'' collision won''t use game physics.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠所有动态对象**：此碰撞预设默认重叠所有演员，并将碰撞本身设置为**WorldDynamic**对象。这种类型的碰撞预设对于你希望在与其他对象碰撞时重叠的动态对象非常有用。最后，**碰撞启用**属性设置为**无物理碰撞**，意味着资产的碰撞不会使用游戏物理。'
- en: '**Ignore Only Pawn**: This collision preset blocks all the actors by default,
    but it ignores the **Pawn** and **Vehicle** object responses. This preset also
    sets the **Object Type** of the collision to **WorldDynamic** and is useful for
    assets that you want to ignore for **Pawns** and **Vehicles** in your game world.
    Lastly, the **Collision Enabled** property is set to **No Physics Collision**.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅忽略Pawn**：此碰撞预设默认阻止所有演员，但忽略**Pawn**和**车辆**对象响应。此预设还将碰撞的**对象类型**设置为**WorldDynamic**，对于你希望在游戏中忽略**Pawn**和**车辆**的资产非常有用。最后，**碰撞启用**属性设置为**无物理碰撞**。'
- en: '**Overlap Only Pawn**: This collision preset blocks all the actors by default,
    but it overlaps the **Pawn** and **Vehicle** object responses. It also overlaps
    the **Camera** trace channel. This preset also sets the **Object Type** of the
    collision to **WorldDynamic** and is useful for assets that need overlap events
    to fire when it is overlapped during a collision with **Pawns**, **Vehicles**,
    and **Camera Traces**. Lastly, the **Collision Enabled** property is set to **No
    Physics Collision**.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅重叠Pawn**：此碰撞预设默认阻止所有演员，但重叠**Pawn**和**车辆**对象响应。它还重叠**相机**跟踪通道。此预设还将碰撞的**对象类型**设置为**WorldDynamic**，对于在与其他**Pawn**、**车辆**和**相机跟踪**碰撞时需要触发重叠事件的资产非常有用。最后，**碰撞启用**属性设置为**无物理碰撞**。'
- en: '**Spectator**: This collision preset ignores all the actors by default, except
    the **WorldStatic** object responses. This preset also sets the **Object Type**
    of the collision to **Pawn** and is useful when you want players to see a game
    in multiplayer situations. Lastly, the **Collision Enabled** property is set to
    **No Physics Collision**.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观众**：此碰撞预设默认忽略所有演员，除了**WorldStatic**对象响应。此预设还将碰撞的**对象类型**设置为**Pawn**，在你想让玩家在多人情况下看到游戏时非常有用。最后，**碰撞启用**属性设置为**无物理碰撞**。'
- en: '**Character Mesh**: This collision preset is a **Pawn Object Type** that is
    used for a **Character** **Mesh** when you create a player character. By default,
    this preset ignores the **Visibility** trace response and the **Pawn** and **Vehicle**
    object responses, although it blocks the remaining values. Lastly, the **Collision
    Enabled** property is set to **No Physics Collision**.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色网格**：此碰撞预设是一个**Pawn对象类型**，用于创建玩家角色时的**角色网格**。默认情况下，此预设忽略**可见性**跟踪响应和**Pawn**以及**车辆**对象响应，尽管它阻止了剩余的值。最后，**碰撞启用**属性设置为**无物理碰撞**。'
- en: '**Destructible**: This collision preset is a **Destructible Object Type** that
    is used for assets that can be destructible in the game. By default, this preset
    blocks all the **Trace** and **Object Channels**. Its **Collision Enabled** property
    is set to **Collision Enabled**.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可破坏(Destructible)**: 此碰撞预设是一个**可破坏对象类型**，用于游戏中可以破坏的资产。默认情况下，此预设阻止所有**轨迹**和**对象通道**。其**碰撞启用**属性设置为**碰撞启用**。'
- en: '**Invisible Wall**: This collision preset is a **World Static Object Type**
    that is used as an invisible wall that blocks all the **Trace** and **Object Responses**,
    except the **Visibility Trace Response**, which this preset ignores. This preset
    works exactly similar to a blocking volume. Lastly, its **Collision Enabled**
    property is set to **Collision Enabled**.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可见墙**: 此碰撞预设是一个**世界静态对象类型**，用作不可见的墙，阻止所有**轨迹**和**对象响应**，除了**可见性轨迹响应**，该响应被此预设忽略。此预设的工作方式与阻塞体积完全相同。最后，其**碰撞启用**属性设置为**碰撞启用**。'
- en: '**Invisible Wall Dynamic**: This collision preset is a **World Dynamic Object
    Type** that is used as an invisible wall that functions exactly similar to the
    **Invisible Wall** collision preset, in which it blocks all the **Trace** and
    **Object Responses**, except the **Visibility Trace Response**, which this preset
    also ignores. Lastly, its **Collision Enabled** property is set to **Collision
    Enabled**.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态不可见墙(Invisible Wall Dynamic)**: 此碰撞预设是一个**世界动态对象类型**，用作不可见的墙，其功能与**不可见墙**碰撞预设完全相同，其中它阻止所有**轨迹**和**对象响应**，除了**可见性轨迹响应**，该响应也被此预设忽略。最后，其**碰撞启用**属性设置为**碰撞启用**。'
- en: '**Trigger**: This collision preset is a **World Dynamic Object Type** that
    is used as a **Trigger**, meaning that it functions similar to a **Trigger Volume**
    so that we can use it to call all the events and functions in our game. By default,
    the **Trigger Collision Preset** overlaps all the **Trace** and **Object Channel
    Responses**, except the **Visibility Trace Channel**, which this preset ignores.
    Lastly, its **Collision Enabled** property is set to **No Physics Collision**.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**: 此碰撞预设是一个**世界动态对象类型**，用作**触发器**，这意味着它的工作方式类似于**触发体积**，因此我们可以用它来调用我们游戏中的所有事件和函数。默认情况下，**触发器碰撞预设**重叠所有**轨迹**和**对象通道响应**，除了**可见性轨迹通道**，该通道被此预设忽略。最后，其**碰撞启用**属性设置为**无物理碰撞**。'
- en: '**Ragdoll**: This collision preset is used to simulate skeletal mesh components.
    Its **Object Type** is set to **Physics Body**. We can use this preset for character
    meshes that would turn rag doll when players are killed or lose control and would
    want the player character to be taken over by physics. By default, this collision
    preset blocks all the **Trace** and **Object Responses**, except the **Pawn Object
    Response**, which it ignores. Lastly, the **Collision Enabled** property is set
    to **Collision Enabled**.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布娃娃(Ragdoll)**: 此碰撞预设用于模拟骨骼网格组件。其**对象类型**设置为**物理体**。我们可以使用此预设来处理当玩家被击败或失去控制时变成布娃娃的角色网格，并希望玩家角色被物理控制接管。默认情况下，此碰撞预设阻止所有**轨迹**和**对象响应**，除了**Pawn对象响应**，该响应被忽略。最后，其**碰撞启用**属性设置为**碰撞启用**。'
- en: '**Vehicle**: This collision preset is a **Vehicle Object Type** that is used
    for any moving vehicle assets in our game world. By default, this preset blocks
    all the **Trace** and **Object Responses**. Its **Collision Enabled** property
    is set to **Collision Enabled**.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**车辆**: 此碰撞预设是一个**车辆对象类型**，用于我们游戏世界中任何移动的车辆资产。默认情况下，此预设阻止所有**轨迹**和**对象响应**。其**碰撞启用**属性设置为**碰撞启用**。'
- en: '**UI**: This collision preset is a **World Dynamic Object Type** that is used
    for any **UI** assets (such as **UMG HUD** elements). By default, this preset
    overlaps all the **Trace** and **Object Responses**, except the **Visibility Trace**
    **Response**, which this preset blocks. Lastly, the **Collision Enabled** property
    is set to **No Physics Collision**.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面(UI)**: 此碰撞预设是一个**世界动态对象类型**，用于任何**UI**资产（例如**UMG HUD**元素）。默认情况下，此预设重叠所有**轨迹**和**对象响应**，除了**可见性轨迹响应**，该响应被此预设阻止。最后，其**碰撞启用**属性设置为**无物理碰撞**。'
- en: In-depth collision presets – a section review
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解碰撞预设 - 一节回顾
- en: In this section, we took an in-depth look at all the collision presets that
    Unreal Engine 4 provides users by default, and by doing so, we analyzed the purpose
    and functionalities of each. Now that we have covered collision presets, we can
    now conclude this chapter and move on to discussing constraints in Unreal Engine
    4.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入研究了Unreal Engine 4为用户提供的所有默认碰撞预设，并通过对每个预设的目的和功能进行分析。现在我们已经涵盖了碰撞预设，我们可以现在总结本章，并继续讨论Unreal
    Engine 4中的约束。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how collision works and how it is implemented
    in Unreal Engine 4 by first analyzing the topics of trace and collision responses.
    We also discussed how these responses work, their parameter values, and how to
    implement these responses to our blueprint assets in detail.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先分析了跟踪和碰撞响应的主题，讨论了碰撞在Unreal Engine 4中的工作原理及其实现方式。我们还讨论了这些响应的工作原理、参数值以及如何详细地将这些响应实现到我们的蓝图资产中。
- en: Next, you learned about simple and complex collisions by defining what each
    type is and how they are used. We also looked at its pros and cons and how to
    generate the different types of simple collision.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过定义每种类型是什么以及它们如何被使用，学习了简单和复杂碰撞。我们还探讨了它们的优缺点以及如何生成不同类型的简单碰撞。
- en: Additionally, you learned more about complex collisions and how to generate
    these types of collisions in Unreal Engine 4\. You also looked at how to create
    custom collision hulls in third-party art programs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你学习了更多关于复杂碰撞以及如何在Unreal Engine 4中生成这些类型碰撞的知识。你还了解了如何在第三方艺术程序中创建自定义碰撞外壳。
- en: Furthermore, you learned about collision interactions. We used the **First Person
    Projectile** blueprint as an example of how these interactions are used when it
    comes to scripting different behaviors for our assets.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你学习了关于碰撞交互的内容。我们以**第一人称投射**蓝图为例，说明了这些交互在为我们的资产编写不同行为时的应用。
- en: Moreover, we went through the purposes of custom objects and trace channels.
    We discussed how to create custom collision presets, including how to implement
    these customized parameters in blueprints.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了自定义对象和跟踪通道的目的。我们讨论了如何创建自定义碰撞预设，包括如何在蓝图中实现这些自定义参数。
- en: Lastly, we discussed the different collision presets that exist in Unreal Engine
    4, their purposes, and how they function in detail.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了Unreal Engine 4中存在的不同碰撞预设、它们的目的以及它们如何详细工作。
- en: Now that we have a stronger understanding of how collision works and how to
    implement the different collisions for our assets, we can now dive deep into creating
    constraints in Unreal Engine 4.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对碰撞的工作原理以及如何为我们的资产实现不同类型的碰撞有了更深入的了解，我们现在可以深入探讨在Unreal Engine 4中创建约束。
