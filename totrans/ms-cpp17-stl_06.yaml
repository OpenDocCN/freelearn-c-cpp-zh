- en: Smart Pointers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针
- en: C++ holds its grip on large swaths of the software industry by virtue of its
    performance--well-written C++ code runs faster than anything else out there, *almost*
    by definition, because C++ gives the programmer almost complete control over the
    code that is ultimately generated by the compiler.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++凭借其性能——编写良好的C++代码比其他任何东西都要快——几乎可以说是定义性的，因为C++给了程序员几乎完全控制最终由编译器生成的代码。
- en: One of the classic features of low-level, performant code is the use of *raw
    pointers* (`Foo*`). However, raw pointers come with many pitfalls, such as memory
    leaks and dangling pointers. The C++11 library's "smart pointer" types can help
    you avoid these pitfalls at little to no expense.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 低级、高性能代码的一个经典特性是使用*原始指针*（`Foo*`）。然而，原始指针伴随着许多陷阱，例如内存泄漏和悬垂指针。C++11库的“智能指针”类型可以帮助你在几乎不花费任何代价的情况下避免这些陷阱。
- en: 'In this chapter we''ll learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The definition of "smart pointer" and how you might write your own
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “智能指针”的定义以及如何编写你自己的
- en: The usefulness of `std::unique_ptr<T>` in preventing resource leaks of all types
    (not just memory leaks)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr<T>`在防止所有类型的资源泄漏（不仅仅是内存泄漏）中的有用性'
- en: How `std::shared_ptr<T>` is implemented, and its implications for memory usage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_ptr<T>`的实现方式及其对内存使用的含义'
- en: The meaning and uses of the Curiously Recurring Template Pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇怪重复模板模式（Curiously Recurring Template Pattern）的意义和用途
- en: The origins of smart pointers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针的起源
- en: 'Raw pointers have many uses in C:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 原始指针在C语言中有许多用途：
- en: As a cheap, non-copying view of an object owned by the caller
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对调用方拥有的对象的一种便宜的非复制视图
- en: As a way for the callee to modify an object owned by the caller
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为被调用方修改调用方拥有的对象的一种方式
- en: As one-half of a pointer/length pair, used for arrays
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为指针/长度对的一半，用于数组
- en: As an optional argument (either a valid pointer *or* null)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为可选参数（一个有效的指针*或*空指针）
- en: As a way to manage memory on the heap
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为管理堆内存的一种方式
- en: In C++, we have native references (`const Foo&` and `Foo&`) to handle the first
    two bullets; plus, move semantics makes it cheap for a callee to take and pass
    back a complex object by value in most cases, thus completely avoiding aliasing.
    In C++17 we can use `std::string_view` to address some of the first and third
    bullet. And we've just seen in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*, that passing an `optional<T>`--or perhaps getting fancy with
    an `optional<reference_wrapper<T>>`--is sufficient to handle the fourth bullet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们有原生引用（`const Foo&`和`Foo&`）来处理前两点；此外，移动语义使得调用方在大多数情况下通过值传递复杂数据给被调用方变得非常便宜，从而完全避免了别名问题。在C++17中，我们可以使用`std::string_view`来解决一些第一点和第三点的问题。我们已经在[第5章](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d)，“词汇类型”中看到，传递一个`optional<T>`——或者可能使用一个`optional<reference_wrapper<T>>`来变得复杂——足以处理第四点。
- en: This chapter will be concerned with the fifth bullet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将关注第五点。
- en: 'Heap allocation comes with a host of problems in C, and all those problems
    (and more!) applied to C++ prior to 2011\. As of C++11, though, almost all of
    those problems have disappeared. Let''s enumerate them:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，堆分配带来了一系列问题，并且所有这些问题（以及更多！）在2011年之前的C++中都得到了应用。然而，从C++11开始，几乎所有这些问题都消失了。让我们列举一下：
- en: '**Memory leaks**: You might allocate a piece of memory or an object on the
    heap, and accidentally forget to write the code that frees it.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：你可能在堆上分配了一块内存或一个对象，但意外地忘记编写释放它的代码。'
- en: '**Memory leaks**: You might have written that code, but due to an early return
    or an exception being thrown, the code never runs and the memory remains unfreed!'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：你可能已经编写了那段代码，但由于早期返回或抛出异常，代码从未运行，内存仍然未被释放！'
- en: '**Use-after-free**: You take a copy of a pointer to an object on the heap,
    and then free that object through the original pointer. The holder of the copied
    pointer doesn''t realize that their pointer is no longer valid.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用后释放**：你复制了一个指向堆上对象的指针，然后通过原始指针释放了该对象。复制指针的持有者没有意识到他们的指针已经不再有效。'
- en: '**Heap corruption via pointer arithmetic**: You allocate an array on the heap
    at address *A*. Having a raw pointer to an array tempts you to do pointer arithmetic,
    and in the end you accidentally free a pointer to address *A*+*k*. When *k*=0
    (as Murphy''s Law ensures it will be, in testing) there is no problem; when *k*=1
    you corrupt your heap and cause a crash.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过指针算术导致的堆损坏**：你在堆上以地址 *A* 分配了一个数组。拥有一个指向数组的原始指针会诱使你进行指针算术，最终你意外地释放了指向地址
    *A*+*k* 的指针。当 *k*=0（正如墨菲定律确保的那样，在测试中）时没有问题；当 *k*=1 时，你会损坏你的堆并导致崩溃。'
- en: The first two problems are compounded by the fact that heap allocation is semantically
    allowed to fail--`malloc` can return null, `operator new` can throw `std::bad_alloc`--which
    means that if you're writing pre-C++11 code that allocates memory, you are probably
    writing a lot of cleanup code to deal with allocation failure. (In C++, you're
    "writing" that code whether you know it or not, because the control flow paths
    due to exception handling are there even if you're not consciously thinking about
    them.) The upshot of all this is that managing heap-allocated memory in C++ is
    *hard*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个问题由于堆分配在语义上允许失败--`malloc` 可以返回空，`operator new` 可以抛出 `std::bad_alloc`--而加剧，这意味着如果你正在编写预C++11代码来分配内存，你可能会编写大量的清理代码来处理分配失败。（在C++中，无论你是否意识到，你都在“编写”这些代码，因为由于异常处理而产生的控制流路径是存在的，即使你没有有意识地思考它们。）所有这些的结果是，在C++中管理堆分配的内存是
    *困难的*。
- en: Unless you use smart pointers!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你使用智能指针！
- en: Smart pointers never forget
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针永远不会忘记
- en: 'The idea of a "smart pointer" type (not to be confused with a "fancy pointer"
    type, which we''ll cover in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*) is that it''s a class--typically a class template--which behaves
    syntactically just like a pointer, but whose special member functions (construction,
    destruction, and copying/moving) have additional bookkeeping to ensure certain
    invariants. For example, we might ensure the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “智能指针”类型的概念（不要与“花哨指针”类型混淆，我们将在第8章（part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d）*分配器*中介绍）是它是一个类--通常是类模板--它在语法上表现得就像一个指针，但其特殊成员函数（构造、析构和复制/移动）有额外的簿记来确保某些不变性。例如，我们可能确保以下内容：
- en: The pointer's destructor also frees its pointee--helping to solve memory leaks
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针的析构函数也会释放其指向的对象--有助于解决内存泄漏问题
- en: Maybe the pointer cannot be copied--helping to solve use-after-free
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能指针不能被复制--有助于解决使用后释放
- en: Or maybe the pointer *can* be copied, but it knows how many copies exist and
    won't free the pointee until the last pointer to it has been destroyed
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者指针 *可以*被复制，但它知道存在多少个副本，并且只有在最后一个指向它的指针被销毁后才会释放指向的对象
- en: Or maybe the pointer can be copied, and you can free the pointee, but if you
    do, all other pointers to it magically become null
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者指针可以被复制，你可以释放指向的对象，但如果你这样做，指向它的所有其他指针都会神奇地变为空
- en: Or maybe the pointer has no built-in `operator+`--helping
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者指针没有内置的 `operator+`--有助于
- en: to solve corruption due to pointer arithmetic
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决由于指针算术引起的损坏
- en: Or maybe you're allowed to adjust the pointer's value arithmetically, but the
    arithmetic "what object is pointed-to" is managed separately from the identity
    of "what object is to be freed"
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者你可能允许以算术方式调整指针的值，但算术“指向哪个对象”的管理与“要释放哪个对象”的标识是分开的
- en: The standard smart pointer types are `std::unique_ptr<T>`, `std::shared_ptr<T>`,
    and (not really a pointer type, but we'll lump it in with them) `std::weak_ptr<T>`.
    In this chapter we'll cover all three of those types, plus one non-standard smart
    pointer that you might find useful--and which might become a standard smart pointer
    type in a future C++ standard!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 标准智能指针类型是 `std::unique_ptr<T>`, `std::shared_ptr<T>`, 以及（虽然不是一个真正的指针类型，但我们将它们放在一起）`std::weak_ptr<T>`。在本章中，我们将介绍这三种类型，以及一种可能对你有用的非标准智能指针，它可能在未来的C++标准中成为标准智能指针类型！
- en: Automatically managing memory with std::unique_ptr<T>
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::unique_ptr<T> 自动管理内存
- en: 'The fundamental properties of a smart pointer type are simple: it should support
    `operator*`, and it should overload the special member functions to preserve its
    class invariants, whatever those are.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针类型的根本属性很简单：它应该支持 `operator*`，并且它应该重载特殊成员函数以保持其类的不变性，无论这些是什么。
- en: '`std::unique_ptr<T>` supports the same interface as `T*`, but with the class
    invariant that, once you construct a `unique_ptr` pointing to a given heap-allocated
    object, that object *will* be freed when the destructor `unique_ptr` is called.
    Let''s write some code supporting that `T*` interface:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr<T>` 支持与 `T*` 相同的接口，但具有类不变性，即一旦构造了一个指向给定堆分配对象的 `unique_ptr`，当调用析构函数
    `unique_ptr` 时，该对象 *将会* 被释放。让我们编写一些支持该 `T*` 接口的代码：'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we stopped here--with just a way to construct a pointer object from a `T*`
    and a way to get the pointer out again--we''d have the `observer_ptr<T>` discussed
    at the end of this chapter. But we''ll keep going. We''ll add methods `release`
    and `reset`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里停止——只提供了从 `T*` 构造指针对象的方法以及再次获取指针的方法——我们将得到本章末尾讨论的 `observer_ptr<T>`。但我们会继续前进。我们将添加
    `release` 和 `reset` 方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`p.release()` is just like `p.get()`, but in addition to returning a copy of
    the original raw pointer, it nulls out the contents of `p` (without freeing the
    original pointer, of course, because presumably our caller wants to take ownership
    of it).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`p.release()` 就像 `p.get()`，但除了返回原始原始指针的副本外，它还会将 `p` 的内容置为空（当然，不会释放原始指针，因为我们的调用者可能想要拥有它）。'
- en: '`p.reset(q)` *does* free the current contents of `p`, and then puts the raw
    pointer `q` in its place.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`p.reset(q)` *确实* 释放了 `p` 的当前内容，然后将原始指针 `q` 放在其位置。'
- en: 'Notice that we have implemented both of these member functions in terms of
    the standard algorithm `std::exchange`, which we didn''t cover in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*. It''s sort of a value-returning version of `std::swap`:
    pass in a new value, get out the former value.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经用标准算法 `std::exchange` 实现了这两个成员函数，我们在 [第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)
    “迭代器对算法” 中没有介绍过。它有点像是返回值的 `std::swap`：传入一个新值，得到旧值。
- en: 'Finally, with these two primitive operations, we can implement the special
    member functions of `std::unique_ptr<T>` so as to preserve our invariant--which,
    again, is this: once a raw pointer has been acquired by a `unique_ptr` object,
    it will remain valid as long as the `unique_ptr` object has the same value, and
    when that''s no longer true--when the `unique_ptr` is adjusted to point elsewhere,
    or destroyed--the raw pointer will be freed correctly. Here are the special member
    functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用这两个基本操作，我们可以实现 `std::unique_ptr<T>` 的特殊成员函数，以保持我们的不变性——再次强调，这是：一旦原始指针被
    `unique_ptr` 对象获取，只要 `unique_ptr` 对象具有相同的值，它就会保持有效，当不再是这样时——当 `unique_ptr` 调整以指向其他地方或被销毁时——原始指针将被正确释放。以下是特殊成员函数：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In memory, our `std::unique_ptr<T>` will look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，我们的 `std::unique_ptr<T>` 将看起来像这样：
- en: '![](img/00017.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: 'There is one more little helper function we need, so as never to touch raw
    pointers with our hands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个额外的辅助函数，以确保我们永远不用手动接触原始指针：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With `unique_ptr` in our toolbox, we can replace old-style code such as this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具箱中有 `unique_ptr` 后，我们可以替换旧式代码，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It can be replaced with modern C++17 code like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用现代 C++17 代码替换，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that `unique_ptr<T>` is yet another application of **RAII**--in this
    case, quite literally. Although the "interesting" action (the freeing of the underlying
    raw pointer) still happens during destruction (of the `unique_ptr`), the only
    way you'll get the full benefit of `unique_ptr` is if you make sure that whenever
    you *allocate* a *resource*, you also *initialize* a `unique_ptr` to manage it.
    The `std::make_unique<T>()` function shown in the previous section (and introduced
    to the standard library in C++14) is the key to safe memory management in modern
    C++.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`unique_ptr<T>` 是 **RAII** 的另一个应用——在这种情况下，非常直接。尽管“有趣”的操作（底层原始指针的释放）仍然发生在销毁（`unique_ptr`）期间，但你想要充分利用
    `unique_ptr` 的唯一方法是在你 *分配* 资源时，也 *初始化* 一个 `unique_ptr` 来管理它。上一节中展示的 `std::make_unique<T>()`
    函数（以及 C++14 中引入标准库）是现代 C++ 中安全内存管理的关键。
- en: 'While it is *possible* to use `unique_ptr` without using `make_unique`, you
    should not do it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *可能* 在不使用 `make_unique` 的情况下使用 `unique_ptr`，但你不应这样做：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Why C++ doesn't have the finally keyword
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 C++ 没有finally 关键字
- en: 'Consider again this snippet of code from the preceding section''s "pre-modern"
    code sample:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑上一节“现代”代码示例中的这段代码：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In other languages such as Java and Python, these semantics might be expressed
    more compactly using the `finally` keyword:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言，如 Java 和 Python 中，这些语义可能更紧凑地使用 `finally` 关键字来表示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'C++ doesn''t have the `finally` keyword, and shows no signs that it will ever
    enter the language. This is simply due to a philosophical difference between C++
    and those other languages: the C++ philosophy is that if you''re concerned with
    *enforcing some invariant*--such as "this pointer shall always be freed at the
    end of this block, no matter how we get there"--then you shouldn''t ever be writing
    *explicit code*, because then there''s always a chance for you to write it wrong,
    and then you''ll have bugs.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C++没有`finally`关键字，也没有迹象表明它将进入这个语言。这仅仅是由于C++与其他语言之间的哲学差异：C++的哲学是，如果你关心*强制某些不变性*——例如“指针必须在块的末尾释放，无论我们如何到达那里”——那么你不应该编写*显式代码*，因为这样总有可能写错，然后你会遇到错误。
- en: If you have some *invariant* that you want to enforce, then the right place
    to enforce it is *in the type system*, using constructors, destructors, and other
    special member functions--the tools of RAII. Then, you can ensure that *any possible*
    use of your new type preserves its invariants--such as "the underlying pointer
    shall be freed whenever it's no longer held by an object of this type"--and when
    you go to write your business logic, you won't have to write anything explicitly;
    the code will look simple and yet always--provably--have correct behavior.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些*不变性*想要强制执行，那么强制执行它的正确地方是在*类型系统*中，使用构造函数、析构函数和其他特殊成员函数——RAII的工具。然后，你可以确保*任何可能的*使用你的新类型都保留了其不变性——例如“当不再由该类型对象持有时，应释放底层指针”——当你编写业务逻辑时，你不需要编写任何显式的内容；代码看起来简单，而且总是——可证明地——具有正确的行为。
- en: 'So if you find yourself writing code that looks like the preceding example,
    or if you find yourself wishing you could just write `finally`, stop and think:
    "Should I be using `unique_ptr` for this?" or "Should I write an RAII class type
    for this?"'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你发现自己编写的代码看起来像前面的例子，或者如果你发现自己希望能直接写`finally`，那就停下来想想：“我应该为这个使用`unique_ptr`吗？”或者“我应该为这个编写一个RAII类类型吗？”
- en: Customizing the deletion callback
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义删除回调
- en: 'Speaking of custom RAII types, you might be wondering whether it''s possible
    to use `std::unique_ptr` with a customized deletion callback: for example, instead
    of passing the underlying pointer to `delete`, you might want to pass it to `free()`.
    Yes you can!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 说到自定义RAII类型，你可能想知道是否可以使用`std::unique_ptr`与自定义的删除回调一起使用：例如，你可能会想将底层指针传递给`free()`而不是`delete`。是的，你可以！
- en: '`std::unique_ptr<T,D>` has a second template type parameter: a *deletion callback
    type*. The parameter `D` defaults to `std::default_delete<T>`, which just calls
    `operator delete`, but you can pass in any type you want--typically a user-defined
    class type with an overloaded `operator()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr<T,D>`有一个第二个模板类型参数：一个*删除回调类型*。参数`D`默认为`std::default_delete<T>`，它只是调用`operator
    delete`，但你可以传递任何你想要的类型——通常是具有重载`operator()`的用户定义类类型：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Incidentally, notice that the destructor of `std::unique_ptr` is carefully written
    so that it guarantees never to call your callback with a null pointer. This is
    absolutely critical in the preceding example, because `fclose(NULL)` is a special
    case that means "close all open file handles in the current process"--which is
    never what you wanted to do!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，注意`std::unique_ptr`的析构函数被精心编写，以确保它永远不会用空指针调用你的回调。这在前面的例子中是绝对关键的，因为`fclose(NULL)`是一个特殊情况，意味着“关闭当前进程中的所有打开的文件句柄”——这绝对不是你想要的！
- en: Observe also that `std::make_unique<T>()` only ever takes one template type
    parameter; there is no `std::make_unique<T,D>()`. But the rule to avoid touching
    raw pointers with your hands is still a good one; that's why our preceding example
    wraps the `fopen` and `unique_ptr` construction into a small reusable helper function
    `fcloser::open`, rather than inlining the call to `fopen` into the body of `test`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`std::make_unique<T>()`只接受一个模板类型参数；没有`std::make_unique<T,D>()`。但避免用手直接触摸原始指针的规则仍然是一个好规则；这就是为什么我们前面的例子将`fopen`和`unique_ptr`构造封装在一个小的可重用辅助函数`fcloser::open`中，而不是将`fopen`的调用内联到`test`的作用域中。
- en: 'The space for your custom deleter will be allocated in the body of the `std::unique_ptr<T,D>`
    object itself, which means `sizeof(unique_ptr<T,D>)` may be bigger than `sizeof(unique_ptr<T>)`
    if `D` has any member data:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的自定义删除器的空间将在`std::unique_ptr<T,D>`对象本身的作用域中分配，这意味着如果`D`有任何成员数据，`sizeof(unique_ptr<T,D>)`可能大于`sizeof(unique_ptr<T>)`：
- en: '![](img/00018.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00018.jpeg)'
- en: Managing arrays with std::unique_ptr<T[]>
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::unique_ptr<T[]>管理数组
- en: Another case where `delete p` is not the appropriate way to free a raw pointer
    is if `p` is a pointer to the first element of an array; in that case, `delete
    [] p` should be used instead. Fortunately, as of C++14, `std::unique_ptr<T[]>`
    exists and does the right thing in this case (by virtue of the fact that `std::default_delete<T[]>`
    also exists and does the right thing, which is to call `operator delete[]`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`delete p`不是释放原始指针适当方式的情况是，如果`p`是指向数组第一个元素的指针；在这种情况下，应该使用`delete [] p`。幸运的是，从C++14开始，存在`std::unique_ptr<T[]>`，在这种情况下它会做正确的事情（由于`std::default_delete<T[]>`也存在并且做正确的事情，即调用`operator
    delete[]`）。
- en: An overload of `std::make_unique` for array types does exist, although be careful--it
    assigns a different meaning to its argument! `std::make_unique<T[]>(n)` essentially
    calls `new T[n]()`, where the parentheses on the end signify that it's going to
    value-initialize all the elements; that is, it will zero out primitive types.
    In the rare case that you don't want this behavior, you'll have to call `new`
    yourself and wrap the return value in a `std::unique_ptr<T[]>`, preferably using
    a helper function as we did in the example in the preceding section (where we
    used `fcloser::open`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组类型，确实存在`std::make_unique`的重载，但请注意——它为其参数赋予了不同的含义！`std::make_unique<T[]>(n)`本质上调用`new
    T[n]()`，其中末尾的括号表示它将初始化所有元素；也就是说，它将为原始类型清零。在极少数情况下，如果你不希望这种行为，你必须自己调用`new`，并将返回值包裹在`std::unique_ptr<T[]>`中，最好使用我们在上一节示例中使用的辅助函数（在那里我们使用了`fcloser::open`）。
- en: Reference counting with std::shared_ptr<T>
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::shared_ptr<T>进行引用计数
- en: Having completely solved the problem of memory leaks, we now tackle the problem
    of use-after-free bugs. The essential problem to be solved here is *unclear ownership*--or
    rather `shared ownership`--of a given resource or chunk of memory. This chunk
    of memory might have several people looking at it at different times, maybe from
    different data structures or from different threads, and we want to make sure
    that all these stakeholders are involved in the decision about when to free it.
    The ownership of the underlying chunk of memory should be *shared*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完全解决了内存泄漏的问题后，我们现在着手解决使用后释放（use-after-free）错误的问题。这里需要解决的基本问题是关于给定资源或内存块的所有权不明确——或者说更确切地说是`共享所有权`。这个内存块可能在不同时间被多个人查看，可能来自不同的数据结构或来自不同的线程，我们想要确保所有这些利益相关者都参与决定何时释放它。底层内存块的所有权应该是*共享的*。
- en: For this, the standard has provided `std::shared_ptr<T>`. Its interface appears
    very similar to `std::unique_ptr<T>`; all of the differences are hidden under
    the hood, in the implementations of the special member functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，标准提供了`std::shared_ptr<T>`。它的接口看起来与`std::unique_ptr<T>`非常相似；所有差异都隐藏在底层，在特殊成员函数的实现中。
- en: '`std::shared_ptr<T>` provides an approach to memory management that is often
    known as *reference counting*. Each object managed by a `shared_ptr` keeps count
    of how many references to it are in the system--that is, how many stakeholders
    care about it right now--and as soon as that number drops to zero, the object
    knows it''s time to clean itself up. Of course, it''s not really "the object"
    that cleans itself up; the entity that knows how to count references and clean
    things up is a small wrapper, or "control block," which is created on the heap
    whenever you transfer ownership of an object to `shared_ptr`. The control block
    is handled invisibly by the library, but if we were to view its layout in memory,
    it might look something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr<T>`提供了一种内存管理方法，通常被称为*引用计数*。每个由`shared_ptr`管理的对象都会记录系统中对其的引用数量——也就是说，有多少利益相关者现在关心它——一旦这个数字降到零，对象就知道是时候清理自己了。当然，实际上并不是“对象”在清理自己；知道如何计数引用和清理事物的实体是一个小的包装器，或称为“控制块”，每次你将对象的所有权转移到`shared_ptr`时，都会在堆上创建它。控制块由库无形地处理，但如果我们查看其在内存中的布局，它可能看起来像这样：'
- en: '![](img/00019.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.jpeg)'
- en: Just as `unique_ptr` has `make_unique`, the standard library provides `shared_ptr`
    with `make_shared` so that you never have to touch raw pointers with your hands.
    The other advantage of using `std::make_shared<T>(args)` to allocate shared objects
    is that transferring ownership into a `shared_ptr` requires allocating additional
    memory for the control block. When you call `make_shared`, the library is permitted
    to allocate a single chunk of memory that's big enough for both the control block
    *and* your `T` object, in one allocation. (This is illustrated by the physical
    placement of the rectangles for `control_block_impl` and `Super` in the preceding
    diagram.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `unique_ptr` 有 `make_unique` 一样，标准库为 `shared_ptr` 提供了 `make_shared`，这样你永远不需要用手去触碰原始指针。使用
    `std::make_shared<T>(args)` 分配共享对象的另一个优点是，将所有权转移到 `shared_ptr` 需要为控制块分配额外的内存。当你调用
    `make_shared` 时，库被允许分配一个足够大的内存块，足以容纳控制块和你的 `T` 对象，在一个分配中完成。（这在前面的图中通过 `control_block_impl`
    和 `Super` 的矩形物理位置得到了说明。）
- en: 'Copying a `shared_ptr` increments the "use-count" of its associated control
    block; destroying a `shared_ptr` decrements its use-count. Assigning over the
    value of a `shared_ptr` will decrement the use-count of its old value (if any),
    and increment the use-count of its new value. Here are some examples of playing
    with `shared_ptr`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 `shared_ptr` 会增加其相关控制块的使用计数；销毁 `shared_ptr` 会减少其使用计数。将 `shared_ptr` 的值赋给另一个值会减少旧值的使用计数（如果有的话），并增加新值的使用计数。以下是一些玩转
    `shared_ptr` 的例子：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following diagram illustrates an interesting and occasionally useful aspect
    of `shared_ptr`: the ability for two instances of `shared_ptr` to refer to the
    same control block and yet point to different pieces of the memory being managed
    by that control block:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了 `shared_ptr` 的一个有趣且偶尔有用的特性：两个 `shared_ptr` 实例可以引用同一个控制块，但指向由该控制块管理的不同内存块：
- en: '![](img/00020.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00020.jpeg)'
- en: 'The constructor being used in the preceding diagram, which is also used in
    the `get_second()` function, is often called the "aliasing constructor" of `shared_ptr`.
    It takes an existing non-null `shared_ptr` object of any type, whose control block
    will be shared by the newly constructed object. In the following code sample,
    the message "destroying `Super`" will not be printed until *after* the message
    "accessing `Super::second`":'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中使用的构造函数，它也用于 `get_second()` 函数中，通常被称为 `shared_ptr` 的“别名构造函数”。它接受任何类型的现有非空
    `shared_ptr` 对象，其控制块将由新构造的对象共享。在下面的代码示例中，直到“访问 `Super::second`”的消息之后，才会打印出“销毁
    `Super`”的消息：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, once ownership has been transferred into the `shared_ptr` system,
    the responsibility for remembering how to free a managed resource rests entirely
    on the shoulders of the control block. It isn't necessary for your code to deal
    in `shared_ptr<T>` just because the underlying managed object happens to be of
    type `T`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一旦所有权被转移到 `shared_ptr` 系统中，记住如何释放管理资源的责任就完全落在控制块上。你的代码不需要处理 `shared_ptr<T>`，仅仅因为底层管理对象恰好是类型
    `T`。
- en: Don't double-manage!
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要双重管理！
- en: 'While `shared_ptr<T>` has the potential to eliminate nasty double-free bugs
    from your pointer code, it is sadly all too common for inexperienced programmers
    to write the same bugs using `shared_ptr` simply by over-using the constructors
    that take raw pointer arguments. Here''s an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `shared_ptr<T>` 有潜力从你的指针代码中消除讨厌的双重释放错误，但遗憾的是，对于缺乏经验的程序员来说，仅仅通过过度使用接受原始指针参数的构造函数，就使用
    `shared_ptr` 编写相同的错误是非常常见的。以下是一个例子：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that your goal should be never to touch raw pointers with your hands!
    The place where this code goes wrong is the very first time it calls `pb.get()`
    to fetch the raw pointer out of `shared_ptr`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的目标应该是永远不要用手去触碰原始指针！这段代码出错的地方就是它第一次调用 `pb.get()` 从 `shared_ptr` 中获取原始指针的时候。
- en: 'It would have been correct to call the aliasing constructor here, `pc = std::shared_ptr<X>(pb,
    pb.get())`, but that would have had the same effect as a simple assignment `pc
    = pb`. So another general rule we can state is: if you have to use the word `shared_ptr`
    explicitly in your code, you''re doing something out of the ordinary--and perhaps
    dangerous. *Without* naming `shared_ptr` in your code, you can already allocate
    and manage heap objects (using `std::make_shared`) and manipulate a managed object''s
    use-count by creating and destroying copies of the pointer (using `auto` to declare
    variables as you need them). The one place this rule definitely breaks down is
    when you sometimes need to declare a class data member of type `shared_ptr<T>`;
    you generally can''t do that without writing the name of the type!'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用别名构造函数是正确的，`pc = std::shared_ptr<X>(pb, pb.get())`，但这会产生与简单赋值`pc = pb`相同的效果。因此，我们可以提出另一条通用规则：如果你在代码中必须显式使用`shared_ptr`这个词，那么你正在做一些非同寻常的事情——也许还有危险。*不*在代码中命名`shared_ptr`，你仍然可以分配和管理堆对象（使用`std::make_shared`），并通过创建和销毁指针副本来操作托管对象的使用计数（使用`auto`声明变量，按需使用）。这条规则肯定不适用的情况是，当你有时需要声明一个类型为`shared_ptr<T>`的类数据成员时；你通常不能不写出类型的名称来做到这一点！
- en: Holding nullable handles with weak_ptr
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`weak_ptr`持有可空句柄
- en: You may have noticed in the previous diagrams, an unexplained data member of
    the control block marked "weak count". It's time to explain what that is.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了之前的图中，控制块中标记为“弱计数”的未解释数据成员。现在是时候解释它是什么了。
- en: 'Sometimes--it''s rare, but sometimes--we have a situation where we''re using
    `shared_ptr` to manage the ownership of shared objects, and we''d like to keep
    a pointer to an object without actually expressing ownership of that object. Of
    course we could use a raw pointer, reference, or `observer_ptr<T>` to express
    the idea of "non-owning reference," but the danger then would be that the actual
    owners of the referenced object could decide to free it, and then when we went
    to dereference our non-owning pointer, we''d visit a freed object and get undefined
    behavior. `DangerousWatcher` in the following code sample illustrates this dangerous
    behavior:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时——这种情况很少见，但有时——我们使用`shared_ptr`来管理共享对象的所有权，并且我们希望保留一个对象的指针，而不实际上表达对该对象的所有权。当然，我们可以使用原始指针、引用或`observer_ptr<T>`来表示“非拥有引用”，但危险在于，实际拥有引用对象的拥有者可能会决定释放它，然后当我们尝试取消引用我们的非拥有指针时，我们会访问一个已释放的对象并得到未定义的行为。以下代码示例中的`DangerousWatcher`说明了这种危险行为：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could alternatively use a `shared_ptr` to express the idea of "reference,"
    but of course that would give us an owning reference, making us less of a `Watcher`
    and more of a `Participant`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`shared_ptr`来表示“引用”的概念，但当然这会给我们一个拥有引用，使我们更像是一个`Participant`而不是一个`Watcher`：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What we really want is a non-owning reference that is nevertheless aware of
    the `shared_ptr` system for managing memory, and is able to query the control
    block and find out whether the referenced object still exists. But by the time
    we found out that the object existed and went to access it, it might have been
    deallocated by some other thread! So the primitive operation we need is "atomically
    get an owning reference (a `shared_ptr`) to the referenced object if it exists,
    or otherwise indicate failure." That is, we don't want a *non-owning reference*;
    what we want is a *ticket that we can exchange at some future date for an owning
    reference*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是一个非拥有引用，但它仍然对管理内存的`shared_ptr`系统有所了解，并且能够查询控制块以确定引用的对象是否仍然存在。但当我们发现对象存在并尝试访问它时，它可能已经被其他线程释放了！因此，我们需要的基本操作是“如果存在，原子地获取引用对象的拥有引用（`shared_ptr`），否则指示失败。”也就是说，我们不想一个*非拥有引用*；我们想要的是一个*可以在将来某个日期兑换为拥有引用的票据*。
- en: 'The standard library provides this "ticket for a `shared_ptr`" under the name
    `std::weak_ptr<T>`. (It''s called "weak" in opposition to the "strong" owning
    references of `shared_ptr`.) Here''s an example of how to use `weak_ptr` to solve
    our `Watcher` problem:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在名称`std::weak_ptr<T>`下提供了这个“`shared_ptr`的票据”。（它被称为“弱”以区别于`shared_ptr`的“强”拥有引用。）以下是如何使用`weak_ptr`解决我们的`Watcher`问题的示例：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only two operations you need to know with `weak_ptr` are that you can construct
    a `weak_ptr<T>` from a `shared_ptr<T>` (by calling the constructor, as shown in
    the `watch()` function), and you can attempt to construct a `shared_ptr<T>` from
    a `weak_ptr<T>` by calling `wptr.lock()`. If the `weak_ptr` has expired, you'll
    get back a null `shared_ptr`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的关于 `weak_ptr` 的唯一两个操作是，你可以从 `shared_ptr<T>` 构造一个 `weak_ptr<T>`（通过调用构造函数，如
    `watch()` 函数中所示），并且你可以通过调用 `wptr.lock()` 尝试从 `weak_ptr<T>` 构造一个 `shared_ptr<T>`。如果
    `weak_ptr` 已过期，你会得到一个空的 `shared_ptr`。
- en: There's also the member function `wptr.expired()`, which can tell you if the
    `weak_ptr` in question has already expired; but notice that it's essentially useless,
    since even if it returns `false` right now, it might return `true` a few microseconds
    later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个成员函数 `wptr.expired()`，它可以告诉你相关的 `weak_ptr` 是否已经过期；但请注意，它基本上是无用的，因为即使它现在返回
    `false`，它也可能在几微秒后返回 `true`。
- en: 'The following diagram continues the narrative started in the previous diagram
    by creating `weak_ptr` from `q` and then nulling out the `shared_ptr` it came
    from:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表通过从 `q` 创建 `weak_ptr` 并然后将其 `shared_ptr` 置为空来继续前一个图表开始的故事：
- en: '![](img/00021.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: 'Copying a `weak_ptr` increments the weak-count associated with the referenced
    object''s control block, and destroying a `weak_ptr` decrements the weak-count.
    When the use-count hits zero, the system knows it''s safe to deallocate the controlled
    object; but the control block itself will not be deallocated until the weak-count
    hits zero, at which point we know that there are no more `weak_ptr` objects pointing
    at this control block:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个 `weak_ptr` 会增加与引用对象的控制块关联的弱引用计数，而销毁一个 `weak_ptr` 会减少弱引用计数。当使用计数达到零时，系统知道可以安全地重新分配受控对象；但控制块本身将不会重新分配，直到弱引用计数达到零，这时我们知道没有更多的
    `weak_ptr` 对象指向这个控制块：
- en: '![](img/00022.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: You might have noticed that `shared_ptr` is using the same trick on its `Deleter`
    that we saw in the context of `std::any` and `std::function` in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d),
    *Vocabulary Types*--it is using *type erasure*. And, like `std::any` and `std::function`,
    `std::shared_ptr` provides a "go fish" function--`std::get_deleter<Deleter>(p)`--to
    retrieve the original deleter object. This tidbit will be entirely useless to
    you in your work; I mention it only to call attention to the importance of type
    erasure in modern C++. Even `shared_ptr`, whose ostensible purpose has nothing
    to do with erasing types, relies on type erasure in one little corner of its functionality.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `shared_ptr` 在其 `Deleter` 上使用了与我们在第 5 章[第 26I9K0-2fdac365b8984feebddfbb9250eaf20d]节中提到的
    `std::any` 和 `std::function` 上下文中的相同技巧——它使用了 *类型擦除*。而且，就像 `std::any` 和 `std::function`
    一样，`std::shared_ptr` 提供了一个“去钓鱼”函数——`std::get_deleter<Deleter>(p)`——来检索原始的删除对象。这个信息在你的工作中将完全无用；我提到它只是为了强调类型擦除在现代
    C++ 中的重要性。甚至 `shared_ptr`，其表面目的与擦除类型无关，也在其功能的一个小角落中依赖于类型擦除。
- en: Talking about oneself with std::enable_shared_from_this
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::enable_shared_from_this` 来谈论自己
- en: There's just one more piece of the `shared_ptr` ecosystem that we should discuss.
    We've mentioned the danger of "double-managing" a pointer by creating multiple
    control blocks. So we might want a way to ask, given a pointer to a heap-allocated
    object, just who exactly is managing it right now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该讨论 `shared_ptr` 生态系统中的最后一个部分。我们已经提到了通过创建多个控制块来“双重管理”指针的危险。因此，我们可能需要一个方法来询问，给定一个堆分配对象的指针，现在究竟是谁在管理它。
- en: The most common use-case for this feature is in object-oriented programming,
    where a method `A::foo()` wants to invoke some external function `bar()`, and
    `bar()` needs a pointer back to the `A` object. If we weren't worrying about lifetime
    management, this would be easy; `A::foo()` would simply invoke `bar(this)`. But
    let's say our `A` is being managed by `shared_ptr`, and let's say that `bar()`
    is likely to stash a copy of the `this` pointer somewhere internally--maybe we're
    registering a callback for later, or maybe we're spawning a new thread that will
    run concurrently while `A::foo()` finishes up and returns to its caller. So we
    need some way to keep `A` alive while `bar()` is still running.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性的最常见用例是在面向对象编程中，其中方法 `A::foo()` 想要调用某个外部函数 `bar()`，而 `bar()` 需要一个指向 `A`
    对象的指针。如果我们不担心生命周期管理，这会很简单；`A::foo()` 会简单地调用 `bar(this)`。但假设我们的 `A` 正在被 `shared_ptr`
    管理，假设 `bar()` 很可能将 `this` 指针的副本存储在其内部——也许我们正在注册一个稍后调用的回调，或者也许我们正在创建一个将在 `A::foo()`
    完成并返回调用者时并发运行的线程。因此，我们需要某种方法在 `bar()` 运行期间保持 `A` 的存活。
- en: Clearly `bar()` should take a parameter of type `std::shared_ptr<A>`; this will
    keep our `A` alive. But within `A::foo()`, where do we get that `shared_ptr` from?
    We could give `A` a member variable of type `std::shared_ptr<A>`, but then `A`
    would be keeping *itself* alive--it would never die! That's certainly not what
    we!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`bar()` 应该接受一个类型为 `std::shared_ptr<A>` 的参数；这将保持我们的 `A` 对象存活。但在 `A::foo()`
    中，我们从哪里获得那个 `shared_ptr` 呢？我们可以给 `A` 一个类型为 `std::shared_ptr<A>` 的成员变量，但这样 `A`
    就会保持*自己*的存活——它永远不会死亡！这显然不是我们想要的！
- en: A preliminary solution is that `A` should keep a member variable of type `std::weak_ptr<A>`
    pointing to itself, and when it invokes `bar`, it should do so with `bar(this->m_wptr.lock())`.
    This has quite a bit of syntactic overhead, though, and besides it's unclear how
    the pointer `m_wptr` ought to get initialized. So, C++ took this idea and built
    it right into the standard library!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个初步的解决方案是，`A` 应该保留一个指向自己的类型为 `std::weak_ptr<A>` 的成员变量，并在调用 `bar` 时使用 `bar(this->m_wptr.lock())`。这确实有一些语法开销，而且不清楚指针
    `m_wptr` 应该如何初始化。因此，C++ 将这个想法直接构建到了标准库中！
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `std::enable_shared_from_this<A>` class holds our member variable of type
    `std::weak_ptr<A>`, and exposes the operation "get a `shared_ptr` to myself" under
    the name `x.shared_from_this()`. There are a couple of interesting details to
    notice in the preceding code: First, if you try to call `x.shared_from_this()`
    on an object that isn''t currently being managed by the `shared_ptr` system, you''ll
    get an exception of type `std::bad_weak_ptr`. Second, notice the empty copy constructor
    and copy assignment operator. Empty braces in this case is *not* the same thing
    as `=default`! If we had used `=default` to make the copy operations defaulted,
    they would have performed memberwise copying. Every time you made a copy of a
    managed object, the new object would receive a copy of the original''s `m_weak`;
    which isn''t what we want here at all. The "identity" of the `enable_shared_from_this`
    portion of a C++ object is tied to its *location in memory*, and therefore it
    does not (and should not) follow the rules of copying and value semantics for
    which we typically strive.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_shared_from_this<A>` 类持有我们的类型为 `std::weak_ptr<A>` 的成员变量，并以 `x.shared_from_this()`
    的名称公开“获取指向自己的 `shared_ptr`”操作。在前面的代码中，有几个有趣的细节需要注意：首先，如果你尝试在一个当前没有被 `shared_ptr`
    系统管理的对象上调用 `x.shared_from_this()`，你会得到一个类型为 `std::bad_weak_ptr` 的异常。其次，注意空的拷贝构造函数和拷贝赋值运算符。在这种情况下，空的大括号*不是*与
    `=default` 相同！如果我们使用 `=default` 来使拷贝操作默认化，它们将执行成员-wise 拷贝。每次你复制一个受管理的对象时，新对象都会收到原始对象的
    `m_weak` 的一个副本；这在这里根本不是我们想要的。C++ 对象的 `enable_shared_from_this` 部分的“身份”与其*内存位置*相关联，因此它（并且不应该）遵循我们通常努力追求的拷贝和值语义规则。'
- en: 'The last question to answer is: how does the member `m_weak` (which remember
    is a *private* member; we''re using the name `m_weak` purely for exposition) get
    initialized in the first place? The answer is that the constructor of `shared_ptr`
    includes some lines of code to detect whether `T` publicly inherits from `enable_shared_from_this<T>`,
    and, if so, to set its `m_weak` member through some hidden back door. Notice that
    the inheritance must be *public* and *unambiguous*, since the constructor of `shared_ptr`
    is just another user-defined function as far as the rules of C++ are concerned;
    it can''t crack open your class to find its private base classes, or to disambiguate
    between multiple copies of `enable_shared_from_this`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是要回答：成员 `m_weak`（记住它是一个 *私有* 成员；我们使用 `m_weak` 这个名字纯粹是为了说明）最初是如何初始化的？答案是
    `shared_ptr` 的构造函数包含一些代码来检测 `T` 是否公开继承自 `enable_shared_from_this<T>`，如果是的话，将通过一些隐藏的后门设置其
    `m_weak` 成员。请注意，继承必须是 *公开* 和 *明确的*，因为就 C++ 的规则而言，`shared_ptr` 的构造函数只是一个用户定义的函数；它不能打开你的类来找到其私有基类，或者在不同副本之间进行歧义消除。
- en: These restrictions imply that you should only ever inherit from `enable_shared_from_this`
    publicly; that once a class derives from `enable_shared_from_this` you should
    only ever inherit from *it* publicly; and to keep things simple you probably ought
    to inherit from `enable_shared_from_this` only at the very leaves of your inheritance
    hierarchy. Of course, if you do not make deep inheritance hierarchies in the first
    place, following these rules will be fairly easy!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制意味着你应该只公开继承自 `enable_shared_from_this`；一旦一个类继承自 `enable_shared_from_this`，你应该只公开继承自
    *它*；为了保持简单，你可能只应该在继承层次结构的叶子节点处继承 `enable_shared_from_this`。当然，如果你一开始就没有构建深层继承层次结构，遵循这些规则将会相对容易！
- en: 'Let''s put everything we know about `enable_shared_from_this` together into
    a single example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把关于 `enable_shared_from_this` 的所有知识都集中在一个示例中：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Curiously Recurring Template Pattern
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Curiously Recurring Template Pattern
- en: You may already have noticed, but especially after seeing the preceding code
    sample it should be apparent, that whenever you inherit from `enable_shared_from_this`
    the name of *your class* always appears in the template parameter list of its
    own base class! This pattern of "`X` inherits from `A<X>`" is known as the **Curiously
    Recurring Template Pattern**, or **CRTP** for short. It's common whenever some
    aspect of the base class depends on its derived class. For example, in our case
    the name of the derived class is incorporated into the return type of the `shared_from_this`
    method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，但尤其是在看到前面的代码示例之后，应该很明显，每次你继承自 `enable_shared_from_this` 时，*你的类* 的名称总是出现在其基类模板参数列表中！这种“`X`
    继承自 `A<X>`”的模式被称为 **Curiously Recurring Template Pattern**，或简称 **CRTP**。当基类的一些方面依赖于其派生类时，这种情况很常见。例如，在我们的情况下，派生类的名称被纳入
    `shared_from_this` 方法的返回类型中。
- en: 'Another common case where the CRTP is warranted is when some *behavior* of
    the derived class is incorporated into the behavior provided by the base class.
    For example, using the CRTP we can write a base class template that provides a
    value-returning `operator+` for any derived class that implements `operator+=`
    and copy-construction. Notice the required `static_cast` from `addable<Derived>`
    to `Derived`, so that we call the copy constructor of `Derived` instead of the
    copy constructor of the base class `addable<Derived>`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP 另一个常见的应用场景是，当派生类的一些 *行为* 被纳入基类提供的行为中时。例如，使用 CRTP，我们可以编写一个基类模板，为任何实现 `operator+=`
    和复制构造的派生类提供一个返回值的 `operator+`。注意所需的 `static_cast` 从 `addable<Derived>` 到 `Derived`，这样我们调用的是
    `Derived` 的复制构造函数，而不是基类 `addable<Derived>` 的复制构造函数：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In fact, this is almost exactly the service provided by `boost::addable` in
    the Boost Operators library; except that `boost::addable` uses the so-called "Barton-Nackman
    trick" to make its `operator+` a friend free function instead of a member function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这几乎就是 Boost 运算符库中 `boost::addable` 提供的服务；只不过 `boost::addable` 使用所谓的“Barton-Nackman
    技巧”使其 `operator+` 成为一个非成员的友元函数，而不是成员函数：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Even if you never use `enable_shared_from_this` in your codebase, you should
    be aware of the Curiously Recurring Template Pattern and be able to pull it out
    of your toolbox whenever you need to "inject" some derived-class behavior into
    a method of your base class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从未在你的代码库中使用 `enable_shared_from_this`，你也应该了解 Curiously Recurring Template
    Pattern，并且能够在需要将派生类行为“注入”到基类方法时从你的工具箱中取出它。
- en: A final warning
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的警告
- en: The mini-ecosystem of `shared_ptr`, `weak_ptr`, and `enable_shared_from_this`
    is one of the coolest parts of modern C++; it can give your code the safety of
    a garbage-collected language while preserving the speed and deterministic destruction
    that have always characterized C++. However, be careful not to abuse `shared_ptr`!
    Most of your C++ code shouldn't be using `shared_ptr` at all, because you shouldn't
    be *sharing* the ownership of heap-allocated objects. Your first preference should
    always be to avoid heap-allocation altogether (by using value semantics); your
    second preference should be to make sure each heap-allocated object has a unique
    owner (by using `std::unique_ptr<T>`); and only if both of those are really impossible
    should you consider use of shared ownership and `std::shared_ptr<T>`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`、`weak_ptr` 和 `enable_shared_from_this` 的迷你生态系统是现代 C++ 中最酷的部分之一；它可以为你的代码提供垃圾回收语言的安全性，同时保留
    C++ 始终具有的速度和确定性销毁特性。然而，请注意不要滥用 `shared_ptr`！大多数 C++ 代码根本不应该使用 `shared_ptr`，因为你不应该共享堆分配对象的拥有权。你的首选应该始终是避免堆分配（通过使用值语义）；其次，你应该确保每个堆分配的对象都有一个唯一的所有者（通过使用
    `std::unique_ptr<T>`）；只有在两者都真的不可能的情况下，才考虑使用共享拥有权和 `std::shared_ptr<T>`。'
- en: Denoting un-special-ness with observer_ptr<T>
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `observer_ptr<T>` 表示非特殊化
- en: We've now seen two or three different smart pointer types (depending on whether
    you count `weak_ptr` as a pointer type in its own right, or more like a ticket
    for a `shared_ptr`). Each of these types carries with it some useful source-level
    information about lifetime management. For example, just from the function signatures
    of these two C++ functions, what can we say about their semantics?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了两种或三种不同的智能指针类型（这取决于你是否将 `weak_ptr` 作为独立的指针类型，或者更像是 `shared_ptr` 的入场券）。这些类型中的每一个都携带一些关于生命周期管理的有用源级信息。例如，仅从这两个
    C++ 函数的函数签名中，我们能说些什么关于它们的语义？
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We see that `remusnoc` takes a `unique_ptr` by value, which means that ownership
    of the controlled object is transferred to `remusnoc`. When we call this function,
    we must have *unique ownership* of a `Widget`, and after we call this function,
    we will no longer be able to access that `Widget`. We don't know whether `remusnoc`
    is going to destroy the `Widget`, keep it around, or attach it to some other object
    or thread; but it's explicitly *no longer our concern*. The `remusnoc` function
    is a *consumer* of widgets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `remusnoc` 通过值接收一个 `unique_ptr`，这意味着控制对象的拥有权被转移到了 `remusnoc`。当我们调用这个函数时，我们必须拥有一个
    `Widget` 的唯一拥有权，并且在调用这个函数之后，我们将无法再访问那个 `Widget`。我们不知道 `remusnoc` 是否会销毁 `Widget`、保留它，或者将其附加到其他对象或线程上；但它明确不再是我们的关注点。`remusnoc`
    函数是 widgets 的消费者。
- en: More subtly, we can also say that when we call `remusnoc`, we must have unique
    ownership of a `Widget` that was allocated with `new`, and which it is safe to
    `delete`!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 更微妙的是，我们还可以说，当我们调用 `remusnoc` 时，我们必须拥有一个使用 `new` 分配的 `Widget` 的唯一拥有权，并且可以安全地
    `delete` 它！
- en: 'And vice versa: when I call `recudorp`, I know that whatever `Widget` we receive
    will be *uniquely owned* by me. It isn''t a reference to someone else''s `Widget`;
    it isn''t a pointer to some static data. It''s explicitly a heap-allocated `Widget`
    owned by me and me alone. Even if the first thing I do with the return value is
    to call `.release()` on it and stuff the raw pointer into some "pre-modern" struct,
    I can be sure that it is *safe* to do so, because I am definitely the *unique
    owner* of the return value.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 反之：当我调用 `recudorp` 时，我知道我们接收到的任何 `Widget` 都将唯一归我所有。它不是指向其他人 `Widget` 的引用；它也不是指向某些静态数据的指针。它明确是一个由我独自拥有的堆分配的
    `Widget`。即使我处理返回值的第一件事是在它上面调用 `.release()` 并将原始指针放入某个“前现代”结构中，我也可以确信这样做是安全的，因为我肯定是返回值的唯一所有者。
- en: What can we say about the semantics of this C++ function?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能说些什么关于这个 C++ 函数的语义？
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's ambiguous. Maybe this function will take ownership of the passed pointer;
    maybe it won't. We can tell (we hope) from the documentation of `suougibma`, or
    from certain stylistic conventions in our codebase (such as "a raw pointer shall
    never denote ownership," which is a reasonable convention), but we can't tell
    from the signature alone. Another way to express this distinction is to say that
    `unique_ptr<T>` is a *vocabulary type* for expressing ownership transfer, whereas
    `T*` is not a vocabulary type for anything at all; it's the C++ equivalent of
    a nonsense word or a Rorschach blot, in that no two people will necessarily agree
    on what it means.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不明确的。也许这个函数将接管传递的指针的所有权；也许它不会。我们可以从`suougibma`的文档中（我们希望如此）或从我们代码库中的某些风格约定（例如，“一个原始指针永远不会表示所有权”，这是一个合理的约定）中得知，但我们不能仅从签名中得知。另一种表达这种区别的方法是说，`unique_ptr<T>`是表示所有权转移的词汇类型，而`T*`根本不是任何事物的词汇类型；它是C++中无意义词汇或罗夏墨迹的等价物，因为在任何两个人之间，对它的含义都不一定有共识。
- en: 'So, if you find yourself passing around a lot of non-owning pointers in your
    codebase, you might want a *vocabulary type* to represent the idea of a non-owning
    pointer. (Your first step should be to pass references instead of pointers whenever
    possible, but let''s say that you''ve already exhausted that avenue.) Such a vocabulary
    type does exist, although it is not (yet) in the C++ standard library: due to
    Walter Brown, it''s called "the world''s dumbest smart pointer," and is merely
    a class-shaped wrapper around a raw non-owning pointer:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在代码库中发现自己传递了大量的非拥有指针，你可能需要一个*词汇类型*来表示非拥有指针的概念。（你的第一步应该是尽可能传递引用而不是指针，但假设你已经用尽了这条路。）这样的词汇类型确实存在，尽管它目前还没有包含在C++标准库中：由于沃尔特·布朗，它被称为“世界上最愚蠢的智能指针”，它仅仅是一个围绕原始非拥有指针的类形状包装器：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With `observer_ptr` in our toolbox, it becomes crystal clear that `revresbo`
    merely *observes* its argument; it definitely doesn't take ownership of it. In
    fact, we can assume that it doesn't even keep a copy of the passed-in pointer,
    because the validity of that pointer would depend on the lifetime of the controlled
    object, and `revresbo` is explicitly claiming not to have any stake in the lifetime
    of that object. If it wanted a stake in the lifetime of the controlled object,
    it would ask for that stake explicitly, by requesting `unique_ptr` or `shared_ptr`
    from its caller. By requesting `observer_ptr`, `revresbo` is "opting out" of the
    whole ownership debate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具箱中有`observer_ptr`后，变得非常清楚，`revresbo`仅仅*观察*其参数；它绝对没有接管它的所有权。实际上，我们可以假设它甚至没有保留传入指针的副本，因为该指针的有效性将取决于受控对象的生命周期，而`revresbo`明确表示它对该对象的生命周期没有任何利益。如果它想要对受控对象的生命周期有利益，它将通过从其调用者那里请求`unique_ptr`或`shared_ptr`来明确请求那个利益。通过请求`observer_ptr`，`revresbo`“退出”了整个所有权辩论。
- en: 'As I said, `observer_ptr` is not part of the C++17 standard. One of the main
    objections keeping it out is its terrible name (being as it has nothing to do
    with the "observer pattern"). There are also many knowledgeable people who would
    say that `T*` *should* be the vocabulary type for "non-owning pointer," and that
    all old code using `T*` for ownership transfer should be rewritten or at least
    re-annotated with constructs such as `owner<T*>`. This is the approach currently
    recommended by the editors of the C++ Core Guidelines, including C++ inventor
    Bjarne Stroustrup. One thing is certain, though: *never use raw pointers for ownership
    transfer!*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，`observer_ptr`不是C++17标准的一部分。阻止它进入标准的主要反对意见之一是其糟糕的名称（因为它与“观察者模式”没有任何关系）。还有许多知识渊博的人会说，`T*`应该是“非拥有指针”的词汇类型，并且所有使用`T*`进行所有权转移的旧代码都应该重写或至少用诸如`owner<T*>`之类的结构重新注释。这是目前C++核心指南编辑，包括C++发明者Bjarne
    Stroustrup推荐的方法。尽管如此，有一点是确定的：*永远不要使用原始指针进行所有权转移！*
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned a few things about smart pointers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些关于智能指针的知识。
- en: '`std::unique_ptr<T>` is a vocabulary type for ownership, and for ownership
    transfer; prefer it over raw `T*`. Consider the use of `observer_ptr` in situations
    where ownership is explicitly *not* being transferred, or where raw `T*` might
    be ambiguous to the reader.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr<T>`是表示所有权的词汇类型，也是表示所有权转移的词汇类型；优先考虑它而不是原始的`T*`。考虑在所有权明确*不是*被转移的情况下，或者原始`T*`可能对读者来说模糊不清的情况下使用`observer_ptr`。'
- en: '`std::shared_ptr<T>` is a good (and standard) tool for dealing with shared
    ownership, where many different entities are all stakeholders in the lifetime
    of a single controlled object. `std::weak_ptr<T>` is a "ticket for `shared_ptr`";
    it provides `.lock()` instead of `operator*`. If your class needs the ability
    to get `shared_ptr` to itself, inherit from `std::enable_shared_from_this<T>`.
    Remember to inherit publicly, and generally speaking, only at the leaves of your
    inheritance graph. And don''t overuse these features in situations that do not
    absolutely require shared ownership!'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr<T>` 是处理共享所有权的优秀（且标准）工具，其中许多不同的实体都是单个受控对象生命周期的利益相关者。`std::weak_ptr<T>`
    是一个“`shared_ptr`的入场券”；它提供`.lock()`而不是`operator*`。如果你的类需要获取自身`shared_ptr`的能力，则从`std::enable_shared_from_this<T>`继承。请记住公开继承，并且一般来说，仅在继承图的最底层进行继承。并且不要在绝对不要求共享所有权的情况下过度使用这些功能！'
- en: 'Never touch raw pointers with your hands: use `make_unique` and `make_shared`
    to create heap-allocated objects and manage them in a single swoop. And remember
    the Curiously Recurring Template Pattern whenever you need to "inject" derived-class
    behaviors back into a function provided by your base class.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 千万不要手动触摸原始指针：使用`make_unique`和`make_shared`来创建堆分配的对象，并一次性管理它们。并且每当你需要将派生类行为“注入”到由你的基类提供的函数中时，记得使用“奇特重复的模板模式”。
- en: 'In the next chapter, we''ll talk about a different kind of "sharing": the kind
    that arises in multi-threaded programming.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论另一种类型的“共享”：在多线程编程中出现的共享。
