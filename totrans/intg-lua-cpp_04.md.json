["```cpp\nLUA_PATH = ../../lua\nCXX = g++\nCXXFLAGS = -std=c++17 -Wall -Werror\nCPPFLAGS = -I${LUA_PATH}/src\nLDFLAGS = -L${LUA_PATH}/src\nEXECUTABLE = executable\nALL_O = main.o LuaExecutor.o LoggingLuaExecutorListener.o\nall: clean lua project\nlua:\n    @cd ${LUA_PATH} && make\nproject: ${ALL_O}\n    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -o $(EXECUTABLE) \n     ${ALL_O} -llua\nclean:\n    rm -f ${ALL_O} $(EXECUTABLE)\n```", "```cpp\nenum class LuaType\n{\n    nil,\n    boolean,\n    number,\n    string,\n};\n```", "```cpp\n#include \"LuaType.hpp\"\n```", "```cpp\n#include <cstddef>\nstruct LuaNil final\n{\n    const LuaType type = LuaType::nil;\n    const std::nullptr_t value = nullptr;\n    static LuaNil make() { return LuaNil(); }\nprivate:\n    LuaNil() = default;\n};\n```", "```cpp\nstruct LuaBoolean final\n{\n    const LuaType type = LuaType::boolean;\n    const bool value;\n    static LuaBoolean make(const bool value)\n    {\n        return LuaBoolean(value);\n    }\nprivate:\n    LuaBoolean(const bool value) : value(value) {}\n};\n```", "```cpp\nstruct LuaNumber final\n{\n    const LuaType type = LuaType::number;\n    const double value;\n    static LuaNumber make(const double value)\n    {\n        return LuaNumber(value);\n    }\nprivate:\n    LuaNumber(const double value) : value(value) {}\n};\n```", "```cpp\n#include <string>\nstruct LuaString final\n{\n    const LuaType type = LuaType::string;\n    const std::string value;\n    static LuaString make(const std::string &value)\n    {\n        return LuaString(value);\n    }\nprivate:\n    LuaString(const std::string &value) : value(value) {}\n};\n```", "```cpp\n#include <variant>\nusing LuaValue = std::variant<\n    LuaNil, LuaBoolean, LuaNumber, LuaString>;\n```", "```cpp\ninline LuaType getLuaType(const LuaValue &value)\n{\n    return std::visit(\n        [](const auto &v) { return v.type; },\n        value);\n}\n```", "```cpp\ninline std::string\ngetLuaValueString(const LuaValue &value)\n{\n    switch (getLuaType(value))\n    {\n    case LuaType::nil:\n        return \"nil\";\n    case LuaType::boolean:\n        return std::get<LuaBoolean>(value).value\n            ? \"true\" : \"false\";\n    case LuaType::number:\n        return std::to_string(\n            std::get<LuaNumber>(value).value);\n    case LuaType::string:\n        return  std::get<LuaString>(value).value;\n    }\n}\n```", "```cpp\nstd::string call(const std::string &function,\n                 const std::string &param);\n```", "```cpp\nLuaValue call(const std::string &function,\n              const LuaValue &param);\n```", "```cpp\nlua_pushstring(L, param.c_str());\n```", "```cpp\nclass LuaExecutor\n{\nprivate:\n    void pushValue(const LuaValue &value);\n};\n```", "```cpp\nvoid LuaExecutor::pushValue(const LuaValue &value)\n{\n    switch (getLuaType(value))\n    {\n    case LuaType::nil:\n        lua_pushnil(L);\n        break;\n    case LuaType::boolean:\n        lua_pushboolean(L,\n            std::get<LuaBoolean>(value).value ? 1 : 0);\n        break;\n    case LuaType::number:\n        lua_pushnumber(L,\n            std::get<LuaNumber>(value).value);\n        break;\n    case LuaType::string:\n        lua_pushstring(L,\n            std::get<LuaString>(value).value.c_str());\n        break;\n    }\n}\n```", "```cpp\nclass LuaExecutor\n{\nprivate:\n    LuaValue getValue(int index);\n    LuaValue popValue();\n};\n```", "```cpp\nLuaValue LuaExecutor::getValue(int index)\n{\n    switch (lua_type(L, index))\n    {\n    case LUA_TNIL:\n        return LuaNil::make();\n    case LUA_TBOOLEAN:\n        return LuaBoolean::make(\n            lua_toboolean(L, index) == 1);\n    case LUA_TNUMBER:\n        return LuaNumber::make(\n            (double)lua_tonumber(L, index));\n    case LUA_TSTRING:\n        return LuaString::make(lua_tostring(L, index));\n    default:\n        return LuaNil::make();\n    }\n}\n```", "```cpp\nLuaValue LuaExecutor::popValue()\n{\n    auto value = getValue(-1);\n    lua_pop(L, 1);\n    return value;\n}\n```", "```cpp\nstd::string LuaExecutor::call(\n    const std::string &function,\n    const std::string &param)\n{\n    int type = lua_getglobal(L, function.c_str());\n    assert(LUA_TFUNCTION == type);\n    lua_pushstring(L, param.c_str());\n    pcall(1, 1);\n    return popString();\n}\n```", "```cpp\nLuaValue LuaExecutor::call(\n    const std::string &function, const LuaValue &param)\n{\n    int type = lua_getglobal(L, function.c_str());\n    assert(LUA_TFUNCTION == type);\n    pushValue(param);\n    pcall(1, 1);\n    return popValue();\n}\n```", "```cpp\nstd::string LuaExecutor::popString()\n{\n    auto result = std::get<LuaString>(popValue());\n    return result.value;\n}\n```", "```cpp\nint main()\n{\n    auto listener = std::make_unique<\n        LoggingLuaExecutorListener>();\n    auto lua = std::make_unique<LuaExecutor>(*listener);\n    lua->executeFile(\"script.lua\");\n    auto value1 = lua->call(\n        \"greetings\", LuaString::make(\"C++\"));\n    std::cout << getLuaValueString(value1) << std::endl;\n    auto value2 = lua->call(\n        \"greetings\", LuaNumber::make(3.14));\n    std::cout << getLuaValueString(value2) << std::endl;\n    return 0;\n}\n```", "```cpp\nHello C++\nHello 3.14\n```", "```cpp\nfunction greetings(...)\n    local result = \"Hello\"\n    for i, v in ipairs{...} do\n        result = result .. \" \" .. v .. \",\"\n    end\n    return result\nend\n```", "```cpp\ntemplate <typename... Ts>\nLuaValue call(const std::string &function,\n              const Ts &...params);\n```", "```cpp\ntemplate <typename... Ts>\nLuaValue LuaExecutor::call(const std::string &function,\n                           const Ts &...params)\n{\n    int type = lua_getglobal(L, function.c_str());\n    assert(LUA_TFUNCTION == type);\n    for (auto param :\n        std::initializer_list<LuaValue>{params...})\n    {\n        pushValue(param);\n    }\n    pcall(sizeof...(params), 1);\n    return popValue();\n}\n```", "```cpp\nauto result = lua->call(\"greetings\",\n    LuaString::make(\"C++\"), LuaString::make(\"Lua\"));\nstd::cout << getLuaValueString(result) << std::endl;\n```", "```cpp\nfunction dump_params(...)\n    local results = {}\n    for i, v in ipairs{...} do\n        results[i] = i .. \": \" .. tostring(v) ..\n            \" [\" .. type(v) .. \"]\"\n    end\n    return table.unpack(results)\nend\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    template <typename... Ts>\n    std::vector<LuaValue> vcall(\n        const std::string &function,\n        const Ts &...params);\nprivate:\n    std::vector<LuaValue> popValues(int n);\n};\n```", "```cpp\ntemplate <typename... Ts>\nstd::vector<LuaValue> LuaExecutor::vcall(\n    const std::string &function, const Ts &...params)\n{\n    int stackSz = lua_gettop(L);\n    int type = lua_getglobal(L, function.c_str());\n    assert(LUA_TFUNCTION == type);\n    for (auto param :\n        std::initializer_list<LuaValue>{params...})\n    {\n        pushValue(param);\n    }\n    if (pcall(sizeof...(params), LUA_MULTRET))\n    {\n        int nresults = lua_gettop(L) - stackSz;\n        return popValues(nresults);\n    }\n    return std::vector<LuaValue>();\n}\n```", "```cpp\nstd::vector<LuaValue> LuaExecutor::popValues(int n)\n{\n    std::vector<LuaValue> results;\n    for (int i = n; i > 0; --i)\n    {\n        results.push_back(getValue(-i));\n    }\n    lua_pop(L, n);\n    return results;\n}\n```", "```cpp\nauto results = lua->vcall(\n    \"dump_params\",\n    LuaString::make(\"C++\"),\n    LuaString::make(\"Lua\"),\n    LuaNumber::make(3.14),\n    LuaBoolean::make(true),\n    LuaNil::make());\nfor (auto result : results)\n{\n    std::cout << getLuaValueString(result) << std::endl;\n}\n```", "```cpp\n1: C++ [string]\n2: Lua [string]\n3: 3.14 [number]\n4: true [boolean]\n```"]