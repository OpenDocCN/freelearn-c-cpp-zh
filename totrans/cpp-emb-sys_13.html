<html><head></head><body>
<div><h1 class="chapterNumber">10</h1>
<h1 class="chapterTitle" id="_idParaDest-149">Writing Expressive Code with Lambdas</h1>
<p class="normal">Lambda expressions in C++ allow us to write short blocks of code that encapsulate functionality and capture the surrounding state into a callable object. We can use <code class="inlineCode">operator()</code> on a callable object to execute the functionality implemented in it.</p>
<p class="normal">Common uses of lambdas include passing a function object (also called a functor – an object of a class that overrides <code class="inlineCode">operator()</code>) to standard library algorithms, or any code expecting a function object, encapsulating small blocks of code that are often used only in a single function, and variable initialization. Their ability to localize functionality without separate functions or class methods modernized C++, making it possible to write cleaner, more expressive code.</p>
<p class="normal">In embedded development, lambdas are especially useful for defining actions in response to timer or external interrupts, scheduling tasks, and similar event-driven mechanisms. The goal of this chapter is to learn how to use lambda expressions to write expressive C++ code. In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList">Lambda expression basics</li>
<li class="bulletList">Store lambdas using <code class="inlineCode">std::function</code></li>
<li class="bulletList"><code class="inlineCode">std::function</code> and dynamic memory allocation</li>
</ul>
<h1 class="heading-1" id="_idParaDest-150">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler and target x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using a lot of modern C++ features, make sure to select the C++23 standard by adding <code class="inlineCode">-std=c++23</code> in the compiler options box.</p>
<p class="normal">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. Most of the examples can also be run in the Renode simulator on the ARM Cortex-M0 target and are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10</a>).</p>
<h1 class="heading-1" id="_idParaDest-151">Lambda expression basics</h1>
<p class="normal"><strong class="keyWord">Lambda expressions</strong>, or lambdas, were <a id="_idIndexMarker482"/>introduced in C++11. They are used to create an instance of an unnamed closure type in C++. A closure stores an unnamed function and can capture variables from its scope by value or reference. We can call <code class="inlineCode">operator ()</code> on a lambda instance, with arguments specified in the lambda definition, effectively calling the underlying unnamed function. To draw a parallel with C, lambdas are callable in the same way as function pointers.</p>
<p class="normal">We will now dive into an example to demonstrate how we can use lambdas in C++ and explain details regarding lambda capturing. Let us process the example below:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
int main() {
    std::array&lt;int, 4&gt; arr{5, 3, 4, 1};
    const auto print_arr = [&amp;arr](const char* message) {
        printf("%s\r\n", message);
        for(auto elem : arr) {
            printf("%d, ", elem);
        }
        printf("\r\n");
    };
    print_arr("Unsorted array:");
    std::sort(arr.begin(), arr.end(), [](int a, int b) {
       return a &lt; b;});
    print_arr("Sorted in ascending order:");
    std::sort(arr.begin(), arr.end(), [](int a, int b) {
       return a &gt; b;});
    print_arr("Sorted in descending order:");
    return 0;
}
</code></pre>
<p class="normal">Running the <a id="_idIndexMarker483"/>above example, we will get the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Unsorted array:
5, 3, 4, 1,
Sorted in ascending order:
1, 3, 4, 5,
Sorted in descending order:
5, 4, 3, 1,
</code></pre>
<p class="normal">What we see are outputs of the lambda <code class="inlineCode">print_arr</code> used to print an array <code class="inlineCode">arr</code> defined in the main function. Let’s go through the <code class="inlineCode">print_arr</code> lambda in detail:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">[&amp;arr]</code> syntax captures the variable arr by reference from the surrounding scope. This means the lambda can access and use arr directly within its body.</li>
<li class="bulletList">We can capture variables by value, or by reference if we prefix the name of a variable with <code class="inlineCode">&amp;</code> as we did for the <code class="inlineCode">print_arr</code> lambda.</li>
<li class="bulletList">Capturing by reference <code class="inlineCode">[&amp;arr]</code> allows the lambda to see any changes made to <code class="inlineCode">arr</code> outside the lambda after its definition. If we captured by value, the lambda would have its own copy of <code class="inlineCode">arr</code>.</li>
<li class="bulletList">By defining <code class="inlineCode">print_arr</code> as a lambda within <code class="inlineCode">main</code>, we encapsulate the functionality of printing the array without needing to create a separate function. This keeps related code together and enhances readability.</li>
</ul>
<p class="normal">In the same example, we used <a id="_idIndexMarker484"/>lambdas as predicate functions to the <code class="inlineCode">std::sort</code> algorithm, to sort array <code class="inlineCode">arr</code> first in ascending, then in descending order. We will go through this use case of lambdas in more detail:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">std::sort</code> algorithm rearranges the elements of <code class="inlineCode">arr</code> based on the comparator provided.</li>
<li class="bulletList">The lambda <code class="inlineCode">[](int a, int b) { return a &lt; b; }</code> acts as a comparator function for <code class="inlineCode">std::sort</code>. It takes two integers and returns <code class="inlineCode">true</code> if the first is less than the second, which results in an ascending sort.</li>
<li class="bulletList">The lambda <code class="inlineCode">[](int a, int b) { return a &gt; b; }</code> returns <code class="inlineCode">true</code> if the first integer is greater than the second, resulting in a descending sort.</li>
</ul>
<p class="normal">Defining the comparator directly at the call site of <code class="inlineCode">std::sort</code> makes the code more concise. It becomes immediately clear how the array is being sorted without needing to look elsewhere in the code.</p>
<p class="normal">In the cases of using lambdas with the <code class="inlineCode">std::sort</code> algorithm, both lambdas are small and simple, making it easy to deduce what they return. Keeping lambdas short and straightforward is considered a good practice as it improves readability and makes the intent of the code immediately clear to others. We can also specify the lambda return type explicitly as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code"> auto greater_than = [](int a, int b) -&gt; bool {
        return a &gt; b;
    };
</code></pre>
<p class="normal">Here, we explicitly <a id="_idIndexMarker485"/>defined the return type. This is optional and can be used when we want to be explicit about the type that a lambda returns. Also, note that the capture clause of this lambda is empty square brackets <code class="inlineCode">[]</code>. This indicates that the lambda is not capturing any variables from the surrounding scope.</p>
<p class="normal">When the lambda is capturing a variable by reference, it is important to note that this introduces lifetime dependency – meaning that the object that reference is bound to must exist when we call the lambda – else, we will use a so-called dangling reference, which is undefined behavior. This is especially a concern with asynchronous operations – that is, when a lambda is passed to a function and called later. Next, we will learn how to store lambdas using <code class="inlineCode">std::function</code> to use them asynchronously.</p>
<h1 class="heading-1" id="_idParaDest-152">Storing lambdas using std::function</h1>
<p class="normal"><code class="inlineCode">std::function</code> is a<a id="_idIndexMarker486"/> class template that allows us to store, copy, and<a id="_idIndexMarker487"/> invoke callable objects such as function pointers and lambdas. We will go through a simple code example to demonstrate this:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
#include &lt;functional&gt;
int main() {
    std::function&lt;void()&gt; fun;
    fun = []() {
        printf("This is a lambda!\r\n");
    }; 
    fun();
    std::uint32_t reg = 0x12345678;
    fun = [reg]() {
        printf("Reg content 0x%8X\r\n", reg);
    };
    reg = 0;
    fun();
    return 0;
}
</code></pre>
<p class="normal">Let us go<a id="_idIndexMarker488"/> through the example:</p>
<ul>
<li class="bulletList">In <a id="_idIndexMarker489"/>the <code class="inlineCode">main</code> function, we first create an object fun of type <code class="inlineCode">std::function&lt;void()&gt;</code>. This specifies that <code class="inlineCode">fun</code> can store any callable object that returns <code class="inlineCode">void</code> and takes no arguments. This includes function pointers, lambdas, or any object with an <code class="inlineCode">operator()</code> that matches the signature.</li>
<li class="bulletList"> We then assign a lambda to <code class="inlineCode">fun</code> and invoke it, which prints the message “This is a lambda!” to the console.</li>
<li class="bulletList">Next, we assigned another lambda to the <code class="inlineCode">fun</code> object. This time the lambda captures the <code class="inlineCode">uint32_t reg</code> by value from the surrounding scope and prints it. Capturing by value means the lambda makes its own copy of <code class="inlineCode">reg</code> at the moment the lambda is defined.</li>
<li class="bulletList">We change the value of <code class="inlineCode">reg</code> to <code class="inlineCode">0</code> before invoking the callable object stored in <code class="inlineCode">fun</code> to show it is being captured by value. Calling <code class="inlineCode">fun</code> prints <code class="inlineCode">Reg content 0x12345678</code>.</li>
</ul>
<p class="normal">Let’s <a id="_idIndexMarker490"/>use <code class="inlineCode">std::function</code> in a more interesting example, where we will use it to<a id="_idIndexMarker491"/> store a callback to a GPIO interrupt. The code is below:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
#include &lt;functional&gt;
namespace hal
{
class gpio
{
public:
    gpio(const std::function&lt;void()&gt; &amp; on_press) {
        if(on_press) {
            on_press_ = on_press;
        }
    }
    void execute_interrupt_handler () const {
        if(on_press_) {
            on_press_();
        }
    }
private:
    std::function&lt;void()&gt; on_press_ = nullptr;
};
}; // namespace hal
int main () {
    hal::gpio button1([]() {
        printf("Button1 pressed!\r\n");
    });
    // invoke stored lambda
    button1.execute_interrupt_handler();
    return 0;
}
</code></pre>
<p class="normal">In the code above, we created a <code class="inlineCode">hal::gpio</code> class that represents a GPIO:</p>
<p class="normal">The class stores <code class="inlineCode">std::function&lt;void()&gt; on_press_</code>, which can hold any callable object like a lambda function. It is initialized to nullptr to indicate it holds no callable object.</p>
<ul>
<li class="bulletList">It provides the method <code class="inlineCode">execute_interrupt_handler</code>, which checks if <code class="inlineCode">on_press_</code> evaluates to true, that is, if it stores a callable object, and executes it if it does.</li>
</ul>
<p class="normal">In the <code class="inlineCode">main</code> function, we <a id="_idIndexMarker492"/>create <code class="inlineCode">button1</code>, an object of <a id="_idIndexMarker493"/>class <code class="inlineCode">hal::button</code>:</p>
<ul>
<li class="bulletList">We provide the constructor with a simple lambda that prints Button1 pressed!.</li>
<li class="bulletList">Next, we call the method <code class="inlineCode">execute_interrupt_handler</code>, which invokes the stored lambda and the program prints <code class="inlineCode">Button1 pressed!</code>.</li>
</ul>
<p class="normal">In a real firmware, we would call the method <code class="inlineCode">execute_interrupt_handler</code> from an interrupt service.</p>
<p class="normal">The above code is an example of the application of the <strong class="keyWord">command pattern</strong>, which is implemented in a simple and expressive way in C++ thanks to <code class="inlineCode">std::function</code> and lambda expressions.</p>
<h2 class="heading-2" id="_idParaDest-153">The command pattern</h2>
<p class="normal">The <strong class="keyWord">command pattern</strong> is a behavioral <a id="_idIndexMarker494"/>design pattern used to capture a function call together with required arguments – allowing us to execute those functions with a delay.</p>
<p class="normal">We will go through a canonical definition of the command pattern. Let us start with a UML diagram of the pattern and explain it afterward:</p>
<figure class="mediaobject"><img alt="Figure 10.1 – Command pattern – UML diagram" src="img/B22402_10_01.png"/></figure>
<p class="packt_figref">Figure 10.1 – Command pattern – UML diagram</p>
<p class="normal"><em class="italic">Figure 10</em><em class="italic">.1</em> depicts a <a id="_idIndexMarker495"/>UML diagram of the command pattern. We notice the following entities in the above diagram.</p>
<p class="normal">The <code class="inlineCode">command</code> interface with a virtual <code class="inlineCode">execute</code> method, and a <code class="inlineCode">concrete_command</code> implementation of the interface.</p>
<ul>
<li class="bulletList"><code class="inlineCode">receiver</code>, stored by a reference in the <code class="inlineCode">concrete_command</code> implementation. It performs an <code class="inlineCode">action</code> that takes <code class="inlineCode">params</code> as arguments.</li>
<li class="bulletList"><code class="inlineCode">invoker</code>, which stores a reference to the <code class="inlineCode">command</code> interface and executes a <code class="inlineCode">command</code>.</li>
<li class="bulletList"><code class="inlineCode">client</code>, which creates a <code class="inlineCode">receiver</code> and passes it to the constructor of <code class="inlineCode">concrete_command</code>. It passes a reference of a created <code class="inlineCode">concrete_command</code> to an <code class="inlineCode">invoker</code>.</li>
</ul>
<p class="normal">By using the command interface, we are able to make different concrete commands and provide them to invokers. Instead of the command interface and concrete commands, we can use class template <code class="inlineCode">std::function</code> and lambda expressions for the same purpose.</p>
<p class="normal">In our previous example, we created the <code class="inlineCode">hal::gpio</code> class as an invoker from the command pattern. It has a <code class="inlineCode">std::function&lt;void()&gt;</code> as a member – an equivalent to a command interface. A concrete command is a lambda expression that we stored in <code class="inlineCode">std::function&lt;void()&gt;</code>.</p>
<p class="normal"><code class="inlineCode">receiver</code> is the lambda body – the <code class="inlineCode">printf</code> function in our example – and <code class="inlineCode">client</code> is the <code class="inlineCode">main</code> function. The<a id="_idIndexMarker496"/> client creates a receiver (<code class="inlineCode">hal::gpio button1</code>) and provides it with a concrete command (lambda expression). We call <code class="inlineCode">execute_interrupt_handler</code> on the invoker directly from the <code class="inlineCode">main</code> function.</p>
<p class="normal">Next, we will expand this example to call <code class="inlineCode">execute_interrupt_handler</code> from the interrupt handler on the STM32 platform. The design will support interrupts from multiple pins. We will introduce the <code class="inlineCode">gpio_interrupt_manager</code> entity, which will be responsible for registering invokers and calling the <code class="inlineCode">execute_interrupt_handler</code> method on them.</p>
<h2 class="heading-2" id="_idParaDest-154">GPIO interrupt manager</h2>
<p class="normal">We want to utilize <a id="_idIndexMarker497"/>the <code class="inlineCode">std::function</code> class template and lambda expressions to enable an expressive way of creating GPIO interrupt handlers in firmware as in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">const hal::gpio_stm32&lt;hal::port_a&gt; button1(hal::pin::p4, [](){
 printf("Button1 pressed!\r\n");
});
</code></pre>
<p class="normal">In the code above, we are creating an object <code class="inlineCode">button1</code> from the class template <code class="inlineCode">hal::gpio_stm32</code> parametrized with <code class="inlineCode">hal::port_a</code>. We are providing a constructor with <code class="inlineCode">hal::pin::p4</code> and a lambda expression that will be executed on interrupt. This is a goal, an expressive interface for writing interrupt handlers that also allows us to capture surrounding variables if needed, thanks to lambda expressions.</p>
<p class="normal">From the code above, we can see both the pin and the port we are configuring and the callback that will be executed on the interrupt. The mechanism that we will create will handle interrupt handler registration to a central entity we will name <code class="inlineCode">gpio_interrupt_manager</code>. Before we proceed with the design, please run the full example in Renode using the instructions below.</p>
<ol>
<li class="numberedList" value="1">Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter10/lambdas</code> project as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:
        <pre class="programlisting con"><code class="hljs-con">$ cd Chapter10/lambdas
$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_std_function_command_pattern.cpp
$ cmake --build build --target run_in_renode
</code></pre>
</li>
<li class="numberedList">In Renode, we can simulate button press and release using the following command for <code class="inlineCode">button1</code> and <code class="inlineCode">button2</code>:
        <pre class="programlisting code"><code class="hljs-code">gpioPortA.button1 PressAndRelease
gpioPortA.button2 PressAndRelease
</code></pre>
</li>
<li class="numberedList">Entering the <a id="_idIndexMarker498"/>above command should result in the following output in the Renode console:
        <pre class="programlisting con"><code class="hljs-con">Button1 pressed!
Button2 pressed!
</code></pre>
</li>
</ol>
<p class="normal">As you can see, actions provided in lambdas are invoked by interrupts generated by buttons. Let us go through the UML diagram of this example to understand how it works:</p>
<figure class="mediaobject"><img alt="Figure 10.2 – GPIO Interrupt manager UML diagram" src="img/B22402_10_02.png"/></figure>
<p class="packt_figref">Figure 10.2 – GPIO Interrupt manager UML diagram</p>
<p class="normal">In <em class="italic">Figure 10</em><em class="italic">.2</em>, we see the <a id="_idIndexMarker499"/>UML diagram of the GPIO interrupt manager. It is based on the command pattern. We are using <code class="inlineCode">std::function&lt;void()&gt;</code> in place of the command interface and lambda expression for concrete commands. The invoker is the <code class="inlineCode">hal::gpio</code> abstract class, which stores the lambda in the member <code class="inlineCode">on_press</code>. It registers itself with <code class="inlineCode">gpio_interrupt_manager</code> in the constructor as we can see from the following code:</p>
<pre class="programlisting code"><code class="hljs-code">gpio::gpio(const std::function&lt;void()&gt; &amp; on_press) {
   on_press_ = on_press;
   gpio_interrupt_manager::register_interrupt_handler(this)
}
</code></pre>
<p class="normal"><code class="inlineCode">gpio_interrupt_manager</code> is a simple struct. It serves as a central entity for the interrupt handling mechanism with the following features:</p>
<ul>
<li class="bulletList">It contains an array of hal::gpio pointers – <code class="inlineCode">std::array&lt;gpio*, c_gpio_handlers_num&gt; gpio_handlers</code>.</li>
<li class="bulletList">It provides a static method to register a <code class="inlineCode">hal::gpio</code> pointer – <code class="inlineCode">void register_interrupt_handler(gpio * pin)</code>.</li>
<li class="bulletList">It provides a static method that executes interrupt handlers stored in the array – <code class="inlineCode">void execute_interrupt_handlers()</code>.</li>
</ul>
<p class="normal">The method <code class="inlineCode">execute_interrupt_handlers</code> is called from the interrupt service routine as shown below:</p>
<pre class="programlisting code"><code class="hljs-code">extern "C" void EXTI4_15_IRQHandler(void) {
    gpio_interrupt_manager::execute_interrupt_handlers();
}
</code></pre>
<p class="normal"><code class="inlineCode">EXTI4_15_IRQHandler</code> is an<a id="_idIndexMarker500"/> interrupt service routine defined in the vector table (defined in platform/startup_stm32f072xb.s). That’s why we used <code class="inlineCode">"C"</code> language linkage and implemented it as a global function. The <code class="inlineCode">execute_interrupt_handlers</code> method loops through the array of <code class="inlineCode">hal::gpio</code> pointers and calls the <code class="inlineCode">execute_interrupt_handler</code> method on them as shown below:</p>
<pre class="programlisting code"><code class="hljs-code">void gpio_interrupt_manager::execute_interrupt_handlers() {
    for(std::size_t i = 0; i &lt; w_idx; i++) {
        gpio_handlers[i]-&gt;execute_interrupt_handler();
    }
}
</code></pre>
<p class="normal"><code class="inlineCode">hal::gpio</code> is an <a id="_idIndexMarker501"/>abstract class with the following features:</p>
<ul>
<li class="bulletList">It implements the <code class="inlineCode">execute_interrupt_handler</code> method used by <code class="inlineCode">gpio_interrupt_manager</code> as we saw earlier.</li>
<li class="bulletList">It defines the pure virtual method <code class="inlineCode">[[nodiscard]] virtual bool is_interrupt_generated() const = 0</code>. This method needs to be overridden by the derived class that implements platform-specific functionality.</li>
<li class="bulletList">It defines the virtual method <code class="inlineCode">virtual void clear_interrupt_flag() const = 0</code>. This method needs to be overridden by the derived class that implements platform-specific functionality.</li>
</ul>
<p class="normal">The code for <code class="inlineCode">execute_interrupt_handler</code> is shown below:</p>
<pre class="programlisting code"><code class="hljs-code">void gpio::execute_interrupt_handler () const {
    if(is_interrupt_generated()){
        clear_interrupt_flag();
        if(on_press_) {
            on_press_();
        }
    }
}
</code></pre>
<p class="normal">The <code class="inlineCode">execute_interrupt_handler</code> method implements the following functionality:</p>
<ul>
<li class="bulletList">It checks if the interrupt should be handled by the current object using the virtual method <code class="inlineCode">is_interrupt_generated</code>. This method must be overridden by a derived class. The derived class has the data needed to determine if the generated interrupt needs to be addressed by the current object.</li>
<li class="bulletList">If the interrupt should be addressed by the current object, the interrupt flag is cleared using the virtual method <code class="inlineCode">clear_interrupt_flag</code> and <code class="inlineCode">on_press_</code> is called if it stores a callable object.</li>
</ul>
<p class="normal"><code class="inlineCode">hal::gpio_stm32</code> is a <a id="_idIndexMarker502"/>class template derived from <code class="inlineCode">hal::gpio</code>. We instantiate it with port as a parameter, and it implements platform-specific operations such as GPIO initialization using the vendor-provided C HAL library.</p>
<p class="normal">In the example, we instantiated <code class="inlineCode">hal::gpio_stm32</code> with struct <code class="inlineCode">port_a</code>, which contains the <code class="inlineCode">void init_clock()</code> static function. This allows us to call a static method on the template parameter, instead of defining port as an <code class="inlineCode">enum</code>, checking it in runtime, and calling a port-specific function for clock initialization.</p>
<p class="normal">The <code class="inlineCode">hal::gpio_stm32</code> class template uses <code class="inlineCode">hal::gpio</code> as a base class:</p>
<ul>
<li class="bulletList">The constructor takes an enum pin and const reference to a <code class="inlineCode">std::function&lt;void()&gt;</code> object that we use to initialize the base class in the initialization list.</li>
<li class="bulletList"><code class="inlineCode">[[nodiscard]] bool is_interrupt_generated() const</code> – the overridden method uses vendor-provided C HAL to determine if the interrupt was generated by the pin provided to the object through the constructor.</li>
<li class="bulletList"><code class="inlineCode">void clear_interrupt_flag() const</code> – the overridden method implements platform-specific code used to clear the interrupt flag.</li>
</ul>
<p class="normal">This sums up the implementation of the GPIO interrupt manager and explains the design. You can refer to other details of the implementation in the source code provided in the <code class="inlineCode">Chapter10/lambdas</code> folder of the book’s GitHub repo.</p>
<p class="normal">Next, we will discuss the implications of using <code class="inlineCode">std::function</code> on dynamic memory allocation.</p>
<h1 class="heading-1" id="_idParaDest-155">std::function and dynamic memory allocation</h1>
<p class="normal"><code class="inlineCode">std::function</code> needs to<a id="_idIndexMarker503"/> store all variables and references that a lambda captures. This behavior is implementation-defined, and implementations usually use heap, which is dynamic memory allocation to store large amounts of variables. If the captured data is small (on some platforms, 16 bytes), it will be stored on the stack. This is called small object optimization. To demonstrate the behavior of the <code class="inlineCode">std::function</code> class template when capturing data, we will go through the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;functional&gt;
void *operator new(std::size_t count) {
  printf("%s, size = %ld\r\n", __PRETTY_FUNCTION__, count);
  return std::malloc(count);
}
void operator delete(void *ptr) noexcept {
  printf("%s\r\n", __PRETTY_FUNCTION__);
  std::free(ptr);
}
int main () {
    std::function&lt;void()&gt; func;
    auto arr = []() {
        constexpr std::size_t c_array_size = 6;
        std::array&lt;int, c_array_size&gt; ar{};
        for(int i = 0; i &lt; ar.size(); i++) {
            ar[i] = i;
        }
        return ar;
    }();
    auto array_printer = [arr]() {
        for(int elem: arr) {
            printf("%d, ", elem);
        }
        printf("\r\n");
    };
    func = array_printer;
    // invoke stored lambda
func();
    return 0;
}
</code></pre>
<p class="normal">In the above example, we have overridden the operators <code class="inlineCode">new</code> and <code class="inlineCode">delete</code> to show that storing a lambda that captures an array of 6 integers will invoke dynamic memory allocation. If you run the above <a id="_idIndexMarker504"/>example in Compiler Explorer using <code class="inlineCode">x86-64 GCC 14.2</code>, you will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">void* operator new(std::size_t), size = 24
0, 1, 2, 3, 4,
void operator delete(void*)
</code></pre>
<p class="normal">This example also demonstrates the initialization of variable <code class="inlineCode">arr</code> by using a lambda to generate members of the array. If you change <code class="inlineCode">constexpr std::size_t c_array_size</code> to 4, you will notice that the operators <code class="inlineCode">new</code> and <code class="inlineCode">delete</code> are no longer invoked, meaning that, in this case, the captured data is stored on the stack.</p>
<p class="normal">To get around this problem, we can assign <code class="inlineCode">std::reference_wrapper</code> of a lambda object to <code class="inlineCode">std::function&lt;void()&gt; fun</code> instead of the object itself as in the following line of code:</p>
<pre class="programlisting code"><code class="hljs-code">    func = std::ref(array_printer);
</code></pre>
<p class="normal">This will make the <code class="inlineCode">std::function</code> object use a reference wrapper to the lambda object, instead of copying it and storing all the variables that lambda is capturing. Using this approach, we must take care of the lambda object lifetime, meaning that if it goes out of scope and we try to invoke it through the <code class="inlineCode">std::function</code> object, we will end up with undefined behavior of the program.</p>
<p class="normal">We can also use plain function pointers to store lambdas, but only if they don’t capture anything from the surrounding scope, as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;functional&gt;
int main () {
    void(*fun)(void);
    fun = []() {
        printf("Lambda!\r\n");
    };
    fun();
    return 0;
}
</code></pre>
<p class="normal">In the above<a id="_idIndexMarker505"/> example, we assign the lambda to a function pointer, making it a possible alternative to storing lambdas to the <code class="inlineCode">std::function</code> class template in certain applications. This also makes it possible to pass non-capturing lambdas to C functions that expect function pointers.</p>
<h1 class="heading-1" id="_idParaDest-156">Summary</h1>
<p class="normal">Lambda expressions and <code class="inlineCode">std::function</code> are powerful modern C++ tools that allow us to write expressive code and implement design patterns such as command patterns in an elegant way. We learned about different ways to capture data from the surrounding scope – by value or a reference. We also went through the command pattern design pattern and learned how to apply it to a GPIO interrupt manager.</p>
<p class="normal">In the next chapter, we will go through compile-time computation in C++.</p>
</div>
</body></html>