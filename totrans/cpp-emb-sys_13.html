<html><head></head><body>
<div id="_idContainer059">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 class="chapterTitle" id="_idParaDest-149"><span class="koboSpan" id="kobo.2.1">Writing Expressive Code with Lambdas</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Lambda expressions in C++ allow us to write short blocks of code that encapsulate functionality and capture the surrounding state into a callable object. </span><span class="koboSpan" id="kobo.3.2">We can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4.1">operator()</span></code><span class="koboSpan" id="kobo.5.1"> on a callable object to execute the functionality implemented in it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">Common uses of lambdas include passing a function object (also called a functor – an object of a class that overrides </span><code class="inlineCode"><span class="koboSpan" id="kobo.7.1">operator()</span></code><span class="koboSpan" id="kobo.8.1">) to standard library algorithms, or any code expecting a function object, encapsulating small blocks of code that are often used only in a single function, and variable initialization. </span><span class="koboSpan" id="kobo.8.2">Their ability to localize functionality without separate functions or class methods modernized C++, making it possible to write cleaner, more expressive code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">In embedded development, lambdas are especially useful for defining actions in response to timer or external interrupts, scheduling tasks, and similar event-driven mechanisms. </span><span class="koboSpan" id="kobo.9.2">The goal of this chapter is to learn how to use lambda expressions to write expressive C++ code. </span><span class="koboSpan" id="kobo.9.3">In this chapter, we’re going to cover the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Lambda expression basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Store lambdas using </span><code class="inlineCode"><span class="koboSpan" id="kobo.12.1">std::function</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.13.1">std::function</span></code><span class="koboSpan" id="kobo.14.1"> and dynamic memory allocation</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-150"><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.16.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.17.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.18.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.18.2">Select GCC as your compiler and target x86 architecture. </span><span class="koboSpan" id="kobo.18.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.18.4">As we are using a lot of modern C++ features, make sure to select the C++23 standard by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.19.1">-std=c++23</span></code><span class="koboSpan" id="kobo.20.1"> in the compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.21.1">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. </span><span class="koboSpan" id="kobo.21.2">Most of the examples can also be run in the Renode simulator on the ARM Cortex-M0 target and are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10"><span class="url"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10</span></span></a><span class="koboSpan" id="kobo.23.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-151"><span class="koboSpan" id="kobo.24.1">Lambda expression basics</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">Lambda expressions</span></strong><span class="koboSpan" id="kobo.26.1">, or lambdas, were </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.27.1">introduced in C++11. </span><span class="koboSpan" id="kobo.27.2">They are used to create an instance of an unnamed closure type in C++. </span><span class="koboSpan" id="kobo.27.3">A closure stores an unnamed function and can capture variables from its scope by value or reference. </span><span class="koboSpan" id="kobo.27.4">We can call </span><code class="inlineCode"><span class="koboSpan" id="kobo.28.1">operator ()</span></code><span class="koboSpan" id="kobo.29.1"> on a lambda instance, with arguments specified in the lambda definition, effectively calling the underlying unnamed function. </span><span class="koboSpan" id="kobo.29.2">To draw a parallel with C, lambdas are callable in the same way as function pointers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">We will now dive into an example to demonstrate how we can use lambdas in C++ and explain details regarding lambda capturing. </span><span class="koboSpan" id="kobo.30.2">Let us process the example below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.31.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.32.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.33.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.34.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.35.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.36.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.37.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.38.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.39.1">&lt;algorithm&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.40.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.41.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.42.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.43.1">{
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.44.1">int</span></span><span class="koboSpan" id="kobo.45.1">, 4&gt; arr{</span><span class="hljs-number"><span class="koboSpan" id="kobo.46.1">5</span></span><span class="koboSpan" id="kobo.47.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.48.1">3</span></span><span class="koboSpan" id="kobo.49.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.50.1">4</span></span><span class="koboSpan" id="kobo.51.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.52.1">1</span></span><span class="koboSpan" id="kobo.53.1">};
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.54.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.55.1">auto</span></span><span class="koboSpan" id="kobo.56.1"> print_arr = [&amp;arr](</span><span class="hljs-type"><span class="koboSpan" id="kobo.57.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.58.1">char</span></span><span class="koboSpan" id="kobo.59.1">* message) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.60.1">printf</span></span><span class="koboSpan" id="kobo.61.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.62.1">"%s\r\n"</span></span><span class="koboSpan" id="kobo.63.1">, message);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.64.1">for</span></span><span class="koboSpan" id="kobo.65.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.66.1">auto</span></span><span class="koboSpan" id="kobo.67.1"> elem : arr) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.68.1">printf</span></span><span class="koboSpan" id="kobo.69.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.70.1">"%d, "</span></span><span class="koboSpan" id="kobo.71.1">, elem);
        }
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.72.1">printf</span></span><span class="koboSpan" id="kobo.73.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.74.1">"\r\n"</span></span><span class="koboSpan" id="kobo.75.1">);
    };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.76.1">print_arr</span></span><span class="koboSpan" id="kobo.77.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.78.1">"Unsorted array:"</span></span><span class="koboSpan" id="kobo.79.1">);
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.80.1">sort</span></span><span class="koboSpan" id="kobo.81.1">(arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.82.1">begin</span></span><span class="koboSpan" id="kobo.83.1">(), arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.84.1">end</span></span><span class="koboSpan" id="kobo.85.1">(), [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.86.1">int</span></span><span class="koboSpan" id="kobo.87.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.88.1">int</span></span><span class="koboSpan" id="kobo.89.1"> b) {
       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.90.1">return</span></span><span class="koboSpan" id="kobo.91.1"> a &lt; b;});
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.92.1">print_arr</span></span><span class="koboSpan" id="kobo.93.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.94.1">"Sorted in ascending order:"</span></span><span class="koboSpan" id="kobo.95.1">);
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.96.1">sort</span></span><span class="koboSpan" id="kobo.97.1">(arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.98.1">begin</span></span><span class="koboSpan" id="kobo.99.1">(), arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.100.1">end</span></span><span class="koboSpan" id="kobo.101.1">(), [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.102.1">int</span></span><span class="koboSpan" id="kobo.103.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.104.1">int</span></span><span class="koboSpan" id="kobo.105.1"> b) {
       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.106.1">return</span></span><span class="koboSpan" id="kobo.107.1"> a &gt; b;});
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.108.1">print_arr</span></span><span class="koboSpan" id="kobo.109.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.110.1">"Sorted in descending order:"</span></span><span class="koboSpan" id="kobo.111.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.112.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.113.1">0</span></span><span class="koboSpan" id="kobo.114.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.115.1">Running the </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.116.1">above example, we will get the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.117.1">Unsorted array:
5, 3, 4, 1,
Sorted in ascending order:
1, 3, 4, 5,
Sorted in descending order:
5, 4, 3, 1,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.118.1">What we see are outputs of the lambda </span><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">print_arr</span></code><span class="koboSpan" id="kobo.120.1"> used to print an array </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">arr</span></code><span class="koboSpan" id="kobo.122.1"> defined in the main function. </span><span class="koboSpan" id="kobo.122.2">Let’s go through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">print_arr</span></code><span class="koboSpan" id="kobo.124.1"> lambda in detail:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.125.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">[&amp;arr]</span></code><span class="koboSpan" id="kobo.127.1"> syntax captures the variable arr by reference from the surrounding scope. </span><span class="koboSpan" id="kobo.127.2">This means the lambda can access and use arr directly within its body.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.128.1">We can capture variables by value, or by reference if we prefix the name of a variable with </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">&amp;</span></code><span class="koboSpan" id="kobo.130.1"> as we did for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">print_arr</span></code><span class="koboSpan" id="kobo.132.1"> lambda.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.133.1">Capturing by reference </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">[&amp;arr]</span></code><span class="koboSpan" id="kobo.135.1"> allows the lambda to see any changes made to </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">arr</span></code><span class="koboSpan" id="kobo.137.1"> outside the lambda after its definition. </span><span class="koboSpan" id="kobo.137.2">If we captured by value, the lambda would have its own copy of </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">arr</span></code><span class="koboSpan" id="kobo.139.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.140.1">By defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">print_arr</span></code><span class="koboSpan" id="kobo.142.1"> as a lambda within </span><code class="inlineCode"><span class="koboSpan" id="kobo.143.1">main</span></code><span class="koboSpan" id="kobo.144.1">, we encapsulate the functionality of printing the array without needing to create a separate function. </span><span class="koboSpan" id="kobo.144.2">This keeps related code together and enhances readability.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.145.1">In the same example, we used </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.146.1">lambdas as predicate functions to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">std::sort</span></code><span class="koboSpan" id="kobo.148.1"> algorithm, to sort array </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">arr</span></code><span class="koboSpan" id="kobo.150.1"> first in ascending, then in descending order. </span><span class="koboSpan" id="kobo.150.2">We will go through this use case of lambdas in more detail:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.151.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">std::sort</span></code><span class="koboSpan" id="kobo.153.1"> algorithm rearranges the elements of </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">arr</span></code><span class="koboSpan" id="kobo.155.1"> based on the comparator provided.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.156.1">The lambda </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">[](int a, int b) { return a &lt; b; }</span></code><span class="koboSpan" id="kobo.158.1"> acts as a comparator function for </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">std::sort</span></code><span class="koboSpan" id="kobo.160.1">. </span><span class="koboSpan" id="kobo.160.2">It takes two integers and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">true</span></code><span class="koboSpan" id="kobo.162.1"> if the first is less than the second, which results in an ascending sort.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.163.1">The lambda </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">[](int a, int b) { return a &gt; b; }</span></code><span class="koboSpan" id="kobo.165.1"> returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">true</span></code><span class="koboSpan" id="kobo.167.1"> if the first integer is greater than the second, resulting in a descending sort.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.168.1">Defining the comparator directly at the call site of </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">std::sort</span></code><span class="koboSpan" id="kobo.170.1"> makes the code more concise. </span><span class="koboSpan" id="kobo.170.2">It becomes immediately clear how the array is being sorted without needing to look elsewhere in the code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">In the cases of using lambdas with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">std::sort</span></code><span class="koboSpan" id="kobo.173.1"> algorithm, both lambdas are small and simple, making it easy to deduce what they return. </span><span class="koboSpan" id="kobo.173.2">Keeping lambdas short and straightforward is considered a good practice as it improves readability and makes the intent of the code immediately clear to others. </span><span class="koboSpan" id="kobo.173.3">We can also specify the lambda return type explicitly as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.174.1">auto</span></span><span class="koboSpan" id="kobo.175.1"> greater_than = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.176.1">int</span></span><span class="koboSpan" id="kobo.177.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.178.1">int</span></span><span class="koboSpan" id="kobo.179.1"> b) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.180.1">bool</span></span><span class="koboSpan" id="kobo.181.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.182.1">return</span></span><span class="koboSpan" id="kobo.183.1"> a &gt; b;
    };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.184.1">Here, we explicitly </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.185.1">defined the return type. </span><span class="koboSpan" id="kobo.185.2">This is optional and can be used when we want to be explicit about the type that a lambda returns. </span><span class="koboSpan" id="kobo.185.3">Also, note that the capture clause of this lambda is empty square brackets </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">[]</span></code><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">This indicates that the lambda is not capturing any variables from the surrounding scope.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.188.1">When the lambda is capturing a variable by reference, it is important to note that this introduces lifetime dependency – meaning that the object that reference is bound to must exist when we call the lambda – else, we will use a so-called dangling reference, which is undefined behavior. </span><span class="koboSpan" id="kobo.188.2">This is especially a concern with asynchronous operations – that is, when a lambda is passed to a function and called later. </span><span class="koboSpan" id="kobo.188.3">Next, we will learn how to store lambdas using </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">std::function</span></code><span class="koboSpan" id="kobo.190.1"> to use them asynchronously.</span></p>
<h1 class="heading-1" id="_idParaDest-152"><span class="koboSpan" id="kobo.191.1">Storing lambdas using std::function</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">std::function</span></code><span class="koboSpan" id="kobo.193.1"> is a</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.194.1"> class template that allows us to store, copy, and</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.195.1"> invoke callable objects such as function pointers and lambdas. </span><span class="koboSpan" id="kobo.195.2">We will go through a simple code example to demonstrate this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.196.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.198.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.199.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.200.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.201.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.202.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.203.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.204.1">&lt;functional&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.205.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.206.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.207.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.208.1">{
    std::function&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.209.1">void</span></span><span class="koboSpan" id="kobo.210.1">()&gt; fun;
    fun = []() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.211.1">printf</span></span><span class="koboSpan" id="kobo.212.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.213.1">"This is a lambda!\r\n"</span></span><span class="koboSpan" id="kobo.214.1">);
    }; 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.215.1">fun</span></span><span class="koboSpan" id="kobo.216.1">();
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.217.1">uint32_t</span></span><span class="koboSpan" id="kobo.218.1"> reg = </span><span class="hljs-number"><span class="koboSpan" id="kobo.219.1">0x12345678</span></span><span class="koboSpan" id="kobo.220.1">;
    fun = [reg]() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.221.1">printf</span></span><span class="koboSpan" id="kobo.222.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.223.1">"Reg content 0x%8X\r\n"</span></span><span class="koboSpan" id="kobo.224.1">, reg);
    };
    reg = </span><span class="hljs-number"><span class="koboSpan" id="kobo.225.1">0</span></span><span class="koboSpan" id="kobo.226.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.227.1">fun</span></span><span class="koboSpan" id="kobo.228.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.229.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.230.1">0</span></span><span class="koboSpan" id="kobo.231.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.232.1">Let us go</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.233.1"> through the example:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.234.1">In </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.235.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">main</span></code><span class="koboSpan" id="kobo.237.1"> function, we first create an object fun of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">This specifies that </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">fun</span></code><span class="koboSpan" id="kobo.241.1"> can store any callable object that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">void</span></code><span class="koboSpan" id="kobo.243.1"> and takes no arguments. </span><span class="koboSpan" id="kobo.243.2">This includes function pointers, lambdas, or any object with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">operator()</span></code><span class="koboSpan" id="kobo.245.1"> that matches the signature.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.246.1"> We then assign a lambda to </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">fun</span></code><span class="koboSpan" id="kobo.248.1"> and invoke it, which prints the message “This is a lambda!” </span><span class="koboSpan" id="kobo.248.2">to the console.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.249.1">Next, we assigned another lambda to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">fun</span></code><span class="koboSpan" id="kobo.251.1"> object. </span><span class="koboSpan" id="kobo.251.2">This time the lambda captures the </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">uint32_t reg</span></code><span class="koboSpan" id="kobo.253.1"> by value from the surrounding scope and prints it. </span><span class="koboSpan" id="kobo.253.2">Capturing by value means the lambda makes its own copy of </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">reg</span></code><span class="koboSpan" id="kobo.255.1"> at the moment the lambda is defined.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.256.1">We change the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">reg</span></code><span class="koboSpan" id="kobo.258.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">0</span></code><span class="koboSpan" id="kobo.260.1"> before invoking the callable object stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">fun</span></code><span class="koboSpan" id="kobo.262.1"> to show it is being captured by value. </span><span class="koboSpan" id="kobo.262.2">Calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">fun</span></code><span class="koboSpan" id="kobo.264.1"> prints </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">Reg content 0x12345678</span></code><span class="koboSpan" id="kobo.266.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.267.1">Let’s </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.268.1">use </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">std::function</span></code><span class="koboSpan" id="kobo.270.1"> in a more interesting example, where we will use it to</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.271.1"> store a callback to a GPIO interrupt. </span><span class="koboSpan" id="kobo.271.2">The code is below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.272.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.274.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.275.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.276.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.277.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.278.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.279.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.280.1">&lt;functional&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.281.1">namespace</span></span><span class="koboSpan" id="kobo.282.1"> hal
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.283.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.284.1">gpio</span></span><span class="koboSpan" id="kobo.285.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.286.1">public</span></span><span class="koboSpan" id="kobo.287.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.288.1">gpio</span></span><span class="koboSpan" id="kobo.289.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.290.1">const</span></span><span class="koboSpan" id="kobo.291.1"> std::function&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.292.1">void</span></span><span class="koboSpan" id="kobo.293.1">()&gt; &amp; on_press) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">if</span></span><span class="koboSpan" id="kobo.295.1">(on_press) {
            on_press_ = on_press;
        }
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.296.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.297.1">execute_interrupt_handler</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.298.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.299.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.300.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.301.1">if</span></span><span class="koboSpan" id="kobo.302.1">(on_press_) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.303.1">on_press_</span></span><span class="koboSpan" id="kobo.304.1">();
        }
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">private</span></span><span class="koboSpan" id="kobo.306.1">:
    std::function&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.307.1">void</span></span><span class="koboSpan" id="kobo.308.1">()&gt; on_press_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.309.1">nullptr</span></span><span class="koboSpan" id="kobo.310.1">;
};
}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.311.1">// namespace hal</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.312.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.313.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.314.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.315.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.316.1">hal::gpio </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.317.1">button1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.318.1">([]() {</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.319.1">        printf(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.320.1">"Button1 pressed!\r\n"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.321.1">);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.322.1">    })</span></span><span class="koboSpan" id="kobo.323.1">;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.324.1">// invoke stored lambda</span></span><span class="koboSpan" id="kobo.325.1">
    button</span><span class="hljs-number"><span class="koboSpan" id="kobo.326.1">1.</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.327.1">execute_interrupt_handler</span></span><span class="koboSpan" id="kobo.328.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.330.1">0</span></span><span class="koboSpan" id="kobo.331.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.332.1">In the code above, we created a </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">hal::gpio</span></code><span class="koboSpan" id="kobo.334.1"> class that represents a GPIO:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.335.1">The class stores </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">std::function&lt;void()&gt; on_press_</span></code><span class="koboSpan" id="kobo.337.1">, which can hold any callable object like a lambda function. </span><span class="koboSpan" id="kobo.337.2">It is initialized to nullptr to indicate it holds no callable object.</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.338.1">It provides the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.340.1">, which checks if </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">on_press_</span></code><span class="koboSpan" id="kobo.342.1"> evaluates to true, that is, if it stores a callable object, and executes it if it does.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.343.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">main</span></code><span class="koboSpan" id="kobo.345.1"> function, we </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.346.1">create </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">button1</span></code><span class="koboSpan" id="kobo.348.1">, an object of </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.349.1">class </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">hal::button</span></code><span class="koboSpan" id="kobo.351.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.352.1">We provide the constructor with a simple lambda that prints Button1 pressed!.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.353.1">Next, we call the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.355.1">, which invokes the stored lambda and the program prints </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">Button1 pressed!</span></code><span class="koboSpan" id="kobo.357.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.358.1">In a real firmware, we would call the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.360.1"> from an interrupt service.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.361.1">The above code is an example of the application of the </span><strong class="keyWord"><span class="koboSpan" id="kobo.362.1">command pattern</span></strong><span class="koboSpan" id="kobo.363.1">, which is implemented in a simple and expressive way in C++ thanks to </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">std::function</span></code><span class="koboSpan" id="kobo.365.1"> and lambda expressions.</span></p>
<h2 class="heading-2" id="_idParaDest-153"><span class="koboSpan" id="kobo.366.1">The command pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.367.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.368.1">command pattern</span></strong><span class="koboSpan" id="kobo.369.1"> is a behavioral </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.370.1">design pattern used to capture a function call together with required arguments – allowing us to execute those functions with a delay.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.371.1">We will go through a canonical definition of the command pattern. </span><span class="koboSpan" id="kobo.371.2">Let us start with a UML diagram of the pattern and explain it afterward:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.372.1"><img alt="Figure 10.1 – Command pattern – UML diagram" src="../Images/B22402_10_01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.373.1">Figure 10</span></span><span class="koboSpan" id="kobo.374.1">.1 – Command pattern – UML diagram</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.375.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.376.1">.1</span></em><span class="koboSpan" id="kobo.377.1"> depicts a </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.378.1">UML diagram of the command pattern. </span><span class="koboSpan" id="kobo.378.2">We notice the following entities in the above diagram.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">command</span></code><span class="koboSpan" id="kobo.381.1"> interface with a virtual </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">execute</span></code><span class="koboSpan" id="kobo.383.1"> method, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">concrete_command</span></code><span class="koboSpan" id="kobo.385.1"> implementation of the interface.</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">receiver</span></code><span class="koboSpan" id="kobo.387.1">, stored by a reference in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">concrete_command</span></code><span class="koboSpan" id="kobo.389.1"> implementation. </span><span class="koboSpan" id="kobo.389.2">It performs an </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">action</span></code><span class="koboSpan" id="kobo.391.1"> that takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">params</span></code><span class="koboSpan" id="kobo.393.1"> as arguments.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.394.1">invoker</span></code><span class="koboSpan" id="kobo.395.1">, which stores a reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">command</span></code><span class="koboSpan" id="kobo.397.1"> interface and executes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">command</span></code><span class="koboSpan" id="kobo.399.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">client</span></code><span class="koboSpan" id="kobo.401.1">, which creates a </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">receiver</span></code><span class="koboSpan" id="kobo.403.1"> and passes it to the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">concrete_command</span></code><span class="koboSpan" id="kobo.405.1">. </span><span class="koboSpan" id="kobo.405.2">It passes a reference of a created </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">concrete_command</span></code><span class="koboSpan" id="kobo.407.1"> to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">invoker</span></code><span class="koboSpan" id="kobo.409.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.410.1">By using the command interface, we are able to make different concrete commands and provide them to invokers. </span><span class="koboSpan" id="kobo.410.2">Instead of the command interface and concrete commands, we can use class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">std::function</span></code><span class="koboSpan" id="kobo.412.1"> and lambda expressions for the same purpose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.413.1">In our previous example, we created the </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">hal::gpio</span></code><span class="koboSpan" id="kobo.415.1"> class as an invoker from the command pattern. </span><span class="koboSpan" id="kobo.415.2">It has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.417.1"> as a member – an equivalent to a command interface. </span><span class="koboSpan" id="kobo.417.2">A concrete command is a lambda expression that we stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.419.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">receiver</span></code><span class="koboSpan" id="kobo.421.1"> is the lambda body – the </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">printf</span></code><span class="koboSpan" id="kobo.423.1"> function in our example – and </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">client</span></code><span class="koboSpan" id="kobo.425.1"> is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">main</span></code><span class="koboSpan" id="kobo.427.1"> function. </span><span class="koboSpan" id="kobo.427.2">The</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.428.1"> client creates a receiver (</span><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">hal::gpio button1</span></code><span class="koboSpan" id="kobo.430.1">) and provides it with a concrete command (lambda expression). </span><span class="koboSpan" id="kobo.430.2">We call </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.432.1"> on the invoker directly from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">main</span></code><span class="koboSpan" id="kobo.434.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.435.1">Next, we will expand this example to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.437.1"> from the interrupt handler on the STM32 platform. </span><span class="koboSpan" id="kobo.437.2">The design will support interrupts from multiple pins. </span><span class="koboSpan" id="kobo.437.3">We will introduce the </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">gpio_interrupt_manager</span></code><span class="koboSpan" id="kobo.439.1"> entity, which will be responsible for registering invokers and calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.441.1"> method on them.</span></p>
<h2 class="heading-2" id="_idParaDest-154"><span class="koboSpan" id="kobo.442.1">GPIO interrupt manager</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.443.1">We want to utilize </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.444.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">std::function</span></code><span class="koboSpan" id="kobo.446.1"> class template and lambda expressions to enable an expressive way of creating GPIO interrupt handlers in firmware as in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.447.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.448.1"> hal::gpio_stm32&lt;hal::port_a&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.449.1">button1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.450.1">(hal::pin::p4, [](){</span></span>
<span class="hljs-keyword"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.451.1">printf(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.452.1">"Button1 pressed!\r\n"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.453.1">);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.454.1">})</span></span><span class="koboSpan" id="kobo.455.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.456.1">In the code above, we are creating an object </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">button1</span></code><span class="koboSpan" id="kobo.458.1"> from the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">hal::gpio_stm32</span></code><span class="koboSpan" id="kobo.460.1"> parametrized with </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">hal::port_a</span></code><span class="koboSpan" id="kobo.462.1">. </span><span class="koboSpan" id="kobo.462.2">We are providing a constructor with </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">hal::pin::p4</span></code><span class="koboSpan" id="kobo.464.1"> and a lambda expression that will be executed on interrupt. </span><span class="koboSpan" id="kobo.464.2">This is a goal, an expressive interface for writing interrupt handlers that also allows us to capture surrounding variables if needed, thanks to lambda expressions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.465.1">From the code above, we can see both the pin and the port we are configuring and the callback that will be executed on the interrupt. </span><span class="koboSpan" id="kobo.465.2">The mechanism that we will create will handle interrupt handler registration to a central entity we will name </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">gpio_interrupt_manager</span></code><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">Before we proceed with the design, please run the full example in Renode using the instructions below.</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.468.1">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">Chapter10/lambdas</span></code><span class="koboSpan" id="kobo.470.1"> project as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.471.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.472.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.473.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.474.1">cd</span></span><span class="language-bash"><span class="koboSpan" id="kobo.475.1"> Chapter10/lambdas</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.476.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.477.1">cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_std_function_command_pattern.cpp</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.478.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.479.1">cmake --build build --target run_in_renode</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.480.1">In Renode, we can simulate button press and release using the following command for </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">button1</span></code><span class="koboSpan" id="kobo.482.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">button2</span></code><span class="koboSpan" id="kobo.484.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.485.1">gpioPortA.button1 PressAndRelease
gpioPortA.button2 PressAndRelease
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.486.1">Entering the </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.487.1">above command should result in the following output in the Renode console:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.488.1">Button1 pressed!
</span><span class="koboSpan" id="kobo.488.2">Button2 pressed!
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.489.1">As you can see, actions provided in lambdas are invoked by interrupts generated by buttons. </span><span class="koboSpan" id="kobo.489.2">Let us go through the UML diagram of this example to understand how it works:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.490.1"><img alt="Figure 10.2 – GPIO Interrupt manager UML diagram" src="../Images/B22402_10_02.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.491.1">Figure 10</span></span><span class="koboSpan" id="kobo.492.1">.2 – GPIO Interrupt manager UML diagram</span></p>
<p class="normal"><span class="koboSpan" id="kobo.493.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.494.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.495.1">.2</span></em><span class="koboSpan" id="kobo.496.1">, we see the </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.497.1">UML diagram of the GPIO interrupt manager. </span><span class="koboSpan" id="kobo.497.2">It is based on the command pattern. </span><span class="koboSpan" id="kobo.497.3">We are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.499.1"> in place of the command interface and lambda expression for concrete commands. </span><span class="koboSpan" id="kobo.499.2">The invoker is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">hal::gpio</span></code><span class="koboSpan" id="kobo.501.1"> abstract class, which stores the lambda in the member </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">on_press</span></code><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">It registers itself with </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">gpio_interrupt_manager</span></code><span class="koboSpan" id="kobo.505.1"> in the constructor as we can see from the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.506.1">gpio::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.507.1">gpio</span></span><span class="koboSpan" id="kobo.508.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.509.1">const</span></span><span class="koboSpan" id="kobo.510.1"> std::function&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.511.1">void</span></span><span class="koboSpan" id="kobo.512.1">()&gt; &amp; on_press) {
   on_press_ = on_press;
   gpio_interrupt_manager::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.513.1">register_interrupt_handler</span></span><span class="koboSpan" id="kobo.514.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.515.1">this</span></span><span class="koboSpan" id="kobo.516.1">)
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">gpio_interrupt_manager</span></code><span class="koboSpan" id="kobo.518.1"> is a simple struct. </span><span class="koboSpan" id="kobo.518.2">It serves as a central entity for the interrupt handling mechanism with the following features:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.519.1">It contains an array of hal::gpio pointers – </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">std::array&lt;gpio*, c_gpio_handlers_num&gt; gpio_handlers</span></code><span class="koboSpan" id="kobo.521.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.522.1">It provides a static method to register a </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">hal::gpio</span></code><span class="koboSpan" id="kobo.524.1"> pointer – </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">void register_interrupt_handler(gpio * pin)</span></code><span class="koboSpan" id="kobo.526.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.527.1">It provides a static method that executes interrupt handlers stored in the array – </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">void execute_interrupt_handlers()</span></code><span class="koboSpan" id="kobo.529.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.530.1">The method </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">execute_interrupt_handlers</span></code><span class="koboSpan" id="kobo.532.1"> is called from the interrupt service routine as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.533.1">extern</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.534.1">"C"</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.535.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.536.1">EXTI4_15_IRQHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.537.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.538.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.539.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.540.1">{
    gpio_interrupt_manager::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.541.1">execute_interrupt_handlers</span></span><span class="koboSpan" id="kobo.542.1">();
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">EXTI4_15_IRQHandler</span></code><span class="koboSpan" id="kobo.544.1"> is an</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.545.1"> interrupt service routine defined in the vector table (defined in platform/startup_stm32f072xb.s). </span><span class="koboSpan" id="kobo.545.2">That’s why we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">"C"</span></code><span class="koboSpan" id="kobo.547.1"> language linkage and implemented it as a global function. </span><span class="koboSpan" id="kobo.547.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.548.1">execute_interrupt_handlers</span></code><span class="koboSpan" id="kobo.549.1"> method loops through the array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">hal::gpio</span></code><span class="koboSpan" id="kobo.551.1"> pointers and calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.553.1"> method on them as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.554.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.555.1">gpio_interrupt_manager::execute_interrupt_handlers</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.556.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.557.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.558.1">for</span></span><span class="koboSpan" id="kobo.559.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.560.1">size_t</span></span><span class="koboSpan" id="kobo.561.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.562.1">0</span></span><span class="koboSpan" id="kobo.563.1">; i &lt; w_idx; i++) {
        gpio_handlers[i]-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.564.1">execute_interrupt_handler</span></span><span class="koboSpan" id="kobo.565.1">();
    }
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">hal::gpio</span></code><span class="koboSpan" id="kobo.567.1"> is an </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.568.1">abstract class with the following features:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.569.1">It implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.571.1"> method used by </span><code class="inlineCode"><span class="koboSpan" id="kobo.572.1">gpio_interrupt_manager</span></code><span class="koboSpan" id="kobo.573.1"> as we saw earlier.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.574.1">It defines the pure virtual method </span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">[[nodiscard]] virtual bool is_interrupt_generated() const = 0</span></code><span class="koboSpan" id="kobo.576.1">. </span><span class="koboSpan" id="kobo.576.2">This method needs to be overridden by the derived class that implements platform-specific functionality.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.577.1">It defines the virtual method </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">virtual void clear_interrupt_flag() const = 0</span></code><span class="koboSpan" id="kobo.579.1">. </span><span class="koboSpan" id="kobo.579.2">This method needs to be overridden by the derived class that implements platform-specific functionality.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.580.1">The code for </span><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.582.1"> is shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.583.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.584.1">gpio::execute_interrupt_handler</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.585.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.586.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.587.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">if</span></span><span class="koboSpan" id="kobo.589.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.590.1">is_interrupt_generated</span></span><span class="koboSpan" id="kobo.591.1">()){
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.592.1">clear_interrupt_flag</span></span><span class="koboSpan" id="kobo.593.1">();
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.594.1">if</span></span><span class="koboSpan" id="kobo.595.1">(on_press_) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.596.1">on_press_</span></span><span class="koboSpan" id="kobo.597.1">();
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.598.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">execute_interrupt_handler</span></code><span class="koboSpan" id="kobo.600.1"> method implements the following functionality:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.601.1">It checks if the interrupt should be handled by the current object using the virtual method </span><code class="inlineCode"><span class="koboSpan" id="kobo.602.1">is_interrupt_generated</span></code><span class="koboSpan" id="kobo.603.1">. </span><span class="koboSpan" id="kobo.603.2">This method must be overridden by a derived class. </span><span class="koboSpan" id="kobo.603.3">The derived class has the data needed to determine if the generated interrupt needs to be addressed by the current object.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.604.1">If the interrupt should be addressed by the current object, the interrupt flag is cleared using the virtual method </span><code class="inlineCode"><span class="koboSpan" id="kobo.605.1">clear_interrupt_flag</span></code><span class="koboSpan" id="kobo.606.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">on_press_</span></code><span class="koboSpan" id="kobo.608.1"> is called if it stores a callable object.</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">hal::gpio_stm32</span></code><span class="koboSpan" id="kobo.610.1"> is a </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.611.1">class template derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">hal::gpio</span></code><span class="koboSpan" id="kobo.613.1">. </span><span class="koboSpan" id="kobo.613.2">We instantiate it with port as a parameter, and it implements platform-specific operations such as GPIO initialization using the vendor-provided C HAL library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.614.1">In the example, we instantiated </span><code class="inlineCode"><span class="koboSpan" id="kobo.615.1">hal::gpio_stm32</span></code><span class="koboSpan" id="kobo.616.1"> with struct </span><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">port_a</span></code><span class="koboSpan" id="kobo.618.1">, which contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">void init_clock()</span></code><span class="koboSpan" id="kobo.620.1"> static function. </span><span class="koboSpan" id="kobo.620.2">This allows us to call a static method on the template parameter, instead of defining port as an </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">enum</span></code><span class="koboSpan" id="kobo.622.1">, checking it in runtime, and calling a port-specific function for clock initialization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.623.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">hal::gpio_stm32</span></code><span class="koboSpan" id="kobo.625.1"> class template uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">hal::gpio</span></code><span class="koboSpan" id="kobo.627.1"> as a base class:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.628.1">The constructor takes an enum pin and const reference to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.629.1">std::function&lt;void()&gt;</span></code><span class="koboSpan" id="kobo.630.1"> object that we use to initialize the base class in the initialization list.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.631.1">[[nodiscard]] bool is_interrupt_generated() const</span></code><span class="koboSpan" id="kobo.632.1"> – the overridden method uses vendor-provided C HAL to determine if the interrupt was generated by the pin provided to the object through the constructor.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">void clear_interrupt_flag() const</span></code><span class="koboSpan" id="kobo.634.1"> – the overridden method implements platform-specific code used to clear the interrupt flag.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.635.1">This sums up the implementation of the GPIO interrupt manager and explains the design. </span><span class="koboSpan" id="kobo.635.2">You can refer to other details of the implementation in the source code provided in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.636.1">Chapter10/lambdas</span></code><span class="koboSpan" id="kobo.637.1"> folder of the book’s GitHub repo.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.638.1">Next, we will discuss the implications of using </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">std::function</span></code><span class="koboSpan" id="kobo.640.1"> on dynamic memory allocation.</span></p>
<h1 class="heading-1" id="_idParaDest-155"><span class="koboSpan" id="kobo.641.1">std::function and dynamic memory allocation</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">std::function</span></code><span class="koboSpan" id="kobo.643.1"> needs to</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.644.1"> store all variables and references that a lambda captures. </span><span class="koboSpan" id="kobo.644.2">This behavior is implementation-defined, and implementations usually use heap, which is dynamic memory allocation to store large amounts of variables. </span><span class="koboSpan" id="kobo.644.3">If the captured data is small (on some platforms, 16 bytes), it will be stored on the stack. </span><span class="koboSpan" id="kobo.644.4">This is called small object optimization. </span><span class="koboSpan" id="kobo.644.5">To demonstrate the behavior of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">std::function</span></code><span class="koboSpan" id="kobo.646.1"> class template when capturing data, we will go through the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.647.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.648.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.649.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.650.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.652.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.653.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.655.1">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.656.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.657.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.658.1">&lt;functional&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.659.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.660.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.662.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.663.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.664.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.665.1"> count)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.666.1">{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.667.1">printf</span></span><span class="koboSpan" id="kobo.668.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">"%s, size = %ld\r\n"</span></span><span class="koboSpan" id="kobo.670.1">, __PRETTY_FUNCTION__, count);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.671.1">return</span></span><span class="koboSpan" id="kobo.672.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.673.1">malloc</span></span><span class="koboSpan" id="kobo.674.1">(count);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.675.1">void</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.676.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.677.1">delete</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.678.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.679.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.680.1"> *ptr)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.681.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.682.1">{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.683.1">printf</span></span><span class="koboSpan" id="kobo.684.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.685.1">"%s\r\n"</span></span><span class="koboSpan" id="kobo.686.1">, __PRETTY_FUNCTION__);
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.687.1">free</span></span><span class="koboSpan" id="kobo.688.1">(ptr);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.689.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.690.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.691.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.692.1">{
    std::function&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.693.1">void</span></span><span class="koboSpan" id="kobo.694.1">()&gt; func;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.695.1">auto</span></span><span class="koboSpan" id="kobo.696.1"> arr = []() {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.697.1">constexpr</span></span><span class="koboSpan" id="kobo.698.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.699.1">size_t</span></span><span class="koboSpan" id="kobo.700.1"> c_array_size = </span><span class="hljs-number"><span class="koboSpan" id="kobo.701.1">6</span></span><span class="koboSpan" id="kobo.702.1">;
        std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.703.1">int</span></span><span class="koboSpan" id="kobo.704.1">, c_array_size&gt; ar{};
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.705.1">for</span></span><span class="koboSpan" id="kobo.706.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.707.1">int</span></span><span class="koboSpan" id="kobo.708.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.709.1">0</span></span><span class="koboSpan" id="kobo.710.1">; i &lt; ar.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.711.1">size</span></span><span class="koboSpan" id="kobo.712.1">(); i++) {
            ar[i] = i;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.713.1">return</span></span><span class="koboSpan" id="kobo.714.1"> ar;
    }();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.715.1">auto</span></span><span class="koboSpan" id="kobo.716.1"> array_printer = [arr]() {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">for</span></span><span class="koboSpan" id="kobo.718.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.719.1">int</span></span><span class="koboSpan" id="kobo.720.1"> elem: arr) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.721.1">printf</span></span><span class="koboSpan" id="kobo.722.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.723.1">"%d, "</span></span><span class="koboSpan" id="kobo.724.1">, elem);
        }
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.725.1">printf</span></span><span class="koboSpan" id="kobo.726.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.727.1">"\r\n"</span></span><span class="koboSpan" id="kobo.728.1">);
    };
    func = array_printer;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.729.1">// invoke stored lambda</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.730.1">func</span></span><span class="koboSpan" id="kobo.731.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.732.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.733.1">0</span></span><span class="koboSpan" id="kobo.734.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.735.1">In the above example, we have overridden the operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">new</span></code><span class="koboSpan" id="kobo.737.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">delete</span></code><span class="koboSpan" id="kobo.739.1"> to show that storing a lambda that captures an array of 6 integers will invoke dynamic memory allocation. </span><span class="koboSpan" id="kobo.739.2">If you run the above </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.740.1">example in Compiler Explorer using </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">x86-64 GCC 14.2</span></code><span class="koboSpan" id="kobo.742.1">, you will see the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.743.1">void* operator new(std::size_t), size = 24
0, 1, 2, 3, 4,
void operator delete(void*)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.744.1">This example also demonstrates the initialization of variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.745.1">arr</span></code><span class="koboSpan" id="kobo.746.1"> by using a lambda to generate members of the array. </span><span class="koboSpan" id="kobo.746.2">If you change </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">constexpr std::size_t c_array_size</span></code><span class="koboSpan" id="kobo.748.1"> to 4, you will notice that the operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.749.1">new</span></code><span class="koboSpan" id="kobo.750.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">delete</span></code><span class="koboSpan" id="kobo.752.1"> are no longer invoked, meaning that, in this case, the captured data is stored on the stack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.753.1">To get around this problem, we can assign </span><code class="inlineCode"><span class="koboSpan" id="kobo.754.1">std::reference_wrapper</span></code><span class="koboSpan" id="kobo.755.1"> of a lambda object to </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">std::function&lt;void()&gt; fun</span></code><span class="koboSpan" id="kobo.757.1"> instead of the object itself as in the following line of code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.758.1">    func = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.759.1">ref</span></span><span class="koboSpan" id="kobo.760.1">(array_printer);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.761.1">This will make the </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">std::function</span></code><span class="koboSpan" id="kobo.763.1"> object use a reference wrapper to the lambda object, instead of copying it and storing all the variables that lambda is capturing. </span><span class="koboSpan" id="kobo.763.2">Using this approach, we must take care of the lambda object lifetime, meaning that if it goes out of scope and we try to invoke it through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">std::function</span></code><span class="koboSpan" id="kobo.765.1"> object, we will end up with undefined behavior of the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.766.1">We can also use plain function pointers to store lambdas, but only if they don’t capture anything from the surrounding scope, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.767.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.768.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.769.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.770.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.771.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.772.1">&lt;functional&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.773.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.774.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.775.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.776.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.777.1">void</span></span><span class="koboSpan" id="kobo.778.1">(*fun)(</span><span class="hljs-type"><span class="koboSpan" id="kobo.779.1">void</span></span><span class="koboSpan" id="kobo.780.1">);
    fun = []() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.781.1">printf</span></span><span class="koboSpan" id="kobo.782.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.783.1">"Lambda!\r\n"</span></span><span class="koboSpan" id="kobo.784.1">);
    };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.785.1">fun</span></span><span class="koboSpan" id="kobo.786.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.787.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.788.1">0</span></span><span class="koboSpan" id="kobo.789.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.790.1">In the above</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.791.1"> example, we assign the lambda to a function pointer, making it a possible alternative to storing lambdas to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.792.1">std::function</span></code><span class="koboSpan" id="kobo.793.1"> class template in certain applications. </span><span class="koboSpan" id="kobo.793.2">This also makes it possible to pass non-capturing lambdas to C functions that expect function pointers.</span></p>
<h1 class="heading-1" id="_idParaDest-156"><span class="koboSpan" id="kobo.794.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.795.1">Lambda expressions and </span><code class="inlineCode"><span class="koboSpan" id="kobo.796.1">std::function</span></code><span class="koboSpan" id="kobo.797.1"> are powerful modern C++ tools that allow us to write expressive code and implement design patterns such as command patterns in an elegant way. </span><span class="koboSpan" id="kobo.797.2">We learned about different ways to capture data from the surrounding scope – by value or a reference. </span><span class="koboSpan" id="kobo.797.3">We also went through the command pattern design pattern and learned how to apply it to a GPIO interrupt manager.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.798.1">In the next chapter, we will go through compile-time computation in C++.</span></p>
</div>
</body></html>