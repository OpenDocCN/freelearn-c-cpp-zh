<html><head></head><body>
		<div><h1 id="_idParaDest-123" class="chapter-number" lang="en-GB"><a id="_idTextAnchor131"/><a id="_idTextAnchor132"/>13</h1>
			<h1 id="_idParaDest-124" lang="en-GB"><a id="_idTextAnchor133"/>How to Test Floating-Point and Custom Values</h1>
			<p lang="en-GB">We first encountered the need to test floating-point values in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>, <em class="italic" lang="">Adding More Confirm Types</em>, and created a simple solution that would let us compare floating-point values within a margin of error. We need the small margin because floating-point values that are close and might even look identical when displayed are almost always not exactly equal. These small differences make it hard to verify test results.</p>
			<p lang="en-GB">The main topics in this chapter are as follows:</p>
			<ul>
				<li lang="en-GB">More precise floating-point comparisons</li>
				<li lang="en-GB">Adding floating-point Hamcrest matchers</li>
				<li lang="en-GB">Writing custom Hamcrest matchers</li>
			</ul>
			<p lang="en-GB">We’re going to improve the simple solution developed earlier into a much better way to compare floating-point values that is more precise and works for both small and big values. We’ll use the better comparison for both the earlier classical-style confirmations and the new Hamcrest-style confirmations.</p>
			<p lang="en-GB">You’ll also learn how to create your own Hamcrest matchers in this chapter. We’ll be creating a new matcher to test for inequality instead of always testing for equality, and you’ll see how to contain one matcher inside another so that you can better reuse a matcher without needing to duplicate all the matcher template specializations.</p>
			<p lang="en-GB">Finally, you’ll learn how to create another custom simple matcher that will be slightly different than the other matchers so far because the new matcher will not need an expected value.</p>
			<h1 id="_idParaDest-125" lang="en-GB"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 20 or later compiler and standard library. The code is based on and continues enhancing the testing library from <em class="italic" lang="">Part 1</em> of this book, <em class="italic" lang="">Testing MVP</em>.</p>
			<p lang="en-GB">You can find all the code for this chapter in the following GitHub repository:</p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP&#13;">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a></p>
			<h1 id="_idParaDest-126" lang="en-GB"><a id="_idTextAnchor135"/>More precise floating-point comparisons</h1>
			<p lang="en-GB">Whenever improvements<a id="_idIndexMarker490"/> are needed, one of the first things to look for is a way to measure the current design. Back in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>,<em class="italic" lang=""> Adding More Confirm Types</em>, we examined floating-point numbers and I explained that comparing any floating-point type value—float, double, or long double—directly with another floating-point value is a bad idea. The comparison is too sensitive to small rounding errors and will usually result in the two values comparing not equal.</p>
			<p lang="en-GB">In <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>, I showed you how to add a small margin to the comparison so that an accumulation of errors would not throw off the comparison as long as the two numbers being compared were close enough in value to each other. In other words, two values can compare equal as long as they are close enough to each other.</p>
			<p lang="en-GB">But what margin should be used? We simply picked some small numbers, and that solution worked. We’re going to improve that solution. And now that you’re becoming familiar with <code>Hamcrest.cpp</code>.</p>
			<p lang="en-GB">The first function will convert a floating-point value into a fraction by dividing by a constant. We’ll divide by <code>10</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
T calculateFraction (T input)
{
    T denominator {10};
    return input / denominator;
}</pre>
			<p lang="en-GB">This is a template, so it will work for float, double, and long double types. The intent is for the input to be a whole number, and this function will turn the number into tenths. Remember from <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a> that tenths don’t have exact representations in binary. There will be a slight error introduced but not much because we only do one division calculation.</p>
			<p lang="en-GB">We’ll need another function that will generate bigger margins of error by doing more work, like this function:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
T accumulateError (T input)
{
    // First add many small amounts.
    T partialAmount {0.1};
    for (int i = 0; i &lt; 10; ++i)
    {
        input += partialAmount;
    }
    // Then subtract to get back to the original.
    T wholeAmount {1};
    input -= wholeAmount;
    return input;
}</pre>
			<p lang="en-GB">This function adds <code>1</code> and then <a id="_idIndexMarker492"/>subtracts <code>1</code>, so the input should remain unchanged. But because we add many small amounts that will all equal <code>1</code>, the function introduces many errors during the calculations. The result that gets returned should be close to the original <code>input</code> but not the same.</p>
			<p lang="en-GB">The last helper function will call the first two functions many times for many different values and count how many times the results are equal. The function looks like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
int performComparisons (int totalCount)
{
    int passCount {0};
    for (int i = 0; i &lt; totalCount; ++i)
    {
        T expected = static_cast&lt;T&gt;(i);
        expected = calculateFraction(expected);
        T actual = accumulateError(expected);
        if (actual == expected)
        {
            ++passCount;
        }
    }
    return passCount;
}</pre>
			<p lang="en-GB">The function uses the fraction as the <code>expected</code> value since it should have the fewest errors. The <code>expected</code> value is compared with the <code>actual</code> value, which we get from accumulating many small errors. The two values should be close but not exactly equal. They should be close enough to be counted as equal, though.</p>
			<p lang="en-GB">Who defines what is close<a id="_idIndexMarker493"/> enough? That’s really up to you to decide. The tests we’re creating in this book might be allowing more errors than your application can tolerate. You’ll understand after reading this section how to modify your code if you need more or less tolerance. There is no right answer for how to compare floating-point values that will work for all applications. The best you can do is to be aware of your own needs and adapt the code to fit those needs.</p>
			<p lang="en-GB">The <code>performComparisons</code> function also uses the <code>==</code> operator without any type of margin. The results should have a lot of unequal results. But how many? Let’s write a test to find out!</p>
			<p lang="en-GB">Add this test to the end of <code>Hamcrest.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test many float comparisons")
{
    int totalCount {1'000};
    int passCount = performComparisons&lt;float&gt;(totalCount);
    CONFIRM_THAT(passCount, Equals(totalCount));
}</pre>
			<p lang="en-GB">The test will cycle through <code>1,000</code> values, turning each one into tenths, introducing errors, and counting how many compared equal. The results are really bad:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test many float comparisons</strong>
<strong class="bold" lang="">Failed confirm on line 125</strong>
<strong class="bold" lang="">    Expected: 1000</strong>
<strong class="bold" lang="">    Actual  : 4</strong></pre>
			<p lang="en-GB">Only four values were close enough to be considered equal with the standard equality operator. You might get slightly different results depending on your computer and your compiler. If you do get different results, then that should be more evidence about how unreliable floating-point comparisons are. How about double and long double types? Add these two tests to find out:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test many double comparisons")
{
    int totalCount {1'000};
    int passCount = performComparisons&lt;double&gt;(totalCount);
    CONFIRM_THAT(passCount, Equals(totalCount));
}
TEST("Test many long double comparisons")
{
    int totalCount {1'000};
    int passCount = performComparisons&lt;long                     double&gt;(totalCount);
    CONFIRM_THAT(passCount, Equals(totalCount));
}</pre>
			<p lang="en-GB">The results are just as bad <a id="_idIndexMarker494"/>and look like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test many double comparisons</strong>
<strong class="bold" lang="">Failed confirm on line 132</strong>
<strong class="bold" lang="">    Expected: 1000</strong>
<strong class="bold" lang="">    Actual  : 4</strong>
<strong class="bold" lang="">------- Test: Test many long double comparisons</strong>
<strong class="bold" lang="">Failed confirm on line 139</strong>
<strong class="bold" lang="">    Expected: 1000</strong>
<strong class="bold" lang="">    Actual  : 0</strong></pre>
			<p lang="en-GB">Let’s add a margin to the equality comparison to see how much better the comparisons become. We’ll start with the values used in the existing <code>confirm</code> overloads in <code>Test.h</code>. One of the overloads looks like this:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    float expected,
    float actual,
    int line)
{
    if (actual &lt; (expected - 0.0001f) ||
        actual &gt; (expected + 0.0001f))
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">The value we are interested in is the hardcoded literal floating-point value. In this case, it’s <code>0.0001f</code>. All we need to do is create three more helper functions that return these values. Note that the double and long double overloads have a different value than the float type. Place these three helper functions in <code>Hamcrest.cpp</code>, right before the <code>performComparisons</code> function, like this:</p>
			<pre class="source-code" lang="en-GB">
constexpr float getMargin (float)
{
    return 0.0001f;
}
constexpr double getMargin (double)
{
    return 0.000001;
}
constexpr long double getMargin (long double)
{
    return 0.000001L;
}</pre>
			<p lang="en-GB">These three helper functions will let us customize the margin for each type. They each take a floating-point type <a id="_idIndexMarker495"/>parameter that is only used to determine which function to call. We don’t actually need or use the parameter value passed to the function. We’ll call these helper functions from within the <code>performComparisons</code> template, which will know the type to be used based on how the template was constructed.</p>
			<p lang="en-GB">We’re also going to slightly change how we compare with a margin. Here’s an example of how the confirm functions compare:</p>
			<pre class="source-code" lang="en-GB">
    if (actual &lt; (expected - 0.0001f) ||
        actual &gt; (expected + 0.0001f))</pre>
			<p lang="en-GB">Instead of this, we’re going to subtract the <code>expected</code> value from the <code>actual</code> value and then compare the absolute value of that subtraction result with the margin. We need to include <code>cmath</code> at the top of <code>Hamcrest.cpp</code> for the <code>abs</code> function, and we’re going to need <code>limits</code> soon also, like this:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
#include &lt;cmath&gt;
#include &lt;limits&gt;</pre>
			<p lang="en-GB">And now, we can change the <code>performComparisons</code> function to use the margin, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
int performComparisons (int totalCount)
{
    int passCount {0};
    for (int i = 0; i &lt; totalCount; ++i)
    {
        T expected = static_cast&lt;T&gt;(i);
        expected = calculateFraction(expected);
        T actual = accumulateError(expected);
        if (std::abs(actual - expected) &lt; getMargin(actual))
        {
            ++passCount;
        }
    }
    return passCount;
}</pre>
			<p lang="en-GB">After making these changes, all the<a id="_idIndexMarker496"/> tests pass, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test many float comparisons</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test many double comparisons</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test many long double comparisons</strong>
<strong class="bold" lang="">Passed</strong></pre>
			<p lang="en-GB">This means that all <code>1,000</code> values are now matching within a small margin of error. This is the same solution explained in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>. We should be good, right? Not quite.</p>
			<p lang="en-GB">The problem is that the margin value is quite big for small numbers and too small for big numbers. All the tests are passing, but that’s just because we have a margin that’s big enough to let a lot of comparisons be treated as equal.</p>
			<p lang="en-GB">To see this, let’s refactor the comparison out of the <code>performComparisons</code> function so that the check is in its own function, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
bool compareEq (T lhs, T rhs)
{
    return std::abs(lhs - rhs) &lt; getMargin(lhs);
}
template &lt;typename T&gt;
int performComparisons (int totalCount)
{
    int passCount {0};
    for (int i = 0; i &lt; totalCount; ++i)
    {
        T expected = static_cast&lt;T&gt;(i);
        expected = calculateFraction(expected);
        T actual = accumulateError(expected);
        if (compareEq(actual, expected))
        {
            ++passCount;
        }
    }
    return passCount;
}</pre>
			<p lang="en-GB">And then we can write a couple<a id="_idIndexMarker497"/> tests to call <code>compareEq</code> directly, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test small float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    bool result = compareEq(0.000001f, 0.000002f);
    CONFIRM_FALSE(result);
}
TEST("Test large float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    bool result = compareEq(9'999.0f, 9'999.001f);
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The test for small float values compares two numbers that are obviously different, yet the comparison function will consider them equal and the test fails. The fixed margin considers any float values within <code>0.0001f</code> to be equal. We want the two values to compare not equal, but our margin is big enough that they are considered to be equal.</p>
			<p lang="en-GB">What is the <em class="italic" lang="">epsilon</em> value that the comment refers to? We’ll start using the actual epsilon values in just a moment, and this is why I suggested that you include <code>limits</code>. Floating-point numbers have a concept called epsilon, which is a value defined in <code>limits</code> for each floating-point type. The<a id="_idIndexMarker498"/> epsilon value represents the smallest distance between adjacent floating-point values for values between 1.0 and 2.0. Remember that floating-point values can’t represent every possible fractional number, so there are gaps between the numbers that can be represented.</p>
			<p lang="en-GB">You can see the same thing<a id="_idIndexMarker499"/> yourself if you write down numbers with only a fixed number of decimal places on paper. Let’s say that you limit yourself to only using two digits after the decimal point. You could write <code>1.00</code> and <code>1.01</code> and <code>1.02</code>. Those are adjacent values. In fact, <code>1.00</code> and <code>1.02</code> are the closest numbers you can represent to <code>1.01</code> by using only two digits after the decimal place. What about a number such as <code>1.011</code>? It’s definitely closer to <code>1.01</code> than <code>1.02</code> but we can’t write <code>1.011</code> because it needs three digits after the decimal point. The epsilon value for our experiment is <code>0.01</code>. Floating-point numbers have a similar problem except that the value of epsilon is smaller and not a simple value such as <code>0.01</code>.</p>
			<p lang="en-GB">Another complication is that the distance between adjacent floating-point numbers increases as the numbers get larger, and the distance decreases as the numbers get smaller. The test for small float values uses small values, but the values are much bigger than epsilon. Because the numbers are much bigger than epsilon, we want the test to fail. The test passes because our fixed margin is even bigger than epsilon.</p>
			<p lang="en-GB">The test for large float values also fails. It uses two values that are different by <code>0.001f</code>, which would be a really big difference if we were comparing <code>1.0f</code> with <code>1.001f</code>. At small values, a difference of <code>0.001f</code> would be enough to cause the values to compare not equal. But we’re not dealing with small values—we’re dealing with values that are almost 10,000! We now want the larger values to be considered equal because the fractional part makes up a smaller percentage of the larger numbers. The test fails because our fixed margin doesn’t consider that the values are larger and only looks at the difference, which is greater than the fixed margin allows.</p>
			<p lang="en-GB">We can also test the other floating-point types. Add these two similar tests for double right after the two tests added for small and large float values, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test small double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    bool result = compareEq(0.000000000000001,                   0.000000000000002);
    CONFIRM_FALSE(result);
}
TEST("Test large double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    bool result = compareEq(1'500'000'000'000.0,                   1'500'000'000'000.0003);
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">For the double type, we have a <a id="_idIndexMarker500"/>different epsilon value that’s much smaller than the epsilon for floats, and we also have many more significant digits to work with, so we can use numbers with more digits. We were limited to only about 7 digits when working with floats. With doubles, we can use numbers with about 16 digits. Notice that with doubles, we need a large value in the trillions in order to see a difference of <code>0.0003</code> that should be compared as equal.</p>
			<p lang="en-GB">If you are wondering how I arrived at these test numbers, I just picked small numbers just one decimal place bigger than epsilon for the small value tests. And for the large values, I choose a bigger number that I multiplied by (1 + epsilon) to arrive at the other number to be compared with. I then rounded the other number a bit so that it would be a bit closer. I had to choose a big number to start with that would stay within the number of digits allowed for each type.</p>
			<p lang="en-GB">Since we’re using the double epsilon value for long doubles, the tests for small and large long doubles look similar to the tests for double. The long double tests look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test small long double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    bool result = compareEq(0.000000000000001L,                   0.000000000000002L);
    CONFIRM_FALSE(result);
}
TEST("Test large long double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    bool result = compareEq(1'500'000'000'000.0L,                   1'500'000'000'000.0003L);
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The only difference between the double tests and the long double tests is the long double suffix <code>L</code> at the end of the long double literal values.</p>
			<p lang="en-GB">After adding all six tests for small and large floating-point type tests, they all fail when run.</p>
			<p lang="en-GB">The reason for the failures is the same for each type. The small value tests all fail because the fixed margin considers the values to be equal when they should not be equal, and the large value tests consider the values to be not equal when they really are close, considering the large<a id="_idIndexMarker501"/> value. In fact, the large values are all within a single epsilon value from each other. The large values are as close as they can possibly get without being exactly equal. Sure—the long double large values could have been closer, but we’re simplifying long doubles a bit by using the bigger epsilon from the double type.</p>
			<p lang="en-GB">We need to enhance the <code>compareEq</code> function so that the margin can be smaller for small values and bigger for big values. The moment we take on the responsibilities of comparing floating-point values, there are a lot of details that need to be handled. We skipped the extra details in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>. We’re also going to skip some of the details even here. If you haven’t realized it yet, dealing with floating-point values is really hard. The moment you think everything is working is when another detail comes along that changes everything.</p>
			<p lang="en-GB">Let’s first fix the <code>getMargin</code> functions to return the real <code>epsilon</code> values modified slightly for each type, like this:</p>
			<pre class="source-code" lang="en-GB">
constexpr float getMargin (float)
{
    // 4 is chosen to pass a reasonable amount of error.
    return std::numeric_limits&lt;float&gt;::epsilon() * 4;
}
constexpr double getMargin (double)
{
    // 4 is chosen to pass a reasonable amount of error.
    return std::numeric_limits&lt;double&gt;::epsilon() * 4;
}
constexpr long double getMargin (long double)
{
    // Use double epsilon instead of long double epsilon.
    // Double epsilon is already much bigger than
    // long double epsilon so we don't need to multiply it.
    return std::numeric_limits&lt;double&gt;::epsilon();
}</pre>
			<p lang="en-GB">The <code>getMargin</code> functions now use the <code>epsilon</code> values for the types as defined in <code>numeric_limits</code>. The margins are tuned for our needs. You might want to multiply by different numbers, and you might want to use the real <code>epsilon</code> value for long doubles. The reason we want bigger margins than <code>epsilon</code> itself is that we want to consider values to be equal that are more than just one <code>epsilon</code> value greater or lesser away from each other. We want a little more room for the accumulation of at least a few calculation errors. We <a id="_idIndexMarker502"/>multiply <code>epsilon</code> by <code>4</code> to give that extra room, and we use the double <code>epsilon</code> for long doubles, which might really be too much already. But these margins work for what we need.</p>
			<p lang="en-GB">We’ll use the more accurate margin values in the new <code>compareEq</code> function, which looks like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
bool compareEq (T lhs, T rhs)
{
    // Check for an exact match with operator == first.
    if (lhs == rhs)
    {
        return true;
    }
    // Subnormal diffs near zero are treated as equal.
    T diff = std::abs(lhs - rhs);
    if (diff &lt;= std::numeric_limits&lt;T&gt;::min())
    {
        return true;
    }
    // The margin should get bigger with bigger absolute values.
    // We scale the margin up by the larger value or
    // leave the margin unchanged if larger is less than 1.
    lhs = std::abs(lhs);
    rhs = std::abs(rhs);
    T larger = (lhs &gt; rhs) ? lhs : rhs;
    larger = (larger &lt; 1.0) ? 1.0 : larger;
    return diff &lt;= getMargin(lhs) * larger;
}</pre>
			<p lang="en-GB">I like to use parameter names <code>lhs</code> and <code>rhs</code> for operator-type functions such as this. The abbreviations stand for left-hand side and right-hand side, respectively. </p>
			<p lang="en-GB">Consider these two numbers:</p>
			<pre class="source-code" lang="en-GB">
3 == 4</pre>
			<p lang="en-GB">When making a comparison of <a id="_idIndexMarker503"/>these, <code>3</code> is on the left side of the operator and would be the <code>lhs</code> argument, while <code>4</code> is on the right and would be the <code>rhs</code> argument.</p>
			<p lang="en-GB">There’s always a chance that the two numbers being compared are exactly equal to each other. So, the first thing we check is for an exact match using the <code>==</code> operator.</p>
			<p lang="en-GB">The <code>compareEq</code> function goes on to check the difference between the two numbers for a <em class="italic" lang="">subnormal</em> result. Remember I said that floating-point numbers are complicated? There could be an entire book written about floating-point math, and there are probably several books already written. I won’t go into much explanation about subnormal values except to say that this is how floating-point values are represented when they are extremely close to zero. We’ll consider any two subnormal values to be equal.</p>
			<p lang="en-GB">Subnormal values are also a good reason to <em class="italic" lang="">compare your numbers with each other</em> instead of <em class="italic" lang="">comparing their difference with zero</em>. You might wonder what the problem is. Doesn’t the code in the <code>compareEq</code> function subtract one value from the other to arrive at the difference? Yes, it does. But our <code>compareEq</code> function doesn’t try to compare the difference with zero directly. We figure out which of the two values is bigger and then scale the margin by multiplying the margin with the bigger value. We also avoid scaling the margin down when we are comparing values less than <code>1.0</code>.</p>
			<p lang="en-GB">If you have two values to compare and instead of passing them to <code>compareEq</code>, you pass their difference and compare the difference with zero, then you remove the ability of the <code>compareEq</code> function to do the scaling because the <code>compareEq</code> function would then only see a small difference and zero being compared.</p>
			<p lang="en-GB">The lesson here is to always pass your numbers to be compared directly to the <code>compareEq</code> function and let it figure out how much the two numbers are different by taking into account how big the numbers are. You’ll get more accurate comparisons.</p>
			<p lang="en-GB">We could make the <code>compareEq</code> function even more elaborate. Maybe we could consider the sign of subnormal values instead of considering all of them to be equal, or maybe we could scale the margin down more so that we get very precise when dealing with subnormal values. This is not a book about math, so we’re going to stop adding more to the <code>compareEq</code> function.</p>
			<p lang="en-GB">After making the changes to <code>compareEq</code>, all the tests pass. We now have a solution that allows small amounts of <a id="_idIndexMarker504"/>accumulated errors and lets two numbers compare equal when they are close enough. The solution works for both really small numbers and really big numbers. The next section will turn the code we explored here into a better Hamcrest equality matcher.</p>
			<h1 id="_idParaDest-127" lang="en-GB"><a id="_idTextAnchor136"/>Adding floating-point Hamcrest matchers</h1>
			<p lang="en-GB">We explored better floating-point <a id="_idIndexMarker505"/>comparisons in the previous section, and now it’s time to use the comparison code in the unit test library. Some of the code should be moved into <code>Test.h</code> where it fits better and can then be used by the test library. The rest of the code that was written should stay in <code>Hamcrest.cpp</code> because it’s code that supports the tests.</p>
			<p lang="en-GB">The code that needs to be moved is the <code>compareEq</code> function and the three <code>getMargin</code> functions that <code>compareEq</code> calls to get the margins. We also need to move the includes of <code>cmath</code> and <code>limits</code> into <code>Test.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;
#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;string_view&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">The three <code>getMargin</code> functions and the <code>compareEq</code> function can be moved into <code>Test.h</code>, right before the first override of the <code>confirm</code> function that accepts Booleans. None of the code in the moved functions needs to change. Just cut the includes and the functions out of <code>Hamcrest.cpp</code> and paste the code into <code>Test.h</code>.</p>
			<p lang="en-GB">We might as well fix the existing floating-point classic <code>confirm</code> functions. This is why I had you move the <code>compareEq</code> function into <code>Test.h</code> immediately before the first <code>confirm</code> function. The change to the existing floating-point <code>confirm</code> functions is simple. They need to call <code>compareEq</code> instead of using hardcoded margins that don’t scale. The <code>confirm</code> function for float types looks like this after the change:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    float expected,
    float actual,
    int line)
{
    if (not compareEq(actual, expected))
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">The other two <code>confirm</code> functions that accept double and long double types should be changed to look similar. All three <code>confirm</code> functions will create the correct template of <code>compareEq</code> based on the <code>expected</code> and <code>actual</code> parameter types.</p>
			<p lang="en-GB">We should build and run the test application to make sure nothing broke with this small refactoring. And all the tests pass. We now have updated classic style <code>confirm</code> functions that will work<a id="_idIndexMarker506"/> better with floating-point comparisons.</p>
			<p lang="en-GB">We can make the code slightly better, though. We have three almost identical functions that are different only by their parameter types. The only reason for the three functions is that we want to override the <code>confirm</code> function for floating-point types. But since we’re using C++20, let’s use <em class="italic" lang="">concepts</em> instead! Concepts are a new feature that we’ve already started using when we specialized the <code>Equals</code> matcher to work with char arrays and char pointers in the previous chapter. Concepts allow us to tell the compiler which types are acceptable for template parameters and even function parameters. In the previous chapter, we were only using the requires keyword to place some restrictions on the template parameters. We’ll be using more well-known concepts here in this chapter.</p>
			<p lang="en-GB">We need to include <code>concepts</code> like this in <code>Test.h</code>:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;concepts&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;
#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;string_view&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">And then, we can replace the three <code>confirm</code> functions that accept float, double, and long double types with a single template that uses the <code>floating_point</code> concept, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;std::floating_point T&gt;
void confirm (
    T expected,
    T actual,
    int line)
{
    if (not compareEq(actual, expected))
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">This new template will only<a id="_idIndexMarker507"/> accept floating-point types, and by making both <code>expected</code> and <code>actual</code> share the same type <code>T</code>, then both types must be the same. The definition of <code>floating_point</code> is one of the well-known concepts defined in the <code>concepts</code> header.</p>
			<p lang="en-GB">Now that we have the classic style confirmations working, let’s get the Hamcrest <code>Equals</code> matcher working for floating-point values. We can first change the three large floating-point tests in <code>Hamcrest.cpp</code> to stop calling <code>compareEq</code> directly and instead use the <code>CONFIRM_THAT</code> macro so that they look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test large float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(9'999.0f, Equals(9'999.001f));
}
TEST("Test large double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    CONFIRM_THAT(1'500'000'000'000.0,                 Equals(1'500'000'000'000.0003));
}
TEST("Test large long double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    CONFIRM_THAT(1'500'000'000'000.0L,             Equals(1'500'000'000'000.0003L));
}</pre>
			<p lang="en-GB">We’re not going to change the tests for the small floating-point values yet because we don’t have a matcher that does inequality comparisons. The solution might be as simple as putting the <code>not</code> keyword in front of <code>Equals</code>, but let’s hold off on that for just a moment because we’ll be exploring our options in the next section.</p>
			<p lang="en-GB">With the change to the<a id="_idIndexMarker508"/> tests, they should fail because we haven’t yet specialized the <code>Equals</code> matcher to do anything different for floating-point types. Building and running the test application shows that the three tests do fail, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test large float values</strong>
<strong class="bold" lang="">Failed confirm on line 152</strong>
<strong class="bold" lang="">    Expected: 9999.000977</strong>
<strong class="bold" lang="">    Actual  : 9999.000000</strong>
<strong class="bold" lang="">------- Test: Test small double values</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test large double values</strong>
<strong class="bold" lang="">Failed confirm on line 165</strong>
<strong class="bold" lang="">    Expected: 1500000000000.000244</strong>
<strong class="bold" lang="">    Actual  : 1500000000000.000000</strong>
<strong class="bold" lang="">------- Test: Test small long double values</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test large long double values</strong>
<strong class="bold" lang="">Failed confirm on line 178</strong>
<strong class="bold" lang="">    Expected: 1500000000000.000300</strong>
<strong class="bold" lang="">    Actual  : 1500000000000.000000</strong></pre>
			<p lang="en-GB">Notice how the expected values printed in the summary report don’t exactly match the literal values given in the tests for the float and the double types. The long double does display a value that matches the value given in the test. The discrepancy is because floating-point variables are unable to always match exact values. The differences become more visible with floats, a little less visible with doubles, and closer to the desired values with long doubles.</p>
			<p lang="en-GB">The steps we just went through follow TDD. We modified existing tests instead of creating new tests because we don’t expect callers to use <code>compareEq</code> directly. The tests were initially written to call <code>compareEq</code> directly to show that we had a solution for floating-point types that worked. Modifying the tests to the desired usage is the right thing to do, and then, by running the tests, we can see the failures. This is good because we expected the tests to fail. Had the tests passed instead, then we would need to find the reason for the unexpected success.</p>
			<p lang="en-GB">Let’s get the tests to <a id="_idIndexMarker509"/>pass again! We need a version of <code>Equals</code> that knows how to work with floating-point types. We’ll use the concept <code>floating_point</code> that we just used for the classic style confirmations to create another version of <code>Equals</code> that will call <code>compareEq</code> for floating-point types. Place this new <code>Equals</code> specialization in <code>Test.h</code> right after <code>Equals</code> that works with char pointers, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;std::floating_point T&gt;
class Equals&lt;T&gt; : public Matcher
{
public:
    Equals (T const &amp; expected)
    : mExpected(expected)
    { }
    bool pass (T const &amp; actual) const
    {
        return compareEq(actual, mExpected);
    }
    std::string to_string () const override
    {
        return std::to_string(mExpected);
    }
private:
    T mExpected;
};</pre>
			<p lang="en-GB">That’s all we need to change to get the tests passing again. The new <code>Equals</code> specialization accepts any floating-point type and will be preferred by the compiler for floating-point types instead of the general-purpose <code>Equals</code> template. The floating-point version of <code>Equals</code> calls <code>compareEq</code> to do the comparison. We also don’t need to worry about which types will be passed to <code>to_string</code> and can simply call <code>std::to_string</code> since we know that we will have one of the built-in floating-point types. The <code>to_string</code> assumption could fail if the user passes in some other type that has been created to be a <code>floating_point</code> concept type, but let’s keep the code as simple as it can be for now and not worry about custom floating-point types.</p>
			<p lang="en-GB">The next section will <a id="_idIndexMarker510"/>start by creating a solution to test for inequality instead. We’ll use the solution we create in the next section to modify the small floating-point Hamcrest tests.</p>
			<h1 id="_idParaDest-128" lang="en-GB"><a id="_idTextAnchor137"/>Writing custom Hamcrest matchers</h1>
			<p lang="en-GB">The previous section <a id="_idIndexMarker511"/>ended with the <code>Equals</code> matcher specialized to call <code>compareEq</code> for floating-point types. We also modified the tests for large floating-point values because they could use the Hamcrest style and the <code>Equals</code> matcher.</p>
			<p lang="en-GB">We left the tests for small floating-point values unchanged because those tests need to make sure that the actual and expected values are not equal.</p>
			<p lang="en-GB">We want to update the small floating-point value tests and need a way to test for not equal values. Maybe we could create a new matcher called <code>NotEquals</code>, or we could put the <code>not</code> keyword in front of the <code>Equals</code> matcher.</p>
			<p lang="en-GB">I’d like to avoid the need for a new matcher if possible. We don’t really need any new behavior—we just need to flip the results of the existing <code>Equals</code> matcher. Let’s try modifying the small floating-point value tests to look like this in <code>Hamcrest.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test small float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(0.000001f, not Equals(0.000002f));
}
TEST("Test small double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    CONFIRM_THAT(0.000000000000001,             not Equals(0.000000000000002));
}
TEST("Test small long double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    CONFIRM_THAT(0.000000000000001L,             not Equals(0.000000000000002L));
}</pre>
			<p lang="en-GB">The only changes are to stop calling <code>compareEq</code> directly and to use the <code>CONFIRM_THAT</code> macro with the <code>Equals</code> matcher. Notice that we flip the results of the <code>Equals</code> matcher by <a id="_idIndexMarker512"/>placing the <code>not</code> keyword in front.</p>
			<p lang="en-GB">Does it build? No. We get compile errors similar to this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">MereTDD/tests/Hamcrest.cpp:145:29: error: no match for 'operator!' (operand type is 'MereTDD::Equals&lt;float&gt;')</strong>
<strong class="bold" lang="">  145 |     CONFIRM_THAT(0.000001f, not Equals(0.000002f));</strong>
<strong class="bold" lang="">      |                             ^~~~~~~~~~~~~~~~~~~~~</strong></pre>
			<p lang="en-GB">The <code>not</code> keyword in C++ is a shortcut for <code>operator !</code>. Normally with TDD, the next step would be to modify the code so that the tests can build. But we have a problem. The <code>not</code> keyword expects the class to have an <code>operator !</code> method or some way to cast the class to a Boolean. Either option requires that the class be able to generate a bool value, and that’s not how the matchers work. In order for a matcher to know whether the result should pass or not, it needs to know the <code>actual</code> value. The <code>confirm_that</code> function passes the matcher the needed <code>actual</code> value as an argument to the <code>pass</code> method. We can’t turn a matcher by itself into a bool result.</p>
			<p lang="en-GB">We’re going to have to create a <code>NotEquals</code> matcher. While not my first preference, a new matcher is acceptable from a test perspective. Let’s change the tests to look like this instead:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test small float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(0.000001f, NotEquals(0.000002f));
}
TEST("Test small double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    CONFIRM_THAT(0.000000000000001,             NotEquals(0.000000000000002));
}
TEST("Test small long double values")
{
    // Based on double epsilon = 2.2204460492503130808e-16
    CONFIRM_THAT(0.000000000000001L,             NotEquals(0.000000000000002L));
}</pre>
			<p lang="en-GB">Another reason that I<a id="_idIndexMarker513"/> wanted to avoid a new matcher is to avoid the need to specialize the new matcher as we did for the <code>Equals</code> matcher, but there is a way to create a matcher called <code>NotEquals</code> and base its implementation on all the work we did for the <code>Equals</code> matcher. All we need to do is contain the <code>Equals</code> matcher and flip the <code>pass</code> result, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class NotEquals : public Matcher
{
public:
    NotEquals (T const &amp; expected)
    : mExpected(expected)
    { }
    template &lt;typename U&gt;
    bool pass (U const &amp; actual) const
    {
        return not mExpected.pass(actual);
    }
    std::string to_string () const override
    {
        return "not " + mExpected.to_string();
    }
private:
    Equals&lt;T&gt; mExpected;
};</pre>
			<p lang="en-GB">Add the <code>NotEquals</code> matcher right after all the template specializations of the <code>Equals</code> matcher in <code>Test.h</code>.</p>
			<p lang="en-GB">The <code>NotEquals</code> matcher is a new matcher type that contains an <code>Equals</code> matcher for its <code>mExpected</code> data member. This will give us all the specialization we did for the <code>Equals</code> matcher. Whenever the <code>NotEquals::pass</code> method is called, we just call the <code>mExpected.pass</code> method and flip the result. And whenever the <code>to_string</code> method is called, we just add <code>"not "</code> to whichever string <code>mExpected</code> provides.</p>
			<p lang="en-GB">One interesting thing to notice is that the <code>pass</code> method is itself a template based on a type <code>U</code>. This will let us construct a <code>NotEquals</code> matcher given a string literal and then call the <code>pass</code> method with <code>std::string</code>.</p>
			<p lang="en-GB">We should add a test for using the NotEquals matcher with a string literal and std::string or, even better, to extend <a id="_idIndexMarker514"/>an existing test. We have two tests already that work with strings, string literals, and char pointers. Both tests are in <code>Hamcrest.cpp</code>. The first test should look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string confirms")
{
    std::string s1 = "abc";
    std::string s2 = "abc";
    CONFIRM_THAT(s1, Equals(s2));       // string vs. string
    CONFIRM_THAT(s1, Equals("abc"));    // string vs. literal
    CONFIRM_THAT("abc", Equals(s1));    // literal vs. string
    // Probably not needed, but this works too.
    CONFIRM_THAT("abc", Equals("abc")); // literal vs. literal
    std::string s3 = "def";
    CONFIRM_THAT(s1, NotEquals(s3));       // string vs. string
    CONFIRM_THAT(s1, NotEquals("def"));    // string vs. literal
    CONFIRM_THAT("def", NotEquals(s1));    // literal vs. string
}</pre>
			<p lang="en-GB">And the second test should<a id="_idIndexMarker515"/> be modified to look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string pointer confirms")
{
    char const * sp1 = "abc";
    std::string s1 = "abc";
    char const * sp2 = s1.c_str();    // avoid sp1 and sp2 being same
    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer
    CONFIRM_THAT(sp2, Equals("abc")); // pointer vs. literal
    CONFIRM_THAT("abc", Equals(sp2)); // literal vs. pointer
    CONFIRM_THAT(sp1, Equals(s1));    // pointer vs. string
    CONFIRM_THAT(s1, Equals(sp1));    // string vs. pointer
    char const * sp3 = "def";
    CONFIRM_THAT(sp1, NotEquals(sp3));   // pointer vs. pointer
    CONFIRM_THAT(sp1, NotEquals("def")); // pointer vs. literal
    CONFIRM_THAT("def", NotEquals(sp1)); // literal vs. pointer
    CONFIRM_THAT(sp3, NotEquals(s1));    // pointer vs. string
    CONFIRM_THAT(s1, NotEquals(sp3));    // string vs. pointer
}</pre>
			<p lang="en-GB">Building and running the test application shows that all the tests pass. Instead of adding new tests, we were able to modify the existing tests because the two existing tests were focused on the string and char pointer types. The <code>NotEquals</code> matcher fit right into the existing tests.</p>
			<p lang="en-GB">Having both <code>Equals</code> and <code>NotEquals</code> matchers gives us more than we had with the classic style confirmations, and we can go further by creating another matcher. You can also create matchers to do whatever you want in your test projects. We’re going to create a new matcher in the <code>MereTDD</code> namespace but you can put yours in your own namespace. The matcher <a id="_idIndexMarker516"/>we’ll be creating will test to make sure that an integral number is even. We’ll call the matcher <code>IsEven</code>, and we can write a couple of tests in <code>Hamcrest.cpp</code> to look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test even integral value")
{
    CONFIRM_THAT(10, IsEven&lt;int&gt;());
}
TEST("Test even integral value confirm failure")
{
    CONFIRM_THAT(11, IsEven&lt;int&gt;());
}</pre>
			<p lang="en-GB">You’ll notice something different about the <code>IsEven</code> matcher: it doesn’t require an expected value. The matcher only needs the actual value passed to it in order to confirm whether the actual value is even or not. Because there’s nothing to pass to the constructor when creating an <code>IsEven</code> matcher in the test, we need to specify the type, like this:</p>
			<pre class="source-code" lang="en-GB">
IsEven&lt;int&gt;()</pre>
			<p lang="en-GB">The second test should fail, and we’ll use the failure to get the exact error message so that we can turn the test into an expected failure. But we first need to create an <code>IsEven</code> matcher. The <code>IsEven</code> class can go in <code>Test.h</code> immediately after the <code>NotEquals</code> matcher, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;std::integral T&gt;
class IsEven : public Matcher
{
public:
    IsEven ()
    { }
    bool pass (T const &amp; actual) const
    {
        return actual % 2 == 0;
    }
    std::string to_string () const override
    {
        return "is even";
    }
};</pre>
			<p lang="en-GB">I wanted to show you an example of a really simple custom matcher so that you’ll know that they don’t all need to be complicated or have multiple template specializations. The <code>IsEven</code> matcher just tests the <code>actual</code> value in the <code>pass</code> method to make sure it’s even, and the <code>to_string</code> method returns a fixed string.</p>
			<p lang="en-GB">Building and running shows the even value test passes while the intended failure test fails, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test even integral value</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test even integral value confirm failure</strong>
<strong class="bold" lang="">Failed confirm on line 185</strong>
<strong class="bold" lang="">    Expected: is even</strong>
<strong class="bold" lang="">    Actual  : 11</strong></pre>
			<p lang="en-GB">With the error message, we can<a id="_idIndexMarker517"/> modify the even confirm failure test so that it will pass with an expected failure, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test even integral value confirm failure")
{
    std::string reason = "    Expected: is even\n";
    reason += "    Actual  : 11";
    setExpectedFailureReason(reason);
    CONFIRM_THAT(11, IsEven&lt;int&gt;());
}</pre>
			<p lang="en-GB">Building and running now shows that both tests pass. One passes successfully and the other passes with an expected failure, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test even integral value</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test even integral value confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: is even</strong>
<strong class="bold" lang="">    Actual  : 11</strong></pre>
			<p lang="en-GB">That’s all there is to making custom matchers! You can make matchers for your own classes or add custom matchers for new behaviors. Maybe you want to verify that a number has only a certain number of digits, that a string begins with some given text prefix, or that a log message contains a certain tag. Remember how in <a href="B18567_10.xhtml#_idTextAnchor096"><em class="italic" lang="">Chapter 10</em></a>, <em class="italic" lang="">The TDD Process in Depth</em>, we had to verify tags by writing to a file and then scanning the file to make sure the line just written contained a tag? We could have a custom matcher that looks for a tag instead.</p>
			<h1 id="_idParaDest-129" lang="en-GB"><a id="_idTextAnchor138"/>Summary</h1>
			<p lang="en-GB">One of the main benefits of the Hamcrest style confirmations is their ability to be extended through custom matchers. What better way to explore this ability than through floating-point confirmations? Because there is no single best way to compare floating-point values, you might need a solution that’s tuned to your specific needs. You learned about a good general-purpose floating-point comparison technique in this chapter that scales a small margin of error so that bigger floating-point values are allowed to differ by greater amounts as the values get bigger and still be considered to be equal.</p>
			<p lang="en-GB">If this general solution doesn’t meet your needs, you now know how to create your own matcher that will do exactly what you need.</p>
			<p lang="en-GB">And the ability to extend matchers doesn’t stop at floating-point values. You might have your own custom behavior that you need to confirm, and after reading this chapter, you now know how to create a custom matcher to do what you need.</p>
			<p lang="en-GB">Not all matchers need to be big and complicated and have multiple template specializations. You saw an example of a very simple custom matcher that confirms whether a number is even or not.</p>
			<p lang="en-GB">We also made good use of the concepts feature, new in C++20, which allows you to easily specify requirements on your template types. We made good use of concepts in this chapter to make sure that the floating-point matcher only works for floating-point types and that the <code>IsEven</code> matcher only works for integral types. You can use concepts in your matchers too, which will help you control how your matchers can be used.</p>
			<p lang="en-GB">The next chapter will explore how to test services and will introduce a new service project that uses all the code developed so far in this book.</p>
		</div>
	</body></html>