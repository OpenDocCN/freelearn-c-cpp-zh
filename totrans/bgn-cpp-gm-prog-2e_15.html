<html><head></head><body>
		<div id="_idContainer094">
			<h1 id="_idParaDest-283"><a id="_idTextAnchor292"/><em class="italic">Chapter 14</em>: Abstraction and Code Management – Making Better Use of OOP</h1>
			<p>In this chapter, we will take a first look at the penultimate project of this book. The project we will be building will use advanced features such as directional sound, which has the effect of appearing to play relative to the position of the player. It will also have split-screen cooperative gameplay. In addition, this project will introduce the concept of <strong class="bold">Shaders</strong>, which are programs written in another language that run directly on the graphics card. By the end of <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>,<em class="italic"> Particle Systems and Shaders</em>, you will have a fully functioning, multiplayer platform game built in the style of the hit classic <em class="italic">Thomas Was Alone</em>.</p>
			<p>This chapter's focus will be getting the project started and exploring how the code will be structured to make better use of OOP. Here are the details of the topics that will be covered in this chapter:</p>
			<ul>
				<li>Introducing the final project, <strong class="bold">Thomas Was Late</strong>, including the gameplay features and project assets</li>
				<li>A detailed discussion of how we will improve the structure of the code compared to previous projects</li>
				<li>Coding the Thomas Was Late game engine</li>
				<li>Implementing split-screen functionality</li>
			</ul>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor293"/>The Thomas Was Late game</h1>
			<p class="callout-heading">Tip</p>
			<p class="callout">At this point, if you haven't already, I suggest that you go and watch a video of Thomas Was Alone at <a href="http://store.steampowered.com/app/220780/">http://store.steampowered.com/app/220780/</a>.</p>
			<p>Notice the simple but aesthetically excellent graphics. The video also shows a variety of gameplay challenges such as using the character's different attributes (height, jump, power, and so on). To keep our game simple without losing the challenge, we will have fewer puzzle features than Thomas Was Alone but will have the additional challenge of creating the need for two players to play cooperatively. Just to make sure the game is not too easy, we will also make the players have to rush to beat the clock, which is why the name of our game is Thomas Was Late.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor294"/>Features of Thomas Was Late</h2>
			<p>Our game will not be nearly as advanced as the masterpiece that we are attempting to emulate, but it will have a good selection of exciting game-play features, such as the following:</p>
			<ul>
				<li>A clock that counts down from a time appropriate to the challenge of the level.</li>
				<li>Fire pits that emit a roar relative to the position of the player and respawn the player at the start if they fall in. Water pits have the same effect but without the directional sound effects.</li>
				<li>Cooperative gameplay. Both players will have to get their characters to the goal within the allotted time. They will need to work together frequently so that the shorter, lower-jumping Bob will need to stand on his friend's (Thomas') head.</li>
				<li>The player will have the option of switching between full and split-screen so they can attempt to control both characters themselves.</li>
				<li>Each level will be designed in, and loaded from, a text file. This will make it easy to design varied and numerous levels.</li>
			</ul>
			<p>Take a look at the following annotated screenshot of the game to see some of the features in action and the components/assets that make up the game:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B14278_14_01a.jpg" alt=""/>
				</div>
			</div>
			<p>Let's look at each of these features and describe a few more:</p>
			<ul>
				<li>The preceding screenshot shows a simple HUD that details the level number and the number of seconds remaining until the player(s) fail and must restart the level.</li>
				<li>You can also clearly see the split-screen coop in action. Remember that this is optional. A single player can take on the game, fullscreen, while switching the camera focus between Thomas and Bob.</li>
				<li>It is not very clear in the preceding screenshot (especially in print), but when a character dies, they will explode in a starburst/firework-like particle effect.</li>
				<li>The water and fire tiles can be strategically placed to make the level fun, as well as forcing cooperation between the characters. More on this will be covered in <a href="B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327"><em class="italic">Chapter 16</em></a>,<em class="italic"> Building Playable Levels and Collision Detection</em>.</li>
				<li>Next, notice Thomas and Bob. They are not only different in height but also have significantly varied jumping abilities. This means that Bob is dependent upon Thomas for big jumps, and levels can be designed to force Thomas to take a specific route to avoid him "banging his head".</li>
				<li>In addition, the fire tiles will emit a roaring sound. These will be relative to the position of Thomas. Not only will they be directional and come from either the left or right speaker, they will also get louder and quieter as Thomas moves closer to or further away from the source.</li>
				<li>Finally, in the preceding annotated screenshot, you can see the background. Why not compare how that looks to the <strong class="source-inline">background.png</strong> file (shown later in this chapter)? You will see it is quite different. We will use OpenGL shader effects in <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>, <em class="italic">Particle Systems and Shaders</em>, to achieve the moving, almost bubbling, effect in the background.</li>
			</ul>
			<p>All of these features warrant a few more screenshots so that we can keep the finished product in mind as we write the C++ code.</p>
			<p>The following screenshot shows Thomas and Bob arriving at a fire pit that Bob has no chance of jumping over without help:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B14278_14_01b.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot shows Bob and Thomas collaborating to clear a precarious jump:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B14278_14_01c.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot shows how we can design puzzles where a "leap of faith" is required in order to reach the goal:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B14278_14_01d.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot demonstrates how we can design oppressive cave systems of almost any size. We can also devise levels where Bob and Thomas are forced to split up and go different routes:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B14278_14_01e.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor295"/>Creating the project</h2>
			<p>Creating the Thomas Was Late project will follow the same procedure that we used in the previous three projects. Since creating a project is a slightly fiddly process, I will detail all the steps again here. For even more detail and images, refer to setting up the Timber!!! project in <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>:</p>
			<ol>
				<li value="1">Start Visual Studio and click on the <strong class="bold">Create New Project</strong> button. If you have another project open, you can select <strong class="bold">File</strong> | <strong class="bold">New project</strong>.</li>
				<li>In the window shown next, choose <strong class="bold">Console app</strong> and click the <strong class="bold">Next</strong> button. You will then see the <strong class="bold">Configure your new project</strong> window. </li>
				<li>In the <strong class="bold">Configure your new project</strong> window, type <strong class="source-inline">TWL</strong> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field.</li>
				<li>In the <strong class="bold">Location</strong> field, browse to the <strong class="source-inline">VS Projects</strong> folder.</li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>. </li>
				<li>When you have completed these steps, click <strong class="bold">Create</strong>.</li>
				<li>We will now configure the project to use the SFML files that we put in the <strong class="source-inline">SFML</strong> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">TWL properties…</strong>. At this stage, you should have the <strong class="bold">TWL Property Pages</strong> window open. </li>
				<li>In the <strong class="bold">TWL Property Pages</strong> window, take the following steps. Select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> dropdown.</li>
				<li>Now, select <strong class="bold">C/C++</strong> and then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>Now, locate the <strong class="bold">Additional Include Directories</strong> edit box and type the drive letter where your SFML folder is located, followed by <strong class="source-inline">\SFML\include</strong>. The full path to type, if you located your <strong class="source-inline">SFML</strong> folder on your D drive, is <strong class="source-inline">D:\SFML\include</strong>. Vary your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform the following steps. From the left-hand menu, select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <strong class="bold">Additional Library Directories</strong> edit box and type the drive letter where your <strong class="source-inline">SFML</strong> folder is, followed by <strong class="source-inline">\SFML\lib</strong>. So, the full path to type if you located your <strong class="source-inline">SFML</strong> folder on your D drive is <strong class="source-inline">D:\SFML\lib</strong>. Vary your path if you installed SFML to a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Next, still in the same window, perform these steps. Switch the <strong class="bold">Configuration:</strong> dropdown to <strong class="bold">Debug </strong>as we will be running and testing Pong in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong>.</li>
				<li>Find the <strong class="bold">Additional Dependencies</strong> edit box and click into it at the far-left-hand side. Now, copy and paste/type the following: <strong class="source-inline">sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</strong>. Be extra careful to place the cursor exactly at the start of the edit box's current content so that you don't overwrite any of the text that is already there.</li>
				<li>Click <strong class="bold">OK</strong>.</li>
				<li>Click <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
			</ol>
			<p>That's the project properties configured and ready to go. Now, we need to copy the SFML <strong class="source-inline">.dll</strong> files into the main project directory by following these steps:</p>
			<ol>
				<li value="1">My main project directory is <strong class="source-inline">D:\VS Projects\TWL</strong>. This folder was created by Visual Studio in the previous steps. If you put your <strong class="source-inline">Projects</strong> folder somewhere else, then perform this step there instead. The files we need to copy into the project folder are located in our <strong class="source-inline">SFML\bin</strong> folder. Open a window for each of the two locations and highlight all the <strong class="source-inline">.dll</strong> files.</li>
				<li>Now, copy and paste the highlighted files into the project.</li>
			</ol>
			<p>The project is now set up and ready to go. </p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor296"/>The project's assets</h2>
			<p>The assets in this project are even more numerous and diverse than the Zombie Arena game. As usual, the assets include a font for the writing on the screen, sound effects for different actions such as jumping, reaching the goal, or the distant roar of fire, and, of course, graphics for Thomas and Bob as well as a sprite sheet for all the background tiles.</p>
			<p>All of the assets that are required for this game are included in the download bundle. They can be found in the <strong class="source-inline">Chapter 14/graphics</strong> and <strong class="source-inline">Chapter 14/sound</strong> folders.</p>
			<p>In addition to the graphics, sounds, and fonts that we have come to expect, this game has two new asset types. They are level design files and GLSL shader programs. Let's find out about each of them.</p>
			<h3>Game level designs</h3>
			<p>Levels are all created in a text file. By using the numbers 0 through 3, we can build level designs to challenge players. All the level designs are in the <strong class="source-inline">levels</strong> folder in the same directory as the other assets. Feel free to take a peek at one now, but we will look at them in detail in <em class="italic">Chapter 18</em>, <em class="italic">Particle Systems and Shaders</em>.</p>
			<p>In addition to these level design assets, we have a special type of graphical asset called <strong class="bold">shaders</strong>.</p>
			<h3>GLSL shaders</h3>
			<p><strong class="bold">Shaders</strong> are programs written in <strong class="bold">GLSL</strong> (<strong class="bold">Graphics Library Shading Language</strong>). Don't worry about having to learn another language as we don't need to get too in-depth to take advantage of shaders. Shaders are special as they are entire programs, separate from our C++ code, that are executed by the GPU each and every frame. In fact, some of these shader programs are run every frame, for every pixel! We will find out more about these details in <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>, <em class="italic">Particle Systems and Shaders</em>. If you can't wait that long, take a look at the files in the <strong class="source-inline">Chapter 14/shaders</strong> folder of the download bundle.</p>
			<h3>The graphical assets close up</h3>
			<p>The graphical assets make up the parts of the scene of our game. If you take a look at the graphical assets, it should be clear where in our game they will be used:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B14278_14_03.jpg" alt=""/>
				</div>
			</div>
			<p>If the tiles on the <strong class="source-inline">tiles_sheet</strong> graphic look a little different to the screenshots of the game, this is because they are partly transparent and the background showing through changes them a little. If the background graphic looks totally different to the actual background in the game screenshots, that is because the shader programs we will write will manipulate each and every pixel, each and every frame, to create a kind of "molten" effect.</p>
			<h3>The sound assets close up</h3>
			<p>The sound files are all in <strong class="source-inline">.wav</strong> format. These files contain the sound effects that we will play at certain events throughout the game. They are as follows:</p>
			<ul>
				<li><strong class="source-inline">fallinfire.wav</strong>: A sound that will be played when the player's head goes into fire and the player has no chance of escape.</li>
				<li><strong class="source-inline">fallinwater.wav</strong>: Water has the same end effect as fire: death. This sound effect notifies the player that they need to start from the beginning of the level.</li>
				<li><strong class="source-inline">fire1.wav</strong>: This sound effect is recorded in mono. It will be played at different volumes, based on the player's distance from fire tiles and from different speakers based on whether the player is to the left or the right of the fire tile. Clearly, we will need to learn a few more tricks to implement this functionality.</li>
				<li><strong class="source-inline">jump.wav</strong>: A pleasing (slightly predictable) whooping sound for when the player jumps.</li>
				<li><strong class="source-inline">reachgoal.wav</strong>: A pleasing victory sound for when the player(s) get both characters (Thomas and Bob) to the goal tile.</li>
			</ul>
			<p>The sound effects are very straightforward, and you can easily create your own. If you intend to replace the <strong class="source-inline">fire1.wav </strong>file, be sure to save your sounds in mono (not stereo) format. The reasons for this will be explained in <a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>,<em class="italic"> Sound Spatialization and HUD.</em></p>
			<h3>Adding the assets to the project</h3>
			<p>Once you have decided which assets you will use, it is time to add them to the project. The following instructions will assume you are using all the assets that were supplied in this book's download bundle. </p>
			<p>Where you are using your own, simply replace the appropriate sound or graphic file with your own, using exactly the same filename. Let's get started:</p>
			<ol>
				<li value="1">Browse to the <strong class="source-inline">D:\VS Projects\TWL</strong> folder.</li>
				<li>Create five new folders within this folder and name them <strong class="source-inline">graphics</strong>, <strong class="source-inline">sound</strong>, <strong class="source-inline">fonts</strong>,<strong class="source-inline"> shaders, </strong>and<strong class="source-inline"> levels</strong>.</li>
				<li>From the download bundle, copy the entire contents of <strong class="source-inline">Chapter 14/graphics</strong> into the <strong class="source-inline">D:\VS Projects\TWL\graphics</strong> folder.</li>
				<li>From the download bundle, copy the entire contents of <strong class="source-inline">Chapter 14/sound</strong> into the <strong class="source-inline">D:\VS Projects\TWL\sound</strong> folder.</li>
				<li>Now, visit <a href="http://www.dafont.com/roboto.font">http://www.dafont.com/roboto.font</a> in your web browser and download the <strong class="bold">Roboto Light</strong> font.</li>
				<li>Extract the contents of the zipped download and add the <strong class="source-inline">Roboto-Light.ttf</strong> file to the <strong class="source-inline">D:\VS Projects\TWL\fonts</strong> folder.</li>
				<li>From the download bundle, copy the entire contents of <strong class="source-inline">Chapter 12/levels </strong>into the <strong class="source-inline">D:\VS Projects\TWL\levels</strong> folder.</li>
				<li>From the download bundle, copy the entire contents of <strong class="source-inline">Chapter 12/shaders </strong>into the <strong class="source-inline">D:\VS Projects\TWL\shaders</strong> folder.</li>
			</ol>
			<p>Now that we have a new project, along with all the assets we will need for the entire project, we can talk about how we will structure the game engine code.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor297"/>Structuring the Thomas Was Late code</h1>
			<p>One of the problems that has been getting worse from project to project, despite taking measures to reduce the problem, is how long and unwieldy the code gets. <strong class="bold">Object-oriented programming</strong> (<strong class="bold">OOP</strong>) allows us to break our projects up into logical and manageable chunks, known as classes.</p>
			<p>We will make a big improvement to the manageability of the code in this project with the introduction of an <strong class="source-inline">Engine</strong> class. Among other functions, the <strong class="source-inline">Engine</strong> class will have three private functions. These are <strong class="source-inline">input</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong>. These should sound very familiar. Each of these functions will hold a chunk of the code that was previously in the <strong class="source-inline">main</strong> function. Each of these functions will be in a code file of its own, that is, <strong class="source-inline">Input.cpp</strong>, <strong class="source-inline">Update.cpp</strong>, and <strong class="source-inline">Draw.cpp</strong>, respectively.</p>
			<p>There will also be one public function in the <strong class="source-inline">Engine</strong> class, which can be called with an instance of <strong class="source-inline">Engine</strong>. This function is <strong class="source-inline">run</strong> and will be responsible for calling <strong class="source-inline">input</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong> once for each frame of the game:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B14278_14_06.jpg" alt=""/>
				</div>
			</div>
			<p>Furthermore, because we have abstracted the major parts of the game engine to the <strong class="source-inline">Engine</strong> class, we can also move many of the variables from <strong class="source-inline">main</strong> and make them members of <strong class="source-inline">Engine</strong>. All we need to do to get our game engine fired up is create an instance of <strong class="source-inline">Engine</strong> and call its <strong class="source-inline">run</strong> function. Here is a sneak preview of the super-simple <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Declare an instance of Engine</p>
			<p class="source-code">    Engine engine;</p>
			<p class="source-code">    // Start the engine</p>
			<p class="source-code">    engine.run();</p>
			<p class="source-code">    // Quit in the usual way when the engine is stopped</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't add the previous code just yet.</p>
			<p>To make our code even more manageable and readable, we will also abstract responsibility for big tasks such as loading a level and collision detection to separate functions (in separate code files). These two functions are <strong class="source-inline">loadLevel</strong> and <strong class="source-inline">detectCollisions</strong>. We will also code other functions to handle some of the new features of the Thomas Was Late project. We will cover them in detail, as and when they occur.</p>
			<p>To further take advantage of OOP, we will delegate responsibility for areas of the game entirely to new classes. You probably remember that the sound and HUD code was quite lengthy in previous projects. We will build a <strong class="source-inline">SoundManager</strong> and <strong class="source-inline">HUD</strong> class to handle these aspects in a cleaner manner. Exactly how they work will be explored in depth when we implement them. </p>
			<p>The game levels themselves are also much more in-depth than previous games, so we will also code a <strong class="source-inline">LevelManager</strong> class.</p>
			<p>As you would expect, the playable characters will be made with classes as well. For this project, however, we will learn some more C++ and implement a <strong class="source-inline">PlayableCharacter</strong> class with all the common functionality of Thomas and Bob. Then, the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes will <em class="italic">inherit</em> this common functionality as well as implementing their own unique functions and abilities. This technique, perhaps unsurprisingly, is called <strong class="bold">inheritance</strong>. I will go into more detail about inheritance in the next chapter: <a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>, <em class="italic">Advanced OOP – Inheritance and Polymorphism</em>.</p>
			<p>We will also implement several other classes to perform specific responsibilities. For example, we will make some neat explosions using particle systems. You might be able to guess that, to do this, we will code a <strong class="source-inline">Particle</strong> class and a <strong class="source-inline">ParticleSystem</strong> class. All these classes will have instances that are members of the <strong class="source-inline">Engine</strong> class. Doing things this way will make all the features of the game accessible from the game engine but encapsulate the details into the appropriate classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note that despite these new techniques to separate out the different aspects of our code, by the end of this project, we will still have some slightly unwieldy classes. The final project of this book, while a much simpler shooter game, will explore one more way of organizing our code to make it manageable.</p>
			<p>The last thing to mention before we move on to seeing the actual code that will make the <strong class="source-inline">Engine</strong> class is that we will reuse, without any changes whatsoever, the <strong class="source-inline">TextureHolder</strong> class that we discussed and coded for the Zombie Arena game.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor298"/>Building the game engine</h1>
			<p>As we suggested in the previous section, we will code a class called <strong class="source-inline">Engine</strong> that will control and bind the different parts of the Thomas Was Late game.</p>
			<p>The first thing we will do is make the <strong class="source-inline">TextureHolder</strong> class from the previous project available in this one.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor299"/>Reusing the TextureHolder class</h2>
			<p>The <strong class="source-inline">TextureHolder</strong> class that we discussed and coded for the Zombie Arena game will also be useful in this project. While it is possible to add the files (<strong class="source-inline">TextureHolder.h</strong> and <strong class="source-inline">TextureHolder.cpp</strong>) directly from the previous project, without recoding them or recreating the files, I don't want to assume that you haven't jumped straight to this project. What follows is very brief instructions, along with the complete code listing we need, to create the <strong class="source-inline">TextureHolder</strong> class. If you want the class or the code explained, please see <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>, <em class="italic">Pointers, the Standard Template Library, and Texture Management</em>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you did complete the previous project and you <em class="italic">do</em> want to add the class from the Zombie Arena project, simply do the following. In the <strong class="bold">Solution Explorer</strong> window, right-click <strong class="bold">Header Files</strong> and select <strong class="bold">Add | Existing Item...</strong>. Browse to <strong class="source-inline">TextureHolder.h</strong> from the previous project and select it. In the <strong class="bold">Solution Explorer</strong> window, right-click <strong class="bold">Source Files</strong> and select <strong class="bold">Add | Existing Item...</strong>. Browse to <strong class="source-inline">TextureHolder.cpp</strong> from the previous project and select it. You can now use the <strong class="source-inline">TextureHolder</strong> class in this project. Note that the files are shared between projects and any changes will take effect in both projects.</p>
			<p>To create the <strong class="source-inline">TextureHolder</strong> class from scratch, right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong>, and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">TextureHolder.h</strong>. Finally, click the <strong class="bold">Add</strong> button.</p>
			<p>Add the following code to <strong class="source-inline">TextureHolder.h</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#ifndef TEXTURE_HOLDER_H</p>
			<p class="source-code">#define TEXTURE_HOLDER_H</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;map&gt;</p>
			<p class="source-code">class TextureHolder</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // A map container from the STL,</p>
			<p class="source-code">    // that holds related pairs of String and Texture</p>
			<p class="source-code">    std::map&lt;std::string, sf::Texture&gt; m_Textures;</p>
			<p class="source-code">    // A pointer of the same type as the class itself</p>
			<p class="source-code">    // the one and only instance</p>
			<p class="source-code">    static TextureHolder* m_s_Instance;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    TextureHolder();</p>
			<p class="source-code">    static sf::Texture&amp; GetTexture(std::string const&amp; filename);</p>
			<p class="source-code">};</p>
			<p class="source-code">#endif</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong>, and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">TextureHolder.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button.</p>
			<p>Add the following code to <strong class="source-inline">TextureHolder.cpp</strong>:</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include &lt;assert.h&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">TextureHolder* TextureHolder::m_s_Instance = nullptr;</p>
			<p class="source-code">TextureHolder::TextureHolder()</p>
			<p class="source-code">{</p>
			<p class="source-code">    assert(m_s_Instance == nullptr);</p>
			<p class="source-code">    m_s_Instance = this;</p>
			<p class="source-code">}</p>
			<p class="source-code">sf::Texture&amp; TextureHolder::GetTexture(std::string const&amp; filename)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get a reference to m_Textures using m_S_Instance</p>
			<p class="source-code">    auto&amp; m = m_s_Instance-&gt;m_Textures;</p>
			<p class="source-code">    // auto is the equivalent of map&lt;string, Texture&gt;</p>
			<p class="source-code">    // Create an iterator to hold a key-value-pair (kvp)</p>
			<p class="source-code">    // and search for the required kvp</p>
			<p class="source-code">    // using the passed in file name</p>
			<p class="source-code">    auto keyValuePair = m.find(filename);</p>
			<p class="source-code">    // auto is equivalent of map&lt;string, Texture&gt;::iterator</p>
			<p class="source-code">    // Did we find a match?</p>
			<p class="source-code">    if (keyValuePair != m.end())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Yes</p>
			<p class="source-code">        // Return the texture,</p>
			<p class="source-code">        // the second part of the kvp, the texture</p>
			<p class="source-code">        return keyValuePair-&gt;second;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // File name not found</p>
			<p class="source-code">        // Create a new key value pair using the filename</p>
			<p class="source-code">        auto&amp; texture = m[filename];</p>
			<p class="source-code">        // Load the texture from file in the usual way</p>
			<p class="source-code">        texture.loadFromFile(filename);</p>
			<p class="source-code">        // Return the texture to the calling code</p>
			<p class="source-code">        return texture;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can now get on with our new <strong class="source-inline">Engine</strong> class.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor300"/>Coding Engine.h</h2>
			<p>As usual, we will start with the header file, which holds the function declarations and member variables. Note that we will revisit this file throughout the project to add more functions and member variables. At this stage, we will add just the code that is necessary.</p>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Engine.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">Engine</strong> class.</p>
			<p>Add the following member variables, as well as the function declarations. Many of them we have seen before in the other projects and some of them were discussed in the <em class="italic">Structuring the Thomas Was Late Code</em> section. Take note of the function and variable names, as well as whether they are private or public. Add the following code to the <strong class="source-inline">Engine.h</strong> file and then we will talk about it:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Engine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // The texture holder</p>
			<p class="source-code">    TextureHolder th;</p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p class="source-code">    const int VERTS_IN_QUAD = 4;</p>
			<p class="source-code">    // The force pushing the characters down</p>
			<p class="source-code">    const int GRAVITY = 300;</p>
			<p class="source-code">    // A regular RenderWindow</p>
			<p class="source-code">    RenderWindow m_Window;</p>
			<p class="source-code">    // The main Views</p>
			<p class="source-code">    View m_MainView;</p>
			<p class="source-code">    View m_LeftView;</p>
			<p class="source-code">    View m_RightView;</p>
			<p class="source-code">    // Three views for the background</p>
			<p class="source-code">    View m_BGMainView;</p>
			<p class="source-code">    View m_BGLeftView;</p>
			<p class="source-code">    View m_BGRightView;</p>
			<p class="source-code">    View m_HudView;</p>
			<p class="source-code">    // Declare a sprite and a Texture </p>
			<p class="source-code">    // for the background</p>
			<p class="source-code">    Sprite m_BackgroundSprite;</p>
			<p class="source-code">    Texture m_BackgroundTexture;</p>
			<p class="source-code">    // Is the game currently playing?</p>
			<p class="source-code">    bool m_Playing = false;</p>
			<p class="source-code">    // Is character 1 or 2 the current focus?</p>
			<p class="source-code">    bool m_Character1 = true;</p>
			<p class="source-code">    // Start in full screen (not split) mode</p>
			<p class="source-code">    bool m_SplitScreen = false;</p>
			<p class="source-code">    // Time left in the current level (seconds)</p>
			<p class="source-code">    float m_TimeRemaining = 10;</p>
			<p class="source-code">    Time m_GameTimeTotal;</p>
			<p class="source-code">    // Is it time for a new/first level?</p>
			<p class="source-code">    bool m_NewLevelRequired = true;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Private functions for internal use only</p>
			<p class="source-code">    void input();</p>
			<p class="source-code">    void update(float dtAsSeconds);</p>
			<p class="source-code">    void draw();</p>
			<p class="source-code">    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    // The Engine constructor</p>
			<p class="source-code">    Engine();</p>
			<p class="source-code">    // Run will call all the private functions</p>
			<p class="source-code">    void run();</p>
			<p class="source-code">};</p>
			<p>Here is a complete run down of all the private variables and functions. Where it is appropriate, I will spend a little longer on the explanation:</p>
			<ul>
				<li><strong class="source-inline">TextureHolder th</strong>: The one and only instance of the <strong class="source-inline">TextureHolder</strong> class.</li>
				<li><strong class="source-inline">TILE_SIZE</strong>: A useful constant to remind us that each tile in the sprite-sheet is 50 pixels wide and 50 pixels high.</li>
				<li><strong class="source-inline">VERTS_IN_QUAD</strong>: A useful constant to make our manipulation of a <strong class="source-inline">VertexArray</strong> less error-prone. There are, in fact, four vertices in a quad. Now, we can't forget it.</li>
				<li><strong class="source-inline">GRAVITY</strong>: A constant int value representing the number of pixels by which the game characters will be pushed downward each second. This is quite a fun value to play with once the game is done. We initialize it to 300 here as this works well for our initial level designs.</li>
				<li><strong class="source-inline">m_Window</strong>: The usual <strong class="source-inline">RenderWindow</strong> object that we have had in all our projects.</li>
				<li>The SFML <strong class="source-inline">View</strong> objects, <strong class="source-inline">m_MainView</strong>, <strong class="source-inline">m_LeftView</strong>, <strong class="source-inline">m_RightView</strong>, <strong class="source-inline">m_BGMainView</strong>: <strong class="source-inline">m_BGLeftView</strong>, <strong class="source-inline">m_BGRightView</strong>, and <strong class="source-inline">m_HudView</strong>: The first three <strong class="source-inline">View</strong> objects are for the full screen view and the left and right and split-screen views of the game. We also have a separate SFML <strong class="source-inline">View</strong> object for each of those three, which will draw the background behind. The last <strong class="source-inline">View</strong> object, <strong class="source-inline">m_HudView</strong>, will be drawn on top of the appropriate combination of the other six views to display the score, the remaining time, and any messages to the players. Having seven different <strong class="source-inline">View</strong> objects might imply complexity, but when you see how we deal with them as the chapter progresses, you will see they are quite straightforward. We will have the whole split-screen/full screen conundrum sorted out by the end of this chapter.</li>
				<li><strong class="source-inline">Sprite m_BackgroundSprite</strong> and <strong class="source-inline">Texture m_BackgroundTexture</strong>: Somewhat predictably, this combination of SFML Sprite and Texture will be for showing and holding the background graphic from the graphics assets folder.</li>
				<li><strong class="source-inline">m_Playing</strong>: This Boolean will keep the game engine informed about whether the level has started yet (by pressing the <em class="italic">Enter</em> key). The player does not have the option to pause the game once they have started it.</li>
				<li><strong class="source-inline">m_Character1</strong>: When the screen is full screen, should it center on Thomas (<strong class="source-inline">m_Character1</strong> <strong class="source-inline">= true</strong>) or Bob (<strong class="source-inline">m_Character1 = false</strong>)? Initially, it is initialized to true, to center on Thomas.</li>
				<li><strong class="source-inline">m_SplitScreen</strong>: This variable is used to determine whether the game currently being played is in split-screen mode or not. We will use this variable to decide how exactly to use all the View objects we declared a few steps ago.</li>
				<li><strong class="source-inline">m_TimeRemaining</strong> variable: This <strong class="source-inline">float</strong> variable holds how much time (in seconds) is remaining to get to the goal of the current level. In the previous code, it is set to 10 for the purposes of testing, until we get to set a specific time for each level.</li>
				<li><strong class="source-inline">m_GameTimeTotal</strong> variable: This variable is an SFML <strong class="source-inline">Time</strong> object. It keeps track of how long the game has been played for.</li>
				<li><strong class="source-inline">m_NewLevelRequired</strong> Boolean variable: This variable keeps an eye on whether the player has just completed or failed a level. We can then use it to trigger loading the next level or restarting the current level. </li>
				<li>The <strong class="source-inline">input</strong> function: This function will handle all the player's input, which in this game is entirely from the keyboard. At first glance, it would appear that it handles all the keyboard input directly. In this game, however, we will be handling keyboard input that directly affects Thomas or Bob within the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes. This function will also handle keyboard input such as quitting, switching to split-screen, and any other keyboard input.</li>
				<li>The <strong class="source-inline">update</strong> function: This function will do all the work that we previously did in the update section of the <strong class="source-inline">main</strong> function. We will also call some other functions from the <strong class="source-inline">update</strong> function in order to keep the code organized. If you look back at the code, you will see that it receives a <strong class="source-inline">float</strong> parameter that will hold the fraction of a second that has passed since the previous frame. This, of course, is just what we need to update all our game objects.</li>
				<li>The <strong class="source-inline">draw</strong> function: This function will hold all the code that used to go in the drawing section of the main function in previous projects. We will, however, have some drawing code that is not kept in this function when we look at other ways to draw with SFML. We will see this new code when we learn about particle systems in <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>, <em class="italic">Particle Systems and Shaders</em>.</li>
			</ul>
			<p>Now, let's run through all the public functions:</p>
			<ul>
				<li>The <strong class="source-inline">Engine</strong> constructor function: As we have come to expect, this function will be called when we first declare an instance of <strong class="source-inline">Engine</strong>. It will do all the setup and initialization of the class. We will see exactly what when we code the <strong class="source-inline">Engine.cpp</strong> file shortly.</li>
				<li>The <strong class="source-inline">run</strong> function: This is the only public function that we need to call. It will trigger the execution of <strong class="source-inline">input</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong>, and will do all the work for us.</li>
			</ul>
			<p>Next, we will see the definitions of all these functions and some of the variables in action.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor301"/>Coding Engine.cpp</h2>
			<p>In all our previous classes, we have put all the function definitions into the <strong class="source-inline">.cpp</strong> file prefixed with the class name. As our aim for this project is to make the code more manageable, we are doing things a little differently. </p>
			<p>In the <strong class="source-inline">Engine.cpp</strong> file, we will place the constructor (<strong class="source-inline">Engine</strong>) and the public <strong class="source-inline">run</strong> function. The rest of the functions will be going in their own <strong class="source-inline">.cpp</strong> file with a name that makes it clear which function goes where. This will not be a problem for the compiler if we add the appropriate include directive (<strong class="source-inline">#include "Engine.h"</strong>)<strong class="source-inline"> </strong>at the top of all the files that contain function definitions from the <strong class="source-inline">Engine</strong> class. </p>
			<p>Let's get started by coding <strong class="source-inline">Engine</strong> and running it in <strong class="source-inline">Engine.cpp</strong>. Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Engine.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">Engine</strong> class.</p>
			<h3>Coding the Engine class constructor definition</h3>
			<p>The code for this function will go in the <strong class="source-inline">Engine.cpp</strong> file we have recently created.</p>
			<p>Add the following code and then we can discuss it:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">Engine::Engine()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get the screen resolution </p>
			<p class="source-code">    // and create an SFML window and View</p>
			<p class="source-code">    Vector2f resolution;</p>
			<p class="source-code">    resolution.x = VideoMode::getDesktopMode().width;</p>
			<p class="source-code">    resolution.y = VideoMode::getDesktopMode().height;</p>
			<p class="source-code">    m_Window.create(VideoMode(resolution.x, resolution.y),</p>
			<p class="source-code">        "Thomas was late",</p>
			<p class="source-code">        Style::Fullscreen);</p>
			<p class="source-code">    // Initialize the full screen view</p>
			<p class="source-code">    m_MainView.setSize(resolution);</p>
			<p class="source-code">    m_HudView.reset(</p>
			<p class="source-code">        FloatRect(0, 0, resolution.x, resolution.y));</p>
			<p class="source-code">    // Initialize the split-screen Views</p>
			<p class="source-code">    m_LeftView.setViewport(</p>
			<p class="source-code">        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));</p>
			<p class="source-code">    m_RightView.setViewport(</p>
			<p class="source-code">        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));</p>
			<p class="source-code">    m_BGLeftView.setViewport(</p>
			<p class="source-code">        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));</p>
			<p class="source-code">    m_BGRightView.setViewport(</p>
			<p class="source-code">        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));</p>
			<p class="source-code">    </p>
			<p class="source-code">    m_BackgroundTexture = TextureHolder::GetTexture(</p>
			<p class="source-code">        "graphics/background.png");</p>
			<p class="source-code">    // Associate the sprite with the texture</p>
			<p class="source-code">    m_BackgroundSprite.setTexture(m_BackgroundTexture);</p>
			<p class="source-code">}</p>
			<p>We have seen much of this code before. For example, there are the usual lines of code to get the screen resolution, as well as to create a <strong class="source-inline">RenderWindow</strong>. At the end of the previous code, we use the now-familiar code to load a texture and assign it to a Sprite. In this case, we are loading the <strong class="source-inline">background.png</strong> texture and assigning it to <strong class="source-inline">m_BackgroundSprite</strong>.</p>
			<p>It is the code in between the four calls to the <strong class="source-inline">setViewport</strong> function that needs some explanation. The <strong class="source-inline">setViewport</strong> function assigns a portion of the screen to an SFML <strong class="source-inline">View</strong> object. It doesn't work with pixel coordinates, however. It works using a ratio. Here, "1" is the entire screen (width or height). The first two values in each call to <strong class="source-inline">setViewport</strong> are the starting position (horizontally then vertically), while the last two are the ending position.</p>
			<p>Notice that <strong class="source-inline">m_LeftView</strong> and <strong class="source-inline">m_BGLeftView</strong> are placed in exactly the same place, that is, starting on virtually the far-left (0.001) of the screen and ending two-thousandths from the center (0.498). </p>
			<p><strong class="source-inline">m_RightView</strong> and <strong class="source-inline">m_BGRightView</strong> are also in exactly the same position as each other, starting just right of the previous two <strong class="source-inline">View</strong> objects (0.5) and extending to almost the far-right-hand side (0.998).</p>
			<p>Furthermore, all the views leave a tiny slither of a gap at the top and bottom of the screen. When we draw these <strong class="source-inline">View</strong> objects on the screen, on top of a white background, it will have the effect of splitting the screen with a thin white line between the two sides of the screen, as well as a thin white border around the edges.</p>
			<p>I have tried to represent this effect in the following diagram:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Image90695.jpg" alt=""/>
				</div>
			</div>
			<p>The best way to understand it is to finish this chapter, run the code, and see it in action.</p>
			<h3>Coding the run function definition</h3>
			<p>The code for this function will go in the <strong class="source-inline">Engine.cpp</strong> file we have recently created.</p>
			<p>Add the following code immediately after the previous constructor code:</p>
			<p class="source-code">void Engine::run()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Timing     </p>
			<p class="source-code">    Clock clock;</p>
			<p class="source-code">    while (m_Window.isOpen())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Time dt = clock.restart();</p>
			<p class="source-code">        // Update the total game time</p>
			<p class="source-code">        m_GameTimeTotal += dt;</p>
			<p class="source-code">        // Make a decimal fraction from the delta time</p>
			<p class="source-code">        float dtAsSeconds = dt.asSeconds();</p>
			<p class="source-code">        // Call each part of the game loop in turn</p>
			<p class="source-code">        input();</p>
			<p class="source-code">        update(dtAsSeconds);</p>
			<p class="source-code">        draw();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">run</strong> function is the center of our engine; it initiates all the other parts. First, we declare a <strong class="source-inline">Clock</strong> object. Next, we have the familiar <strong class="source-inline">while(window.isOpen())</strong> loop, which creates the game loop. Inside this while loop, we do the following:</p>
			<ol>
				<li value="1">Restart <strong class="source-inline">clock</strong> and save the time that the previous loop took in <strong class="source-inline">dt.</strong></li>
				<li>Keep track of the total time elapsed in <strong class="source-inline">m_GameTimeTotal.</strong></li>
				<li>Declare and initialize a <strong class="source-inline">float</strong> to represent the fraction of a second that elapsed during the previous frame.</li>
				<li>Call <strong class="source-inline">input.</strong></li>
				<li>Call <strong class="source-inline">update</strong>, passing in the elapsed time (<strong class="source-inline">dtAsSeconds</strong>).</li>
				<li>Call <strong class="source-inline">draw.</strong></li>
			</ol>
			<p>All of this should look very familiar. What's new is that it is wrapped in the <strong class="source-inline">run</strong> function.</p>
			<h3>Coding the input function definition</h3>
			<p>As we explained previously, the code for the <strong class="source-inline">input</strong> function will go in its own file because it is more extensive than the constructor or the <strong class="source-inline">run</strong> function. We will use <strong class="source-inline">#include "Engine.h"</strong> and prefix the function signature with <strong class="source-inline">Engine::</strong> to make sure the compiler is aware of our intentions.</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Input.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">input </strong>function.</p>
			<p>Add the following code:</p>
			<p class="source-code">void Engine::input()</p>
			<p class="source-code">{</p>
			<p class="source-code">    Event event;</p>
			<p class="source-code">    while (m_Window.pollEvent(event))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (event.type == Event::KeyPressed)</p>
			<p class="source-code">        {            </p>
			<p class="source-code">            // Handle the player quitting</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_Window.close();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            // Handle the player starting the game</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::Return))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_Playing = true;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            // Switch between Thomas and Bob</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::Q))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_Character1 = !m_Character1;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            // Switch between full and split-screen</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::E))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_SplitScreen = !m_SplitScreen;</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }    </p>
			<p class="source-code">}</p>
			<p>Like the previous projects, we check the <strong class="source-inline">RenderWindow</strong> event queue each frame. Also like we've already done before, we detect specific keyboard keys using <strong class="source-inline">if (Keyboard::isKeyPressed...</strong>. The most relevant information in the code we just added is what the keys do:</p>
			<ul>
				<li>As per usual, the <em class="italic">Esc</em> key closes the window and the game will quit.</li>
				<li>The <em class="italic">Enter</em> key sets <strong class="source-inline">m_Playing</strong> to true and eventually this will have the effect of starting the level.</li>
				<li>The <em class="italic">Q</em> key alternates the value of <strong class="source-inline">m_Character1</strong> between true and false. This key only has an effect in full screen mode. It will switch between Thomas and Bob being the center of the main <strong class="source-inline">View</strong>.</li>
				<li>The <em class="italic">E</em> keyboard key switches <strong class="source-inline">m_SplitScreen</strong> between true and false. This will have the effect of switching between full screen and split-screen views.</li>
			</ul>
			<p>Most of this keyboard functionality will be fully working by the end of this chapter. We are getting close to being able to run our game engine. Next, let's code the <strong class="source-inline">update</strong> function.</p>
			<h3>Coding the update function definition</h3>
			<p>As we explained previously, the code for this function will go in its own file because it is more extensive than the constructor or the <strong class="source-inline">run</strong> function. We will use <strong class="source-inline">#include "Engine.h"</strong> and prefix the function signature with <strong class="source-inline">Engine::</strong> to make sure the compiler is aware of our intentions.</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Update.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to write some code for the <strong class="source-inline">update </strong>function.</p>
			<p>Add the following code to the <strong class="source-inline">Update.cpp </strong>file to implement the <strong class="source-inline">update</strong> function:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">void Engine::update(float dtAsSeconds)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Playing)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Count down the time the player has left</p>
			<p class="source-code">        m_TimeRemaining -= dtAsSeconds;</p>
			<p class="source-code">        // Have Thomas and Bob run out of time?</p>
			<p class="source-code">        if (m_TimeRemaining &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_NewLevelRequired = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }// End if playing</p>
			<p class="source-code">        </p>
			<p class="source-code">}</p>
			<p>First, notice that the <strong class="source-inline">update</strong> function receives the time the previous frame took as a parameter. This, of course, will be essential for the update function to fulfill its role.</p>
			<p>The previous code doesn't achieve anything visible at this stage. It does put in the structure that we will require for future chapters. It subtracts the time the previous frame took from <strong class="source-inline">m_TimeRemaining</strong> and checks whether time has run out. If it has, it sets <strong class="source-inline">m_NewLevelRequired</strong> to <strong class="source-inline">true</strong>. All this code is wrapped in an <strong class="source-inline">if</strong> statement that only executes when <strong class="source-inline">m_Playing</strong> is <strong class="source-inline">true</strong>. The reason for this is that, like the previous projects, we don't want time advancing and objects updating when the game has not started.</p>
			<p>We will build on this code as the project continues.</p>
			<h3>Coding the draw function definition</h3>
			<p>As we explained previously, the code for this function will go in its own file because it is more extensive than the constructor or the <strong class="source-inline">run</strong> function. We will use <strong class="source-inline">#include "Engine.h"</strong> and prefix the function signature with <strong class="source-inline">Engine::</strong> to make sure the compiler is aware of our intentions.</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Draw.cpp</strong>. Finally click the <strong class="bold">Add</strong> button. We are now ready to add some code to the <strong class="source-inline">draw </strong>function.</p>
			<p>Add the following code to the <strong class="source-inline">Draw.cpp</strong> file to implement the <strong class="source-inline">draw</strong> function:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">void Engine::draw()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Rub out the last frame</p>
			<p class="source-code">    m_Window.clear(Color::White);</p>
			<p class="source-code">    if (!m_SplitScreen)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGMainView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_MainView</p>
			<p class="source-code">        m_Window.setView(m_MainView);        </p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Split-screen view is active</p>
			<p class="source-code">        // First draw Thomas' side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGLeftView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_LeftView</p>
			<p class="source-code">        m_Window.setView(m_LeftView);</p>
			<p class="source-code">        </p>
			<p class="source-code">        // Now draw Bob's side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGRightView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_RightView</p>
			<p class="source-code">        m_Window.setView(m_RightView);</p>
			<p class="source-code">                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Draw the HUD</p>
			<p class="source-code">    // Switch to m_HudView</p>
			<p class="source-code">    m_Window.setView(m_HudView);</p>
			<p class="source-code">    </p>
			<p class="source-code">    </p>
			<p class="source-code">    // Show everything we have just drawn</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}</p>
			<p>In the previous code, there is nothing we haven't seen before. The code starts, as usual, by clearing the screen. In this project, we clear the screen with White. What's new is the way the different drawing options are separated by a condition that checks whether the screen is currently split or not:</p>
			<p class="source-code">if (!m_SplitScreen)</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>If the screen is not split, we draw the background sprite in the background <strong class="source-inline">View</strong> (<strong class="source-inline">m_BGView</strong>) and then switch to the main full screen <strong class="source-inline">View</strong> (<strong class="source-inline">m_MainView</strong>). Note that, currently, we don't do any drawing in <strong class="source-inline">m_MainView</strong>.</p>
			<p>If, on the other hand, the screen is split, the code in the <strong class="source-inline">else</strong> block is executed and we draw <strong class="source-inline">m_BGLeftView</strong> with the background sprite on the left of the screen, followed by switching to <strong class="source-inline">m_LeftView</strong>.</p>
			<p>Then, still in the <strong class="source-inline">else</strong> block, we draw <strong class="source-inline">m_BGRightView</strong> with the background sprite on the right of the screen, followed by switching to <strong class="source-inline">m_RightView</strong>.</p>
			<p>Outside of the <strong class="source-inline">if</strong> <strong class="source-inline">else</strong> structure we just described, we switch to the <strong class="source-inline">m_HUDView</strong>. At this stage, we are not actually drawing anything in <strong class="source-inline">m_HUDView</strong>.</p>
			<p>Like  the other two (<strong class="source-inline">input</strong>, <strong class="source-inline">update</strong>) of the three most significant functions, we will go back to the <strong class="source-inline">draw</strong> function often. We will add new elements for our game that need to be drawn. You will notice that, each time we do, we will add code into each of the main, left-hand, and right-hand sections. </p>
			<p>Let's quickly recap on the <strong class="source-inline">Engine</strong> class and then we can fire it up.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor302"/>The Engine class so far</h2>
			<p>What we have done is abstract  all the code that used to be in the <strong class="source-inline">main</strong> function into the <strong class="source-inline">input</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong> functions. The continuous looping of these functions, as well as the timing, is handled by the <strong class="source-inline">run</strong> function.</p>
			<p>Consider leaving the <strong class="bold">Input.cpp</strong>, <strong class="bold">Update.cpp</strong>, and<strong class="bold"> Draw.cpp</strong> tabs open in Visual Studio, perhaps organized in order, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B14278_14_09.jpg" alt=""/>
				</div>
			</div>
			<p>We will revisit each of these functions throughout the course of the project and add more code. Now that we have the basic structure and functionality of the <strong class="source-inline">Engine</strong> class, we can create an instance of it in the <strong class="source-inline">main</strong> function and see it in action.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor303"/>Coding the main function</h1>
			<p>Let's rename the <strong class="source-inline">TFL.cpp</strong> file that was autogenerated when the project was created to <strong class="source-inline">Main.cpp</strong>. Right-click the <strong class="source-inline">TFL</strong> file in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Rename</strong>. Change the name to <strong class="source-inline">Main.cpp</strong>. This will be the file that contains our <strong class="source-inline">main</strong> function and the code that instantiates the <strong class="source-inline">Engine</strong> class.</p>
			<p>Add the following code to <strong class="source-inline">Main.cpp</strong>:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Declare an instance of Engine</p>
			<p class="source-code">    Engine engine;</p>
			<p class="source-code">    // Start the engine VRRrrrrmmm</p>
			<p class="source-code">    engine.run();</p>
			<p class="source-code">    // Quit in the usual way when the engine is stopped</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>All we do is add an <strong class="source-inline">include</strong> directive for the <strong class="source-inline">Engine</strong> class, declare an instance of <strong class="source-inline">Engine</strong>, and then call its <strong class="source-inline">run</strong> function. Everything will be handled by the <strong class="source-inline">Engine</strong> class until the player quits and the execution returns to <strong class="source-inline">main</strong> and the <strong class="source-inline">return 0</strong> statement.</p>
			<p>That was easy. Now, we can run the game and see the empty background, either in full screen or split-screen, which will eventually contain all the action.</p>
			<p>Here is the game so far in full screen mode, showing just the background:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B14278_14_10.jpg" alt=""/>
				</div>
			</div>
			<p>Now, tap the <em class="italic">E</em> key. You will be able to see the screen neatly partitioned into two halves, ready for split-screen coop gameplay:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B14278_14_11.jpg" alt=""/>
				</div>
			</div>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor304"/>Summary</h1>
			<p>In this chapter, we introduced the Thomas Was Late game and laid the foundations of understanding as well as the code structure for the rest of the project. It is certainly true that there are a lot of files in the Solution Explorer but, provided we understand the purpose of each, we will find the implementation of the rest of the project quite easy.</p>
			<p>In the next chapter, we will learn about two more fundamental C++ topics, inheritance and polymorphism. We will also begin to put them to use by building three classes to represent two playable characters. </p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor305"/>FAQ</h1>
			<p>Here is a question that might be on your mind:</p>
			<p>Q) I don't fully understand the structure of the code files. What should I do?</p>
			<p>A) It is true that abstraction can make the structure of our code less clear, but the actual code itself becomes so much easier. Instead of cramming everything into the <strong class="source-inline">main</strong> function like we did in the previous projects, we will split the code up into <strong class="source-inline">Input.cpp</strong>, <strong class="source-inline">Update.cpp</strong>, and <strong class="source-inline">Draw.cpp</strong>. Furthermore, we will use more classes to group together related code as we proceed. Study the <em class="italic">Structuring the Thomas Was Late code</em> section again, especially the diagrams.</p>
		</div>
	</body></html>