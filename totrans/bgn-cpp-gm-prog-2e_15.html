<html><head></head><body>
		<div><h1 id="_idParaDest-283"><a id="_idTextAnchor292"/><em class="italic">Chapter 14</em>: Abstraction and Code Management – Making Better Use of OOP</h1>
			<p>In this chapter, we will take a first look at the penultimate project of this book. The project we will be building will use advanced features such as directional sound, which has the effect of appearing to play relative to the position of the player. It will also have split-screen cooperative gameplay. In addition, this project will introduce the concept of <strong class="bold">Shaders</strong>, which are programs written in another language that run directly on the graphics card. By the end of <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>,<em class="italic"> Particle Systems and Shaders</em>, you will have a fully functioning, multiplayer platform game built in the style of the hit classic <em class="italic">Thomas Was Alone</em>.</p>
			<p>This chapter's focus will be getting the project started and exploring how the code will be structured to make better use of OOP. Here are the details of the topics that will be covered in this chapter:</p>
			<ul>
				<li>Introducing the final project, <strong class="bold">Thomas Was Late</strong>, including the gameplay features and project assets</li>
				<li>A detailed discussion of how we will improve the structure of the code compared to previous projects</li>
				<li>Coding the Thomas Was Late game engine</li>
				<li>Implementing split-screen functionality</li>
			</ul>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor293"/>The Thomas Was Late game</h1>
			<p class="callout-heading">Tip</p>
			<p class="callout">At this point, if you haven't already, I suggest that you go and watch a video of Thomas Was Alone at <a href="http://store.steampowered.com/app/220780/">http://store.steampowered.com/app/220780/</a>.</p>
			<p>Notice the simple but aesthetically excellent graphics. The video also shows a variety of gameplay challenges such as using the character's different attributes (height, jump, power, and so on). To keep our game simple without losing the challenge, we will have fewer puzzle features than Thomas Was Alone but will have the additional challenge of creating the need for two players to play cooperatively. Just to make sure the game is not too easy, we will also make the players have to rush to beat the clock, which is why the name of our game is Thomas Was Late.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor294"/>Features of Thomas Was Late</h2>
			<p>Our game will not be nearly as advanced as the masterpiece that we are attempting to emulate, but it will have a good selection of exciting game-play features, such as the following:</p>
			<ul>
				<li>A clock that counts down from a time appropriate to the challenge of the level.</li>
				<li>Fire pits that emit a roar relative to the position of the player and respawn the player at the start if they fall in. Water pits have the same effect but without the directional sound effects.</li>
				<li>Cooperative gameplay. Both players will have to get their characters to the goal within the allotted time. They will need to work together frequently so that the shorter, lower-jumping Bob will need to stand on his friend's (Thomas') head.</li>
				<li>The player will have the option of switching between full and split-screen so they can attempt to control both characters themselves.</li>
				<li>Each level will be designed in, and loaded from, a text file. This will make it easy to design varied and numerous levels.</li>
			</ul>
			<p>Take a look at the following annotated screenshot of the game to see some of the features in action and the components/assets that make up the game:</p>
			<div><div><img src="img/B14278_14_01a.jpg" alt=""/>
				</div>
			</div>
			<p>Let's look at each of these features and describe a few more:</p>
			<ul>
				<li>The preceding screenshot shows a simple HUD that details the level number and the number of seconds remaining until the player(s) fail and must restart the level.</li>
				<li>You can also clearly see the split-screen coop in action. Remember that this is optional. A single player can take on the game, fullscreen, while switching the camera focus between Thomas and Bob.</li>
				<li>It is not very clear in the preceding screenshot (especially in print), but when a character dies, they will explode in a starburst/firework-like particle effect.</li>
				<li>The water and fire tiles can be strategically placed to make the level fun, as well as forcing cooperation between the characters. More on this will be covered in <a href="B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327"><em class="italic">Chapter 16</em></a>,<em class="italic"> Building Playable Levels and Collision Detection</em>.</li>
				<li>Next, notice Thomas and Bob. They are not only different in height but also have significantly varied jumping abilities. This means that Bob is dependent upon Thomas for big jumps, and levels can be designed to force Thomas to take a specific route to avoid him "banging his head".</li>
				<li>In addition, the fire tiles will emit a roaring sound. These will be relative to the position of Thomas. Not only will they be directional and come from either the left or right speaker, they will also get louder and quieter as Thomas moves closer to or further away from the source.</li>
				<li>Finally, in the preceding annotated screenshot, you can see the background. Why not compare how that looks to the <code>background.png</code> file (shown later in this chapter)? You will see it is quite different. We will use OpenGL shader effects in <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>, <em class="italic">Particle Systems and Shaders</em>, to achieve the moving, almost bubbling, effect in the background.</li>
			</ul>
			<p>All of these features warrant a few more screenshots so that we can keep the finished product in mind as we write the C++ code.</p>
			<p>The following screenshot shows Thomas and Bob arriving at a fire pit that Bob has no chance of jumping over without help:</p>
			<div><div><img src="img/B14278_14_01b.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot shows Bob and Thomas collaborating to clear a precarious jump:</p>
			<div><div><img src="img/B14278_14_01c.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot shows how we can design puzzles where a "leap of faith" is required in order to reach the goal:</p>
			<div><div><img src="img/B14278_14_01d.jpg" alt=""/>
				</div>
			</div>
			<p>The following screenshot demonstrates how we can design oppressive cave systems of almost any size. We can also devise levels where Bob and Thomas are forced to split up and go different routes:</p>
			<div><div><img src="img/B14278_14_01e.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor295"/>Creating the project</h2>
			<p>Creating the Thomas Was Late project will follow the same procedure that we used in the previous three projects. Since creating a project is a slightly fiddly process, I will detail all the steps again here. For even more detail and images, refer to setting up the Timber!!! project in <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>:</p>
			<ol>
				<li value="1">Start Visual Studio and click on the <strong class="bold">Create New Project</strong> button. If you have another project open, you can select <strong class="bold">File</strong> | <strong class="bold">New project</strong>.</li>
				<li>In the window shown next, choose <strong class="bold">Console app</strong> and click the <strong class="bold">Next</strong> button. You will then see the <strong class="bold">Configure your new project</strong> window. </li>
				<li>In the <code>TWL</code> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field.</li>
				<li>In the <code>VS Projects</code> folder.</li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>. </li>
				<li>When you have completed these steps, click <strong class="bold">Create</strong>.</li>
				<li>We will now configure the project to use the SFML files that we put in the <code>SFML</code> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">TWL properties…</strong>. At this stage, you should have the <strong class="bold">TWL Property Pages</strong> window open. </li>
				<li>In the <strong class="bold">TWL Property Pages</strong> window, take the following steps. Select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> dropdown.</li>
				<li>Now, select <strong class="bold">C/C++</strong> and then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>Now, locate the <code>\SFML\include</code>. The full path to type, if you located your <code>SFML</code> folder on your D drive, is <code>D:\SFML\include</code>. Vary your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform the following steps. From the left-hand menu, select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <code>SFML</code> folder is, followed by <code>\SFML\lib</code>. So, the full path to type if you located your <code>SFML</code> folder on your D drive is <code>D:\SFML\lib</code>. Vary your path if you installed SFML to a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Next, still in the same window, perform these steps. Switch the <strong class="bold">Configuration:</strong> dropdown to <strong class="bold">Debug </strong>as we will be running and testing Pong in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong>.</li>
				<li>Find the <code>sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</code>. Be extra careful to place the cursor exactly at the start of the edit box's current content so that you don't overwrite any of the text that is already there.</li>
				<li>Click <strong class="bold">OK</strong>.</li>
				<li>Click <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
			</ol>
			<p>That's the project properties configured and ready to go. Now, we need to copy the SFML <code>.dll</code> files into the main project directory by following these steps:</p>
			<ol>
				<li value="1">My main project directory is <code>D:\VS Projects\TWL</code>. This folder was created by Visual Studio in the previous steps. If you put your <code>Projects</code> folder somewhere else, then perform this step there instead. The files we need to copy into the project folder are located in our <code>SFML\bin</code> folder. Open a window for each of the two locations and highlight all the <code>.dll</code> files.</li>
				<li>Now, copy and paste the highlighted files into the project.</li>
			</ol>
			<p>The project is now set up and ready to go. </p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor296"/>The project's assets</h2>
			<p>The assets in this project are even more numerous and diverse than the Zombie Arena game. As usual, the assets include a font for the writing on the screen, sound effects for different actions such as jumping, reaching the goal, or the distant roar of fire, and, of course, graphics for Thomas and Bob as well as a sprite sheet for all the background tiles.</p>
			<p>All of the assets that are required for this game are included in the download bundle. They can be found in the <code>Chapter 14/graphics</code> and <code>Chapter 14/sound</code> folders.</p>
			<p>In addition to the graphics, sounds, and fonts that we have come to expect, this game has two new asset types. They are level design files and GLSL shader programs. Let's find out about each of them.</p>
			<h3>Game level designs</h3>
			<p>Levels are all created in a text file. By using the numbers 0 through 3, we can build level designs to challenge players. All the level designs are in the <code>levels</code> folder in the same directory as the other assets. Feel free to take a peek at one now, but we will look at them in detail in <em class="italic">Chapter 18</em>, <em class="italic">Particle Systems and Shaders</em>.</p>
			<p>In addition to these level design assets, we have a special type of graphical asset called <strong class="bold">shaders</strong>.</p>
			<h3>GLSL shaders</h3>
			<p><code>Chapter 14/shaders</code> folder of the download bundle.</p>
			<h3>The graphical assets close up</h3>
			<p>The graphical assets make up the parts of the scene of our game. If you take a look at the graphical assets, it should be clear where in our game they will be used:</p>
			<div><div><img src="img/B14278_14_03.jpg" alt=""/>
				</div>
			</div>
			<p>If the tiles on the <code>tiles_sheet</code> graphic look a little different to the screenshots of the game, this is because they are partly transparent and the background showing through changes them a little. If the background graphic looks totally different to the actual background in the game screenshots, that is because the shader programs we will write will manipulate each and every pixel, each and every frame, to create a kind of "molten" effect.</p>
			<h3>The sound assets close up</h3>
			<p>The sound files are all in <code>.wav</code> format. These files contain the sound effects that we will play at certain events throughout the game. They are as follows:</p>
			<ul>
				<li><code>fallinfire.wav</code>: A sound that will be played when the player's head goes into fire and the player has no chance of escape.</li>
				<li><code>fallinwater.wav</code>: Water has the same end effect as fire: death. This sound effect notifies the player that they need to start from the beginning of the level.</li>
				<li><code>fire1.wav</code>: This sound effect is recorded in mono. It will be played at different volumes, based on the player's distance from fire tiles and from different speakers based on whether the player is to the left or the right of the fire tile. Clearly, we will need to learn a few more tricks to implement this functionality.</li>
				<li><code>jump.wav</code>: A pleasing (slightly predictable) whooping sound for when the player jumps.</li>
				<li><code>reachgoal.wav</code>: A pleasing victory sound for when the player(s) get both characters (Thomas and Bob) to the goal tile.</li>
			</ul>
			<p>The sound effects are very straightforward, and you can easily create your own. If you intend to replace the <code>fire1.wav </code>file, be sure to save your sounds in mono (not stereo) format. The reasons for this will be explained in <a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>,<em class="italic"> Sound Spatialization and HUD.</em></p>
			<h3>Adding the assets to the project</h3>
			<p>Once you have decided which assets you will use, it is time to add them to the project. The following instructions will assume you are using all the assets that were supplied in this book's download bundle. </p>
			<p>Where you are using your own, simply replace the appropriate sound or graphic file with your own, using exactly the same filename. Let's get started:</p>
			<ol>
				<li value="1">Browse to the <code>D:\VS Projects\TWL</code> folder.</li>
				<li>Create five new folders within this folder and name them <code>graphics</code>, <code>sound</code>, <code>fonts</code>,<code> shaders, </code>and<code> levels</code>.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 14/graphics</code> into the <code>D:\VS Projects\TWL\graphics</code> folder.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 14/sound</code> into the <code>D:\VS Projects\TWL\sound</code> folder.</li>
				<li>Now, visit <a href="http://www.dafont.com/roboto.font">http://www.dafont.com/roboto.font</a> in your web browser and download the <strong class="bold">Roboto Light</strong> font.</li>
				<li>Extract the contents of the zipped download and add the <code>Roboto-Light.ttf</code> file to the <code>D:\VS Projects\TWL\fonts</code> folder.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 12/levels </code>into the <code>D:\VS Projects\TWL\levels</code> folder.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 12/shaders </code>into the <code>D:\VS Projects\TWL\shaders</code> folder.</li>
			</ol>
			<p>Now that we have a new project, along with all the assets we will need for the entire project, we can talk about how we will structure the game engine code.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor297"/>Structuring the Thomas Was Late code</h1>
			<p>One of the problems that has been getting worse from project to project, despite taking measures to reduce the problem, is how long and unwieldy the code gets. <strong class="bold">Object-oriented programming</strong> (<strong class="bold">OOP</strong>) allows us to break our projects up into logical and manageable chunks, known as classes.</p>
			<p>We will make a big improvement to the manageability of the code in this project with the introduction of an <code>Engine</code> class. Among other functions, the <code>Engine</code> class will have three private functions. These are <code>input</code>, <code>update</code>, and <code>draw</code>. These should sound very familiar. Each of these functions will hold a chunk of the code that was previously in the <code>main</code> function. Each of these functions will be in a code file of its own, that is, <code>Input.cpp</code>, <code>Update.cpp</code>, and <code>Draw.cpp</code>, respectively.</p>
			<p>There will also be one public function in the <code>Engine</code> class, which can be called with an instance of <code>Engine</code>. This function is <code>run</code> and will be responsible for calling <code>input</code>, <code>update</code>, and <code>draw</code> once for each frame of the game:</p>
			<div><div><img src="img/B14278_14_06.jpg" alt=""/>
				</div>
			</div>
			<p>Furthermore, because we have abstracted the major parts of the game engine to the <code>Engine</code> class, we can also move many of the variables from <code>main</code> and make them members of <code>Engine</code>. All we need to do to get our game engine fired up is create an instance of <code>Engine</code> and call its <code>run</code> function. Here is a sneak preview of the super-simple <code>main</code> function:</p>
			<pre>int main()
{
    // Declare an instance of Engine
    Engine engine;
    // Start the engine
    engine.run();
    // Quit in the usual way when the engine is stopped
    return 0;
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't add the previous code just yet.</p>
			<p>To make our code even more manageable and readable, we will also abstract responsibility for big tasks such as loading a level and collision detection to separate functions (in separate code files). These two functions are <code>loadLevel</code> and <code>detectCollisions</code>. We will also code other functions to handle some of the new features of the Thomas Was Late project. We will cover them in detail, as and when they occur.</p>
			<p>To further take advantage of OOP, we will delegate responsibility for areas of the game entirely to new classes. You probably remember that the sound and HUD code was quite lengthy in previous projects. We will build a <code>SoundManager</code> and <code>HUD</code> class to handle these aspects in a cleaner manner. Exactly how they work will be explored in depth when we implement them. </p>
			<p>The game levels themselves are also much more in-depth than previous games, so we will also code a <code>LevelManager</code> class.</p>
			<p>As you would expect, the playable characters will be made with classes as well. For this project, however, we will learn some more C++ and implement a <code>PlayableCharacter</code> class with all the common functionality of Thomas and Bob. Then, the <code>Thomas</code> and <code>Bob</code> classes will <em class="italic">inherit</em> this common functionality as well as implementing their own unique functions and abilities. This technique, perhaps unsurprisingly, is called <strong class="bold">inheritance</strong>. I will go into more detail about inheritance in the next chapter: <a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>, <em class="italic">Advanced OOP – Inheritance and Polymorphism</em>.</p>
			<p>We will also implement several other classes to perform specific responsibilities. For example, we will make some neat explosions using particle systems. You might be able to guess that, to do this, we will code a <code>Particle</code> class and a <code>ParticleSystem</code> class. All these classes will have instances that are members of the <code>Engine</code> class. Doing things this way will make all the features of the game accessible from the game engine but encapsulate the details into the appropriate classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note that despite these new techniques to separate out the different aspects of our code, by the end of this project, we will still have some slightly unwieldy classes. The final project of this book, while a much simpler shooter game, will explore one more way of organizing our code to make it manageable.</p>
			<p>The last thing to mention before we move on to seeing the actual code that will make the <code>Engine</code> class is that we will reuse, without any changes whatsoever, the <code>TextureHolder</code> class that we discussed and coded for the Zombie Arena game.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor298"/>Building the game engine</h1>
			<p>As we suggested in the previous section, we will code a class called <code>Engine</code> that will control and bind the different parts of the Thomas Was Late game.</p>
			<p>The first thing we will do is make the <code>TextureHolder</code> class from the previous project available in this one.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor299"/>Reusing the TextureHolder class</h2>
			<p>The <code>TextureHolder</code> class that we discussed and coded for the Zombie Arena game will also be useful in this project. While it is possible to add the files (<code>TextureHolder.h</code> and <code>TextureHolder.cpp</code>) directly from the previous project, without recoding them or recreating the files, I don't want to assume that you haven't jumped straight to this project. What follows is very brief instructions, along with the complete code listing we need, to create the <code>TextureHolder</code> class. If you want the class or the code explained, please see <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>, <em class="italic">Pointers, the Standard Template Library, and Texture Management</em>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you did complete the previous project and you <em class="italic">do</em> want to add the class from the Zombie Arena project, simply do the following. In the <code>TextureHolder.h</code> from the previous project and select it. In the <code>TextureHolder.cpp</code> from the previous project and select it. You can now use the <code>TextureHolder</code> class in this project. Note that the files are shared between projects and any changes will take effect in both projects.</p>
			<p>To create the <code>TextureHolder</code> class from scratch, right-click <code>TextureHolder.h</code>. Finally, click the <strong class="bold">Add</strong> button.</p>
			<p>Add the following code to <code>TextureHolder.h</code>:</p>
			<pre>#pragma once
#ifndef TEXTURE_HOLDER_H
#define TEXTURE_HOLDER_H
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;map&gt;
class TextureHolder
{
private:
    // A map container from the STL,
    // that holds related pairs of String and Texture
    std::map&lt;std::string, sf::Texture&gt; m_Textures;
    // A pointer of the same type as the class itself
    // the one and only instance
    static TextureHolder* m_s_Instance;
public:
    TextureHolder();
    static sf::Texture&amp; GetTexture(std::string const&amp; filename);
};
#endif</pre>
			<p>Right-click <code>TextureHolder.cpp</code>. Finally, click the <strong class="bold">Add</strong> button.</p>
			<p>Add the following code to <code>TextureHolder.cpp</code>:</p>
			<pre>#include "TextureHolder.h"
#include &lt;assert.h&gt;
using namespace sf;
using namespace std;
TextureHolder* TextureHolder::m_s_Instance = nullptr;
TextureHolder::TextureHolder()
{
    assert(m_s_Instance == nullptr);
    m_s_Instance = this;
}
sf::Texture&amp; TextureHolder::GetTexture(std::string const&amp; filename)
{
    // Get a reference to m_Textures using m_S_Instance
    auto&amp; m = m_s_Instance-&gt;m_Textures;
    // auto is the equivalent of map&lt;string, Texture&gt;
    // Create an iterator to hold a key-value-pair (kvp)
    // and search for the required kvp
    // using the passed in file name
    auto keyValuePair = m.find(filename);
    // auto is equivalent of map&lt;string, Texture&gt;::iterator
    // Did we find a match?
    if (keyValuePair != m.end())
    {
        // Yes
        // Return the texture,
        // the second part of the kvp, the texture
        return keyValuePair-&gt;second;
    }
    else
    {
        // File name not found
        // Create a new key value pair using the filename
        auto&amp; texture = m[filename];
        // Load the texture from file in the usual way
        texture.loadFromFile(filename);
        // Return the texture to the calling code
        return texture;
    }
}</pre>
			<p>We can now get on with our new <code>Engine</code> class.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor300"/>Coding Engine.h</h2>
			<p>As usual, we will start with the header file, which holds the function declarations and member variables. Note that we will revisit this file throughout the project to add more functions and member variables. At this stage, we will add just the code that is necessary.</p>
			<p>Right-click <code>Engine.h</code>. Finally, click the <code>Engine</code> class.</p>
			<p>Add the following member variables, as well as the function declarations. Many of them we have seen before in the other projects and some of them were discussed in the <em class="italic">Structuring the Thomas Was Late Code</em> section. Take note of the function and variable names, as well as whether they are private or public. Add the following code to the <code>Engine.h</code> file and then we will talk about it:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "TextureHolder.h"
using namespace sf;
class Engine
{
private:
    // The texture holder
    TextureHolder th;
    const int TILE_SIZE = 50;
    const int VERTS_IN_QUAD = 4;
    // The force pushing the characters down
    const int GRAVITY = 300;
    // A regular RenderWindow
    RenderWindow m_Window;
    // The main Views
    View m_MainView;
    View m_LeftView;
    View m_RightView;
    // Three views for the background
    View m_BGMainView;
    View m_BGLeftView;
    View m_BGRightView;
    View m_HudView;
    // Declare a sprite and a Texture 
    // for the background
    Sprite m_BackgroundSprite;
    Texture m_BackgroundTexture;
    // Is the game currently playing?
    bool m_Playing = false;
    // Is character 1 or 2 the current focus?
    bool m_Character1 = true;
    // Start in full screen (not split) mode
    bool m_SplitScreen = false;
    // Time left in the current level (seconds)
    float m_TimeRemaining = 10;
    Time m_GameTimeTotal;
    // Is it time for a new/first level?
    bool m_NewLevelRequired = true;
    
    // Private functions for internal use only
    void input();
    void update(float dtAsSeconds);
    void draw();
    
public:
    // The Engine constructor
    Engine();
    // Run will call all the private functions
    void run();
};</pre>
			<p>Here is a complete run down of all the private variables and functions. Where it is appropriate, I will spend a little longer on the explanation:</p>
			<ul>
				<li><code>TextureHolder th</code>: The one and only instance of the <code>TextureHolder</code> class.</li>
				<li><code>TILE_SIZE</code>: A useful constant to remind us that each tile in the sprite-sheet is 50 pixels wide and 50 pixels high.</li>
				<li><code>VERTS_IN_QUAD</code>: A useful constant to make our manipulation of a <code>VertexArray</code> less error-prone. There are, in fact, four vertices in a quad. Now, we can't forget it.</li>
				<li><code>GRAVITY</code>: A constant int value representing the number of pixels by which the game characters will be pushed downward each second. This is quite a fun value to play with once the game is done. We initialize it to 300 here as this works well for our initial level designs.</li>
				<li><code>m_Window</code>: The usual <code>RenderWindow</code> object that we have had in all our projects.</li>
				<li>The SFML <code>View</code> objects, <code>m_MainView</code>, <code>m_LeftView</code>, <code>m_RightView</code>, <code>m_BGMainView</code>: <code>m_BGLeftView</code>, <code>m_BGRightView</code>, and <code>m_HudView</code>: The first three <code>View</code> objects are for the full screen view and the left and right and split-screen views of the game. We also have a separate SFML <code>View</code> object for each of those three, which will draw the background behind. The last <code>View</code> object, <code>m_HudView</code>, will be drawn on top of the appropriate combination of the other six views to display the score, the remaining time, and any messages to the players. Having seven different <code>View</code> objects might imply complexity, but when you see how we deal with them as the chapter progresses, you will see they are quite straightforward. We will have the whole split-screen/full screen conundrum sorted out by the end of this chapter.</li>
				<li><code>Sprite m_BackgroundSprite</code> and <code>Texture m_BackgroundTexture</code>: Somewhat predictably, this combination of SFML Sprite and Texture will be for showing and holding the background graphic from the graphics assets folder.</li>
				<li><code>m_Playing</code>: This Boolean will keep the game engine informed about whether the level has started yet (by pressing the <em class="italic">Enter</em> key). The player does not have the option to pause the game once they have started it.</li>
				<li><code>m_Character1</code>: When the screen is full screen, should it center on Thomas (<code>m_Character1</code> <code>= true</code>) or Bob (<code>m_Character1 = false</code>)? Initially, it is initialized to true, to center on Thomas.</li>
				<li><code>m_SplitScreen</code>: This variable is used to determine whether the game currently being played is in split-screen mode or not. We will use this variable to decide how exactly to use all the View objects we declared a few steps ago.</li>
				<li><code>m_TimeRemaining</code> variable: This <code>float</code> variable holds how much time (in seconds) is remaining to get to the goal of the current level. In the previous code, it is set to 10 for the purposes of testing, until we get to set a specific time for each level.</li>
				<li><code>m_GameTimeTotal</code> variable: This variable is an SFML <code>Time</code> object. It keeps track of how long the game has been played for.</li>
				<li><code>m_NewLevelRequired</code> Boolean variable: This variable keeps an eye on whether the player has just completed or failed a level. We can then use it to trigger loading the next level or restarting the current level. </li>
				<li>The <code>input</code> function: This function will handle all the player's input, which in this game is entirely from the keyboard. At first glance, it would appear that it handles all the keyboard input directly. In this game, however, we will be handling keyboard input that directly affects Thomas or Bob within the <code>Thomas</code> and <code>Bob</code> classes. This function will also handle keyboard input such as quitting, switching to split-screen, and any other keyboard input.</li>
				<li>The <code>update</code> function: This function will do all the work that we previously did in the update section of the <code>main</code> function. We will also call some other functions from the <code>update</code> function in order to keep the code organized. If you look back at the code, you will see that it receives a <code>float</code> parameter that will hold the fraction of a second that has passed since the previous frame. This, of course, is just what we need to update all our game objects.</li>
				<li>The <code>draw</code> function: This function will hold all the code that used to go in the drawing section of the main function in previous projects. We will, however, have some drawing code that is not kept in this function when we look at other ways to draw with SFML. We will see this new code when we learn about particle systems in <a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>, <em class="italic">Particle Systems and Shaders</em>.</li>
			</ul>
			<p>Now, let's run through all the public functions:</p>
			<ul>
				<li>The <code>Engine</code> constructor function: As we have come to expect, this function will be called when we first declare an instance of <code>Engine</code>. It will do all the setup and initialization of the class. We will see exactly what when we code the <code>Engine.cpp</code> file shortly.</li>
				<li>The <code>run</code> function: This is the only public function that we need to call. It will trigger the execution of <code>input</code>, <code>update</code>, and <code>draw</code>, and will do all the work for us.</li>
			</ul>
			<p>Next, we will see the definitions of all these functions and some of the variables in action.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor301"/>Coding Engine.cpp</h2>
			<p>In all our previous classes, we have put all the function definitions into the <code>.cpp</code> file prefixed with the class name. As our aim for this project is to make the code more manageable, we are doing things a little differently. </p>
			<p>In the <code>Engine.cpp</code> file, we will place the constructor (<code>Engine</code>) and the public <code>run</code> function. The rest of the functions will be going in their own <code>.cpp</code> file with a name that makes it clear which function goes where. This will not be a problem for the compiler if we add the appropriate include directive (<code>#include "Engine.h"</code>)<code> </code>at the top of all the files that contain function definitions from the <code>Engine</code> class. </p>
			<p>Let's get started by coding <code>Engine</code> and running it in <code>Engine.cpp</code>. Right-click <code>Engine.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>Engine</code> class.</p>
			<h3>Coding the Engine class constructor definition</h3>
			<p>The code for this function will go in the <code>Engine.cpp</code> file we have recently created.</p>
			<p>Add the following code and then we can discuss it:</p>
			<pre>#include "Engine.h"
Engine::Engine()
{
    // Get the screen resolution 
    // and create an SFML window and View
    Vector2f resolution;
    resolution.x = VideoMode::getDesktopMode().width;
    resolution.y = VideoMode::getDesktopMode().height;
    m_Window.create(VideoMode(resolution.x, resolution.y),
        "Thomas was late",
        Style::Fullscreen);
    // Initialize the full screen view
    m_MainView.setSize(resolution);
    m_HudView.reset(
        FloatRect(0, 0, resolution.x, resolution.y));
    // Initialize the split-screen Views
    m_LeftView.setViewport(
        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));
    m_RightView.setViewport(
        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));
    m_BGLeftView.setViewport(
        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));
    m_BGRightView.setViewport(
        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));
    
    m_BackgroundTexture = TextureHolder::GetTexture(
        "graphics/background.png");
    // Associate the sprite with the texture
    m_BackgroundSprite.setTexture(m_BackgroundTexture);
}</pre>
			<p>We have seen much of this code before. For example, there are the usual lines of code to get the screen resolution, as well as to create a <code>RenderWindow</code>. At the end of the previous code, we use the now-familiar code to load a texture and assign it to a Sprite. In this case, we are loading the <code>background.png</code> texture and assigning it to <code>m_BackgroundSprite</code>.</p>
			<p>It is the code in between the four calls to the <code>setViewport</code> function that needs some explanation. The <code>setViewport</code> function assigns a portion of the screen to an SFML <code>View</code> object. It doesn't work with pixel coordinates, however. It works using a ratio. Here, "1" is the entire screen (width or height). The first two values in each call to <code>setViewport</code> are the starting position (horizontally then vertically), while the last two are the ending position.</p>
			<p>Notice that <code>m_LeftView</code> and <code>m_BGLeftView</code> are placed in exactly the same place, that is, starting on virtually the far-left (0.001) of the screen and ending two-thousandths from the center (0.498). </p>
			<p><code>m_RightView</code> and <code>m_BGRightView</code> are also in exactly the same position as each other, starting just right of the previous two <code>View</code> objects (0.5) and extending to almost the far-right-hand side (0.998).</p>
			<p>Furthermore, all the views leave a tiny slither of a gap at the top and bottom of the screen. When we draw these <code>View</code> objects on the screen, on top of a white background, it will have the effect of splitting the screen with a thin white line between the two sides of the screen, as well as a thin white border around the edges.</p>
			<p>I have tried to represent this effect in the following diagram:</p>
			<div><div><img src="img/Image90695.jpg" alt=""/>
				</div>
			</div>
			<p>The best way to understand it is to finish this chapter, run the code, and see it in action.</p>
			<h3>Coding the run function definition</h3>
			<p>The code for this function will go in the <code>Engine.cpp</code> file we have recently created.</p>
			<p>Add the following code immediately after the previous constructor code:</p>
			<pre>void Engine::run()
{
    // Timing     
    Clock clock;
    while (m_Window.isOpen())
    {
        Time dt = clock.restart();
        // Update the total game time
        m_GameTimeTotal += dt;
        // Make a decimal fraction from the delta time
        float dtAsSeconds = dt.asSeconds();
        // Call each part of the game loop in turn
        input();
        update(dtAsSeconds);
        draw();
    }
}</pre>
			<p>The <code>run</code> function is the center of our engine; it initiates all the other parts. First, we declare a <code>Clock</code> object. Next, we have the familiar <code>while(window.isOpen())</code> loop, which creates the game loop. Inside this while loop, we do the following:</p>
			<ol>
				<li value="1">Restart <code>clock</code> and save the time that the previous loop took in <code>dt.</code></li>
				<li>Keep track of the total time elapsed in <code>m_GameTimeTotal.</code></li>
				<li>Declare and initialize a <code>float</code> to represent the fraction of a second that elapsed during the previous frame.</li>
				<li>Call <code>input.</code></li>
				<li>Call <code>update</code>, passing in the elapsed time (<code>dtAsSeconds</code>).</li>
				<li>Call <code>draw.</code></li>
			</ol>
			<p>All of this should look very familiar. What's new is that it is wrapped in the <code>run</code> function.</p>
			<h3>Coding the input function definition</h3>
			<p>As we explained previously, the code for the <code>input</code> function will go in its own file because it is more extensive than the constructor or the <code>run</code> function. We will use <code>#include "Engine.h"</code> and prefix the function signature with <code>Engine::</code> to make sure the compiler is aware of our intentions.</p>
			<p>Right-click <code>Input.cpp</code>. Finally, click the <code>input </code>function.</p>
			<p>Add the following code:</p>
			<pre>void Engine::input()
{
    Event event;
    while (m_Window.pollEvent(event))
    {
        if (event.type == Event::KeyPressed)
        {            
            // Handle the player quitting
            if (Keyboard::isKeyPressed(Keyboard::Escape))
            {
                m_Window.close();
            }
            // Handle the player starting the game
            if (Keyboard::isKeyPressed(Keyboard::Return))
            {
                m_Playing = true;
            }
            // Switch between Thomas and Bob
            if (Keyboard::isKeyPressed(Keyboard::Q))
            {
                m_Character1 = !m_Character1;
            }
            // Switch between full and split-screen
            if (Keyboard::isKeyPressed(Keyboard::E))
            {
                m_SplitScreen = !m_SplitScreen;
            }
        }
    }    
}</pre>
			<p>Like the previous projects, we check the <code>RenderWindow</code> event queue each frame. Also like we've already done before, we detect specific keyboard keys using <code>if (Keyboard::isKeyPressed...</code>. The most relevant information in the code we just added is what the keys do:</p>
			<ul>
				<li>As per usual, the <em class="italic">Esc</em> key closes the window and the game will quit.</li>
				<li>The <em class="italic">Enter</em> key sets <code>m_Playing</code> to true and eventually this will have the effect of starting the level.</li>
				<li>The <em class="italic">Q</em> key alternates the value of <code>m_Character1</code> between true and false. This key only has an effect in full screen mode. It will switch between Thomas and Bob being the center of the main <code>View</code>.</li>
				<li>The <em class="italic">E</em> keyboard key switches <code>m_SplitScreen</code> between true and false. This will have the effect of switching between full screen and split-screen views.</li>
			</ul>
			<p>Most of this keyboard functionality will be fully working by the end of this chapter. We are getting close to being able to run our game engine. Next, let's code the <code>update</code> function.</p>
			<h3>Coding the update function definition</h3>
			<p>As we explained previously, the code for this function will go in its own file because it is more extensive than the constructor or the <code>run</code> function. We will use <code>#include "Engine.h"</code> and prefix the function signature with <code>Engine::</code> to make sure the compiler is aware of our intentions.</p>
			<p>Right-click <code>Update.cpp</code>. Finally, click the <code>update </code>function.</p>
			<p>Add the following code to the <code>Update.cpp </code>file to implement the <code>update</code> function:</p>
			<pre>#include "Engine.h"
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;sstream&gt;
using namespace sf;
void Engine::update(float dtAsSeconds)
{
    if (m_Playing)
    {
        // Count down the time the player has left
        m_TimeRemaining -= dtAsSeconds;
        // Have Thomas and Bob run out of time?
        if (m_TimeRemaining &lt;= 0)
        {
            m_NewLevelRequired = true;
        }
    }// End if playing
        
}</pre>
			<p>First, notice that the <code>update</code> function receives the time the previous frame took as a parameter. This, of course, will be essential for the update function to fulfill its role.</p>
			<p>The previous code doesn't achieve anything visible at this stage. It does put in the structure that we will require for future chapters. It subtracts the time the previous frame took from <code>m_TimeRemaining</code> and checks whether time has run out. If it has, it sets <code>m_NewLevelRequired</code> to <code>true</code>. All this code is wrapped in an <code>if</code> statement that only executes when <code>m_Playing</code> is <code>true</code>. The reason for this is that, like the previous projects, we don't want time advancing and objects updating when the game has not started.</p>
			<p>We will build on this code as the project continues.</p>
			<h3>Coding the draw function definition</h3>
			<p>As we explained previously, the code for this function will go in its own file because it is more extensive than the constructor or the <code>run</code> function. We will use <code>#include "Engine.h"</code> and prefix the function signature with <code>Engine::</code> to make sure the compiler is aware of our intentions.</p>
			<p>Right-click <code>Draw.cpp</code>. Finally click the <code>draw </code>function.</p>
			<p>Add the following code to the <code>Draw.cpp</code> file to implement the <code>draw</code> function:</p>
			<pre>#include "Engine.h"
void Engine::draw()
{
    // Rub out the last frame
    m_Window.clear(Color::White);
    if (!m_SplitScreen)
    {
        // Switch to background view
        m_Window.setView(m_BGMainView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_MainView
        m_Window.setView(m_MainView);        
    }
    else
    {
        // Split-screen view is active
        // First draw Thomas' side of the screen
        // Switch to background view
        m_Window.setView(m_BGLeftView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_LeftView
        m_Window.setView(m_LeftView);
        
        // Now draw Bob's side of the screen
        // Switch to background view
        m_Window.setView(m_BGRightView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_RightView
        m_Window.setView(m_RightView);
                
    }
    // Draw the HUD
    // Switch to m_HudView
    m_Window.setView(m_HudView);
    
    
    // Show everything we have just drawn
    m_Window.display();
}</pre>
			<p>In the previous code, there is nothing we haven't seen before. The code starts, as usual, by clearing the screen. In this project, we clear the screen with White. What's new is the way the different drawing options are separated by a condition that checks whether the screen is currently split or not:</p>
			<pre>if (!m_SplitScreen)
{
}
else
{
}</pre>
			<p>If the screen is not split, we draw the background sprite in the background <code>View</code> (<code>m_BGView</code>) and then switch to the main full screen <code>View</code> (<code>m_MainView</code>). Note that, currently, we don't do any drawing in <code>m_MainView</code>.</p>
			<p>If, on the other hand, the screen is split, the code in the <code>else</code> block is executed and we draw <code>m_BGLeftView</code> with the background sprite on the left of the screen, followed by switching to <code>m_LeftView</code>.</p>
			<p>Then, still in the <code>else</code> block, we draw <code>m_BGRightView</code> with the background sprite on the right of the screen, followed by switching to <code>m_RightView</code>.</p>
			<p>Outside of the <code>if</code> <code>else</code> structure we just described, we switch to the <code>m_HUDView</code>. At this stage, we are not actually drawing anything in <code>m_HUDView</code>.</p>
			<p>Like  the other two (<code>input</code>, <code>update</code>) of the three most significant functions, we will go back to the <code>draw</code> function often. We will add new elements for our game that need to be drawn. You will notice that, each time we do, we will add code into each of the main, left-hand, and right-hand sections. </p>
			<p>Let's quickly recap on the <code>Engine</code> class and then we can fire it up.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor302"/>The Engine class so far</h2>
			<p>What we have done is abstract  all the code that used to be in the <code>main</code> function into the <code>input</code>, <code>update</code>, and <code>draw</code> functions. The continuous looping of these functions, as well as the timing, is handled by the <code>run</code> function.</p>
			<p>Consider leaving the <strong class="bold">Input.cpp</strong>, <strong class="bold">Update.cpp</strong>, and<strong class="bold"> Draw.cpp</strong> tabs open in Visual Studio, perhaps organized in order, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_14_09.jpg" alt=""/>
				</div>
			</div>
			<p>We will revisit each of these functions throughout the course of the project and add more code. Now that we have the basic structure and functionality of the <code>Engine</code> class, we can create an instance of it in the <code>main</code> function and see it in action.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor303"/>Coding the main function</h1>
			<p>Let's rename the <code>TFL.cpp</code> file that was autogenerated when the project was created to <code>Main.cpp</code>. Right-click the <code>TFL</code> file in the <code>Main.cpp</code>. This will be the file that contains our <code>main</code> function and the code that instantiates the <code>Engine</code> class.</p>
			<p>Add the following code to <code>Main.cpp</code>:</p>
			<pre>#include "Engine.h"
int main()
{
    // Declare an instance of Engine
    Engine engine;
    // Start the engine VRRrrrrmmm
    engine.run();
    // Quit in the usual way when the engine is stopped
    return 0;
}</pre>
			<p>All we do is add an <code>include</code> directive for the <code>Engine</code> class, declare an instance of <code>Engine</code>, and then call its <code>run</code> function. Everything will be handled by the <code>Engine</code> class until the player quits and the execution returns to <code>main</code> and the <code>return 0</code> statement.</p>
			<p>That was easy. Now, we can run the game and see the empty background, either in full screen or split-screen, which will eventually contain all the action.</p>
			<p>Here is the game so far in full screen mode, showing just the background:</p>
			<div><div><img src="img/B14278_14_10.jpg" alt=""/>
				</div>
			</div>
			<p>Now, tap the <em class="italic">E</em> key. You will be able to see the screen neatly partitioned into two halves, ready for split-screen coop gameplay:</p>
			<div><div><img src="img/B14278_14_11.jpg" alt=""/>
				</div>
			</div>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor304"/>Summary</h1>
			<p>In this chapter, we introduced the Thomas Was Late game and laid the foundations of understanding as well as the code structure for the rest of the project. It is certainly true that there are a lot of files in the Solution Explorer but, provided we understand the purpose of each, we will find the implementation of the rest of the project quite easy.</p>
			<p>In the next chapter, we will learn about two more fundamental C++ topics, inheritance and polymorphism. We will also begin to put them to use by building three classes to represent two playable characters. </p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor305"/>FAQ</h1>
			<p>Here is a question that might be on your mind:</p>
			<p>Q) I don't fully understand the structure of the code files. What should I do?</p>
			<p>A) It is true that abstraction can make the structure of our code less clear, but the actual code itself becomes so much easier. Instead of cramming everything into the <code>main</code> function like we did in the previous projects, we will split the code up into <code>Input.cpp</code>, <code>Update.cpp</code>, and <code>Draw.cpp</code>. Furthermore, we will use more classes to group together related code as we proceed. Study the <em class="italic">Structuring the Thomas Was Late code</em> section again, especially the diagrams.</p>
		</div>
	</body></html>