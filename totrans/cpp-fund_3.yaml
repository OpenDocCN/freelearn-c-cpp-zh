- en: '*Chapter 3*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*'
- en: Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Lesson Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够：
- en: Declare and define a class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和定义一个类
- en: Access the members of a class using objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象访问类的成员
- en: Apply access modifiers to encapsulate data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用访问修饰符以封装数据
- en: Use the static modifier on data members and member functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据成员和成员函数上使用静态修饰符
- en: Implement a nested class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现嵌套类
- en: Utilize the friend specifier to access private and protected members
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用友元指定符访问私有和受保护的成员
- en: Use constructors, copy constructors, assignment operators, and destructors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数、拷贝构造函数、赋值运算符和析构函数
- en: Overload operators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载运算符
- en: Implement functors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现函数对象
- en: In this chapter, we will be learning about classes and objects in C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于 C++ 中的类和对象。
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how we can use functions to combine basic operations
    into units with a clear meaning. Additionally, in the first chapter, we saw how,
    in C++, we can store data in basic types, such as integers, chars, and floats.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用函数将基本操作组合成具有明确意义的单元。此外，在第一章中，我们看到了在 C++ 中，我们可以将数据存储在基本类型中，例如整数、字符和浮点数。
- en: In this chapter, we will be covering how to define and declare classes and how
    to access member functions of a class. We will explore what `member` and `friend`
    functions are and how to use each in a program. Later in the chapter, we will
    look at how constructors and destructors work. At the end of the chapter, we will
    explore functors and how you can use them in your programs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何定义和声明类以及如何访问类的成员函数。我们将探讨 `成员` 和 `友元` 函数是什么以及如何在程序中使用它们。在本章的后面部分，我们将探讨构造函数和析构函数的工作原理。在本章结束时，我们将探讨函数对象（functors）以及如何在程序中使用它们。
- en: Declaring and Defining a Class
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和定义一个类
- en: A **class** is a way to combine data and operations together to create new types
    that can be used to represent complex concepts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是将数据和操作组合在一起以创建新类型的一种方式，这些类型可以用来表示复杂的概念。'
- en: Basic types can be composed to create more meaningful abstractions. For example,
    *location data* is composed of latitude and longitude coordinates, which are represented
    as `float` values. With such a representation, when our code needs to operate
    on a location, we would have to provide both the latitude and longitude as separate
    variables. This is error-prone, as we might forget to pass one of the two variables,
    or we could provide them in the wrong order.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型可以组合成更有意义的抽象。例如，*位置数据*由纬度和经度坐标组成，这些坐标以 `float` 值表示。在这种表示下，当我们的代码需要操作位置时，我们必须提供纬度和经度作为单独的变量。这很容易出错，因为我们可能会忘记传递两个变量中的一个，或者我们可能会以错误的顺序提供它们。
- en: Additionally, computing the distance between two coordinates is a complex task
    and we don't want to write the same code again and again. It becomes even more
    difficult when we use more complex objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，计算两个坐标之间的距离是一个复杂任务，我们不希望一遍又一遍地编写相同的代码。当我们使用更复杂对象时，这变得更加困难。
- en: Continuing our example on Coordinates, instead of using operations on two `float`
    types, we can define a type, which stores the location and provides the necessary
    operations to interact with it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的坐标示例，我们不是使用两个 `float` 类型的操作，而是可以定义一个类型，该类型存储位置并提供与它交互所需的必要操作。
- en: The Advantages of Using Classes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类的优势
- en: 'Classes provide several benefits, such as abstraction, information hiding,
    and encapsulation. Let''s explore each of these in depth:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供了多个好处，例如抽象、信息隐藏和封装。让我们深入探讨这些内容：
- en: '`float` variables, but this does not represent the concept that we want to
    use. The programmer needs to remember that the two variables have a different
    meaning and should be used together. Classes allow us to explicitly define a concept,
    composed by data and operations on that data, and assign a *name* to it.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 变量，但这并不代表我们想要使用的概念。程序员需要记住这两个变量具有不同的含义，并且应该一起使用。类允许我们明确地定义一个概念，该概念由数据和该数据上的操作组成，并给它赋予一个
    *名称*。'
- en: In our example, we can create a class to represent GPS coordinates. The data
    will be the two `float` variables to describe `float` variables that are used
    to represent it.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以创建一个类来表示 GPS 坐标。数据将是两个 `float` 变量，用于描述表示它的 `float` 变量。
- en: '**Information hiding**: The process of exposing a set of functionalities to
    the user of the class while hiding the details of how they are implemented in
    the class.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息隐藏**：向类的用户公开一组功能，同时隐藏它们在类中实现细节的过程。'
- en: 'This approach reduces the complexity of interacting with the class and makes
    it easier to update the class implementation in the future:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法减少了与类交互的复杂性，并使得将来更新类实现变得更加容易：
- en: '![Figure 2.1: The class exposes functionality that the user code uses directly,
    hiding the fact that it is implemented with two floats](img/Image70122.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：类直接暴露了用户代码使用的功能，隐藏了它实际上是用两个浮点数实现的这一事实](img/Image70122.jpg)'
- en: 'Figure 2.1: The class exposes functionality that the user code uses directly,
    hiding the fact that it is implemented with two floats'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：类直接暴露了用户代码使用的功能，隐藏了它实际上是用两个浮点数实现的这一事实
- en: 'We discussed the fact that we can represent GPS coordinates as latitude and
    longitude. Later, we might decide to represent a coordinate as the distance from
    the **North Pole**. Thanks to information hiding, we can change how a class is
    implemented and the users of the class will not be impacted, since we do not change
    the functionality offered by the class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了可以将GPS坐标表示为纬度和经度的事实。稍后，我们可能会决定将坐标表示为从**北极**的距离。多亏了信息隐藏，我们可以改变类的实现方式，而类的用户不会受到影响，因为我们没有改变类提供的功能：
- en: '![Figure 2.2: The implementation of the class changes, but since it is hidden
    from the user and the functionality was not changed, the user does not have to
    change how their code interacts with the class](img/Image70130.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：类的实现方式发生变化，但由于它对用户隐藏，并且功能没有改变，用户不需要改变他们的代码与类的交互方式](img/Image70130.jpg)'
- en: 'Figure 2.2: The implementation of the class changes, but since it is hidden
    from the user and the functionality was not changed, the user does not have to
    change how their code interacts with it'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：类的实现方式发生变化，但由于它对用户隐藏，并且功能没有改变，用户不需要改变他们的代码与它的交互方式
- en: The set of functionalities the class exposes to the users is normally referred
    to as the **public interface**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类向用户公开的功能集通常被称为**公共接口**。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Changing the implementation of a class is generally more convenient than to
    changing the interface of a class, which requires you to change all the users
    of the class to adapt to the new interface. Getting the design of the public interface
    of a class right is the first step to creating a class that is easy to use and
    requires low maintenance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 改变类的实现通常比改变类的接口更方便，因为改变接口需要你改变所有类的用户以适应新的接口。正确设计类的公共接口是创建易于使用且维护性低的类的第一步。
- en: '**Encapsulation**: This is the principle of grouping the data and the operations
    we can perform on it together. Since the data is hidden in the class, the user
    cannot access or operate on it. The class must provide functionality to interact
    with it. C++ enables encapsulation by letting the user put the operations to interact
    with a class and the data that is used to implement such operations in the same
    unit: **class**.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：这是将数据和我们可以对其执行的操作组合在一起的原则。由于数据被隐藏在类中，用户无法访问或操作它。类必须提供与它交互的功能。C++通过允许用户将用于与类交互的操作和实现这些操作所使用的数据放在同一个单元中来实现封装：**类**。'
- en: 'Let''s explore the structure of a class in C++ and the information associated
    with it. The following is the basic structure of a class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索C++中类的结构及其相关信息。以下是一个类的基本结构：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is common to forget the last `semicolon` after closing curly brackets. Always
    make sure that you add it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭花括号后忘记添加最后一个分号是很常见的。请务必确保添加它。
- en: C++ Data Members and Access Specifiers
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++数据成员和访问说明符
- en: 'Inside the body of a class, we can define the following class members:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的主体内部，我们可以定义以下类成员：
- en: '**Data members**: These are variables that live inside a class, which look
    like a **variable declaration**, but are inside the class body. They are also
    called **fields**.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据成员**：这些是存在于类内部的变量，看起来像**变量声明**，但位于类体内部。它们也被称为**字段**。'
- en: '**Member functions**: These are functions that can access the variables inside
    a class. They look like a **function declaration** but are inside the class body.
    They are also called **methods**.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员函数**：这些是可以访问类内部变量的函数。它们看起来像**函数声明**，但位于类体内部。它们也被称为**方法**。'
- en: As we mentioned before, classes support information hiding by denying users
    of the class to access information. The programmer uses **access specifiers**
    to specify which parts of the class are available for the user to be accessed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，类通过拒绝用户访问信息来支持信息隐藏。程序员使用**访问修饰符**来指定类的哪些部分可供用户访问。
- en: 'There are the following three access specifiers in C++:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有以下三种访问修饰符：
- en: '`private` can only be accessed by the functions inside the class and are not
    allowed to be accessed directly outside the class'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`只能被类内部的函数访问，并且不允许在类外部直接访问'
- en: '`protected` can only be accessed by the functions inside the class and the
    derived classes. We will learn more about in the last chapter of this book'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`只能被类内部和派生类中的函数访问。我们将在本书的最后一章中了解更多'
- en: '`public` can be accessed from anywhere in the program'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`可以在程序的任何地方访问'
- en: 'Access specifiers followed by a colon delimit an area in the class, and any
    member defined in that area has the access specifier that precedes it. Here''s
    the syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符后面跟着冒号来限定类中的一个区域，并且在该区域中定义的任何成员都具有它前面的访问修饰符。以下是语法：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: By default, class members have the `private` access modifier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类成员具有`private`访问修饰符。
- en: In C++, we can also use the `struct` keyword to define a class. A `struct` is
    identical to a class, with the only exception that, by default, the access modifier
    is `public`, while for the class it is `private`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们也可以使用`struct`关键字来定义一个类。`struct`与类相同，唯一的区别是，默认情况下，访问修饰符是`public`，而对于类来说，它是`private`。
- en: 'The following side-by-side code snippets are equivalent:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下并排的代码片段是等效的：
- en: '![](img/C11557_03_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11557_03_03.jpg)'
- en: 'Figure 3.2: The difference between the code snippets of class and struct'
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：类和struct代码片段之间的区别
- en: 'Whether to use `struct` or `class` depends on convention used: usually, we
    use `structs` when we want a collection of data members that should be accessible
    from anywhere in the code; on the other hand, we use classes when we are modelling
    a more complex concept.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用`struct`或`class`取决于使用的约定：通常，当我们想要一个可以从代码的任何地方访问的数据成员集合时，我们使用`structs`；另一方面，当我们正在模拟一个更复杂的概念时，我们使用类。
- en: We have learned how to define a class. Now, let's understand how to use one
    in a program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何定义一个类。现在，让我们了解如何在程序中使用它。
- en: A class defines a blueprint or the design of an object. Like a blueprint, we
    can create multiple objects from the same class. These objects are called **instances**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类定义了一个对象的蓝图或设计。就像蓝图一样，我们可以从同一个类创建多个对象。这些对象被称为**实例**。
- en: 'We can create an instance in the same way that we create any basic type: define
    the type of the variable followed by the name of the variable. Let''s explore
    the following example.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以创建任何基本类型相同的方式创建一个实例：先定义变量的类型，然后是变量的名称。让我们看看以下示例。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s an example that shows a class that has multiple instances:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了具有多个实例的类：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have two instances of the `Coordinates` class, each with their `latitude`
    and `longitude`, which can change independently. Once we have an instance, we
    can access its members.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`Coordinates`类的两个实例，每个实例都有其`latitude`和`longitude`，它们可以独立改变。一旦我们有一个实例，我们就可以访问它的成员。
- en: When we declare a class, we create a new scope called the `class` or a `struct`
    from a scope outside the class is the dot (`.`) operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个类时，我们创建一个新的作用域，称为`class`或`struct`，从类外部的作用域是点（`.`）运算符。
- en: 'For the previously defined variables, we can access their `latitude` using
    the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前定义的变量，我们可以使用以下代码来访问它们的`latitude`：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we want to call a member function instead, we can invoke it like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想调用一个成员函数，我们可以这样调用它：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the other hand, when we are writing the body of a `class` method, we are
    inside the class's scope. This means that we can access the other members of the
    class by using their names directly, without having to use the *dot* operator.
    The members of the current instance are going to be used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们编写`class`方法的主体时，我们处于类的范围内。这意味着我们可以通过直接使用它们的名称来访问类的其他成员，而无需使用*点*运算符。当前实例的成员将被使用。
- en: 'Let''s assume that the `distance` method is implemented as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`distance`方法实现如下：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we call `newYorkPosition.distance(tokyoPosition);`, the `distance` method
    is called on the `newYorkPosition` instance. This means that `latitude` and `longitude`
    in the `distance` method refer to `newYorkPosition.latitude` and `newYorkPosition.longitude`,
    while `other_coordinate.latitude` refers to `tokyoPosition.latitude`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `newYorkPosition.distance(tokyoPosition);` 时，`distance` 方法是在 `newYorkPosition`
    实例上被调用的。这意味着 `distance` 方法中的 `latitude` 和 `longitude` 指的是 `newYorkPosition.latitude`
    和 `newYorkPosition.longitude`，而 `other_coordinate.latitude` 指的是 `tokyoPosition.latitude`。
- en: If we had called `tokyoPosition.distance(newYorkPosition);` instead, the current
    instance would have been `tokyoPosition`, and `latitude` and `longitude` would
    have referred to the `tokyoPosition`, and `other_coordinate` to `newYorkPosition`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `tokyoPosition.distance(newYorkPosition);`，当前的实例将是 `tokyoPosition`，而
    `latitude` 和 `longitude` 将指向 `tokyoPosition`，`other_coordinate` 则指向 `newYorkPosition`。
- en: Static Members
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态成员
- en: In the previous section, we learned that a class defines the fields and methods
    that compose an object. It is like a blueprint, specifying what the object looks
    like, but it does not actually build it. *An instance is the object that's built
    from the blueprint that's defined by the class*. Instances contain data and we
    can operate on instances.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到一个类定义了组成对象的字段和方法。它就像一个蓝图，指定了对象的外观，但实际上并没有构建它。*一个实例是由类定义的蓝图构建的对象*。实例包含数据，我们可以对实例进行操作。
- en: Imagine the blueprint of a car. It specifies the engine of the car and that
    the car will have four wheels. The blueprint is the class of the car, but we cannot
    turn on and drive a blueprint. A car that's built by following the blueprint is
    an instance of the class. The built car has four wheels and an engine, and we
    can drive it. In the same way, an instance of a class contains the fields that
    are specified by the class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下汽车的蓝图。它指定了汽车的引擎，以及汽车将有四个轮子。蓝图是汽车类，但我们不能启动并驾驶蓝图。按照蓝图构建的汽车是类的实例。构建的汽车有四个轮子和引擎，我们可以驾驶它。同样，类的实例包含由类指定的字段。
- en: 'This means that the value of each field is connected to a specific instance
    of a class and evolves independently from the fields of all the other instances.
    At the same time, it also means that a field cannot exist without the associated
    instance: there would be no object that would be able to provide the storage (the
    space in memory) to store the value of the field!'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个字段的值都与类的特定实例相关联，并独立于所有其他实例的字段演变。同时，这也意味着字段不能没有关联的实例存在：将没有对象能够提供存储（内存中的空间）来存储字段的值！
- en: 'However, sometimes, we want to share the same value across all instances. In
    those cases, we can associate the field with the class instead of the instance
    by creating a `static` field. Let''s examine the following syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们希望所有实例共享相同的值。在这种情况下，我们可以通过创建一个 `static` 字段，将字段与类关联而不是与实例关联。让我们检查以下语法：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There will be only one `memberName` field, which is shared across all instances.
    Like any variable in C++, `memberName` needs to be stored in memory. We cannot
    use the storage of the instance object, since `memberName` is not associated with
    any specific instance. `memberName` is stored in a similar way to a *global variable*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将只有一个 `memberName` 字段，它被所有实例共享。像任何 C++ 变量一样，`memberName` 需要存储在内存中。我们不能使用实例对象的存储，因为
    `memberName` 与任何特定实例无关。`memberName` 以类似 *全局变量* 的方式存储。
- en: 'Outside of the class in which the static variable is declared, in a `.cpp`
    file, we can define the value of the `static` variable. The syntax to initialize
    the value is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明 `static` 变量的类之外，在一个 `.cpp` 文件中，我们可以定义 `static` 变量的值。初始化值的语法如下：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we do not repeat the `static` keyword.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要重复 `static` 关键字。
- en: It is important to define the values of the `static` variables in the `.cpp`
    file. If we define them inside the **header** file, the definition will be included
    anywhere inside the header, which will create multiple definitions, and the **linker**
    will complain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中定义 `static` 变量的值非常重要。如果我们将其定义在 **头文件** 中，定义将被包含在头文件内的任何地方，这将创建多个定义，并且
    **链接器** 将会报错。
- en: A class static variable's lifetime lasts for the complete duration of the program,
    like global variables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类静态变量的生命周期持续整个程序运行期间，就像全局变量一样。
- en: 'Let''s see an example of how a static field in a class can be defined in the
    header and how to assign a value to it in the `.cpp` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类中的静态字段如何在头文件中定义，以及如何在`.cpp`文件中为其赋值：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When accessing the members of an instance, we learned to use the dot operator.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问实例的成员时，我们学习了如何使用点运算符。
- en: When accessing a static member, we might not have an instance to use the dot
    operator on. C++ gives us the ability to access the static members of a class
    by using the `::`), after the class name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问静态成员时，我们可能没有实例来使用点运算符。C++通过在类名后使用`::`运算符，给了我们访问类静态成员的能力。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Always use `const` when declaring a static field. Any instance can access the
    static fields of its class; if they are **mutable**, it becomes extremely hard
    to track down which instances is modifying the value. In programs that use multiple
    threads, it is common to create bugs by modifying the static fields from different
    threads at the same time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 声明静态字段时始终使用`const`。任何实例都可以访问其类的静态字段；如果它们是**可变的**，那么追踪哪个实例正在修改值就变得极其困难。在多线程程序中，同时从不同的线程修改静态字段是常见的，这会导致创建错误。
- en: Let's examine the following exercise to understand how static variables work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下练习，以了解静态变量是如何工作的。
- en: 'Exercise 7: Working with Static Variables'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：使用静态变量
- en: 'Let''s write a program to print and find the square of numbers from 1 to 10:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来打印和查找从1到10的数字的平方：
- en: Include the required header files.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含所需的头文件。
- en: 'Write the `squares()` function and the following logic:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`squares()`函数和以下逻辑：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, in the `main` function, add the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中，添加以下代码：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In addition to static fields, classes can also have static methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态字段之外，类还可以有静态方法。
- en: 'A static method is associated with a class; it can be invoked without an instance.
    Since the fields and members of a class are associated with an instance, while
    static methods are not, static methods cannot invoke them. Static methods can
    be invoked using the scope resolution operator: `ClassName::staticMethodName();`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法与类相关联；它可以不通过实例来调用。由于类的字段和成员与实例相关联，而静态方法则不是，因此静态方法不能调用它们。可以使用作用域解析运算符调用静态方法：`ClassName::staticMethodName();`。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Static methods can only call other static methods and static fields inside a
    class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法只能调用类内部的其它静态方法和静态字段。
- en: Member Functions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员函数
- en: '**Member functions** are functions that are used to manipulate the data members
    of a class, and they define the properties and behavior of the objects of the
    class.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员函数**是用于操作类数据成员的函数，它们定义了类的对象属性和行为。'
- en: 'Declaring a member function is just a matter of declaring a function inside
    the body of a class. Let''s examine the following syntax:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 声明成员函数只是在一个类体内部声明一个函数的事情。让我们检查以下语法：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Member functions, like the data members of a class, can be accessed using the
    dot (`.`) operator that''s applied on the object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数，就像类的数据成员一样，可以使用应用于对象的点（`.`）运算符来访问：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's understand how to declare a member function outside the class scope.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何在类作用域之外声明成员函数。
- en: Declaring a Member Function
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明成员函数
- en: Member functions, like data members, must be declared inside the class. However,
    a member function's implementation can be placed either inside or outside the
    class, body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数，就像数据成员一样，必须在类内部声明。然而，成员函数的实现可以放在类体内部或外部。
- en: 'The following is a definition of a member function outside of the class, scope.
    This is done by using the scope resolution operator (`::`) to declare that the
    function that''s being referred to is a member of the class. In the class, body,
    the function is declared with its prototype:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在类外部定义成员函数的定义，这是通过使用作用域解析运算符（`::`）来声明所引用的函数是类的成员来完成的。在类体中，函数使用其原型进行声明：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using const Member Functions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用const成员函数
- en: The member functions of a class can be qualified as `const`, which means that
    the function limits its access to be read-only. Moreover, a member function is
    required to be `const` when it accesses `const` member data. So, `const` member
    functions are not allowed to modify the state of an object or call another function
    that does so.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类的成员函数可以被指定为`const`，这意味着该函数限制其访问为只读。此外，当成员函数访问`const`成员数据时，它必须为`const`。因此，不允许`const`成员函数修改对象的状态或调用这样做的方法。
- en: 'To declare a member function as `const`, we use the `const` keyword in the
    function declaration after the function name and before its body:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将成员函数声明为`const`，我们在函数声明中使用`const`关键字，位于函数名之后和函数体之前：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In addition to the overloading rules that we learned in the previous chapter
    that member functions can be overloaded in their const-ness, which means that
    two functions can have identical signatures except for one being `const` and the
    other not. The `const` member function will be called when an object is declared
    `const`; otherwise, the non-const function is called. Let''s examine the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一章中学到的重载规则之外，成员函数可以在它们的`const-ness`上进行重载，这意味着两个函数可以具有相同的签名，除了一个是`const`而另一个不是。当对象被声明为`const`时，将调用`const`成员函数；否则，调用非`const`函数。让我们考察以下代码：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to distinguish between a `const` function and a function returning
    a `const` type. Both make use of the same `const` keyword, but in different places
    in the function prototype. They express a different concept and are independent.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 区分`const`函数和返回`const`类型的函数很重要。两者都使用了相同的`const`关键字，但在函数原型中的位置不同。它们表达的概念不同，是独立的。
- en: 'The following examples show three versions of the `const` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了三种`const`函数的版本：
- en: The first one is a `const` member function
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个`const`成员函数
- en: The second returns a `const` reference
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个返回一个`const`引用
- en: 'The third one is a `const` function that returns a `const` reference:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是一个返回`const`引用的`const`函数：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The this Keyword
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`this`关键字'
- en: When the `this` keyword is used in the `class` context, it represents a pointer
    whose value is the address of the object on which the member function is called.
    It can appear within the body of any non-static member function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`class`上下文中使用`this`关键字时，它代表一个指针，其值是调用成员函数的对象的地址。它可以出现在任何非静态成员函数的体内。
- en: 'In the following example, `setColorToRed()` and `setColorToBlue()` perform
    the same action. Both set a data member, but the former uses the `this` keyword
    to refer to the current object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`setColorToRed()`和`setColorToBlue()`执行相同的操作。两者都设置一个数据成员，但前者使用`this`关键字来引用当前对象：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`pointer->member` is a convenient way to access the member of the `struct`
    pointed by `pointer`. It is equivalent to `(*pointer).member`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointer->member`是访问由`pointer`指向的`struct`成员的一种方便方式。它等价于`(*pointer).member`。'
- en: 'Exercise 8: Creating a Program Using the this Keyword to Greet New Users'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习八：使用`this`关键字创建一个问候新用户的程序
- en: 'Let''s write a program that asks users for their names and greets them with
    a welcoming message:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，要求用户输入他们的名字，并用欢迎信息问候他们：
- en: First, include the required header files.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包含所需的头文件。
- en: 'Then, add the following functions to print the required output:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下函数以打印所需输出：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s complete the program with a closing message using the `this` keyword.
    Define the following methods inside the previous class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`this`关键字完成程序，并添加一个结束语。在之前的类中定义以下方法：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Write the `main` function, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写如下`main`函数：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A function argument that has the same name as a data member of a class can shadow
    its visibility. In this case, the `this` keyword is required for disambiguation.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数参数与类的数据成员同名时，会遮蔽其可见性。在这种情况下，需要使用`this`关键字来消除歧义。
- en: Non-Member Class-Related Functions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非成员类相关函数
- en: 'Defined as functions or operations that conceptually belong to the interface
    of a class, non-member class-related functions are not part of a class itself.
    Let''s examine the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为属于类接口的概念性函数或操作，非成员类相关函数不是类本身的一部分。让我们考察以下示例：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The print function writes the radius of the circle on the given stream, which
    is most commonly the standard output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打印函数将圆的半径写入给定的流，这通常是标准输出。
- en: 'Activity 7: Information Hiding Through Getters and Setters'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动七：通过获取器和设置器实现信息隐藏
- en: In this activity, you are being asked to define a class named `Coordinates`,
    which contains two data members, and `latitude` and `longitude`, both of type
    `float` and not publicly accessible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你被要求定义一个名为`Coordinates`的类，它包含两个数据成员，`latitude`和`longitude`，都是`float`类型且不可公开访问。
- en: 'There are four operations that are associated with the `Coordinates` class:
    `set_latitude`, `set_longitude`, `get_latitude`, and `get_longitude`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Coordinates`类相关联的操作有四个：`set_latitude`、`set_longitude`、`get_latitude`和`get_longitude`。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `set_latitude` and `set_longitude` operations are used to `x` and `y` coordinates
    (also referred to as `get_latitude` and `get_longitude` are used to **retrieve**
    them (sometimes called **getters**).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_latitude`和`set_longitude`操作用于设置`x`和`y`坐标（也称为`get_latitude`和`get_longitude`用于**检索**它们（有时称为**获取器**）。'
- en: Performing encapsulation using the member functions through getter and setters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过成员函数使用获取器和设置器进行封装。
- en: 'To perform this activity, follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此活动，请按照以下步骤进行：
- en: Define a class with the name `Coordinates`, with its members under a `private`
    access specifier.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Coordinates`的类，其成员在`private`访问指定符下。
- en: Add the four operations previously specified and make them publicly accessible
    by preceding their declaration by the `public` access specifier.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前指定的四个操作添加，并通过在它们的声明前加上`public`访问指定符使它们公开可访问。
- en: The setters (`set_latitude` and `set_longitude`) should take a float as a parameter
    and return `void`, while the getters do not take any parameters and return a `float`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置器（`set_latitude`和`set_longitude`）应该接受一个浮点数作为参数并返回`void`，而获取器不接收任何参数并返回一个`float`。
- en: The four methods should now be implemented. The setters assign the given value
    to the corresponding member they are supposed to set; the getters return the values
    that are stored.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该实现这四个方法。设置器将给定的值赋给它们应该设置的相应成员；获取器返回存储的值。
- en: Note
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 288.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第288页找到。
- en: Constructors and Destructors
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: Up until now, we have learned how to declare data members, how to use them in
    functions with a `public` specifier, and how to access them. Now, let's explore
    how to set a value to them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何声明数据成员，如何在带有`public`指定符的函数中使用它们，以及如何访问它们。现在，让我们来探讨如何给它们设置值。
- en: 'In the following example, we''ll declare a `struct` by the name of `Rectangle`,
    and set a value to it as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将声明一个名为`Rectangle`的`struct`，并按照以下方式为其设置值：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This line will print a random value because we never set the value of `int`.
    The C++ rule for the initialization of basic types is that they get non-specified
    values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将打印一个随机值，因为我们从未设置`int`的值。C++对基本类型的初始化规则是它们获得非指定值。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In some situations, the values of variables are set to `0` when they are not
    initialized. This might happen because of some details in the implementation of
    the operating system, the standard library, or the compiler, and the C++ standard
    does not guarantee it. A program will have strange bugs when it relies on this
    behavior, since it is unpredictable when variables are initialized to `0`. Always
    explicitly initialize variables with basic types.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当变量未初始化时，它们的值被设置为`0`。这可能是由于操作系统实现、标准库或编译器的某些细节导致的，C++标准不保证这一点。当程序依赖于这种行为时，程序将出现奇怪的错误，因为变量初始化为`0`是不可预测的。始终显式初始化基本类型的变量。
- en: Constructors
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: The way to initialize data members is by using a **constructor**. A constructor
    is a special member function that has the *same name* as the class and *no return
    type*, and it is called automatically by the compiler when a new object of the
    class is created.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数据成员的方式是通过使用**构造函数**。构造函数是一个特殊的成员函数，它具有与类**相同名称**且**没有返回类型**，当编译器创建类的新对象时，它会被自动调用。
- en: 'Like any other function, a constructor can accept parameters and has a function
    body. We can invoke a constructor by adding a parameter list after the name of
    the variable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他函数一样，构造函数可以接受参数并具有函数体。我们可以在变量的名称后添加参数列表来调用构造函数：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When there are no parameters, we can avoid using parentheses, which is what
    we did in the previous example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有参数时，我们可以避免使用括号，就像我们在前面的例子中所做的那样。
- en: 'An example of a constructor with no parameters for the `Rectangle` struct would
    look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`结构体不带参数的构造函数示例如下：'
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When the only operation the constructor does is initialize the data members,
    opt for using the initialization list, which we will show you later in this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数所做的唯一操作是初始化数据成员时，可以选择使用初始化列表，我们将在本章后面向您展示。
- en: In addition to assigning values to data members, a constructor can also execute
    code, similar to a normal function body. This is important for the concept of
    the *class invariant*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为数据成员赋值外，构造函数还可以执行代码，类似于正常函数体。这对于**类不变性**的概念很重要。
- en: A key advantage of hiding the implementation of a class in *private* members
    and only exposing *public* methods to interact with the concept represented by
    the class is the ability to enforce a class invariant.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将类的实现隐藏在`private`成员中，并且只通过`public`方法与类表示的概念进行交互的关键优势是能够强制执行类不变性。
- en: A class invariant is a property or a set of properties of a class that should
    be `true` for any given instance of the class, at any point. It is called `true`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 类不变性是类的属性或属性集，对于类的任何给定实例，在任何点上都应该是`true`。它被称为`true`。
- en: Let's look at an example of a class that requires a class invariant. Imagine
    that we want to create a class that represents a date. The date would contain
    a year, month, and day, all represented as integers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个需要类不变性的类的示例。想象一下，我们想要创建一个表示日期的类。日期将包含年、月和日，所有这些都表示为整数。
- en: 'Implement it as a `struct` with all the fields as `public`. Refer to the following
    code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将其实现为一个`struct`，其中所有字段都是`public`。参考以下代码：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, the user could easily do the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以轻松地执行以下操作：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous code does not make any sense, as there are only 12 months in the
    Gregorian calendar.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码没有意义，因为格里高利历中只有12个月。
- en: A class invariant for the date would be that the month is always between 1 and
    12, and that the day is always between 1 and 31, and depending on the month, even
    less.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日期，一个类不变性是月份总是在1到12之间，日期总是在1到31之间，并且根据月份，甚至更少。
- en: Independently of any change the user performs on the `Date` object, the invariant
    must always hold.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不论用户对`Date`对象进行的任何更改，不变性都必须始终成立。
- en: A class can hide the detail that the date is stored as three integers and expose
    the functions to interact with the `Date` object. Functions can expect to find
    the dates to always be in a valid state (the invariant is satisfied at the start
    of the function), and they need to make sure to leave the class in a valid state
    (the invariant is satisfied at the end of the function).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以隐藏日期存储为三个整数的事实，并公开与`Date`对象交互的函数。函数可以期望找到的日期始终处于有效状态（不变性在函数开始时得到满足），并且它们需要确保在函数结束时将类留在有效状态（不变性在函数结束时得到满足）。
- en: The constructor does not only initialize the data members but also ensure that
    the class respects the invariant. After the constructor is executed, the invariant
    must be `true`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不仅初始化数据成员，还确保类遵守不变性。在构造函数执行后，不变性必须是`true`。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of an invariant is not specific to the C++ language, and there is
    no dedicated facility to specify the invariant of a class. A best practice is
    to document the expected invariant of the class together with the class code so
    that the developers working with the class can easily check what the expected
    invariant is and make sure they respect it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性的概念并不仅限于C++语言，并且没有专门的设施来指定类的不变性。一个最佳实践是在类代码中一起记录类的预期不变性，以便与该类一起工作的开发者可以轻松地检查预期的不变性并确保他们遵守它。
- en: Using assertions in code also helps in identifying when the invariant is not
    respected. This probably means there is a bug in the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用断言也有助于识别何时不遵守不变性。这可能意味着代码中存在错误。
- en: Overloading Constructor
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载构造函数
- en: Similar to other functions, we can overload the constructor by accepting different
    parameters. This is useful when an object can be created in several ways, since
    the user can create the object by providing the expected parameter, and the correct
    constructor is going to be called.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他函数类似，我们可以通过接受不同的参数来重载构造函数。当对象可以通过多种方式创建时，这很有用，因为用户可以通过提供预期的参数来创建对象，并且将调用正确的构造函数。
- en: 'We showed an example of a default constructor for the `Rectangle` class earlier
    in this chapter. If we want to add a constructor that creates a rectangle from
    a square, we could add the following constructor to the `Rectangle` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面展示了`Rectangle`类的默认构造函数的示例。如果我们想添加一个从正方形创建矩形的构造函数，我们可以在`Rectangle`类中添加以下构造函数：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second constructor is an overloaded constructor and will be invoked according
    to the way the class object is initialized.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数是一个重载构造函数，它将根据类对象的初始化方式被调用。
- en: 'In the following example, the first line will call the constructor with empty
    parameters, while the second line will call the overloaded constructor:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，第一行将调用带有空参数的构造函数，而第二行将调用重载构造函数：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A constructor with a single non-default parameter is also called a **converting
    constructor**. This kind of constructor specifies an implicit conversion, from
    the type of the argument to the class type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个非默认参数的构造函数也称为**转换构造函数**。这种构造函数指定了一个隐式转换，即从参数的类型转换为类类型。
- en: 'The following conversion is possible according to the previous definitions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的定义，以下转换是可能的：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The constructor is initialized, and it converts from type `Square` to `Rectangle`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数被初始化，并且它从类型`Square`转换为`Rectangle`。
- en: 'Similarly, the compiler can create implicit conversions when calling functions,
    as shown in the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编译器在调用函数时也可以创建隐式转换，如下面的示例所示：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When calling `use_rectangle`, the compiler creates a new object of type `Rectangle`
    by calling the conversion constructor, which accepts a `Square`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`use_rectangle`时，编译器通过调用转换构造函数创建一个新的`Rectangle`类型的对象，该构造函数接受一个`Square`。
- en: 'One way to avoid this is to use the `explicit` specifier before the constructor
    definition:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的一种方法是在构造函数定义前使用`explicit`指定符：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s look at a different implementation of `Rectangle`, which has an explicit
    constructor:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Rectangle`的另一种实现，它有一个显式构造函数：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we use try to use `Square` to call a function that takes `ExplicitRectangle`,
    we get an error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用`Square`调用一个接受`ExplicitRectangle`的函数时，我们会得到一个错误：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Constructor Member Initialization
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数成员初始化
- en: 'Constructors, as we''ve seen already, are used to initialize members. Up until
    now, we have initialized the members inside the body of the function by assigning
    values to members directly. C++ provides a feature to initialize the values of
    fields of the class in a more ergonomic way: initialization lists. Initialization
    lists allow you to call the constructor of the data members of class before the
    constructor body is executed. To write an initializer list, insert a colon (`:`)
    and a comma-separated list of initializations for class members before the constructor''s
    body.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，构造函数用于初始化成员。到目前为止，我们通过直接给成员赋值在函数体内初始化成员。C++提供了一种更方便的方式来初始化类的字段值：初始化列表。初始化列表允许你在执行构造函数体之前调用类的数据成员的构造函数。要编写初始化列表，在构造函数体之前插入一个冒号（`:`）和一个用逗号分隔的初始化成员列表。
- en: 'Let''s look at the following example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how, in this last case, the constructor does nothing other than initialize
    its members. Hence, it has an empty function body.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个最后的情况下，构造函数除了初始化其成员外没有做任何事情。因此，它有一个空函数体。
- en: 'Now, if we try to print the width and the height of the `Rectangle` object,
    we will notice that they are correctly initialized to `0`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试打印`Rectangle`对象的宽度和高度，我们会注意到它们被正确地初始化为`0`：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Initializer lists are the recommended way to initialize member variables in
    C++, and they are necessary when a data member is `const`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化列表是C++中初始化成员变量的推荐方式，当数据成员是`const`时是必要的。
- en: 'When using an initializer list, the order in which the members are constructed
    is the one in which they are declared inside the class; not the one in which they
    appear in the initializer list. Let''s look at the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用初始化列表时，成员构造的顺序是它们在类内部声明的顺序；而不是它们在初始化列表中出现的顺序。让我们看看以下示例：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When calling the default constructor of the `Example` class, the `first` method
    will be initialized first, and the `second` method after it, even if they appear
    in a different order in the initializer list.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Example`类的默认构造函数时，`first`方法将首先被初始化，然后是`second`方法，即使它们在初始化列表中的顺序不同。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You should always write the members in the initializer list in the same order
    as they are declared; compilers will help you by warning you when the order differs
    from the expected one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终按照成员声明的顺序在初始化列表中编写成员；当顺序与预期不同时，编译器会通过警告来帮助你。
- en: Aggregate Classes Initialization
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合类初始化
- en: Classes or structs with no user-declared constructors, no private or protected
    specifiers non-static data members, no base classes, and no virtual functions
    are considered aggregate.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用户声明的构造函数、没有私有或保护指定符的非静态数据成员、没有基类和没有虚函数的类或结构体被认为是聚合。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We will talk about base classes and virtual functions in chapter 6.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第6章中讨论基类和虚函数。
- en: 'These types of classes can be initialized, even though they do not have a constructor,
    by using a brace-enclosed comma-separated list of initializer-clauses, as shown
    here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这些类没有构造函数，也可以通过使用括号括起来的逗号分隔的初始化子句列表来初始化，如下所示：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Destructors
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 析构函数
- en: A *destructor* function is called automatically when the object goes out of
    scope and is used to destroy objects of its class type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象超出作用域时，会自动调用**析构函数**，并用于销毁其类的对象。
- en: 'Destructors have the same name as the class preceded by a tilde (`~`) and do
    not take any argument nor return any value (not even void). Let''s examine the
    following example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数与类名相同，前面有一个波浪号(`~`)，并且不接收任何参数也不返回任何值（甚至不是void）。让我们来看一个例子：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After executing the body of the destructor and destroying any automatic objects
    allocated within the body, a destructor for a class calls the destructors for
    all the direct members of the class. Data members are destroyed in reverse order
    of their construction.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 执行析构函数的主体并销毁在主体内部分配的任何自动对象后，类的析构函数会调用所有直接成员的析构函数。数据成员的销毁顺序与它们的构造顺序相反。
- en: 'Exercise 9: Creating a Simple Coordinate Program to Demonstrate the Use of
    Constructors and Destructors'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：创建一个简单的坐标程序以演示构造函数和析构函数的使用
- en: 'Let''s write a simple program to demonstrate the use of constructors and destructors:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来演示构造函数和析构函数的使用：
- en: First, include the required header files.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包含所需的头文件。
- en: 'Now, add the following code to the `Coordinates` class:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`Coordinates`类中：
- en: '[PRE42]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `main` function, add the following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，添加以下代码：
- en: '[PRE43]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Default Constructor and Destructor
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认构造函数和析构函数
- en: All the classes needs constructor and destructor functions. When the programmer
    does not define these, the compiler automatically creates an implicitly defined
    constructor and destructor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都需要构造函数和析构函数。当程序员没有定义这些函数时，编译器会自动创建隐式定义的构造函数和析构函数。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The default constructor might not initialize data members. Classes that have
    members of a built-in or compound type should ordinarily either initialize those
    members inside the class or define their version of the default constructor.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数可能不会初始化数据成员。具有内置或复合类型成员的类通常应在类内部初始化这些成员或定义其默认构造函数版本。
- en: 'Activity 8: Representing Positions in a 2D Map'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：在2D地图上表示位置
- en: Alice is building a program to show 2D maps of the world. Users need to be able
    to save locations, such as their house, a restaurant, or their workplace. To enable
    this functionality, Alice needs to be able to represent a position in the world.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Alice正在编写一个程序来展示世界地图的2D版本。用户需要能够保存位置，例如他们的房子、餐厅或工作场所。为了启用此功能，Alice需要能够表示世界中的位置。
- en: Create a class named `Coordinates` whose data members are the 2D coordinates
    of a point. To ensure that the object is always properly initialized, implement
    a constructor to initialize the data members of the class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Coordinates`的类，其数据成员是点的2D坐标。为了确保对象始终正确初始化，实现一个构造函数来初始化类的数据成员。
- en: 'Let''s perform the following steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: The first step is to create a class named `Coordinates` containing the coordinates
    as data members.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个名为`Coordinates`的类，其中包含坐标作为数据成员。
- en: Now, there are two floating-point values, `_latitude` and `_longitude`, which
    identify the coordinates on a geographic coordinate system. Additionally, these
    data members are defined with the `private` access specifier.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有两个浮点值`_latitude`和`_longitude`，它们标识地理坐标系统上的坐标。此外，这些数据成员使用`private`访问修饰符定义。
- en: Extend the class with a `public` constructor that takes two arguments, `latitude`
    and `longitude`, which are used to initialize the data members of the class.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加两个参数`latitude`和`longitude`的`public`构造函数来扩展类，这些参数用于初始化类的数据成员。
- en: Alice can now use this `Coordinates` class to represent 2D positions on the
    map.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice现在可以使用这个`Coordinates`类来表示地图上的2D位置。
- en: Note
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 289.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第289页找到。
- en: Resource Acquisition Is Initialization
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源获取即初始化
- en: '**Resource Acquisition Is Initialization**, or just **RAII**, is a programming
    idiom that is used to manage the life cycle of a resource automatically by binding
    it to the lifetime of an object.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源获取即初始化**，或简称**RAII**，是一种编程习惯，用于通过将其绑定到对象的生存周期来自动管理资源的生命周期。'
- en: Through the smart use of the constructor and destructor of an object, you can
    achieve RAII. The former acquires the resource, while the latter takes care of
    realizing it. The constructor is allowed to throw an exception, when a resource
    cannot be acquired, while the destructor must never throw exceptions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能地使用对象的构造函数和析构函数，你可以实现RAII。前者获取资源，而后者负责实现它。当资源无法获取时，构造函数可以抛出异常，而析构函数绝不能抛出异常。
- en: Typically, it is a good practice to operate on a resource via an instance of
    a RAII class when its usage involves `open()`/`close()`, `lock()`/`unlock()`,
    `start()`/`stop()`, `init()`/`destroy()`, or similar function calls.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当资源的使用涉及`open()`/`close()`、`lock()`/`unlock()`、`start()`/`stop()`、`init()`/`destroy()`或类似函数调用时，通过RAII类的实例操作资源是一种良好的实践。
- en: The following is a way to open and close a file using an RAII-style mechanism.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一种使用RAII风格机制打开和关闭文件的方法。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: C++, like many languages, represents input/output operations as streams, where
    data can be written to or read from.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: C++像许多语言一样，将输入/输出操作表示为流，其中数据可以写入或读取。
- en: 'The constructor of the class opens the file into a provided stream, while the
    destructor closes it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数将文件打开到提供的流中，而析构函数将关闭它：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To open the file, it is sufficient to provide the file path to the `file_handle`
    class. Then, for the entire lifetime of the `file_handle` object, the file will
    not be closed. Once the object reaches the end of the scope, the file is closed:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开文件，只需向`file_handle`类提供文件路径。然后，在整个`file_handle`对象的生命周期内，文件将不会关闭。一旦对象达到作用域的末尾，文件将被关闭：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is used instead of the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这代替了以下代码：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Even though the benefit provided by applying the RAII idiom seems to be just
    to reduce code, the real improvement is having safer code. It is common for a
    programmer to write a function that correctly opens a file but never closes it
    or allocates memory that never gets destroyed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用RAII惯用语提供的优势似乎只是减少代码，但真正的改进是拥有更安全的代码。程序员编写一个正确打开文件但从未关闭它或分配永远不会被销毁的内存的函数是很常见的情况。
- en: RAII makes sure that these operations cannot be forgotten, as it automatically
    handles them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: RAII确保这些操作不会被遗忘，因为它会自动处理它们。
- en: 'Activity 9: Storing Multiple Coordinates of Different Positions on a Map'
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动9：在地图上存储不同位置的多组坐标
- en: 'In the 2D map program, the user can save multiple positions on the map. We
    need to be able to store multiple coordinates to keep track of the positions saved
    by the user. To do so, we need a way to create an array that can store them:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D地图程序中，用户可以在地图上保存多个位置。我们需要能够存储多个坐标以跟踪用户保存的位置。为此，我们需要一种创建可以存储它们的数组的方法：
- en: Using the RAII programming idiom, write a class that manages memory allocation
    and the deletion of an array of values . The class has an array of integers as
    member data, which will be used to store the values .
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用RAII编程惯用语，编写一个管理内存分配和删除值数组的类。该类有一个整数数组作为成员数据，它将用于存储值。
- en: The constructor takes the size of the array as a parameter.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受数组的大小作为参数。
- en: The constructor also takes care of allocating memory, which is used to store
    the coordinates.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数还负责分配内存，该内存用于存储坐标。
- en: To allocate the memory use the function `allocate_memory` (number of elements)
    which returns a pointer to an array of Coordinates of the requested size. To release
    the memory, call `release_memory` (array) which takes an array of Coordinates
    and releases the memory.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要分配内存，请使用`allocate_memory`函数（元素数量），它返回一个指向请求大小的坐标数组的指针。要释放内存，请调用`release_memory`（数组），它接受一个坐标数组并释放内存。
- en: 'Finally, define a destructor and make sure to free the previously allocated
    array in its implementation:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个析构函数，并确保在其实现中释放先前分配的数组：
- en: Note
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 290.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第290页找到。
- en: Nested Class Declarations
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套类声明
- en: Inside the scope of a class, we can declare more than just data members and
    member functions; we can declare a class inside another class. These classes are
    called **nested classes**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的范围内，我们可以声明的不仅仅是数据成员和成员函数；我们可以在另一个类内部声明一个类。这些类被称为**嵌套类**。
- en: 'Since a nested class declaration happens inside the *outer class*, it has access
    to all the declared names as if it were part of the outer class: it can access
    even **private declarations**.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌套类声明发生在*外部类*内部，它可以访问所有声明的名称，就像它是外部类的一部分：它可以访问甚至**私有声明**。
- en: On the other hand, a nested class is not associated with any instance, so it
    can only access *static members*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，嵌套类与任何实例都不相关联，因此它只能访问*静态成员*。
- en: 'To access a nested class, we can use the double colon (`::`), similar to accessing
    static members of the outer class. Let''s examine the following example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问嵌套类，我们可以使用双冒号（`::`），类似于访问外部类的静态成员。让我们看看以下示例：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Nested classes are useful for two main reasons:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类有两个主要用途：
- en: When implementing a class, we need an object that manages some of the logic
    of the class. In such cases, the nested class is usually **private**, and is not
    exposed through the **public interface** of the class. It is mostly used to ease
    the implementation of the class.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当实现一个类时，我们需要一个对象来管理类的一些逻辑。在这种情况下，嵌套类通常是**私有的**，并且不会通过类的**公共接口**暴露出来。它主要用于简化类的实现。
- en: When designing the functionality of a class, we want to provide a different
    class, closely related to the original one, which provides part of that functionality.
    In that case, the class is accessible by the users of the class and is usually
    an important part of the interaction with the class.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计类的功能时，我们希望提供一个与原始类密切相关且提供部分该功能的类。在这种情况下，该类对类的用户是可访问的，并且通常是类交互的重要部分。
- en: Imagine a list – a sequence of objects. We would like the user to be able to
    iterate over the items contained in the list. To do so, we need to keep track
    of which items the user has already iterated over and which are remaining. This
    is typically done with an `List` class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个列表——对象序列。我们希望用户能够遍历列表中的项目。为此，我们需要跟踪用户已经遍历过的项目和剩余的项目。这通常是通过一个`List`类来完成的。
- en: We will look at iterators more in detail in *Lesson 5*, *Standard Library Containers
    and Algorithms*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第5课*，*标准库容器和算法*中更详细地了解迭代器。
- en: Friend Specifier
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 友元指定符
- en: 'As we have already seen, private and protected members of a class are not accessible
    from within other functions and classes. A class can declare another function
    or class as a friend: this function or class will have access to the private and
    protected members of the class which declares the **friend relationship**.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，类的私有和保护成员不能从其他函数和类内部访问。一个类可以声明另一个函数或类为友元：这个函数或类将有权访问声明**友元关系**的类的私有和保护成员。
- en: The user has to specify the `friend` declaration within the body of the class.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须在类的主体内部指定`friend`声明。
- en: Friend Functions
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 友元函数
- en: 'Friend functions are non-member functions that are entitled to access the private
    and protected members of a class. The way to declare a function as a `friend`
    function is by adding its declaration within the class and preceding it by the
    `friend` keyword. Let''s examine the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 友元函数是非成员函数，有权访问类的私有和保护成员。将函数声明为`friend`函数的方法是在类内部添加其声明，并在其前面加上`friend`关键字。让我们看看以下代码：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the previous example, the function declared outside of the class scope has
    the right to access the class data members because it is declared as a `friend`
    function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，声明在类作用域之外的功能有权访问类数据成员，因为它被声明为`friend`函数。
- en: Friend Classes
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 友元类
- en: Similarly, like a `friend` function, a class can also be made a friend of another
    class by using the `friend` keyword.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，像`friend`函数一样，一个类也可以通过使用`friend`关键字成为另一个类的友元。
- en: Declaring a class as a `friend` is like declaring all of its methods as friend
    functions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类声明为`friend`就像声明它的所有方法为友元函数一样。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Friendship is not mutual. If a class is a friend of another, then the opposite
    is not automatically true.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 友情不是相互的。如果一个类是另一个类的友元，那么相反的情况并不自动成立。
- en: 'The following code demonstrates the concept of how friendship is not mutual:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了友情不是相互的概念：
- en: '[PRE50]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Friendship is not transitive; so, in the previous example, class `C` is not
    a friend of class `A,` and the methods of class `C` cannot access the protected
    or private members of class `A`. Additionally, `A` cannot access B's private members,
    since `B` is a friend of `A`, but friendship is not mutual.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 友情不是传递的；因此，在前面的例子中，类`C`不是类`A`的友元，类`C`的方法不能访问类`A`的保护或私有成员。此外，`A`不能访问`B`的私有成员，因为`B`是`A`的友元，但友情不是相互的。
- en: 'Exercise 10: Creating a Program to Print the User''s Height'
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 10：创建一个打印用户身高的程序
- en: 'Let''s write a program that collects height input from the user in inches and,
    after performing a calculation, prints the height of the user in feet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，从用户那里收集以英寸为单位的高度输入，并在执行计算后打印用户以英尺为单位的高度：
- en: First, let's add all the required header files to the program.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将所有必需的头文件添加到程序中。
- en: 'Now, create the `Height` class with one `public` method, as illustrated:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`Height`的类，包含一个`public`方法，如下所示：
- en: '[PRE51]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, in the previous code, we used a friend function named `print_feet`.
    Now, let''s declare it:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，在之前的代码中，我们使用了一个名为`print_feet`的友元函数。现在，让我们声明它：
- en: '[PRE52]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Invoke the class in the `main` function, as shown here:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中调用类，如下所示：
- en: '[PRE53]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE54]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Activity 10: The AppleTree Class, which Creates an Apple Instance'
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动10：创建苹果实例的`AppleTree`类
- en: Sometimes, we would like to prevent the creation of an object of a specific
    type except for a limited number of classes. This usually happens when the classes
    are strictly related.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能只想在有限数量的类中创建特定类型的对象，以防止创建该类型的对象。这通常发生在类之间有严格关系时。
- en: Create an `Apple` class that does not provide a `public` constructor and an
    `AppleTree` class that is in charge of creating the former object.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个不提供`public`构造函数的`Apple`类和一个负责创建前者的`AppleTree`类。
- en: 'Let''s execute the following steps:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'First, we need to create a class with a `private` constructor. In this way,
    the object cannot be constructed, because the constructor is not publicly accessible:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个具有`private`构造函数的类。这样，对象就不能被构造，因为构造函数不是公开可访问的：
- en: '[PRE55]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `AppleTree` class is defined and contains a method called `createFruit`,
    which is in charge of creating an `Apple` and returning it:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppleTree`类被定义，并包含一个名为`createFruit`的方法，负责创建一个`Apple`并返回它：'
- en: '[PRE56]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we compile this code, we will get an error. At this point, the `Apple` constructor
    is `private`, so the `AppleTree` class cannot access it. We need to declare the
    `AppleTree` class as a `friend` of `Apple` to allow `AppleTree` to access the
    private methods of `Apple`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们编译此代码，我们将得到一个错误。此时，`Apple`构造函数是`private`的，因此`AppleTree`类无法访问它。我们需要将`AppleTree`类声明为`Apple`的`friend`，以允许`AppleTree`访问`Apple`的私有方法：
- en: '[PRE57]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Apple` object can now be constructed using the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用以下代码构造`Apple`对象：
- en: '[PRE58]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 291.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第291页找到。
- en: Copy Constructors and Assignment Operators
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制构造函数和赋值运算符
- en: One special type of constructor is the `const` qualified.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的构造函数类型是`const`修饰的。
- en: 'The following code refers to a class with a user-defined copy constructor,
    which copies the data member of the other object into the current one:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码引用了一个具有用户定义的复制构造函数的类，它将另一个对象的数据成员复制到当前对象中：
- en: '[PRE59]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A copy constructor is declared *implicitly* by the compiler when the class definition
    does not explicitly declare a copy constructor and all the data members have a
    copy constructor. This implicit copy constructor performs a copy of the class
    members in the *same order* of initialization.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当类定义没有显式声明复制构造函数且所有数据成员都具有复制构造函数时，编译器会**隐式地**声明一个复制构造函数。这个隐式复制构造函数会按照初始化的**相同顺序**复制类的成员。
- en: 'Let''s look at an example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE60]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When `C` is copy constructed, the members are copied in order: first, `a` is
    copied and then `b` is copied. To copy `A` and `B`, the compiler calls the copy
    constructor defined in those classes.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当`C`被复制构造时，成员按顺序复制：首先复制`a`，然后复制`b`。要复制`A`和`B`，编译器会调用这些类中定义的复制构造函数。
- en: Note
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When a pointer is copied, we are not copying the object pointed to, but simply
    the address at which the object is located.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当复制指针时，我们不是复制指向的对象，而是简单地复制对象所在的位置的地址。
- en: This means that when a class contains a `pointer` as a data member, the implicit
    copy constructor only copies the pointer and not the pointed object, so the copied
    object and the original one will share the object that's pointed to by the pointer.
    This is sometimes called a **shallow copy**.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当一个类包含一个`指针`作为数据成员时，隐式复制构造函数只会复制指针，而不是指向的对象，因此复制的对象和原始对象将共享指针指向的对象。这有时被称为**浅拷贝**。
- en: The copy Assignment Operator
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制赋值运算符
- en: An alternative way to copy an object is by using the **copy assignment operator**,
    which, contrary to the construct operator, is called when the object has been
    already initialized.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 复制对象的另一种方式是使用**复制赋值运算符**，与构造运算符相反，当对象已经被初始化时才会调用它。
- en: The assignment operator signature and implementation look quite similar to the
    copy constructor, with the only difference being that the former is an overload
    of the `=` operator and it generally returns a reference to `*this`, although
    it's not required.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符的签名和实现看起来与复制构造函数非常相似，唯一的区别是前者是 `=` 运算符的重载，它通常返回对 `*this` 的引用，尽管这不是必需的。
- en: 'Here''s an example of the use of the copy assignment operator:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用复制赋值运算符的一个示例：
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Also, for the copy assignment operator, the compiler generates an *implicit*
    one when it is not explicitly declared. As for the copy constructor, the members
    are copied in the same order of initialization.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于复制赋值运算符，当它没有显式声明时，编译器生成一个 *隐式* 的。至于复制构造函数，成员的复制顺序与初始化顺序相同。
- en: 'In the following example, the copy constructor and the copy assignment operator
    will output a sentence when they are called:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，当复制构造函数和复制赋值运算符被调用时，它们将输出一句话：
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following code shows two ways of copying an object. The former uses the
    copy constructor, while the latter uses the copy assignment operator. The two
    implementations will print a sentence when they are called:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了两种复制对象的方法。前者使用复制构造函数，而后者使用复制赋值运算符。当它们被调用时，两种实现将打印一句话：
- en: '[PRE63]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The move-constructor and move-assignment Operator
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动构造函数和移动赋值运算符
- en: Like copying, moving also allows you to set the data members of an object to
    be equal to those of another data member. The only difference with copying lies
    in the fact that the content is transferred from one object to another, removing
    it from the source.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与复制类似，移动也允许你将一个对象的数据成员设置为与另一个数据成员相等。唯一的区别在于内容是从一个对象转移到另一个对象，从而从源对象中移除。
- en: 'The move-constructor and move-assignment are members that take a parameter
    of type `rvalue` reference to the `class` itself:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数和移动赋值操作符是接受对 `class` 本身 `rvalue` 引用参数的成员：
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For clarity, we can briefly describe an `rvalue` reference (formed by placing
    an `&&` operator after the type of the function argument) as a value that does
    not have a memory address and does not persist beyond a single expression, for
    example, a **temporary object**.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们可以简要描述一个 `rvalue` 引用（通过在函数参数类型后放置一个 `&&` 运算符形成）为一个没有内存地址且不会超出单个表达式的值，例如，一个**临时对象**。
- en: A move constructor and a move assignment operator enable the resources owned
    by an `rvalue` object to be moved into an `lvalue` without copying.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数和移动赋值运算符允许将 `rvalue` 对象拥有的资源移动到 `lvalue` 中，而不进行复制。
- en: When we move a construct or assign a source object to a destination object,
    we transfer the content of the source object into the destination object, but
    the source object needs to remain valid. To do so, when implementing such methods,
    it is fundamental to reset the data members of the source object to a valid value.
    This is necessary to prevent the destructor from freeing the resources (such as
    memory) of the class multiple times.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将构造函数或源对象赋值给目标对象时，我们将源对象的内容转移到目标对象中，但源对象需要保持有效。为此，在实现此类方法时，将源对象的数据成员重置为有效值是基本的。这是防止析构函数多次释放类的资源（如内存）所必需的。
- en: Let's assume that there is a `Resource` that can be acquired, released, reset,
    and checked if it's reset.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在一个可以获取、释放、重置并检查是否已重置的 `Resource`。
- en: 'Here is an example of a `WrongMove` constructor:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `WrongMove` 构造函数的一个示例：
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The move-constructor of the `WrongMove` class will release the resource twice:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrongMove` 类的移动构造函数会释放资源两次：'
- en: '[PRE66]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Instead, the move constructor should have reset the `_resource` member of other,
    so that the destructor would not call `release_resource` again:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，移动构造函数应该重置其他对象的 `_resource` 成员，这样析构函数就不会再次调用 `release_resource`：
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The move constructor and move assignment operator can be implicitly generated
    by the compiler if no user-defined ones are provided and there are no user-declared
    destructors, copy constructors, or copy or move assignment operators:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供用户定义的构造函数、析构函数、复制构造函数或复制或移动赋值运算符，编译器可以隐式生成移动构造函数和移动赋值运算符：
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Preventing Implicit Constructors and Assignment Operators
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止隐式构造函数和赋值运算符
- en: The compiler will implicitly generate the copy constructor, copy assignment,
    move constructor, and move assignment if our class respects all the required conditions.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的类满足所有必需条件，编译器将隐式生成复制构造函数、复制赋值、移动构造函数和移动赋值。
- en: For cases in which our class should not be copied or moved, we can prevent that.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的类不应该被复制或移动的情况，我们可以阻止这种情况发生。
- en: To prevent the generation of implicit constructors and operators, we can write
    the declaration of the constructor or operator and add `= delete`; at the end
    of the declaration.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止生成隐式构造函数和运算符，我们可以编写构造函数或运算符的声明，并在声明末尾添加`= delete`。
- en: 'Let''s examine the following example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察以下示例：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Operator Overloading
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符重载
- en: C++ classes represent user-defined types. So, the need arises to be able to
    operate with these types in a different way. Some operator functions may have
    a different meaning when operating on different types. **Operator overloading**
    lets you define the meaning of an operator when applied to a class type object.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: C++类代表用户定义类型。因此，需要能够以不同的方式操作这些类型。某些运算符函数在操作不同类型时可能具有不同的意义。**运算符重载**允许你定义运算符应用于类类型对象时的含义。
- en: For example, the `+` operator applied to numerical types is different than when
    it is applied to the following `Point` class, which is constituted of coordinates.
    The language cannot specify what the `+` operator should do for user-defined types
    such as `Point`, as it is not in control of such types and does not know what
    the expected behavior is. Because of that, the language does not define the operators
    for user-defined types.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`+`运算符应用于数值类型时，与应用于以下由坐标构成的`Point`类不同。语言无法指定`+`运算符对用户定义类型（如`Point`）应该做什么，因为它不控制这些类型，也不知道预期的行为是什么。因此，语言不定义用户定义类型的运算符。
- en: However, C++ allows the user to specify the behavior of most operators for user-defined
    types, including classes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++允许用户指定用户定义类型（包括类）的大多数运算符的行为。
- en: 'Here is an example of the `+` operator, defined for the `Point` class:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`+`运算符的例子，它被定义为`Point`类：
- en: '[PRE70]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is a list of all the operators that can and cannot be overloaded:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以重载和不能重载的所有运算符的列表：
- en: 'The following are the operators that can be overloaded:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是可以重载的运算符：
- en: '![Figure 3.4: Operators that can be overloaded](img/C11557_03_04.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：可以重载的运算符](img/C11557_03_04.jpg)'
- en: 'Figure 3.4: Operators that can be overloaded'
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：可以重载的运算符
- en: 'The following are the operators that cannot be overloaded:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是不能重载的运算符：
- en: '![Figure 3.5: Operators that cannot be overloaded](img/C11557_03_05.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5：不能重载的运算符](img/C11557_03_05.jpg)'
- en: 'Figure 3.5: Operators that cannot be overloaded'
  id: totrans-400
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：不能重载的运算符
- en: Operators that expect two operands are called `+`, `-`, `*`, and `/`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 需要两个操作数的运算符被称为`+`、`-`、`*`和`/`。
- en: A method overloading a binary operator needs to accept a single parameter. When
    the compiler encounters the use of the operator, it will call the method on the
    variable on the left-hand side of the operator, while the variable on the right-hand
    side will be passed as parameter to the method.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 重载二元运算符的方法需要接受一个参数。当编译器遇到运算符的使用时，它将调用位于运算符左侧的变量的方法，而右侧的变量将作为参数传递给方法。
- en: 'We saw in the previous example that `Point` defines the `+` operator, which
    takes a parameter. When using the addition operation on a `Point`, the code would
    look like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到`Point`定义了`+`运算符，它接受一个参数。当在`Point`上使用加法操作时，代码将如下所示：
- en: '[PRE71]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The last line from the code example is equivalent to writing the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例的最后一行等价于编写以下内容：
- en: '[PRE72]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The compiler automatically rewrites the first expression to the second one.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器自动将第一个表达式重写为第二个表达式。
- en: Operators that expect only one operand are called `--`, `++`, and `!`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一个操作数的运算符被称为`--`、`++`和`!`。
- en: A method overloading a unary operator must not accept any parameters. When the
    compiler encounters the use of the operator, it will call the method on the variable
    to which the operator is assigned.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 重载一元运算符的方法不能接受任何参数。当编译器遇到运算符的使用时，它将调用分配给该运算符的变量的方法。
- en: 'As an example, let''s say we are given an object that''s defined as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个如下定义的对象：
- en: '[PRE73]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We would write the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写以下内容：
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The code is therefore rewritten as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码被重写如下：
- en: '[PRE75]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Operator overloading is possible in two ways: either as a member function or
    as a non-member function. The two end up producing the same effect.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载可以通过两种方式实现：要么作为成员函数，要么作为非成员函数。这两种方式最终会产生相同的效果。
- en: 'Activity 11: Ordering Point Objects'
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：对点对象进行排序
- en: 'In the 2D map application, we want to be able to display the locations that
    have been saved by the user in order: from South-West to North-East. To be able
    to show the locations in order, we need to be able to sort the location points
    representing the locations in such an order.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2D 地图应用中，我们希望能够按照从西南到东北的顺序显示用户保存的位置：为了能够按顺序显示位置，我们需要能够按照这种顺序对表示位置的点进行排序。
- en: Remember that the `x` coordinate represents the location along the West-East
    axis and the `y` coordinate represents the location along the North-South axis.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`x` 坐标代表沿着西东轴的位置，而 `y` 坐标代表沿着南北轴的位置。
- en: In a real-life scenario, to compare two points, we need to compare their `x`
    and `y` coordinates. To do so in code, we need to overload the `<` operator for
    the `Point` class. This new function we're defining returns a `bool`, either `true`
    or `false`, according to the order of `p_1` and `p_2`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，为了比较两个点，我们需要比较它们的 `x` 和 `y` 坐标。要在代码中这样做，我们需要为 `Point` 类重载 `<` 操作符。我们定义的这个新函数返回一个
    `bool`，根据 `p_1` 和 `p_2` 的顺序返回 `true` 或 `false`。
- en: The `p_1` point comes before than `p_2` in the order if the `x` coordinate of
    `p_1` is less than the `x` coordinate of `p_2`. If they are equal, then we need
    to compare their `y` coordinates.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `p_1` 的 `x` 坐标小于 `p_2` 的 `x` 坐标，则 `p_1` 点在顺序上比 `p_2` 点更早。如果它们相等，则需要比较它们的
    `y` 坐标。
- en: 'Let''s perform the following steps:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'We need to add an overload for the `<` operator to the `Point` class that we
    previously defined, which takes another object of type `Point` as an argument
    and returns a `bool` indicating whether the object is less than the one provided
    as a parameter, using the previous definition for how to compare two points:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为之前定义的 `Point` 类添加一个 `<` 操作符的重载，该重载接受另一个类型为 `Point` 的对象作为参数，并返回一个 `bool`，指示该对象是否小于提供的参数，使用之前定义的比较两个点的方法：
- en: 'At this point, we are able to compare two `Point` objects:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们能够比较两个 `Point` 对象：
- en: Since, in our example, `p_1.x` is initialized to `1` and `p_2.x` to `2`, the
    result of the comparison will be `true`, which indicates that `p_1` comes earlier
    than `p_2` in the order.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在我们的示例中，`p_1.x` 被初始化为 `1`，而 `p_2.x` 被初始化为 `2`，比较的结果将是 `true`，这表明 `p_1` 在顺序上比
    `p_2` 更早。
- en: Note
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 293.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 293 页找到。
- en: Introducing Functors
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Functors
- en: A `operator()` function is also known as the **function call operator**.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator()` 函数也被称为 **函数调用操作符**。'
- en: 'The syntax that''s used to define a `functor` is as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `functor` 所使用的语法如下：
- en: '[PRE76]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The function call operator has a return type and takes any number of arguments
    of any type. To invoke the call operator of an object, we can write the name of
    the object, followed by parentheses containing the arguments to pass to the operator.
    You can imagine that an object that provides a call operator can be used in the
    same way as you would use a function. Here''s an example of a `functor`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用操作符有一个返回类型，并可以接受任何类型和数量的参数。要调用对象的函数调用操作符，我们可以写出对象的名字，然后是包含传递给操作符的参数的括号。你可以想象，提供了一个调用操作符的对象可以像使用函数一样使用。以下是一个
    `functor` 的例子：
- en: '[PRE77]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: They are particularly useful in places where you can pass a function object
    to an algorithmic template that accepts an object with `operator()` defined. This
    exploits code reusability and testability. We will see more on this in chapter
    5 when we talk about **lambda**.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在可以传递一个具有 `operator()` 定义的对象到接受该对象的算法模板的地方特别有用。这利用了代码的可重用性和可测试性。我们将在第 5 章讨论
    **lambda** 时了解更多。
- en: 'The following is a simple example of a `functor` that prints a string before
    appending a new line at the end of it:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的 `functor` 示例，它在字符串末尾添加一个新行之前打印一个字符串：
- en: '[PRE78]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Activity 12: Implementing Functors'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 12：实现 Functors
- en: Write a function object that takes a number when constructed and defines an
    operator call that takes another number and returns the sum of the two.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数对象，它在构造时接受一个数字，并定义一个操作符调用，该调用接受另一个数字并返回两个数字的和。
- en: 'Let''s perform the following steps to achieve the desired output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤以实现所需的输出：
- en: Define a class by the name of `AddX`, constituted by a `private` data member
    of type `int`, and a constructor that is used to initialize it.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `AddX` 的类，它由一个类型为 `int` 的 `private` 数据成员和一个用于初始化它的构造函数组成。
- en: Extend it with the call operator, `operator()`, which takes an `int` as a parameter
    and returns an `int`. The implementation in the function body should return the
    addition of the previously defined `x` value and the parameter of the function
    named `y`.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用操作符`operator()`扩展它，该操作符接受一个`int`类型的参数并返回一个`int`。函数体内的实现应该返回先前定义的`x`值与函数参数`y`的和。
- en: 'Instantiate an object of the class we just defined and invoke the calling operator:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化我们刚刚定义的类的对象并调用调用操作符：
- en: '[PRE79]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 294.
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第294页找到。
- en: Summary
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how the concept of classes can be used in C++. We started
    by delineating the advantages of using classes, describing how they can help us
    to create powerful abstractions.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在C++中使用类概念。我们首先阐述了使用类的优点，描述了它们如何帮助我们创建强大的抽象。
- en: We outlined the access modifiers a class can use to control who has access to
    class fields and methods.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了类可以使用哪些访问修饰符来控制谁可以访问类的字段和方法。
- en: We continued by exploring the conceptual differences between a class and its
    instances, along with the implications this has when implementing static fields
    and static methods.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探讨类与其实例之间的概念差异，以及这在对静态字段和静态方法实现时产生的含义。
- en: We saw how constructors are used to initialize classes and their members, while
    destructors are used to clean up the resources that are managed by a class.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了构造函数是如何用于初始化类及其成员的，而析构函数则是用于清理由类管理的资源。
- en: 'We then explored how constructors and destructors can be combined to implement
    the fundamental paradigm C++ is famous for: RAII. We showed how RAII makes it
    easy to create classes that handle resources and make programs safer and easier
    to work with.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后探讨了如何结合构造函数和析构函数来实现C++著名的RAII（资源获取即初始化）范式。我们展示了RAII如何使创建处理资源并使程序更安全、更易于工作的类变得简单。
- en: Finally, we introduced the concept of operator overloading and how it can be
    used to create classes that are as easy to use as built-in types.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了操作符重载的概念以及如何使用它来创建与内置类型一样易于使用的类。
- en: In the next chapter, we'll focus on templates. We'll primarily look at how to
    implement template functions and classes, and write code that works for multiple
    types.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注模板。我们将主要探讨如何实现模板函数和类，并编写适用于多种类型的代码。
