- en: '*Chapter 3*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lesson Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare and define a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access the members of a class using objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply access modifiers to encapsulate data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the static modifier on data members and member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a nested class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the friend specifier to access private and protected members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use constructors, copy constructors, assignment operators, and destructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overload operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be learning about classes and objects in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how we can use functions to combine basic operations
    into units with a clear meaning. Additionally, in the first chapter, we saw how,
    in C++, we can store data in basic types, such as integers, chars, and floats.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be covering how to define and declare classes and how
    to access member functions of a class. We will explore what `member` and `friend`
    functions are and how to use each in a program. Later in the chapter, we will
    look at how constructors and destructors work. At the end of the chapter, we will
    explore functors and how you can use them in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and Defining a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **class** is a way to combine data and operations together to create new types
    that can be used to represent complex concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types can be composed to create more meaningful abstractions. For example,
    *location data* is composed of latitude and longitude coordinates, which are represented
    as `float` values. With such a representation, when our code needs to operate
    on a location, we would have to provide both the latitude and longitude as separate
    variables. This is error-prone, as we might forget to pass one of the two variables,
    or we could provide them in the wrong order.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, computing the distance between two coordinates is a complex task
    and we don't want to write the same code again and again. It becomes even more
    difficult when we use more complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our example on Coordinates, instead of using operations on two `float`
    types, we can define a type, which stores the location and provides the necessary
    operations to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: The Advantages of Using Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes provide several benefits, such as abstraction, information hiding,
    and encapsulation. Let''s explore each of these in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float` variables, but this does not represent the concept that we want to
    use. The programmer needs to remember that the two variables have a different
    meaning and should be used together. Classes allow us to explicitly define a concept,
    composed by data and operations on that data, and assign a *name* to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we can create a class to represent GPS coordinates. The data
    will be the two `float` variables to describe `float` variables that are used
    to represent it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Information hiding**: The process of exposing a set of functionalities to
    the user of the class while hiding the details of how they are implemented in
    the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This approach reduces the complexity of interacting with the class and makes
    it easier to update the class implementation in the future:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.1: The class exposes functionality that the user code uses directly,
    hiding the fact that it is implemented with two floats](img/Image70122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The class exposes functionality that the user code uses directly,
    hiding the fact that it is implemented with two floats'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We discussed the fact that we can represent GPS coordinates as latitude and
    longitude. Later, we might decide to represent a coordinate as the distance from
    the **North Pole**. Thanks to information hiding, we can change how a class is
    implemented and the users of the class will not be impacted, since we do not change
    the functionality offered by the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: The implementation of the class changes, but since it is hidden
    from the user and the functionality was not changed, the user does not have to
    change how their code interacts with the class](img/Image70130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The implementation of the class changes, but since it is hidden
    from the user and the functionality was not changed, the user does not have to
    change how their code interacts with it'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The set of functionalities the class exposes to the users is normally referred
    to as the **public interface**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Changing the implementation of a class is generally more convenient than to
    changing the interface of a class, which requires you to change all the users
    of the class to adapt to the new interface. Getting the design of the public interface
    of a class right is the first step to creating a class that is easy to use and
    requires low maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: This is the principle of grouping the data and the operations
    we can perform on it together. Since the data is hidden in the class, the user
    cannot access or operate on it. The class must provide functionality to interact
    with it. C++ enables encapsulation by letting the user put the operations to interact
    with a class and the data that is used to implement such operations in the same
    unit: **class**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s explore the structure of a class in C++ and the information associated
    with it. The following is the basic structure of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is common to forget the last `semicolon` after closing curly brackets. Always
    make sure that you add it.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Data Members and Access Specifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the body of a class, we can define the following class members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data members**: These are variables that live inside a class, which look
    like a **variable declaration**, but are inside the class body. They are also
    called **fields**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Member functions**: These are functions that can access the variables inside
    a class. They look like a **function declaration** but are inside the class body.
    They are also called **methods**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned before, classes support information hiding by denying users
    of the class to access information. The programmer uses **access specifiers**
    to specify which parts of the class are available for the user to be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the following three access specifiers in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` can only be accessed by the functions inside the class and are not
    allowed to be accessed directly outside the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected` can only be accessed by the functions inside the class and the
    derived classes. We will learn more about in the last chapter of this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public` can be accessed from anywhere in the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access specifiers followed by a colon delimit an area in the class, and any
    member defined in that area has the access specifier that precedes it. Here''s
    the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, class members have the `private` access modifier.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, we can also use the `struct` keyword to define a class. A `struct` is
    identical to a class, with the only exception that, by default, the access modifier
    is `public`, while for the class it is `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following side-by-side code snippets are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C11557_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The difference between the code snippets of class and struct'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Whether to use `struct` or `class` depends on convention used: usually, we
    use `structs` when we want a collection of data members that should be accessible
    from anywhere in the code; on the other hand, we use classes when we are modelling
    a more complex concept.'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to define a class. Now, let's understand how to use one
    in a program.
  prefs: []
  type: TYPE_NORMAL
- en: A class defines a blueprint or the design of an object. Like a blueprint, we
    can create multiple objects from the same class. These objects are called **instances**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an instance in the same way that we create any basic type: define
    the type of the variable followed by the name of the variable. Let''s explore
    the following example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example that shows a class that has multiple instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two instances of the `Coordinates` class, each with their `latitude`
    and `longitude`, which can change independently. Once we have an instance, we
    can access its members.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a class, we create a new scope called the `class` or a `struct`
    from a scope outside the class is the dot (`.`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the previously defined variables, we can access their `latitude` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to call a member function instead, we can invoke it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, when we are writing the body of a `class` method, we are
    inside the class's scope. This means that we can access the other members of the
    class by using their names directly, without having to use the *dot* operator.
    The members of the current instance are going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the `distance` method is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we call `newYorkPosition.distance(tokyoPosition);`, the `distance` method
    is called on the `newYorkPosition` instance. This means that `latitude` and `longitude`
    in the `distance` method refer to `newYorkPosition.latitude` and `newYorkPosition.longitude`,
    while `other_coordinate.latitude` refers to `tokyoPosition.latitude`.
  prefs: []
  type: TYPE_NORMAL
- en: If we had called `tokyoPosition.distance(newYorkPosition);` instead, the current
    instance would have been `tokyoPosition`, and `latitude` and `longitude` would
    have referred to the `tokyoPosition`, and `other_coordinate` to `newYorkPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: Static Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we learned that a class defines the fields and methods
    that compose an object. It is like a blueprint, specifying what the object looks
    like, but it does not actually build it. *An instance is the object that's built
    from the blueprint that's defined by the class*. Instances contain data and we
    can operate on instances.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the blueprint of a car. It specifies the engine of the car and that
    the car will have four wheels. The blueprint is the class of the car, but we cannot
    turn on and drive a blueprint. A car that's built by following the blueprint is
    an instance of the class. The built car has four wheels and an engine, and we
    can drive it. In the same way, an instance of a class contains the fields that
    are specified by the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the value of each field is connected to a specific instance
    of a class and evolves independently from the fields of all the other instances.
    At the same time, it also means that a field cannot exist without the associated
    instance: there would be no object that would be able to provide the storage (the
    space in memory) to store the value of the field!'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes, we want to share the same value across all instances. In
    those cases, we can associate the field with the class instead of the instance
    by creating a `static` field. Let''s examine the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There will be only one `memberName` field, which is shared across all instances.
    Like any variable in C++, `memberName` needs to be stored in memory. We cannot
    use the storage of the instance object, since `memberName` is not associated with
    any specific instance. `memberName` is stored in a similar way to a *global variable*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside of the class in which the static variable is declared, in a `.cpp`
    file, we can define the value of the `static` variable. The syntax to initialize
    the value is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Note that we do not repeat the `static` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to define the values of the `static` variables in the `.cpp`
    file. If we define them inside the **header** file, the definition will be included
    anywhere inside the header, which will create multiple definitions, and the **linker**
    will complain.
  prefs: []
  type: TYPE_NORMAL
- en: A class static variable's lifetime lasts for the complete duration of the program,
    like global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how a static field in a class can be defined in the
    header and how to assign a value to it in the `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When accessing the members of an instance, we learned to use the dot operator.
  prefs: []
  type: TYPE_NORMAL
- en: When accessing a static member, we might not have an instance to use the dot
    operator on. C++ gives us the ability to access the static members of a class
    by using the `::`), after the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Always use `const` when declaring a static field. Any instance can access the
    static fields of its class; if they are **mutable**, it becomes extremely hard
    to track down which instances is modifying the value. In programs that use multiple
    threads, it is common to create bugs by modifying the static fields from different
    threads at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the following exercise to understand how static variables work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Working with Static Variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a program to print and find the square of numbers from 1 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the required header files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the `squares()` function and the following logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `main` function, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to static fields, classes can also have static methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A static method is associated with a class; it can be invoked without an instance.
    Since the fields and members of a class are associated with an instance, while
    static methods are not, static methods cannot invoke them. Static methods can
    be invoked using the scope resolution operator: `ClassName::staticMethodName();`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Static methods can only call other static methods and static fields inside a
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Member Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Member functions** are functions that are used to manipulate the data members
    of a class, and they define the properties and behavior of the objects of the
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a member function is just a matter of declaring a function inside
    the body of a class. Let''s examine the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Member functions, like the data members of a class, can be accessed using the
    dot (`.`) operator that''s applied on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand how to declare a member function outside the class scope.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Member Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Member functions, like data members, must be declared inside the class. However,
    a member function's implementation can be placed either inside or outside the
    class, body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a definition of a member function outside of the class, scope.
    This is done by using the scope resolution operator (`::`) to declare that the
    function that''s being referred to is a member of the class. In the class, body,
    the function is declared with its prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using const Member Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The member functions of a class can be qualified as `const`, which means that
    the function limits its access to be read-only. Moreover, a member function is
    required to be `const` when it accesses `const` member data. So, `const` member
    functions are not allowed to modify the state of an object or call another function
    that does so.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a member function as `const`, we use the `const` keyword in the
    function declaration after the function name and before its body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the overloading rules that we learned in the previous chapter
    that member functions can be overloaded in their const-ness, which means that
    two functions can have identical signatures except for one being `const` and the
    other not. The `const` member function will be called when an object is declared
    `const`; otherwise, the non-const function is called. Let''s examine the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is important to distinguish between a `const` function and a function returning
    a `const` type. Both make use of the same `const` keyword, but in different places
    in the function prototype. They express a different concept and are independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show three versions of the `const` function:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a `const` member function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second returns a `const` reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third one is a `const` function that returns a `const` reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The this Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the `this` keyword is used in the `class` context, it represents a pointer
    whose value is the address of the object on which the member function is called.
    It can appear within the body of any non-static member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `setColorToRed()` and `setColorToBlue()` perform
    the same action. Both set a data member, but the former uses the `this` keyword
    to refer to the current object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`pointer->member` is a convenient way to access the member of the `struct`
    pointed by `pointer`. It is equivalent to `(*pointer).member`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Creating a Program Using the this Keyword to Greet New Users'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a program that asks users for their names and greets them with
    a welcoming message:'
  prefs: []
  type: TYPE_NORMAL
- en: First, include the required header files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the following functions to print the required output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s complete the program with a closing message using the `this` keyword.
    Define the following methods inside the previous class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the `main` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: A function argument that has the same name as a data member of a class can shadow
    its visibility. In this case, the `this` keyword is required for disambiguation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Non-Member Class-Related Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defined as functions or operations that conceptually belong to the interface
    of a class, non-member class-related functions are not part of a class itself.
    Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The print function writes the radius of the circle on the given stream, which
    is most commonly the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7: Information Hiding Through Getters and Setters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, you are being asked to define a class named `Coordinates`,
    which contains two data members, and `latitude` and `longitude`, both of type
    `float` and not publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four operations that are associated with the `Coordinates` class:
    `set_latitude`, `set_longitude`, `get_latitude`, and `get_longitude`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `set_latitude` and `set_longitude` operations are used to `x` and `y` coordinates
    (also referred to as `get_latitude` and `get_longitude` are used to **retrieve**
    them (sometimes called **getters**).
  prefs: []
  type: TYPE_NORMAL
- en: Performing encapsulation using the member functions through getter and setters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this activity, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class with the name `Coordinates`, with its members under a `private`
    access specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the four operations previously specified and make them publicly accessible
    by preceding their declaration by the `public` access specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The setters (`set_latitude` and `set_longitude`) should take a float as a parameter
    and return `void`, while the getters do not take any parameters and return a `float`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The four methods should now be implemented. The setters assign the given value
    to the corresponding member they are supposed to set; the getters return the values
    that are stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 288.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Constructors and Destructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we have learned how to declare data members, how to use them in
    functions with a `public` specifier, and how to access them. Now, let's explore
    how to set a value to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll declare a `struct` by the name of `Rectangle`,
    and set a value to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This line will print a random value because we never set the value of `int`.
    The C++ rule for the initialization of basic types is that they get non-specified
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some situations, the values of variables are set to `0` when they are not
    initialized. This might happen because of some details in the implementation of
    the operating system, the standard library, or the compiler, and the C++ standard
    does not guarantee it. A program will have strange bugs when it relies on this
    behavior, since it is unpredictable when variables are initialized to `0`. Always
    explicitly initialize variables with basic types.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way to initialize data members is by using a **constructor**. A constructor
    is a special member function that has the *same name* as the class and *no return
    type*, and it is called automatically by the compiler when a new object of the
    class is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other function, a constructor can accept parameters and has a function
    body. We can invoke a constructor by adding a parameter list after the name of
    the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When there are no parameters, we can avoid using parentheses, which is what
    we did in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a constructor with no parameters for the `Rectangle` struct would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the only operation the constructor does is initialize the data members,
    opt for using the initialization list, which we will show you later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to assigning values to data members, a constructor can also execute
    code, similar to a normal function body. This is important for the concept of
    the *class invariant*.
  prefs: []
  type: TYPE_NORMAL
- en: A key advantage of hiding the implementation of a class in *private* members
    and only exposing *public* methods to interact with the concept represented by
    the class is the ability to enforce a class invariant.
  prefs: []
  type: TYPE_NORMAL
- en: A class invariant is a property or a set of properties of a class that should
    be `true` for any given instance of the class, at any point. It is called `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a class that requires a class invariant. Imagine
    that we want to create a class that represents a date. The date would contain
    a year, month, and day, all represented as integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement it as a `struct` with all the fields as `public`. Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the user could easily do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous code does not make any sense, as there are only 12 months in the
    Gregorian calendar.
  prefs: []
  type: TYPE_NORMAL
- en: A class invariant for the date would be that the month is always between 1 and
    12, and that the day is always between 1 and 31, and depending on the month, even
    less.
  prefs: []
  type: TYPE_NORMAL
- en: Independently of any change the user performs on the `Date` object, the invariant
    must always hold.
  prefs: []
  type: TYPE_NORMAL
- en: A class can hide the detail that the date is stored as three integers and expose
    the functions to interact with the `Date` object. Functions can expect to find
    the dates to always be in a valid state (the invariant is satisfied at the start
    of the function), and they need to make sure to leave the class in a valid state
    (the invariant is satisfied at the end of the function).
  prefs: []
  type: TYPE_NORMAL
- en: The constructor does not only initialize the data members but also ensure that
    the class respects the invariant. After the constructor is executed, the invariant
    must be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The concept of an invariant is not specific to the C++ language, and there is
    no dedicated facility to specify the invariant of a class. A best practice is
    to document the expected invariant of the class together with the class code so
    that the developers working with the class can easily check what the expected
    invariant is and make sure they respect it.
  prefs: []
  type: TYPE_NORMAL
- en: Using assertions in code also helps in identifying when the invariant is not
    respected. This probably means there is a bug in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to other functions, we can overload the constructor by accepting different
    parameters. This is useful when an object can be created in several ways, since
    the user can create the object by providing the expected parameter, and the correct
    constructor is going to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We showed an example of a default constructor for the `Rectangle` class earlier
    in this chapter. If we want to add a constructor that creates a rectangle from
    a square, we could add the following constructor to the `Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second constructor is an overloaded constructor and will be invoked according
    to the way the class object is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the first line will call the constructor with empty
    parameters, while the second line will call the overloaded constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A constructor with a single non-default parameter is also called a **converting
    constructor**. This kind of constructor specifies an implicit conversion, from
    the type of the argument to the class type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following conversion is possible according to the previous definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is initialized, and it converts from type `Square` to `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the compiler can create implicit conversions when calling functions,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When calling `use_rectangle`, the compiler creates a new object of type `Rectangle`
    by calling the conversion constructor, which accepts a `Square`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to avoid this is to use the `explicit` specifier before the constructor
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a different implementation of `Rectangle`, which has an explicit
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use try to use `Square` to call a function that takes `ExplicitRectangle`,
    we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Constructor Member Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructors, as we''ve seen already, are used to initialize members. Up until
    now, we have initialized the members inside the body of the function by assigning
    values to members directly. C++ provides a feature to initialize the values of
    fields of the class in a more ergonomic way: initialization lists. Initialization
    lists allow you to call the constructor of the data members of class before the
    constructor body is executed. To write an initializer list, insert a colon (`:`)
    and a comma-separated list of initializations for class members before the constructor''s
    body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note how, in this last case, the constructor does nothing other than initialize
    its members. Hence, it has an empty function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to print the width and the height of the `Rectangle` object,
    we will notice that they are correctly initialized to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Initializer lists are the recommended way to initialize member variables in
    C++, and they are necessary when a data member is `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an initializer list, the order in which the members are constructed
    is the one in which they are declared inside the class; not the one in which they
    appear in the initializer list. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When calling the default constructor of the `Example` class, the `first` method
    will be initialized first, and the `second` method after it, even if they appear
    in a different order in the initializer list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should always write the members in the initializer list in the same order
    as they are declared; compilers will help you by warning you when the order differs
    from the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate Classes Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes or structs with no user-declared constructors, no private or protected
    specifiers non-static data members, no base classes, and no virtual functions
    are considered aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will talk about base classes and virtual functions in chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types of classes can be initialized, even though they do not have a constructor,
    by using a brace-enclosed comma-separated list of initializer-clauses, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Destructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *destructor* function is called automatically when the object goes out of
    scope and is used to destroy objects of its class type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructors have the same name as the class preceded by a tilde (`~`) and do
    not take any argument nor return any value (not even void). Let''s examine the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After executing the body of the destructor and destroying any automatic objects
    allocated within the body, a destructor for a class calls the destructors for
    all the direct members of the class. Data members are destroyed in reverse order
    of their construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Creating a Simple Coordinate Program to Demonstrate the Use of
    Constructors and Destructors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a simple program to demonstrate the use of constructors and destructors:'
  prefs: []
  type: TYPE_NORMAL
- en: First, include the required header files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `Coordinates` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` function, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Default Constructor and Destructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the classes needs constructor and destructor functions. When the programmer
    does not define these, the compiler automatically creates an implicitly defined
    constructor and destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The default constructor might not initialize data members. Classes that have
    members of a built-in or compound type should ordinarily either initialize those
    members inside the class or define their version of the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8: Representing Positions in a 2D Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alice is building a program to show 2D maps of the world. Users need to be able
    to save locations, such as their house, a restaurant, or their workplace. To enable
    this functionality, Alice needs to be able to represent a position in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Coordinates` whose data members are the 2D coordinates
    of a point. To ensure that the object is always properly initialized, implement
    a constructor to initialize the data members of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a class named `Coordinates` containing the coordinates
    as data members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, there are two floating-point values, `_latitude` and `_longitude`, which
    identify the coordinates on a geographic coordinate system. Additionally, these
    data members are defined with the `private` access specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the class with a `public` constructor that takes two arguments, `latitude`
    and `longitude`, which are used to initialize the data members of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice can now use this `Coordinates` class to represent 2D positions on the
    map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 289.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Resource Acquisition Is Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Resource Acquisition Is Initialization**, or just **RAII**, is a programming
    idiom that is used to manage the life cycle of a resource automatically by binding
    it to the lifetime of an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Through the smart use of the constructor and destructor of an object, you can
    achieve RAII. The former acquires the resource, while the latter takes care of
    realizing it. The constructor is allowed to throw an exception, when a resource
    cannot be acquired, while the destructor must never throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, it is a good practice to operate on a resource via an instance of
    a RAII class when its usage involves `open()`/`close()`, `lock()`/`unlock()`,
    `start()`/`stop()`, `init()`/`destroy()`, or similar function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a way to open and close a file using an RAII-style mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C++, like many languages, represents input/output operations as streams, where
    data can be written to or read from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the class opens the file into a provided stream, while the
    destructor closes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To open the file, it is sufficient to provide the file path to the `file_handle`
    class. Then, for the entire lifetime of the `file_handle` object, the file will
    not be closed. Once the object reaches the end of the scope, the file is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used instead of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Even though the benefit provided by applying the RAII idiom seems to be just
    to reduce code, the real improvement is having safer code. It is common for a
    programmer to write a function that correctly opens a file but never closes it
    or allocates memory that never gets destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: RAII makes sure that these operations cannot be forgotten, as it automatically
    handles them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9: Storing Multiple Coordinates of Different Positions on a Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the 2D map program, the user can save multiple positions on the map. We
    need to be able to store multiple coordinates to keep track of the positions saved
    by the user. To do so, we need a way to create an array that can store them:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the RAII programming idiom, write a class that manages memory allocation
    and the deletion of an array of values . The class has an array of integers as
    member data, which will be used to store the values .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor takes the size of the array as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor also takes care of allocating memory, which is used to store
    the coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To allocate the memory use the function `allocate_memory` (number of elements)
    which returns a pointer to an array of Coordinates of the requested size. To release
    the memory, call `release_memory` (array) which takes an array of Coordinates
    and releases the memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, define a destructor and make sure to free the previously allocated
    array in its implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 290.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Nested Class Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the scope of a class, we can declare more than just data members and
    member functions; we can declare a class inside another class. These classes are
    called **nested classes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a nested class declaration happens inside the *outer class*, it has access
    to all the declared names as if it were part of the outer class: it can access
    even **private declarations**.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a nested class is not associated with any instance, so it
    can only access *static members*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a nested class, we can use the double colon (`::`), similar to accessing
    static members of the outer class. Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested classes are useful for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a class, we need an object that manages some of the logic
    of the class. In such cases, the nested class is usually **private**, and is not
    exposed through the **public interface** of the class. It is mostly used to ease
    the implementation of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When designing the functionality of a class, we want to provide a different
    class, closely related to the original one, which provides part of that functionality.
    In that case, the class is accessible by the users of the class and is usually
    an important part of the interaction with the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine a list â€“ a sequence of objects. We would like the user to be able to
    iterate over the items contained in the list. To do so, we need to keep track
    of which items the user has already iterated over and which are remaining. This
    is typically done with an `List` class.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at iterators more in detail in *Lesson 5*, *Standard Library Containers
    and Algorithms*.
  prefs: []
  type: TYPE_NORMAL
- en: Friend Specifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have already seen, private and protected members of a class are not accessible
    from within other functions and classes. A class can declare another function
    or class as a friend: this function or class will have access to the private and
    protected members of the class which declares the **friend relationship**.'
  prefs: []
  type: TYPE_NORMAL
- en: The user has to specify the `friend` declaration within the body of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Friend Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Friend functions are non-member functions that are entitled to access the private
    and protected members of a class. The way to declare a function as a `friend`
    function is by adding its declaration within the class and preceding it by the
    `friend` keyword. Let''s examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the function declared outside of the class scope has
    the right to access the class data members because it is declared as a `friend`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Friend Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, like a `friend` function, a class can also be made a friend of another
    class by using the `friend` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class as a `friend` is like declaring all of its methods as friend
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Friendship is not mutual. If a class is a friend of another, then the opposite
    is not automatically true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the concept of how friendship is not mutual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Friendship is not transitive; so, in the previous example, class `C` is not
    a friend of class `A,` and the methods of class `C` cannot access the protected
    or private members of class `A`. Additionally, `A` cannot access B's private members,
    since `B` is a friend of `A`, but friendship is not mutual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Creating a Program to Print the User''s Height'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a program that collects height input from the user in inches and,
    after performing a calculation, prints the height of the user in feet:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's add all the required header files to the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the `Height` class with one `public` method, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, in the previous code, we used a friend function named `print_feet`.
    Now, let''s declare it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the class in the `main` function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activity 10: The AppleTree Class, which Creates an Apple Instance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we would like to prevent the creation of an object of a specific
    type except for a limited number of classes. This usually happens when the classes
    are strictly related.
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Apple` class that does not provide a `public` constructor and an
    `AppleTree` class that is in charge of creating the former object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a class with a `private` constructor. In this way,
    the object cannot be constructed, because the constructor is not publicly accessible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AppleTree` class is defined and contains a method called `createFruit`,
    which is in charge of creating an `Apple` and returning it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we compile this code, we will get an error. At this point, the `Apple` constructor
    is `private`, so the `AppleTree` class cannot access it. We need to declare the
    `AppleTree` class as a `friend` of `Apple` to allow `AppleTree` to access the
    private methods of `Apple`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Apple` object can now be constructed using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 291.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy Constructors and Assignment Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One special type of constructor is the `const` qualified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code refers to a class with a user-defined copy constructor,
    which copies the data member of the other object into the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A copy constructor is declared *implicitly* by the compiler when the class definition
    does not explicitly declare a copy constructor and all the data members have a
    copy constructor. This implicit copy constructor performs a copy of the class
    members in the *same order* of initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When `C` is copy constructed, the members are copied in order: first, `a` is
    copied and then `b` is copied. To copy `A` and `B`, the compiler calls the copy
    constructor defined in those classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a pointer is copied, we are not copying the object pointed to, but simply
    the address at which the object is located.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when a class contains a `pointer` as a data member, the implicit
    copy constructor only copies the pointer and not the pointed object, so the copied
    object and the original one will share the object that's pointed to by the pointer.
    This is sometimes called a **shallow copy**.
  prefs: []
  type: TYPE_NORMAL
- en: The copy Assignment Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way to copy an object is by using the **copy assignment operator**,
    which, contrary to the construct operator, is called when the object has been
    already initialized.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator signature and implementation look quite similar to the
    copy constructor, with the only difference being that the former is an overload
    of the `=` operator and it generally returns a reference to `*this`, although
    it's not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of the use of the copy assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Also, for the copy assignment operator, the compiler generates an *implicit*
    one when it is not explicitly declared. As for the copy constructor, the members
    are copied in the same order of initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the copy constructor and the copy assignment operator
    will output a sentence when they are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows two ways of copying an object. The former uses the
    copy constructor, while the latter uses the copy assignment operator. The two
    implementations will print a sentence when they are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The move-constructor and move-assignment Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like copying, moving also allows you to set the data members of an object to
    be equal to those of another data member. The only difference with copying lies
    in the fact that the content is transferred from one object to another, removing
    it from the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The move-constructor and move-assignment are members that take a parameter
    of type `rvalue` reference to the `class` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For clarity, we can briefly describe an `rvalue` reference (formed by placing
    an `&&` operator after the type of the function argument) as a value that does
    not have a memory address and does not persist beyond a single expression, for
    example, a **temporary object**.
  prefs: []
  type: TYPE_NORMAL
- en: A move constructor and a move assignment operator enable the resources owned
    by an `rvalue` object to be moved into an `lvalue` without copying.
  prefs: []
  type: TYPE_NORMAL
- en: When we move a construct or assign a source object to a destination object,
    we transfer the content of the source object into the destination object, but
    the source object needs to remain valid. To do so, when implementing such methods,
    it is fundamental to reset the data members of the source object to a valid value.
    This is necessary to prevent the destructor from freeing the resources (such as
    memory) of the class multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that there is a `Resource` that can be acquired, released, reset,
    and checked if it's reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `WrongMove` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The move-constructor of the `WrongMove` class will release the resource twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the move constructor should have reset the `_resource` member of other,
    so that the destructor would not call `release_resource` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The move constructor and move assignment operator can be implicitly generated
    by the compiler if no user-defined ones are provided and there are no user-declared
    destructors, copy constructors, or copy or move assignment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Preventing Implicit Constructors and Assignment Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler will implicitly generate the copy constructor, copy assignment,
    move constructor, and move assignment if our class respects all the required conditions.
  prefs: []
  type: TYPE_NORMAL
- en: For cases in which our class should not be copied or moved, we can prevent that.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the generation of implicit constructors and operators, we can write
    the declaration of the constructor or operator and add `= delete`; at the end
    of the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Operator Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ classes represent user-defined types. So, the need arises to be able to
    operate with these types in a different way. Some operator functions may have
    a different meaning when operating on different types. **Operator overloading**
    lets you define the meaning of an operator when applied to a class type object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `+` operator applied to numerical types is different than when
    it is applied to the following `Point` class, which is constituted of coordinates.
    The language cannot specify what the `+` operator should do for user-defined types
    such as `Point`, as it is not in control of such types and does not know what
    the expected behavior is. Because of that, the language does not define the operators
    for user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: However, C++ allows the user to specify the behavior of most operators for user-defined
    types, including classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `+` operator, defined for the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a list of all the operators that can and cannot be overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the operators that can be overloaded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.4: Operators that can be overloaded](img/C11557_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Operators that can be overloaded'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the operators that cannot be overloaded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.5: Operators that cannot be overloaded](img/C11557_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Operators that cannot be overloaded'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Operators that expect two operands are called `+`, `-`, `*`, and `/`.
  prefs: []
  type: TYPE_NORMAL
- en: A method overloading a binary operator needs to accept a single parameter. When
    the compiler encounters the use of the operator, it will call the method on the
    variable on the left-hand side of the operator, while the variable on the right-hand
    side will be passed as parameter to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw in the previous example that `Point` defines the `+` operator, which
    takes a parameter. When using the addition operation on a `Point`, the code would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line from the code example is equivalent to writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The compiler automatically rewrites the first expression to the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Operators that expect only one operand are called `--`, `++`, and `!`.
  prefs: []
  type: TYPE_NORMAL
- en: A method overloading a unary operator must not accept any parameters. When the
    compiler encounters the use of the operator, it will call the method on the variable
    to which the operator is assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s say we are given an object that''s defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is therefore rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Operator overloading is possible in two ways: either as a member function or
    as a non-member function. The two end up producing the same effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11: Ordering Point Objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the 2D map application, we want to be able to display the locations that
    have been saved by the user in order: from South-West to North-East. To be able
    to show the locations in order, we need to be able to sort the location points
    representing the locations in such an order.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the `x` coordinate represents the location along the West-East
    axis and the `y` coordinate represents the location along the North-South axis.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-life scenario, to compare two points, we need to compare their `x`
    and `y` coordinates. To do so in code, we need to overload the `<` operator for
    the `Point` class. This new function we're defining returns a `bool`, either `true`
    or `false`, according to the order of `p_1` and `p_2`.
  prefs: []
  type: TYPE_NORMAL
- en: The `p_1` point comes before than `p_2` in the order if the `x` coordinate of
    `p_1` is less than the `x` coordinate of `p_2`. If they are equal, then we need
    to compare their `y` coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add an overload for the `<` operator to the `Point` class that we
    previously defined, which takes another object of type `Point` as an argument
    and returns a `bool` indicating whether the object is less than the one provided
    as a parameter, using the previous definition for how to compare two points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we are able to compare two `Point` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since, in our example, `p_1.x` is initialized to `1` and `p_2.x` to `2`, the
    result of the comparison will be `true`, which indicates that `p_1` comes earlier
    than `p_2` in the order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 293.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Introducing Functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `operator()` function is also known as the **function call operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax that''s used to define a `functor` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The function call operator has a return type and takes any number of arguments
    of any type. To invoke the call operator of an object, we can write the name of
    the object, followed by parentheses containing the arguments to pass to the operator.
    You can imagine that an object that provides a call operator can be used in the
    same way as you would use a function. Here''s an example of a `functor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: They are particularly useful in places where you can pass a function object
    to an algorithmic template that accepts an object with `operator()` defined. This
    exploits code reusability and testability. We will see more on this in chapter
    5 when we talk about **lambda**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of a `functor` that prints a string before
    appending a new line at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 12: Implementing Functors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function object that takes a number when constructed and defines an
    operator call that takes another number and returns the sum of the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to achieve the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class by the name of `AddX`, constituted by a `private` data member
    of type `int`, and a constructor that is used to initialize it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend it with the call operator, `operator()`, which takes an `int` as a parameter
    and returns an `int`. The implementation in the function body should return the
    addition of the previously defined `x` value and the parameter of the function
    named `y`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instantiate an object of the class we just defined and invoke the calling operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 294.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we saw how the concept of classes can be used in C++. We started
    by delineating the advantages of using classes, describing how they can help us
    to create powerful abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: We outlined the access modifiers a class can use to control who has access to
    class fields and methods.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by exploring the conceptual differences between a class and its
    instances, along with the implications this has when implementing static fields
    and static methods.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how constructors are used to initialize classes and their members, while
    destructors are used to clean up the resources that are managed by a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then explored how constructors and destructors can be combined to implement
    the fundamental paradigm C++ is famous for: RAII. We showed how RAII makes it
    easy to create classes that handle resources and make programs safer and easier
    to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced the concept of operator overloading and how it can be
    used to create classes that are as easy to use as built-in types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll focus on templates. We'll primarily look at how to
    implement template functions and classes, and write code that works for multiple
    types.
  prefs: []
  type: TYPE_NORMAL
