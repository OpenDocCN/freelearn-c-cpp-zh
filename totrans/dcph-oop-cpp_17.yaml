- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Applying the Factory Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用工厂模式
- en: This chapter will continue our pursuit to expand your C++ programming repertoire
    beyond core OOP concepts, with the goal of enabling you to solve recurring types
    of coding problems utilizing common design patterns. We know that incorporating
    design patterns can enhance code maintenance and provide avenues for potential
    code reuse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续我们的追求，以扩展你的C++编程工具箱，使其超越核心OOP概念，目标是使你能够利用常见的设计模式解决重复出现的编码问题。我们知道，结合设计模式可以增强代码维护性，并为潜在的代码重用提供途径。
- en: Continuing to demonstrate and explain popular design patterns and idioms and
    learning how to implement them effectively in C++, we continue our quest with
    the Factory pattern, more precisely known as the **Factory Method pattern**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 继续演示和解释流行的设计模式和惯用法，并学习如何在C++中有效地实现它们，我们继续我们的探索之旅，这次是工厂模式，更确切地说是**工厂方法模式**。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the Factory Method pattern and how it contributes to OOP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解工厂方法模式及其对面向对象编程（OOP）的贡献
- en: Understanding how to implement the Factory Method pattern with and without an
    Object Factory, and comparing an Object Factory to an Abstract Factory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用和没有对象工厂实现工厂方法模式，以及比较对象工厂和抽象工厂
- en: By the end of this chapter, you will understand the popular Factory Method pattern.
    We will see two example implementations of this pattern in C++. Adding additional
    core design patterns to your programming repertoire will enable you to become
    a more sophisticated and valuable programmer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解流行的工厂方法模式。我们将看到C++中该模式的两个示例实现。将更多的核心设计模式添加到你的编程工具箱中，将使你成为一个更复杂且更有价值的程序员。
- en: Let’s increase our programming skillset by examining another common design pattern,
    the Factory Method pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究另一个常见的设计模式，即工厂方法模式，让我们提高我们的编程技能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter17` in a file named `Chp17-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter17`子目录中找到，文件名为`Chp17-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3QOmCC1](https://bit.ly/3QOmCC1).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下网址查看：[https://bit.ly/3QOmCC1](https://bit.ly/3QOmCC1)。
- en: Understanding the Factory Method pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解工厂方法模式
- en: The **Factory pattern**, or **Factory Method pattern**, is a creational design
    pattern that allows the creation of objects without needing to specify the exact
    (derived) class that will be instantiated. A Factory Method pattern provides an
    interface for creating an object, yet allows details within the creation method
    to decide which (derived) class to instantiate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂模式**，或称为**工厂方法模式**，是一种创建型设计模式，它允许在不指定将要实例化的确切（派生）类的情况下创建对象。工厂方法模式提供了一个创建对象的接口，同时允许创建方法中的细节决定要实例化哪个（派生）类。'
- en: A Factory Method pattern is also known as a **virtual constructor**. Much as
    a virtual destructor has the specific destructor (which is the entry point of
    the destruction sequence) determined at runtime through dynamic binding, the concept
    of a virtual constructor is such that the desired object to instantiate is uniformly
    determined at runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式也被称为**虚拟构造函数**。正如虚拟析构函数具有特定的析构函数（它是销毁序列的入口点），通过动态绑定在运行时确定一样，虚拟构造函数的概念是，在运行时统一确定要实例化的所需对象。
- en: We cannot always anticipate the specific mix of related derived class objects
    needed in an application. A Factory Method (or virtual constructor) can create,
    upon request, an instance of one of many related derived class types, based on
    the input provided. A derived class object will be returned as its base class
    type by the Factory Method, allowing objects to be both created and stored more
    generically. Polymorphic operations can be applied to the newly created (upcasted)
    instances, allowing relevant derived class behaviors to shine through. A Factory
    Method promotes loose coupling with client code by removing the need to bind specific
    derived class types in the client code itself. The client merely utilizes the
    Factory Method to create and provide appropriate instances.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法总是预见到在应用程序中需要的特定相关派生类对象的混合。工厂方法（或虚拟构造函数）可以根据提供的输入，在请求时创建许多相关派生类类型中的一种实例。工厂方法将派生类对象作为其基类类型返回，允许对象以更通用的方式创建和存储。可以将多态操作应用于新创建的（向上转型）实例，使相关的派生类行为得以展现。工厂方法通过消除在客户端代码中绑定特定派生类类型的需要，促进了与客户端代码的松耦合。客户端只需利用工厂方法来创建和提供适当的实例。
- en: With a Factory Method pattern, we will specify an abstract class (or interface)
    for collecting and specifying the general behaviors of derived classes we wish
    to create. The abstract class or interface in this pattern is known as **Product**.
    We then create the derived classes that we may want to instantiate, overriding
    any necessary abstract methods. The various concrete derived classes are known
    as **Concrete Products**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂方法模式，我们将指定一个抽象类（或接口）来收集和指定我们希望创建的派生类的通用行为。在这个模式中的抽象类或接口被称为**产品**。然后我们创建可能想要实例化的派生类，覆盖任何必要的抽象方法。各种具体的派生类被称为**具体产品**。
- en: We then specify a Factory Method whose purpose is to host an interface for uniformly
    creating instances of Concrete Products. The Factory Method can either be placed
    in the abstract Product class or in a separate Object Factory class; an **Object
    Factory** represents a class with the task of creating Concrete Products. This
    Factory (creation) Method will be static if placed within the abstract Product
    class and optionally static if instead placed within an Object Factory class.
    The Factory Method will decide which specific Concrete Product to manufacture,
    based on a consistent list of input parameters. The Factory Method will return
    a generalized Product pointer to the Concrete Product. Polymorphic methods can
    be applied to the newly created object to elicit its specific behavior.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们指定一个工厂方法，其目的是提供一个接口，以统一创建具体产品实例。工厂方法可以放在抽象产品类中，也可以放在单独的对象工厂类中；**对象工厂**代表一个具有创建具体产品任务的类。如果放在抽象产品类中，这个工厂（创建）方法将是静态的；如果放在对象工厂类中，则可选地是静态的。工厂方法将根据一致的输入参数列表决定制造哪个具体的产品。工厂方法将返回一个指向具体产品的通用产品指针。可以将多态方法应用于新创建的对象，以引发其特定行为。
- en: 'The Factory Method pattern will include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式将包括以下内容：
- en: An abstract **Product** class (or interface).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个抽象的**产品**类（或接口）。
- en: Multiple **Concrete Product** derived classes.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个**具体产品**派生类。
- en: A **Factory Method** in either the abstract Product class or in a separate **Object
    Factory** class. The Factory Method will have a uniform interface to create an
    instance of any of the Concrete Product types.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在抽象产品类或单独的**对象工厂**类中的**工厂方法**。工厂方法将具有统一的接口来创建任何具体产品类型的实例。
- en: Concrete Products will be returned by the Factory Method as generalized Product
    instances.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体产品将由工厂方法作为通用产品实例返回。
- en: Keep in mind that a Factory Method (regardless of whether it is in an Object
    Factory) produces Products. A Factory Method provides a uniform manner for producing
    many related Product types. Multiple Factory Methods can exist to produce unique
    Product lines; each Factory Method can be distinguished by a meaningful name,
    even if their signatures happen to be the same.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，工厂方法（无论是否在对象工厂中）产生产品。工厂方法提供了一种统一的方式产生许多相关的产品类型。可以存在多个工厂方法来生产独特的产品线；每个工厂方法可以通过一个有意义的名称来区分，即使它们的签名碰巧是相同的。
- en: Let’s move forward to see two sample implementations of the Factory Method pattern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看工厂方法模式的两个示例实现。
- en: Implementing the Factory Method pattern
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现工厂方法模式
- en: We will explore two common implementations of the Factory Method pattern. Each
    will have design trade-offs, certainly worthy of discussion!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种常见的工厂方法模式的实现。每种实现都会有设计权衡，当然值得讨论！
- en: Let’s start with the technique in which the Factory Method is placed in the
    abstract Product class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将工厂方法放置在抽象产品类中的技术开始。
- en: Including the Factory Method in the Product class
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在产品类中包含工厂方法
- en: To implement the Factory Method pattern, we will first need to create our abstract
    Product class as well as our Concrete Product classes. These class definitions
    will begin the foundation on which to build our pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现工厂方法模式，我们首先需要创建我们的抽象产品类以及我们的具体产物类。这些类定义将为我们构建模式的基础。
- en: In our example, we will create our Product using a class we are accustomed to
    seeing – `Student`. We will then create Concrete Product classes, namely `GradStudent`,
    `UnderGradStudent`, and `NonDegreeStudent`. We will include a Factory Method in
    our Product (`Student`) class with a consistent interface to create any of the
    derived Product types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用我们习惯看到的类来创建我们的产品 – `Student`。然后我们将创建具体的产物类，即`GradStudent`、`UnderGradStudent`和`NonDegreeStudent`。我们将在我们的产品（`Student`）类中包含一个工厂方法，它具有一致的接口来创建任何派生产品类型。
- en: The components we will model complement our framework for our existing `Student`
    application by adding classes to differentiate students based on their educational
    degree goals. The new components provide the basis for a university matriculation
    (new `Student` admission) system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要建模的组件将通过添加基于他们教育学位目标的类来补充我们现有的`Student`应用程序的框架。这些新组件为大学入学（新的`Student`录取）系统提供了基础。
- en: Let us assume that rather than instantiating a `Student`, our application will
    instantiate various types of `Student` – `GradStudent`, `UnderGradStudent`, or
    `NonDegreeStudent` – based on their learning goals. The `Student` class will include
    an abstract polymorphic `Graduate()` operation; each derived class will override
    this method with varying implementations. For example, a `GradStudent` seeking
    a Ph.D. may have more degree-related criteria to satisfy in the `GradStudent::Graduate()`
    method than other specializations of `Student`. They may require credit hours
    to be verified, a passing grade point average to be verified, and verification
    that their dissertation has been accepted. In contrast, an `UnderGradStudent`
    might only have their credit hours and overall grade point average to be corroborated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设，而不是实例化一个`Student`，我们的应用程序将根据他们的学习目标实例化各种类型的`Student` – `GradStudent`、`UnderGradStudent`或`NonDegreeStudent`。`Student`类将包括一个抽象的多态`Graduate()`操作；每个派生类将使用不同的实现覆盖此方法。例如，寻求博士学位的`GradStudent`可能在`GradStudent::Graduate()`方法中需要满足比其他`Student`特殊化更多的学位相关标准。他们可能需要验证学分小时数，验证通过的平均成绩点，以及验证他们的论文已被接受。相比之下，`UnderGradStudent`可能只需要验证他们的学分小时数和整体平均成绩点。
- en: The abstract Product class will include a static method, `MatriculateStudent()`,
    as the Factory Method to create various types of students (the Concrete Product
    types).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象产品类将包括一个静态方法`MatriculateStudent()`作为工厂方法来创建各种类型的学生（具体的产物类型）。
- en: Defining the abstract Product class
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义抽象产品类
- en: 'Let’s first take a look at the mechanics for the implementation of our Factory
    Method, beginning by examining the definition for our abstract Product class,
    `Student`. This example can be found, as a complete program, in our GitHub repository:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看实现我们的工厂方法的具体机制，从检查我们的抽象产品类`Student`的定义开始。这个例子可以作为完整的程序在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous class definition, we introduce our abstract `Student` class,
    which is derived from `Person` (a concrete and hence instantiable class). This
    has been accomplished with the introduction of the abstract method `virtual void
    Graduate() = 0;`. In our student matriculation example, we will be following the
    design decision that only specific types of students should be instantiated, that
    is, derived class types `GradStudent`, `UnderGradStudent`, or `NonDegreeStudent`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们引入了我们的抽象`Student`类，它从`Person`（一个具体类，因此可以实例化）派生而来。这是通过引入抽象方法`virtual
    void Graduate() = 0;`实现的。在我们的学生注册示例中，我们将遵循这样的设计决策：只有特定类型的学生的实例应该被创建，即派生类类型`GradStudent`、`UnderGradStudent`或`NonDegreeStudent`。
- en: In the preceding class definition, notice our Factory Method, with the prototype
    `static Student *MatriculateStudent();`. This method will use a uniform interface
    and will provide the means for the creation of various derived class types of
    `Student`. We will examine this method in detail once we have seen the class definitions
    for the derived classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，请注意我们的工厂方法，其原型为`static Student *MatriculateStudent();`。这个方法将使用统一的接口，并提供创建`Student`的各种派生类类型的手段。一旦我们看到了派生类的类定义，我们将详细研究这个方法。
- en: Defining the Concrete Product classes
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义具体产品类
- en: 'Now, let’s take a look at our Concrete Product classes, starting with `GradStudent`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的具体产品类，从`GradStudent`开始：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned `GradStudent` class definition, we add a `degree` data
    member to indicate a degree of `"PhD"`, `"MS"`, or `"MA"`, and adjust the constructors
    and destructor, as necessary. We have moved `EarnPhD()` to `GradStudent`, as this
    method is not applicable to all `Student` instances. Instead, `EarnPhD()` is applicable
    to a subset of `GradStudent` instances; we will award the title of `"Dr."` only
    to the Ph.D. candidates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`GradStudent`类定义中，我们添加了一个`degree`数据成员来表示“PhD”、“MS”或“MA”学位，并根据需要调整构造函数和析构函数。我们将`EarnPhD()`移动到`GradStudent`中，因为这个方法并不适用于所有`Student`实例。相反，`EarnPhD()`适用于`GradStudent`实例的一个子集；我们只会授予“Dr.”头衔给博士候选人。
- en: In this class, we have overridden `IsA()` to return `"GradStudent"`. We have
    also overridden `Graduate()` to go through the graduation checklist that is applicable
    for graduate students, calling `EarnPhD()` if those checklist items have been
    met.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们重写了`IsA()`以返回`"GradStudent"`。我们还重写了`Graduate()`，以执行适用于研究生的毕业清单，如果清单项目已经满足，则调用`EarnPhD()`。
- en: 'Now, let’s take a look at our next Concrete Product class, `UnderGradStudent`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的下一个具体产品类，`UnderGradStudent`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Quickly taking a look at the previously defined `UnderGradStudent` class, we
    notice that it is very similar to `GradStudent`. This class even includes a `degree`
    data member. Keep in mind that not all `Student` instances will receive degrees,
    so we don’t want to generalize this attribute by defining it in `Student`. Though
    we could have introduced a shared base class of `DegreeSeekingStudent` for `UnderGradStudent`
    and `GradStudent` to collect this commonality, that fine level of granularization
    would add an additional layer almost unnecessarily. The duplication here is a
    design trade-off.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下之前定义的`UnderGradStudent`类，我们会发现它非常类似于`GradStudent`。这个类甚至包括一个`degree`数据成员。记住，并不是所有的`Student`实例都会获得学位，所以我们不希望在`Student`中定义这个属性，从而将其泛化。虽然我们可以为`UnderGradStudent`和`GradStudent`引入一个共享的基类`DegreeSeekingStudent`来收集这种共性，但这种细粒度的层次结构几乎是不必要的。这里的重复是一个设计权衡。
- en: The key difference between these two sibling classes is the overridden `Graduate()`
    method. We can imagine that the checklist for an undergraduate student for graduation
    may be quite different from that of a graduate student. For this reason, we can
    reasonably differentiate the two classes. Otherwise, they are very much the same.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个兄弟类之间的关键区别在于重写的`Graduate()`方法。我们可以想象，本科生毕业的清单可能和研究生毕业的清单有很大不同。因此，我们可以合理地区分这两个类。否则，它们非常相似。
- en: 'Now, let’s take a look at our next Concrete Product class, `NonDegreeStudent`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的下一个具体产品类，`NonDegreeStudent`：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Taking a comparably quick look at the aforementioned `NonDegreeStudent` class,
    we notice that this Concrete Product is similar to its sibling classes. However,
    there is no `degree` data member within this class. Also, the overridden `Graduate()`
    method has less verification to undertake than in the overridden versions of this
    method for either the `GradStudent` or `UnderGradStudent` classes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下前面提到的`NonDegreeStudent`类，我们会注意到这个具体产品与其兄弟类相似。然而，这个类中没有`degree`数据成员。此外，重写的`Graduate()`方法比`GradStudent`或`UnderGradStudent`类中此方法的重写版本需要进行的验证要少。
- en: Examining the Factory Method definition
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查工厂方法定义
- en: 'Next, let’s take a look at our Factory Method, a static method in our Product
    (`Student`) class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的工厂方法，这是我们的产品（`Student`）类中的一个静态方法：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The aforementioned static method of `Student`, `MatriculateStudent()`, represents
    the Factory Method to create various Products (concrete `Student` instances).
    Here, based on the degree type that the `Student` seeks, one of `GradStudent`,
    `UnderGradStudent`, and `NonDegreeStudent` will be instantiated. Notice that the
    signature of `MatriculateStudent()` can handle the parameter requirements for
    any of the derived class constructors. Also notice that any of these specialized
    instance types will be returned as a base class pointer of the abstract Product
    type (`Student`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的`Student`类的静态方法`MatriculateStudent()`代表了工厂方法来创建各种产品（具体的`Student`实例）。在这里，根据`Student`寻求的学位类型，将实例化`GradStudent`、`UnderGradStudent`和`NonDegreeStudent`之一。注意，`MatriculateStudent()`的签名可以处理任何派生类构造函数的参数要求。也请注意，这些专门的实例类型将作为抽象产品类型（`Student`）的基类指针返回。
- en: An interesting option within the Factory Method, `MatriculateStudent()`, is
    that this method is not obligated to instantiate a new derived class instance.
    Instead, it may recycle a previous instance that may still be available. For example,
    imagine a `Student` is temporarily unregistered in the university (due to late
    payment), yet has been kept available on a list of *pending students*. The `MatriculateStudent()`
    method may instead choose to return a pointer to such an existing `Student`. *Recycling*
    is an alternative within a Factory Method!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法中的一个有趣选项是`MatriculateStudent()`，这个方法并不强制实例化一个新的派生类实例。相反，它可能回收一个可能仍然可用的先前实例。例如，想象一个`Student`因为延迟付款而暂时在大学中未注册，但仍然保留在*待处理学生*名单上。`MatriculateStudent()`方法可以选择返回这样一个现有`Student`的指针。*回收*是工厂方法中的一个替代方案！
- en: Bringing the pattern components together
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Finally, let’s now bring all of our various components together by taking a
    look at our `main()` function to see how our Factory Method pattern is orchestrated:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在让我们通过查看`main()`函数来将所有各种组件组合在一起，看看我们的工厂方法模式是如何编排的：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reviewing our aforementioned `main()` function, we first create an array of
    pointers for potentially specialized `Student` instances in their generalized
    `Student` form. Next, we invoke the static Factory Method `Student::MatriculateStudent()`,
    within the abstract Product class, to create the appropriate Concrete Product
    (derived `Student` class type). We create one of each of the derived `Student`
    types – `GradStudent`, `UnderGradStudent`, and `NonDegreeStudent`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们前面提到的`main()`函数，我们首先创建了一个指针数组，用于潜在的专门`Student`实例，以它们的泛化`Student`形式存在。接下来，我们在抽象产品类中调用静态工厂方法`Student::MatriculateStudent()`，以创建适当的具体产品（派生`Student`类类型）。我们创建了每种派生`Student`类型的一个实例——`GradStudent`、`UnderGradStudent`和`NonDegreeStudent`。
- en: We then loop through our generalized collection, calling `Graduate()` and then
    `Print()` for each instance. For students earning a Ph.D. (`GradStudent` instances),
    their title will be changed to `"Dr."` by the `GradStudent::Graduate()` method.
    Finally, we iterate through another loop to deallocate each instance’s memory.
    Thankfully, `Student` has included a virtual destructor so that the destruction
    sequence starts at the proper level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后遍历我们的泛化集合，对每个实例调用`Graduate()`方法，然后调用`Print()`方法。对于获得博士学位的学生（`GradStudent`实例），他们的头衔将通过`GradStudent::Graduate()`方法更改为`"Dr."`。最后，我们通过另一个循环来释放每个实例的内存。幸运的是，`Student`类包含了一个虚析构函数，这样销毁序列就会从正确的级别开始。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An advantage of the preceding implementation is that it is very straightforward.
    However, we can see a close coupling exists between the abstract Product, containing
    the Factory Method (which constructs the derived class types), and the derived
    Concrete Products. Yet in OOP, a base class will ideally have no knowledge of
    any descendent types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现的一个优点是它非常直接。然而，我们可以看到抽象Product（包含Factory Method，它构建派生类类型）和派生具体Product之间存在紧密耦合。然而，在面向对象编程中，基类理想情况下对任何子类类型一无所知。
- en: A disadvantage to this closely coupled implementation is that the abstract Product
    class must include a means for instantiation for each of its descendants in its
    static creation method, `MatriculateStudent()`. Adding new derived classes now
    affects the abstract base class definition – it needs to be recompiled. What if
    we don’t have access to the source code for this base class? Is there a way to
    decouple the dependencies that exist between the Factory Method and the Products
    that the Factory Method will create? Yes, there is an alternate implementation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种紧密耦合的实现的一个缺点是，抽象的Product类必须在它的静态创建方法`MatriculateStudent()`中包含一个实例化的方法，用于其每个子类。现在添加新的派生类会影响抽象基类定义——它需要重新编译。如果我们无法访问这个基类的源代码怎么办？有没有一种方法可以解耦Factory
    Method和Factory Method将要创建的Products之间的依赖关系？是的，有一种替代实现。
- en: Let us now take a look at an alternate implementation of the Factory Method
    pattern. We will instead use an Object Factory class to encapsulate our Factory
    Method of `MatriculateStudent()`, rather than including this method in the abstract
    Product class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看Factory Method模式的另一种实现。我们将使用一个Object Factory类来封装我们的`MatriculateStudent()`Factory
    Method，而不是将其包含在抽象Product类中。
- en: Creating an Object Factory class to encapsulate the Factory Method
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个封装Factory Method的对象工厂类
- en: For our alternative implementation of the Factory Method pattern, we will create
    our abstract Product class with a slight deviation from its previous definition.
    We will, however, create our concrete Product classes as before. These class definitions,
    collectively, will again begin the framework on which to base our pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Factory Method模式的替代实现，我们将创建我们的抽象Product类，与之前的定义略有不同。然而，我们仍然会像以前一样创建我们的具体Product类。这些类定义共同构成了我们模式的基础框架。
- en: In our revised example, we will define our Product again as the `Student` class.
    We will also again derive Concrete Product classes of `GradStudent`, `UnderGradStudent`,
    and `NonDegreeStudent`. This time, however, we will not include a Factory Method
    in our Product (`Student`) class. Instead, we will create a separate Object Factory
    class that will include the Factory Method. As before, the Factory Method will
    have a uniform interface to create any of the derived Product types. The Factory
    Method need not be static, as it was in our last implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的修改后的例子中，我们将再次将Product定义为`Student`类。我们也将再次派生`GradStudent`、`UnderGradStudent`和`NonDegreeStudent`的具体产品类。然而，这一次，我们不会在我们的Product（`Student`）类中包含Factory
    Method。相反，我们将创建一个单独的对象工厂类，该类将包含Factory Method。像以前一样，Factory Method将有一个统一的接口来创建任何派生产品类型。Factory
    Method不需要是静态的，就像我们上一个实现中那样。
- en: Our Object Factory class will include `MatriculateStudent()` as the Factory
    Method to create various types of `Student` instances (the Concrete Product types).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Object Factory类将包括`MatriculateStudent()`作为Factory Method来创建各种类型的`Student`实例（具体产品类型）。
- en: Defining the abstract Product class without the Factory Method
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不包含Factory Method的抽象Product类定义
- en: 'Let’s take a look at the mechanics for our alternate implementation of the
    Factory Method pattern, beginning by examining the definition for our abstract
    Product class, `Student`. This example can be found, as a complete program, in
    our GitHub repository at the following URL:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Factory Method模式替代实现的机制，首先从我们的抽象Product类`Student`的定义开始。这个例子可以作为完整的程序，在我们的GitHub仓库中找到，以下URL：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp)'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our aforementioned class definition for `Student`, the key difference from
    our prior implementation is that this class no longer contains a static `MatriculateStudent()`
    method to serve as the Factory Method. `Student` is merely an abstract base class.
    Remember, all graduate students, undergraduate students, and non-degree students
    are all specializations of `Student`, therefore `static int numStudents` is a
    shared, collective count of all types of `Student`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前提到的`Student`类定义中，与之前的实现相比，关键的不同之处在于这个类不再包含一个静态的`MatriculateStudent()`方法作为工厂方法。`Student`仅仅是一个抽象基类。记住，所有的研究生、本科生和非学位学生都是`Student`的特化形式，因此`static
    int numStudents`是所有`Student`类型的一个共享、集体计数。
- en: Defining the Concrete Product classes
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义具体产品类
- en: 'With that in mind, let’s take a look at the derived (Concrete Product) classes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看派生（具体产品）类：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our previously listed class definitions, we can see that our Concrete derived
    Product classes are identical to our implementation for these classes as in our
    first example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前列出的类定义中，我们可以看到我们的具体派生产品类与我们在第一个示例中的这些类的实现是相同的。
- en: Adding the Object Factory class with the Factory Method
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加带有工厂方法的对象工厂类
- en: 'Next, let us introduce an Object Factory class that includes our Factory Method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们介绍一个包含我们的工厂方法的对象工厂类：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the aforementioned Object Factory class definition (the `StudentFactory`
    class), we minimally include the Factory Method specification, namely, `MatriculateStudent()`.
    The method is very similar to that in our prior example. However, by capturing
    the creation of Concrete Products in an Object Factory, we have decoupled the
    relationship between the abstract Product and the Factory Method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的对象工厂类定义（`StudentFactory`类）中，我们最小化地包含了工厂方法规范，即`MatriculateStudent()`。该方法与之前的示例非常相似。然而，通过在对象工厂中捕获具体产品的创建，我们将抽象产品与工厂方法之间的关系解耦了。
- en: Bringing the pattern components together
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Next, let’s compare our `main()` function to that of our original example to
    visualize how our revised components implement the Factory Method pattern:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们比较我们的`main()`函数与原始示例，以可视化我们修改后的组件如何实现工厂方法模式：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Considering our previously listed `main()` function, we see that we have again
    created an array of pointers to the abstract Product type (`Student`). We have
    then instantiated an Object Factory that can create various `Student` instances
    of Concrete Product types with `StudentFactory *UofD = new StudentFactory();`.
    As with the previous example, one instance of each derived type `GradStudent`,
    `UnderGradStudent`, and `NonDegreeStudent` is created by the Object Factory based
    upon the degree type sought by each student. The remainder of the code in `main()`
    is as found in our prior example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前列出的`main()`函数，我们看到我们再次创建了一个指向抽象产品类型（`Student`）的指针数组。然后我们实例化了一个对象工厂，它可以创建各种具体产品类型的`Student`实例，使用`StudentFactory
    *UofD = new StudentFactory();`。与之前的示例一样，根据每个学生的学位类型，对象工厂创建了每种派生类型`GradStudent`、`UnderGradStudent`和`NonDegreeStudent`的一个实例。`main()`中的其余代码与之前的示例相同。
- en: Our output will be the same as our last example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果将与我们的上一个示例相同。
- en: The advantage of the Object Factory class over our prior means of implementation
    is that we have removed the dependency of object creation from our abstract Product
    class (in the Factory Method) with knowledge of what the derived class types are.
    That is, should we expand our hierarchy to include new Concrete Product types,
    we do not have to modify the abstract Product class. Of course, we will need to
    have access to modify our Object Factory class, `StudentFactory`, to augment our
    `MatriculateStudent()` Factory Method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的方法相比，对象工厂类的优势在于我们消除了从抽象产品类（在工厂方法中）创建对象的知识依赖。也就是说，如果我们扩展我们的层次结构以包括新的具体产品类型，我们不需要修改抽象产品类。当然，我们需要能够修改我们的对象工厂类`StudentFactory`，以增强我们的`MatriculateStudent()`工厂方法。
- en: A pattern related to this implementation, an **Abstract Factory**, is an additional
    pattern that allows individual factories with a similar purpose to be grouped
    together. An Abstract Factory can be specified to provide a means to unify similar
    Object Factories; it is a factory that will create factories, adding yet another
    level of abstraction to our original pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与此实现相关的模式，即**抽象工厂**，是一种允许具有相似目的的单独工厂被分组在一起的附加模式。抽象工厂可以指定提供一种统一类似对象工厂的方法；它是一个将创建工厂的工厂，为我们的原始模式增加了另一个抽象层次。
- en: We have now seen two implementations of the Factory Method pattern. We have
    folded the concepts of Product and Factory Method into the framework of classes
    we are accustomed to seeing, namely `Student`, and descendants of `Student`. Let’s
    now briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了工厂方法模式的两种实现。我们将产品和工厂方法的概念融合到了我们习惯看到的类框架中，即`Student`及其`Student`的派生类。现在，让我们简要回顾一下与模式相关的内容，然后再继续下一章。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have continued our pursuit to become better C++ programmers
    by expanding our knowledge of design patterns. In particular, we have explored
    the Factory Method pattern, both conceptually and with two common implementations.
    Our first implementation included placing the Factory Method in our abstract Product
    class. Our second implementation removed the dependency between our Abstract Product
    and our Factory Method by instead adding an Object Factory class to contain our
    Factory Method. We also very briefly discussed the notion of an Abstract Factory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过扩展我们对设计模式的知识，继续追求成为更好的 C++ 程序员。特别是，我们探讨了工厂方法模式，从概念上以及通过两种常见的实现方式进行了研究。我们的第一个实现是将工厂方法放置在我们的抽象产品类中。我们的第二个实现通过添加一个包含工厂方法的对象工厂类，而不是在抽象产品和工厂方法之间建立依赖关系，从而消除了这种依赖。我们还非常简短地讨论了抽象工厂的概念。
- en: Utilizing common design patterns, such as the Factory Method pattern, will help
    you more easily solve recurring types of programming problems in a manner understood
    by other programmers. By utilizing core design patterns, you will be contributing
    to well-understood and reusable solutions with more sophisticated programming
    techniques.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 利用常见的模式，如工厂方法模式，将帮助您更轻松地以其他程序员能理解的方式解决重复出现的编程问题。通过利用核心设计模式，您将为具有更复杂编程技术的可理解和可重用解决方案做出贡献。
- en: We are now ready to continue forward with our next design pattern, in [*Chapter
    18*](B19087_18.xhtml#_idTextAnchor783), *Implementing the Adapter Pattern*. Adding
    more patterns to our collection of skills makes us more versatile and valued programmers.
    Let’s continue onward!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续前进，学习下一个设计模式，即[*第 18 章*](B19087_18.xhtml#_idTextAnchor783)中的*实现适配器模式*。将更多模式添加到我们的技能集合中，使我们成为更灵活、更有价值的程序员。让我们继续前进！
- en: Questions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Using the solution from a previous exercise (*Question 1*, [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*), augment your code as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前练习的解决方案（*问题 1*，[*第 8 章*](B19087_08.xhtml#_idTextAnchor399)，*掌握抽象类*），按照以下方式增强您的代码：
- en: Implement the Factory Method pattern to create various shapes. You will have
    already created an abstract base class of `Shape` and derived classes such as
    `Rectangle`, `Circle`, `Triangle`, and possibly `Square`.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现工厂方法模式以创建各种形状。你将已经创建了一个抽象基类`Shape`以及派生类，如`Rectangle`、`Circle`、`Triangle`，以及可能的`Square`。
- en: Choose whether to implement your Factory Method as a static method in `Shape`
    or as a method in a `ShapeFactory` class (introducing the latter class if necessary).
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择是否将您的工厂方法实现为`Shape`中的静态方法，或者作为`ShapeFactory`类中的方法（如果需要，引入此类）。
- en: What other examples can you imagine that might easily incorporate the Factory
    Method pattern?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想象出哪些其他例子可以轻松地结合工厂方法模式？
