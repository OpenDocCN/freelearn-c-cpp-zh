- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying the Factory Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit to expand your C++ programming repertoire
    beyond core OOP concepts, with the goal of enabling you to solve recurring types
    of coding problems utilizing common design patterns. We know that incorporating
    design patterns can enhance code maintenance and provide avenues for potential
    code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to demonstrate and explain popular design patterns and idioms and
    learning how to implement them effectively in C++, we continue our quest with
    the Factory pattern, more precisely known as the **Factory Method pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Factory Method pattern and how it contributes to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to implement the Factory Method pattern with and without an
    Object Factory, and comparing an Object Factory to an Abstract Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the popular Factory Method pattern.
    We will see two example implementations of this pattern in C++. Adding additional
    core design patterns to your programming repertoire will enable you to become
    a more sophisticated and valuable programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our programming skillset by examining another common design pattern,
    the Factory Method pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter17` in a file named `Chp17-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3QOmCC1](https://bit.ly/3QOmCC1).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Factory Method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Factory pattern**, or **Factory Method pattern**, is a creational design
    pattern that allows the creation of objects without needing to specify the exact
    (derived) class that will be instantiated. A Factory Method pattern provides an
    interface for creating an object, yet allows details within the creation method
    to decide which (derived) class to instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: A Factory Method pattern is also known as a **virtual constructor**. Much as
    a virtual destructor has the specific destructor (which is the entry point of
    the destruction sequence) determined at runtime through dynamic binding, the concept
    of a virtual constructor is such that the desired object to instantiate is uniformly
    determined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot always anticipate the specific mix of related derived class objects
    needed in an application. A Factory Method (or virtual constructor) can create,
    upon request, an instance of one of many related derived class types, based on
    the input provided. A derived class object will be returned as its base class
    type by the Factory Method, allowing objects to be both created and stored more
    generically. Polymorphic operations can be applied to the newly created (upcasted)
    instances, allowing relevant derived class behaviors to shine through. A Factory
    Method promotes loose coupling with client code by removing the need to bind specific
    derived class types in the client code itself. The client merely utilizes the
    Factory Method to create and provide appropriate instances.
  prefs: []
  type: TYPE_NORMAL
- en: With a Factory Method pattern, we will specify an abstract class (or interface)
    for collecting and specifying the general behaviors of derived classes we wish
    to create. The abstract class or interface in this pattern is known as **Product**.
    We then create the derived classes that we may want to instantiate, overriding
    any necessary abstract methods. The various concrete derived classes are known
    as **Concrete Products**.
  prefs: []
  type: TYPE_NORMAL
- en: We then specify a Factory Method whose purpose is to host an interface for uniformly
    creating instances of Concrete Products. The Factory Method can either be placed
    in the abstract Product class or in a separate Object Factory class; an **Object
    Factory** represents a class with the task of creating Concrete Products. This
    Factory (creation) Method will be static if placed within the abstract Product
    class and optionally static if instead placed within an Object Factory class.
    The Factory Method will decide which specific Concrete Product to manufacture,
    based on a consistent list of input parameters. The Factory Method will return
    a generalized Product pointer to the Concrete Product. Polymorphic methods can
    be applied to the newly created object to elicit its specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Factory Method pattern will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract **Product** class (or interface).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple **Concrete Product** derived classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Factory Method** in either the abstract Product class or in a separate **Object
    Factory** class. The Factory Method will have a uniform interface to create an
    instance of any of the Concrete Product types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete Products will be returned by the Factory Method as generalized Product
    instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that a Factory Method (regardless of whether it is in an Object
    Factory) produces Products. A Factory Method provides a uniform manner for producing
    many related Product types. Multiple Factory Methods can exist to produce unique
    Product lines; each Factory Method can be distinguished by a meaningful name,
    even if their signatures happen to be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to see two sample implementations of the Factory Method pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Factory Method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will explore two common implementations of the Factory Method pattern. Each
    will have design trade-offs, certainly worthy of discussion!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the technique in which the Factory Method is placed in the
    abstract Product class.
  prefs: []
  type: TYPE_NORMAL
- en: Including the Factory Method in the Product class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the Factory Method pattern, we will first need to create our abstract
    Product class as well as our Concrete Product classes. These class definitions
    will begin the foundation on which to build our pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will create our Product using a class we are accustomed to
    seeing – `Student`. We will then create Concrete Product classes, namely `GradStudent`,
    `UnderGradStudent`, and `NonDegreeStudent`. We will include a Factory Method in
    our Product (`Student`) class with a consistent interface to create any of the
    derived Product types.
  prefs: []
  type: TYPE_NORMAL
- en: The components we will model complement our framework for our existing `Student`
    application by adding classes to differentiate students based on their educational
    degree goals. The new components provide the basis for a university matriculation
    (new `Student` admission) system.
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume that rather than instantiating a `Student`, our application will
    instantiate various types of `Student` – `GradStudent`, `UnderGradStudent`, or
    `NonDegreeStudent` – based on their learning goals. The `Student` class will include
    an abstract polymorphic `Graduate()` operation; each derived class will override
    this method with varying implementations. For example, a `GradStudent` seeking
    a Ph.D. may have more degree-related criteria to satisfy in the `GradStudent::Graduate()`
    method than other specializations of `Student`. They may require credit hours
    to be verified, a passing grade point average to be verified, and verification
    that their dissertation has been accepted. In contrast, an `UnderGradStudent`
    might only have their credit hours and overall grade point average to be corroborated.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract Product class will include a static method, `MatriculateStudent()`,
    as the Factory Method to create various types of students (the Concrete Product
    types).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the abstract Product class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s first take a look at the mechanics for the implementation of our Factory
    Method, beginning by examining the definition for our abstract Product class,
    `Student`. This example can be found, as a complete program, in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we introduce our abstract `Student` class,
    which is derived from `Person` (a concrete and hence instantiable class). This
    has been accomplished with the introduction of the abstract method `virtual void
    Graduate() = 0;`. In our student matriculation example, we will be following the
    design decision that only specific types of students should be instantiated, that
    is, derived class types `GradStudent`, `UnderGradStudent`, or `NonDegreeStudent`.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding class definition, notice our Factory Method, with the prototype
    `static Student *MatriculateStudent();`. This method will use a uniform interface
    and will provide the means for the creation of various derived class types of
    `Student`. We will examine this method in detail once we have seen the class definitions
    for the derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Concrete Product classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our Concrete Product classes, starting with `GradStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `GradStudent` class definition, we add a `degree` data
    member to indicate a degree of `"PhD"`, `"MS"`, or `"MA"`, and adjust the constructors
    and destructor, as necessary. We have moved `EarnPhD()` to `GradStudent`, as this
    method is not applicable to all `Student` instances. Instead, `EarnPhD()` is applicable
    to a subset of `GradStudent` instances; we will award the title of `"Dr."` only
    to the Ph.D. candidates.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, we have overridden `IsA()` to return `"GradStudent"`. We have
    also overridden `Graduate()` to go through the graduation checklist that is applicable
    for graduate students, calling `EarnPhD()` if those checklist items have been
    met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our next Concrete Product class, `UnderGradStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Quickly taking a look at the previously defined `UnderGradStudent` class, we
    notice that it is very similar to `GradStudent`. This class even includes a `degree`
    data member. Keep in mind that not all `Student` instances will receive degrees,
    so we don’t want to generalize this attribute by defining it in `Student`. Though
    we could have introduced a shared base class of `DegreeSeekingStudent` for `UnderGradStudent`
    and `GradStudent` to collect this commonality, that fine level of granularization
    would add an additional layer almost unnecessarily. The duplication here is a
    design trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between these two sibling classes is the overridden `Graduate()`
    method. We can imagine that the checklist for an undergraduate student for graduation
    may be quite different from that of a graduate student. For this reason, we can
    reasonably differentiate the two classes. Otherwise, they are very much the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our next Concrete Product class, `NonDegreeStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Taking a comparably quick look at the aforementioned `NonDegreeStudent` class,
    we notice that this Concrete Product is similar to its sibling classes. However,
    there is no `degree` data member within this class. Also, the overridden `Graduate()`
    method has less verification to undertake than in the overridden versions of this
    method for either the `GradStudent` or `UnderGradStudent` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the Factory Method definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at our Factory Method, a static method in our Product
    (`Student`) class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned static method of `Student`, `MatriculateStudent()`, represents
    the Factory Method to create various Products (concrete `Student` instances).
    Here, based on the degree type that the `Student` seeks, one of `GradStudent`,
    `UnderGradStudent`, and `NonDegreeStudent` will be instantiated. Notice that the
    signature of `MatriculateStudent()` can handle the parameter requirements for
    any of the derived class constructors. Also notice that any of these specialized
    instance types will be returned as a base class pointer of the abstract Product
    type (`Student`).
  prefs: []
  type: TYPE_NORMAL
- en: An interesting option within the Factory Method, `MatriculateStudent()`, is
    that this method is not obligated to instantiate a new derived class instance.
    Instead, it may recycle a previous instance that may still be available. For example,
    imagine a `Student` is temporarily unregistered in the university (due to late
    payment), yet has been kept available on a list of *pending students*. The `MatriculateStudent()`
    method may instead choose to return a pointer to such an existing `Student`. *Recycling*
    is an alternative within a Factory Method!
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let’s now bring all of our various components together by taking a
    look at our `main()` function to see how our Factory Method pattern is orchestrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing our aforementioned `main()` function, we first create an array of
    pointers for potentially specialized `Student` instances in their generalized
    `Student` form. Next, we invoke the static Factory Method `Student::MatriculateStudent()`,
    within the abstract Product class, to create the appropriate Concrete Product
    (derived `Student` class type). We create one of each of the derived `Student`
    types – `GradStudent`, `UnderGradStudent`, and `NonDegreeStudent`.
  prefs: []
  type: TYPE_NORMAL
- en: We then loop through our generalized collection, calling `Graduate()` and then
    `Print()` for each instance. For students earning a Ph.D. (`GradStudent` instances),
    their title will be changed to `"Dr."` by the `GradStudent::Graduate()` method.
    Finally, we iterate through another loop to deallocate each instance’s memory.
    Thankfully, `Student` has included a virtual destructor so that the destruction
    sequence starts at the proper level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An advantage of the preceding implementation is that it is very straightforward.
    However, we can see a close coupling exists between the abstract Product, containing
    the Factory Method (which constructs the derived class types), and the derived
    Concrete Products. Yet in OOP, a base class will ideally have no knowledge of
    any descendent types.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage to this closely coupled implementation is that the abstract Product
    class must include a means for instantiation for each of its descendants in its
    static creation method, `MatriculateStudent()`. Adding new derived classes now
    affects the abstract base class definition – it needs to be recompiled. What if
    we don’t have access to the source code for this base class? Is there a way to
    decouple the dependencies that exist between the Factory Method and the Products
    that the Factory Method will create? Yes, there is an alternate implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now take a look at an alternate implementation of the Factory Method
    pattern. We will instead use an Object Factory class to encapsulate our Factory
    Method of `MatriculateStudent()`, rather than including this method in the abstract
    Product class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Object Factory class to encapsulate the Factory Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our alternative implementation of the Factory Method pattern, we will create
    our abstract Product class with a slight deviation from its previous definition.
    We will, however, create our concrete Product classes as before. These class definitions,
    collectively, will again begin the framework on which to base our pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In our revised example, we will define our Product again as the `Student` class.
    We will also again derive Concrete Product classes of `GradStudent`, `UnderGradStudent`,
    and `NonDegreeStudent`. This time, however, we will not include a Factory Method
    in our Product (`Student`) class. Instead, we will create a separate Object Factory
    class that will include the Factory Method. As before, the Factory Method will
    have a uniform interface to create any of the derived Product types. The Factory
    Method need not be static, as it was in our last implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Our Object Factory class will include `MatriculateStudent()` as the Factory
    Method to create various types of `Student` instances (the Concrete Product types).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the abstract Product class without the Factory Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the mechanics for our alternate implementation of the
    Factory Method pattern, beginning by examining the definition for our abstract
    Product class, `Student`. This example can be found, as a complete program, in
    our GitHub repository at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned class definition for `Student`, the key difference from
    our prior implementation is that this class no longer contains a static `MatriculateStudent()`
    method to serve as the Factory Method. `Student` is merely an abstract base class.
    Remember, all graduate students, undergraduate students, and non-degree students
    are all specializations of `Student`, therefore `static int numStudents` is a
    shared, collective count of all types of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Concrete Product classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With that in mind, let’s take a look at the derived (Concrete Product) classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In our previously listed class definitions, we can see that our Concrete derived
    Product classes are identical to our implementation for these classes as in our
    first example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Object Factory class with the Factory Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let us introduce an Object Factory class that includes our Factory Method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned Object Factory class definition (the `StudentFactory`
    class), we minimally include the Factory Method specification, namely, `MatriculateStudent()`.
    The method is very similar to that in our prior example. However, by capturing
    the creation of Concrete Products in an Object Factory, we have decoupled the
    relationship between the abstract Product and the Factory Method.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s compare our `main()` function to that of our original example to
    visualize how our revised components implement the Factory Method pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Considering our previously listed `main()` function, we see that we have again
    created an array of pointers to the abstract Product type (`Student`). We have
    then instantiated an Object Factory that can create various `Student` instances
    of Concrete Product types with `StudentFactory *UofD = new StudentFactory();`.
    As with the previous example, one instance of each derived type `GradStudent`,
    `UnderGradStudent`, and `NonDegreeStudent` is created by the Object Factory based
    upon the degree type sought by each student. The remainder of the code in `main()`
    is as found in our prior example.
  prefs: []
  type: TYPE_NORMAL
- en: Our output will be the same as our last example.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the Object Factory class over our prior means of implementation
    is that we have removed the dependency of object creation from our abstract Product
    class (in the Factory Method) with knowledge of what the derived class types are.
    That is, should we expand our hierarchy to include new Concrete Product types,
    we do not have to modify the abstract Product class. Of course, we will need to
    have access to modify our Object Factory class, `StudentFactory`, to augment our
    `MatriculateStudent()` Factory Method.
  prefs: []
  type: TYPE_NORMAL
- en: A pattern related to this implementation, an **Abstract Factory**, is an additional
    pattern that allows individual factories with a similar purpose to be grouped
    together. An Abstract Factory can be specified to provide a means to unify similar
    Object Factories; it is a factory that will create factories, adding yet another
    level of abstraction to our original pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen two implementations of the Factory Method pattern. We have
    folded the concepts of Product and Factory Method into the framework of classes
    we are accustomed to seeing, namely `Student`, and descendants of `Student`. Let’s
    now briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have continued our pursuit to become better C++ programmers
    by expanding our knowledge of design patterns. In particular, we have explored
    the Factory Method pattern, both conceptually and with two common implementations.
    Our first implementation included placing the Factory Method in our abstract Product
    class. Our second implementation removed the dependency between our Abstract Product
    and our Factory Method by instead adding an Object Factory class to contain our
    Factory Method. We also very briefly discussed the notion of an Abstract Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing common design patterns, such as the Factory Method pattern, will help
    you more easily solve recurring types of programming problems in a manner understood
    by other programmers. By utilizing core design patterns, you will be contributing
    to well-understood and reusable solutions with more sophisticated programming
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with our next design pattern, in [*Chapter
    18*](B19087_18.xhtml#_idTextAnchor783), *Implementing the Adapter Pattern*. Adding
    more patterns to our collection of skills makes us more versatile and valued programmers.
    Let’s continue onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the solution from a previous exercise (*Question 1*, [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*), augment your code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the Factory Method pattern to create various shapes. You will have
    already created an abstract base class of `Shape` and derived classes such as
    `Rectangle`, `Circle`, `Triangle`, and possibly `Square`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose whether to implement your Factory Method as a static method in `Shape`
    or as a method in a `ShapeFactory` class (introducing the latter class if necessary).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might easily incorporate the Factory
    Method pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
