- en: Particle Systems and Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统与动画
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Animating a surface with vertex displacement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点位移动画表面
- en: Creating a particle fountain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建粒子喷泉
- en: Creating a particle system using transform feedback
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换反馈创建粒子系统
- en: Creating a particle system using instanced meshes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实例网格创建粒子系统
- en: Simulating fire with particles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子模拟火焰
- en: Simulating smoke with particles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子模拟烟雾
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Shaders provide us with the ability to leverage the massive parallelism offered
    by modern graphics processors. Since they have the ability to transform the vertex
    positions, they can be used to implement animation directly within the shaders
    themselves. This can provide a boost in efficiency if the animation algorithm
    can be parallelized appropriately for execution within the shader.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器为我们提供了利用现代图形处理器提供的巨大并行性的能力。由于它们能够变换顶点位置，因此可以直接在着色器内部实现动画。如果动画算法可以在着色器内部适当地并行化执行，这可以提高效率。
- en: If a shader is to help with animation, it must not only compute the positions,
    but often it must write out the updated positions for use in the next frame. Shaders
    were not originally designed to write to arbitrary buffers (except, of course,
    the framebuffer). However, with recent versions, OpenGL has provided the ability
    to do so via a number of techniques including shader storage buffer objects and
    image load/store. As of OpenGL 3.0, we can also send the values of the vertex
    or geometry shader's output variables to an arbitrary buffer (or buffers). This
    feature is called **transform feedback**, and is particularly useful for particle
    systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果着色器要帮助动画，它不仅必须计算位置，而且通常还必须输出更新后的位置以供下一帧使用。着色器最初并不是设计用来写入任意缓冲区的（当然，除了帧缓冲区）。然而，随着最近版本的推出，OpenGL已经提供了一系列技术来实现这一功能，包括着色器存储缓冲区对象和图像加载/存储。截至OpenGL
    3.0，我们还可以将顶点或几何着色器输出变量的值发送到任意缓冲区（或缓冲区）。这个功能被称为**变换反馈**，对于粒子系统特别有用。
- en: In this chapter, we'll look at several examples of animation within shaders,
    focusing mostly on particle systems. The first example, animating with vertex
    displacement, demonstrates animation by transforming the vertex positions of an
    object based on a time-dependent function. In the *Creating a particle fountain*
    recipe, we will create a simple particle system under constant acceleration. In
    the *Creating a particle system using transform feedback* recipe, there is an
    example illustrating how to use OpenGL's transform feedback functionality within
    a particle system. The *Creating a particle system using instanced particles*
    recipe shows you how to animate many complex objects using instanced rendering.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个着色器内动画的示例，主要关注粒子系统。第一个示例，通过顶点位移进行动画，通过基于时间依赖函数变换对象的顶点位置来演示动画。在*创建粒子喷泉*配方中，我们将创建一个在恒定加速度下的简单粒子系统。在*使用变换反馈创建粒子系统*配方中，有一个示例说明了如何在粒子系统中使用OpenGL的变换反馈功能。*使用实例粒子创建粒子系统*配方展示了如何使用实例渲染来动画化许多复杂对象。
- en: The last two recipes demonstrate some particle systems for simulating complex,
    real phenomena such as smoke and fire.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个配方演示了一些用于模拟复杂、真实现象（如烟雾和火焰）的粒子系统。
- en: Animating a surface with vertex displacement
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点位移动画表面
- en: A straightforward way to leverage shaders for animation is to simply transform
    the vertices within the vertex shader based on some time-dependent function. The
    OpenGL application supplies static geometry, and the vertex shader modifies the
    geometry using the current time (supplied as a uniform variable). This moves the
    computation of the vertex position from the CPU to the GPU, and leverages whatever
    parallelism the graphics driver makes available.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 利用着色器进行动画的一个简单方法是在顶点着色器内部根据某个时间依赖函数变换顶点。OpenGL应用程序提供静态几何体，顶点着色器使用当前时间（作为统一变量提供）修改几何体。这将从CPU将顶点位置的计算移动到GPU，并利用图形驱动程序提供的任何并行性。
- en: 'In this example, we''ll create a waving surface by transforming the vertices
    of a tessellated quad based on a sine wave. We''ll send down the pipeline a set
    of triangles that make up a flat surface in the *x*-*z* plane. In the vertex shader,
    we''ll transform the *y* coordinate of each vertex based on a time-dependent sine
    function, and compute the normal vector of the transformed vertex. The following
    image shows the desired result (you''ll have to imagine that the waves are travelling
    across the surface from left to right):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将通过根据正弦波转换划分四边形的顶点来创建一个波动的表面。我们将通过管道发送一组三角形，这些三角形构成了*x*-*z*平面上的一个平坦表面。在顶点着色器中，我们将根据时间依赖的正弦函数转换每个顶点的*y*坐标，并计算变换顶点的法向量。以下图像显示了期望的结果（你必须想象波浪是从左到右穿过表面的）：
- en: '![](img/6fdf555b-2946-408d-b99d-b454326e94b2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fdf555b-2946-408d-b99d-b454326e94b2.png)'
- en: Alternatively, we could use a noise texture to animate the vertices (that make
    up the surface) based on a random function. (See [Chapter 9](5e6b75a0-9f0c-4798-bc37-b5d34b53ef4a.xhtml),
    *Using Noise in Shaders*, for details on noise textures.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用噪声纹理根据随机函数动画顶点（构成表面的顶点）。（有关噪声纹理的详细信息，请参阅第9章[5e6b75a0-9f0c-4798-bc37-b5d34b53ef4a.xhtml]，*在着色器中使用噪声*。）
- en: Before we jump into the code, let's take a look at the mathematics that we'll
    need.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我们看看我们将需要的数学知识。
- en: 'We''ll transform the *y *coordinate of the surface as a function of the current
    time and the modeling *x *coordinate. To do so, we''ll use the basic plane wave
    equation, as shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据当前时间和建模的*x*坐标将表面的*y*坐标作为函数进行转换。为此，我们将使用基本的平面波动方程，如下面的图示所示：
- en: '![](img/a3f07ddf-11f9-4abe-b84e-10bde8473cdb.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f07ddf-11f9-4abe-b84e-10bde8473cdb.png)'
- en: '**A** is the wave''s amplitude (the height of the peaks), the lambda (**λ**)
    is the wavelength (the distance between successive peaks), and **v** is the wave''s
    velocity. The previous diagram shows an example of the wave when *t = 0* and the
    wavelength is equal to one. We''ll configure these coefficients through uniform
    variables.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**A**是波的振幅（波峰的高度），lambda（**λ**）是波长（相邻波峰之间的距离），**v**是波的速度。前面的图示展示了当*t = 0*且波长等于一时波的例子。我们将通过uniform变量配置这些系数。'
- en: 'In order to render the surface with proper shading, we also need the normal
    vector at the transformed location. We can compute the normal vector using the
    (partial) derivative of the previous function. The result is the following equation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以适当的着色渲染表面，我们还需要变换位置的法向量。我们可以通过前一个函数的（偏）导数来计算法向量。结果是以下方程：
- en: '![](img/77694054-ee14-4dac-bae7-ba391d3a6b6f.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77694054-ee14-4dac-bae7-ba391d3a6b6f.png)'
- en: Of course, this vector should be normalized before we use it in our shading
    model.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们在着色模型中使用它之前，这个向量应该是归一化的。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL application to render a flat, tessellated surface in the
    *x*-*z* plane. The results will look better if you use a large number of triangles.
    Also, keep track of the animation time using whatever method you prefer. Provide
    the current time to the vertex shader via the uniform `Time` variable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的OpenGL应用程序设置成在*x*-*z*平面上渲染一个平坦的、划分成多边形的表面。如果你使用大量的三角形，结果会看起来更好。同时，使用你喜欢的任何方法跟踪动画时间。通过uniform变量`Time`将当前时间传递给顶点着色器。
- en: 'The other important uniform variables are the coefficients of the previous
    wave equation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一些重要的uniform变量是先前波动方程的系数：
- en: '`K`: It is the wavenumber (*2π/λ*)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`K`：它是波数（*2π/λ*）'
- en: '`Velocity`: It is the wave''s velocity'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Velocity`：它是波的速度'
- en: '`Amp`: It is the wave''s amplitude'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Amp`：它是波的振幅'
- en: Set up your program to provide appropriate uniform variables for your chosen
    shading model.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的程序以提供适当的uniform变量以供你选择的着色模型使用。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the vertex shader, we translate the *y* coordinate of the vertex:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们转换顶点的*y*坐标：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a fragment shader that computes the fragment color based on the `Position`
    and `Normal` variables using whatever shading model you choose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个片段着色器，它根据`Position`和`Normal`变量以及你选择的任何着色模型计算片段颜色。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader takes the position of the vertex and updates the *y* coordinate
    using the wave equation discussed previously. After the first three statements,
    the variable `pos` is just a copy of the `VertexPosition` input variable with
    the modified *y* coordinate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器获取顶点的位置并使用之前讨论的波动方程更新*y*坐标。在第一个三个语句之后，变量`pos`只是`VertexPosition`输入变量的一个副本，带有修改后的*y*坐标。
- en: We then compute the normal vector using the previous equation, normalize the
    result, and store it in the `n` variable. Since the wave is really just a two-dimensional
    wave (it doesn't depend on *z*), the *z* component of the normal vector will be
    zero.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用前一个方程计算法线向量，将结果归一化，并将其存储在`n`变量中。由于波实际上是二维波（它不依赖于*z*），法线向量的*z*分量将为零。
- en: Finally, we pass along the new position and normal to the fragment shader after
    converting to camera coordinates. As usual, we also pass the position in clip
    coordinates to the built-in `gl_Position` variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在将位置转换为相机坐标后，将新的位置和法线传递给片段着色器。像往常一样，我们也将位置传递到内置的`gl_Position`变量中，以裁剪坐标形式。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Modifying the vertex position within the vertex shader is a straightforward
    way to offload some computation from the CPU to the GPU. It also eliminates the
    possible need to transfer vertex buffers between the GPU memory and main memory
    in order to modify the positions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中修改顶点位置是一种简单的方法，可以将一些计算从CPU卸载到GPU上。这还消除了在修改位置时需要在GPU内存和主内存之间传输顶点缓冲区的可能需求。
- en: The main disadvantage is that the updated positions are not available on the
    CPU side. For example, they might be needed for additional processing (such as
    collision detection). However, there are a number of ways to provide this data
    back to the CPU. One technique might be the clever use of FBOs to receive the
    updated positions from the fragment shader. In a later recipe, we'll look at another
    technique that makes use of a newer OpenGL feature called **transform feedback**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 主要缺点是更新的位置在CPU端不可用。例如，它们可能需要用于额外的处理（如碰撞检测）。然而，有几种方法可以将这些数据返回到CPU。一种技术可能是巧妙地使用FBO来从片段着色器接收更新的位置。在后面的菜谱中，我们将探讨另一种利用较新的OpenGL功能**变换反馈**的技术。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`chapter10/scenewave.cpp` in the example code'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter10/scenewave.cpp`
- en: Creating a particle fountain
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建粒子喷泉
- en: 'In computer graphics, a particle system is a group of objects that are used
    to simulate a variety of **fuzzy** systems such as smoke, liquid spray, fire,
    explosions, or other similar phenomena. Each particle is considered to be a point
    object with a position, but no size. They could be rendered as point sprites (using
    the `GL_POINTS` primitive mode), or as camera aligned quads or triangles. Each
    particle has a lifetime: it is born, animates according to a set of rules, and
    then dies. The particle can then be resurrected and go through the entire process
    again. In this example, particles do not interact with other particles, but some
    systems, such as fluid simulations, would require a particle to interact. A common
    technique is to render the particle as a single, textured, camera-facing quad
    with transparency.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，粒子系统是一组用于模拟各种**模糊**系统（如烟雾、液体喷雾、火焰、爆炸或其他类似现象）的对象。每个粒子被认为是一个具有位置但没有大小的点对象。它们可以渲染为点精灵（使用`GL_POINTS`原语模式），或者作为对齐的相机四边形或三角形。每个粒子都有一个生命周期：它诞生，根据一组规则进行动画处理，然后死亡。粒子随后可以被复活并再次经历整个过程。在这个例子中，粒子不会与其他粒子交互，但某些系统，如流体模拟，需要粒子进行交互。一种常见的技术是将粒子渲染为一个单独的、纹理化的、面向相机的四边形，具有透明度。
- en: During the lifetime of a particle, it is animated according to a set of rules.
    These rules include the basic kinematic equations that define the movement of
    a particle that is subjected to constant acceleration (such as a gravitational
    field). In addition, we might take into account things such as wind, friction,
    or other factors. The particle may also change shape or transparency during its
    lifetime. Once the particle has reached a certain age (or position), it is considered
    to be *dead* and can be *recycled* and used again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在粒子的生命周期内，它会根据一组规则进行动画处理。这些规则包括定义受恒定加速度（如重力场）影响的粒子运动的基运动方程。此外，我们可能还会考虑风、摩擦或其他因素。粒子在其生命周期内也可能改变形状或透明度。一旦粒子达到一定年龄（或位置），它就被认为是*死亡*的，可以被*回收*并再次使用。
- en: In this example, we'll implement a relatively simple particle system that has
    the look of a fountain of water. For simplicity, the particles in this example
    will not be *recycled*. Once they have reached the end of their lifetime, we'll
    draw them as fully transparent so that they are effectively invisible. This gives
    the fountain a finite lifetime, as if it only has a limited supply of material.
    In later recipes, we'll see some ways to improve this system by recycling particles.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实现一个相对简单的粒子系统，其外观类似于喷泉。为了简单起见，这个例子中的粒子将不会**回收**。一旦它们达到生命周期的终点，我们将以完全透明的方式绘制它们，使它们实际上不可见。这给了喷泉一个有限的生命周期，就像它只有有限的材料供应一样。在后面的菜谱中，我们将看到一些回收粒子的方法来改进这个系统。
- en: 'The following image shows a sequence of images—several successive frames from
    the output of this simple particle system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像显示了一系列图像——来自这个简单粒子系统输出的几个连续帧：
- en: '![](img/086c3aa6-b2f0-4185-810c-66a6abf2160f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/086c3aa6-b2f0-4185-810c-66a6abf2160f.png)'
- en: 'To animate the particles, we''ll use the standard kinematics equation for objects
    under constant acceleration:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画粒子，我们将使用恒定加速度下物体的标准运动学方程：
- en: '![](img/94fac40d-2580-4ef9-8d08-7725264501ce.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94fac40d-2580-4ef9-8d08-7725264501ce.png)'
- en: The previous equation describes the position of a particle at time *t*. *P[0]*
    is the initial position, *v[0]* is the initial velocity, and *a* is the acceleration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方程式描述了时间*t*时粒子的位置。*P[0]*是初始位置，*v[0]*是初始速度，*a*是加速度。
- en: We'll define the initial position of all particles to be the origin (0,0,0).
    The initial velocity will be determined randomly within a range of values. Each
    particle will be created at a slightly different time, so the time that we use
    in the previous equation will be relative to the start time for the particle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义所有粒子的初始位置为原点（0,0,0）。初始速度将在一个值范围内随机确定。每个粒子将在一个略微不同的时间被创建，因此我们之前方程式中使用的时间将相对于粒子的起始时间。
- en: 'Since the initial position is the same for all particles, we won''t need to
    provide it as an input attribute to the shader. Instead, we''ll just provide two
    other vertex attributes: the initial velocity and the start time (the particle''s
    time of *birth*)*.* Prior to the particle''s birth time, we''ll render it completely
    transparent. During its lifetime, the particle''s position will be determined
    using the previous equation with a value for *t* that is relative to the particle''s
    start time (`Time - StartTime`).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有粒子的初始位置相同，我们不需要将其作为输入属性提供给着色器。相反，我们只需提供另外两个顶点属性：初始速度和起始时间（粒子的**出生时间**）。在粒子出生时间之前，我们将将其完全透明地渲染。在其生命周期内，粒子的位置将使用之前的方程式，其中*t*的值相对于粒子的起始时间（`Time
    - StartTime`）。
- en: To render our particles, we'll use a technique called **instancing**, along
    with a simple trick to generate screen-aligned quads. With this technique, we
    don't actually need any vertex buffers for the quad itself! Instead, we'll just
    invoke the vertex shader six times for each particle in order to generate two
    triangles (a quad). In the vertex shader, we'll compute the positions of the vertices
    as offsets from the particle's position. If we do so in screen space, we can easily
    create a screen-aligned quad. We'll need to provide input attributes that include
    the particle's initial velocity and **birth time**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染我们的粒子，我们将使用一种称为**实例化**的技术，并结合一个简单的技巧来生成屏幕对齐的四边形。使用这种技术，我们实际上不需要为四边形本身提供任何顶点缓冲区！相反，我们将只为每个粒子调用六次顶点着色器来生成两个三角形（一个四边形）。在顶点着色器中，我们将计算顶点的位置，作为粒子位置的偏移量。如果我们这样做在屏幕空间中，我们可以轻松地创建一个屏幕对齐的四边形。我们需要提供包含粒子初始速度和**出生时间**的输入属性。
- en: This technique makes use of the vertex shader to do all the work of animating
    the particles. We gain a great deal of efficiency over computing the positions
    on the CPU. The GPU can execute the vertex shader in parallel, and process several
    particles at once.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术利用顶点着色器来完成所有粒子的动画工作。与在CPU上计算位置相比，我们获得了巨大的效率提升。GPU可以并行执行顶点着色器，并一次性处理多个粒子。
- en: The core of this technique involves the use of the `glDrawArraysInstanced` function.
    This function is similar to the familiar `glDrawArrays`, but instead of just drawing
    once, it does so repeatedly. Where `glDrawArrays` would just *walk* through the
    vertex buffers once, `glDrawArraysInstanced` will do so a specified number of
    times. In addition, while *walking* through the buffers, we can also configure
    when to move to the next element in the buffer (how quickly to walk). Normally,
    we move to the next element with each invocation of the vertex shader (essentially
    once per vertex). However, with instanced drawing, we don't always want that.
    We might want several (sometimes hundreds) of invocations to get the same input
    value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的核心涉及使用`glDrawArraysInstanced`函数。这个函数与熟悉的`glDrawArrays`类似，但它不是只绘制一次，而是重复绘制。`glDrawArrays`会一次遍历顶点缓冲区，而`glDrawArraysInstanced`会根据指定的次数进行遍历。此外，在遍历缓冲区的同时，我们还可以配置何时移动到缓冲区的下一个元素（如何快速遍历）。通常，我们会在每次调用顶点着色器时移动到下一个元素（本质上每个顶点一次）。然而，在实例绘制中，我们并不总是希望这样。我们可能希望有多个（有时是数百个）调用以获得相同的输入值。
- en: For example, each particle in our particle system has six vertices (two triangles).
    For each of these six vertices, we want the same velocity, (particle) position,
    and other per-particle parameters. The key to this is the `glVertexAttribDivisor` function,
    which makes it possible to specify how often the index is advanced for a given
    attribute. A divisor value of `0` indicates that the index is advanced once per
    vertex. A value that is greater than zero (*n > 0*) indicates that the index advances
    once after n instances of the shape are drawn.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们粒子系统中的每个粒子都有六个顶点（两个三角形）。对于这六个顶点中的每一个，我们希望它们具有相同的速度、（粒子）位置和其他每个粒子的参数。实现这一点的关键是`glVertexAttribDivisor`函数，它使得指定给定属性索引提升频率成为可能。`0`的除数值表示索引在每个顶点处提升一次。大于零的值（*n
    > 0*）表示在绘制形状的n个实例之后索引提升一次。
- en: 'For example, suppose we have two attributes (A and B) and we set the divisor
    to zero for attribute A and one for attribute B. Then, we execute the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个属性（A和B），我们将属性A的除数设置为零，将属性B的除数设置为1。然后，我们执行以下操作：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first three arguments are the same as `glDrawArrays`. The fourth argument
    is the number of instances. So, this call would draw three instances of a triangle
    primitive (for a total of nine vertices), and the values of attributes A and B
    would be taken from the corresponding buffers at the indices shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数与`glDrawArrays`相同。第四个参数是实例数。因此，这个调用将绘制三个三角形原型的实例（总共九个顶点），属性A和B的值将来自此处显示的相应缓冲区中的索引：
- en: '| **Attribute** | **Vertex indices** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **顶点索引** |'
- en: '| A | 0,1,2,0,1,2,0,1,2 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| A | 0,1,2,0,1,2,0,1,2 |'
- en: '| B | 0,0,0,1,1,1,2,2,2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| B | 0,0,0,1,1,1,2,2,2 |'
- en: Note how setting the vertex attribute divisor for B to one causes the index
    to advance once per instance, rather than once per vertex. In fact, in this recipe,
    we'll set the divisor for all of our attributes to one! We'll compute the positions
    of each vertex of a particle as offsets from the particle's position.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将属性B的顶点属性除数设置为1会导致索引在每个实例处提升一次，而不是在每个顶点处提升一次。实际上，在这个配方中，我们将所有属性的除数都设置为1！我们将计算每个粒子的顶点位置，作为粒子位置的偏移量。
- en: You might be wondering how it will be possible to distinguish one vertex from
    another in the vertex shader in order to determine the needed offsets if the attribute
    values are the same for all vertices of the particle. The solution comes via the
    built-in variable `gl_VertexID`. More on this follows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果所有粒子的顶点属性值都相同，如何在顶点着色器中区分一个顶点与另一个顶点，以确定所需的偏移量。解决方案是通过内置变量`gl_VertexID`。更多内容将在后面介绍。
- en: We'll render each particle as a textured-point quad of two triangles. We'll
    increase the transparency of the particle linearly with the age of the particle,
    to make the particle appear to fade out as it animates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染每个粒子为一个纹理点四边形，由两个三角形组成。我们将随着粒子的年龄线性增加粒子的透明度，使粒子在动画过程中看起来逐渐消失。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll create two buffers (or a single interleaved buffer) to store our input
    attributes. The first buffer will store the initial velocity for each particle.
    We''ll choose the values randomly from a limited range of possible vectors. To
    create the *cone* of particles in the previous image, we''ll choose randomly from
    a set of vectors within the cone. We will *tilt* the cone toward some direction
    by applying a rotation matrix (`emitterBasis`). The following code is one way
    to do this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个缓冲区（或一个单一的交错缓冲区）来存储我们的输入属性。第一个缓冲区将存储每个粒子的初始速度。我们将从可能的向量范围内随机选择值。为了创建前一个图像中的粒子锥体，我们将从锥体内的向量集中随机选择。我们将通过应用旋转矩阵（`emitterBasis`）将锥体向某个方向倾斜。以下代码是这样做的一种方法：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, the `randFloat` function returns a random value between
    zero and one. We pick random numbers within a range of possible values by using
    the GLM `mix` function (the GLM `mix` function works the same as the corresponding
    GLSL function—it performs a linear interpolation between the values of the first
    two arguments). Here, we choose a random `float` between zero and one and use
    that value to interpolate between the endpoints of our range.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`randFloat`函数返回一个介于零和一之间的随机值。我们通过使用GLM的`mix`函数（GLM的`mix`函数与相应的GLSL函数作用相同——它在第一个两个参数的值之间执行线性插值）在可能值的范围内选择随机数。在这里，我们选择一个介于零和一之间的随机`float`值，并使用该值在范围的端点之间进行插值。
- en: To pick vectors from within our cone, we utilize spherical coordinates. The
    value of `theta` determines the angle between the center of the cone and the vector.
    The value of `phi` defines the possible directions around the *y *axis for a given
    value of `theta`. For more on spherical coordinates, grab your favorite math book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的锥体中选择向量，我们使用球坐标。`theta`的值决定了锥体中心和向量之间的角度。`phi`的值定义了给定`theta`值时围绕`y`轴的可能方向。关于球坐标的更多信息，请拿起你最喜欢的数学书。
- en: Once a direction is chosen, the vector is scaled to have a magnitude between
    1.25 and 1.5\. This is a range that seems to work well for the desired effect.
    The magnitude of the velocity vector is the overall speed of the particle, and
    we can tweak this range to get a wider variety of speeds or faster/slower particles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个方向后，向量会被缩放到1.25和1.5之间的幅度。这似乎是达到预期效果的良好范围。速度向量的幅度是粒子的整体速度，我们可以调整这个范围以获得更广泛的速度或更快/更慢的粒子。
- en: The last three lines in the loop assign the vector to the appropriate location
    in the vector `data`. After the loop, we copy the data into the buffer referred
    to by `initVel`. Set up this buffer to provide data for vertex attribute zero.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的最后三行将向量分配到向量`data`的适当位置。循环之后，我们将数据复制到由`initVel`引用的缓冲区中。设置此缓冲区以提供顶点属性零的数据。
- en: 'In the second buffer, we''ll store the start time for each particle. This will
    provide only a single float per vertex (particle). For this example, we''ll just
    create each particle in succession at a fixed rate. The following code will set
    up a buffer with each particle created a fixed number of seconds after the previous
    one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个缓冲区中，我们将存储每个粒子的起始时间。这将为每个顶点（粒子）提供仅一个浮点数。在这个例子中，我们将以固定的速率连续创建每个粒子。以下代码将设置一个缓冲区，其中每个粒子在之前的粒子之后固定秒数被创建：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code simply creates an array of floats that starts at zero and gets incremented
    by `rate`. The array is then copied into the buffer referred to by `startTime`.
    Set this buffer to be the input for vertex attribute one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码简单地创建了一个以零开始并按`rate`递增的浮点数数组。然后，该数组被复制到由`startTime`引用的缓冲区中。设置此缓冲区作为顶点属性一的输入。
- en: 'Before continuing, we set the divisor for both attributes to one. This ensures
    that all vertices of a particle will receive the same value for the attributes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将两个属性的分母都设置为1。这确保了粒子的所有顶点都将获得相同的属性值：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding commands should be executed while the **vertex array object**
    (**VAO**) is bound. The divisor information is stored within the VAO. See the
    example code for details.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定**顶点数组对象**（**VAO**）时执行前面的命令。分母信息存储在VAO中。请参阅示例代码以获取详细信息。
- en: 'The vertex shader has a number of uniform variables that control the simulation.
    Set the following uniform variables from within the OpenGL program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器有几个统一变量，用于控制模拟。在OpenGL程序中设置以下统一变量：
- en: '`ParticleTex`: The particle''s texture'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleTex`：粒子的纹理'
- en: '`Time`: The amount of time that has elapsed since the animation began'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time`：动画开始以来经过的时间量'
- en: '`Gravity`: The vector representing one half of the acceleration in the previous
    equation'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重力`：代表前一个方程中加速度一半的矢量'
- en: '`ParticleLifetime`: Defines how long a particle survives after it is created'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleLifetime`：定义粒子在被创建后存活的时间'
- en: '`ParticleSize`:  Size of the particle'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSize`：粒子的尺寸'
- en: '`EmitterPos`:  The position of the particle emitter'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmitterPos`：粒子发射器的位置'
- en: 'Since we want our particles to be partially transparent, we enable alpha blending
    using the following statements:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望粒子部分透明，我们使用以下语句启用alpha混合：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the vertex shader code, we *create* the particle by offsetting the particle
    position in camera coordinates. Note the use of `gl_VertexID` to identify the
    quad''s vertex:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器代码中，我们通过在相机坐标中偏移粒子位置来*创建*粒子。注意使用`gl_VertexID`来识别四边形的顶点：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the fragment shader, we just apply the texture and scale the alpha for the
    particle:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们只是应用纹理并缩放粒子的alpha值：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To render our particles, we make the depth buffer read-only using `glDepthMask`,
    and issue a `glDrawArraysInstanced` call with six vertices per particle:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染我们的粒子，我们使用`glDepthMask`使深度缓冲区只读，并对每个粒子使用六个顶点发出`glDrawArraysInstanced`调用：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader receives the particle's initial velocity (`VertexInitVel`)
    and start time (`VertexBirthTime`) in its two input attributes. The `Time` variable
    stores the amount of time that has elapsed since the beginning of the animation.
    The `Transp` output variable is the overall transparency of the particle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器接收粒子的初始速度（`VertexInitVel`）和起始时间（`VertexBirthTime`）作为其两个输入属性。`Time`变量存储自动画开始以来经过的时间量。`Transp`输出变量是粒子的整体透明度。
- en: In the main function of the vertex shader, we start by determining the particle's
    age (`t`) as the current simulation time minus the particle's birth time. The
    following `if` statement determines whether the particle is alive yet. If the
    particle's age is greater than zero, the particle is alive, otherwise, the particle
    has yet to be *born*. In the latter case, the position is set to the camera's
    origin and the particle is rendered fully transparent. We do the same thing if
    the particle's age is greater than its lifetime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器的主函数中，我们首先确定粒子的年龄（`t`），即当前模拟时间减去粒子的出生时间。下面的`if`语句确定粒子是否已经存活。如果粒子的年龄大于零，则粒子是存活的，否则，粒子尚未*出生*。在后一种情况下，位置被设置为相机的原点，粒子被完全透明地渲染。如果粒子的年龄大于其寿命，我们也会做同样的事情。
- en: If the particle is alive, the particle's position (`pos`) is determined using
    the kinematic equation described previously. The `cameraPos` vertex position is
    determined by offsetting the particle's position using the `offsets` array. We
    transform the position into camera coordinates (using `MV`), and add the offset
    for the current vertex using `gl_VertexID` as the index.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子是存活的，则使用之前描述的动力学方程来确定粒子的位置（`pos`）。`cameraPos`顶点位置是通过使用`offsets`数组偏移粒子的位置来确定的。我们将位置转换到相机坐标（使用`MV`），并使用`gl_VertexID`作为索引添加当前顶点的偏移。
- en: '`gl_VertexID` is a built-in variable in GLSL that takes on the index of the
    vertex of the current instance.  In this case, since we are using six vertices
    per particle, `gl_VertexID` will be between 0 and 5.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_VertexID`是GLSL中的一个内置变量，它承担当前实例顶点的索引。在这种情况下，由于我们每个粒子使用六个顶点，`gl_VertexID`将在0到5之间。'
- en: By applying the offsets in camera coordinates, we gain a quality that is often
    desired in particle systems. The particle's quad will always face the camera.
    This effect, called **billboarding**, gives the particles the illusion that they
    are solid shapes rather than just flat quads.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在相机坐标中应用偏移，我们获得了粒子系统中通常期望的质量。粒子的四边形将始终面向相机。这种称为**板面渲染**的效果，使粒子看起来是实心形状而不是仅仅的平面四边形。
- en: 'We scale the offset value by `ParticleSize` to set the size of the particle.
    The transparency is determined by linearly interpolating based on the particle''s
    age:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`ParticleSize`缩放偏移值来设置粒子的大小。透明度是通过根据粒子的年龄进行线性插值来确定的：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the particle is born it is fully opaque, and linearly becomes transparent
    as it ages. The value of `Transp` is `1.0` at birth and `0.0` at the end of the
    particle's lifetime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当粒子出生时它是完全不透明的，并且随着它的老化线性地变得透明。`Transp`的值在出生时为`1.0`，在粒子寿命结束时为`0.0`。
- en: In the fragment shader, we color the fragment with the result of value of a
    texture lookup. Before finishing, we multiply the alpha value of the final color
    by the variable `Transp`, in order to scale the overall transparency of the particle
    based on the particle's age (as determined in the vertex shader).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们使用纹理查找的结果来给片段上色。在完成之前，我们将最终颜色的alpha值乘以变量`Transp`，以便根据粒子的年龄（在顶点着色器中确定）来调整粒子的整体透明度。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: This example is meant to be a fairly gentle introduction to GPU-based particle
    systems. There are many things that could be done to improve the power and flexibility
    of this system. For example, we could vary the rotation of the particles as they
    progress through their lifetime to produce different effects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子旨在为基于GPU的粒子系统提供一个相当温和的介绍。有许多事情可以做以增强该系统的功能和灵活性。例如，我们可以改变粒子在其生命周期中的旋转，以产生不同的效果。
- en: One of the most significant drawbacks of the technique in this recipe is that
    the particles can't be recycled easily. When a particle dies, it is simply rendered
    as transparent. It would be nice to be able to reuse each dead particle to create
    an apparently continuous stream of particles. Additionally, it would be useful
    to be able to have the particles respond appropriately to changing accelerations
    or modifications of the system (for example, wind or movement of the source).
    With the system described here, we couldn't do so because we are working with
    a single equation that defines the movement of the particle for all time. What
    would be needed is to incrementally update the positions based on the current
    forces involved (a simulation).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方中技术的最大缺点之一是粒子无法轻易回收。当一个粒子死亡时，它只是简单地以透明的方式渲染。如果能重用每个死亡的粒子来创建一个看似连续的粒子流那就太好了。此外，如果粒子能够适当地响应变化的加速度或系统的修改（例如，风或源头的移动）将非常有用。然而，由于我们正在着色器中执行模拟，因此我们受到写入内存方式的限制，所以我们无法做到这一点。我们需要根据当前涉及的力逐步更新位置（即模拟）。
- en: In order to accomplish the previous objective, we need some way to feed the
    output of the vertex shader (the particle's updated positions) back into the input
    of the vertex shader during the next frame. This would of course be simple if
    we weren't doing the simulation within the shader because we could simply update
    the positions of the primitives directly before rendering. However, since we are
    doing the work within the vertex shader, we are limited in the ways that we can
    write to memory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的目标，我们需要一种方法将顶点着色器的输出（粒子的更新位置）反馈到下一帧顶点着色器的输入中。当然，如果我们不在着色器内进行模拟，这将很简单，因为我们可以在渲染之前直接更新原型的位置。然而，由于我们在顶点着色器内执行工作，我们在写入内存的方式上受到限制。
- en: In the following recipe, we'll see an example of how to use an OpenGL feature
    called **transform feedback** to accomplish exactly what was just described. We
    can designate certain output variables to be sent to buffers that can be read
    as input in subsequent rendering passes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的配方中，我们将看到一个如何使用OpenGL中称为**变换反馈**的功能来实现上述功能的例子。我们可以指定某些输出变量被发送到缓冲区，这些缓冲区可以在后续的渲染过程中作为输入读取。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter10/scene_particles.cpp` file in the example code
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter10/scene_particles.cpp`文件
- en: The *Animating a surface with vertex displacement* recipe
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点位移动画表面*的配方'
- en: The *Creating a particle system using transform feedback* recipe
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用变换反馈创建粒子系统*的配方'
- en: Creating a particle system using transform feedback
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变换反馈创建粒子系统
- en: Transform feedback provides a way to capture the output of the vertex (or geometry)
    shader to a buffer for use in subsequent passes. Originally introduced into OpenGL
    with version 3.0, this feature is particularly well-suited for particle systems,
    because among other things, it enables us to do discrete simulations. We can update
    a particle's position within the vertex shader and render that updated position
    in a subsequent pass (or the same pass). Then the updated positions can be used
    in the same way as input to the next frame of animation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 变换反馈提供了一种将顶点（或几何）着色器的输出捕获到缓冲区的方法，以便在后续的传递中使用。最初在OpenGL 3.0版本中引入，这个特性特别适合粒子系统，因为除此之外，它还使我们能够进行离散模拟。我们可以在顶点着色器内更新粒子的位置，并在后续的传递（或相同的传递）中渲染该更新位置。然后，更新的位置可以像输入一样用于下一帧动画。
- en: In this example, we'll implement the same particle system from the previous
    recipe (*Creating a particle fountain*), this time making use of transform feedback.
    Instead of using an equation that describes the particle's motion for all time,
    we'll update the particle positions incrementally, solving the equations of motion
    based on the forces involved at the time each frame is rendered.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实现与上一个配方（*创建粒子喷泉*）相同的粒子系统，这次我们将使用变换反馈。我们不会使用描述粒子在整个时间内的运动的方程，而是将逐步更新粒子位置，根据渲染每个帧时涉及的力来求解运动方程。
- en: 'A common technique is to make use of the Euler method, which approximates the
    position and velocity at time `t` based on the position, velocity, and acceleration
    at an earlier time:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的技术是使用欧拉法，该方法基于较早时间点的位置、速度和加速度来近似时间`t`的位置和速度：
- en: '![](img/6a827dcc-e6c1-4c2e-90c2-33194a93e417.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a827dcc-e6c1-4c2e-90c2-33194a93e417.png)'
- en: In the previous equation, the subscripts represent the time step (or animation
    frame), *P* is the particle position, and *v* is the particle velocity. The equations
    describe the position and velocity at frame *n + 1* as a function of the position
    and velocity during the previous frame (*n*). The variable *h* represents the
    time step size, or the amount of time that has elapsed between frames. The term
    *a[n]* represents the instantaneous acceleration. For our simulation, this will
    be a constant value, but in general it might be a value that changes depending
    on the environment (wind, collisions, inter-particle interactions, and so on).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个方程中，下标代表时间步长（或动画帧），*P*表示粒子位置，*v*表示粒子速度。这些方程将帧*n + 1*的位置和速度描述为前一个帧（*n*）中位置和速度的函数。变量*h*代表时间步长大小，即帧之间经过的时间量。项*a[n]*代表瞬时加速度。对于我们的模拟，这将是一个常数，但在一般情况下，它可能是一个取决于环境（风、碰撞、粒子间相互作用等）的值。
- en: The Euler method is actually numerically integrating the Newtonian equation
    of motion. It is one of the simplest techniques for doing so. However, it is a
    first-order technique, which means that it can introduce a significant amount
    of error. More accurate techniques include **Verlet integration** and **Runge-Kutta
    integration**. Since our particle simulation is designed to look good and physical
    accuracy is not of high importance, the Euler method should suffice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉法实际上是数值积分牛顿运动方程。这是实现这一目标的最简单技术之一。然而，它是一种一阶技术，这意味着它可能会引入相当大的误差。更精确的技术包括**Verlet积分**和**Runge-Kutta积分**。由于我们的粒子模拟旨在看起来很好，且物理精度不是特别重要，因此欧拉法应该足够了。
- en: 'To make our simulation work, we''ll use a technique sometimes called **buffer
    ping-ponging**. We maintain two sets of vertex buffers and swap their uses each
    frame. For example, we use buffer **A** to provide the positions and velocities
    as input to the vertex shader. The vertex shader updates the positions and velocities
    using the Euler method and sends the results to buffer **B** using transform feedback.
    Then, in a second pass, we render the particles using buffer **B**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的模拟工作，我们将使用一种有时被称为**缓冲区乒乓**的技术。我们维护两组顶点缓冲区，并在每一帧交换它们的使用。例如，我们使用缓冲区**A**提供位置和速度作为顶点着色器的输入。顶点着色器使用欧拉法更新位置和速度，并通过变换反馈将结果发送到缓冲区**B**。然后，在第二次遍历中，我们使用缓冲区**B**渲染粒子：
- en: '![](img/772c7ecf-5b73-4dac-8082-33f25d96fc8b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/772c7ecf-5b73-4dac-8082-33f25d96fc8b.png)'
- en: In the next frame of animation, we repeat the same process, swapping the two
    buffers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个动画帧中，我们重复相同的过程，交换两个缓冲区。
- en: In general, transform feedback allows us to define a set of shader output variables
    that are to be written to a designated buffer (or set of buffers). There are several
    steps involved that will be demonstrated, but the basic idea is as follows. Just
    before the shader program is linked, we define the relationship between buffers
    and shader output variables using the `glTransformFeedbackVaryings` function.
    During rendering, we initiate a transform feedback pass. We bind the appropriate
    buffers to the transform feedback binding points. (If desired, we can disable
    rasterization so that the particles are not rendered.) We enable transform feedback
    using the `glBeginTransformFeedback` function and then draw the point primitives.
    The output from the vertex shader will be stored in the appropriate buffers. Then
    we disable transform feedback by calling `glEndTransformFeedback`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，变换反馈允许我们定义一组要写入指定缓冲区（或缓冲区集）的着色器输出变量。涉及几个步骤，但基本思路如下。在着色器程序链接之前，我们使用 `glTransformFeedbackVaryings`
    函数定义缓冲区与着色器输出变量之间的关系。在渲染过程中，我们启动一个变换反馈过程。我们将适当的缓冲区绑定到变换反馈绑定点。（如果需要，我们可以禁用光栅化，这样就不会渲染粒子。）我们使用
    `glBeginTransformFeedback` 函数启用变换反馈，然后绘制点原语。顶点着色器的输出将存储在适当的缓冲区中。然后我们通过调用 `glEndTransformFeedback`
    禁用变换反馈。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create and allocate three pairs of buffers. The first pair will be for the particle
    positions, the second for the particle velocities, and the third for the *age* of
    each particle. For clarity, we'll refer to the first buffer in each pair as the
    A buffer, and the second as the B buffer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并分配三对缓冲区。第一对用于粒子位置，第二对用于粒子速度，第三对用于每个粒子的 *年龄*。为了清晰起见，我们将每对中的第一个缓冲区称为 A 缓冲区，第二个称为
    B 缓冲区。
- en: Create two vertex arrays. The first vertex array should link the A position
    buffer with the first vertex attribute (attribute index 0), the A velocity buffer
    with vertex attribute one, and the A age buffer with vertex attribute two.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个顶点数组。第一个顶点数组应将 A 位置缓冲区与第一个顶点属性（属性索引 0）链接，A 速度缓冲区与顶点属性一链接，以及 A 年龄缓冲区与顶点属性二链接。
- en: The second vertex array should be set up in the same way using the B buffers.  The
    handles to the two vertex arrays will be accessed via the `GLuint` array named
    `particleArray`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个顶点数组应使用 B 缓冲区以相同的方式设置。两个顶点数组的句柄将通过名为 `particleArray` 的 `GLuint` 数组访问。
- en: Initialize the A buffers with appropriate initial values. For example, all of
    the positions could be set to the origin, and the velocities and start times could
    be initialized in the same way as described in the previous *Creating a particle
    fountain *recipe. The initial velocity buffer could simply be a copy of the velocity
    buffer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的初始值初始化 A 缓冲区。例如，所有位置可以设置为原点，速度和起始时间可以像在先前的 *创建粒子喷泉* 菜谱中描述的那样初始化。初始速度缓冲区可以简单地是速度缓冲区的副本。
- en: When using transform feedback, we define the buffers that will receive the output
    data from the vertex shader by binding the buffers to the indexed binding points
    under the `GL_TRANSFORM_FEEDBACK_BUFFER` target. The index corresponds to the
    index of the vertex shader's output variable as defined by `glTransformFeedbackVaryings`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用变换反馈时，我们通过将缓冲区绑定到 `GL_TRANSFORM_FEEDBACK_BUFFER` 目标下的索引绑定点来定义将接收顶点着色器输出数据的缓冲区。索引对应于由
    `glTransformFeedbackVaryings` 定义的顶点着色器输出变量的索引。
- en: 'To help simplify things, we''ll make use of transform feedback objects. Use
    the following code to set up two transform feedback objects for each set of buffers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将使用变换反馈对象。使用以下代码为每套缓冲区设置两个变换反馈对象：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similar to vertex array objects, transform feedback objects store the buffer
    bindings to the `GL_TRANSFORM_FEEDBACK_BUFFER` binding point so that they can
    be reset quickly at a later time. In the previous code, we create two transform
    feedback objects, and store their handles in the array named `feedback`. For the
    first object, we bind `posBuf[0]` to index `0`, `velBuf[0]` to index `1`, and
    `startTime[0]` to index `2` of the binding point (buffer set A). These bindings
    are connected to the shader output variables with `glTransformFeedbackVaryings`
    (or via a layout qualifier; see the following *There's more...* section). The
    last argument for each is the buffer's handle. For the second object, we do the
    same thing using the buffer set B. Once this is set up, we can define the set
    of buffers to receive the vertex shader's output, by binding to one or the other
    transform feedback object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点数组对象类似，变换反馈对象存储到`GL_TRANSFORM_FEEDBACK_BUFFER`绑定点的缓冲区绑定，以便可以在稍后快速重置。在之前的代码中，我们创建了两个变换反馈对象，并将它们的句柄存储在名为`feedback`的数组中。对于第一个对象，我们将`posBuf[0]`绑定到索引`0`，`velBuf[0]`绑定到索引`1`，`startTime[0]`绑定到索引`2`的绑定点（缓冲区集A）。这些绑定通过`glTransformFeedbackVaryings`（或通过布局限定符；参见以下*更多内容...*部分）与着色器输出变量连接。每个的最后一个参数是缓冲区的句柄。对于第二个对象，我们使用缓冲区集B执行相同操作。一旦设置好，我们就可以通过绑定到一个或另一个变换反馈对象来定义接收顶点着色器输出的缓冲区集。
- en: The initial values for the age buffer are all negative values. The absolute
    value represents how long before the particle is *born*. A particle is born when
    its age reaches zero.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄缓冲区的初始值都是负值。绝对值表示粒子“出生”之前的时间长度。当粒子的年龄达到零时，粒子就会出生。
- en: We also need some way of specifying the initial velocity of each particle. A
    simple solution is to use a texture of random velocities and query the texture
    when a random value is needed. We will use the built-in `gl_VertexID` variable
    to access a unique location within the texture for each particle. Create a 1D
    texture of float values and fill it with random initial velocities (the code omitted
    here, but is available in the example code).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方式来指定每个粒子的初始速度。一个简单的解决方案是使用随机速度的纹理，并在需要随机值时查询该纹理。我们将使用内置的`gl_VertexID`变量来访问每个粒子纹理中的唯一位置。创建一个浮点值的一维纹理，并用随机初始速度填充它（此处省略代码，但可在示例代码中找到）。
- en: 'The important uniform variables are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的统一变量如下：
- en: '`ParticleTex`: The texture to apply to the point sprites'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`粒子纹理`: 应用于点精灵的纹理'
- en: '`RandomTex`: The texture containing the random initial velocities'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`随机纹理`: 包含随机初始速度的纹理'
- en: '`Time`: The simulation time'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`时间`: 模拟时间'
- en: '`DeltaT`:  Defines the elapsed time between animation frames'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeltaT`: 定义动画帧之间的经过时间'
- en: '`Accel`: The acceleration'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`加速度`: 加速度'
- en: '`ParticleLifetime`: The length of time that a particle exists before it is
    recycled'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`粒子寿命`: 粒子存在的时间长度，在此之后它将被回收'
- en: '`Emitter`: The position of the particle emitter in world coordinates'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发射器`: 粒子发射器在世界坐标中的位置'
- en: '`EmitterBasis`: A rotation matrix for directing the emitter'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发射器基`: 用于指向发射器的旋转矩阵'
- en: '`ParticleSize`: The size of a particle'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`粒子大小`: 粒子的大小'
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the vertex shader, we have code that supports two passes: the update pass
    where the particles'' position, age, and velocity are updated, and the render
    pass where the particles are drawn:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们有支持两次遍历的代码：更新遍历，其中更新粒子的位置、年龄和速度，以及渲染遍历，其中绘制粒子：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The fragment shader code is simple and identical to that of the previous recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器代码简单且与上一个示例相同。
- en: 'After compiling the shader program, but before linking, use the following code
    to set up the connection between vertex shader output variables and output buffers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译着色器程序后，但在链接之前，使用以下代码设置顶点着色器输出变量与输出缓冲区之间的连接：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the OpenGL render function, we''ll use two passes. The first pass sends
    the particle positions to the vertex shader for updating, and capture the results
    using transform feedback. The input to the vertex shader will come from buffer
    A, and the output will be stored in buffer B. During this pass, we enable `GL_RASTERIZER_DISCARD`
    so that nothing is actually rendered to the framebuffer:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL渲染函数中，我们将使用两次遍历。第一次遍历将粒子位置发送到顶点着色器进行更新，并使用变换反馈捕获结果。顶点着色器的输入将来自缓冲区A，输出将存储在缓冲区B中。在此遍历期间，我们将启用`GL_RASTERIZER_DISCARD`，以便实际上不会将任何内容渲染到帧缓冲区：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we set the divisor to zero for all particle buffers and use `glDrawArrays`
    here. There's no need to use instancing here because we're not actually rendering
    the particles.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将所有粒子缓冲区的除数设置为零，并在这里使用 `glDrawArrays`。这里不需要使用实例化，因为我们实际上并没有渲染粒子。
- en: 'In the second pass, we use the output gathered from the first pass to render
    the particles using `glDrawArraysInstanced`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次传递中，我们使用第一次传递收集到的输出，使用 `glDrawArraysInstanced` 渲染粒子：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we swap the buffers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们交换缓冲区：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There's quite a bit here to sort through. Let's start with the vertex shader.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多东西需要整理。让我们从顶点着色器开始。
- en: The vertex shader is broken up into two primary functions (`update` and `render`).
    The `update` function is used during the first pass, and uses Euler's method to
    update the position and velocity of the particle. The `render` function is used
    during the second pass. It computes the transparency based on the age of the particle
    and sends the position and transparency along to the fragment shader.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器分为两个主要函数（`update` 和 `render`）。`update` 函数在第一次传递期间使用，并使用欧拉方法更新粒子的位置和速度。`render`
    函数在第二次传递期间使用。它根据粒子的年龄计算透明度，并将位置和透明度传递到片段着色器。
- en: 'The vertex shader has three output variables that are used during the first
    pass: `Position`, `Velocity`, and `Age`. They are used to write to the feedback
    buffers.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器有三个输出变量，在第一次传递期间使用：`Position`、`Velocity` 和 `Age`。它们用于写入反馈缓冲区。
- en: The `update` function updates the particle position and velocity using Euler's
    method unless the particle is not alive yet, or has passed its lifetime. If its
    age is greater than the lifetime of a particle, we recycle the particle by resetting
    its position to the emitter position, updating the particle's age by subtracting
    `ParticleLifetime`, and setting its velocity to a new random velocity determined
    by the `randomInitialVelocity` function. Note that we do the same thing if the
    particle hasn't been born for the first time yet (the age is less than zero),
    except that we just update the age by `DeltaT`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数使用欧拉方法更新粒子的位置和速度，除非粒子尚未存活，或者已经过了它的生命周期。如果粒子的年龄大于粒子的生命周期，我们通过将位置重置为发射器位置、通过减去
    `ParticleLifetime` 更新粒子的年龄，并将速度设置为一个新的随机速度（由 `randomInitialVelocity` 函数确定）来回收粒子。注意，如果粒子尚未第一次出生（年龄小于零），我们也会做同样的事情，只是通过
    `DeltaT` 更新年龄。'
- en: The `render` function is fairly straightforward. It draws the quad by offsetting
    the particle's position in camera coordinates in much the same way as the previous
    recipe. The `VertexAge` variable is used to determine the transparency of the
    particle, assigning the result to the `Transp` output variable. It transforms
    the vertex position into clip coordinates and places the result in the built-in
    `gl_Position` output variable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 函数相当直接。它通过在相机坐标中偏移粒子的位置来绘制四边形，这与之前的食谱非常相似。`VertexAge` 变量用于确定粒子的透明度，并将结果分配给
    `Transp` 输出变量。它将顶点位置转换为裁剪坐标，并将结果放入内置的 `gl_Position` 输出变量中。'
- en: The fragment shader is only utilized during the second pass. It is disabled
    during the first. It colors the fragment based on the `ParticleTex` texture and
    the transparency delivered from the vertex shader (`Transp`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器仅在第二次传递期间使用。在第一次传递期间被禁用。它根据 `ParticleTex` 纹理和从顶点着色器（`Transp`）传递的透明度来着色片段。
- en: The next code segment is placed prior to linking the shader program and is responsible
    for setting up the correspondence between shader output variables and feedback
    buffers (buffers that are bound to indices of the `GL_TRANSFORM_FEEDBACK_BUFFER`
    binding point). The `glTransformFeedbackVaryings` function takes three arguments.
    The first is the handle to the shader program object. The second is the number
    of output variable names that will be provided. The third is an array of output
    variable names. The order of the names in this list corresponds to the indices
    of the feedback buffers. In this case, `Position` corresponds to index zero, `Velocity`
    to index one, and `Age` to index two. Check the previous code that creates our
    feedback buffer objects (the `glBindBufferBase` calls) to verify that this is
    indeed the case.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码段放置在链接着色程序之前，并负责设置着色器输出变量与反馈缓冲区（绑定到`GL_TRANSFORM_FEEDBACK_BUFFER`绑定点的索引）之间的对应关系。`glTransformFeedbackVaryings`函数接受三个参数。第一个是着色程序对象的句柄。第二个是提供的输出变量名称的数量。第三个是输出变量名称的数组。此列表中名称的顺序对应于反馈缓冲区的索引。在这种情况下，`Position`对应于索引零，`Velocity`对应于索引一，`Age`对应于索引二。检查创建我们的反馈缓冲区对象的先前代码（`glBindBufferBase`调用）以验证这一点。
- en: '`glTransformFeedbackVaryings` can be used to send data into an interleaved
    buffer instead (rather than separate buffers for each variable). Take a look at
    the OpenGL documentation for details.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`glTransformFeedbackVaryings`将数据发送到交错缓冲区（而不是为每个变量分别使用单独的缓冲区）。请查看OpenGL文档以获取详细信息。
- en: 'The next code segments describe how you might implement the render function
    within the main OpenGL program. In this example, there two important GLuint arrays:
    `feedback` and `particleArray`. They are each of size two and contain the handles
    to the two feedback buffer objects, and the two vertex array objects respectively.
    The `drawBuf` variable is just an integer used to alternate between the two sets
    of buffers. At any given frame, `drawBuf` will be either zero or one.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码段描述了如何在主OpenGL程序中实现渲染函数。在这个例子中，有两个重要的GLuint数组：`feedback`和`particleArray`。它们各自的大小为两个，包含两个反馈缓冲区对象的句柄以及两个顶点数组对象。`drawBuf`变量只是一个整数，用于在两组缓冲区之间交替。在任何给定帧中，`drawBuf`将是零或一。
- en: The code for the first pass sets the `Pass` uniform to `1` to enable the update
    functionality within the vertex shader. The next call, `glEnable(GL_RASTERIZER_DISCARD)`,
    turns rasterization off so that nothing is rendered during this pass. The call
    to `glBindTransformFeedback` selects the set of buffers corresponding to the `drawBuf` variable
    as the target for the transform feedback output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一遍的代码将`Pass`统一变量设置为`1`，以在顶点着色器内启用更新功能。接下来的调用`glEnable(GL_RASTERIZER_DISCARD)`关闭光栅化，以确保在此遍历期间不进行渲染。调用`glBindTransformFeedback`选择与`drawBuf`变量对应的缓冲区集作为变换反馈输出的目标。
- en: Before drawing the points (and thereby triggering our vertex shader), we call
    `glBeginTransformFeedback` to enable transform feedback. The argument is the kind
    of primitive that will be sent down the pipeline. In this case, we use `GL_POINTS`
    even though we'll actually be drawing triangles because we're not actually drawing
    any primitives. This pass is just used to update the particles, so there's no
    need to invoke the shader more than once per particle. This also indicates why
    we need to set the divisor to zero for our attributes in this pass. We're not
    using instancing in this pass, so we just want to invoke the vertex shader once
    per particle. We do so by calling `glDrawArrays`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制点（从而触发我们的顶点着色器）之前，我们调用`glBeginTransformFeedback`来启用变换反馈。参数是管道中将发送的原始类型。在这种情况下，我们使用`GL_POINTS`，尽管我们实际上会绘制三角形，因为我们实际上并没有绘制任何原始图形。这个遍历只是用来更新粒子，所以没有必要为每个粒子调用着色器超过一次。这也表明为什么我们需要在这个遍历中将我们的属性除数设置为零。在这个遍历中，我们不使用实例化，所以我们只想为每个粒子调用一次顶点着色器。我们通过调用`glDrawArrays`来实现这一点。
- en: Output from the vertex shader will go to the buffers that are bound to the `GL_TRANSFORM_FEEDBACK_BUFFER`
    binding point until `glEndTransformFeedback` is called. In this case, we bound
    the vertex array corresponding to `1 - drawBuf` (if `drawBuf` is 0, we use 1 and
    vice versa).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器的输出将发送到绑定到`GL_TRANSFORM_FEEDBACK_BUFFER`绑定点的缓冲区，直到调用`glEndTransformFeedback`。在这种情况下，我们绑定了对应于`1
    - drawBuf`的顶点数组（如果`drawBuf`是0，我们使用1，反之亦然）。
- en: At the end of the update pass, we re-enable rasterization with `glEnable(GL_RASTERIZER_DISCARD)`,
    and move on to the render pass.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新遍历的末尾，我们通过`glEnable(GL_RASTERIZER_DISCARD)`重新启用光栅化，并继续到渲染遍历。
- en: The render pass is straightforward; we just set `Pass` to `2` and draw the particles
    from the vertex array corresponding to `drawBuf`. That vertex array object contains
    the set of buffers that were written to in the previous pass.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染过程很简单；我们只需将`Pass`设置为`2`，并从对应于`drawBuf`的顶点数组中绘制粒子。该顶点数组对象包含在上一过程中写入的缓冲区集合。
- en: Here, we use instancing in the same fashion as described in the previous recipe,
    so we set the divisor for all of our attributes back to one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用实例化的方式与前面菜谱中描述的相同，因此将所有属性的除数都设置回一。
- en: Finally, at the end of the render pass, we swap our buffers by setting `drawBuf`
    to `1 - drawBuf`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在渲染过程结束时，通过将`drawBuf`设置为`1 - drawBuf`来交换我们的缓冲区。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The use of transform feedback is an effective way to capture vertex shader output.
    However, there are alternatives that make use of recent features that were introduced
    in OpenGL. For example, image load/store or shader storage buffer objects could
    be used. These are writable buffers that can be made available to the shader.
    Instead of using transform feedback, the vertex shader could write its results
    directly to a buffer. This might enable you to do everything in a single pass.
    We use these with compute shaders in [Chapter 11](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml), *Using
    Compute Shaders*, so look there for examples of their use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变换反馈是捕获顶点着色器输出的有效方法。然而，有一些利用OpenGL中引入的最近功能的方法。例如，可以使用图像加载/存储或着色器存储缓冲区对象。这些是可写缓冲区，可以提供给着色器。而不是使用变换反馈，顶点着色器可以直接将其结果写入缓冲区。这可能使您能够在单个过程中完成所有操作。我们在第11章中使用计算着色器[Chapter
    11](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml)，*使用计算着色器*中使用了这些，因此请在那里查找它们的使用示例。
- en: Using layout qualifiers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布局限定符
- en: OpenGL 4.4 introduced layout qualifiers that make it possible to specify the
    relationship between the shader output variables and feedback buffers directly
    within the shader instead of using `glTransformFeedbackVaryings`. The `xfb_buffer`,
    `xfb_stride`, and `xfb_offset` layout qualifiers can be specified for each output
    variable that is to be used with transform feedback.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 4.4 引入了布局限定符，这使得在着色器中直接指定着色器输出变量与反馈缓冲区之间的关系成为可能，而不是使用`glTransformFeedbackVaryings`。可以为每个要用于变换反馈的输出变量指定`xfb_buffer`、`xfb_stride`和`xfb_offset`布局限定符。
- en: Querying transform feedback results
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询变换反馈结果
- en: It is often useful to determine how many primitives were written during transform
    feedback pass. For example, if a geometry shader was active, the number of primitives
    written could be different than the number of primitives that were sent down the
    pipeline.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在变换反馈过程中确定写入了多少原语通常很有用。例如，如果几何着色器处于活动状态，写入的原语数量可能不同于通过管道发送的原语数量。
- en: 'OpenGL provides a way to query for this information using query objects. To
    do so, start by creating a query object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL提供了一种使用查询对象查询此信息的方法。要这样做，首先创建一个查询对象：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, prior to starting the transform feedback pass, start the counting process
    using the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在开始变换反馈过程之前，使用以下命令开始计数过程：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the end of the transform feedback pass, call `glEndQuery` to stop counting:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在变换反馈过程结束后，调用`glEndQuery`停止计数：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can get the number of primitives by using the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码获取原语的数量：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter10/sceneparticlesinstanced.cpp` file in the example code
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter10/sceneparticlesinstanced.cpp`文件
- en: The *Creating a particle fountain *recipe
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建粒子喷泉*菜谱'
- en: Creating a particle system using instanced meshes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实例网格创建粒子系统
- en: To give more geometric detail to each particle in a particle system, we can
    draw entire meshes instead of single quads. Instanced rendering is a convenient
    and efficient way to draw several copies of a particular object. OpenGL provides
    support for instanced rendering through the functions `glDrawArraysInstanced`
    and `glDrawElementsInstanced`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给粒子系统中的每个粒子提供更多的几何细节，我们可以绘制整个网格而不是单个四边形。实例渲染是绘制特定对象多个副本的一种方便且高效的方式。OpenGL通过`glDrawArraysInstanced`和`glDrawElementsInstanced`函数提供了对实例渲染的支持。
- en: 'In this example, we''ll modify the particle system introduced in the previous
    recipes. Rather than drawing single quads, we''ll render a more complex object
    in the place of each particle. The following image shows an example where each
    particle is rendered as a shaded torus:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将修改前一个菜谱中引入的粒子系统。我们不会绘制单个四边形，而是在每个粒子的位置渲染一个更复杂的对象。以下图像显示了每个粒子被渲染为着色环面的示例：
- en: '![](img/25d322a0-d832-49a4-b8e0-0e17d18abdad.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25d322a0-d832-49a4-b8e0-0e17d18abdad.png)'
- en: We covered the basics of instanced rendering in the previous recipes, so you
    may want to review those before reading this one. To draw full meshes, we'll use
    the same basic technique, with some minor changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们介绍了实例渲染的基础知识，所以在阅读这一部分之前，您可能需要回顾一下。为了绘制完整的网格，我们将使用相同的基本技术，但进行一些小的修改。
- en: We'll also add another attribute to control the rotation of each particle so
    that each can independently spin at a random rotational velocity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加另一个属性来控制每个粒子的旋转，以便每个粒子可以独立地以随机的旋转速度旋转。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll start the particle system as described in the *Creating a particle system
    using transform feedback *recipe. We'll just make a few modifications to that
    basic system.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照*使用变换反馈创建粒子系统*配方中描述的方式启动粒子系统。我们只会对基本系统进行一些修改。
- en: Instead of three pairs of buffers, we'll use four this time. We'll need buffers
    for the particle's position, velocity, age, and rotation. The rotation buffer
    will store both the rotational velocity and the angle of rotation using the `vec2` type.
    The *x* component will be the rotational velocity and the *y* component will be
    the angle. All shapes will rotate around the same axis. If desired, you could
    extend this to support a per-particle axis of rotation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的三对缓冲区不同，这次我们将使用四个。我们需要为粒子的位置、速度、年龄和旋转设置缓冲区。旋转缓冲区将使用`vec2`类型存储旋转速度和旋转角度。*x*分量是旋转速度，*y*分量是角度。所有形状都将围绕同一轴旋转。如果需要，您可以扩展以支持每粒子的旋转轴。
- en: Set up the other buffers in the same way as in the previous recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的配方设置其他缓冲区。
- en: Because we are drawing full meshes, we need attributes for the position and
    normal of each vertex of the mesh. These attributes will have a divisor of zero,
    while the per-particle attributes will have a divisor of one. During the update
    pass, we will ignore the mesh vertex and normal attributes, focusing on the per-particle
    attributes. During the render pass, we'll use all attributes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在绘制完整的网格，我们需要为网格的每个顶点的位置和法线设置属性。这些属性将具有除数为零，而每粒子的属性将具有除数为一。在更新过程中，我们将忽略网格顶点和法线属性，专注于每粒子的属性。在渲染过程中，我们将使用所有属性。
- en: 'To summarize, we need six attributes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们需要六个属性：
- en: '**Attributes 0 and 1**: Mesh vertex position and mesh vertex normal (divisor
    = 0)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性 0 和 1**：网格顶点位置和网格顶点法线（除数 = 0）'
- en: '**Attributes 3-6**: Per-particle attributes—particle position, velocity, age,
    and rotation (*divisor = 1* during render, *divisor = 0* during update)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性 3-6**：每粒子的属性——粒子位置、速度、年龄和旋转（渲染时*除数 = 1*，更新时*除数 = 0*）'
- en: Attribute 2 could be used for texture coordinates if desired.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，属性 2 可以用于纹理坐标。
- en: We need pairs of buffers for the per-particle attributes, but we only need one
    buffer for our mesh data, so we'll share the mesh buffers with both vertex array
    objects. For details, see the example code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每粒子的属性成对设置缓冲区，但我们需要为我们的网格数据只设置一个缓冲区，因此我们将共享网格缓冲区与两个顶点数组对象。有关详细信息，请参阅示例代码。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The vertex shader attributes include per-particle values and mesh values:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器属性包括每粒子的值和网格值：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We include output variables for transform feedback, used during the update
    pass, and for the fragment shader, used during the render pass:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括变换反馈的输出变量，用于更新传递期间，以及用于渲染传递期间的片段着色器：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `update` function (vertex shader) is similar to the one used in the previous
    recipe, however, here we update the particle''s rotation as well:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数（顶点着色器）与之前配方中使用的类似，但是在这里我们还会更新粒子的旋转：'
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `render` function (in the vertex shader) applies the rotation and translation
    using a matrix built from the particle''s rotation and position attributes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数（在顶点着色器中）使用由粒子的旋转和位置属性构建的矩阵应用旋转和变换：'
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The fragment shader applies a shading model such as Blinn-Phong. The code is
    omitted here.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器应用如Blinn-Phong之类的着色模型。代码在此省略。
- en: 'When invoking the transform feedback pass (the update pass), we disable the
    mesh attributes and set the divisor to zero for the particle attributes. We invoke
    the vertex shader for each particle using `glDrawArrays`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用变换反馈传递（更新传递）时，我们禁用网格属性，并将粒子属性的除数设置为零。我们使用`glDrawArrays`为每个粒子调用顶点着色器：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To draw the particles, we re-enable the mesh attributes, set the divisor for
    the per-particle attributes to one, and draw the torus `nParticles` times using
    `glDrawElementsInstanced`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制粒子，我们重新启用网格属性，将每个粒子的属性除数设置为 `1`，并使用 `glDrawElementsInstanced` 绘制 `nParticles`
    次的环面：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Recall that the first two input attributes to the vertex shader are not-instanced,
    meaning that they are advanced every vertex (and repeated every instance). The
    last four (attributes 3-6) are instanced attributes and only update every instance.
    Therefore, the effect is that all vertices of an instance of the mesh are transformed
    by the same matrix, ensuring that it acts as a single particle.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，传递给顶点着色器的第一个两个输入属性不是实例化的，这意味着它们在每个顶点（以及每个实例）上都会更新（并重复）。最后四个（属性 3-6）是实例化属性，并且只在每个实例上更新。因此，效果是网格实例的所有顶点都通过相同的矩阵变换，确保它作为一个单独的粒子起作用。
- en: There's more...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OpenGL provides a built-in variable to the vertex shader named `gl_InstanceID`.
    This is simply a counter and takes on a different value for each instance that
    is rendered. The first instance will have an ID of zero, the second will have
    an ID of one, and so on. This can be useful as a way to index to texture data
    appropriate for each instance. Another possibility is to use the instance's ID
    as a way to generate some random data for that instance. For example, we could
    use the instance ID (or some hash) as a seed to a pseudo-random number generation
    routine to get a unique random stream for each instance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 为顶点着色器提供了一个内置变量，名为 `gl_InstanceID`。这只是一个计数器，并为每个渲染的实例具有不同的值。第一个实例将具有
    ID 为零，第二个将具有 ID 为一，依此类推。这可以作为为每个实例索引适当纹理数据的方法。另一种可能性是使用实例的 ID 作为生成该实例一些随机数据的方法。例如，我们可以使用实例
    ID（或某些散列）作为伪随机数生成例程的种子，为每个实例获取唯一的随机流。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter10/sceneparticlesinstanced.cpp` file in the example code
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter10/sceneparticlesinstanced.cpp` 文件
- en: The *Creating a particle fountain* recipe
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建粒子喷泉* 菜单'
- en: The *Creating a particle system using transform feedback* recipe
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用变换反馈创建粒子系统* 菜单'
- en: Simulating fire with particles
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粒子模拟火焰
- en: To create an effect that roughly simulates fire, we only need to make a few
    changes to our basic particle system. Since fire is a substance that is only slightly
    affected by gravity, we don't worry about a downward gravitational acceleration.
    In fact, we'll actually use a slight upwards acceleration to make the particles
    spread out near the top of the flame. We'll also spread out the initial positions
    of the particles so that the base of the flame is not just a single point. Of
    course, we'll need to use a particle texture that has the red and orange colors
    associated with flame.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个大致模拟火焰的效果，我们只需要对我们的基本粒子系统进行一些修改。由于火焰是一种仅略微受重力影响的物质，我们不必担心向下的重力加速度。实际上，我们将使用轻微的向上加速度，使粒子在火焰顶部附近扩散。我们还将扩散粒子的初始位置，以便火焰的底部不是一个单独的点。当然，我们需要使用具有与火焰相关的红色和橙色颜色的粒子纹理。
- en: 'The following image shows an example of the running particle system:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了正在运行的粒子系统的示例：
- en: '![](img/a2cff4ec-04a3-4088-8a9d-6e0d148ee2b0.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2cff4ec-04a3-4088-8a9d-6e0d148ee2b0.png)'
- en: The texture that was used for the particles looks like a light *smudge* of the
    flame's colors. It is not shown here because it would not be very visible in print.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 用于粒子的纹理看起来像是火焰颜色的轻微 *污点*。它在这里没有显示，因为它在印刷中不太明显。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start with the basic particle system presented in the *Creating a particle
    system using transform feedback* recipe earlier in this chapter:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章前面提供的 *使用变换反馈创建粒子系统* 菜单开始：
- en: Set the uniform variable `Accel` to a small upward value such as (0.0, 0.1,
    0.0).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将统一变量 `Accel` 设置为一个小向上的值，例如 (0.0, 0.1, 0.0)。
- en: Set the `ParticleLifetime` uniform variable to about `3` seconds.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ParticleLifetime` 统一变量设置为大约 `3` 秒。
- en: Create and load a texture for the particles that has fire-like colors. Bind
    it to the first texture channel, and set the uniform `ParticleTex` to `0`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并加载一个具有火焰颜色纹理的粒子。将其绑定到第一个纹理通道，并将统一变量 `ParticleTex` 设置为 `0`。
- en: Use a particle size of about `0.5`. This is a good size for the texture that
    is used in this recipe, but you might use a different size depending on the number
    of particles and the texture.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大约 `0.5` 的粒子大小。这是本菜谱中使用的纹理的好大小，但您可能需要根据粒子的数量和纹理使用不同的尺寸。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll use a texture filled with random values (two values per particle). The
    first value will be used to generate the initial velocity and the second, the
    initial position. For the initial positions, instead of using the the emitter
    position for all particles, we offset that with random x location. When generating
    the initial velocities, we'll set the *x* and *z* components to zero and take
    the *y* component from the random texture.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用填充随机值的纹理（每个颗粒两个值）。第一个值将用于生成初始速度，第二个值用于生成初始位置。对于初始位置，我们不是使用发射器的位置为所有颗粒，而是使用随机的
    x 位置进行偏移。在生成初始速度时，我们将 *x* 和 *z* 分量设置为零，并从随机纹理中获取 *y* 分量。
- en: 'This, combined with the chosen acceleration, makes each particle move in only
    the *y* (vertical) direction:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这与所选加速度相结合，使得每个颗粒只在 *y*（垂直）方向上移动：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the fragment shader, we mix the color with black proportional to the age
    of the particle. This gives the effect of the flame turning to smoke as it rises:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们根据颗粒的年龄与黑色按比例混合颜色。这给出了火焰上升时变成烟雾的效果：
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We randomly distribute the *x* coordinate of the initial positions between -2.0
    and 2.0 for all of the particles, and set the initial velocities to have a *y*
    coordinate between 0.1 and 0.5\. Since the acceleration has only a *y* component,
    the particles will move only along a straight, vertical line in the y direction.
    The *x* or *z* component of the position should always remain at zero. This way,
    when recycling the particles, we can simply just reset the *y* coordinate to zero,
    to restart the particle at its initial position.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有颗粒的初始位置的 *x* 坐标随机分布在 -2.0 和 2.0 之间，并将初始速度的 *y* 坐标设置为 0.1 和 0.5 之间。由于加速度只有
    *y* 分量，颗粒将只在 y 方向上沿直线移动。位置的位置的 *x* 或 *z* 分量应始终保持在零。这样，当回收颗粒时，我们只需将 *y* 坐标重置为零，就可以重新启动颗粒到其初始位置。
- en: There's more...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of course, if you want a flame that moves in different directions, perhaps blown
    by the wind, you'd need to use a different value for the acceleration.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想要一个在不同方向上移动的火焰，可能被风吹动，你需要使用不同的加速度值。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter10/scenefire.cpp` file in the example code
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter10/scenefire.cpp` 文件
- en: The *Creating a particle system using transform feedback* recipe
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换反馈创建粒子系统的配方
- en: Simulating smoke with particles
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用颗粒模拟烟雾
- en: Smoke is characterized by many small particles that float away from the source,
    and spread out as they move through the air. We can simulate the floatation effect
    with particles by using a small upwards acceleration (or constant velocity), but
    simulating the diffusion of each small smoke particle might be too expensive.
    Instead, we can simulate the diffusion of many small particles by making our simulated
    particles change their size (grow) over time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾由许多小颗粒组成，这些颗粒从源头飘散，并在移动过程中扩散开来。我们可以通过使用小的向上加速度（或恒定速度）来模拟浮力效果，但模拟每个小烟雾颗粒的扩散可能过于昂贵。相反，我们可以通过使模拟的颗粒随时间改变大小（增长）来模拟许多小颗粒的扩散。
- en: 'The following image shows an example of the results:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了结果的一个示例：
- en: '![](img/fdfe21fd-0c01-4882-bb5c-d2f580675e63.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdfe21fd-0c01-4882-bb5c-d2f580675e63.png)'
- en: The texture for each particle is a very light *smudge* of grey or black color.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个颗粒的纹理是一种非常淡的灰色或黑色颜色的 *污点*。
- en: To make the particles grow over time, we'll simply increase the size of our
    quads.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要使颗粒随时间增长，我们只需增加我们的四边形的尺寸。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start with the basic particle system presented in the *Creating a particle
    system using transform feedback* recipe:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *使用变换反馈创建粒子系统* 的配方中提供的基粒子系统开始：
- en: Set the uniform variable `Accel` to a small upward value like (0.0, 0.1, 0.0).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将统一变量 `Accel` 设置为一个小向上的值，如（0.0，0.1，0.0）。
- en: Set the `ParticleLifetime` uniform variable to about `10` seconds.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ParticleLifetime` 统一变量设置为大约 `10` 秒。
- en: Create and load a texture for the particles that looks like just a light-grey
    smudge. Bind it to texture unit zero, and set the uniform `ParticleTex` to `0`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并加载一个看起来像浅灰色污点的颗粒纹理。将其绑定到纹理单元零，并将统一变量 `ParticleTex` 设置为 `0`。
- en: Set the `MinParticleSize` and `MaxParticleSize` uniform variables to `0.1` and
    `2.5` respectively.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MinParticleSize` 和 `MaxParticleSize` 统一变量分别设置为 `0.1` 和 `2.5`。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Within the vertex shader, add the following uniforms:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中，添加以下统一变量：
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, within the vertex shader, in the `render` function, we''ll update the
    size of the particle based on its age:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在顶点着色器中，在`render`函数中，我们将根据粒子的年龄更新粒子的大小：
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `render` function scales the particle's offsets by a value between `MinParticleSize`
    and `MaxParticleSize`, proportional to the age of the particle. This causes the
    size of the particles to grow as they evolve through the system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数根据粒子的年龄，将粒子偏移量按`MinParticleSize`和`MaxParticleSize`之间的一个值进行缩放。这导致粒子的大小随着它们在系统中的演变而增长。'
- en: See also
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter10/scenesmoke.cpp` file in the example code
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter10/scenesmoke.cpp`文件
- en: The *Creating a particle system using transform feedback* recipe
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用变换反馈创建粒子系统*的配方'
