- en: Particle Systems and Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating a surface with vertex displacement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle fountain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle system using transform feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle system using instanced meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating fire with particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating smoke with particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shaders provide us with the ability to leverage the massive parallelism offered
    by modern graphics processors. Since they have the ability to transform the vertex
    positions, they can be used to implement animation directly within the shaders
    themselves. This can provide a boost in efficiency if the animation algorithm
    can be parallelized appropriately for execution within the shader.
  prefs: []
  type: TYPE_NORMAL
- en: If a shader is to help with animation, it must not only compute the positions,
    but often it must write out the updated positions for use in the next frame. Shaders
    were not originally designed to write to arbitrary buffers (except, of course,
    the framebuffer). However, with recent versions, OpenGL has provided the ability
    to do so via a number of techniques including shader storage buffer objects and
    image load/store. As of OpenGL 3.0, we can also send the values of the vertex
    or geometry shader's output variables to an arbitrary buffer (or buffers). This
    feature is called **transform feedback**, and is particularly useful for particle
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at several examples of animation within shaders,
    focusing mostly on particle systems. The first example, animating with vertex
    displacement, demonstrates animation by transforming the vertex positions of an
    object based on a time-dependent function. In the *Creating a particle fountain*
    recipe, we will create a simple particle system under constant acceleration. In
    the *Creating a particle system using transform feedback* recipe, there is an
    example illustrating how to use OpenGL's transform feedback functionality within
    a particle system. The *Creating a particle system using instanced particles*
    recipe shows you how to animate many complex objects using instanced rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The last two recipes demonstrate some particle systems for simulating complex,
    real phenomena such as smoke and fire.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a surface with vertex displacement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A straightforward way to leverage shaders for animation is to simply transform
    the vertices within the vertex shader based on some time-dependent function. The
    OpenGL application supplies static geometry, and the vertex shader modifies the
    geometry using the current time (supplied as a uniform variable). This moves the
    computation of the vertex position from the CPU to the GPU, and leverages whatever
    parallelism the graphics driver makes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a waving surface by transforming the vertices
    of a tessellated quad based on a sine wave. We''ll send down the pipeline a set
    of triangles that make up a flat surface in the *x*-*z* plane. In the vertex shader,
    we''ll transform the *y* coordinate of each vertex based on a time-dependent sine
    function, and compute the normal vector of the transformed vertex. The following
    image shows the desired result (you''ll have to imagine that the waves are travelling
    across the surface from left to right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fdf555b-2946-408d-b99d-b454326e94b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, we could use a noise texture to animate the vertices (that make
    up the surface) based on a random function. (See [Chapter 9](5e6b75a0-9f0c-4798-bc37-b5d34b53ef4a.xhtml),
    *Using Noise in Shaders*, for details on noise textures.)
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the code, let's take a look at the mathematics that we'll
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll transform the *y *coordinate of the surface as a function of the current
    time and the modeling *x *coordinate. To do so, we''ll use the basic plane wave
    equation, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3f07ddf-11f9-4abe-b84e-10bde8473cdb.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A** is the wave''s amplitude (the height of the peaks), the lambda (**λ**)
    is the wavelength (the distance between successive peaks), and **v** is the wave''s
    velocity. The previous diagram shows an example of the wave when *t = 0* and the
    wavelength is equal to one. We''ll configure these coefficients through uniform
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to render the surface with proper shading, we also need the normal
    vector at the transformed location. We can compute the normal vector using the
    (partial) derivative of the previous function. The result is the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77694054-ee14-4dac-bae7-ba391d3a6b6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, this vector should be normalized before we use it in our shading
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your OpenGL application to render a flat, tessellated surface in the
    *x*-*z* plane. The results will look better if you use a large number of triangles.
    Also, keep track of the animation time using whatever method you prefer. Provide
    the current time to the vertex shader via the uniform `Time` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important uniform variables are the coefficients of the previous
    wave equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`K`: It is the wavenumber (*2π/λ*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Velocity`: It is the wave''s velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Amp`: It is the wave''s amplitude'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up your program to provide appropriate uniform variables for your chosen
    shading model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the vertex shader, we translate the *y* coordinate of the vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create a fragment shader that computes the fragment color based on the `Position`
    and `Normal` variables using whatever shading model you choose.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vertex shader takes the position of the vertex and updates the *y* coordinate
    using the wave equation discussed previously. After the first three statements,
    the variable `pos` is just a copy of the `VertexPosition` input variable with
    the modified *y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: We then compute the normal vector using the previous equation, normalize the
    result, and store it in the `n` variable. Since the wave is really just a two-dimensional
    wave (it doesn't depend on *z*), the *z* component of the normal vector will be
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we pass along the new position and normal to the fragment shader after
    converting to camera coordinates. As usual, we also pass the position in clip
    coordinates to the built-in `gl_Position` variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modifying the vertex position within the vertex shader is a straightforward
    way to offload some computation from the CPU to the GPU. It also eliminates the
    possible need to transfer vertex buffers between the GPU memory and main memory
    in order to modify the positions.
  prefs: []
  type: TYPE_NORMAL
- en: The main disadvantage is that the updated positions are not available on the
    CPU side. For example, they might be needed for additional processing (such as
    collision detection). However, there are a number of ways to provide this data
    back to the CPU. One technique might be the clever use of FBOs to receive the
    updated positions from the fragment shader. In a later recipe, we'll look at another
    technique that makes use of a newer OpenGL feature called **transform feedback**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`chapter10/scenewave.cpp` in the example code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle fountain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In computer graphics, a particle system is a group of objects that are used
    to simulate a variety of **fuzzy** systems such as smoke, liquid spray, fire,
    explosions, or other similar phenomena. Each particle is considered to be a point
    object with a position, but no size. They could be rendered as point sprites (using
    the `GL_POINTS` primitive mode), or as camera aligned quads or triangles. Each
    particle has a lifetime: it is born, animates according to a set of rules, and
    then dies. The particle can then be resurrected and go through the entire process
    again. In this example, particles do not interact with other particles, but some
    systems, such as fluid simulations, would require a particle to interact. A common
    technique is to render the particle as a single, textured, camera-facing quad
    with transparency.'
  prefs: []
  type: TYPE_NORMAL
- en: During the lifetime of a particle, it is animated according to a set of rules.
    These rules include the basic kinematic equations that define the movement of
    a particle that is subjected to constant acceleration (such as a gravitational
    field). In addition, we might take into account things such as wind, friction,
    or other factors. The particle may also change shape or transparency during its
    lifetime. Once the particle has reached a certain age (or position), it is considered
    to be *dead* and can be *recycled* and used again.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll implement a relatively simple particle system that has
    the look of a fountain of water. For simplicity, the particles in this example
    will not be *recycled*. Once they have reached the end of their lifetime, we'll
    draw them as fully transparent so that they are effectively invisible. This gives
    the fountain a finite lifetime, as if it only has a limited supply of material.
    In later recipes, we'll see some ways to improve this system by recycling particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a sequence of images—several successive frames from
    the output of this simple particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/086c3aa6-b2f0-4185-810c-66a6abf2160f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To animate the particles, we''ll use the standard kinematics equation for objects
    under constant acceleration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94fac40d-2580-4ef9-8d08-7725264501ce.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous equation describes the position of a particle at time *t*. *P[0]*
    is the initial position, *v[0]* is the initial velocity, and *a* is the acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: We'll define the initial position of all particles to be the origin (0,0,0).
    The initial velocity will be determined randomly within a range of values. Each
    particle will be created at a slightly different time, so the time that we use
    in the previous equation will be relative to the start time for the particle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the initial position is the same for all particles, we won''t need to
    provide it as an input attribute to the shader. Instead, we''ll just provide two
    other vertex attributes: the initial velocity and the start time (the particle''s
    time of *birth*)*.* Prior to the particle''s birth time, we''ll render it completely
    transparent. During its lifetime, the particle''s position will be determined
    using the previous equation with a value for *t* that is relative to the particle''s
    start time (`Time - StartTime`).'
  prefs: []
  type: TYPE_NORMAL
- en: To render our particles, we'll use a technique called **instancing**, along
    with a simple trick to generate screen-aligned quads. With this technique, we
    don't actually need any vertex buffers for the quad itself! Instead, we'll just
    invoke the vertex shader six times for each particle in order to generate two
    triangles (a quad). In the vertex shader, we'll compute the positions of the vertices
    as offsets from the particle's position. If we do so in screen space, we can easily
    create a screen-aligned quad. We'll need to provide input attributes that include
    the particle's initial velocity and **birth time**.
  prefs: []
  type: TYPE_NORMAL
- en: This technique makes use of the vertex shader to do all the work of animating
    the particles. We gain a great deal of efficiency over computing the positions
    on the CPU. The GPU can execute the vertex shader in parallel, and process several
    particles at once.
  prefs: []
  type: TYPE_NORMAL
- en: The core of this technique involves the use of the `glDrawArraysInstanced` function.
    This function is similar to the familiar `glDrawArrays`, but instead of just drawing
    once, it does so repeatedly. Where `glDrawArrays` would just *walk* through the
    vertex buffers once, `glDrawArraysInstanced` will do so a specified number of
    times. In addition, while *walking* through the buffers, we can also configure
    when to move to the next element in the buffer (how quickly to walk). Normally,
    we move to the next element with each invocation of the vertex shader (essentially
    once per vertex). However, with instanced drawing, we don't always want that.
    We might want several (sometimes hundreds) of invocations to get the same input
    value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, each particle in our particle system has six vertices (two triangles).
    For each of these six vertices, we want the same velocity, (particle) position,
    and other per-particle parameters. The key to this is the `glVertexAttribDivisor` function,
    which makes it possible to specify how often the index is advanced for a given
    attribute. A divisor value of `0` indicates that the index is advanced once per
    vertex. A value that is greater than zero (*n > 0*) indicates that the index advances
    once after n instances of the shape are drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have two attributes (A and B) and we set the divisor
    to zero for attribute A and one for attribute B. Then, we execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three arguments are the same as `glDrawArrays`. The fourth argument
    is the number of instances. So, this call would draw three instances of a triangle
    primitive (for a total of nine vertices), and the values of attributes A and B
    would be taken from the corresponding buffers at the indices shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Vertex indices** |'
  prefs: []
  type: TYPE_TB
- en: '| A | 0,1,2,0,1,2,0,1,2 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 0,0,0,1,1,1,2,2,2 |'
  prefs: []
  type: TYPE_TB
- en: Note how setting the vertex attribute divisor for B to one causes the index
    to advance once per instance, rather than once per vertex. In fact, in this recipe,
    we'll set the divisor for all of our attributes to one! We'll compute the positions
    of each vertex of a particle as offsets from the particle's position.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how it will be possible to distinguish one vertex from
    another in the vertex shader in order to determine the needed offsets if the attribute
    values are the same for all vertices of the particle. The solution comes via the
    built-in variable `gl_VertexID`. More on this follows.
  prefs: []
  type: TYPE_NORMAL
- en: We'll render each particle as a textured-point quad of two triangles. We'll
    increase the transparency of the particle linearly with the age of the particle,
    to make the particle appear to fade out as it animates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create two buffers (or a single interleaved buffer) to store our input
    attributes. The first buffer will store the initial velocity for each particle.
    We''ll choose the values randomly from a limited range of possible vectors. To
    create the *cone* of particles in the previous image, we''ll choose randomly from
    a set of vectors within the cone. We will *tilt* the cone toward some direction
    by applying a rotation matrix (`emitterBasis`). The following code is one way
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `randFloat` function returns a random value between
    zero and one. We pick random numbers within a range of possible values by using
    the GLM `mix` function (the GLM `mix` function works the same as the corresponding
    GLSL function—it performs a linear interpolation between the values of the first
    two arguments). Here, we choose a random `float` between zero and one and use
    that value to interpolate between the endpoints of our range.
  prefs: []
  type: TYPE_NORMAL
- en: To pick vectors from within our cone, we utilize spherical coordinates. The
    value of `theta` determines the angle between the center of the cone and the vector.
    The value of `phi` defines the possible directions around the *y *axis for a given
    value of `theta`. For more on spherical coordinates, grab your favorite math book.
  prefs: []
  type: TYPE_NORMAL
- en: Once a direction is chosen, the vector is scaled to have a magnitude between
    1.25 and 1.5\. This is a range that seems to work well for the desired effect.
    The magnitude of the velocity vector is the overall speed of the particle, and
    we can tweak this range to get a wider variety of speeds or faster/slower particles.
  prefs: []
  type: TYPE_NORMAL
- en: The last three lines in the loop assign the vector to the appropriate location
    in the vector `data`. After the loop, we copy the data into the buffer referred
    to by `initVel`. Set up this buffer to provide data for vertex attribute zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second buffer, we''ll store the start time for each particle. This will
    provide only a single float per vertex (particle). For this example, we''ll just
    create each particle in succession at a fixed rate. The following code will set
    up a buffer with each particle created a fixed number of seconds after the previous
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code simply creates an array of floats that starts at zero and gets incremented
    by `rate`. The array is then copied into the buffer referred to by `startTime`.
    Set this buffer to be the input for vertex attribute one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, we set the divisor for both attributes to one. This ensures
    that all vertices of a particle will receive the same value for the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands should be executed while the **vertex array object**
    (**VAO**) is bound. The divisor information is stored within the VAO. See the
    example code for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader has a number of uniform variables that control the simulation.
    Set the following uniform variables from within the OpenGL program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParticleTex`: The particle''s texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time`: The amount of time that has elapsed since the animation began'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gravity`: The vector representing one half of the acceleration in the previous
    equation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleLifetime`: Defines how long a particle survives after it is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSize`:  Size of the particle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmitterPos`:  The position of the particle emitter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we want our particles to be partially transparent, we enable alpha blending
    using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the vertex shader code, we *create* the particle by offsetting the particle
    position in camera coordinates. Note the use of `gl_VertexID` to identify the
    quad''s vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fragment shader, we just apply the texture and scale the alpha for the
    particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To render our particles, we make the depth buffer read-only using `glDepthMask`,
    and issue a `glDrawArraysInstanced` call with six vertices per particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vertex shader receives the particle's initial velocity (`VertexInitVel`)
    and start time (`VertexBirthTime`) in its two input attributes. The `Time` variable
    stores the amount of time that has elapsed since the beginning of the animation.
    The `Transp` output variable is the overall transparency of the particle.
  prefs: []
  type: TYPE_NORMAL
- en: In the main function of the vertex shader, we start by determining the particle's
    age (`t`) as the current simulation time minus the particle's birth time. The
    following `if` statement determines whether the particle is alive yet. If the
    particle's age is greater than zero, the particle is alive, otherwise, the particle
    has yet to be *born*. In the latter case, the position is set to the camera's
    origin and the particle is rendered fully transparent. We do the same thing if
    the particle's age is greater than its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: If the particle is alive, the particle's position (`pos`) is determined using
    the kinematic equation described previously. The `cameraPos` vertex position is
    determined by offsetting the particle's position using the `offsets` array. We
    transform the position into camera coordinates (using `MV`), and add the offset
    for the current vertex using `gl_VertexID` as the index.
  prefs: []
  type: TYPE_NORMAL
- en: '`gl_VertexID` is a built-in variable in GLSL that takes on the index of the
    vertex of the current instance.  In this case, since we are using six vertices
    per particle, `gl_VertexID` will be between 0 and 5.'
  prefs: []
  type: TYPE_NORMAL
- en: By applying the offsets in camera coordinates, we gain a quality that is often
    desired in particle systems. The particle's quad will always face the camera.
    This effect, called **billboarding**, gives the particles the illusion that they
    are solid shapes rather than just flat quads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We scale the offset value by `ParticleSize` to set the size of the particle.
    The transparency is determined by linearly interpolating based on the particle''s
    age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the particle is born it is fully opaque, and linearly becomes transparent
    as it ages. The value of `Transp` is `1.0` at birth and `0.0` at the end of the
    particle's lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: In the fragment shader, we color the fragment with the result of value of a
    texture lookup. Before finishing, we multiply the alpha value of the final color
    by the variable `Transp`, in order to scale the overall transparency of the particle
    based on the particle's age (as determined in the vertex shader).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example is meant to be a fairly gentle introduction to GPU-based particle
    systems. There are many things that could be done to improve the power and flexibility
    of this system. For example, we could vary the rotation of the particles as they
    progress through their lifetime to produce different effects.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most significant drawbacks of the technique in this recipe is that
    the particles can't be recycled easily. When a particle dies, it is simply rendered
    as transparent. It would be nice to be able to reuse each dead particle to create
    an apparently continuous stream of particles. Additionally, it would be useful
    to be able to have the particles respond appropriately to changing accelerations
    or modifications of the system (for example, wind or movement of the source).
    With the system described here, we couldn't do so because we are working with
    a single equation that defines the movement of the particle for all time. What
    would be needed is to incrementally update the positions based on the current
    forces involved (a simulation).
  prefs: []
  type: TYPE_NORMAL
- en: In order to accomplish the previous objective, we need some way to feed the
    output of the vertex shader (the particle's updated positions) back into the input
    of the vertex shader during the next frame. This would of course be simple if
    we weren't doing the simulation within the shader because we could simply update
    the positions of the primitives directly before rendering. However, since we are
    doing the work within the vertex shader, we are limited in the ways that we can
    write to memory.
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipe, we'll see an example of how to use an OpenGL feature
    called **transform feedback** to accomplish exactly what was just described. We
    can designate certain output variables to be sent to buffers that can be read
    as input in subsequent rendering passes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter10/scene_particles.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Animating a surface with vertex displacement* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a particle system using transform feedback* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle system using transform feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transform feedback provides a way to capture the output of the vertex (or geometry)
    shader to a buffer for use in subsequent passes. Originally introduced into OpenGL
    with version 3.0, this feature is particularly well-suited for particle systems,
    because among other things, it enables us to do discrete simulations. We can update
    a particle's position within the vertex shader and render that updated position
    in a subsequent pass (or the same pass). Then the updated positions can be used
    in the same way as input to the next frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll implement the same particle system from the previous
    recipe (*Creating a particle fountain*), this time making use of transform feedback.
    Instead of using an equation that describes the particle's motion for all time,
    we'll update the particle positions incrementally, solving the equations of motion
    based on the forces involved at the time each frame is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common technique is to make use of the Euler method, which approximates the
    position and velocity at time `t` based on the position, velocity, and acceleration
    at an earlier time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a827dcc-e6c1-4c2e-90c2-33194a93e417.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous equation, the subscripts represent the time step (or animation
    frame), *P* is the particle position, and *v* is the particle velocity. The equations
    describe the position and velocity at frame *n + 1* as a function of the position
    and velocity during the previous frame (*n*). The variable *h* represents the
    time step size, or the amount of time that has elapsed between frames. The term
    *a[n]* represents the instantaneous acceleration. For our simulation, this will
    be a constant value, but in general it might be a value that changes depending
    on the environment (wind, collisions, inter-particle interactions, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The Euler method is actually numerically integrating the Newtonian equation
    of motion. It is one of the simplest techniques for doing so. However, it is a
    first-order technique, which means that it can introduce a significant amount
    of error. More accurate techniques include **Verlet integration** and **Runge-Kutta
    integration**. Since our particle simulation is designed to look good and physical
    accuracy is not of high importance, the Euler method should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our simulation work, we''ll use a technique sometimes called **buffer
    ping-ponging**. We maintain two sets of vertex buffers and swap their uses each
    frame. For example, we use buffer **A** to provide the positions and velocities
    as input to the vertex shader. The vertex shader updates the positions and velocities
    using the Euler method and sends the results to buffer **B** using transform feedback.
    Then, in a second pass, we render the particles using buffer **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/772c7ecf-5b73-4dac-8082-33f25d96fc8b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next frame of animation, we repeat the same process, swapping the two
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: In general, transform feedback allows us to define a set of shader output variables
    that are to be written to a designated buffer (or set of buffers). There are several
    steps involved that will be demonstrated, but the basic idea is as follows. Just
    before the shader program is linked, we define the relationship between buffers
    and shader output variables using the `glTransformFeedbackVaryings` function.
    During rendering, we initiate a transform feedback pass. We bind the appropriate
    buffers to the transform feedback binding points. (If desired, we can disable
    rasterization so that the particles are not rendered.) We enable transform feedback
    using the `glBeginTransformFeedback` function and then draw the point primitives.
    The output from the vertex shader will be stored in the appropriate buffers. Then
    we disable transform feedback by calling `glEndTransformFeedback`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create and allocate three pairs of buffers. The first pair will be for the particle
    positions, the second for the particle velocities, and the third for the *age* of
    each particle. For clarity, we'll refer to the first buffer in each pair as the
    A buffer, and the second as the B buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Create two vertex arrays. The first vertex array should link the A position
    buffer with the first vertex attribute (attribute index 0), the A velocity buffer
    with vertex attribute one, and the A age buffer with vertex attribute two.
  prefs: []
  type: TYPE_NORMAL
- en: The second vertex array should be set up in the same way using the B buffers.  The
    handles to the two vertex arrays will be accessed via the `GLuint` array named
    `particleArray`.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the A buffers with appropriate initial values. For example, all of
    the positions could be set to the origin, and the velocities and start times could
    be initialized in the same way as described in the previous *Creating a particle
    fountain *recipe. The initial velocity buffer could simply be a copy of the velocity
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: When using transform feedback, we define the buffers that will receive the output
    data from the vertex shader by binding the buffers to the indexed binding points
    under the `GL_TRANSFORM_FEEDBACK_BUFFER` target. The index corresponds to the
    index of the vertex shader's output variable as defined by `glTransformFeedbackVaryings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help simplify things, we''ll make use of transform feedback objects. Use
    the following code to set up two transform feedback objects for each set of buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similar to vertex array objects, transform feedback objects store the buffer
    bindings to the `GL_TRANSFORM_FEEDBACK_BUFFER` binding point so that they can
    be reset quickly at a later time. In the previous code, we create two transform
    feedback objects, and store their handles in the array named `feedback`. For the
    first object, we bind `posBuf[0]` to index `0`, `velBuf[0]` to index `1`, and
    `startTime[0]` to index `2` of the binding point (buffer set A). These bindings
    are connected to the shader output variables with `glTransformFeedbackVaryings`
    (or via a layout qualifier; see the following *There's more...* section). The
    last argument for each is the buffer's handle. For the second object, we do the
    same thing using the buffer set B. Once this is set up, we can define the set
    of buffers to receive the vertex shader's output, by binding to one or the other
    transform feedback object.
  prefs: []
  type: TYPE_NORMAL
- en: The initial values for the age buffer are all negative values. The absolute
    value represents how long before the particle is *born*. A particle is born when
    its age reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: We also need some way of specifying the initial velocity of each particle. A
    simple solution is to use a texture of random velocities and query the texture
    when a random value is needed. We will use the built-in `gl_VertexID` variable
    to access a unique location within the texture for each particle. Create a 1D
    texture of float values and fill it with random initial velocities (the code omitted
    here, but is available in the example code).
  prefs: []
  type: TYPE_NORMAL
- en: 'The important uniform variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParticleTex`: The texture to apply to the point sprites'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RandomTex`: The texture containing the random initial velocities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time`: The simulation time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeltaT`:  Defines the elapsed time between animation frames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Accel`: The acceleration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleLifetime`: The length of time that a particle exists before it is
    recycled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Emitter`: The position of the particle emitter in world coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmitterBasis`: A rotation matrix for directing the emitter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSize`: The size of a particle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the vertex shader, we have code that supports two passes: the update pass
    where the particles'' position, age, and velocity are updated, and the render
    pass where the particles are drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The fragment shader code is simple and identical to that of the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling the shader program, but before linking, use the following code
    to set up the connection between vertex shader output variables and output buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the OpenGL render function, we''ll use two passes. The first pass sends
    the particle positions to the vertex shader for updating, and capture the results
    using transform feedback. The input to the vertex shader will come from buffer
    A, and the output will be stored in buffer B. During this pass, we enable `GL_RASTERIZER_DISCARD`
    so that nothing is actually rendered to the framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that we set the divisor to zero for all particle buffers and use `glDrawArrays`
    here. There's no need to use instancing here because we're not actually rendering
    the particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second pass, we use the output gathered from the first pass to render
    the particles using `glDrawArraysInstanced`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we swap the buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's quite a bit here to sort through. Let's start with the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader is broken up into two primary functions (`update` and `render`).
    The `update` function is used during the first pass, and uses Euler's method to
    update the position and velocity of the particle. The `render` function is used
    during the second pass. It computes the transparency based on the age of the particle
    and sends the position and transparency along to the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader has three output variables that are used during the first
    pass: `Position`, `Velocity`, and `Age`. They are used to write to the feedback
    buffers.'
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function updates the particle position and velocity using Euler's
    method unless the particle is not alive yet, or has passed its lifetime. If its
    age is greater than the lifetime of a particle, we recycle the particle by resetting
    its position to the emitter position, updating the particle's age by subtracting
    `ParticleLifetime`, and setting its velocity to a new random velocity determined
    by the `randomInitialVelocity` function. Note that we do the same thing if the
    particle hasn't been born for the first time yet (the age is less than zero),
    except that we just update the age by `DeltaT`.
  prefs: []
  type: TYPE_NORMAL
- en: The `render` function is fairly straightforward. It draws the quad by offsetting
    the particle's position in camera coordinates in much the same way as the previous
    recipe. The `VertexAge` variable is used to determine the transparency of the
    particle, assigning the result to the `Transp` output variable. It transforms
    the vertex position into clip coordinates and places the result in the built-in
    `gl_Position` output variable.
  prefs: []
  type: TYPE_NORMAL
- en: The fragment shader is only utilized during the second pass. It is disabled
    during the first. It colors the fragment based on the `ParticleTex` texture and
    the transparency delivered from the vertex shader (`Transp`).
  prefs: []
  type: TYPE_NORMAL
- en: The next code segment is placed prior to linking the shader program and is responsible
    for setting up the correspondence between shader output variables and feedback
    buffers (buffers that are bound to indices of the `GL_TRANSFORM_FEEDBACK_BUFFER`
    binding point). The `glTransformFeedbackVaryings` function takes three arguments.
    The first is the handle to the shader program object. The second is the number
    of output variable names that will be provided. The third is an array of output
    variable names. The order of the names in this list corresponds to the indices
    of the feedback buffers. In this case, `Position` corresponds to index zero, `Velocity`
    to index one, and `Age` to index two. Check the previous code that creates our
    feedback buffer objects (the `glBindBufferBase` calls) to verify that this is
    indeed the case.
  prefs: []
  type: TYPE_NORMAL
- en: '`glTransformFeedbackVaryings` can be used to send data into an interleaved
    buffer instead (rather than separate buffers for each variable). Take a look at
    the OpenGL documentation for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code segments describe how you might implement the render function
    within the main OpenGL program. In this example, there two important GLuint arrays:
    `feedback` and `particleArray`. They are each of size two and contain the handles
    to the two feedback buffer objects, and the two vertex array objects respectively.
    The `drawBuf` variable is just an integer used to alternate between the two sets
    of buffers. At any given frame, `drawBuf` will be either zero or one.'
  prefs: []
  type: TYPE_NORMAL
- en: The code for the first pass sets the `Pass` uniform to `1` to enable the update
    functionality within the vertex shader. The next call, `glEnable(GL_RASTERIZER_DISCARD)`,
    turns rasterization off so that nothing is rendered during this pass. The call
    to `glBindTransformFeedback` selects the set of buffers corresponding to the `drawBuf` variable
    as the target for the transform feedback output.
  prefs: []
  type: TYPE_NORMAL
- en: Before drawing the points (and thereby triggering our vertex shader), we call
    `glBeginTransformFeedback` to enable transform feedback. The argument is the kind
    of primitive that will be sent down the pipeline. In this case, we use `GL_POINTS`
    even though we'll actually be drawing triangles because we're not actually drawing
    any primitives. This pass is just used to update the particles, so there's no
    need to invoke the shader more than once per particle. This also indicates why
    we need to set the divisor to zero for our attributes in this pass. We're not
    using instancing in this pass, so we just want to invoke the vertex shader once
    per particle. We do so by calling `glDrawArrays`.
  prefs: []
  type: TYPE_NORMAL
- en: Output from the vertex shader will go to the buffers that are bound to the `GL_TRANSFORM_FEEDBACK_BUFFER`
    binding point until `glEndTransformFeedback` is called. In this case, we bound
    the vertex array corresponding to `1 - drawBuf` (if `drawBuf` is 0, we use 1 and
    vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the update pass, we re-enable rasterization with `glEnable(GL_RASTERIZER_DISCARD)`,
    and move on to the render pass.
  prefs: []
  type: TYPE_NORMAL
- en: The render pass is straightforward; we just set `Pass` to `2` and draw the particles
    from the vertex array corresponding to `drawBuf`. That vertex array object contains
    the set of buffers that were written to in the previous pass.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use instancing in the same fashion as described in the previous recipe,
    so we set the divisor for all of our attributes back to one.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of the render pass, we swap our buffers by setting `drawBuf`
    to `1 - drawBuf`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of transform feedback is an effective way to capture vertex shader output.
    However, there are alternatives that make use of recent features that were introduced
    in OpenGL. For example, image load/store or shader storage buffer objects could
    be used. These are writable buffers that can be made available to the shader.
    Instead of using transform feedback, the vertex shader could write its results
    directly to a buffer. This might enable you to do everything in a single pass.
    We use these with compute shaders in [Chapter 11](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml), *Using
    Compute Shaders*, so look there for examples of their use.
  prefs: []
  type: TYPE_NORMAL
- en: Using layout qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL 4.4 introduced layout qualifiers that make it possible to specify the
    relationship between the shader output variables and feedback buffers directly
    within the shader instead of using `glTransformFeedbackVaryings`. The `xfb_buffer`,
    `xfb_stride`, and `xfb_offset` layout qualifiers can be specified for each output
    variable that is to be used with transform feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Querying transform feedback results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often useful to determine how many primitives were written during transform
    feedback pass. For example, if a geometry shader was active, the number of primitives
    written could be different than the number of primitives that were sent down the
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL provides a way to query for this information using query objects. To
    do so, start by creating a query object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, prior to starting the transform feedback pass, start the counting process
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the end of the transform feedback pass, call `glEndQuery` to stop counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can get the number of primitives by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter10/sceneparticlesinstanced.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a particle fountain *recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle system using instanced meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give more geometric detail to each particle in a particle system, we can
    draw entire meshes instead of single quads. Instanced rendering is a convenient
    and efficient way to draw several copies of a particular object. OpenGL provides
    support for instanced rendering through the functions `glDrawArraysInstanced`
    and `glDrawElementsInstanced`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll modify the particle system introduced in the previous
    recipes. Rather than drawing single quads, we''ll render a more complex object
    in the place of each particle. The following image shows an example where each
    particle is rendered as a shaded torus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25d322a0-d832-49a4-b8e0-0e17d18abdad.png)'
  prefs: []
  type: TYPE_IMG
- en: We covered the basics of instanced rendering in the previous recipes, so you
    may want to review those before reading this one. To draw full meshes, we'll use
    the same basic technique, with some minor changes.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add another attribute to control the rotation of each particle so
    that each can independently spin at a random rotational velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start the particle system as described in the *Creating a particle system
    using transform feedback *recipe. We'll just make a few modifications to that
    basic system.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of three pairs of buffers, we'll use four this time. We'll need buffers
    for the particle's position, velocity, age, and rotation. The rotation buffer
    will store both the rotational velocity and the angle of rotation using the `vec2` type.
    The *x* component will be the rotational velocity and the *y* component will be
    the angle. All shapes will rotate around the same axis. If desired, you could
    extend this to support a per-particle axis of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the other buffers in the same way as in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are drawing full meshes, we need attributes for the position and
    normal of each vertex of the mesh. These attributes will have a divisor of zero,
    while the per-particle attributes will have a divisor of one. During the update
    pass, we will ignore the mesh vertex and normal attributes, focusing on the per-particle
    attributes. During the render pass, we'll use all attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we need six attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes 0 and 1**: Mesh vertex position and mesh vertex normal (divisor
    = 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes 3-6**: Per-particle attributes—particle position, velocity, age,
    and rotation (*divisor = 1* during render, *divisor = 0* during update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute 2 could be used for texture coordinates if desired.
  prefs: []
  type: TYPE_NORMAL
- en: We need pairs of buffers for the per-particle attributes, but we only need one
    buffer for our mesh data, so we'll share the mesh buffers with both vertex array
    objects. For details, see the example code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vertex shader attributes include per-particle values and mesh values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We include output variables for transform feedback, used during the update
    pass, and for the fragment shader, used during the render pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` function (vertex shader) is similar to the one used in the previous
    recipe, however, here we update the particle''s rotation as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` function (in the vertex shader) applies the rotation and translation
    using a matrix built from the particle''s rotation and position attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The fragment shader applies a shading model such as Blinn-Phong. The code is
    omitted here.
  prefs: []
  type: TYPE_NORMAL
- en: 'When invoking the transform feedback pass (the update pass), we disable the
    mesh attributes and set the divisor to zero for the particle attributes. We invoke
    the vertex shader for each particle using `glDrawArrays`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the particles, we re-enable the mesh attributes, set the divisor for
    the per-particle attributes to one, and draw the torus `nParticles` times using
    `glDrawElementsInstanced`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that the first two input attributes to the vertex shader are not-instanced,
    meaning that they are advanced every vertex (and repeated every instance). The
    last four (attributes 3-6) are instanced attributes and only update every instance.
    Therefore, the effect is that all vertices of an instance of the mesh are transformed
    by the same matrix, ensuring that it acts as a single particle.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL provides a built-in variable to the vertex shader named `gl_InstanceID`.
    This is simply a counter and takes on a different value for each instance that
    is rendered. The first instance will have an ID of zero, the second will have
    an ID of one, and so on. This can be useful as a way to index to texture data
    appropriate for each instance. Another possibility is to use the instance's ID
    as a way to generate some random data for that instance. For example, we could
    use the instance ID (or some hash) as a seed to a pseudo-random number generation
    routine to get a unique random stream for each instance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter10/sceneparticlesinstanced.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a particle fountain* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a particle system using transform feedback* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating fire with particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an effect that roughly simulates fire, we only need to make a few
    changes to our basic particle system. Since fire is a substance that is only slightly
    affected by gravity, we don't worry about a downward gravitational acceleration.
    In fact, we'll actually use a slight upwards acceleration to make the particles
    spread out near the top of the flame. We'll also spread out the initial positions
    of the particles so that the base of the flame is not just a single point. Of
    course, we'll need to use a particle texture that has the red and orange colors
    associated with flame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an example of the running particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2cff4ec-04a3-4088-8a9d-6e0d148ee2b0.png)'
  prefs: []
  type: TYPE_IMG
- en: The texture that was used for the particles looks like a light *smudge* of the
    flame's colors. It is not shown here because it would not be very visible in print.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start with the basic particle system presented in the *Creating a particle
    system using transform feedback* recipe earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the uniform variable `Accel` to a small upward value such as (0.0, 0.1,
    0.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `ParticleLifetime` uniform variable to about `3` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and load a texture for the particles that has fire-like colors. Bind
    it to the first texture channel, and set the uniform `ParticleTex` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a particle size of about `0.5`. This is a good size for the texture that
    is used in this recipe, but you might use a different size depending on the number
    of particles and the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll use a texture filled with random values (two values per particle). The
    first value will be used to generate the initial velocity and the second, the
    initial position. For the initial positions, instead of using the the emitter
    position for all particles, we offset that with random x location. When generating
    the initial velocities, we'll set the *x* and *z* components to zero and take
    the *y* component from the random texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This, combined with the chosen acceleration, makes each particle move in only
    the *y* (vertical) direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fragment shader, we mix the color with black proportional to the age
    of the particle. This gives the effect of the flame turning to smoke as it rises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We randomly distribute the *x* coordinate of the initial positions between -2.0
    and 2.0 for all of the particles, and set the initial velocities to have a *y*
    coordinate between 0.1 and 0.5\. Since the acceleration has only a *y* component,
    the particles will move only along a straight, vertical line in the y direction.
    The *x* or *z* component of the position should always remain at zero. This way,
    when recycling the particles, we can simply just reset the *y* coordinate to zero,
    to restart the particle at its initial position.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, if you want a flame that moves in different directions, perhaps blown
    by the wind, you'd need to use a different value for the acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter10/scenefire.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a particle system using transform feedback* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating smoke with particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smoke is characterized by many small particles that float away from the source,
    and spread out as they move through the air. We can simulate the floatation effect
    with particles by using a small upwards acceleration (or constant velocity), but
    simulating the diffusion of each small smoke particle might be too expensive.
    Instead, we can simulate the diffusion of many small particles by making our simulated
    particles change their size (grow) over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an example of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdfe21fd-0c01-4882-bb5c-d2f580675e63.png)'
  prefs: []
  type: TYPE_IMG
- en: The texture for each particle is a very light *smudge* of grey or black color.
  prefs: []
  type: TYPE_NORMAL
- en: To make the particles grow over time, we'll simply increase the size of our
    quads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start with the basic particle system presented in the *Creating a particle
    system using transform feedback* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the uniform variable `Accel` to a small upward value like (0.0, 0.1, 0.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `ParticleLifetime` uniform variable to about `10` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and load a texture for the particles that looks like just a light-grey
    smudge. Bind it to texture unit zero, and set the uniform `ParticleTex` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `MinParticleSize` and `MaxParticleSize` uniform variables to `0.1` and
    `2.5` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the vertex shader, add the following uniforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, within the vertex shader, in the `render` function, we''ll update the
    size of the particle based on its age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `render` function scales the particle's offsets by a value between `MinParticleSize`
    and `MaxParticleSize`, proportional to the age of the particle. This causes the
    size of the particles to grow as they evolve through the system.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter10/scenesmoke.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a particle system using transform feedback* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
