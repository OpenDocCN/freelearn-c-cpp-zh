<html><head></head><body>
<div epub:type="chapter" id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-115"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.2.1">Overloading Memory Allocation Operators</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Enjoying yourself so far? </span><span class="koboSpan" id="kobo.3.2">I hope you are! </span><span class="koboSpan" id="kobo.3.3">We are at the point where we hold all the keys and can start to do what this book advertises and look in more detail at how memory management works in C++. </span><span class="koboSpan" id="kobo.3.4">It’s not a simple topic, nor is it something trivial, so we needed to make sure we were ready… but we are now, so let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">do it!</span></span></p>
<p><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.6.1"> and </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.8.1"> examined the standard tools one can use to ensconce responsibility over dynamically allocated resources into the C++ type system through smart pointers, the ones provided by the standard as well as those we could write to fill other niches. </span><span class="koboSpan" id="kobo.8.2">Using smart pointers instead of raw pointers as data members and function return types tends to simplify (and clarify) a significant proportion of memory management tasks in </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">C++ programs.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Sometimes, we want to work at a lower level than this and take control over what happens when someone writes </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">new X</span></strong><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">The reasons for wanting such control are numerous, and we will explore a few in this book, but in this chapter, we will focus on the basics of memory management functions and how to take control of these mechanisms </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">in C++.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">After these basics are covered, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">See how our knowledge of the memory allocation mechanisms of C++ lets us write a simple (yet working) leak detector in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 8</span></em></span></a></li>
<li><span class="koboSpan" id="kobo.18.1">Examine how one can manage atypical (persistent, shared, and so on) memory in C++ in </span><a href="B21071_09.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 9</span></em></span></a></li>
<li><span class="koboSpan" id="kobo.20.1">Write arena-based memory allocation in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.22.1"> to ensure deterministic time allocation and deallocation, leading to blazingly fast implementations of </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">new</span></strong><span class="koboSpan" id="kobo.24.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">delete</span></strong><span class="koboSpan" id="kobo.26.1"> when context </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">allows it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">Later chapters will use the knowledge acquired in this chapter and the ones that follow to write efficient containers and deferred reclamation mechanisms that resemble a garbage collector. </span><span class="koboSpan" id="kobo.28.2">Past that point, we will examine how containers can use these facilities, with and </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">without allocators.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.30.1">Why would one overload allocation functions?</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Before we start discussing how to overload memory allocation mechanisms, let’s take a step back and examine why one would want to do this. </span><span class="koboSpan" id="kobo.31.2">Indeed, most programmers (even experienced ones) never end up doing anything of the sort, and we could wager that a majority of programmers never thought they had a reason to do so. </span><span class="koboSpan" id="kobo.31.3">Yet, we will allocate (!) a few chapters to that very topic. </span><span class="koboSpan" id="kobo.31.4">There has to be </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">a reason…</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">The thing about memory allocation is that there’s no perfect solution to the problem in general; there are many </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.34.1">good solutions on average, and there are very good solutions to more specialized versions of the problem. </span><span class="koboSpan" id="kobo.34.2">What constitutes a good solution for a given use case in programming language A might be inappropriate for another use case or in programming </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">language B.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Take, for example, languages where is it idiomatic to allocate dynamically large numbers of small objects, something customary of Java or C#. </span><span class="koboSpan" id="kobo.36.2">In such a language, one could expect the allocation strategies to be optimized for that usage pattern. </span><span class="koboSpan" id="kobo.36.3">In a language such as C, where one would tend to allocate when faced with objects too large to put on the stack or when using node-based data structures for example, the best dynamic memory allocation strategy could be quite different. </span><span class="koboSpan" id="kobo.36.4">In </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.38.1">, we will see an example where the allocation process benefits from the fact that the allocated objects are all of the same size and alignment, another interesting </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">C++ emphasizes control and provides sophisticated and versatile tools to programmers. </span><span class="koboSpan" id="kobo.40.2">When facing a situation where we know the context in which allocations will be performed, we can sometimes use these tools to do better (even </span><em class="italic"><span class="koboSpan" id="kobo.41.1">much</span></em><span class="koboSpan" id="kobo.42.1"> better, as we will see in </span><a href="B21071_11.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.43.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.44.1">!) than a default implementation would, and for numerous metrics: better execution time, more deterministic execution time, reduced memory fragmentation, and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">so on.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.46.1">Brief overview of the C language allocation functions</span></h1>
<p><span class="koboSpan" id="kobo.47.1">Before we get to the memory </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.48.1">allocation mechanisms of C++, let’s first take a brief look at the C family of memory allocation functions through its most distinguished representatives: </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">malloc()</span></strong><span class="koboSpan" id="kobo.50.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">free()</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">There are, of course, many other memory-allocation-related functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">calloc()</span></strong><span class="koboSpan" id="kobo.54.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">realloc()</span></strong><span class="koboSpan" id="kobo.56.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">aligned_alloc()</span></strong><span class="koboSpan" id="kobo.58.1">, not counting operating-system-specific services that perform similar tasks for specialized use cases, but these will serve our </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">discussion well.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Note that since this is a book on memory management with C++, I will use the C++ version of these functions (from </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">&lt;cstdlib&gt;</span></strong><span class="koboSpan" id="kobo.62.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">&lt;stdlib.h&gt;</span></strong><span class="koboSpan" id="kobo.64.1">), which really changes nothing to the code we will write except for the fact that in C++, these functions are located in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">std</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">The signatures for these two functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
void* malloc(size_t n);
void free(void *p);</span></pre> <p><span class="koboSpan" id="kobo.70.1">The role of </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">malloc(n)</span></strong><span class="koboSpan" id="kobo.72.1"> is to find a location where there are at least </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">n</span></strong><span class="koboSpan" id="kobo.74.1"> consecutive bytes available, potentially marking that location as “taken” and returning an abstract pointer (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">void*</span></strong><span class="koboSpan" id="kobo.76.1">) to the beginning of that block of memory. </span><span class="koboSpan" id="kobo.76.2">Note that the pointer returned has to be aligned for the worst possible natural case in a given machine, which means that it has to suit the alignment requirements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">On most machines, this type is an alias </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">double</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Interestingly, it is legal to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">malloc()</span></strong><span class="koboSpan" id="kobo.84.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">n==0</span></strong><span class="koboSpan" id="kobo.86.1">, but the results of such a call are implementation-defined: a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">malloc(0)</span></strong><span class="koboSpan" id="kobo.88.1"> could return </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">nullptr</span></strong><span class="koboSpan" id="kobo.90.1"> but it could also return a non-null pointer. </span><span class="koboSpan" id="kobo.90.2">Note that the pointer returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">malloc(0)</span></strong><span class="koboSpan" id="kobo.92.1"> should not be dereferenced, regardless of whether it is null </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">malloc()</span></strong><span class="koboSpan" id="kobo.96.1"> fails to allocate memory, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">nullptr</span></strong><span class="koboSpan" id="kobo.98.1"> since the C language does not support exceptions in the C++ sense. </span><span class="koboSpan" id="kobo.98.2">In contemporary C (since C11), a </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">malloc()</span></strong><span class="koboSpan" id="kobo.100.1"> implementation has to be thread-safe and has to synchronize appropriately with other C allocation functions if they are called concurrently, including </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">free()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">The role of </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">free(p)</span></strong><span class="koboSpan" id="kobo.106.1"> is to ensure that the memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">p</span></strong><span class="koboSpan" id="kobo.108.1"> becomes available for further allocation requests, as long as </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">p</span></strong><span class="koboSpan" id="kobo.110.1"> points to a block that has been allocated through a memory allocation function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">malloc()</span></strong><span class="koboSpan" id="kobo.112.1"> and has not yet been freed. </span><span class="koboSpan" id="kobo.112.2">It is </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">undefined behavior</span></strong><span class="koboSpan" id="kobo.114.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.115.1">UB</span></strong><span class="koboSpan" id="kobo.116.1">) to try to </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">free()</span></strong><span class="koboSpan" id="kobo.118.1"> an address that has not been allocated through such an allocation function… Don’t do that! </span><span class="koboSpan" id="kobo.118.2">Also, know</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.119.1"> that once the memory has been freed, it is no longer considered allocated, so code such as the following leads </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">to UB:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
#include &lt;cstdlib&gt;
int main() {
   using std::malloc, std::free;
   int *p = static_cast&lt;int*&gt;(malloc(sizeof(int)));
   free(p); // fine since it comes from malloc()
   free(p); // NOOOOOO unless (stroke of luck?) p is null
}</span></pre> <p><span class="koboSpan" id="kobo.122.1">As mentioned in the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">free(nullptr)</span></strong><span class="koboSpan" id="kobo.124.1"> does nothing, and has been defined as doing nothing for decades as of this </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.125.1">writing. </span><span class="koboSpan" id="kobo.125.2">If there is code in your code base that verifies </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">p!=nullptr</span></strong><span class="koboSpan" id="kobo.127.1"> before calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">free()</span></strong><span class="koboSpan" id="kobo.129.1"> – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">if(p) free(p)</span></strong><span class="koboSpan" id="kobo.131.1"> – you can safely get rid of </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">that test.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">We will sometimes (not always) use these C functions to implement our homemade C++ allocation functions. </span><span class="koboSpan" id="kobo.133.2">They work, they are well understood, and they are low-level abstractions we can use to our advantage when building </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">higher-level ones.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.135.1">Overview of the C++ allocation operators</span></h1>
<p><span class="koboSpan" id="kobo.136.1">In C++, there are many (infinitely many!) flavors </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.137.1">of memory allocation operators, but there are rules to follow when writing your own. </span><span class="koboSpan" id="kobo.137.2">The current chapter is mostly about those rules; the chapters that follow will explore ways to benefit from this freedom C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">gives us:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.139.1">C++ lets us overload the </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">global versions</span></strong><span class="koboSpan" id="kobo.141.1"> of the memory allocation operators. </span><span class="koboSpan" id="kobo.141.2">If we do so, then </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.142.1">even things such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">new int</span></strong><span class="koboSpan" id="kobo.144.1"> will use our homemade versions. </span><span class="koboSpan" id="kobo.144.2">One has to be careful here since small mistakes can have a significant impact on code execution: if your implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">operator new()</span></strong><span class="koboSpan" id="kobo.146.1"> is slow, you will slow down most memory allocations in your program! </span><span class="koboSpan" id="kobo.146.2">We will use this approach when writing a simple-yet-working leak detector in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.147.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.148.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">C++ lets us overload </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">member function versions</span></strong><span class="koboSpan" id="kobo.151.1"> of the memory allocation operators. </span><span class="koboSpan" id="kobo.151.2">If we do, then </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.152.1">the global versions (overloaded or not) apply in general, but the member function versions apply for specific types. </span><span class="koboSpan" id="kobo.152.2">This can be useful when we have knowledge specific to the usage pattern of some types but not to others. </span><span class="koboSpan" id="kobo.152.3">We will use that to our advantage in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.153.1">Chapter 10</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.154.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.155.1">C++ lets us overload </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">versions with additional arguments</span></strong><span class="koboSpan" id="kobo.157.1"> of the memory allocation operators. </span><span class="koboSpan" id="kobo.157.2">In the current chapter, we will examine some standard versions of these operators such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">nothrow</span></strong><span class="koboSpan" id="kobo.159.1"> version and the (extremely important) </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">placement new</span></strong><span class="koboSpan" id="kobo.161.1">-related </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.162.1">versions. </span><span class="koboSpan" id="kobo.162.2">We can also use this feature to benefit from “exotic” memory such as shared memory or persistent memory, as we will see in </span><a href="B21071_09.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.163.1">Chapter 9</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.164.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.165.1">In each case, memory allocation functions come in groups of four: </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">operator new()</span></strong><span class="koboSpan" id="kobo.167.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.169.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">operator delete()</span></strong><span class="koboSpan" id="kobo.171.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">There are some exceptions to this rule, as we will see, but the rule generally holds. </span><span class="koboSpan" id="kobo.173.3">If we overload at least one of these functions, it’s </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.174.1">important that we overload all four to keep the behavior of our program consistent. </span><span class="koboSpan" id="kobo.174.2">When playing with low-level facilities like this, mistakes tend to bite harder than they would otherwise, which explains why we took so much care in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.175.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.176.1"> and </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.177.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.178.1"> explaining ways we could get in trouble… and how to play by the rules at the </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Memory allocation interacts closely with the object model (see </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.181.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.182.1"> for the basics) and with exception safety (a topic that’s pervasive throughout this book), so make sure to grasp these interactions in the pages and chapters that follow. </span><span class="koboSpan" id="kobo.182.2">They will help you make the best of what you will </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">read here.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.184.1">A word on Heap Allocation Optimization (HALO)</span></p>
<p class="callout"><span class="koboSpan" id="kobo.185.1">It’s important to know that there are benefits to </span><em class="italic"><span class="koboSpan" id="kobo.186.1">not</span></em><span class="koboSpan" id="kobo.187.1"> overloading memory allocation operators. </span><span class="koboSpan" id="kobo.187.2">One of them is that your </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.188.1">library vendor provides very good ones by default; another is that if you do not overload the memory allocation operators, the compiler can assume that the number of allocations you make is not observable. </span><span class="koboSpan" id="kobo.188.2">This means that it is allowed to replace </span><em class="italic"><span class="koboSpan" id="kobo.189.1">n</span></em><span class="koboSpan" id="kobo.190.1"> calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">new</span></strong><span class="koboSpan" id="kobo.192.1"> with a single call that allocates everything at once, and then manages the results as if you had performed many allocations. </span><span class="koboSpan" id="kobo.192.2">That can lead to some spectacular optimizations in practice, including the removal of calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">new</span></strong><span class="koboSpan" id="kobo.194.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">delete</span></strong><span class="koboSpan" id="kobo.196.1"> altogether from the generated code even when they </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.197.1">appear in the source code! </span><span class="koboSpan" id="kobo.197.2">If in doubt, please make sure that your optimizations provide measurable benefits before committing them and using them in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">production code.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Note that for the allocation operator overloads we will see in this chapter, you will want to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">&lt;new&gt;</span></strong><span class="koboSpan" id="kobo.201.1"> header as</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.202.1"> this is where </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.204.1"> is declared, among other things, and this is the type that allocation functions typically use to report failure </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">to allocate.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.206.1">Global allocation operators</span></h2>
<p><span class="koboSpan" id="kobo.207.1">Suppose we want to take control of the global versions of the allocation operators in C++. </span><span class="koboSpan" id="kobo.207.2">For the sake of exposing how this can </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.208.1">work, we will simply use them to delegate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">malloc()</span></strong><span class="koboSpan" id="kobo.210.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">free()</span></strong><span class="koboSpan" id="kobo.212.1"> for now, and show a more elaborate example in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.213.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.214.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">If we stick to the basic forms </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.216.1">of these operators, we will want to overload… well, four functions before C++11 or six functions since then. </span><span class="koboSpan" id="kobo.216.2">Of course, this book supposes that we’re over a decade past C++14, so we will </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">proceed accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">The signatures we want to overload are </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.220.1">
void *operator new(std::size_t);
void *operator new[](std::size_t);
void operator delete(void *) noexcept;
void operator delete[](void *) noexcept;
// since C++14
void operator delete(void *, std::size_t) noexcept;
void operator delete[](void *, std::size_t) noexcept;</span></pre> <p><span class="koboSpan" id="kobo.221.1">That’s a lot, I agree, but taking control of memory management facilities is specialized work. </span><span class="koboSpan" id="kobo.221.2">As soon as you write one of these functions, you officially replace the ones provided by your standard library for that program and that function becomes responsible for the allocation (or deallocation) requests that come through that channel. </span><span class="koboSpan" id="kobo.221.3">Replacing an allocation function requires you to use the exact same signature as </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">the original.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">The reason why it is important that</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.224.1"> you overload the whole set of functions if you overload at least one of them is that these functions form a consistent whole. </span><span class="koboSpan" id="kobo.224.2">For example, if you change the way </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">new</span></strong><span class="koboSpan" id="kobo.226.1"> behaves but neglect to </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.227.1">change the way the standard library-provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">delete</span></strong><span class="koboSpan" id="kobo.229.1"> performs its task, it’s essentially impossible to predict how much damage your program will incur. </span><span class="koboSpan" id="kobo.229.2">As a well-known popular comic book hero stated many times, </span><em class="italic"><span class="koboSpan" id="kobo.230.1">“with great power comes great responsibility.”</span></em><span class="koboSpan" id="kobo.231.1"> Be careful, be rigorous, and follow </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">the rules.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Pay attention to the signatures of these functions as they provide </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">interesting information…</span></span></p>
<h3><span class="koboSpan" id="kobo.235.1">On operators new and new[]</span></h3>
<p><span class="koboSpan" id="kobo.236.1">Functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">operator new()</span></strong><span class="koboSpan" id="kobo.238.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.240.1"> both take a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">std::size_t</span></strong><span class="koboSpan" id="kobo.242.1"> object as an argument and both return </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">void*</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">The argument is, in both cases, the minimal number of</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.245.1"> contiguous bytes to allocate. </span><span class="koboSpan" id="kobo.245.2">As such, their signatures resemble that of </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">That often surprises people; how can the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">new X</span></strong><span class="koboSpan" id="kobo.249.1"> expression create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">X</span></strong><span class="koboSpan" id="kobo.251.1"> object if </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">new</span></strong><span class="koboSpan" id="kobo.253.1"> is not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">template</span></strong><span class="koboSpan" id="kobo.255.1"> and does not know what </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">to create?</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">That’s the thing: </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">new</span></strong><span class="koboSpan" id="kobo.259.1"> does </span><em class="italic"><span class="koboSpan" id="kobo.260.1">not</span></em><span class="koboSpan" id="kobo.261.1"> create </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.262.1">objects. </span><span class="koboSpan" id="kobo.262.2">What </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">new</span></strong><span class="koboSpan" id="kobo.264.1"> does is find the location where an object will be constructed. </span><span class="koboSpan" id="kobo.264.2">It’s the constructor that turns the raw memory found by </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">new</span></strong><span class="koboSpan" id="kobo.266.1"> into an object. </span><span class="koboSpan" id="kobo.266.2">In practice, you could write something such as </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
X *p = new X{ /* ... </span><span class="koboSpan" id="kobo.268.2">args ... </span><span class="koboSpan" id="kobo.268.3">*/ };</span></pre> <p><span class="koboSpan" id="kobo.269.1">What you have written is a </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">two-step operation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
// allocate enough space to put an X object
void * buf = operator new(sizeof(X));
// construct an X object at that location
X *p = ... </span><span class="koboSpan" id="kobo.271.2">// apply X::X( /* ... </span><span class="koboSpan" id="kobo.271.3">args ... </span><span class="koboSpan" id="kobo.271.4">*/ ) on buf</span></pre> <p><span class="koboSpan" id="kobo.272.1">This means the constructor is like a coat of paint applied to a block of memory, turning that memory into an object. </span><span class="koboSpan" id="kobo.272.2">This also means that an expression such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">new X</span></strong><span class="koboSpan" id="kobo.274.1"> can fail either on </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">operator new()</span></strong><span class="koboSpan" id="kobo.276.1">, if the allocation </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.277.1">request could not succeed, or on </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">X::X()</span></strong><span class="koboSpan" id="kobo.279.1">, because the constructor failed</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.280.1"> somehow. </span><span class="koboSpan" id="kobo.280.2">Only if both steps succeed does client code become responsible for the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">pointed-to object.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.282.1">A note on calling these operators</span></p>
<p class="callout"><span class="koboSpan" id="kobo.283.1">You might have noticed in the preceding example that we sometimes write </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">new X</span></strong><span class="koboSpan" id="kobo.285.1"> and we sometimes write </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">operator new(sizeof(X))</span></strong><span class="koboSpan" id="kobo.287.1">. </span><span class="koboSpan" id="kobo.287.2">The first form – the </span><em class="italic"><span class="koboSpan" id="kobo.288.1">operator form</span></em><span class="koboSpan" id="kobo.289.1"> – will do the two-step process of allocation followed by construction, whereas the second form – the </span><em class="italic"><span class="koboSpan" id="kobo.290.1">function form</span></em><span class="koboSpan" id="kobo.291.1"> – directly calls the allocation function without invoking a constructor. </span><span class="koboSpan" id="kobo.291.2">This distinction also applies to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">operator delete()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">The situation is similar with </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">operator new[]</span></strong><span class="koboSpan" id="kobo.296.1">: the number of bytes passed as argument to the function is the total number of bytes for the array, so the allocation function itself knows neither the type of object that will be created nor the number of elements or the individual size of the objects. </span><span class="koboSpan" id="kobo.296.2">A call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">new X[N]</span></strong><span class="koboSpan" id="kobo.298.1"> will, in practice, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">operator new[](N*sizeof(X))</span></strong><span class="koboSpan" id="kobo.300.1"> to find a place to put the array that will be constructed, then call </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">X::X()</span></strong><span class="koboSpan" id="kobo.302.1"> on each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">N</span></strong><span class="koboSpan" id="kobo.304.1"> blocks of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.306.1"> in that array. </span><span class="koboSpan" id="kobo.306.2">Only when the entire sequence completes successfully does client code become responsible for the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">resulting array.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Failure to allocate a scalar through </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">operator new</span></strong><span class="koboSpan" id="kobo.310.1"> should result in something that matches </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.312.1"> being thrown. </span><span class="koboSpan" id="kobo.312.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.314.1">, one can also throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">std::bad_array_new_length</span></strong><span class="koboSpan" id="kobo.316.1"> (derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.318.1">) if the requested size is problematic, typically because it exceeds </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">implementation-defined limits.</span></span></p>
<h3><span class="koboSpan" id="kobo.320.1">On operators delete and delete[]</span></h3>
<p><span class="koboSpan" id="kobo.321.1">Like the C language’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">free()</span></strong><span class="koboSpan" id="kobo.323.1"> function, operators </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">delete()</span></strong><span class="koboSpan" id="kobo.325.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">delete[]()</span></strong><span class="koboSpan" id="kobo.327.1"> both take a </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">void*</span></strong><span class="koboSpan" id="kobo.329.1"> as argument. </span><span class="koboSpan" id="kobo.329.2">This </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.330.1">means that they cannot </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.331.1">destroy your object… When they are called, the object has already been destroyed! </span><span class="koboSpan" id="kobo.331.2">Indeed, you could write </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
delete p; // suppose that p is of type X*</span></pre> <p><span class="koboSpan" id="kobo.334.1">This is, in practice, a two-step operation that is equivalent to </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
p-&gt;~X(); // destroy the pointed-to object
operator delete(p); // free the associated memory</span></pre> <p><span class="koboSpan" id="kobo.337.1">In C++, neither your destructors </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.338.1">nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">operator delete()</span></strong><span class="koboSpan" id="kobo.340.1"> should throw exceptions. </span><span class="koboSpan" id="kobo.340.2">If they do, the program is pretty much terminated, for reasons that will become self-evident in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.342.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">The size-aware versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">operator delete()</span></strong><span class="koboSpan" id="kobo.345.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.347.1"> have been introduced with C++14 and it is customary to implement them today, in addition to the classical versions of these functions. </span><span class="koboSpan" id="kobo.347.2">The idea is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">operator new()</span></strong><span class="koboSpan" id="kobo.349.1"> was informed of </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.350.1">the size of the blocks to allocate but </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">operator delete()</span></strong><span class="koboSpan" id="kobo.352.1"> was not, which required unneeded acrobatics on the part of implementations that sought to do size-related tasks, such as filling the block of memory with some value in order to try to obscure what was stored at that location. </span><span class="koboSpan" id="kobo.352.2">Contemporary implementations of these functions require us to write a version that accepts the size of the pointed-to objects in addition to the classical version; if one’s implementation does not need that size, one can simply call the classical version from the size-aware one and be done </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">with it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.354.1">A note on sized operator delete[]() overloads</span></p>
<p class="callout"><span class="koboSpan" id="kobo.355.1">If you trace the execution of your overloads, you might be surprised to see that the sized version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.357.1"> is not necessarily called for some types. </span><span class="koboSpan" id="kobo.357.2">Indeed, if you have an array </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">arr</span></strong><span class="koboSpan" id="kobo.359.1"> of </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.360.1">objects of trivially destructible types, the standard leaves it unspecified as to which one of the sized and the unsized versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.362.1"> will be used when you write </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">delete [] arr</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">It’s not a bug, </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">rest assured.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">A full, yet naïve implementation of these functions that essentially delegate work to the C allocation functions could be </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;
void *operator new(std::size_t n) {
    std::cout &lt;&lt; "operator new(" &lt;&lt; n &lt;&lt; ")\n";
    auto p = std::malloc(n);
    if(!p) throw std::bad_alloc{};
    return p;
}
void operator delete(void *p) noexcept {
    std::cout &lt;&lt; "operator delete(...)\n";
    std::free(p);
}
void operator delete(void *p, std::size_t n) noexcept {
    std::cout &lt;&lt; "operator delete(..., " &lt;&lt; n &lt;&lt; ")\n";
    ::operator delete(p);
}
void *operator new[](std::size_t n) {
    std::cout &lt;&lt; "operator new[](" &lt;&lt; n &lt;&lt; ")\n";
    auto p = std::malloc(n);
    if(!p) throw std::bad_alloc{};
    return p;
}
void operator delete[](void *p) noexcept {
    std::cout &lt;&lt; "operator delete[](...)\n";
    std::free(p);
}
void operator delete[](void *p, std::size_t n) noexcept {
    std::cout &lt;&lt; "operator delete[](..., " &lt;&lt; n &lt;&lt; ")\n";
    ::operator delete[](p);
}
int main() {
   auto p = new int{ 3 };
   delete p;
   p = new int[10];
   delete []p;
}</span></pre> <p><span class="koboSpan" id="kobo.369.1">As is probably clear by now, the default behavior when </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">operator new()</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.373.1"> fail to</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.374.1"> achieve their postconditions and actually allocate the requested amount of memory is to throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.376.1"> or, when appropriate, </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">std::bad_array_new_length</span></strong><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">Since allocation is followed by construction, client code might also face any exception thrown by the constructor. </span><span class="koboSpan" id="kobo.378.3">We will look at ways to handle these situations when writing custom containers in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.379.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.380.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">There are application domains</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.382.1"> where exceptions are not an option. </span><span class="koboSpan" id="kobo.382.2">This can be due to memory constraints; most exception handlers make programs slightly bigger, which can be unacceptable in domains such as embedded systems. </span><span class="koboSpan" id="kobo.382.3">It can also be due to speed constraints; the code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">try</span></strong><span class="koboSpan" id="kobo.384.1"> blocks is usually fast as these blocks represent the “normal” execution paths, but code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">catch</span></strong><span class="koboSpan" id="kobo.386.1"> blocks is usually seen as the rare (“exceptional”) path and can be significantly slower to execute. </span><span class="koboSpan" id="kobo.386.2">Of course, some will simply avoid exception usage for philosophical reasons, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">fine too.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Luckily, there is a way to perform dynamic memory allocation without resorting to exceptions to </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">signal failure.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.390.1">Non-throwing versions of the allocation operators</span></h2>
<p><span class="koboSpan" id="kobo.391.1">There are also versions of the allocation operators that do not throw upon failure to allocate. </span><span class="koboSpan" id="kobo.391.2">The signatures for these </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.392.1">functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
void *operator new(std::size_t, </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">const std::nothrow_t&amp;);</span></strong><span class="koboSpan" id="kobo.396.1">
void *operator new[](std::size_t, </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">const std::nothrow_t&amp;);</span></strong><span class="koboSpan" id="kobo.398.1">
void operator delete(void *, </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">const std::nothrow_t&amp;)</span></strong><span class="koboSpan" id="kobo.400.1">
   noexcept;
void operator delete[](void *, </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">const std::nothrow_t&amp;)</span></strong><span class="koboSpan" id="kobo.402.1">
   noexcept;
// since C++14
void operator delete
   (void *, std::size_t, </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">const std::nothrow_t&amp;)</span></strong><span class="koboSpan" id="kobo.404.1"> noexcept;
void operator delete[]
   (void *, std::size_t, </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">const std::nothrow_t&amp;)</span></strong><span class="koboSpan" id="kobo.406.1"> noexcept;</span></pre> <p><span class="koboSpan" id="kobo.407.1">You might be wondering why someone would want to explicitly request that failure to allocate returns a null pointer instead of throwing an exception. </span><span class="koboSpan" id="kobo.407.2">It’s certainly more annoying to litter one’s code with tests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">nullptr</span></strong><span class="koboSpan" id="kobo.409.1"> than to just write it as if no failure occurred! </span><span class="koboSpan" id="kobo.409.2">The fact is that there are costs to using exceptions in one’s programs: it can make binaries slightly bigger, and it can slow down code execution, particularly when exceptions are caught (there are also issues of style involved; some people would not use exceptions even if they led to faster code, and that’s just part of life). </span><span class="koboSpan" id="kobo.409.3">For that reason, application domains </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.410.1">such as games or embedded systems often shun exceptions and go to some lengths to write code that does not depend on them. </span><span class="koboSpan" id="kobo.410.2">The non-throwing versions of the allocation functions target </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">these domains.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">std::nothrow_t</span></strong><span class="koboSpan" id="kobo.414.1"> is what is called a </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">tag type</span></strong><span class="koboSpan" id="kobo.416.1">: an empty class whose instances (here, the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">std::nothrow</span></strong><span class="koboSpan" id="kobo.418.1"> object) can be </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.419.1">used to guide the compiler when generating code. </span><span class="koboSpan" id="kobo.419.2">Note that these function signatures require the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">std::nothrow_t</span></strong><span class="koboSpan" id="kobo.421.1"> arguments to be passed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">const</span></strong><span class="koboSpan" id="kobo.423.1"> reference, not by value, so make sure you respect this signature if you seek to </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">replace them.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">An example usage of these functions would be </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
X *p = new </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">(nothrow)</span></strong><span class="koboSpan" id="kobo.429.1"> X{ /* ... </span><span class="koboSpan" id="kobo.429.2">args ... </span><span class="koboSpan" id="kobo.429.3">*/ };
if(p) {
   // ... </span><span class="koboSpan" id="kobo.429.4">use *p
   // note: this is not the nothrow version of delete
   delete p; // would be Ok even if !p
}</span></pre> <p><span class="koboSpan" id="kobo.430.1">You might be surprised about the position of </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">nothrow</span></strong><span class="koboSpan" id="kobo.432.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">new</span></strong><span class="koboSpan" id="kobo.434.1"> expression, but if you think about it, it’s essentially the only syntactic space for additional arguments passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">operator new()</span></strong><span class="koboSpan" id="kobo.436.1">; the first argument passed to the function is the number of contiguous bytes to allocate (here: </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.438.1">), and in expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">new X { ...args... </span><span class="koboSpan" id="kobo.439.2">}</span></strong><span class="koboSpan" id="kobo.440.1">, what follows the type of object to construct is the list of arguments passed to its constructor. </span><span class="koboSpan" id="kobo.440.2">Thus, the place to specify the additional arguments to </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">operator new()</span></strong><span class="koboSpan" id="kobo.442.1"> itself is </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.443.1">between </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">new</span></strong><span class="koboSpan" id="kobo.445.1"> and the type of the object to construct, </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">between parentheses.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.447.1">A word on the position of additional arguments to operator new()</span></p>
<p class="callout"><span class="koboSpan" id="kobo.448.1">To illustrate this better with an</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.449.1"> artificially crafted example, one could write the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">operator </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.452.1"> overload:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">void* operator new(std::size_t, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">int, double</span></strong></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">);</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.456.1">Then, a possible call to that hypothetical operator would be </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">as follows:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">X *p = new (3, 1.5) X{ /* ... </span><span class="koboSpan" id="kobo.458.2">*/ };</span></strong></p>
<p class="callout"><span class="koboSpan" id="kobo.459.1">Here, we can see how two additional arguments, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">int</span></strong><span class="koboSpan" id="kobo.461.1"> argument and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">double</span></strong><span class="koboSpan" id="kobo.463.1"> argument, are passed by </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">client code.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Returning to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">nothrow</span></strong><span class="koboSpan" id="kobo.467.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">operator new()</span></strong><span class="koboSpan" id="kobo.469.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.471.1">, one thing that is subtle and needs to be understood is why one needs to write overloads of </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">operator delete()</span></strong><span class="koboSpan" id="kobo.473.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">After all, even with client code that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">nothrow</span></strong><span class="koboSpan" id="kobo.477.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">new</span></strong><span class="koboSpan" id="kobo.479.1">, as was the case in our example, it’s highly probable that the “normal” version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">operator delete()</span></strong><span class="koboSpan" id="kobo.481.1"> will be used to end the life of that object. </span><span class="koboSpan" id="kobo.481.2">Why, then, write a </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">nothrow</span></strong><span class="koboSpan" id="kobo.483.1"> version of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">operator delete()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">?</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">The reason is </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">exception safety</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">But why worry about</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.489.1"> exceptions, you’re surely thinking, when writing a non-throwing version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">operator new()</span></strong><span class="koboSpan" id="kobo.491.1">? </span><span class="koboSpan" id="kobo.491.2">Well, remember that memory allocation through </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">operator new()</span></strong><span class="koboSpan" id="kobo.493.1"> is a two-step operation: find the location to place the object, then construct the object at that location. </span><span class="koboSpan" id="kobo.493.2">Thus, even if </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">operator new()</span></strong><span class="koboSpan" id="kobo.495.1"> does not throw, we do not know whether the constructor that will be called will throw. </span><span class="koboSpan" id="kobo.495.2">Our code will obtain the pointer only after both the allocation </span><em class="italic"><span class="koboSpan" id="kobo.496.1">and</span></em><span class="koboSpan" id="kobo.497.1"> the construction that follows have successfully completed execution; as such, client code cannot manage exceptions that occur after allocation succeeded but during the construction of the object, at least not in such a way as to deallocate the memory… It’s difficult to deallocate a pointer your code has not </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">yet seen!</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">For that reason, it falls on the C++ runtime to perform the deallocation if an exception is thrown by the constructor, and</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.500.1"> this is true for all versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">operator new()</span></strong><span class="koboSpan" id="kobo.502.1">, not just the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">nothrow</span></strong><span class="koboSpan" id="kobo.504.1"> ones. </span><span class="koboSpan" id="kobo.504.2">The algorithm (informally) is </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
// step 1, try to perform the allocation for some T object
p = operator new(n, ... </span><span class="koboSpan" id="kobo.506.2">maybe additional arguments ...)
// the following line is only for a nothrow new
if(!p) return p
try {
   // step 2, construct the object at address p
   apply the constructor of T at address p // might throw
} catch(...) { // construction threw an exception
   </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">deallocate p // this is what concerns us here</span></strong><span class="koboSpan" id="kobo.508.1">
   re-throw the exception, whatever it was
}
return p // p points to a fully constructed object
         // only after this point does client code see p</span></pre> <p><span class="koboSpan" id="kobo.509.1">As this algorithm shows, the C++ runtime has to deallocate the memory for us when the constructor throws an exception. </span><span class="koboSpan" id="kobo.509.2">But how does it do so? </span><span class="koboSpan" id="kobo.509.3">Well, it will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">operator delete()</span></strong><span class="koboSpan" id="kobo.511.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.513.1">) whose signature matches that of the version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">new</span></strong><span class="koboSpan" id="kobo.515.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">new[]</span></strong><span class="koboSpan" id="kobo.517.1"> that was used to perform the allocation. </span><span class="koboSpan" id="kobo.517.2">For example, if we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">operator new(size_t,</span></strong><strong class="bold"><span class="koboSpan" id="kobo.519.1">int,double</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">)</span></strong><span class="koboSpan" id="kobo.521.1"> to allocate and the constructor fails, it will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">operator delete(void*,</span></strong><strong class="bold"><span class="koboSpan" id="kobo.523.1">int,double</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">)</span></strong><span class="koboSpan" id="kobo.525.1"> to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">implicit deallocation.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">That is the reason why, if we overload the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">nothrow</span></strong><span class="koboSpan" id="kobo.529.1"> versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">new</span></strong><span class="koboSpan" id="kobo.531.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">new[]</span></strong><span class="koboSpan" id="kobo.533.1">, we have to overload the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">nothrow</span></strong><span class="koboSpan" id="kobo.535.1"> versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">delete</span></strong><span class="koboSpan" id="kobo.537.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">delete[]</span></strong><span class="koboSpan" id="kobo.539.1"> (they will be used for deallocation if a constructor throws), and why we also have to overload the “normal” throwing versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">new</span></strong><span class="koboSpan" id="kobo.541.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">new[]</span></strong><span class="koboSpan" id="kobo.543.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">delete</span></strong><span class="koboSpan" id="kobo.545.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">delete[]</span></strong><span class="koboSpan" id="kobo.547.1">. </span><span class="koboSpan" id="kobo.547.2">Expressed informally, code that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">X *p = new(nothrow)X;</span></strong><span class="koboSpan" id="kobo.549.1"> will usually call </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">delete p;</span></strong><span class="koboSpan" id="kobo.551.1"> to end the life of the pointee, and as such, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">nothrow</span></strong><span class="koboSpan" id="kobo.553.1"> and throwing versions of the allocation functions have to</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.554.1"> be coherent with </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">one another.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Here is a full, yet naïve implementation where the throwing versions delegate to the non-throwing ones to </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">reduce repetition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;
void* operator new(std::size_t n, const std::nothrow_t&amp;) noexcept {
   return std::malloc(n);
}
void* operator new(std::size_t n) {
   auto p = operator new(n, std::nothrow);
   if (!p) throw std::bad_alloc{};
   return p;
}
void operator delete(void* p, const std::nothrow_t&amp;)
   noexcept {
      std::free(p);
   }
void operator delete(void* p) noexcept {
   operator delete(p, std::nothrow);
}
void operator delete(void* p, std::size_t) noexcept {
   operator delete (p, std::nothrow);
}
void* operator new[](std::size_t n,
                     const std::nothrow_t&amp;) noexcept {
   return std::malloc(n);
}
void* operator new[](std::size_t n) {
   auto p = operator new[](n, std::nothrow);
   if (!p) throw std::bad_alloc{};
   return p;
}
void operator delete[](void* p, const std::nothrow_t&amp;)
   noexcept {
   std::free(p);
}
void operator delete[](void* p) noexcept {
   operator delete[](p, std::nothrow);
}
void operator delete[](void* p, std::size_t) noexcept {
   operator delete[](p, std::nothrow);
}
int main() {
   using std::nothrow;
   auto p = new (nothrow) int{ 3 };
   delete p;
   p = new (nothrow) int[10];
   delete[]p;
}</span></pre> <p><span class="koboSpan" id="kobo.559.1">As you can see, there are quite a few functions to write to get a full, cohesive set of allocation operators if we want to</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.560.1"> cover both the throwing and the non-throwing versions of </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">this mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">We still have a lot to cover. </span><span class="koboSpan" id="kobo.562.2">For example, we mentioned a few times already the idea of placing an object at a specific memory location, in particular at the second of the two-step process modeled by calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">new</span></strong><span class="koboSpan" id="kobo.564.1">. </span><span class="koboSpan" id="kobo.564.2">Let’s see how this </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">is done.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.566.1">The most important operator new: placement new</span></h2>
<p><span class="koboSpan" id="kobo.567.1">The most</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.568.1"> important version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">operator new()</span></strong><span class="koboSpan" id="kobo.570.1"> and friends is not one you can replace, but </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.571.1">even if you could… well, let’s just state that it would be difficult to achieve something </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">more efficient:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.573.1">
// note: these exist, you can use them but you cannot
// replace them
void *operator new(std::size_t, </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">void *p</span></strong><span class="koboSpan" id="kobo.575.1">) { </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">return p;</span></strong><span class="koboSpan" id="kobo.577.1"> }
void *operator new[](std::size_t, </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">void *p</span></strong><span class="koboSpan" id="kobo.579.1">) { </span><strong class="bold"><span class="koboSpan" id="kobo.580.1">return p;</span></strong><span class="koboSpan" id="kobo.581.1"> }
void operator delete(void*, </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">void*</span></strong><span class="koboSpan" id="kobo.583.1">) noexcept { }
void operator delete[](void*, </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">void*</span></strong><span class="koboSpan" id="kobo.585.1">) noexcept { }</span></pre> <p><span class="koboSpan" id="kobo.586.1">We call these the placement</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.587.1"> allocation functions, mostly known as </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">placement new</span></strong><span class="koboSpan" id="kobo.589.1"> by the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">programming community.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">What is the purpose of these functions? </span><span class="koboSpan" id="kobo.591.2">You might remember, at the beginning of our discussion of the global versions of the allocation operators, that we stated: “What </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">new</span></strong><span class="koboSpan" id="kobo.593.1"> does is find the location where an object will be constructed.” </span><span class="koboSpan" id="kobo.593.2">This does not necessarily mean that </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">new</span></strong><span class="koboSpan" id="kobo.595.1"> will allocate memory, and indeed, placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">new</span></strong><span class="koboSpan" id="kobo.597.1"> does not allocate; it simply yields back the address it has been given as argument. </span><em class="italic"><span class="koboSpan" id="kobo.598.1">This allows us to place an object wherever we want in memory</span></em><span class="koboSpan" id="kobo.599.1">… as long as we have the right to write the memory at </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">that location.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">Placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">new</span></strong><span class="koboSpan" id="kobo.603.1"> serves </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">many purposes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.605.1">If we have sufficient rights, it can let us map an object onto a piece of memory-mapped hardware, giving us an </span><em class="italic"><span class="koboSpan" id="kobo.606.1">extremely</span></em><span class="koboSpan" id="kobo.607.1"> thin layer of abstraction over </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">that device.</span></span></li>
<li><span class="koboSpan" id="kobo.609.1">It enables us to decouple allocation from construction, leading to significant speed improvements </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.610.1">when </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">writing containers.</span></span></li>
<li><span class="koboSpan" id="kobo.612.1">It opens up options to implement important facilities such as types </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">optional&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.614.1"> (that might or might not store a </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">T</span></strong><span class="koboSpan" id="kobo.616.1"> object) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">variant&lt;T0,T1,...,Tn&gt;</span></strong><span class="koboSpan" id="kobo.618.1"> (that stores an object of one of types </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">T0</span></strong><span class="koboSpan" id="kobo.620.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">T1</span></strong><span class="koboSpan" id="kobo.622.1">,...,</span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Tn</span></strong><span class="koboSpan" id="kobo.624.1">), or even </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">small object optimization</span></strong><span class="koboSpan" id="kobo.626.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.627.1">SOO</span></strong><span class="koboSpan" id="kobo.628.1">)-enabled types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">std::string</span></strong><span class="koboSpan" id="kobo.630.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">std::function</span></strong><span class="koboSpan" id="kobo.632.1"> that sometimes allocate external memory, but sometimes use their internal </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.633.1">data structures and avoid allocation altogether. </span><span class="koboSpan" id="kobo.633.2">Placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">new</span></strong><span class="koboSpan" id="kobo.635.1"> is not the only way to do this, but it is one of the options in </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">our toolbox.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.637.1">One important benefit of placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">new</span></strong><span class="koboSpan" id="kobo.639.1"> is most probably in the implementation of containers and the interaction between containers and allocators, themes we will explore from </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.640.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.641.1"> to </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.642.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.643.1"> of this book. </span><span class="koboSpan" id="kobo.643.2">For now, we will limit ourselves to a simple, artificial example that’s meant as an illustration of how placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">new</span></strong><span class="koboSpan" id="kobo.645.1"> works its magic, not as an example of something you should do (indeed, you should </span><em class="italic"><span class="koboSpan" id="kobo.646.1">not</span></em><span class="koboSpan" id="kobo.647.1"> do what the following </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">example does!).</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Suppose that you want to compute the length of a null-delimited character string and cannot remember the name of the C function that efficiently computes its length (better known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">std::strlen()</span></strong><span class="koboSpan" id="kobo.651.1">). </span><span class="koboSpan" id="kobo.651.2">One way to achieve similar results but </span><em class="italic"><span class="koboSpan" id="kobo.652.1">much</span></em><span class="koboSpan" id="kobo.653.1"> less efficiently would be to write </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
auto string_length(const char *p) {
   return std::string{ p }.size(); // augh! </span><span class="koboSpan" id="kobo.655.2">But it works...
</span><span class="koboSpan" id="kobo.655.3">}</span></pre> <p><span class="koboSpan" id="kobo.656.1">That’s inefficient because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">std::string</span></strong><span class="koboSpan" id="kobo.658.1"> constructor might allocate memory. </span><span class="koboSpan" id="kobo.658.2">We just wanted to count the characters until the first occurrence of a zero in the sequence, but it works (note: if you do the same maneuver with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">std::string_view</span></strong><span class="koboSpan" id="kobo.660.1"> instead of with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">std::string</span></strong><span class="koboSpan" id="kobo.662.1">, its performance will actually be quite reasonable!). </span><span class="koboSpan" id="kobo.662.2">Now, suppose you want to show off to </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.663.1">your friends the fact that you can place an object where you want in memory, and then</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.664.1"> use that object’s data members to do what you set out to do. </span><span class="koboSpan" id="kobo.664.2">You can (but should not) write </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
auto string_length(const char *p) {
   using std::string;
   </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">// A) make a local buffer of the right size and</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.668.1">   // alignment for a string object</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.669.1">   alignas(string) char buf[sizeof(string)];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.670.1">   // B) "paint" a string object in that buffer</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.671.1">   // (note: that object might allocate its</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.672.1">   // own data externally, but that's not</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.673.1">   // our concern here)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.674.1">   string *s = new (static_cast&lt;void*&gt;(buf)) string{ p };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.675.1">   // C) use that object to compute the size</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.676.1">   const auto sz = s-&gt;size();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.677.1">   // D) destroy the object without releasing the memory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.678.1">   // for the buffer (it's not dynamically allocated,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.679.1">   // it's just local storage)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.680.1">   s-&gt;~string(); // yes, you can do this</span></strong><span class="koboSpan" id="kobo.681.1">
   return sz;
}</span></pre> <p><span class="koboSpan" id="kobo.682.1">What are the benefits of the complicated version in comparison to the simple one? </span><span class="koboSpan" id="kobo.682.2">None whatsoever, but it shows</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.683.1"> the intricacies of doing this sort of low-level memory management maneuver. </span><span class="koboSpan" id="kobo.683.2">From the comments in the code example, the steps work </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.685.1">Step </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">A)</span></strong><span class="koboSpan" id="kobo.687.1"> makes sure that the location where the object will be constructed is of the right size and shape: it’s a buffer of bytes (type </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">char</span></strong><span class="koboSpan" id="kobo.689.1">), aligned in memory as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">std::string</span></strong><span class="koboSpan" id="kobo.691.1"> object should be, and of sufficient size to hold a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">std::string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1"> object.</span></span></li>
<li><span class="koboSpan" id="kobo.694.1">Step </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">B)</span></strong><span class="koboSpan" id="kobo.696.1"> paints a </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">std::string</span></strong><span class="koboSpan" id="kobo.698.1"> object in that buffer. </span><span class="koboSpan" id="kobo.698.2">That’s what a constructor does, really: it (conceptually) transforms raw memory into an object and initializes the state of that </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.699.1">object. </span><span class="koboSpan" id="kobo.699.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">std::string</span></strong><span class="koboSpan" id="kobo.701.1"> constructor throws an exception, then the object has never been constructed and our </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">string_length()</span></strong><span class="koboSpan" id="kobo.703.1"> function concludes without satisfying its postconditions. </span><span class="koboSpan" id="kobo.703.2">There is no memory allocation involved here unless the constructor itself allocates, but that’s fair (the object does what it has </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">to do).</span></span></li>
<li><span class="koboSpan" id="kobo.705.1">Step </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">C)</span></strong><span class="koboSpan" id="kobo.707.1"> uses the newly constructed object; in our case, it’s just a matter of querying the size of that character string, but we could do whatever we want here. </span><span class="koboSpan" id="kobo.707.2">Do note, however, that (a) the object’s lifetime is tied to the buffer in which it is located, and (b) since we explicitly called the constructor, we will need to explicitly destroy it, which means that if an exception is thrown when we use the object, we will need to make sure the object’s destructor is </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">called somehow.</span></span></li>
<li><span class="koboSpan" id="kobo.709.1">Step </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">D)</span></strong><span class="koboSpan" id="kobo.711.1"> destroys the object before we leave the function, as not doing so would lead to a possible leak of resources. </span><span class="koboSpan" id="kobo.711.2">If the buffer’s lifetime ends at a point where the object is not yet destroyed, things will be very wrong: either the destructor of the object we put in that buffer will never be called and code will leak, or someone might try to use the object even though the storage for that object is not ours anymore, leading to</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.712.1"> UB. </span><span class="koboSpan" id="kobo.712.2">Note the syntax, </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">s-&gt;~string()</span></strong><span class="koboSpan" id="kobo.714.1">, which calls the destructor but does not deallocate the storage </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">*s</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.718.1">This is a bad example of placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">new</span></strong><span class="koboSpan" id="kobo.720.1"> usage, but it is explicit and (hopefully) instructive. </span><span class="koboSpan" id="kobo.720.2">We will use this feature in much more reasonable ways in order to gain significant speed advantages when we write containers with explicit memory management in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.721.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.722.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.723.1">A note on make_shared&lt;T&gt;(args...)</span></h3>
<p><span class="koboSpan" id="kobo.724.1">We mentioned in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.726.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">make_shared&lt;T&gt;(args...)</span></strong><span class="koboSpan" id="kobo.728.1"> usually leads to a better memory layout than </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">shared_ptr&lt;T&gt;{ new T(args...) }</span></strong><span class="koboSpan" id="kobo.730.1"> would, at least with respect to cache usage. </span><span class="koboSpan" id="kobo.730.2">We </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.731.1">can start to see why that </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">is so.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">Calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">shared_ptr&lt;T&gt;::shared_ptr(T*)</span></strong><span class="koboSpan" id="kobo.735.1"> makes the object responsible for a preexisting pointee, the one whose address is passed as argument. </span><span class="koboSpan" id="kobo.735.2">Since that object has been constructed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.737.1"> object has to allocate a reference counter separately, ending up with two separate allocations, probably on different cache lines. </span><span class="koboSpan" id="kobo.737.2">In most programs, this worsened locality may induce slowdowns </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.739.1">On the other hand, calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">make_shared&lt;T&gt;(args...)</span></strong><span class="koboSpan" id="kobo.741.1"> makes this factory function responsible for creating a block of memory whose layout accommodates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">T</span></strong><span class="koboSpan" id="kobo.743.1"> object and the reference counter, respecting the size and alignment constraints of both. </span><span class="koboSpan" id="kobo.743.2">There’s more than one way to do this, of course, including (a) resorting to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">union</span></strong><span class="koboSpan" id="kobo.745.1"> where “coexist” a pair of pointers and a single pointer to a block that contains a counter and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">T</span></strong><span class="koboSpan" id="kobo.747.1"> object, and (b) resorting to a byte buffer of appropriate size and alignment, then performing placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">new</span></strong><span class="koboSpan" id="kobo.749.1"> for both objects in the appropriate locations within that buffer. </span><span class="koboSpan" id="kobo.749.2">In the latter case, we end up with a single allocation for a contiguous block of memory able to host both objects and two placement </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">new</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1"> calls.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.752.1">Member versions of the allocation operators</span></h2>
<p><span class="koboSpan" id="kobo.753.1">Sometimes, we have special knowledge of the needs and requirements of specific types with respect to dynamic memory allocation. </span><span class="koboSpan" id="kobo.753.2">A full example that goes into detail about a real-life (but simplified) use case of</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.754.1"> such type-specific knowledge is given in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.755.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.756.1">, where we discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">arena-based allocation.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">For now, we will limit ourselves to covering the syntax and the effect of a member function overload of the allocation operators. </span><span class="koboSpan" id="kobo.758.2">In the example that follows, we suppose class </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">X</span></strong><span class="koboSpan" id="kobo.760.1"> would somehow benefit from a per-class specialization of these mechanisms, and show that client code will call these specializations when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">new X</span></strong><span class="koboSpan" id="kobo.762.1"> but not when we call </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">new int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.765.1">
#include &lt;iostream&gt;
#include &lt;new&gt;
class X {
   // ...
</span><span class="koboSpan" id="kobo.765.2">public:
   X() { std::cout &lt;&lt; "X::X()\n"; }
   ~X() { std::cout &lt;&lt; "X::~X()\n"; }
   </span><strong class="bold"><span class="koboSpan" id="kobo.766.1">void *operator new(std::size_t);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.767.1">   void *operator new[](std::size_t);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.768.1">   void operator delete(void*);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.769.1">   void operator delete[](void*);</span></strong><span class="koboSpan" id="kobo.770.1">
   // ...
</span><span class="koboSpan" id="kobo.770.2">};
// ...
</span><strong class="bold"><span class="koboSpan" id="kobo.771.1">void* X::operator new(std::size_t n) {</span></strong><span class="koboSpan" id="kobo.772.1">
   std::cout &lt;&lt; "Some X::operator new() magic\n";
   return ::operator new(n);
}
</span><strong class="bold"><span class="koboSpan" id="kobo.773.1">void* X::operator new[](std::size_t n) {</span></strong><span class="koboSpan" id="kobo.774.1">
   std::cout &lt;&lt; "Some X::operator new[]() magic\n";
   return ::operator new[](n);
}
</span><strong class="bold"><span class="koboSpan" id="kobo.775.1">void X::operator delete(void *p) {</span></strong><span class="koboSpan" id="kobo.776.1">
   std::cout &lt;&lt; "Some X::operator delete() magic\n";
   return ::operator delete(p);
}
</span><strong class="bold"><span class="koboSpan" id="kobo.777.1">void X::operator delete[](void *p) {</span></strong><span class="koboSpan" id="kobo.778.1">
   std::cout &lt;&lt; "Some X::operator delete[]() magic\n";
   return ::operator delete[](p);
}
int main() {
   std::cout &lt;&lt; "p = new int{3}\n";
   </span><strong class="bold"><span class="koboSpan" id="kobo.779.1">int *p = new int{ 3 }; // global operator new</span></strong><span class="koboSpan" id="kobo.780.1">
   std::cout &lt;&lt; "q = new X\n";
   </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">X *q = new X; // X::operator new</span></strong><span class="koboSpan" id="kobo.782.1">
   std::cout &lt;&lt; "delete p\n";
   </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">delete p; // global operator delete</span></strong><span class="koboSpan" id="kobo.784.1">
   std::cout &lt;&lt; "delete q\n";
   </span><strong class="bold"><span class="koboSpan" id="kobo.785.1">delete q; // X::operator delete</span></strong><span class="koboSpan" id="kobo.786.1">
}</span></pre> <p><span class="koboSpan" id="kobo.787.1">One important detail to mention is that these overloaded operators will be inherited by derived classes, which means that if the implementation of these operators somehow depends on details specific to that class – for example, its size of alignment or anything else that might be </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.788.1">invalidated in derived classes through such seemingly inconspicuous details as adding a data member – consider marking the class that overloads these operators </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">final</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.792.1">Alignment-aware versions of the allocation operators</span></h2>
<p><span class="koboSpan" id="kobo.793.1">When designing C++17, a</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.794.1"> fundamental problem with the memory allocation process was fixed with respect to what we call </span><strong class="bold"><span class="koboSpan" id="kobo.795.1">overaligned types</span></strong><span class="koboSpan" id="kobo.796.1">. </span><span class="koboSpan" id="kobo.796.2">The idea is that</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.797.1"> there are types for which we will want alignment constraints that are stricter than the alignment of the strictest natural alignment on a machine as modeled by </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">std::max_align_t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">There are many reasons for this, but a simple example would be when communicating with specialized hardware with requirements that differ from the ones on our computer. </span><span class="koboSpan" id="kobo.801.2">Suppose the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">Float4</span></strong><span class="koboSpan" id="kobo.803.1"> type is such a type. </span><span class="koboSpan" id="kobo.803.2">Its size is </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">4*sizeof(float)</span></strong><span class="koboSpan" id="kobo.805.1">, and we require a </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">Float4</span></strong><span class="koboSpan" id="kobo.807.1"> to be aligned on a </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">16-byte boundary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.809.1">
struct alignas(16) Float4 { float vals[4]; };</span></pre> <p><span class="koboSpan" id="kobo.810.1">In this example, if we</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.811.1"> remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">alignas(16)</span></strong><span class="koboSpan" id="kobo.813.1"> from the type declaration, the natural alignment of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">Float4</span></strong><span class="koboSpan" id="kobo.815.1"> would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">alignof(float)</span></strong><span class="koboSpan" id="kobo.817.1">, which is probably 4 on </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">most platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.819.1">The problem with such types before C++17 is that variables generated by the compiler would respect our alignment requirements, but those located in dynamically allocated storage would, by default, end up with an alignment of </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.821.1">, which would be incorrect. </span><span class="koboSpan" id="kobo.821.2">That makes sense, of course; functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">malloc()</span></strong><span class="koboSpan" id="kobo.823.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">operator new()</span></strong><span class="koboSpan" id="kobo.825.1"> will, by default, cover the “worst-case scenario” of the platform, not knowing what will be constructed in the allocated storage, but they cannot be assumed to implicitly cover even worse scenarios </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">than this.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">Since C++17, we</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.828.1"> can specify </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">overaligned type requirements</span></strong><span class="koboSpan" id="kobo.830.1"> when calling either </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">operator new()</span></strong><span class="koboSpan" id="kobo.832.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.834.1"> by passing an additional argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">std::align_val_t</span></strong><span class="koboSpan" id="kobo.836.1">, an integral type. </span><span class="koboSpan" id="kobo.836.2">This has to be done explicitly at the call site, as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">example shows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.838.1">
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;cstdlib&gt;
#include &lt;type_traits&gt;
void* </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">operator new(std::size_t n, std::align_val_t al)</span></strong><span class="koboSpan" id="kobo.840.1"> {
   std::cout &lt;&lt; "new(" &lt;&lt; n &lt;&lt; ", align: "
             &lt;&lt; static_cast&lt;std::underlying_type_t&lt;
                   std::align_val_t
                &gt;&gt;(al) &lt;&lt; ")\n";
   </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">return std::aligned_alloc(</span></strong><span class="koboSpan" id="kobo.842.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.843.1">static_cast&lt;std::size_t&gt;(al), n</span></strong><span class="koboSpan" id="kobo.844.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">);</span></strong><span class="koboSpan" id="kobo.846.1">
}
// (others omitted for brevity)
struct alignas(16) Float4 { float vals[4]; };
int main() {
   </span><strong class="bold"><span class="koboSpan" id="kobo.847.1">auto p = new Float4; // calls operator new(size_t)</span></strong><span class="koboSpan" id="kobo.848.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.849.1">// calls operator new(size_t, align_val_t)</span></strong><span class="koboSpan" id="kobo.850.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">auto q = new(std::align_val_t{ 16 }) Float4;</span></strong><span class="koboSpan" id="kobo.852.1">
   // leaks, of course, but that's beside the point
}</span></pre> <p><span class="koboSpan" id="kobo.853.1">The memory block allocated for </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">p</span></strong><span class="koboSpan" id="kobo.855.1"> in this example will be aligned on a boundary of </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.857.1">, whereas the memory block allocated for </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">q</span></strong><span class="koboSpan" id="kobo.859.1"> will be aligned on a 16-byte boundary. </span><span class="koboSpan" id="kobo.859.2">The former </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.860.1">might satisfy the requirements of our type if we’re lucky and cause chaos otherwise; the latter will respect our constraints if the allocation operator overload is </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">implemented correctly.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.862.1">Destroying delete</span></h2>
<p><span class="koboSpan" id="kobo.863.1">C++20 brings a novel </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.864.1">and highly specialized feature called destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">delete</span></strong><span class="koboSpan" id="kobo.866.1">. </span><span class="koboSpan" id="kobo.866.2">The use case targeted here is a </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.867.1">member function overload that benefits from specific knowledge of the type of object being destroyed in order to better perform the destruction process. </span><span class="koboSpan" id="kobo.867.2">When that member function is defined for some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">T</span></strong><span class="koboSpan" id="kobo.869.1">, it is preferred over other options when </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">delete</span></strong><span class="koboSpan" id="kobo.871.1"> is invoked on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">T*</span></strong><span class="koboSpan" id="kobo.873.1">, even if </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">T</span></strong><span class="koboSpan" id="kobo.875.1"> exposes another overload of </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">operator delete()</span></strong><span class="koboSpan" id="kobo.877.1">. </span><span class="koboSpan" id="kobo.877.2">To use destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">delete</span></strong><span class="koboSpan" id="kobo.879.1"> for some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">X</span></strong><span class="koboSpan" id="kobo.881.1">, one must implement the following </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.883.1">
class X {
   // ...
</span><span class="koboSpan" id="kobo.883.2">public:
   </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">void operator delete(X*, std::destroying_delete_t);</span></strong><span class="koboSpan" id="kobo.885.1">
   // ...
</span><span class="koboSpan" id="kobo.885.2">};</span></pre> <p><span class="koboSpan" id="kobo.886.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">std::destroying_delete_t</span></strong><span class="koboSpan" id="kobo.888.1"> is a tag type like </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">std::nothrow_t</span></strong><span class="koboSpan" id="kobo.890.1">, which we saw earlier in this chapter. </span><span class="koboSpan" id="kobo.890.2">Note that the first argument of the destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">delete</span></strong><span class="koboSpan" id="kobo.892.1"> for class </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">X</span></strong><span class="koboSpan" id="kobo.894.1"> is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">X*</span></strong><span class="koboSpan" id="kobo.896.1">, not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">void*</span></strong><span class="koboSpan" id="kobo.898.1">, as the destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">delete</span></strong><span class="koboSpan" id="kobo.900.1"> has the double role of destroying the object and deallocating memory… hence </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">its name!</span></span></p>
<p><span class="koboSpan" id="kobo.902.1">How does that work, and why is that useful? </span><span class="koboSpan" id="kobo.902.2">Let’s look at a concrete example with the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">Wrapper</span></strong><span class="koboSpan" id="kobo.904.1"> class. </span><span class="koboSpan" id="kobo.904.2">In this example, an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">Wrapper</span></strong><span class="koboSpan" id="kobo.906.1"> hides one of two implementations, modeled by </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">Wrapper::ImplA</span></strong><span class="koboSpan" id="kobo.908.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">Wrapper::ImplB</span></strong><span class="koboSpan" id="kobo.910.1">. </span><span class="koboSpan" id="kobo.910.2">The implementation is selected at construction time based on an enumerated value of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">Wrapper::Kind</span></strong><span class="koboSpan" id="kobo.912.1">. </span><span class="koboSpan" id="kobo.912.2">The intent is to</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.913.1"> remove the need for </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">virtual</span></strong><span class="koboSpan" id="kobo.915.1"> functions from this class, replacing them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">if</span></strong><span class="koboSpan" id="kobo.917.1"> statements based on the kind of implementation that was chosen. </span><span class="koboSpan" id="kobo.917.2">Of course, in this (admittedly) small example, there’s still only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">virtual</span></strong><span class="koboSpan" id="kobo.919.1"> function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">Impl::f()</span></strong><span class="koboSpan" id="kobo.921.1">) as we aim to minimize the example’s complexity. </span><span class="koboSpan" id="kobo.921.2">There is also a wish to keep the destructor of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">Wrapper</span></strong><span class="koboSpan" id="kobo.923.1"> trivial, a property that can be useful </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">on occasion.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">We will look at this example step by step as it is a bit more elaborate than the previous ones. </span><span class="koboSpan" id="kobo.925.2">First, let’s examine the basic structure of </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">Wrapper</span></strong><span class="koboSpan" id="kobo.927.1"> including </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">Wrapper::Kind</span></strong><span class="koboSpan" id="kobo.929.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">Wrapper::Impl</span></strong><span class="koboSpan" id="kobo.931.1">, and its </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">derived classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.933.1">
#include &lt;new&gt;
#include &lt;iostream&gt;
class Wrapper {
public:
   enum class Kind { A, B };
private:
   struct Impl {
      virtual int f() const = 0;
   };
   struct ImplA final : Impl {
      int f() const override { return 3; }
      ~ImplA() { std::cout &lt;&lt; "Kind A\n"; }
   };
   struct ImplB final : Impl {
      int f() const override { return 4; }
      ~ImplB() { std::cout &lt;&lt; "Kind B\n"; }
   };
   Impl *p;
   Kind kind;
   // ...</span></pre> <p><span class="koboSpan" id="kobo.934.1">Visibly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">Wrapper::Impl</span></strong><span class="koboSpan" id="kobo.936.1"> does not </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.937.1">have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">virtual</span></strong><span class="koboSpan" id="kobo.939.1"> destructor, yet </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">Wrapper</span></strong><span class="koboSpan" id="kobo.941.1"> keeps as a data member an </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">Impl*</span></strong><span class="koboSpan" id="kobo.943.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">p</span></strong><span class="koboSpan" id="kobo.945.1">, which means that simply calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">delete p</span></strong><span class="koboSpan" id="kobo.947.1"> might not call the appropriate destructor for the </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">pointed-to object.</span></span></p>
<p><span class="koboSpan" id="kobo.949.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">Wrapper</span></strong><span class="koboSpan" id="kobo.951.1"> class exposes a </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.952.1">constructor that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">Kind</span></strong><span class="koboSpan" id="kobo.954.1"> as argument, then calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">Wrapper::create()</span></strong><span class="koboSpan" id="kobo.956.1"> to construct the appropriate implementation, modeled by a type derived </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">Impl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.960.1">
   // ...
</span><span class="koboSpan" id="kobo.960.2">   static Impl *create(Kind kind) {
      switch(kind) {
      using enum Kind;
      case A: return new ImplA;
      case B: return new ImplB;
      }
      throw 0;
   }
public:
   Wrapper(Kind kind)
      : p{ create(kind) }, kind{ kind } {
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.961.1">Now comes the destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">delete</span></strong><span class="koboSpan" id="kobo.963.1">. </span><span class="koboSpan" id="kobo.963.2">Since we know by construction that the only possible implementations would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">ImplA</span></strong><span class="koboSpan" id="kobo.965.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">ImplB</span></strong><span class="koboSpan" id="kobo.967.1">, we test </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">p-&gt;kind</span></strong><span class="koboSpan" id="kobo.969.1"> to know which one was chosen for </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">p</span></strong><span class="koboSpan" id="kobo.971.1">, then</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.972.1"> directly call the appropriate destructor. </span><span class="koboSpan" id="kobo.972.2">Once that is done, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">Wrapper</span></strong><span class="koboSpan" id="kobo.974.1"> object itself is finalized and memory is freed through a direct call to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">operator delete()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.977.1">
   // ...
</span><span class="koboSpan" id="kobo.977.2">   </span><strong class="bold"><span class="koboSpan" id="kobo.978.1">void operator delete(Wrapper *p,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.979.1">                        std::destroying_delete_t) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.980.1">      if(p-&gt;kind == Kind::A) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.981.1">         delete static_cast&lt;ImplA*&gt;(p-&gt;p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.982.1">      } else {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.983.1">         delete static_cast&lt;ImplB*&gt;(p-&gt;p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.984.1">      }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.985.1">      p-&gt;~Wrapper();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.986.1">      ::operator delete(p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.987.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.988.1">}</span></strong><span class="koboSpan" id="kobo.989.1">
   int f() const { return p-&gt;f(); }
};</span></pre> <p><span class="koboSpan" id="kobo.990.1">For client code, the fact that we decided to use a destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">delete</span></strong><span class="koboSpan" id="kobo.992.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">completely transparent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.994.1">
int main() {
   using namespace std;
   auto p = new Wrapper{ Wrapper::Kind::A };
   cout &lt;&lt; p-&gt;f() &lt;&lt; endl;
   delete p;
   p = new Wrapper{ Wrapper::Kind::B };
   cout &lt;&lt; p-&gt;f() &lt;&lt; endl;
   delete p;
}</span></pre> <p><span class="koboSpan" id="kobo.995.1">The destroying </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">delete</span></strong><span class="koboSpan" id="kobo.997.1"> is a recent C++ facility as of this writing, but it is a tool that can let us get more control over the destruction process of our objects. </span><span class="koboSpan" id="kobo.997.2">Most of your types probably do not need</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.998.1"> this feature, but it’s good to know it exists for those cases where you need that extra bit of control over execution speed and program size. </span><span class="koboSpan" id="kobo.998.2">As always, measure the results of your efforts to ensure that they bring the </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">desired benefits.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1000.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1001.1">Whew, that was quite the ride! </span><span class="koboSpan" id="kobo.1001.2">Now that we have the basics of memory allocation operator overloading handy, we will start to use them to our advantage. </span><span class="koboSpan" id="kobo.1001.3">Our first application will be a leak detector (</span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1002.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1003.1">) using the global forms of these operators, followed by simplified examples of exotic memory management (</span><a href="B21071_09.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1004.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.1005.1">) using specialized, custom forms of the global operators, and arena-based memory management (</span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1006.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.1007.1">) with member versions of the operators that will perform very </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">satisfying optimizations.</span></span></p>
</div>
</body></html>