<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor116"/>7</h1>
<h1 id="_idParaDest-115"><a id="_idTextAnchor117"/>Overloading Memory Allocation Operators</h1>
<p>Enjoying yourself so far? I hope you are! We are at the point where we hold all the keys and can start to do what this book advertises and look in more detail at how memory management works in C++. It’s not a simple topic, nor is it something trivial, so we needed to make sure we were ready… but we are now, so let’s do it!</p>
<p><a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a> and <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a> examined the standard tools one can use to ensconce responsibility over dynamically allocated resources into the C++ type system through smart pointers, the ones provided by the standard as well as those we could write to fill other niches. Using smart pointers instead of raw pointers as data members and function return types tends to simplify (and clarify) a significant proportion of memory management tasks in C++ programs.</p>
<p>Sometimes, we want to work at a lower level than this and take control over what happens when someone writes <code>new X</code>. The reasons for wanting such control are numerous, and we will explore a few in this book, but in this chapter, we will focus on the basics of memory management functions and how to take control of these mechanisms in C++.</p>
<p>After these basics are covered, we will do the following:</p>
<ul>
<li>See how our knowledge of the memory allocation mechanisms of C++ lets us write a simple (yet working) leak detector in <a href="B21071_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a></li>
<li>Examine how one can manage atypical (persistent, shared, and so on) memory in C++ in <a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a></li>
<li>Write arena-based memory allocation in <a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a> to ensure deterministic time allocation and deallocation, leading to blazingly fast implementations of <code>new</code> and <code>delete</code> when context allows it</li>
</ul>
<p>Later chapters will use the knowledge acquired in this chapter and the ones that follow to write efficient containers and deferred reclamation mechanisms that resemble a garbage collector. Past that point, we will examine how containers can use these facilities, with and without allocators.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Why would one overload allocation functions?</h1>
<p>Before we start discussing how to overload memory allocation mechanisms, let’s take a step back and examine why one would want to do this. Indeed, most programmers (even experienced ones) never end up doing anything of the sort, and we could wager that a majority of programmers never thought they had a reason to do so. Yet, we will allocate (!) a few chapters to that very topic. There has to be a reason…</p>
<p>The thing about memory allocation is that there’s no perfect solution to the problem in general; there are many <a id="_idIndexMarker371"/>good solutions on average, and there are very good solutions to more specialized versions of the problem. What constitutes a good solution for a given use case in programming language A might be inappropriate for another use case or in programming language B.</p>
<p>Take, for example, languages where is it idiomatic to allocate dynamically large numbers of small objects, something customary of Java or C#. In such a language, one could expect the allocation strategies to be optimized for that usage pattern. In a language such as C, where one would tend to allocate when faced with objects too large to put on the stack or when using node-based data structures for example, the best dynamic memory allocation strategy could be quite different. In <a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>, we will see an example where the allocation process benefits from the fact that the allocated objects are all of the same size and alignment, another interesting use case.</p>
<p>C++ emphasizes control and provides sophisticated and versatile tools to programmers. When facing a situation where we know the context in which allocations will be performed, we can sometimes use these tools to do better (even <em class="italic">much</em> better, as we will see in <a href="B21071_11.xhtml#_idTextAnchor163"><em class="italic">Chapter 11</em></a>!) than a default implementation would, and for numerous metrics: better execution time, more deterministic execution time, reduced memory fragmentation, and so on.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Brief overview of the C language allocation functions</h1>
<p>Before we get to the memory <a id="_idIndexMarker372"/>allocation mechanisms of C++, let’s first take a brief look at the C family of memory allocation functions through its most distinguished representatives: <code>malloc()</code> and <code>free()</code>. There are, of course, many other memory-allocation-related functions such as <code>calloc()</code>, <code>realloc()</code>, and <code>aligned_alloc()</code>, not counting operating-system-specific services that perform similar tasks for specialized use cases, but these will serve our discussion well.</p>
<p>Note that since this is a book on memory management with C++, I will use the C++ version of these functions (from <code>&lt;cstdlib&gt;</code> instead of <code>&lt;stdlib.h&gt;</code>), which really changes nothing to the code we will write except for the fact that in C++, these functions are located in the <code>std</code> namespace.</p>
<p>The signatures for these two functions are as follows:</p>
<pre class="source-code">
void* malloc(size_t n);
void free(void *p);</pre> <p>The role of <code>malloc(n)</code> is to find a location where there are at least <code>n</code> consecutive bytes available, potentially marking that location as “taken” and returning an abstract pointer (a <code>void*</code>) to the beginning of that block of memory. Note that the pointer returned has to be aligned for the worst possible natural case in a given machine, which means that it has to suit the alignment requirements of <code>std::max_align_t</code>. On most machines, this type is an alias for <code>double</code>.</p>
<p>Interestingly, it is legal to call <code>malloc()</code> with <code>n==0</code>, but the results of such a call are implementation-defined: a call to <code>malloc(0)</code> could return <code>nullptr</code> but it could also return a non-null pointer. Note that the pointer returned by <code>malloc(0)</code> should not be dereferenced, regardless of whether it is null or not.</p>
<p>If <code>malloc()</code> fails to allocate memory, it returns <code>nullptr</code> since the C language does not support exceptions in the C++ sense. In contemporary C (since C11), a <code>malloc()</code> implementation has to be thread-safe and has to synchronize appropriately with other C allocation functions if they are called concurrently, including with <code>free()</code>.</p>
<p>The role of <code>free(p)</code> is to ensure that the memory pointed to by <code>p</code> becomes available for further allocation requests, as long as <code>p</code> points to a block that has been allocated through a memory allocation function such as <code>malloc()</code> and has not yet been freed. It is <code>free()</code> an address that has not been allocated through such an allocation function… Don’t do that! Also, know<a id="_idIndexMarker373"/> that once the memory has been freed, it is no longer considered allocated, so code such as the following leads to UB:</p>
<pre class="source-code">
#include &lt;cstdlib&gt;
int main() {
   using std::malloc, std::free;
   int *p = static_cast&lt;int*&gt;(malloc(sizeof(int)));
   free(p); // fine since it comes from malloc()
   free(p); // NOOOOOO unless (stroke of luck?) p is null
}</pre> <p>As mentioned in the preceding example, <code>free(nullptr)</code> does nothing, and has been defined as doing nothing for decades as of this <a id="_idIndexMarker374"/>writing. If there is code in your code base that verifies <code>p!=nullptr</code> before calling <code>free()</code> – for example, <code>if(p) free(p)</code> – you can safely get rid of that test.</p>
<p>We will sometimes (not always) use these C functions to implement our homemade C++ allocation functions. They work, they are well understood, and they are low-level abstractions we can use to our advantage when building higher-level ones.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>Overview of the C++ allocation operators</h1>
<p>In C++, there are many (infinitely many!) flavors <a id="_idIndexMarker375"/>of memory allocation operators, but there are rules to follow when writing your own. The current chapter is mostly about those rules; the chapters that follow will explore ways to benefit from this freedom C++ gives us:</p>
<ul>
<li>C++ lets us overload the <code>new int</code> will use our homemade versions. One has to be careful here since small mistakes can have a significant impact on code execution: if your implementation of <code>operator new()</code> is slow, you will slow down most memory allocations in your program! We will use this approach when writing a simple-yet-working leak detector in <a href="B21071_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>.</li>
<li>C++ lets us overload <strong class="bold">member function versions</strong> of the memory allocation operators. If we do, then <a id="_idIndexMarker377"/>the global versions (overloaded or not) apply in general, but the member function versions apply for specific types. This can be useful when we have knowledge specific to the usage pattern of some types but not to others. We will use that to our advantage in <a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>.</li>
<li>C++ lets us overload <code>nothrow</code> version and the (extremely important) <strong class="bold">placement new</strong>-related <a id="_idIndexMarker378"/>versions. We can also use this feature to benefit from “exotic” memory such as shared memory or persistent memory, as we will see in <a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>.</li>
</ul>
<p>In each case, memory allocation functions come in groups of four: <code>operator new()</code>, <code>operator new[]()</code>, <code>operator delete()</code>, and <code>operator delete[]()</code>. There are some exceptions to this rule, as we will see, but the rule generally holds. If we overload at least one of these functions, it’s <a id="_idIndexMarker379"/>important that we overload all four to keep the behavior of our program consistent. When playing with low-level facilities like this, mistakes tend to bite harder than they would otherwise, which explains why we took so much care in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a> and <a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a> explaining ways we could get in trouble… and how to play by the rules at the same time.</p>
<p>Memory allocation interacts closely with the object model (see <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> for the basics) and with exception safety (a topic that’s pervasive throughout this book), so make sure to grasp these interactions in the pages and chapters that follow. They will help you make the best of what you will read here.</p>
<p class="callout-heading">A word on Heap Allocation Optimization (HALO)</p>
<p class="callout">It’s important to know that there are benefits to <em class="italic">not</em> overloading memory allocation operators. One of them is that your <a id="_idIndexMarker380"/>library vendor provides very good ones by default; another is that if you do not overload the memory allocation operators, the compiler can assume that the number of allocations you make is not observable. This means that it is allowed to replace <em class="italic">n</em> calls to <code>new</code> with a single call that allocates everything at once, and then manages the results as if you had performed many allocations. That can lead to some spectacular optimizations in practice, including the removal of calls to <code>new</code> and <code>delete</code> altogether from the generated code even when they <a id="_idIndexMarker381"/>appear in the source code! If in doubt, please make sure that your optimizations provide measurable benefits before committing them and using them in production code.</p>
<p>Note that for the allocation operator overloads we will see in this chapter, you will want to include the <code>&lt;new&gt;</code> header as<a id="_idIndexMarker382"/> this is where <code>std::bad_alloc</code> is declared, among other things, and this is the type that allocation functions typically use to report failure to allocate.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>Global allocation operators</h2>
<p>Suppose we want to take control of the global versions of the allocation operators in C++. For the sake of exposing how this can <a id="_idIndexMarker383"/>work, we will simply use them to delegate to <code>malloc()</code> and <code>free()</code> for now, and show a more elaborate example in <a href="B21071_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>.</p>
<p>If we stick to the basic forms <a id="_idIndexMarker384"/>of these operators, we will want to overload… well, four functions before C++11 or six functions since then. Of course, this book supposes that we’re over a decade past C++14, so we will proceed accordingly.</p>
<p>The signatures we want to overload are the following:</p>
<pre class="source-code">
void *operator new(std::size_t);
void *operator new[](std::size_t);
void operator delete(void *) noexcept;
void operator delete[](void *) noexcept;
// since C++14
void operator delete(void *, std::size_t) noexcept;
void operator delete[](void *, std::size_t) noexcept;</pre> <p>That’s a lot, I agree, but taking control of memory management facilities is specialized work. As soon as you write one of these functions, you officially replace the ones provided by your standard library for that program and that function becomes responsible for the allocation (or deallocation) requests that come through that channel. Replacing an allocation function requires you to use the exact same signature as the original.</p>
<p>The reason why it is important that<a id="_idIndexMarker385"/> you overload the whole set of functions if you overload at least one of them is that these functions form a consistent whole. For example, if you change the way <code>new</code> behaves but neglect to <a id="_idIndexMarker386"/>change the way the standard library-provided <code>delete</code> performs its task, it’s essentially impossible to predict how much damage your program will incur. As a well-known popular comic book hero stated many times, <em class="italic">“with great power comes great responsibility.”</em> Be careful, be rigorous, and follow the rules.</p>
<p>Pay attention to the signatures of these functions as they provide interesting information…</p>
<h3>On operators new and new[]</h3>
<p>Functions <code>operator new()</code> and <code>operator new[]()</code> both take a single <code>std::size_t</code> object as an argument and both return <code>void*</code>. The argument is, in both cases, the minimal number of<a id="_idIndexMarker387"/> contiguous bytes to allocate. As such, their signatures resemble that of <code>std::malloc()</code>. That often surprises people; how can the <code>new X</code> expression create an <code>X</code> object if <code>new</code> is not a <code>template</code> and does not know what to create?</p>
<p>That’s the thing: <code>new</code> does <em class="italic">not</em> create <a id="_idIndexMarker388"/>objects. What <code>new</code> does is find the location where an object will be constructed. It’s the constructor that turns the raw memory found by <code>new</code> into an object. In practice, you could write something such as the following:</p>
<pre class="source-code">
X *p = new X{ /* ... args ... */ };</pre> <p>What you have written is a two-step operation:</p>
<pre class="source-code">
// allocate enough space to put an X object
void * buf = operator new(sizeof(X));
// construct an X object at that location
X *p = ... // apply X::X( /* ... args ... */ ) on buf</pre> <p>This means the constructor is like a coat of paint applied to a block of memory, turning that memory into an object. This also means that an expression such as <code>new X</code> can fail either on <code>operator new()</code>, if the allocation <a id="_idIndexMarker389"/>request could not succeed, or on <code>X::X()</code>, because the constructor failed<a id="_idIndexMarker390"/> somehow. Only if both steps succeed does client code become responsible for the pointed-to object.</p>
<p class="callout-heading">A note on calling these operators</p>
<p class="callout">You might have noticed in the preceding example that we sometimes write <code>new X</code> and we sometimes write <code>operator new(sizeof(X))</code>. The first form – the <em class="italic">operator form</em> – will do the two-step process of allocation followed by construction, whereas the second form – the <em class="italic">function form</em> – directly calls the allocation function without invoking a constructor. This distinction also applies to <code>operator delete()</code>.</p>
<p>The situation is similar with <code>operator new[]</code>: the number of bytes passed as argument to the function is the total number of bytes for the array, so the allocation function itself knows neither the type of object that will be created nor the number of elements or the individual size of the objects. A call to <code>new X[N]</code> will, in practice, call <code>operator new[](N*sizeof(X))</code> to find a place to put the array that will be constructed, then call <code>X::X()</code> on each of the <code>N</code> blocks of size <code>sizeof(X)</code> in that array. Only when the entire sequence completes successfully does client code become responsible for the resulting array.</p>
<p>Failure to allocate a scalar through <code>operator new</code> should result in something that matches <code>std::bad_alloc</code> being thrown. With <code>operator new[]()</code>, one can also throw <code>std::bad_array_new_length</code> (derived from <code>std::bad_alloc</code>) if the requested size is problematic, typically because it exceeds implementation-defined limits.</p>
<h3>On operators delete and delete[]</h3>
<p>Like the C language’s <code>free()</code> function, operators <code>delete()</code> and <code>delete[]()</code> both take a <code>void*</code> as argument. This <a id="_idIndexMarker391"/>means that they cannot <a id="_idIndexMarker392"/>destroy your object… When they are called, the object has already been destroyed! Indeed, you could write the following:</p>
<pre class="source-code">
delete p; // suppose that p is of type X*</pre> <p>This is, in practice, a two-step operation that is equivalent to the following:</p>
<pre class="source-code">
p-&gt;~X(); // destroy the pointed-to object
operator delete(p); // free the associated memory</pre> <p>In C++, neither your destructors <a id="_idIndexMarker393"/>nor <code>operator delete()</code> should throw exceptions. If they do, the program is pretty much terminated, for reasons that will become self-evident in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>.</p>
<p>The size-aware versions of <code>operator delete()</code> and <code>operator delete[]()</code> have been introduced with C++14 and it is customary to implement them today, in addition to the classical versions of these functions. The idea is that <code>operator new()</code> was informed of <a id="_idIndexMarker394"/>the size of the blocks to allocate but <code>operator delete()</code> was not, which required unneeded acrobatics on the part of implementations that sought to do size-related tasks, such as filling the block of memory with some value in order to try to obscure what was stored at that location. Contemporary implementations of these functions require us to write a version that accepts the size of the pointed-to objects in addition to the classical version; if one’s implementation does not need that size, one can simply call the classical version from the size-aware one and be done with it.</p>
<p class="callout-heading">A note on sized operator delete[]() overloads</p>
<p class="callout">If you trace the execution of your overloads, you might be surprised to see that the sized version of <code>operator delete[]()</code> is not necessarily called for some types. Indeed, if you have an array <code>arr</code> of <a id="_idIndexMarker395"/>objects of trivially destructible types, the standard leaves it unspecified as to which one of the sized and the unsized versions of <code>operator delete[]()</code> will be used when you write <code>delete [] arr</code>. It’s not a bug, rest assured.</p>
<p>A full, yet naïve implementation of these functions that essentially delegate work to the C allocation functions could be as follows:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;
void *operator new(std::size_t n) {
    std::cout &lt;&lt; "operator new(" &lt;&lt; n &lt;&lt; ")\n";
    auto p = std::malloc(n);
    if(!p) throw std::bad_alloc{};
    return p;
}
void operator delete(void *p) noexcept {
    std::cout &lt;&lt; "operator delete(...)\n";
    std::free(p);
}
void operator delete(void *p, std::size_t n) noexcept {
    std::cout &lt;&lt; "operator delete(..., " &lt;&lt; n &lt;&lt; ")\n";
    ::operator delete(p);
}
void *operator new[](std::size_t n) {
    std::cout &lt;&lt; "operator new[](" &lt;&lt; n &lt;&lt; ")\n";
    auto p = std::malloc(n);
    if(!p) throw std::bad_alloc{};
    return p;
}
void operator delete[](void *p) noexcept {
    std::cout &lt;&lt; "operator delete[](...)\n";
    std::free(p);
}
void operator delete[](void *p, std::size_t n) noexcept {
    std::cout &lt;&lt; "operator delete[](..., " &lt;&lt; n &lt;&lt; ")\n";
    ::operator delete[](p);
}
int main() {
   auto p = new int{ 3 };
   delete p;
   p = new int[10];
   delete []p;
}</pre> <p>As is probably clear by now, the default behavior when <code>operator new()</code> and <code>operator new[]()</code> fail to<a id="_idIndexMarker396"/> achieve their postconditions and actually allocate the requested amount of memory is to throw <code>std::bad_alloc</code> or, when appropriate, <code>std::bad_array_new_length</code>. Since allocation is followed by construction, client code might also face any exception thrown by the constructor. We will look at ways to handle these situations when writing custom containers in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>.</p>
<p>There are application domains<a id="_idIndexMarker397"/> where exceptions are not an option. This can be due to memory constraints; most exception handlers make programs slightly bigger, which can be unacceptable in domains such as embedded systems. It can also be due to speed constraints; the code in <code>try</code> blocks is usually fast as these blocks represent the “normal” execution paths, but code in <code>catch</code> blocks is usually seen as the rare (“exceptional”) path and can be significantly slower to execute. Of course, some will simply avoid exception usage for philosophical reasons, which is fine too.</p>
<p>Luckily, there is a way to perform dynamic memory allocation without resorting to exceptions to signal failure.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Non-throwing versions of the allocation operators</h2>
<p>There are also versions of the allocation operators that do not throw upon failure to allocate. The signatures for these <a id="_idIndexMarker398"/>functions are as follows:</p>
<pre class="source-code">
void *operator new(std::size_t, <strong class="bold">const std::nothrow_t&amp;);</strong>
void *operator new[](std::size_t, <strong class="bold">const std::nothrow_t&amp;);</strong>
void operator delete(void *, <strong class="bold">const std::nothrow_t&amp;)</strong>
   noexcept;
void operator delete[](void *, <strong class="bold">const std::nothrow_t&amp;)</strong>
   noexcept;
// since C++14
void operator delete
   (void *, std::size_t, <strong class="bold">const std::nothrow_t&amp;)</strong> noexcept;
void operator delete[]
   (void *, std::size_t, <code>nullptr</code> than to just write it as if no failure occurred! The fact is that there are costs to using exceptions in one’s programs: it can make binaries slightly bigger, and it can slow down code execution, particularly when exceptions are caught (there are also issues of style involved; some people would not use exceptions even if they led to faster code, and that’s just part of life). For that reason, application domains <a id="_idIndexMarker399"/>such as games or embedded systems often shun exceptions and go to some lengths to write code that does not depend on them. The non-throwing versions of the allocation functions target these domains.</p>
<p>Type <code>std::nothrow_t</code> is what is called a <code>std::nothrow</code> object) can be <a id="_idIndexMarker400"/>used to guide the compiler when generating code. Note that these function signatures require the <code>std::nothrow_t</code> arguments to be passed by <code>const</code> reference, not by value, so make sure you respect this signature if you seek to replace them.</p>
<p>An example usage of these functions would be as follows:</p>
<pre class="source-code">
X *p = new <strong class="bold">(nothrow)</strong> X{ /* ... args ... */ };
if(p) {
   // ... use *p
   // note: this is not the nothrow version of delete
   delete p; // would be Ok even if !p
}</pre> <p>You might be surprised about the position of <code>nothrow</code> in the <code>new</code> expression, but if you think about it, it’s essentially the only syntactic space for additional arguments passed to <code>operator new()</code>; the first argument passed to the function is the number of contiguous bytes to allocate (here: <code>sizeof(X)</code>), and in expression <code>new X { ...args... }</code>, what follows the type of object to construct is the list of arguments passed to its constructor. Thus, the place to specify the additional arguments to <code>operator new()</code> itself is <a id="_idIndexMarker401"/>between <code>new</code> and the type of the object to construct, between parentheses.</p>
<p class="callout-heading">A word on the position of additional arguments to operator new()</p>
<p class="callout">To illustrate this better with an<a id="_idIndexMarker402"/> artificially crafted example, one could write the following <code>operator </code><code>new()</code> overload:</p>
<p class="callout"><code>void* operator new(std::size_t, </code><code>);</code></p>
<p class="callout">Then, a possible call to that hypothetical operator would be as follows:</p>
<p class="callout"><code>X *p = new (3, 1.5) X{ /* ... */ };</code></p>
<p class="callout">Here, we can see how two additional arguments, an <code>int</code> argument and a <code>double</code> argument, are passed by client code.</p>
<p>Returning to the <code>nothrow</code> version of <code>operator new()</code> and <code>operator new[]()</code>, one thing that is subtle and needs to be understood is why one needs to write overloads of <code>operator delete()</code> and <code>operator delete[]()</code>. After all, even with client code that uses the <code>nothrow</code> version of <code>new</code>, as was the case in our example, it’s highly probable that the “normal” version of <code>operator delete()</code> will be used to end the life of that object. Why, then, write a <code>nothrow</code> version of <code>operator delete()</code>?</p>
<p>The reason is <code>operator new()</code>? Well, remember that memory allocation through <code>operator new()</code> is a two-step operation: find the location to place the object, then construct the object at that location. Thus, even if <code>operator new()</code> does not throw, we do not know whether the constructor that will be called will throw. Our code will obtain the pointer only after both the allocation <em class="italic">and</em> the construction that follows have successfully completed execution; as such, client code cannot manage exceptions that occur after allocation succeeded but during the construction of the object, at least not in such a way as to deallocate the memory… It’s difficult to deallocate a pointer your code has not yet seen!</p>
<p>For that reason, it falls on the C++ runtime to perform the deallocation if an exception is thrown by the constructor, and<a id="_idIndexMarker404"/> this is true for all versions of <code>operator new()</code>, not just the <code>nothrow</code> ones. The algorithm (informally) is as follows:</p>
<pre class="source-code">
// step 1, try to perform the allocation for some T object
p = operator new(n, ... maybe additional arguments ...)
// the following line is only for a nothrow new
if(!p) return p
try {
   // step 2, construct the object at address p
   apply the constructor of T at address p // might throw
} catch(...) { // construction threw an exception
   <strong class="bold">deallocate p // this is what concerns us here</strong>
   re-throw the exception, whatever it was
}
return p // p points to a fully constructed object
         // only after this point does client code see p</pre> <p>As this algorithm shows, the C++ runtime has to deallocate the memory for us when the constructor throws an exception. But how does it do so? Well, it will use the <code>operator delete()</code> (or <code>operator delete[]()</code>) whose signature matches that of the version of <code>new</code> or <code>new[]</code> that was used to perform the allocation. For example, if we use <code>operator new(size_t,</code><code>)</code> to allocate and the constructor fails, it will use <code>operator delete(void*,</code><code>)</code> to perform the implicit deallocation.</p>
<p>That is the reason why, if we overload the <code>nothrow</code> versions of <code>new</code> and <code>new[]</code>, we have to overload the <code>nothrow</code> versions of <code>delete</code> and <code>delete[]</code> (they will be used for deallocation if a constructor throws), and why we also have to overload the “normal” throwing versions of <code>new</code>, <code>new[]</code>, <code>delete</code>, and <code>delete[]</code>. Expressed informally, code that uses <code>X *p = new(nothrow)X;</code> will usually call <code>delete p;</code> to end the life of the pointee, and as such, the <code>nothrow</code> and throwing versions of the allocation functions have to<a id="_idIndexMarker405"/> be coherent with one another.</p>
<p>Here is a full, yet naïve implementation where the throwing versions delegate to the non-throwing ones to reduce repetition:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;
void* operator new(std::size_t n, const std::nothrow_t&amp;) noexcept {
   return std::malloc(n);
}
void* operator new(std::size_t n) {
   auto p = operator new(n, std::nothrow);
   if (!p) throw std::bad_alloc{};
   return p;
}
void operator delete(void* p, const std::nothrow_t&amp;)
   noexcept {
      std::free(p);
   }
void operator delete(void* p) noexcept {
   operator delete(p, std::nothrow);
}
void operator delete(void* p, std::size_t) noexcept {
   operator delete (p, std::nothrow);
}
void* operator new[](std::size_t n,
                     const std::nothrow_t&amp;) noexcept {
   return std::malloc(n);
}
void* operator new[](std::size_t n) {
   auto p = operator new[](n, std::nothrow);
   if (!p) throw std::bad_alloc{};
   return p;
}
void operator delete[](void* p, const std::nothrow_t&amp;)
   noexcept {
   std::free(p);
}
void operator delete[](void* p) noexcept {
   operator delete[](p, std::nothrow);
}
void operator delete[](void* p, std::size_t) noexcept {
   operator delete[](p, std::nothrow);
}
int main() {
   using std::nothrow;
   auto p = new (nothrow) int{ 3 };
   delete p;
   p = new (nothrow) int[10];
   delete[]p;
}</pre> <p>As you can see, there are quite a few functions to write to get a full, cohesive set of allocation operators if we want to<a id="_idIndexMarker406"/> cover both the throwing and the non-throwing versions of this mechanism.</p>
<p>We still have a lot to cover. For example, we mentioned a few times already the idea of placing an object at a specific memory location, in particular at the second of the two-step process modeled by calls to <code>new</code>. Let’s see how this is done.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>The most important operator new: placement new</h2>
<p>The most<a id="_idIndexMarker407"/> important version of <code>operator new()</code> and friends is not one you can replace, but <a id="_idIndexMarker408"/>even if you could… well, let’s just state that it would be difficult to achieve something more efficient:</p>
<pre class="source-code">
// note: these exist, you can use them but you cannot
// replace them
void *operator new(std::size_t, <strong class="bold">void *p</strong>) { <strong class="bold">return p;</strong> }
void *operator new[](std::size_t, <strong class="bold">void *p</strong>) { <strong class="bold">return p;</strong> }
void operator delete(void*, <strong class="bold">void*</strong>) noexcept { }
void operator delete[](void*, <strong class="bold">void*</strong>) noexcept { }</pre> <p>We call these the placement<a id="_idIndexMarker409"/> allocation functions, mostly known as <strong class="bold">placement new</strong> by the programming community.</p>
<p>What is the purpose of these functions? You might remember, at the beginning of our discussion of the global versions of the allocation operators, that we stated: “What <code>new</code> does is find the location where an object will be constructed.” This does not necessarily mean that <code>new</code> will allocate memory, and indeed, placement <code>new</code> does not allocate; it simply yields back the address it has been given as argument. <em class="italic">This allows us to place an object wherever we want in memory</em>… as long as we have the right to write the memory at that location.</p>
<p>Placement <code>new</code> serves many purposes:</p>
<ul>
<li>If we have sufficient rights, it can let us map an object onto a piece of memory-mapped hardware, giving us an <em class="italic">extremely</em> thin layer of abstraction over that device.</li>
<li>It enables us to decouple allocation from construction, leading to significant speed improvements <a id="_idIndexMarker410"/>when writing containers.</li>
<li>It opens up options to implement important facilities such as types <code>optional&lt;T&gt;</code> (that might or might not store a <code>T</code> object) and <code>variant&lt;T0,T1,...,Tn&gt;</code> (that stores an object of one of types <code>T0</code>,<code>T1</code>,...,<code>Tn</code>), or even <code>std::string</code> and <code>std::function</code> that sometimes allocate external memory, but sometimes use their internal <a id="_idIndexMarker411"/>data structures and avoid allocation altogether. Placement <code>new</code> is not the only way to do this, but it is one of the options in our toolbox.</li>
</ul>
<p>One important benefit of placement <code>new</code> is most probably in the implementation of containers and the interaction between containers and allocators, themes we will explore from <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a> to <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a> of this book. For now, we will limit ourselves to a simple, artificial example that’s meant as an illustration of how placement <code>new</code> works its magic, not as an example of something you should do (indeed, you should <em class="italic">not</em> do what the following example does!).</p>
<p>Suppose that you want to compute the length of a null-delimited character string and cannot remember the name of the C function that efficiently computes its length (better known as <code>std::strlen()</code>). One way to achieve similar results but <em class="italic">much</em> less efficiently would be to write the following:</p>
<pre class="source-code">
auto string_length(const char *p) {
   return std::string{ p }.size(); // augh! But it works...
}</pre> <p>That’s inefficient because the <code>std::string</code> constructor might allocate memory. We just wanted to count the characters until the first occurrence of a zero in the sequence, but it works (note: if you do the same maneuver with a <code>std::string_view</code> instead of with a <code>std::string</code>, its performance will actually be quite reasonable!). Now, suppose you want to show off to <a id="_idIndexMarker412"/>your friends the fact that you can place an object where you want in memory, and then<a id="_idIndexMarker413"/> use that object’s data members to do what you set out to do. You can (but should not) write the following:</p>
<pre class="source-code">
auto string_length(const char *p) {
   using std::string;
   <strong class="bold">// A) make a local buffer of the right size and</strong>
<strong class="bold">   // alignment for a string object</strong>
<strong class="bold">   alignas(string) char buf[sizeof(string)];</strong>
<strong class="bold">   // B) "paint" a string object in that buffer</strong>
<strong class="bold">   // (note: that object might allocate its</strong>
<strong class="bold">   // own data externally, but that's not</strong>
<strong class="bold">   // our concern here)</strong>
<strong class="bold">   string *s = new (static_cast&lt;void*&gt;(buf)) string{ p };</strong>
<strong class="bold">   // C) use that object to compute the size</strong>
<strong class="bold">   const auto sz = s-&gt;size();</strong>
<strong class="bold">   // D) destroy the object without releasing the memory</strong>
<strong class="bold">   // for the buffer (it's not dynamically allocated,</strong>
<strong class="bold">   // it's just local storage)</strong>
<strong class="bold">   s-&gt;~string(); // yes, you can do this</strong>
   return sz;
}</pre> <p>What are the benefits of the complicated version in comparison to the simple one? None whatsoever, but it shows<a id="_idIndexMarker414"/> the intricacies of doing this sort of low-level memory management maneuver. From the comments in the code example, the steps work as follows:</p>
<ul>
<li>Step <code>A)</code> makes sure that the location where the object will be constructed is of the right size and shape: it’s a buffer of bytes (type <code>char</code>), aligned in memory as a <code>std::string</code> object should be, and of sufficient size to hold a <code>std::string</code> object.</li>
<li>Step <code>B)</code> paints a <code>std::string</code> object in that buffer. That’s what a constructor does, really: it (conceptually) transforms raw memory into an object and initializes the state of that <a id="_idIndexMarker415"/>object. If the <code>std::string</code> constructor throws an exception, then the object has never been constructed and our <code>string_length()</code> function concludes without satisfying its postconditions. There is no memory allocation involved here unless the constructor itself allocates, but that’s fair (the object does what it has to do).</li>
<li>Step <code>C)</code> uses the newly constructed object; in our case, it’s just a matter of querying the size of that character string, but we could do whatever we want here. Do note, however, that (a) the object’s lifetime is tied to the buffer in which it is located, and (b) since we explicitly called the constructor, we will need to explicitly destroy it, which means that if an exception is thrown when we use the object, we will need to make sure the object’s destructor is called somehow.</li>
<li>Step <code>D)</code> destroys the object before we leave the function, as not doing so would lead to a possible leak of resources. If the buffer’s lifetime ends at a point where the object is not yet destroyed, things will be very wrong: either the destructor of the object we put in that buffer will never be called and code will leak, or someone might try to use the object even though the storage for that object is not ours anymore, leading to<a id="_idIndexMarker416"/> UB. Note the syntax, <code>s-&gt;~string()</code>, which calls the destructor but does not deallocate the storage for <code>*s</code>.</li>
</ul>
<p>This is a bad example of placement <code>new</code> usage, but it is explicit and (hopefully) instructive. We will use this feature in much more reasonable ways in order to gain significant speed advantages when we write containers with explicit memory management in <a href="B21071_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>.</p>
<h3>A note on make_shared&lt;T&gt;(args...)</h3>
<p>We mentioned in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a> that <code>make_shared&lt;T&gt;(args...)</code> usually leads to a better memory layout than <code>shared_ptr&lt;T&gt;{ new T(args...) }</code> would, at least with respect to cache usage. We <a id="_idIndexMarker417"/>can start to see why that is so.</p>
<p>Calling <code>shared_ptr&lt;T&gt;::shared_ptr(T*)</code> makes the object responsible for a preexisting pointee, the one whose address is passed as argument. Since that object has been constructed, the <code>shared_ptr&lt;T&gt;</code> object has to allocate a reference counter separately, ending up with two separate allocations, probably on different cache lines. In most programs, this worsened locality may induce slowdowns at runtime.</p>
<p>On the other hand, calling <code>make_shared&lt;T&gt;(args...)</code> makes this factory function responsible for creating a block of memory whose layout accommodates the <code>T</code> object and the reference counter, respecting the size and alignment constraints of both. There’s more than one way to do this, of course, including (a) resorting to a <code>union</code> where “coexist” a pair of pointers and a single pointer to a block that contains a counter and a <code>T</code> object, and (b) resorting to a byte buffer of appropriate size and alignment, then performing placement <code>new</code> for both objects in the appropriate locations within that buffer. In the latter case, we end up with a single allocation for a contiguous block of memory able to host both objects and two placement <code>new</code> calls.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Member versions of the allocation operators</h2>
<p>Sometimes, we have special knowledge of the needs and requirements of specific types with respect to dynamic memory allocation. A full example that goes into detail about a real-life (but simplified) use case of<a id="_idIndexMarker418"/> such type-specific knowledge is given in <a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>, where we discuss arena-based allocation.</p>
<p>For now, we will limit ourselves to covering the syntax and the effect of a member function overload of the allocation operators. In the example that follows, we suppose class <code>X</code> would somehow benefit from a per-class specialization of these mechanisms, and show that client code will call these specializations when we call <code>new X</code> but not when we call <code>new int</code>:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;new&gt;
class X {
   // ...
public:
   X() { std::cout &lt;&lt; "X::X()\n"; }
   ~X() { std::cout &lt;&lt; "X::~X()\n"; }
   <strong class="bold">void *operator new(std::size_t);</strong>
<strong class="bold">   void *operator new[](std::size_t);</strong>
<strong class="bold">   void operator delete(void*);</strong>
<strong class="bold">   void operator delete[](void*);</strong>
   // ...
};
// ...
<strong class="bold">void* X::operator new(std::size_t n) {</strong>
   std::cout &lt;&lt; "Some X::operator new() magic\n";
   return ::operator new(n);
}
<strong class="bold">void* X::operator new[](std::size_t n) {</strong>
   std::cout &lt;&lt; "Some X::operator new[]() magic\n";
   return ::operator new[](n);
}
<strong class="bold">void X::operator delete(void *p) {</strong>
   std::cout &lt;&lt; "Some X::operator delete() magic\n";
   return ::operator delete(p);
}
<strong class="bold">void X::operator delete[](void *p) {</strong>
   std::cout &lt;&lt; "Some X::operator delete[]() magic\n";
   return ::operator delete[](p);
}
int main() {
   std::cout &lt;&lt; "p = new int{3}\n";
   <strong class="bold">int *p = new int{ 3 }; // global operator new</strong>
   std::cout &lt;&lt; "q = new X\n";
   <strong class="bold">X *q = new X; // X::operator new</strong>
   std::cout &lt;&lt; "delete p\n";
   <strong class="bold">delete p; // global operator delete</strong>
   std::cout &lt;&lt; "delete q\n";
   <strong class="bold">delete q; // X::operator delete</strong>
}</pre> <p>One important detail to mention is that these overloaded operators will be inherited by derived classes, which means that if the implementation of these operators somehow depends on details specific to that class – for example, its size of alignment or anything else that might be <a id="_idIndexMarker419"/>invalidated in derived classes through such seemingly inconspicuous details as adding a data member – consider marking the class that overloads these operators as <code>final</code>.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Alignment-aware versions of the allocation operators</h2>
<p>When designing C++17, a<a id="_idIndexMarker420"/> fundamental problem with the memory allocation process was fixed with respect to what we call <code>std::max_align_t</code>.</p>
<p>There are many reasons for this, but a simple example would be when communicating with specialized hardware with requirements that differ from the ones on our computer. Suppose the following <code>Float4</code> type is such a type. Its size is <code>4*sizeof(float)</code>, and we require a <code>Float4</code> to be aligned on a 16-byte boundary:</p>
<pre class="source-code">
struct alignas(16) Float4 { float vals[4]; };</pre> <p>In this example, if we<a id="_idIndexMarker422"/> remove <code>alignas(16)</code> from the type declaration, the natural alignment of type <code>Float4</code> would be <code>alignof(float)</code>, which is probably 4 on most platforms.</p>
<p>The problem with such types before C++17 is that variables generated by the compiler would respect our alignment requirements, but those located in dynamically allocated storage would, by default, end up with an alignment of <code>std::max_align_t</code>, which would be incorrect. That makes sense, of course; functions such as <code>malloc()</code> and <code>operator new()</code> will, by default, cover the “worst-case scenario” of the platform, not knowing what will be constructed in the allocated storage, but they cannot be assumed to implicitly cover even worse scenarios than this.</p>
<p>Since C++17, we<a id="_idIndexMarker423"/> can specify <code>operator new()</code> or <code>operator new[]()</code> by passing an additional argument of type <code>std::align_val_t</code>, an integral type. This has to be done explicitly at the call site, as the following example shows:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;cstdlib&gt;
#include &lt;type_traits&gt;
void* <strong class="bold">operator new(std::size_t n, std::align_val_t al)</strong> {
   std::cout &lt;&lt; "new(" &lt;&lt; n &lt;&lt; ", align: "
             &lt;&lt; static_cast&lt;std::underlying_type_t&lt;
                   std::align_val_t
                &gt;&gt;(al) &lt;&lt; ")\n";
   <strong class="bold">return std::aligned_alloc(</strong>
      <strong class="bold">static_cast&lt;std::size_t&gt;(al), n</strong>
   <strong class="bold">);</strong>
}
// (others omitted for brevity)
struct alignas(16) Float4 { float vals[4]; };
int main() {
   <strong class="bold">auto p = new Float4; // calls operator new(size_t)</strong>
   <strong class="bold">// calls operator new(size_t, align_val_t)</strong>
   <strong class="bold">auto q = new(std::align_val_t{ 16 }) Float4;</strong>
   // leaks, of course, but that's beside the point
}</pre> <p>The memory block allocated for <code>p</code> in this example will be aligned on a boundary of <code>std::max_align_t</code>, whereas the memory block allocated for <code>q</code> will be aligned on a 16-byte boundary. The former <a id="_idIndexMarker424"/>might satisfy the requirements of our type if we’re lucky and cause chaos otherwise; the latter will respect our constraints if the allocation operator overload is implemented correctly.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Destroying delete</h2>
<p>C++20 brings a novel <a id="_idIndexMarker425"/>and highly specialized feature called destroying <code>delete</code>. The use case targeted here is a <a id="_idIndexMarker426"/>member function overload that benefits from specific knowledge of the type of object being destroyed in order to better perform the destruction process. When that member function is defined for some type <code>T</code>, it is preferred over other options when <code>delete</code> is invoked on a <code>T*</code>, even if <code>T</code> exposes another overload of <code>operator delete()</code>. To use destroying <code>delete</code> for some type <code>X</code>, one must implement the following member function:</p>
<pre class="source-code">
class X {
   // ...
public:
   <strong class="bold">void operator delete(X*, std::destroying_delete_t);</strong>
   // ...
};</pre> <p>Here, <code>std::destroying_delete_t</code> is a tag type like <code>std::nothrow_t</code>, which we saw earlier in this chapter. Note that the first argument of the destroying <code>delete</code> for class <code>X</code> is an <code>X*</code>, not a <code>void*</code>, as the destroying <code>delete</code> has the double role of destroying the object and deallocating memory… hence its name!</p>
<p>How does that work, and why is that useful? Let’s look at a concrete example with the following <code>Wrapper</code> class. In this example, an object of type <code>Wrapper</code> hides one of two implementations, modeled by <code>Wrapper::ImplA</code> and <code>Wrapper::ImplB</code>. The implementation is selected at construction time based on an enumerated value of type <code>Wrapper::Kind</code>. The intent is to<a id="_idIndexMarker427"/> remove the need for <code>virtual</code> functions from this class, replacing them with <code>if</code> statements based on the kind of implementation that was chosen. Of course, in this (admittedly) small example, there’s still only one <code>virtual</code> function (<code>Impl::f()</code>) as we aim to minimize the example’s complexity. There is also a wish to keep the destructor of class <code>Wrapper</code> trivial, a property that can be useful on occasion.</p>
<p>We will look at this example step by step as it is a bit more elaborate than the previous ones. First, let’s examine the basic structure of <code>Wrapper</code> including <code>Wrapper::Kind</code>, <code>Wrapper::Impl</code>, and its derived classes:</p>
<pre class="source-code">
#include &lt;new&gt;
#include &lt;iostream&gt;
class Wrapper {
public:
   enum class Kind { A, B };
private:
   struct Impl {
      virtual int f() const = 0;
   };
   struct ImplA final : Impl {
      int f() const override { return 3; }
      ~ImplA() { std::cout &lt;&lt; "Kind A\n"; }
   };
   struct ImplB final : Impl {
      int f() const override { return 4; }
      ~ImplB() { std::cout &lt;&lt; "Kind B\n"; }
   };
   Impl *p;
   Kind kind;
   // ...</pre> <p>Visibly, <code>Wrapper::Impl</code> does not <a id="_idIndexMarker428"/>have a <code>virtual</code> destructor, yet <code>Wrapper</code> keeps as a data member an <code>Impl*</code> named <code>p</code>, which means that simply calling <code>delete p</code> might not call the appropriate destructor for the pointed-to object.</p>
<p>The <code>Wrapper</code> class exposes a <a id="_idIndexMarker429"/>constructor that takes a <code>Kind</code> as argument, then calls <code>Wrapper::create()</code> to construct the appropriate implementation, modeled by a type derived from <code>Impl</code>:</p>
<pre class="source-code">
   // ...
   static Impl *create(Kind kind) {
      switch(kind) {
      using enum Kind;
      case A: return new ImplA;
      case B: return new ImplB;
      }
      throw 0;
   }
public:
   Wrapper(Kind kind)
      : p{ create(kind) }, kind{ kind } {
   }
   // ...</pre> <p>Now comes the destroying <code>delete</code>. Since we know by construction that the only possible implementations would be <code>ImplA</code> and <code>ImplB</code>, we test <code>p-&gt;kind</code> to know which one was chosen for <code>p</code>, then<a id="_idIndexMarker430"/> directly call the appropriate destructor. Once that is done, the <code>Wrapper</code> object itself is finalized and memory is freed through a direct call to <code>operator delete()</code>:</p>
<pre class="source-code">
   // ...
   <strong class="bold">void operator delete(Wrapper *p,</strong>
<strong class="bold">                        std::destroying_delete_t) {</strong>
<strong class="bold">      if(p-&gt;kind == Kind::A) {</strong>
<strong class="bold">         delete static_cast&lt;ImplA*&gt;(p-&gt;p);</strong>
<strong class="bold">      } else {</strong>
<strong class="bold">         delete static_cast&lt;ImplB*&gt;(p-&gt;p);</strong>
<strong class="bold">      }</strong>
<strong class="bold">      p-&gt;~Wrapper();</strong>
<strong class="bold">      ::operator delete(p);</strong>
<strong class="bold">   </strong><strong class="bold">}</strong>
   int f() const { return p-&gt;f(); }
};</pre> <p>For client code, the fact that we decided to use a destroying <code>delete</code> is completely transparent:</p>
<pre class="source-code">
int main() {
   using namespace std;
   auto p = new Wrapper{ Wrapper::Kind::A };
   cout &lt;&lt; p-&gt;f() &lt;&lt; endl;
   delete p;
   p = new Wrapper{ Wrapper::Kind::B };
   cout &lt;&lt; p-&gt;f() &lt;&lt; endl;
   delete p;
}</pre> <p>The destroying <code>delete</code> is a recent C++ facility as of this writing, but it is a tool that can let us get more control over the destruction process of our objects. Most of your types probably do not need<a id="_idIndexMarker431"/> this feature, but it’s good to know it exists for those cases where you need that extra bit of control over execution speed and program size. As always, measure the results of your efforts to ensure that they bring the desired benefits.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor127"/>Summary</h1>
<p>Whew, that was quite the ride! Now that we have the basics of memory allocation operator overloading handy, we will start to use them to our advantage. Our first application will be a leak detector (<a href="B21071_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>) using the global forms of these operators, followed by simplified examples of exotic memory management (<a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>) using specialized, custom forms of the global operators, and arena-based memory management (<a href="B21071_10.xhtml#_idTextAnchor153"><em class="italic">Chapter 10</em></a>) with member versions of the operators that will perform very satisfying optimizations.</p>
</div>
</body></html>