<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer433">
<h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor268"/>13</h1>
<h1 id="_idParaDest-241"><a id="_idTextAnchor269"/>Creating and Adding the Enemy Artificial Intelligence</h1>
<p>In the previous chapter, you added layered animations for the player character using animation blending with a combination of Anim Slots, Animation Blueprints, and blending functions such as <strong class="source-inline">Layered blend per bone</strong>. With this knowledge, you were able to smoothly blend the throwing animation montage with the base movement state machine to create layered animations for the character.</p>
<p>The primary focus of this chapter is to take the C++ enemy class you created in <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, and bring this enemy to life using AI. UE5 uses many different tools to achieve AI, such as AI Controllers, Blackboards, and Behavior Trees, all of which you will learn about and use in this chapter.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to use a Navigation Mesh to create a navigable space inside of the game world that the enemy can move in. </li>
<li>How to create an enemy AI pawn that can navigate between patrol point locations inside the game world using a combination of the AI tools present inside <strong class="bold">Unreal Engine 5</strong> (<strong class="bold">UE5</strong>), including <strong class="source-inline">Blackboards</strong> and <strong class="source-inline">Behavior Trees</strong>. </li>
<li>How to use a Transform Vector to convert local transform into world transform.</li>
<li>How to create a player projectile class in C++, and how to implement the <strong class="source-inline">OnHit()</strong>collision event function to recognize and log when the projectile hits an object in the game world.</li>
</ul>
<p>By the end of this chapter, you will be able to create a navigable space where the enemy can move. You will also be able to create an enemy AI pawn and navigate it across locations using <strong class="source-inline">Blackboards</strong> and <strong class="source-inline">Behavior Trees</strong>. Lastly, you will know how to create and implement a player projectile class and add visual elements to it. Before you jump into these systems, let’s take a moment to learn about how AI has been used in games in recent history. AI has certainly evolved since the days of <em class="italic">Super Mario Bros</em>.</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor270"/>Technical requirements</h1>
<p>For this chapter, you will need the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
</ul>
<p>The project for this chapter can be found in the <strong class="source-inline">Chapter13</strong> folder of the code bundle for this book, which can be downloaded from</p>
<p><a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor271"/>Enemy AI</h1>
<p>What is <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>)? This term can mean many things, depending on the field and context where it is used, so let’s define it in a <a id="_idIndexMarker1056"/>way that makes sense regarding the subject of video games.</p>
<p><strong class="bold">AI</strong> is an entity that is aware <a id="_idIndexMarker1057"/>of its environment and performs choices that will help it optimally achieve its intended purpose. AI uses what are called <strong class="bold">finite state machines</strong> to switch<a id="_idIndexMarker1058"/> between more than one state based on the input it receives from the user or its environment. For example, a video game AI can switch between an offensive state to a defensive state based on its current health.</p>
<p>In games such as <em class="italic">Hello Neighbor</em>, which was developed in Unreal Engine 4, and <em class="italic">Alien: Isolation</em>, the goal of the AI is to find the player as efficiently as possible, but also to follow some predetermined patterns defined by the developers to ensure that the player can outsmart it. <em class="italic">Hello Neighbor</em> adds a very creative element to its AI by having it learn from the players’ past actions and try to outsmart the player based on the knowledge it learns. </p>
<p>You can find an informative breakdown of how the AI works in the following video by the publishers of the game, <em class="italic">TinyBuild Games</em>: <a href="https://www.youtube.com/watch?v=Hu7Z52RaBGk">https://www.youtube.com/watch?v=Hu7Z52RaBGk</a>.</p>
<p>Interesting and fun AI is crucial to any game, and depending on the game you are making, this can mean a very complex or very simplistic AI. The AI that you will be creating for the <strong class="source-inline">SuperSideScroller</strong> game will not be as sophisticated as those mentioned previously, but it will fill the <a id="_idIndexMarker1059"/>needs of the game we are seeking to create.</p>
<p>Let’s break down how the enemy will behave:</p>
<ul>
<li>The enemy will be a very <a id="_idIndexMarker1060"/>simple enemy that has a basic back and forth movement pattern and will not support any attacks; only by colliding with the player character will they be able to inflict any damage.</li>
<li>However, we need to set the locations for the enemy AI to move between.</li>
<li>Next, we must decide whether the AI should change locations, should constantly move between locations, or whether there should be a pause inbetween selecting a new location to move to.</li>
</ul>
<p>Fortunately for us, UE5 provides us with a wide array of tools that we can use to develop such complex AI. In the case of our project, however, we will use these tools to create a simplistic enemy type. Let’s start by discussing what an AI Controller is in UE5.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor272"/>AI Controller</h1>
<p>Let’s discuss what the main <a id="_idIndexMarker1061"/>difference is between a <strong class="bold">Player Controller</strong> and an <strong class="bold">AI Controller</strong>. Both of these actors derive from the base <strong class="bold">Controller</strong> class. A <strong class="bold">Controller</strong> is used to take control of a <strong class="bold">Pawn</strong> or <strong class="bold">Character</strong> to control the actions of said pawn or character.</p>
<p>While a <strong class="bold">Player Controller</strong> relies on the input of an actual player, an <strong class="bold">AI Controller</strong> applies AI to the characters they possess and responds to the environment based on the rules set forth by the AI. By doing so, the AI can make intelligent decisions in response to the player and other external factors, without the player explicitly telling it to do so. Multiple instances of the same AI pawn can share the same <strong class="bold">AI Controller</strong>, and the same <strong class="bold">AI Controller</strong> can be used across different AI pawn classes. AI, like all actors inside UE5, is spawned through the <strong class="source-inline">UWorld</strong> class. </p>
<p class="callout-heading">Note</p>
<p class="callout">You will learn more about the <strong class="source-inline">UWorld</strong> class in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, but as a reference, you can read more here: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml</a>.</p>
<p>The most important aspect of<a id="_idIndexMarker1062"/> both the Player Controller and the AI Controller is the pawns they will control. Let’s learn more about how AI Controllers handle this.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor273"/>Auto Possess AI</h2>
<p>Like all Controllers, the AI Controller must possess a <em class="italic">pawn</em>. In C++, you can use the following function to <a id="_idIndexMarker1063"/>possess a pawn:</p>
<p class="source-code">void AController::Possess(APawn* InPawn)</p>
<p>You can also use the following function to unpossess a pawn:</p>
<p class="source-code">void AController::UnPossess()</p>
<p>There’s also the <strong class="source-inline">void AController::OnPossess(APawn* InPawn)</strong> and <strong class="source-inline">void AController::OnUnPossess()</strong>functions, which are called whenever the <strong class="source-inline">Possess()</strong> and <strong class="source-inline">UnPossess()</strong>functions are called, respectively.</p>
<p>When it comes to AI, especially in the context of UE5, there are two methods in which AI Pawns or Characters can be possessed by an AI Controller. Let’s take a look at these options: </p>
<ul>
<li><strong class="source-inline">Placed in World</strong>: This first method is how you will be handling AI in this project; you will manually place these enemy actors into your game world, and the AI will take care of the rest once the game begins.</li>
<li><strong class="source-inline">Spawned</strong>: This second method is only a little more complicated because it requires an explicit function call, either in C++ or Blueprint, to <strong class="source-inline">Spawn</strong> an instance of a specified class. The <strong class="source-inline">Spawn Actor</strong> method requires a handful of parameters, including the <strong class="source-inline">World</strong> object and <strong class="source-inline">Transform</strong> parameters such as <strong class="source-inline">Location</strong> and <strong class="source-inline">Rotation</strong>, to ensure that the instance that is spawned is spawned correctly.</li>
<li><strong class="source-inline">Placed in World or Spawned</strong>: If you are unsure of which method you want to use, a safe option would be <strong class="source-inline">Placed in World or Spawned</strong>; that way, both methods are supported.</li>
<li>For the <strong class="source-inline">SuperSideScroller</strong> game, you will be using the <strong class="source-inline">Placed</strong> <strong class="source-inline">in</strong> <strong class="source-inline">World</strong> option because the<a id="_idIndexMarker1064"/> AI you will create will be manually placed in the game level.</li>
</ul>
<p>Let’s move to our first exercise where we will implement the AI Controller for the enemy.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor274"/>Exercise 13.01 – implementing AI Controllers</h2>
<p>Before the enemy pawn can<a id="_idIndexMarker1065"/> do anything, it needs to be possessed by an AI Controller. This also needs to happen before any logic can be performed by the AI. By the end of this exercise, you will have created an AI Controller and applied it to the enemy that you created in the previous chapter. Let’s begin by creating the AI Controller.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li>Head to the <strong class="bold">Content Drawer</strong> interface and navigate to the <strong class="source-inline">Content/Enemy</strong> directory.</li>
<li><em class="italic">Right-click</em> on the <strong class="source-inline">Enemy</strong> folder and select the <strong class="bold">New Folder</strong> option. Name this new folder <strong class="source-inline">AI</strong>. In the new <strong class="source-inline">AI</strong> folder directory, <em class="italic">right-click</em> and select the <strong class="bold">Blueprint Class</strong> option.</li>
<li>From the <strong class="bold">Pick Parent Class</strong> dialog box, expand <strong class="bold">All Classes</strong> and manually search for the <strong class="source-inline">AIController</strong> class.</li>
<li><em class="italic">Left-click</em> this class option and then <em class="italic">left-click</em> on the blue <strong class="bold">Select</strong> option at the bottom to create a new Blueprint from this class. Please refer to the following screenshot to know where to find the <strong class="source-inline">AIController</strong> class. Also, take note of the tooltip that appears when hovering over the class option; it contains useful information about this class from the developers:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer393">
<img alt="Figure 13.1 – The AIController asset class, as found in the Pick Parent Class dialog box " height="342" src="image/Figure_13.01_B18531.jpg" width="745"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The AIController asset class, as found in the Pick Parent Class dialog box</p>
<ol>
<li value="5">With this new <strong class="source-inline">AIController Blueprint</strong> created, name this asset <strong class="source-inline">BP_AIControllerEnemy</strong>. </li>
</ol>
<p>With the AI Controller created and named, it’s <a id="_idIndexMarker1066"/>time to assign this asset to the first enemy Blueprint that you made in the previous chapter.</p>
<ol>
<li value="6">Navigate to the <strong class="source-inline">/Enemy/Blueprints</strong> directory to find <strong class="source-inline">BP_Enemy</strong>. <em class="italic">Double-click</em> to open this Blueprint.</li>
<li>In the <strong class="bold">Details</strong> panel of the first enemy Blueprint, there is a section labeled <strong class="source-inline">Pawn</strong>. This is where you can set different parameters regarding the AI functionality of <strong class="source-inline">Pawn</strong> or <strong class="source-inline">Character</strong>.</li>
<li>The <strong class="source-inline">AI Controller Class</strong> parameter determines, as its name suggests, which AI Controller to use for this enemy. <em class="italic">Left-click</em> on the dropdown to find and select the AI Controller you made earlier–that is, <strong class="source-inline">BP_AIController_Enemy</strong>.</li>
</ol>
<p>With this exercise complete, the enemy AI now knows which AI Controller to use. This is crucial because it is in the AI Controller where the AI will use and execute the <strong class="source-inline">Behavior Tree</strong> you will create later in this chapter.</p>
<p>The AI Controller is now assigned to the enemy, which means you are almost ready to start developing the actual<a id="_idIndexMarker1067"/> intelligence for this AI. However, there is still one important topic to discuss before doing so, and that is the <strong class="bold">Navigation Mesh</strong>.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor275"/>Navigation Mesh</h1>
<p>One of the most crucial aspects of any AI in video games is the ability to navigate the environment in a sophisticated manner. In UE5, there is a way for the engine to tell the AI which parts of an environment are navigable and which parts are not. This is done through a <strong class="bold">Navigation Mesh</strong>, or <strong class="bold">Nav Mesh</strong> for short.</p>
<p>The term <em class="italic">mesh</em> is misleading here <a id="_idIndexMarker1068"/>because it’s implemented through a volume in the editor. We will need a Nav Mesh in our level so that our AI can effectively navigate the playable bounds of the game world. We’ll add one together in the following exercise.</p>
<p>UE5 also supports a <strong class="bold">Dynamic Navigation Mesh</strong>, which allows the Nav Mesh to update in real time as dynamic objects move around the environment. This results in the AI recognizing these changes in the environment and updating their pathing/navigation appropriately. This book will not cover this, but you can access the configuration options via <strong class="bold">Project Settings</strong> | <strong class="bold">Navigation Mesh</strong> | <strong class="bold">Runtime Generation</strong>. </p>
<p>Now that we have learned about the <strong class="bold">Navigation Mesh</strong>, let’s start our first exercise where we will add the <strong class="bold">Navigation Mesh</strong> to our level.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor276"/>Exercise 13.02 – implementing a Nav Mesh Volume for the AI enemy</h2>
<p>In this exercise, you will <a id="_idIndexMarker1069"/>add a Navigation <a id="_idIndexMarker1070"/>Mesh to <strong class="source-inline">SideScrollerExampleMap</strong> and explore how Navigation Meshes work in UE5. You’ll also learn how to parameterize this volume for the needs of your game. This exercise will be performed within the UE5 editor.</p>
<p>By the end of this exercise, you will have a stronger understanding of the Nav Mesh. You will also be able to implement this volume in your levels in the activity that follows this exercise. Let’s begin by <a id="_idIndexMarker1071"/>adding the Nav Mesh Volume to the level.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">If you do not already<a id="_idIndexMarker1072"/> have the map open, please open <strong class="bold">ThirdPersonExampleMap</strong> by navigating to <strong class="bold">File</strong> and <em class="italic">left-clicking</em> on the <strong class="bold">Open Level</strong> option. From the <strong class="bold">Open Level</strong> dialog box, navigate to <strong class="bold">/ThirdPersonCPP/Maps</strong> to find <strong class="bold">SideScrollerExampleMap</strong>. Select this map by <em class="italic">left-clicking</em> and then <em class="italic">left-click</em> <strong class="bold">Open</strong> at the bottom to open the map.</li>
<li>With the map opened, navigate to the <strong class="bold">Window</strong> menu at the top-left of the editor, and make sure you select the <strong class="bold">Place Actors</strong> panel option. The <strong class="bold">Place Actors</strong> panel contains a set of easily accessible actor types such as <strong class="bold">Volumes</strong>, <strong class="bold">Lights</strong>, <strong class="bold">Geometry</strong>, and others. Under the <strong class="bold">Volumes</strong> category, you will find the <strong class="bold">Nav Mesh Bounds Volume</strong> option.</li>
<li><em class="italic">Left-click</em> and drag this volume into the map/scene. By default, you will see the outline of the volume in the editor. Press the <em class="italic">P</em> key to visualize the <strong class="bold">Navigation</strong> area that the volume encompasses, but make sure that the volume is intersecting with the ground geometry to see the green visualization, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer394">
<img alt="Figure 13.2 – Areas outlined in green are perceived as navigable by the engine and the AI " height="594" src="image/Figure_13.02_B18531.jpg" width="1387"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Areas outlined in green are perceived as navigable by the engine and the AI</p>
<p>With the Nav Mesh <a id="_idIndexMarker1073"/>Volume in place, let’s adjust its <a id="_idIndexMarker1074"/>shape so that the volume extends to the entire area of the level. After this, you’ll learn how to adjust the parameters of the Nav Mesh Volume for the game.</p>
<ol>
<li value="4"><em class="italic">Left-click</em> to select <strong class="bold">NavMeshBoundsVolume</strong> and navigate to its <strong class="bold">Details</strong> panel. There’s a section labeled <strong class="bold">Brush Settings</strong> that allows you to adjust the shape and size of the volume. Find the values that fit best for you. Some suggested settings are <strong class="bold">Brush Type: Additive</strong>, <strong class="bold">Brush Shape: Box</strong>, <strong class="source-inline">X: 3000.0</strong>, <strong class="source-inline">Y: 3000.0</strong>, and <strong class="source-inline">Z: 3000.0</strong>.</li>
</ol>
<p>Notice that when the shape and dimensions of <strong class="bold">NavMeshBoundsVolume</strong> change, <strong class="bold">Nav Mesh</strong> will adjust and recalculate the navigable area. This can be seen in the following screenshot. You will also notice that the upper platforms are not navigable; you will fix this later:</p>
<div>
<div class="IMG---Figure" id="_idContainer395">
<img alt="Figure 13.3 – Now, NavMeshBoundsVolume extends to the entire playable area of the example map " height="678" src="image/Figure_13.03_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Now, NavMeshBoundsVolume extends to the entire playable area of the example map</p>
<p>By completing this exercise, you <a id="_idIndexMarker1075"/>have placed your first <strong class="bold">NavMeshBoundsVolume </strong>actor into the game world and, using the debug key, <em class="italic">P</em>, visualized the<a id="_idIndexMarker1076"/> navigable area in the default map. Next, you will learn more about the <strong class="source-inline">RecastNavMesh</strong> actor, which is also created when placing <strong class="source-inline">NavMeshBoundsVolume</strong> in the level.</p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor277"/>Recasting the Nav Mesh</h1>
<p>When you added <strong class="bold">NavMeshBoundsVolume</strong>, you may have noticed that another actor was created automatically: a <strong class="bold">RecastNavMesh</strong> actor called <strong class="bold">RecastNavMesh-Default</strong>. This <strong class="bold">RecastNavMesh</strong> acts<a id="_idIndexMarker1077"/> as the “brain” of the Nav Mesh because it contains the parameters needed to adjust the Nav Mesh that directly influences how the AI navigates the given area.</p>
<p>The following screenshot shows this asset, as seen from the <strong class="bold">World Outliner</strong> tab:</p>
<div>
<div class="IMG---Figure" id="_idContainer396">
<img alt="Figure 13.4 – The RecastNavMesh actor, as seen from the World Outliner tab " height="311" src="image/Figure_13.04_B18531.jpg" width="384"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – The RecastNavMesh actor, as seen from the World Outliner tab</p>
<p class="callout-heading">Note</p>
<p class="callout">There are a lot of parameters that exist in <strong class="source-inline">RecastNavMesh</strong>, and we will only be covering the important parameters in this book. For more information, check out <a href="https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml</a>.</p>
<p>There are only two primary sections that are important to you right now:</p>
<ul>
<li><strong class="bold">Display</strong>: The <strong class="bold">Display</strong> section, as its name suggests, only contains parameters that affect the visual debug display of the generated navigable area of <strong class="bold">NavMeshBoundsVolume</strong>. It is recommended that you try toggling each of the parameters under this category to see how they affect the display of the generated Nav Mesh.</li>
<li><strong class="bold">Generation</strong>: The <strong class="bold">Generation</strong> category contains a set of values that act as a rule set for how the Nav <a id="_idIndexMarker1078"/>Mesh will generate and determine which areas of geometry are navigable, and which are not. There are many options here, which can make the concept very daunting, but let’s discuss just a handful of the parameters under this category:<ul><li><strong class="bold">Cell Size</strong> refers to the accuracy with which the Nav Mesh can generate navigable space within an area. You will be updating this value in the next step of this exercise, so you’ll see how this affects the navigable area in real time.</li><li><strong class="bold">Agent Radius</strong> refers to the radius of the actor that will be navigating this area. In the case of your game, the radius to set here is the radius of the collision component of the character with the largest radius.</li><li><strong class="bold">Agent Height</strong> refers to the height of the actor that will be navigating this area. In the case of your game, the height to set here is the <strong class="bold">Half Height </strong>value of the collision component of the character with the largest <strong class="bold">Half Height</strong>. You can multiply it by <strong class="source-inline">2.0f</strong> to get the full height.</li><li><strong class="bold">Agent Max Slope</strong> refers to the slope angle for inclines that can exist in your game world. By default, the value is <strong class="source-inline">44</strong> degrees, and this is a parameter you will leave alone unless your game requires it to change.</li><li><strong class="bold">Agent Max Step Height</strong> refers to the height of steps, in terms of staircase steps, that can be navigated by the AI. Much like <strong class="bold">Agent Max Slope</strong>, this is a parameter that you will more than likely leave alone unless your game specifically requires this value to change.</li></ul></li>
</ul>
<p>Now that you have learned about the Recast Nav Mesh parameters, let’s put this knowledge into practice in the next exercise, which will walk you through changing a few of these parameters.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor278"/>Exercise 13.03 – recasting Nav Mesh Volume parameters</h2>
<p>Now that you have the <strong class="bold">Nav Mesh</strong> Volume in the<a id="_idIndexMarker1079"/> level, it is time to change the parameters of the <strong class="bold">Recast Nav Mesh</strong> actor so that the Nav Mesh allows the enemy AI to navigate across platforms that are thinner than others. This exercise will be performed within the UE5 editor.</p>
<p>Here, you will simply be updating <strong class="source-inline">Cell Size</strong> and <strong class="source-inline">Agent Height</strong> so that they fit the needs of your character and the accuracy needed for the Nav Mesh:</p>
<pre class="source-code">
Cell Size: 5.0f
Agent Height: 192.0f</pre>
<p>The following screenshot shows that the extended platform is now navigable because of the changes we made to <strong class="source-inline">Cell Size</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer397">
<img alt="Figure 13.5 – Changing Cell Size from 19.0f to 5.0f allows for the narrow extended platform to be navigable " height="834" src="image/Figure_13.05_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Changing Cell Size from 19.0f to 5.0f allows for the narrow extended platform to be navigable</p>
<p>With <strong class="source-inline">SuperSideScrollerExampleMap</strong> set up with its own <strong class="bold">Nav Mesh</strong>, you can now move on and create the AI logic for the enemy. Before doing so, complete the following activity to create a<a id="_idIndexMarker1080"/> level with a unique layout and <strong class="source-inline">NavMeshBoundsVolume</strong> actor that you can use for the remainder of this project.</p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor279"/>Activity 13.01 – creating a new level</h2>
<p>Now that you<a id="_idIndexMarker1081"/> have added <strong class="source-inline">NavMeshBoundsVolume</strong> to the example map, it is time to create a map for the rest of the <strong class="source-inline">Super SideScroller</strong> game. By creating a map, you will have a better understanding of how <strong class="source-inline">NavMeshBoundsVolume</strong> and the properties of <strong class="source-inline">RecastNavMesh</strong> affect the environment they are placed in. </p>
<p class="callout-heading">Note</p>
<p class="callout">Before moving on to the solution for this activity, if you need an example level that will work for the remaining chapters that cover the <strong class="source-inline">SuperSideScroller</strong> game, then don’t worry – this chapter comes with the <strong class="source-inline">SuperSideScroller.umap</strong> asset, as well as a map called <strong class="source-inline">SuperSideScroller_NoNavMesh</strong>, which does not contain <strong class="source-inline">NavMeshBoundsVolume</strong>. You can use <strong class="source-inline">SuperSideScroller.umap</strong> as a reference for how to create a level or to get ideas on how to improve your level. You can download the map from <a href="https://packt.live/3lo7v2f">https://packt.live/3lo7v2f</a>.</p>
<p>Follow these steps to<a id="_idIndexMarker1082"/> create a simplistic map:</p>
<ol>
<li value="1">Create a <strong class="bold">New Level</strong>.</li>
<li>Name this level <strong class="source-inline">SuperSideScroller</strong>.</li>
<li>Using the <strong class="bold">Static Mesh</strong> assets provided by default in the <strong class="bold">Content Drawer</strong> interface of this project, create an interesting space with different elevations to navigate. Add your player character’s <strong class="bold">Blueprint</strong> to the level, and make sure it is possessed by <strong class="bold">Player Controller 0</strong>.</li>
<li>Add the <strong class="bold">NavMeshBoundsVolume</strong> actor to your level and adjust its dimensions so that it fits the space you created. In the example map provided for this activity, the dimensions set should be <strong class="source-inline">1000.0</strong>, <strong class="source-inline">5000.0</strong>, and <strong class="source-inline">2000.0</strong> in the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> axes, respectively.</li>
<li>Make sure that you enable debug visualization for <strong class="bold">NavMeshBoundsVolume</strong> by pressing the <em class="italic">P</em> key.</li>
<li>Adjust the parameters of the <strong class="bold">RecastNavMesh</strong> actor so that <strong class="bold">NavMeshBoundsVolume</strong> works well for your level. In the case of the provided example map, the <strong class="source-inline">Cell Size</strong> parameter is set to <strong class="source-inline">5.0f</strong>, <strong class="source-inline">Agent Radius</strong> is set to <strong class="source-inline">42.0f</strong>, and <strong class="source-inline">Agent Height</strong> is set to <strong class="source-inline">192.0f</strong>. Use these values as a reference.</li>
</ol>
<p><strong class="bold">Expected Output</strong></p>
<div>
<div class="IMG---Figure" id="_idContainer398">
<img alt="Figure 13.6 – The SuperSideScroller map " height="596" src="image/Figure_13.06_B18531.jpg" width="1193"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – The SuperSideScroller map</p>
<p>By the end of this activity, you will have a level that contains the required <strong class="source-inline">NavMeshBoundsVolume</strong> and settings for the <strong class="source-inline">RecastNavMesh</strong> actor. This will allow the AI we’ll develop in the <a id="_idIndexMarker1083"/>upcoming exercises to function correctly. Again, if you are unsure of how the level should look, please refer to the provided example map, <strong class="source-inline">SuperSideScroller.umap</strong>. Now, it is time to jump into developing the AI for the <strong class="source-inline">SuperSideScroller</strong> game.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor280"/>Behavior trees and Blackboards</h1>
<p>Behavior Trees and Blackboards work together to allow our AI to follow different logical paths and make decisions based on a variety of conditions and variables. </p>
<p>A <strong class="bold">behavior tree</strong> is a visual scripting tool that allows you to tell a pawn what to do based on certain factors and parameters. For <a id="_idIndexMarker1084"/>example, a Behavior Tree can tell an AI to move to a certain location based on whether the AI can see the player.</p>
<p>To give an example of how <strong class="source-inline">Behavior Trees</strong> and <strong class="source-inline">Blackboards</strong> are used in games, let’s look at the game <em class="italic">Gears of War 5</em>, which was developed with UE5. The AI in <strong class="bold">Gears of War 5</strong>, and throughout the <strong class="bold">Gears of War</strong> series, always tries to flank the player or force the player out of cover. To do this, a key component of the AI logic is to know who the player is and where they are. A reference variable to the player, and a location vector to store the location of the player, exist in the <strong class="source-inline">Blackboard</strong>. The logic that determines how these variables are used and how the AI will use this information is performed inside the Behavior Tree. </p>
<p>The <strong class="source-inline">Blackboard</strong> is where you define the <a id="_idIndexMarker1085"/>set of variables that are required to have the Behavior Tree perform actions and use those values for decision-making. </p>
<p>The <strong class="source-inline">Behavior Tree</strong> is where you create the tasks that you want the AI to perform, such as moving to a location or performing a custom task that you create. Like many of the in-editor tools in UE5, <strong class="source-inline">Behavior Trees</strong> are, for the most part, a very visual scripting experience. </p>
<p><strong class="source-inline">Blackboards</strong> are where you define the variables, also known as <strong class="bold">Keys</strong>, that will then be referenced by the Behavior Tree. The keys you create here can be used in <strong class="bold">Tasks</strong>, <strong class="bold">Services</strong>, and <strong class="bold">Decorators</strong> to serve different purposes based on how you want the AI to function. The following screenshot shows an example set of variable <strong class="bold">Keys</strong> that can be referenced by its associated Behavior Tree. Without a <strong class="source-inline">Blackboard</strong>, <strong class="source-inline">Behavior Trees</strong> would have no way of passing and storing information across different Tasks, Services, or Decorators, rendering it useless:</p>
<div>
<div class="IMG---Figure" id="_idContainer399">
<img alt="Figure 13.7 – An example set of variables inside a Blackboard that can be accessed in the behavior tree " height="200" src="image/Figure_13.07_B18531.jpg" width="603"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – An example set of variables inside a Blackboard that can be accessed in the behavior tree</p>
<p>Behavior Trees are composed of a set of <strong class="bold">objects</strong> – that is, <strong class="bold">Composites</strong>, <strong class="bold">Tasks</strong>, <strong class="bold">Decorators</strong>, and <strong class="bold">Services</strong> – that work together<a id="_idIndexMarker1086"/> to define how the AI will <a id="_idIndexMarker1087"/>behave and respond based on the conditions and logic flow that you set. All Behavior Trees begin <a id="_idIndexMarker1088"/>with what is called the Root where the<a id="_idIndexMarker1089"/> logic flow begins; this cannot be modified and has only one execution branch. Let’s take a look at these objects in more detail.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for <strong class="source-inline">Behavior Tree</strong> Behavior Tree, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites</a>. </p>
<p>Composite nodes tell the <strong class="source-inline">Behavior Tree</strong> how to go about performing tasks and other actions. The <a id="_idIndexMarker1090"/>following screenshot shows the full list of Composite nodes that Unreal Engine gives you by default: <strong class="bold">Selector</strong>, <strong class="bold">Sequence</strong>, and <strong class="bold">Simple Parallel</strong>.</p>
<p>Composite nodes can also have Decorators and Services attached to them so that optional conditions can be applied before a <strong class="source-inline">Behavior Tree</strong> branch is executed:</p>
<div>
<div class="IMG---Figure" id="_idContainer400">
<img alt="Figure 13.8 – Composite nodes – Selector, Sequence, and Simple Parallel " height="101" src="image/Figure_13.08_B18531.jpg" width="406"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Composite nodes – Selector, Sequence, and Simple Parallel</p>
<p>Let’s look at these nodes in more detail:</p>
<ul>
<li><strong class="bold">Selector</strong>: The <strong class="bold">Selector</strong> Composite node <a id="_idIndexMarker1091"/>executes its children from left to right and will stop executing when one of the child tasks succeeds. Using the example shown in the following screenshot, if the <strong class="source-inline">FinishWithResult</strong> task is successful, the parent <strong class="bold">Selector</strong> succeeds, which will cause the <strong class="source-inline">Root</strong> to execute again and <strong class="source-inline">FinishWithResult</strong> to execute once more. This pattern will continue until <strong class="source-inline">FinishWithResult</strong> fails. The <strong class="bold">Selector</strong> node will then execute <strong class="source-inline">MakeNoise</strong>. If <strong class="source-inline">MakeNoise</strong> fails, the <strong class="bold">Selector</strong> node fails, and the <strong class="source-inline">Root</strong> will execute again. If the <strong class="source-inline">MakeNoise</strong> task succeeds, then the Selector will succeed, and the <strong class="source-inline">Root</strong> will execute again. Depending on the flow of the behavior tree, if the Selector fails or succeeds, the next Composite branch will begin to execute. In the following screenshot, there are no other Composite nodes, so if the Selector fails or succeeds, the <strong class="source-inline">Root</strong> node will be executed again. However, if there were a <strong class="bold">Sequence</strong> Composite node with multiple <strong class="bold">Selector</strong> nodes underneath, each Selector would attempt to successfully execute its children. Regardless of success or failure, each <strong class="bold">Selector</strong> will attempt execution sequentially:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer401">
<img alt="Figure 13.9 – An example of how a Selector Composite node can be used in a behavior tree " height="530" src="image/Figure_13.09_B18531.jpg" width="1026"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – An example of how a Selector Composite node can be used in a behavior tree</p>
<p>Note that when adding tasks and <strong class="source-inline">Composite</strong> nodes, you will notice numeric values on the top-right corners of each node. These numbers indicate the order in which these nodes will be<a id="_idIndexMarker1092"/> executed. The pattern follows the <em class="italic">top</em> to <em class="italic">bottom</em>, <em class="italic">left</em> to <em class="italic">right</em> paradigm, and these values help you keep track of the ordering. Any disconnected task or <strong class="source-inline">Composite</strong> node will be given a value of <strong class="source-inline">–1</strong> to indicate that it is unused.</p>
<ul>
<li><strong class="bold">Sequence</strong>: The <strong class="bold">Sequence</strong> Composite <a id="_idIndexMarker1093"/>node executes its children from left to right and will stop executing when one of the child tasks fails. Using the example shown in the following screenshot, if the <strong class="source-inline">Move To</strong> task is successful, then the parent <strong class="bold">Sequence</strong> node will execute the <strong class="source-inline">Wait</strong> task. If the <strong class="source-inline">Wait</strong> task is successful, then the Sequence is successful, and <strong class="source-inline">Root</strong> will execute again. If the <strong class="source-inline">Move To</strong> task fails, however, the <strong class="bold">Sequence</strong> node will fail and <strong class="source-inline">Root</strong> will execute again, causing the <strong class="source-inline">Wait</strong> task to never execute:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer402">
<img alt="Figure 13.10 – An example of how a Sequence Composite node can be used in a behavior tree " height="486" src="image/Figure_13.10_B18531.jpg" width="1169"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – An example of how a Sequence Composite node can be used in a behavior tree</p>
<ul>
<li><strong class="bold">Simple Parallel</strong>: The <strong class="bold">Simple Parallel</strong> Composite node <a id="_idIndexMarker1094"/>allows you to execute a task and a new standalone branch of logic simultaneously. The following screenshot shows a very basic example of what this will look like. In this example, a task that’s used to <strong class="bold">Wait</strong> for <strong class="source-inline">5</strong> seconds is being executed at the same time as a new <strong class="bold">Sequence</strong> of tasks is being executed:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer403">
<img alt="Figure 13.11 – An example of how a Selector Composite node can be used in a behavior tree " height="708" src="image/Figure_13.11_B18531.jpg" width="1520"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – An example of how a Selector Composite node can be used in a behavior tree</p>
<p>The <strong class="bold">Simple Parallel</strong> Composite <a id="_idIndexMarker1095"/>node is also the only <strong class="bold">Composite</strong> node that has a parameter in its <strong class="bold">Details</strong> panel, which is <strong class="bold">Finish Mode</strong>. There are two options:</p>
<ul>
<li><strong class="bold">Immediate</strong>: When set to <strong class="bold">Immediate</strong>, the <strong class="bold">Simple Parallel</strong> Composite node will finish successfully once the main task finishes. In this case, after the <strong class="source-inline">Wait</strong> task finishes, the background tree Sequence will abort and the entire <strong class="bold">Simple Parallel</strong> will execute again.</li>
<li><strong class="bold">Delayed</strong>: When set to <strong class="bold">Delayed</strong>, the <strong class="bold">Simple Parallel</strong> Composite node will finish successfully once the background tree finishes its execution and the task finishes. In this case, the <strong class="source-inline">Wait</strong> task will finish after <strong class="source-inline">5</strong> seconds, but the entire <strong class="bold">Simple Parallel</strong> will wait for the <strong class="bold">Move To</strong> and <strong class="bold">PlaySound</strong> tasks to execute before restarting.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information <a id="_idIndexMarker1096"/>regarding the C++ API for Composites, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/</a>.</p>
<p>Now that we have a better understanding of Composite nodes, let’s take a look at a few examples of Task nodes.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor281"/>Tasks</h2>
<p>These are tasks that our AI can <a id="_idIndexMarker1097"/>perform. Unreal Engine provides us with built-in tasks for us to use by default, but we can also create our own in both Blueprints and C++. This includes tasks such as telling our AI to <strong class="bold">Move To</strong> a specific location, <strong class="bold">Rotate To Face Target</strong>, and even telling the AI to fire its weapon. It’s also important to know that you can create custom tasks using Blueprints. Let’s briefly discuss two of the tasks you will be using to develop the AI for the enemy character:</p>
<ul>
<li><strong class="bold">Move To Task</strong>: This is one of the more commonly used tasks in <strong class="source-inline">Behavior Trees</strong>, and you will be using this task in the upcoming exercises in this chapter. <strong class="bold">Move To task</strong> uses the navigation system to tell the AI how and where to move based on the location it is given. You will use this task to tell the AI enemy where to go.</li>
<li><strong class="bold">Wait Task</strong>: This is another commonly used task in <strong class="source-inline">Behavior Trees</strong> because it allows a delay inbetween task execution if the logic requires it. This can be used to allow the AI to wait a few seconds before moving to a new location.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for tasks, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/</a>.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor282"/>Decorators</h2>
<p>Decorators are conditions that can be added to tasks or <strong class="bold">Composite</strong> nodes, such as a <strong class="bold">Sequence</strong> or <strong class="bold">Selector</strong>, that allow branching logic to occur. As an example, we can have a <strong class="bold">Decorator</strong> that checks whether or not the <a id="_idIndexMarker1098"/>enemy knows the location of the player. If so, we can tell that enemy to move toward that last known location. If not, we can tell our AI to generate a new location and move there instead. It is also important to know that you can create custom decorators using Blueprints.</p>
<p>Let’s also briefly discuss the decorator you will be using to develop the AI for the enemy character – the <strong class="bold">Is At Location</strong> Decorator. This determines whether the controlled pawn is at the location specified in the decorator itself. This will be useful to you to ensure that the <strong class="source-inline">Behavior Trees</strong> is not executing until you know the AI has reached its given location.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for decorators, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/</a>.</p>
<p>Now that we have a better understanding of Task nodes, let’s briefly discuss Service nodes.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor283"/>Services</h2>
<p>Services work a lot like decorators<a id="_idIndexMarker1099"/> because they can be linked with tasks and <strong class="source-inline">Composite</strong> nodes. The main difference is that a <strong class="bold">Service</strong> allows us to execute a branch of nodes based on the interval defined in the service. It is also important to know that you can create custom services using Blueprints. </p>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for services, please refer to the following documentation:  <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/</a>.</p>
<p>With knowledge of <a id="_idIndexMarker1100"/>Composite, Task, and Service nodes under our belt, let’s move on to the next exercise where we will create the <strong class="source-inline">Behavior Tree</strong> and <strong class="source-inline">Blackboard</strong> for the enemy.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor284"/>Exercise 13.04 – creating the AI behavior tree and Blackboard</h2>
<p>Now that you have had an <a id="_idIndexMarker1101"/>overview of <strong class="source-inline">Behavior Trees</strong> and <strong class="source-inline">Blackboards</strong>, this exercise will guide you through creating these assets, telling the AI Controller to use the <strong class="source-inline">Behavior Tree</strong> you<a id="_idIndexMarker1102"/> created, and assigning the <strong class="source-inline">Blackboard</strong> to the <strong class="source-inline">Behavior Tree</strong>. The <strong class="source-inline">Blackboard</strong> and <strong class="source-inline">Behavior Tree</strong> assets you will create here will be used for the <strong class="source-inline">SuperSideScroller</strong> game. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Within the <strong class="bold">Content Drawer</strong> interface, navigate to the <strong class="source-inline">/Enemy/AI</strong> directory. This is the same directory where you created the AI Controller. </li>
<li>In this directory, <em class="italic">right-click</em> within the blank area of the <strong class="bold">Content Drawer</strong> interface, navigate to the <strong class="bold">Artificial Intelligence</strong> option, and select <strong class="bold">Behavior Tree</strong> to create the <strong class="source-inline">Behavior Tree</strong> asset. Name this asset <strong class="source-inline">BT_EnemyAI</strong>.</li>
<li>In the same directory as the previous step, <em class="italic">right-click</em> again within the blank area of the <strong class="bold">Content Drawer</strong> interface, navigate to the <strong class="bold">Artificial Intelligence</strong> option, and select <strong class="bold">Blackboard</strong> to create the <strong class="source-inline">Blackboard</strong> asset. Name this asset <strong class="source-inline">BB_EnemyAI</strong>.</li>
</ol>
<p>Before we move on to telling the AI Controller to run this new <strong class="source-inline">Behavior Tree</strong>, let’s assign the <strong class="source-inline">Blackboard</strong> to this <strong class="source-inline">Behavior Tree</strong> so that they are connected.</p>
<ol>
<li value="4">Open <strong class="source-inline">BT_EnemyAI</strong> by <em class="italic">double-clicking</em> the asset in the <strong class="bold">Content Drawer</strong> interface. Once opened, navigate to the <strong class="bold">Details</strong> panel on the right-hand side and find the <strong class="source-inline">Blackboard Asset</strong> parameter.</li>
<li><em class="italic">Left-click</em> the drop-down menu on this parameter and find the <strong class="source-inline">BB_EnemyAI</strong> <strong class="source-inline">Blackboard</strong> asset you created earlier. Compile and save the <strong class="source-inline">Behavior Tree</strong>before closing it.</li>
<li>Next, open the AI Controller’s <strong class="source-inline">BP_AIController_Enemy</strong> asset by <em class="italic">double-clicking</em> it inside the <strong class="bold">Content Drawer</strong> interface. Inside the Controller, <em class="italic">right-click</em> and search for the <strong class="source-inline">Run Behavior Tree</strong> function.</li>
</ol>
<p>The <strong class="source-inline">Run Behavior Tree</strong> function is <a id="_idIndexMarker1103"/>very straightforward: you assign a <strong class="bold">Behavior Tree</strong> to the Controller <a id="_idIndexMarker1104"/>and the function returns whether the <strong class="source-inline">Behavior Tree</strong> successfully began its execution.</p>
<ol>
<li value="7">Lastly, connect the <strong class="bold">Event BeginPlay</strong> event node to the execution pin of the <strong class="source-inline">Run Behavior Tree</strong> function and assign <strong class="bold">Behavior Tree asset </strong><strong class="source-inline">BT_EnemyAI</strong>, which you created earlier in this exercise:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer404">
<img alt="Figure 13.12 – Assigning the BT_EnemyAI behavior tree " height="401" src="image/Figure_13.12_B18531.jpg" width="620"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Assigning the BT_EnemyAI behavior tree</p>
<ol>
<li value="8">With this exercise <a id="_idIndexMarker1105"/>complete, the enemy AI Controller now knows<a id="_idIndexMarker1106"/> to run the <strong class="bold">BT_EnemyAI</strong> Behavior Tree, and this Behavior Tree knows to use the Blackboard asset called <strong class="bold">BB_EnemyAI</strong>. With this in place, you can begin to use the Behavior Tree logic to develop the AI so that the enemy character can move around the level.</li>
</ol>
<h2 id="_idParaDest-257"><a id="_idTextAnchor285"/>Exercise 13.05 – creating a new behavior tree task</h2>
<p>The goal of this exercise is to <a id="_idIndexMarker1107"/>develop an AI task for the enemy AI that will allow the character to find a random point to move to within the bounds of the <strong class="bold">Nav Mesh</strong> Volume in your level.</p>
<p>Although the <strong class="source-inline">SuperSideScroller</strong> game will only allow two-dimensional movement, let’s get the AI to move anywhere within the 3D space of the level that you created in <em class="italic">Activity 13.01 – creating a new level</em>, and then work to constrain the enemy to two dimensions. </p>
<p>Follow these steps to create this new task for the enemy:</p>
<ol>
<li value="1">First, open the <strong class="source-inline">Blackboard</strong> asset you created in the previous exercise, <strong class="source-inline">BB_EnemyAI</strong>.</li>
<li><em class="italic">Left-click</em> on the <strong class="bold">New Key</strong> option at the top-left of <strong class="source-inline">Blackboard</strong> and select the <strong class="bold">Vector</strong> option. Name this vector <strong class="bold">MoveToLocation</strong>. You will use this <strong class="bold">vector</strong> variable to track the next move for the AI as it decides where to move to.</li>
</ol>
<p>For this enemy AI, you will need to create a new <strong class="bold">Task</strong> because the currently available tasks inside Unreal do not fit the needs of the enemy behavior.</p>
<ol>
<li value="3">Navigate to and open the <strong class="source-inline">Behavior Tree</strong> asset you created in the previous exercise, <strong class="source-inline">BT_EnemyAI</strong>.</li>
<li><em class="italic">Left-click</em> on the <strong class="bold">New Task</strong> option on the top toolbar. When creating a new <strong class="source-inline">Task</strong>, it will automatically open the task asset for you. However, if you have already created a task, a <a id="_idIndexMarker1108"/>dropdown list of options will appear when selecting the <strong class="bold">New Task</strong> option. Before working on the logic of this <strong class="bold">Task</strong>, you must rename the asset.</li>
<li>Close the <strong class="bold">Task</strong> asset window and navigate to <strong class="bold">/Enemy/AI/</strong>, which is where the task was saved to. By default, the name provided is <strong class="source-inline">BTTask_BlueprintBase_New</strong>. Rename this asset <strong class="source-inline">BTTask_FindLocation</strong>.</li>
<li>With the new <strong class="bold">Task</strong> asset named, <em class="italic">double-click</em> to open <strong class="bold">Task Editor</strong>. New tasks will have empty Blueprint graphs and will not provide you with any default events to use in the graph. </li>
<li><em class="italic">Right-click</em> within the graph and from the context-sensitive search, find the <strong class="bold">Event Receive Execute AI</strong> option. </li>
<li><em class="italic">Left-click</em> the <strong class="bold">Event Receive Execute AI</strong> option to create the event node in the <strong class="bold">Task</strong> graph, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer405">
<img alt="Figure 13.13 – Event Receive Execute AI returns both Owner Controller and Controlled Pawn " height="186" src="image/Figure_13.13_B18531.jpg" width="665"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – Event Receive Execute AI returns both Owner Controller and Controlled Pawn</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">Event Receive Execute AI</strong> event will give you access to both <strong class="bold">Owner Controller</strong> and <strong class="bold">Controlled Pawn</strong>. You will use <strong class="bold">Controlled Pawn</strong> for this task in the upcoming steps.</p>
<ol>
<li value="9">Each <strong class="bold">Task</strong> requires a call to<a id="_idIndexMarker1109"/> the <strong class="source-inline">Finish Execute</strong> function so that the <strong class="source-inline">Behavior Tree</strong> asset knows when it can move on to the next <strong class="source-inline">Task</strong> or branches of the tree. <em class="italic">Right-click</em> in the graph and search for <strong class="source-inline">Finish Execute</strong> via the context-sensitive search.</li>
<li><em class="italic">Left-click</em> the <strong class="bold">Finish Execute</strong> option from the context-sensitive search to create the node inside the Blueprint graph of your <strong class="bold">Task</strong>, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer406">
<img alt="Figure 13.14 – The Finish Execute function, which has a Boolean parameter that determines whether the task is successful " height="180" src="image/Figure_13.14_B18531.jpg" width="293"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – The Finish Execute function, which has a Boolean parameter that determines whether the task is successful</p>
<ol>
<li value="11">The next function that you need is called <strong class="bold">GetRandomLocationInNavigableRadius</strong>. This function, as its name suggests, returns a random vector location within a defined radius of the navigable area. This will allow the enemy character to find random locations and move to those locations.</li>
<li><em class="italic">Right-click</em> in the graph and search for <strong class="source-inline">GetRandomLocationInNavigableRadius</strong> inside the context-sensitive search. <em class="italic">Left-click</em> the <strong class="bold">GetRandomLocationInNavigableRadius</strong> option to place this function inside the graph.</li>
</ol>
<p>With these two functions in<a id="_idIndexMarker1110"/> place, and with <strong class="bold">Event Receive Execute</strong> AI-ready, it is time to obtain the random location for the enemy AI.</p>
<ol>
<li value="13">From the <strong class="bold">Controlled Pawn</strong> output of <strong class="bold">Event Receive Execute AI</strong>, find the <strong class="source-inline">GetActorLocation</strong> function via the context-sensitive search:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer407">
<img alt="Figure 13.15 – The enemy pawn’s location will serve as the origin of the random point selection " height="296" src="image/Figure_13.15_B18531.jpg" width="873"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – The enemy pawn’s location will serve as the origin of the random point selection</p>
<ol>
<li value="14">Connect the vector return value from <strong class="bold">GetActorLocation</strong> to the <strong class="bold">Origin</strong> vector input parameter of the <strong class="source-inline">GetRandomLocationInNavigableRadius</strong> function, as shown in the following screenshot. Now, this function will use the enemy AI pawn’s location as the origin for determining the next random point:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer408">
<img alt="Figure 13.16 – Now, the enemy pawn location will be used as the origin of the random point vector search " height="298" src="image/Figure_13.16_B18531.jpg" width="922"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – Now, the enemy pawn location will be used as the origin of the random point vector search</p>
<ol>
<li value="15">Next, you need to tell the <strong class="source-inline">GetRandomLocationInNavigableRadius</strong> function the radius in which to check for the random point in the navigable area of the level. Set this <a id="_idIndexMarker1111"/>value to <strong class="source-inline">1000.0f</strong>.</li>
</ol>
<p>The remaining parameters, <strong class="source-inline">Nav Data</strong> and <strong class="source-inline">Filter Class</strong>, can remain as is. Now that you are getting a random location from <strong class="source-inline">GetRandomLocationInNavigableRadius</strong>, you will need to be able to store this value in the <strong class="source-inline">Blackboard</strong> vector that you created earlier in this exercise.</p>
<ol>
<li value="16">To get a reference to the <strong class="source-inline">Blackboard</strong> vector variable, you need to create a new variable inside of this <strong class="source-inline">Task</strong> that’s of the <strong class="source-inline">Blackboard Key Selector</strong> type. Create this new variable and name it <strong class="source-inline">NewLocation</strong>.</li>
<li>Now, you need to make this variable a <strong class="source-inline">Public</strong> variable so that it can be exposed inside the <strong class="source-inline">Behavior Tree</strong>. <em class="italic">Left-click</em> on the “eye” icon so that the eye is visible.</li>
<li>With the <strong class="source-inline">Blackboard Key Selector</strong> variable ready, <em class="italic">left-click</em> and drag out a <strong class="source-inline">Getter</strong> of this variable. Then, pull from this variable and search for <strong class="source-inline">Set Blackboard Value as Vector</strong>, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer409">
<img alt="Figure 13.17 – Set Blackboard Value has a variety of different types to support the different variables that can exist inside the Blackboard " height="194" src="image/Figure_13.17_B18531.jpg" width="691"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.17 – Set Blackboard Value has a variety of different types to support the different variables that can exist inside the Blackboard</p>
<ol>
<li value="19">Connect the <strong class="source-inline">RandomLocation</strong> output vector from <strong class="source-inline">GetRandomLocationInNavigableRadius</strong> to the <strong class="source-inline">Value</strong> vector input parameter of <strong class="source-inline">Set Blackboard Value as Vector</strong>. Then, connect the execution pins of these<a id="_idIndexMarker1112"/> two function nodes. The result will look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer410">
<img alt="Figure 13.18 – Now, the Blackboard vector value is assigned to this new random location " height="254" src="image/Figure_13.18_B18531.jpg" width="898"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.18 – Now, the Blackboard vector value is assigned to this new random location</p>
<p>Lastly, you will use the <strong class="source-inline">Return Value</strong> Boolean output parameter of the <strong class="source-inline">GetRandomLocationInNavigableRadius</strong> function to determine whether the task executes successfully.</p>
<ol>
<li value="20">Connect the Boolean output parameter to the <strong class="source-inline">Success</strong> input parameter of the <strong class="source-inline">Finish Execute</strong> function and connect the execution pins of the <strong class="bold">Set Blackboard Value as Vector</strong> and <strong class="bold">Finish Execute</strong> function nodes. The following screenshot shows the final result of the <strong class="bold">Task</strong> logic:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer411">
<img alt="Figure 13.19 – The final setup for the task " height="345" src="image/Figure_13.19_B18531.jpg" width="1627"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.19 – The final setup for the task</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/3lmLyk5">https://packt.live/3lmLyk5</a>.</p>
<p>By completing this exercise, you <a id="_idIndexMarker1113"/>have created your first custom <strong class="bold">Task</strong> using Blueprints in UE5. You now have a task that finds a random location within the navigable bounds of the <strong class="bold">Nav Mesh</strong> volume of your level that uses the enemy pawn as the origin of this search. In the next exercise, you will implement this new <strong class="bold">Task</strong> in the <strong class="source-inline">Behavior Tree</strong> and see the enemy AI move around your level.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor286"/>Exercise 13.06 – creating the behavior tree logic</h2>
<p>The goal of this exercise is to implement the <a id="_idIndexMarker1114"/>new task you created in the previous exercise inside the <strong class="source-inline">Behavior Tree</strong> to have the enemy AI find a random location within the navigable space of your level and then move to this location. You will use a combination of the <strong class="bold">Composite</strong>, <strong class="bold">Task</strong>, and <strong class="bold">Service</strong> nodes to accomplish this behavior. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">To start, open the <strong class="source-inline">Behavior Trees</strong> you created in <em class="italic">Exercise 13.04 – creating the AI behavior tree and Blackboard</em>, which is <strong class="source-inline">BT_EnemyAI</strong>. </li>
<li>Inside this <strong class="source-inline">Behavior Tree</strong>, <em class="italic">left-click</em> and drag from the bottom of the <strong class="source-inline">Root</strong> node and select the <strong class="bold">Sequence</strong> node from the context-sensitive search. The result will be the <strong class="source-inline">Root</strong> that’s connected to the <strong class="bold">Sequence</strong> Composite node.</li>
<li>Next, from the <strong class="bold">Sequence</strong> node, <em class="italic">left-click</em> and drag to bring up the context-sensitive menu. In this menu, search for the task you created in the previous exercise – that is, <strong class="bold">BTTask_FindLocation</strong>.</li>
<li>By default, the <strong class="bold">BTTask_FindLocation</strong> task should automatically assign the <strong class="bold">New Location</strong> Key Selector variable to the <strong class="bold">MovetoLocation</strong> vector variable from the <strong class="source-inline">Blackboard</strong>. If this doesn’t happen, you can assign this Selector manually in the <strong class="bold">Details</strong> panel of the task.</li>
</ol>
<p>Now, <strong class="bold">BTTask_FindLocation</strong> will assign the <strong class="bold">NewLocation</strong> Selector to the <strong class="bold">MovetoLocation</strong> vector variable from <strong class="source-inline">Blackboard</strong>. This means that the random location that’s returned from the task will be assigned to the <strong class="source-inline">Blackboard</strong> variable<a id="_idIndexMarker1115"/> and you can reference this variable in other tasks.</p>
<p>Now that you have found a valid random location and assigned this location to the <strong class="source-inline">Blackboard</strong> variable – that is, <strong class="bold">MovetoLocation</strong> – you can use the <strong class="bold">Move To</strong> task to tell the AI to move to this location.</p>
<ol>
<li value="5"><em class="italic">Left-click</em> and pull from the <strong class="bold">Sequence</strong> Composite node. Then, from the context-sensitive search, find the <strong class="bold">Move To</strong> task. Your <strong class="source-inline">Behavior Tree</strong> will now look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer412">
<img alt="Figure 13.20 – After selecting the random location, the Move To task will let the AI move to this new location " height="500" src="image/Figure_13.20_B18531.jpg" width="815"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.20 – After selecting the random location, the Move To task will let the AI move to this new location</p>
<ol>
<li value="6">By default, the <strong class="bold">Move To</strong> task should assign <strong class="bold">MoveToLocation</strong> as its <strong class="bold">Blackboard Key</strong> value. If it doesn’t, select the task. In its <strong class="bold">Details</strong> panel, you will find the <strong class="bold">Blackboard Key</strong> parameter, which is where you can assign the variable. While in the <strong class="bold">Details</strong> panel, also set <strong class="bold">Acceptable Radius</strong> to <strong class="source-inline">50.0f</strong>.</li>
</ol>
<p>Now, the <strong class="source-inline">Behavior Tree</strong> finds the<a id="_idIndexMarker1116"/> random location using the <strong class="bold">BTTask_FindLocation</strong> custom task and tells the AI to move to that location using the <strong class="bold">Move To</strong> task. These two tasks communicate the location to each other by referencing the <strong class="source-inline">Blackboard</strong> vector variable called <strong class="bold">MovetoLocation</strong>.</p>
<p>The last thing to do here is to add a decorator to the <strong class="bold">Sequence</strong> Composite node so that the enemy character is not at a random location before the tree is executed again to find and move it to that new location.</p>
<ol>
<li value="7"><em class="italic">Right-click</em> on the top area of the <strong class="bold">Sequence</strong> node and select <strong class="bold">Add Decorator</strong>. From the dropdown, <em class="italic">left-click</em> and select <strong class="bold">Is at Location</strong>.</li>
<li>Since you already have a vector parameter inside <strong class="source-inline">Blackboard</strong>, the <strong class="bold">Is at Location</strong> decorator should automatically assign the <strong class="bold">MoveToLocation</strong> vector variable as <strong class="bold">Blackboard Key</strong>. Verify this by selecting the decorator and making sure <strong class="bold">Blackboard Key</strong> is assigned to <strong class="bold">MoveToLocation</strong>.</li>
<li>With the decorator in place, you have completed the <strong class="source-inline">Behavior Tree</strong>. The final result will look as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer413">
<img alt="Figure 13.21 – The final setup for the behavior tree for the AI enemy " height="554" src="image/Figure_13.21_B18531.jpg" width="947"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.21 – The final setup for the behavior tree for the AI enemy</p>
<p>This <strong class="source-inline">Behavior Tree</strong> is telling the AI to find a random location using <strong class="bold">BTTask_FindLocation</strong> and assign <a id="_idIndexMarker1117"/>this location to the <strong class="source-inline">Blackboard</strong> <strong class="bold">MoveToLocation</strong> value. When this task is successful, the <strong class="source-inline">Behavior Tree</strong> will execute the <strong class="bold">Move To</strong> task, which will tell the AI to move to this new random location. The <strong class="bold">Sequence</strong> node is wrapped in a decorator that ensures that the enemy AI is at <strong class="bold">MoveToLocation</strong> before executing again, just as a safety net for the AI.</p>
<ol>
<li value="10">Before you can test the new AI behavior, make sure that you have placed <strong class="bold">BP_Enemy AI</strong> into your level if one is not already there from previous exercises and activities.</li>
<li>Now, if you use <strong class="bold">PIE</strong> or <strong class="bold">Simulate</strong>, you will see the enemy AI run around the map and move to random<a id="_idIndexMarker1118"/> locations within the <strong class="bold">Nav Mesh Volume</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer414">
<img alt="Figure 13.22 – The enemy AI will now move from location to location " height="651" src="image/Figure_13.22_B18531.jpg" width="1106"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.22 – The enemy AI will now move from location to location</p>
<p class="callout-heading">Note</p>
<p class="callout">There can be some cases where the enemy AI will not move. This can be caused by the GetRandomLocationInNavigableRadius function not returning <strong class="source-inline">True</strong>. This is a known issue, and if it occurs, please restart the editor and try again.</p>
<ol>
<li value="12">By completing this exercise, you have created a fully functional <strong class="source-inline">Behavior Tree</strong> that allows the enemy AI to find and move to a random location within the navigable bounds of your level using<strong class="bold"> </strong>the <strong class="bold">Nav Mesh Volume</strong>. The task you created in the previous exercise allows you to find this random point, while the <strong class="bold">Move To</strong> task allows the AI character to move toward this new location.</li>
</ol>
<p>Due to how the <strong class="bold">Sequence</strong> Composite node works, each task must complete successfully before it can move on to the next task, so first, the enemy successfully finds a random location and then moves toward this location. Only when the <strong class="bold">Move To</strong> task completes will the entire <strong class="source-inline">Behavior Tree</strong> start over and choose a new random location.</p>
<p>Now, you can move on to<a id="_idIndexMarker1119"/> the next activity, where you will add to this <strong class="source-inline">Behavior Tree</strong> to have the AI wait between selecting a new random point so that the enemy isn’t constantly moving.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor287"/>Activity 13.02 – AI moving to the player’s location</h2>
<p>In the previous exercise, you made the AI enemy character move to random locations within the bounds of <strong class="bold">Nav Mesh</strong> Volume <a id="_idIndexMarker1120"/>by using a custom <strong class="bold">Task</strong> and the <strong class="bold">Move To</strong> task together.</p>
<p>In this activity, you will continue from the previous exercise and update the <strong class="source-inline">Behavior Tree</strong>. You will take advantage of the <strong class="bold">Wait</strong> task by using a decorator, and also create a new custom task to have the AI follow the player character and update its position every few seconds. </p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Inside the <strong class="bold">BT_EnemyAI Behavior Tree</strong> that you created in the previous exercise, you will continue from where you left off and create a new task. Do this by selecting <strong class="bold">New Task</strong> from the toolbar and choosing <strong class="bold">BTTask_BlueprintBase</strong>. Name this new task <strong class="bold">BTTask_FindPlayer</strong>.</li>
<li>In the <strong class="bold">BTTask_FindPlayer</strong> task, create a new event called <strong class="bold">Event Receive Execute AI</strong>.</li>
<li>Find the <strong class="source-inline">Get Player Character</strong> function to get a reference to the player; make sure that you use <strong class="bold">Player Index 0</strong>. </li>
<li>From the player character, call the <strong class="source-inline">Get Actor Location</strong> function to find the player’s current location.</li>
<li>Create a new <strong class="source-inline">Blackboard</strong> Key <strong class="source-inline">Selector</strong> variable inside this task. Name this variable <strong class="source-inline">NewLocation</strong>.</li>
<li><em class="italic">Left-click</em> and drag the <strong class="source-inline">NewLocation</strong> variable into the graph. From this variable, search for the <strong class="source-inline">Set Blackboard Value</strong> function as a <strong class="source-inline">Vector</strong>.</li>
<li>Connect <strong class="bold">Set Blackboard Value</strong> as a <strong class="source-inline">Vector</strong> function to the execution pin of the event’s <strong class="bold">Receive Execute AI</strong> node.</li>
<li>Add the <strong class="source-inline">Finish Execute</strong> function, ensuring that the Boolean <strong class="bold">Success</strong> parameter is <strong class="source-inline">True</strong>.</li>
<li>Lastly, connect <strong class="bold">Set Blackboard Value</strong> as a <strong class="source-inline">Vector</strong> function to the <strong class="source-inline">Finish Execute</strong> function.</li>
<li>Save and compile the task Blueprint and return to the<strong class="source-inline">BT_EnemyAI</strong> <strong class="source-inline">Behavior Tree</strong>.</li>
<li>Replace the <strong class="bold">BTTask_FindLocation</strong> task with the new <strong class="bold">BTTask_FindPlayer</strong> task so that this new task is <a id="_idIndexMarker1121"/>now the first task underneath the <strong class="bold">Sequence</strong> Composite node.</li>
<li>Add a new <strong class="source-inline">PlaySound</strong> task as the third task underneath the <strong class="bold">Sequence</strong> Composite node by following the custom <strong class="bold">BTTask_FindLocation</strong> and <strong class="bold">Move To</strong> tasks.</li>
<li>In the <strong class="source-inline">Sound to Play</strong> parameter, add the <strong class="bold">Explosion_Cue SoundCue</strong> asset.</li>
<li>Add an <strong class="bold">Is At Location</strong> decorator to the <strong class="bold">PlaySound</strong> task and ensure that the <strong class="bold">MovetoLocation</strong> Key is assigned to this <strong class="bold">Decorator</strong>.</li>
<li>Add a new <strong class="bold">Wait</strong> task as the fourth task underneath the <strong class="bold">Sequence</strong> Composite node following the <strong class="bold">PlaySound</strong> tasks.</li>
<li>Set the <strong class="bold">Wait</strong> task to wait <strong class="source-inline">2.0f</strong> seconds before completing successfully. </li>
</ol>
<p>The expected output is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer415">
<img alt="Figure 13.23 – Enemy AI following the player and updating to the player’s location every 2 seconds " height="597" src="image/Figure_13.23_B18531.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.23 – Enemy AI following the player and updating to the player’s location every 2 seconds</p>
<p>The enemy AI character will move to the <a id="_idIndexMarker1122"/>player’s last known location in the navigable space of the level and pause for <strong class="source-inline">2.0f</strong> seconds between each player position. </p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity complete, you have learned how to create a new task that allows the AI to find the player’s location and move to the player’s last known position. Before moving on to the next set of exercises, remove the <strong class="bold">PlaySound</strong> task and replace the <strong class="bold">BTTask_FindPlayer</strong> task with the <strong class="bold">BTTask_FindLocation</strong> task you created in <em class="italic">Exercise 13.05 – creating a new behavior tree task</em>. Please refer to <em class="italic">Exercise 13.05 – creating a new behavior tree task</em>, and <em class="italic">Exercise 13.06 – creating the behavior tree logic</em>, to ensure the <strong class="source-inline">Behavior</strong> <strong class="source-inline">Tree</strong> is returned correctly. You will be using the <strong class="bold">BTTask_FindLocation</strong> task in the upcoming exercises.</p>
<p>In the next exercise, you will address this issue by developing a new Blueprint actor that will allow you to set up specific positions that the AI can move toward.</p>
<h2 id="_idParaDest-260">Exercise<a id="_idTextAnchor288"/> 13.07 – creating the enemy patrol locations</h2>
<p>The current issue <a id="_idIndexMarker1123"/>with the AI enemy character is that they can move freely around the 3D navigable space because the <strong class="source-inline">Behavior Tree</strong> allows them to find a random location within that space. Instead, the AI needs to be given patrol points that you can specify and change in the editor. Then, it will choose one of these patrol points at random to move to. This is what you will do for the <strong class="source-inline">SuperSideScroller</strong> game: create patrol points that the enemy AI can move to. This exercise will show you how to create these patrol points using a simple <strong class="bold">Blueprint</strong> actor. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, navigate to the <strong class="bold">/Enemy/Blueprints/</strong> directory. This is where you will create the new Blueprint actor that will be used for the AI patrol points.</li>
<li>In this directory, <em class="italic">right-click</em> and choose the <strong class="bold">Blueprint Class</strong> option by <em class="italic">left-clicking</em> this option from the menu.</li>
<li>From the <strong class="bold">Pick Parent Class</strong> menu prompt, <em class="italic">left-click</em> the <strong class="bold">Actor</strong> option to create a new Blueprint based on the <strong class="source-inline">Actor</strong> class:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer416">
<img alt="Figure 13.24 – The Actor class is the base class for all objects that can be placed or spawned in the game world " height="105" src="image/Figure_13.24_B18531.jpg" width="634"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.24 – The Actor class is the base class for all objects that can be placed or spawned in the game world</p>
<ol>
<li value="4">Name this new asset <strong class="bold">BP_AIPoints</strong> and open this Blueprint by <em class="italic">double-clicking</em> the asset in the <strong class="bold">Content Drawer</strong> interface.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The interface for Blueprints shares many of the same features and layouts as other systems, such as Animation Blueprints and tasks, so this should all look familiar to you.</p>
<ol>
<li value="5">Navigate to the <strong class="bold">Variables</strong> tab on the left-hand side of the Blueprint UI and <em class="italic">left-click</em> on the <strong class="bold">+Variable</strong> button. Name this variable <strong class="source-inline">Points</strong>.</li>
<li>From the <strong class="bold">Variable Type</strong> dropdown, <em class="italic">left-click</em> and select the <strong class="bold">Vector</strong> option.</li>
<li>Next, you will need to make this vector variable an <strong class="bold">Array</strong> so that you can store multiple patrol locations. <em class="italic">Left-click</em> the yellow icon next to <strong class="bold">Vector</strong> and <em class="italic">left-click</em> to select the <strong class="bold">Array</strong> option.</li>
<li>The last step for setting up the <strong class="bold">Points</strong> vector variable is to enable <strong class="bold">Instance</strong> <strong class="bold">Editable</strong> and <strong class="bold">Show 3D Widget</strong>:<ul><li>The <strong class="bold">Instance Editable</strong> parameter allows this vector variable to be publicly visible on the actor when placed in a level, allowing each instance of this actor to have this variable available to edit.</li><li><strong class="bold">Show 3D Widget</strong> allows you to position the vector value by using a visible 3D transform widget in the <a id="_idIndexMarker1124"/>editor viewport. You will see what this means in the next steps of this exercise. It is also important to note that the <strong class="source-inline">Show</strong> <strong class="bold">3D Widget</strong> option is only available for variables that involve an actor transform, such as vectors and transforms.</li></ul></li>
</ol>
<p>With the simple actor set up, it is time to place the actor in the level and begin setting up the patrol point locations.</p>
<ol>
<li value="9">Add the <strong class="bold">BP_AIPoints</strong> actor Blueprint to your level, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer417">
<img alt="Figure 13.25 – The BP_AIPoints actor is now in the level " height="681" src="image/Figure_13.25_B18531.jpg" width="1037"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.25 – The BP_AIPoints actor is now in the level</p>
<ol>
<li value="10">With the <strong class="bold">BP_AIPoints</strong> actor selected, navigate to its <strong class="bold">Details</strong> panel and find the <strong class="bold">Points</strong> variable.</li>
<li>Next, you can add a new <a id="_idIndexMarker1125"/>element to the vector array by <em class="italic">left-clicking</em> on the <strong class="bold">+</strong> symbol, as shown here:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer418">
<img alt="Figure 13.26 – You can have many elements inside an array, but the larger the array, the more memory is allocated " height="95" src="image/Figure_13.26_B18531.jpg" width="691"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.26 – You can have many elements inside an array, but the larger the array, the more memory is allocated</p>
<ol>
<li value="12">When you add a new element to the vector array, you will see a 3D widget appear that you can then <em class="italic">left-click</em> to select and move around the level, as shown here:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer419">
<img alt="Figure 13.27 – The first patrol point vector location " height="259" src="image/Figure_13.27_B18531.jpg" width="554"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.27 – The first patrol point vector location</p>
<p class="callout-heading">Note</p>
<p class="callout">As you update the position of the 3D widget that represents the element of the vector array, the 3D coordinates will update in the <strong class="bold">Details</strong> panel for the <strong class="bold">Points</strong> variable.</p>
<ol>
<li value="13">Finally, add as many<a id="_idIndexMarker1126"/> elements into the vector array as you would like for the context of your level. Keep in mind that the positions of these patrol points should line up so that they make a straight line along the horizontal axis, parallel to the direction in which the character will move. The following screenshot shows the setup in the example <strong class="source-inline">SideScroller.umap</strong> level that’s included in this exercise:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer420">
<img alt="Figure 13.28 – The example patrol point path, as seen in the SideScroller.umap example level " height="651" src="image/Figure_13.28_B18531.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.28 – The example patrol point path, as seen in the SideScroller.umap example level</p>
<ol>
<li value="14">Continue to repeat the previous step to create multiple patrol points and position the 3D widgets as you see fit. You can use the provided <strong class="bold">SideScroller.umap</strong> example level as a reference on how to set up these patrol points. </li>
</ol>
<p>By completing this exercise, you <a id="_idIndexMarker1127"/>have created a new <strong class="bold">Actor</strong> Blueprint that contains a <strong class="bold">Vector</strong> array of positions that you can now manually set using a 3D widget in the editor. With the ability to manually set the patrol point positions, you have full control over where the AI can move. However, there is a problem: there is no functionality in place to choose a point from this array and pass it to the <strong class="source-inline">Behavior Tree</strong> so that the AI can move between these patrol points. Before you set up this functionality, let’s learn a bit more about vectors and Vector Transformation, as this knowledge will prove useful in the next exercise.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor289"/>Vector Transformation</h1>
<p>Before you jump <a id="_idIndexMarker1128"/>into the next exercise, it is important that you learn about Vector Transformation and, more importantly, what the <strong class="source-inline">Transform Location</strong> function does. When it comes to an actor’s location, there are two ways of thinking of its position: in terms of world space and local space. An actor’s position in world space is its location relative to the world itself; in more simple terms, this is the location where you place the actor in the level. An actor’s local position is its location relative to either itself or a parent actor. </p>
<p>Let’s consider the <strong class="bold">BP_AIPoints</strong> actor as an example of what world space and local space are. Each of the locations of the <strong class="bold">Points</strong> array is a local-space vector because they are positions relative to the world-space position of the <strong class="bold">BP_AIPoints</strong> actor itself. The following screenshot shows the list of vectors in the <strong class="bold">Points</strong> array, as shown in the previous exercise. These values are positions relative to the location of the <strong class="bold">BP_AIPoints</strong> actor in your level:</p>
<div>
<div class="IMG---Figure" id="_idContainer421">
<img alt="Figure 13.29 – The local-space position vectors of the Points array, relative to the world-space position of the BP_AIPoints actor " height="287" src="image/Figure_13.29_B18531.jpg" width="881"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.29 – The local-space position vectors of the Points array, relative to the world-space position of the BP_AIPoints actor</p>
<p>To have the enemy AI <a id="_idIndexMarker1129"/>move to the correct world space location of these points, you need to use a function called <strong class="source-inline">Transform Location</strong>. This function takes in two parameters:</p>
<ul>
<li><strong class="source-inline">T</strong>: This is the supplied transform that you will use to convert the vector location parameter from a local-space value into a world-space value.</li>
<li><strong class="source-inline">Location</strong>: This is the location that is to be converted from local space into world space.</li>
</ul>
<p>The result of this Vector Transformation is then returned as the return value of the function. You will use this function in the next exercise to return a randomly selected vector point from the <strong class="source-inline">Points</strong> array and convert that value from a local-space vector into a world-space vector. This new world-space vector will then be used to tell the enemy AI where to move relative to <a id="_idIndexMarker1130"/>the world. Let’s implement this now. </p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor290"/>Exercise 13.08 – selecting a random point in an array</h2>
<p>Now that you know more about vectors <a id="_idIndexMarker1131"/>and Vector Transformation, in this exercise, you will create a simple <strong class="source-inline">Blueprint</strong> function to select one of the <em class="italic">patrol point</em> vector locations and transform its vector from a local space value into a world space value using a built-in function called <strong class="bold">Transform Location</strong>. By returning the world space value of the vector position, you can then pass this value to the <strong class="source-inline">Behavior Tree</strong> so that the AI will move to the correct position. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise. Let’s start by creating the new function:</p>
<ol>
<li value="1">Navigate back to the <strong class="bold">BP_AIPoints</strong> Blueprint and create a new function by <em class="italic">left-clicking</em> the <strong class="bold">+</strong> button next to the <strong class="bold">Functions</strong> category on the left-hand side of the Blueprint editor. Name this function <strong class="source-inline">GetNextPoint</strong>.</li>
<li>Before you add logic to this function, select this function by <em class="italic">left-clicking</em> it under the <strong class="bold">Functions</strong> category to access its <strong class="bold">Details</strong> panel.</li>
<li>In the <strong class="bold">Details</strong> panel, enable the <strong class="bold">Pure</strong> parameter so that this function is labeled as a <strong class="bold">Pure Function</strong>. You learned about <strong class="bold">Pure Functions</strong> in <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>, when working in the Animation Blueprint for the player character; the same thing is happening here.</li>
<li>Next, the <strong class="source-inline">GetNextPoint</strong> function needs to return a vector that the <strong class="source-inline">Behavior Tree</strong> can use to tell the enemy AI where to move to. Add this new output by <em class="italic">left-clicking</em> on the <strong class="bold">+</strong> symbol under the <strong class="bold">Outputs</strong> category of the <strong class="bold">Details</strong> function. Make the variable of the <strong class="bold">Vector</strong> type and name it <strong class="source-inline">NextPoint</strong>, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer422">
<img alt="Figure 13.30 – Functions can return multiple variables of different types, depending on the needs of your logic " height="67" src="image/Figure_13.30_B18531.jpg" width="688"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.30 – Functions can return multiple variables of different types, depending on the needs of your logic</p>
<ol>
<li value="5">When adding an <strong class="bold">Output</strong> variable, the function will automatically generate a <strong class="bold">Return</strong> node and place it in the <a id="_idIndexMarker1132"/>function graph, as shown in the following screenshot. You will use this output to return the new vector patrol point for the enemy AI to move to:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer423">
<img alt="Figure 13.31 – The automatically generated Return Node for the function, including the Next Point vector output variable " height="202" src="image/Figure_13.31_B18531.jpg" width="690"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.31 – The automatically generated Return Node for the function, including the Next Point vector output variable</p>
<p>Now that the function’s groundwork is completed, let’s start adding the logic.</p>
<ol>
<li value="6">To pick a random position, first, you need to find the length of the <strong class="source-inline">Points</strong> array. Create a <strong class="bold">Getter</strong> of the <strong class="source-inline">Points</strong> vector and from this vector variable, <em class="italic">left-click</em> and drag to search for the <strong class="source-inline">Length</strong> function, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer424">
<img alt="Figure 13.32 – The Length function is a pure function that returns the length of the array " height="256" src="image/Figure_13.32_B18531.jpg" width="892"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.32 – The Length function is a pure function that returns the length of the array</p>
<ol>
<li value="7">With the integer output of the <strong class="source-inline">Length</strong> function, <em class="italic">left-click</em> and drag out to use the context-sensitive <a id="_idIndexMarker1133"/>search to find the <strong class="source-inline">Random Integer</strong> function, as shown in the following screenshot. The <strong class="source-inline">Random Integer</strong> function returns a random integer between <strong class="source-inline">0</strong> and <strong class="source-inline">Max value</strong>; in this case, this is the length of the <strong class="source-inline">Points</strong> vector array:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer425">
<img alt="Figure 13.33 – Using Random Integer will allow the function to return a random vector from the Points vector array " height="268" src="image/Figure_13.33_B18531.jpg" width="1059"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.33 – Using Random Integer will allow the function to return a random vector from the Points vector array</p>
<p>Here, you are generating a random integer between 0 and the length of the <strong class="source-inline">Points</strong> vector array. Next, you need to find the element of the <strong class="source-inline">Points</strong> vector array at the index position of the returned <strong class="source-inline">Random Integer</strong> function.</p>
<ol>
<li value="8">Do this by creating a new <strong class="source-inline">Getter of the Points</strong> vector array. Then, <em class="italic">left-click</em> and drag to search for the <strong class="source-inline">Get(a copy)</strong>function.</li>
<li>Next, connect the return value of the <strong class="source-inline">Random Integer</strong> function to the input of the <strong class="source-inline">Get (a copy)</strong> function. This will tell the function to choose a random integer and use that integer as the index to return from the <strong class="source-inline">Points</strong> vector array.</li>
</ol>
<p>Now that you are getting a random vector from the <strong class="source-inline">Points</strong> vector array, you need to use the <strong class="source-inline">Transform Location</strong> function to convert the location from a local space vector into a world space vector.</p>
<p>As you have learned <a id="_idIndexMarker1134"/>already, the vectors in the <strong class="source-inline">Points</strong> vector array are local space positions relative to the position of the <strong class="source-inline">BP_AIPoints</strong> actor in the level. As a result, you need to use the <strong class="source-inline">Transform Location</strong> function to convert the randomly selected local space vector into a world space vector so that the AI enemy moves to the correct position.</p>
<ol>
<li value="10"><em class="italic">Left-click</em> and drag from the vector output of the <strong class="source-inline">Get(a copy)</strong>function and, via the context-sensitive search, find the <strong class="source-inline">Transform Location</strong> function.</li>
<li>Connect the vector output of the <strong class="source-inline">Get(a copy)</strong>function to the <strong class="source-inline">Location</strong> input of the <strong class="source-inline">Transform Location</strong> function.</li>
<li>The final step is to use the transform of the Blueprint actor itself as the <strong class="source-inline">T</strong> parameter of the <strong class="source-inline">Transform Location</strong> function. Do this by <em class="italic">right-clicking</em> inside the graph and, via the context-sensitive search, finding the <strong class="source-inline">GetActorTransform</strong> function and connecting it to the <strong class="source-inline">Transform Location</strong> parameter, <strong class="source-inline">T</strong>. </li>
<li>Finally, connect the <strong class="source-inline">Return Value</strong> vector from the <strong class="source-inline">Transform Location</strong> function and connect it to the <strong class="source-inline">NewPoint</strong> vector output of the function:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer426">
<img alt="Figure 13.34 – The final logic has been set up for the GetNextPoint function " height="481" src="image/Figure_13.34_B18531.jpg" width="1106"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.34 – The final logic has been set up for the GetNextPoint function</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/35jlilb">https://packt.live/35jlilb</a>.</p>
<p>By completing this exercise, you have created a new Blueprint function inside the <strong class="bold">BP_AIPoints</strong> actor that takes a<a id="_idIndexMarker1135"/> random index from the <strong class="source-inline">Points</strong> array variable, transforms it into a world space vector value using the <strong class="source-inline">Transform Location</strong> function, and returns this new vector value. You will use this function inside the <strong class="bold">BTTask_FindLocation</strong> task, inside the AI <strong class="source-inline">Behavior Tree</strong>, so that the enemy will move to one of the points you have set up. Before you can do this, the enemy AI needs a reference to the <strong class="bold">BP_AIPoints</strong> actor so that it knows which points it can select from and move to. We’ll do this in the following exercise.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor291"/>Exercise 13.09 – referencing the patrol point actor</h2>
<p>Now that the <strong class="bold">BP_AIPoints</strong> actor has a function that returns a random transformed location from its array of vector patrol points, you<a id="_idIndexMarker1136"/> need to have the enemy AI reference this actor in the level so that it knows which patrol points to reference. To do this, you will add a new <strong class="source-inline">Object Reference</strong> variable to the enemy character Blueprint and assign the <strong class="bold">BP_AIPoints</strong> actor that you placed in your level earlier. This exercise will be performed within the UE5 editor. Let’s get started by adding the <strong class="source-inline">Object Reference</strong> variable.</p>
<p class="callout-heading">Note</p>
<p class="callout">An <strong class="source-inline">Object Reference</strong> variable stores a reference to a specific class object or actor. With this variable, you can get access to the publicly exposed variables, events, and functions that this class has available.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Navigate to the <strong class="source-inline">/Enemy/Blueprints/</strong> directory and open the enemy character Blueprint, <strong class="bold">BP_Enemy</strong>, by <em class="italic">double-clicking</em> the asset from <strong class="bold">the Content Drawer</strong> interface.</li>
<li>Create a new variable of the <strong class="source-inline">BP_AIPoints</strong> type and make sure the variable is of the <strong class="source-inline">Object Reference</strong> variable type.</li>
<li>To reference the existing <strong class="bold">BP_AIPoints</strong> actor in your level, you need to make the variable from the previous step a <strong class="bold">Public Variable</strong> by enabling the <strong class="source-inline">Instance Editable</strong> parameter. Name this variable <strong class="source-inline">Patrol Points</strong>.</li>
<li>Now that you have set the object reference, navigate to your level and select your enemy AI. The following screenshot shows the enemy AI placed in the provided example level – that is, <strong class="source-inline"> SuperSideScroller.umap</strong>. If you don’t have an enemy in your level, please place one now:</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Placing an enemy into a level works the same as it does for any other actor in UE5: <em class="italic">left-click</em> and drag the enemy AI Blueprint from the <strong class="bold">Content Drawer</strong> interface into the level.</p>
<div>
<div class="IMG---Figure" id="_idContainer427">
<img alt="Figure 13.35 – The enemy AI placed in the SuperSideScroller.umap level " height="471" src="image/Figure_13.35_B18531.jpg" width="1461"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.35 – The enemy AI placed in the SuperSideScroller.umap level</p>
<ol>
<li value="5">From its <strong class="bold">Details</strong> panel, find the <strong class="source-inline">Patrol Points</strong> variable under the <strong class="bold">Default</strong> category. The last thing to must do is assign the <strong class="source-inline">BP_AIPoints</strong> actor we already placed in the<a id="_idIndexMarker1137"/> level in <em class="italic">Exercise 13.07 – creating the enemy patrol locations</em>. Do this by <em class="italic">left-clicking</em> the dropdown menu for the <strong class="source-inline">Patrol Points</strong> variable and finding the actor from the list.</li>
</ol>
<p>With this exercise complete, the enemy AI in your level now has a reference to the <strong class="bold">BP_AIPoints</strong> actor in your level. With a valid reference in place, the enemy AI can use this actor to determine which set of points to move between inside the <strong class="bold">BTTask_FindLocation</strong> task. All that is left to do now is update the <strong class="bold">BTTask_FindLocation</strong> task so that it uses these points instead of finding a random location.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor292"/>Exercise 13.10 – updating BTTask_FindLocation</h2>
<p>The final step in completing the enemy AI patrolling behavior is to replace the logic inside <strong class="bold">BTTask_FindLocation</strong> so that it <a id="_idIndexMarker1138"/>uses the <strong class="source-inline">GetNextPoint</strong> function from the <strong class="bold">BP_AIPoints</strong> actor instead of finding a random location within the navigable space of your level. This exercise will be performed within the UE5 editor.</p>
<p>As a reminder, go back to <em class="italic">Exercise 13.05 – creating a new behavior tree task</em>, and see what the <strong class="bold">BTTask_FindLocation</strong> task looked like before you start.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, you must take the returned <strong class="bold">Controlled Pawn</strong> reference from <strong class="bold">Event Receive Execute AI</strong> and cast it to <strong class="bold">BP_Enemy</strong>, as shown in the following screenshot. This way, you can access the <strong class="source-inline">Patrol Points</strong> object reference variable from the previous exercise:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer428">
<img alt="Figure 13.36 – Casting also ensures that the returned Controlled Pawn is of the BP_Enemy class type " height="222" src="image/Figure_13.36_B18531.jpg" width="1154"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.36 – Casting also ensures that the returned Controlled Pawn is of the BP_Enemy class type</p>
<ol>
<li value="2">Next, you can access the <strong class="source-inline">Patrol Points</strong> object reference variable by <em class="italic">left-clicking</em> and dragging from the <strong class="bold">As BP Enemy</strong> pin under the cast to <strong class="bold">BP_Enemy</strong> and, via the context-sensitive search, finding <strong class="source-inline">Patrol Points</strong>. </li>
<li>From the <strong class="source-inline">Patrol Points</strong> reference, you can <em class="italic">left-click</em> and drag to search for the <strong class="source-inline">GetNextPoint</strong> function that you created in <em class="italic">Exercise 13.08 – selecting a random point in an array</em>.</li>
<li>Now, you can connect the <strong class="source-inline">NextPoint</strong> vector output parameter of the <strong class="source-inline">GetNextPoint</strong> function to the <strong class="source-inline">Set Blackboard Value as Vector</strong> function and connect the execution pins from the cast to the <strong class="source-inline">Set Blackboard Value as Vector</strong> function. Now, each time the <strong class="bold">BTTask_FindLocation</strong> task is executed, a new random patrol point will be set.</li>
<li>Lastly, connect the <strong class="source-inline">Set Blackboard Value as Vector</strong> function to the <strong class="source-inline">Finish Execute</strong> function and manually set the <strong class="source-inline">Success</strong> parameter to <strong class="source-inline">True</strong> so that this task will always succeed if the cast is successful.</li>
<li>As a failsafe, create a duplicate of <strong class="bold">Finish Execute</strong> and connect it to the <strong class="bold">Cast Failed</strong> execution pin of the <strong class="source-inline">Cast</strong> function. Then, set the <strong class="source-inline">Success</strong> parameter to <strong class="source-inline">False</strong>. This will act as a failsafe so that if, for any reason, <strong class="bold">Controlled Pawn</strong> is not of the <strong class="source-inline">BP_Enemy</strong> class, the task will fail. This is a good debugging practice to ensure the <a id="_idIndexMarker1139"/>functionality of the task for its intended AI class:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer429">
<img alt="Figure 13.37 – It is always good practice to account for any casting failures in your logic " height="365" src="image/Figure_13.37_B18531.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.37 – It is always good practice to account for any casting failures in your logic</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/3n58THA">https://packt.live/3n58THA</a>.</p>
<p>With the <strong class="bold">BTTask_FindLocation</strong> task updated to use the random patrol point from the <strong class="bold">BP_AIPoints</strong> actor reference in the enemy, the enemy AI will now move between the patrol points at random:</p>
<div>
<div class="IMG---Figure" id="_idContainer430">
<img alt="Figure 13.38 – The enemy AI is now moving between the patrol point locations in the level " height="536" src="image/Figure_13.38_B18531.jpg" width="1224"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.38 – The enemy AI is now moving between the patrol point locations in the level</p>
<p>With this exercise complete, the enemy AI now uses the reference to the <strong class="bold">BP_AIPoints</strong> actor in the level to find and move to the patrol points in the level. Each instance of the enemy character in the level <a id="_idIndexMarker1140"/>can have a reference to another unique instance of the <strong class="bold">BP_AIPoints</strong> actor or can share the same instance reference. It is up to you how you would like each enemy AI to move throughout the level.</p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor293"/>Player projectile</h1>
<p>For the last section of this chapter, you <a id="_idIndexMarker1141"/>will focus on creating the base of the player projectile, which can be used to destroy enemies. The goal is to create the appropriate actor class, introduce the required collision and projectile movement components to the class, and set up the necessary parameters for the projectile’s motion behavior.</p>
<p>For the sake of simplicity, the player projectile will not use gravity, will destroy enemies with one hit, and the projectile itself will be destroyed on hitting any surface; it will not bounce off walls, for example. The primary goal of the player projectile is to have a projectile that the player can spawn and use to destroy enemies throughout the level. In this chapter, you will set up the framework’s basic functionality, while in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, you will add sound and visual effects. Let’s get started by creating the <strong class="source-inline">PlayerProjectile</strong> class.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor294"/>Exercise 13.11 – creating the player projectile</h2>
<p>So far, we have been working in the UE5 editor to create our enemy AI. For the <strong class="source-inline">player projectile</strong> class, we will be using C++ and Visual Studio. The player projectile will allow the player to destroy enemies that <a id="_idIndexMarker1142"/>are placed in the level. This projectile will have a short lifespan, travel at a high speed, and collide with both enemies and the environment.</p>
<p>The goal of this exercise is to set up the base actor class for the player projectile and begin outlining the functions and components needed in the header file for the projectile.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, you will need to create a new C++ class by using the <strong class="source-inline">Actor</strong> class as the parent class for the player projectile. Next, name this new actor class <strong class="source-inline">PlayerProjectile</strong> and <em class="italic">left-click</em> on the <strong class="bold">Create Class</strong> option at the bottom right of the menu prompt.</li>
</ol>
<p>After creating the new class, Visual Studio will generate the required source and header files for the class and open these files for you. The <strong class="source-inline">Actor</strong> base class comes included with a handful of default functions that you will not need for the player projectile. </p>
<ol>
<li value="2">Find the following lines of code inside the <strong class="source-inline">PlayerProjectile.h</strong> file and remove them:<p class="source-code">protected:</p><p class="source-code">  // Called when the game starts or when spawned</p><p class="source-code">  virtual void BeginPlay() override;</p><p class="source-code">public:</p><p class="source-code">  // Called every frame</p><p class="source-code">  virtual void Tick(float DeltaTime) override;</p></li>
</ol>
<p>These lines of code represent the declarations of the <strong class="source-inline">Tick()</strong> and <strong class="source-inline">BeginPlay()</strong> functions that are included in every Actor-based class by default. The <strong class="source-inline">Tick()</strong> function is called on every frame and allows you to perform logic on every frame, which can get expensive, depending on what you are trying to do. The <strong class="source-inline">BeginPlay() </strong>function is called when this actor is initialized and play has started. This can be used to perform logic on the actor as soon as it enters the world. We are removing these functions because they are not required for the player projectile and will just clutter the code.</p>
<ol>
<li value="3">After removing these lines <a id="_idIndexMarker1143"/>from the <strong class="source-inline">PlayerProjectile.h</strong> header file, you can remove the following lines from the <strong class="source-inline">PlayerProjectile.cpp</strong> source files as well:<p class="source-code">// Called when the game starts or when spawned</p><p class="source-code">void APlayerProjectile::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">}</p><p class="source-code">// Called every frame</p><p class="source-code">void APlayerProjectile::Tick(float DeltaTime)</p><p class="source-code">{</p><p class="source-code">  Super::Tick(DeltaTime);</p><p class="source-code">}</p></li>
</ol>
<p>These lines of code represent the function implementations of the two functions you removed in the previous step – that is, <strong class="source-inline">Tick()</strong> and <strong class="source-inline">BeginPlay()</strong>. Again, these are being removed because they serve no purpose for the player projectile and just add clutter to the code. Additionally, without the declarations inside the <strong class="source-inline">PlayerProjectile.h</strong> header file, you would receive a compilation error if you were to try to compile this code asis. The only remaining function will be the constructor for the projectile class, which you will use to initialize the components of the projectile in the next exercise. Now that you have <a id="_idIndexMarker1144"/>removed the unnecessary code from the <strong class="source-inline">PlayerProjectile</strong> class, let’s add the functions and components required for the projectile.</p>
<ol>
<li value="4">Inside the <strong class="source-inline">PlayerProjectile.h</strong> header file, add the following components:<p class="source-code">public:</p><p class="source-code">  //Sphere collision component</p><p class="source-code">  UPROPERTY(VisibleDefaultsOnly, Category = </p><p class="source-code">  Projectile)</p><p class="source-code">  class USphereComponent* CollisionComp;</p><p class="source-code"> </p><p class="source-code">private:</p><p class="source-code">  //Projectile movement component</p><p class="source-code">  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, </p><p class="source-code">  Category = Movement, meta = </p><p class="source-code">  (AllowPrivateAccess = "true"))</p><p class="source-code">  class UProjectileMovementComponent* </p><p class="source-code">  ProjectileMovement;</p><p class="source-code">  //Static mesh component</p><p class="source-code">  UPROPERTY(EditAnywhere, Category = Projectile)</p><p class="source-code">  class UStaticMeshComponent* MeshComp;</p></li>
</ol>
<p>You are adding three different components here. The first is the collision component, which you will use for the projectile to recognize collisions with enemies and environment assets. The next component is the projectile movement component, which you should be familiar with from the previous project. This will allow the projectile to behave like a projectile. The final component is <strong class="source-inline">StaticMeshComponent</strong>. You will use this to give the projectile a visual representation so that it can be seen in-game. </p>
<ol>
<li value="5">Next, add the following function signature code to the <strong class="source-inline">PlayerProjectile.h</strong> header file, under the <strong class="source-inline">public</strong> access modifier:<p class="source-code">UFUNCTION()</p><p class="source-code">void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, </p><p class="source-code">  UPrimitiveComponent* OtherComp, FVector </p><p class="source-code">  NormalImpulse, const FHitResult&amp; </p><p class="source-code">  Hit);</p></li>
</ol>
<p>This final event declaration will allow the player projectile to respond to <strong class="source-inline">OnHit</strong> events from the <strong class="source-inline">CollisionComp</strong> component you created in the previous step. </p>
<ol>
<li value="6">To have this code compile, you<a id="_idIndexMarker1145"/> will need to implement the function from the previous step in the <strong class="source-inline">PlayerProjectile.cpp</strong> source file. Add the following code:<p class="source-code">void APlayerProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* </p><p class="source-code">  OtherActor, UPrimitiveComponent* OtherComp, FVector </p><p class="source-code">  NormalImpulse, const </p><p class="source-code">  FHitResult&amp; Hit)</p><p class="source-code">{</p><p class="source-code">}</p></li>
</ol>
<p>The <strong class="source-inline">OnHit</strong> event provides you with a lot of information about the collision that takes place. The most important parameter that you will be working with in the next exercise is the <strong class="source-inline">OtherActor</strong> parameter. The <strong class="source-inline">OtherActor</strong> parameter will tell you the actor that this <strong class="source-inline">OnHit</strong> event is responding to. This will allow you to know if this other actor is an enemy. You will use this information to destroy the enemies when the projectile hits them.</p>
<ol>
<li value="7">Lastly, navigate back into the Unreal Engine editor and <em class="italic">left-click</em> the <strong class="bold">Compile</strong> option to compile the new code.</li>
</ol>
<p>With this exercise complete, you<a id="_idIndexMarker1146"/> now have the framework ready for the <strong class="source-inline">PlayerProjectile</strong> class. The class contains the required components for <strong class="bold">Projectile Movement</strong>, <strong class="bold">Collision</strong>, and <strong class="bold">Static Mesh</strong>, as well as the event signature for the <strong class="source-inline">OnHit</strong> collision so that the projectile can recognize collisions with other actors.</p>
<p>In the next exercise, you will continue to customize and enable parameters for <strong class="source-inline">PlayerProjectile</strong> so that it behaves the way you need it to for the <strong class="source-inline">SuperSideScroller</strong> project.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor295"/>Exercise 13.12 – initializing the PlayerProjectile class’s settings</h2>
<p>Now that the <a id="_idIndexMarker1147"/>framework of the <strong class="source-inline">PlayerProjectile</strong> class is in place, it’s time to update the constructor of this class with the default settings needed for the projectile so that it moves and behaves as you want it to. To do this, you will need to initialize the <strong class="bold">Projectile Movement</strong>, <strong class="bold">Collision</strong>, and <strong class="bold">Static Mesh</strong> components. </p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Open Visual Studio and navigate to the <strong class="source-inline">PlayerProjectile.cpp</strong> source file.</li>
<li>Before adding any code to the constructor, include the following files inside the <strong class="source-inline">PlayerProjectile.cpp</strong> source file:<p class="source-code">#include "GameFramework/ProjectileMovementComponent.h"</p><p class="source-code">#include "Components/SphereComponent.h"</p><p class="source-code">#include "Components/StaticMeshComponent.h"</p></li>
</ol>
<p>These header files will allow you to initialize and update the parameters of the projectile movement component, the sphere collision component, and <strong class="source-inline">StaticMeshComponent</strong>, respectively. Without these files, the <strong class="source-inline">PlayerProjectile</strong> class wouldn’t know how to handle these components and how to access their functions and parameters. </p>
<ol>
<li value="3">By default, the <strong class="source-inline">APlayerProjectile::APlayerProjectile()</strong> constructor function includes the following line:<p class="source-code">PrimaryActorTick.bCanEverTick = true;</p></li>
</ol>
<p>This line of code can be removed entirely because it is not required in the player projectile.</p>
<ol>
<li value="4">In the <strong class="source-inline">PlayerProjectile.cpp</strong> source file, add the following lines to the <strong class="source-inline">APlayerProjectile::APlayerProjectile()</strong> constructor:<p class="source-code">CollisionComp = CreateDefaultSubobject</p><p class="source-code">  &lt;USphereComponent&gt;(TEXT("SphereComp"));</p><p class="source-code">CollisionComp-&gt;InitSphereRadius(15.0f);</p><p class="source-code">CollisionComp-&gt;BodyInstance.SetCollisionProfileName("BlockAll");</p><p class="source-code">CollisionComp-&gt;OnComponentHit.AddDynamic(this, &amp;APlayerProjectile::OnHit);</p></li>
</ol>
<p>The first line initializes the sphere collision component and assigns it to the <strong class="source-inline">CollisionComp</strong> variable you created in the previous exercise. The sphere collision component has a <a id="_idIndexMarker1148"/>parameter called <strong class="source-inline">InitSphereRadius</strong>. This will determine the size, or radius, of the collision actor by default; in this case, a value of <strong class="source-inline">15.0f</strong> works well. Next, <strong class="source-inline">SetCollisionProfileName</strong> sets the collision component to <strong class="source-inline">BlockAll</strong> so that the collision profile is set to <strong class="source-inline">BlockAll</strong>. This means this collision component will respond to <strong class="source-inline">OnHit</strong> when it collides with other objects. Lastly, the last line you added allows the <strong class="source-inline">OnComponentHit</strong> event to respond to the function you created in the previous exercise:</p>
<p class="source-code">void APlayerProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* </p>
<p class="source-code">  OtherActor, UPrimitiveComponent* OtherComp, FVector </p>
<p class="source-code">  NormalImpulse, const </p>
<p class="source-code">  FHitResult&amp; Hit)</p>
<p class="source-code">{</p>
<p class="source-code">}</p>
<p>This means that when the collision component receives the <strong class="source-inline">OnComponentHit</strong> event from a collision event, it will respond with that function; however, this function<a id="_idIndexMarker1149"/> is empty at the moment. You will add code to this function later in this chapter.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more <a id="_idIndexMarker1150"/>about how to create custom collision profiles at <a href="https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/">https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/</a>.</p>
<ol>
<li value="5">The last thing you must do with <strong class="source-inline">Collision Component</strong> is set this component as the <strong class="source-inline">Root Component</strong> of the player projectile actor. Add the following line of code to the constructor, after the lines from <em class="italic">Step 4</em>:<p class="source-code">// Set as root component</p><p class="source-code">RootComponent = CollisionComp;</p></li>
<li>With the collision component set up and ready, let’s move on to the <strong class="source-inline">Projectile Movement</strong> component. Add the following lines to the constructor:<p class="source-code">// Use a ProjectileMovementComponent to govern this projectile's movement</p><p class="source-code">ProjectileMovement = </p><p class="source-code">  CreateDefaultSubobject&lt;</p><p class="source-code">  UProjectileMovementComponent&gt;(</p><p class="source-code">  TEXT("ProjectileComp"))</p><p class="source-code">  ;</p><p class="source-code">ProjectileMovement-&gt;UpdatedComponent = CollisionComp;</p><p class="source-code">ProjectileMovement-&gt;ProjectileGravityScale = 0.0f;</p><p class="source-code">ProjectileMovement-&gt;InitialSpeed = 800.0f;</p><p class="source-code">ProjectileMovement-&gt;MaxSpeed = 800.0f;</p></li>
</ol>
<p>This first line initializes <strong class="source-inline">ProjectileMovementComponent</strong> and assigns it to the <strong class="source-inline">ProjectileMovement</strong> variable you created in the previous exercise. Next, we set <strong class="source-inline">CollisionComp</strong> as the updated component of the projectile movement component. The reason we’re doing this is that <strong class="source-inline">ProjectileMovementComponent</strong> will use the <strong class="source-inline"> Root</strong> of the actor as the component to move. Then, we set the gravity scale of the projectile to <strong class="source-inline">0.0f</strong> because the player projectile should not be affected by gravity; this behavior should allow the projectile to <a id="_idIndexMarker1151"/>travel at the same speed, at the same height, and not be influenced by gravity. Lastly, we set both the <strong class="source-inline">InitialSpeed</strong> and <strong class="source-inline">MaxSpeed</strong> parameters to <strong class="source-inline">500.0f</strong>. This will allow the projectile to instantly start moving at this speed and remain at this speed for the duration of its lifetime. The player projectile will not support any kind of acceleration motion.</p>
<ol>
<li value="7">With the projectile movement component initialized and set up, it is time to do the same for <strong class="source-inline">StaticMeshComponent</strong>. Add the following code after the lines from the previous step:<p class="source-code">MeshComp = </p><p class="source-code">CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("MeshComp"));</p><p class="source-code">MeshComp-&gt;AttachToComponent(RootComponent, </p><p class="source-code">  FAttachmentTransformRules::KeepWorldTransform);</p></li>
</ol>
<p>This first line initializes <strong class="source-inline">StaticMeshComponent</strong> and assigns it to the <strong class="source-inline">MeshComp</strong> variable you created in the previous exercise. Then, it attaches this <strong class="source-inline">StaticMeshComponent</strong> to <strong class="source-inline">RootComponent</strong> using a struct called <strong class="source-inline">FAttachmentTransformRules</strong> to ensure that <strong class="source-inline">StaticMeshComponent</strong> keeps its world transform during the attachment, which is <strong class="source-inline">CollisionComp</strong> from <em class="italic">Step 5</em> of this exercise.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information about the <strong class="source-inline">FAttachmentTransformRules</strong> struct here: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml</a>.</p>
<ol>
<li value="8">Lastly, let’s give <strong class="source-inline">PlayerProjectile</strong> an initial life span of <strong class="source-inline">3</strong> seconds so that the projectile will automatically be<a id="_idIndexMarker1152"/> destroyed if it doesn’t collide with anything after this time. Add the following code to the end of the constructor:<p class="source-code">InitialLifeSpan = 3.0f;</p></li>
<li>Lastly, navigate back into the Unreal Engine editor and <em class="italic">left-click</em> the <strong class="bold">Compile</strong> option to compile the new code.</li>
</ol>
<p>By completing this exercise, you have set up the groundwork for <strong class="bold">Player Projectile</strong> so that it can be created as a Blueprint actor inside the editor. All three required components have been initialized and contain the default parameters that you want for this projectile. All we need to do now is create the Blueprint from this class to see it in the level.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor296"/>Activity 13.03 – creating the player projectile Blueprint</h2>
<p>To conclude this chapter, you will create the <a id="_idIndexMarker1153"/>Blueprint actor from the new <strong class="source-inline">PlayerProjectile</strong> class and customize this actor so that it uses a placeholder shape for <strong class="bold">Static Mesh Component</strong> for debugging purposes. This will allow you to view the projectile in the game world. Then, you will add a <strong class="source-inline">UE_LOG()</strong> function to the <strong class="source-inline">APlayerProjectile::OnHit</strong> function inside the <strong class="source-inline">PlayerProjectile.cpp</strong> source file so that you can ensure that this function is called when the projectile comes into contact with an object in the level. </p>
<p>Follow these steps:</p>
<ol>
<li value="1">Inside the <strong class="bold">Content Drawer</strong> interface, create a new folder called <strong class="source-inline">Projectile</strong> in the <strong class="source-inline">/MainCharacter</strong> directory.</li>
<li>In this directory, create a new Blueprint from the <strong class="source-inline">PlayerProjectile</strong> class, which you created in <em class="italic">Exercise 13.11 – creating the player projectile</em>. Name this Blueprint <strong class="source-inline">BP_PlayerProjectile</strong>.</li>
<li>Open <strong class="bold">BP_PlayerProjectile</strong> and navigate to its components. Select the <strong class="source-inline">MeshComp</strong> component to access its settings.</li>
<li>Add the <strong class="source-inline">Shape_Sphere</strong> mesh to the <strong class="source-inline">Static Mesh</strong> parameter of the <strong class="source-inline">MeshComp</strong> component.</li>
<li>Update the transform of <strong class="source-inline">MeshComp</strong> so that it fits the <strong class="source-inline">Scale and Location of the CollisionComp</strong> component. Use the following values:<p class="source-code">Location:(X=0.000000,Y=0.000000,Z=-10.000000)</p><p class="source-code">Scale: (X=0.200000,Y=0.200000,Z=0.200000)</p></li>
<li>Compile and save the <strong class="bold">BP_PlayerProjectile</strong> Blueprint.</li>
<li>Navigate to the <strong class="source-inline">PlayerProjectile.cpp</strong> source file in Visual Studio and find the <strong class="source-inline">APlayerProjectile::OnHit</strong> function.</li>
<li>Inside the function, implement the <strong class="source-inline">UE_LOG</strong> call so that the logged line is of <strong class="bold">LogTemp</strong>, <strong class="bold">Warning log level</strong>, and displays the text <strong class="source-inline">HIT</strong>. <strong class="source-inline">UE_LOG</strong> , as covered back in <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>.</li>
<li>Compile your code changes and navigate to the level where you placed the <strong class="bold">BP_PlayerProjectile</strong> actor in the previous exercise. If you haven’t added this actor to the level, do so now.</li>
<li>Before testing, make sure that you open <strong class="bold">Output Log</strong> under <strong class="bold">Window</strong>. From the <strong class="bold">Window</strong> dropdown, hover over the <strong class="bold">Developers Tools</strong> option and <em class="italic">left-click</em> to select <strong class="bold">Output Log</strong>.</li>
<li>Use <strong class="source-inline">PIE</strong> and watch out for<a id="_idIndexMarker1154"/> the log warning inside <strong class="bold">Output Log</strong> when the projectile collides with something.</li>
</ol>
<p>The following is the expected output:</p>
<div>
<div class="IMG---Figure" id="_idContainer431">
<img alt="Figure 13.39 – The scale of MeshComp fits the size of CollisionComp better " height="216" src="image/Figure_13.39_B18531.jpg" width="246"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.39 – The scale of MeshComp fits the size of CollisionComp better</p>
<p>The log warning should look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer432">
<img alt="Figure 13.40 – When the projectile hits an object, HIT is shown in the Output Log area " height="196" src="image/Figure_13.40_B18531.jpg" width="1173"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.40 – When the projectile hits an object, HIT is shown in the Output Log area</p>
<p>With this final activity complete, <strong class="bold">Player Projectile</strong> is ready for the next chapter, where you will spawn this projectile when the player uses the <strong class="source-inline">Throw</strong> action. You will update the <strong class="source-inline">APlayerProjectile::OnHit</strong> function <a id="_idIndexMarker1155"/>so that it destroys the enemy that it collides with and becomes an effective offensive tool for the player to use against the enemies.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor297"/>Summary</h1>
<p>In this chapter, you learned how to use the different aspects of the AI tools offered by UE5, including <strong class="source-inline">Blackboards</strong>, <strong class="source-inline">Behavior Trees</strong>, and AI Controllers. By using a combination of both custom-created tasks and default tasks provided by UE5, as well as a decorator, you were able to have the enemy AI navigate within the bounds of the Nav Mesh you added to your level. </p>
<p>On top of this, you created a new <strong class="source-inline">Blueprint</strong> actor that allows you to add patrol points with the use of a <strong class="source-inline">Vector</strong> array variable. Then, you added a new function to this actor that selects one of these points at random, converts its location from local space into world space, and then returns this new value for use by the enemy character.</p>
<p>With the ability to randomly select a patrol point, you updated the custom <strong class="source-inline">BTTask_FindLocation</strong> task to find and move to the selected patrol point, allowing the enemy to move from each patrol point at random. This brought the enemy AI character to a whole new level of interaction in terms of the player and the environment.</p>
<p>Lastly, you created the <strong class="source-inline">PlayerProjectile</strong> class, which the player will be able to use to destroy enemies within the environment. You took advantage of both <strong class="source-inline">Projectile Movement Component</strong> and <strong class="source-inline">Sphere Component</strong> to allow for both projectile movement and to recognize and respond to collisions within the environment.</p>
<p>With the <strong class="source-inline">PlayerProjectile</strong> class in a functional state, it is time to move on to the next chapter, where you will use <strong class="source-inline">Anim Notifies</strong> to spawn the projectile when the player uses the <strong class="source-inline">Throw</strong> action.</p>
</div>
</div></body></html>