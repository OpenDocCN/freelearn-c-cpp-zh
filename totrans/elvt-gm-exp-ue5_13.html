<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor268"/>13</h1>
<h1 id="_idParaDest-241"><a id="_idTextAnchor269"/>Creating and Adding the Enemy Artificial Intelligence</h1>
<p>In the previous chapter, you added layered animations for the player character using animation blending with a combination of Anim Slots, Animation Blueprints, and blending functions such as <code>Layered blend per bone</code>. With this knowledge, you were able to smoothly blend the throwing animation montage with the base movement state machine to create layered animations for the character.</p>
<p>The primary focus of this chapter is to take the C++ enemy class you created in <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, and bring this enemy to life using AI. UE5 uses many different tools to achieve AI, such as AI Controllers, Blackboards, and Behavior Trees, all of which you will learn about and use in this chapter.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to use a Navigation Mesh to create a navigable space inside of the game world that the enemy can move in. </li>
<li>How to create an enemy AI pawn that can navigate between patrol point locations inside the game world using a combination of the AI tools present inside <code>Blackboards</code> and <code>Behavior Trees</code>. </li>
<li>How to use a Transform Vector to convert local transform into world transform.</li>
<li>How to create a player projectile class in C++, and how to implement the <code>OnHit()</code>collision event function to recognize and log when the projectile hits an object in the game world.</li>
</ul>
<p>By the end of this chapter, you will be able to create a navigable space where the enemy can move. You will also be able to create an enemy AI pawn and navigate it across locations using <code>Blackboards</code> and <code>Behavior Trees</code>. Lastly, you will know how to create and implement a player projectile class and add visual elements to it. Before you jump into these systems, let’s take a moment to learn about how AI has been used in games in recent history. AI has certainly evolved since the days of <em class="italic">Super Mario Bros</em>.</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor270"/>Technical requirements</h1>
<p>For this chapter, you will need the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
</ul>
<p>The project for this chapter can be found in the <code>Chapter13</code> folder of the code bundle for this book, which can be downloaded from</p>
<p><a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor271"/>Enemy AI</h1>
<p>What is <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>)? This term can mean many things, depending on the field and context where it is used, so let’s define it in a <a id="_idIndexMarker1056"/>way that makes sense regarding the subject of video games.</p>
<p><strong class="bold">AI</strong> is an entity that is aware <a id="_idIndexMarker1057"/>of its environment and performs choices that will help it optimally achieve its intended purpose. AI uses what are called <strong class="bold">finite state machines</strong> to switch<a id="_idIndexMarker1058"/> between more than one state based on the input it receives from the user or its environment. For example, a video game AI can switch between an offensive state to a defensive state based on its current health.</p>
<p>In games such as <em class="italic">Hello Neighbor</em>, which was developed in Unreal Engine 4, and <em class="italic">Alien: Isolation</em>, the goal of the AI is to find the player as efficiently as possible, but also to follow some predetermined patterns defined by the developers to ensure that the player can outsmart it. <em class="italic">Hello Neighbor</em> adds a very creative element to its AI by having it learn from the players’ past actions and try to outsmart the player based on the knowledge it learns. </p>
<p>You can find an informative breakdown of how the AI works in the following video by the publishers of the game, <em class="italic">TinyBuild Games</em>: <a href="https://www.youtube.com/watch?v=Hu7Z52RaBGk">https://www.youtube.com/watch?v=Hu7Z52RaBGk</a>.</p>
<p>Interesting and fun AI is crucial to any game, and depending on the game you are making, this can mean a very complex or very simplistic AI. The AI that you will be creating for the <code>SuperSideScroller</code> game will not be as sophisticated as those mentioned previously, but it will fill the <a id="_idIndexMarker1059"/>needs of the game we are seeking to create.</p>
<p>Let’s break down how the enemy will behave:</p>
<ul>
<li>The enemy will be a very <a id="_idIndexMarker1060"/>simple enemy that has a basic back and forth movement pattern and will not support any attacks; only by colliding with the player character will they be able to inflict any damage.</li>
<li>However, we need to set the locations for the enemy AI to move between.</li>
<li>Next, we must decide whether the AI should change locations, should constantly move between locations, or whether there should be a pause inbetween selecting a new location to move to.</li>
</ul>
<p>Fortunately for us, UE5 provides us with a wide array of tools that we can use to develop such complex AI. In the case of our project, however, we will use these tools to create a simplistic enemy type. Let’s start by discussing what an AI Controller is in UE5.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor272"/>AI Controller</h1>
<p>Let’s discuss what the main <a id="_idIndexMarker1061"/>difference is between a <strong class="bold">Player Controller</strong> and an <strong class="bold">AI Controller</strong>. Both of these actors derive from the base <strong class="bold">Controller</strong> class. A <strong class="bold">Controller</strong> is used to take control of a <strong class="bold">Pawn</strong> or <strong class="bold">Character</strong> to control the actions of said pawn or character.</p>
<p>While a <code>UWorld</code> class. </p>
<p class="callout-heading">Note</p>
<p class="callout">You will learn more about the <code>UWorld</code> class in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, but as a reference, you can read more here: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml</a>.</p>
<p>The most important aspect of<a id="_idIndexMarker1062"/> both the Player Controller and the AI Controller is the pawns they will control. Let’s learn more about how AI Controllers handle this.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor273"/>Auto Possess AI</h2>
<p>Like all Controllers, the AI Controller must possess a <em class="italic">pawn</em>. In C++, you can use the following function to <a id="_idIndexMarker1063"/>possess a pawn:</p>
<pre>void AController::Possess(APawn* InPawn)</pre>
<p>You can also use the following function to unpossess a pawn:</p>
<pre>void AController::UnPossess()</pre>
<p>There’s also the <code>void AController::OnPossess(APawn* InPawn)</code> and <code>void AController::OnUnPossess()</code>functions, which are called whenever the <code>Possess()</code> and <code>UnPossess()</code>functions are called, respectively.</p>
<p>When it comes to AI, especially in the context of UE5, there are two methods in which AI Pawns or Characters can be possessed by an AI Controller. Let’s take a look at these options: </p>
<ul>
<li><code>Placed in World</code>: This first method is how you will be handling AI in this project; you will manually place these enemy actors into your game world, and the AI will take care of the rest once the game begins.</li>
<li><code>Spawned</code>: This second method is only a little more complicated because it requires an explicit function call, either in C++ or Blueprint, to <code>Spawn</code> an instance of a specified class. The <code>Spawn Actor</code> method requires a handful of parameters, including the <code>World</code> object and <code>Transform</code> parameters such as <code>Location</code> and <code>Rotation</code>, to ensure that the instance that is spawned is spawned correctly.</li>
<li><code>Placed in World or Spawned</code>: If you are unsure of which method you want to use, a safe option would be <code>Placed in World or Spawned</code>; that way, both methods are supported.</li>
<li>For the <code>SuperSideScroller</code> game, you will be using the <code>Placed</code> <code>in</code> <code>World</code> option because the<a id="_idIndexMarker1064"/> AI you will create will be manually placed in the game level.</li>
</ul>
<p>Let’s move to our first exercise where we will implement the AI Controller for the enemy.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor274"/>Exercise 13.01 – implementing AI Controllers</h2>
<p>Before the enemy pawn can<a id="_idIndexMarker1065"/> do anything, it needs to be possessed by an AI Controller. This also needs to happen before any logic can be performed by the AI. By the end of this exercise, you will have created an AI Controller and applied it to the enemy that you created in the previous chapter. Let’s begin by creating the AI Controller.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li>Head to the <code>Content/Enemy</code> directory.</li>
<li><em class="italic">Right-click</em> on the <code>Enemy</code> folder and select the <code>AI</code>. In the new <code>AI</code> folder directory, <em class="italic">right-click</em> and select the <strong class="bold">Blueprint Class</strong> option.</li>
<li>From the <code>AIController</code> class.</li>
<li><em class="italic">Left-click</em> this class option and then <em class="italic">left-click</em> on the blue <code>AIController</code> class. Also, take note of the tooltip that appears when hovering over the class option; it contains useful information about this class from the developers:</li>
</ol>
<div><div><img alt="Figure 13.1 – The AIController asset class, as found in the Pick Parent Class dialog box " height="342" src="img/Figure_13.01_B18531.jpg" width="745"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The AIController asset class, as found in the Pick Parent Class dialog box</p>
<ol>
<li value="5">With this new <code>AIController Blueprint</code> created, name this asset <code>BP_AIControllerEnemy</code>. </li>
</ol>
<p>With the AI Controller created and named, it’s <a id="_idIndexMarker1066"/>time to assign this asset to the first enemy Blueprint that you made in the previous chapter.</p>
<ol>
<li value="6">Navigate to the <code>/Enemy/Blueprints</code> directory to find <code>BP_Enemy</code>. <em class="italic">Double-click</em> to open this Blueprint.</li>
<li>In the <code>Pawn</code>. This is where you can set different parameters regarding the AI functionality of <code>Pawn</code> or <code>Character</code>.</li>
<li>The <code>AI Controller Class</code> parameter determines, as its name suggests, which AI Controller to use for this enemy. <em class="italic">Left-click</em> on the dropdown to find and select the AI Controller you made earlier–that is, <code>BP_AIController_Enemy</code>.</li>
</ol>
<p>With this exercise complete, the enemy AI now knows which AI Controller to use. This is crucial because it is in the AI Controller where the AI will use and execute the <code>Behavior Tree</code> you will create later in this chapter.</p>
<p>The AI Controller is now assigned to the enemy, which means you are almost ready to start developing the actual<a id="_idIndexMarker1067"/> intelligence for this AI. However, there is still one important topic to discuss before doing so, and that is the <strong class="bold">Navigation Mesh</strong>.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor275"/>Navigation Mesh</h1>
<p>One of the most crucial aspects of any AI in video games is the ability to navigate the environment in a sophisticated manner. In UE5, there is a way for the engine to tell the AI which parts of an environment are navigable and which parts are not. This is done through a <strong class="bold">Navigation Mesh</strong>, or <strong class="bold">Nav Mesh</strong> for short.</p>
<p>The term <em class="italic">mesh</em> is misleading here <a id="_idIndexMarker1068"/>because it’s implemented through a volume in the editor. We will need a Nav Mesh in our level so that our AI can effectively navigate the playable bounds of the game world. We’ll add one together in the following exercise.</p>
<p>UE5 also supports a <strong class="bold">Dynamic Navigation Mesh</strong>, which allows the Nav Mesh to update in real time as dynamic objects move around the environment. This results in the AI recognizing these changes in the environment and updating their pathing/navigation appropriately. This book will not cover this, but you can access the configuration options via <strong class="bold">Project Settings</strong> | <strong class="bold">Navigation Mesh</strong> | <strong class="bold">Runtime Generation</strong>. </p>
<p>Now that we have learned about the <strong class="bold">Navigation Mesh</strong>, let’s start our first exercise where we will add the <strong class="bold">Navigation Mesh</strong> to our level.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor276"/>Exercise 13.02 – implementing a Nav Mesh Volume for the AI enemy</h2>
<p>In this exercise, you will <a id="_idIndexMarker1069"/>add a Navigation <a id="_idIndexMarker1070"/>Mesh to <code>SideScrollerExampleMap</code> and explore how Navigation Meshes work in UE5. You’ll also learn how to parameterize this volume for the needs of your game. This exercise will be performed within the UE5 editor.</p>
<p>By the end of this exercise, you will have a stronger understanding of the Nav Mesh. You will also be able to implement this volume in your levels in the activity that follows this exercise. Let’s begin by <a id="_idIndexMarker1071"/>adding the Nav Mesh Volume to the level.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">If you do not already<a id="_idIndexMarker1072"/> have the map open, please open <strong class="bold">ThirdPersonExampleMap</strong> by navigating to <strong class="bold">File</strong> and <em class="italic">left-clicking</em> on the <strong class="bold">Open Level</strong> option. From the <strong class="bold">Open Level</strong> dialog box, navigate to <strong class="bold">/ThirdPersonCPP/Maps</strong> to find <strong class="bold">SideScrollerExampleMap</strong>. Select this map by <em class="italic">left-clicking</em> and then <em class="italic">left-click</em> <strong class="bold">Open</strong> at the bottom to open the map.</li>
<li>With the map opened, navigate to the <strong class="bold">Window</strong> menu at the top-left of the editor, and make sure you select the <strong class="bold">Place Actors</strong> panel option. The <strong class="bold">Place Actors</strong> panel contains a set of easily accessible actor types such as <strong class="bold">Volumes</strong>, <strong class="bold">Lights</strong>, <strong class="bold">Geometry</strong>, and others. Under the <strong class="bold">Volumes</strong> category, you will find the <strong class="bold">Nav Mesh Bounds Volume</strong> option.</li>
<li><em class="italic">Left-click</em> and drag this volume into the map/scene. By default, you will see the outline of the volume in the editor. Press the <em class="italic">P</em> key to visualize the <strong class="bold">Navigation</strong> area that the volume encompasses, but make sure that the volume is intersecting with the ground geometry to see the green visualization, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 13.2 – Areas outlined in green are perceived as navigable by the engine and the AI " height="594" src="img/Figure_13.02_B18531.jpg" width="1387"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Areas outlined in green are perceived as navigable by the engine and the AI</p>
<p>With the Nav Mesh <a id="_idIndexMarker1073"/>Volume in place, let’s adjust its <a id="_idIndexMarker1074"/>shape so that the volume extends to the entire area of the level. After this, you’ll learn how to adjust the parameters of the Nav Mesh Volume for the game.</p>
<ol>
<li value="4"><em class="italic">Left-click</em> to select <code>X: 3000.0</code>, <code>Y: 3000.0</code>, and <code>Z: 3000.0</code>.</li>
</ol>
<p>Notice that when the shape and dimensions of <strong class="bold">NavMeshBoundsVolume</strong> change, <strong class="bold">Nav Mesh</strong> will adjust and recalculate the navigable area. This can be seen in the following screenshot. You will also notice that the upper platforms are not navigable; you will fix this later:</p>
<div><div><img alt="Figure 13.3 – Now, NavMeshBoundsVolume extends to the entire playable area of the example map " height="678" src="img/Figure_13.03_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Now, NavMeshBoundsVolume extends to the entire playable area of the example map</p>
<p>By completing this exercise, you <a id="_idIndexMarker1075"/>have placed your first <code>RecastNavMesh</code> actor, which is also created when placing <code>NavMeshBoundsVolume</code> in the level.</p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor277"/>Recasting the Nav Mesh</h1>
<p>When you added <strong class="bold">NavMeshBoundsVolume</strong>, you may have noticed that another actor was created automatically: a <strong class="bold">RecastNavMesh</strong> actor called <strong class="bold">RecastNavMesh-Default</strong>. This <strong class="bold">RecastNavMesh</strong> acts<a id="_idIndexMarker1077"/> as the “brain” of the Nav Mesh because it contains the parameters needed to adjust the Nav Mesh that directly influences how the AI navigates the given area.</p>
<p>The following screenshot shows this asset, as seen from the <strong class="bold">World Outliner</strong> tab:</p>
<div><div><img alt="Figure 13.4 – The RecastNavMesh actor, as seen from the World Outliner tab " height="311" src="img/Figure_13.04_B18531.jpg" width="384"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – The RecastNavMesh actor, as seen from the World Outliner tab</p>
<p class="callout-heading">Note</p>
<p class="callout">There are a lot of parameters that exist in <code>RecastNavMesh</code>, and we will only be covering the important parameters in this book. For more information, check out <a href="https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml</a>.</p>
<p>There are only two primary sections that are important to you right now:</p>
<ul>
<li><strong class="bold">Display</strong>: The <strong class="bold">Display</strong> section, as its name suggests, only contains parameters that affect the visual debug display of the generated navigable area of <strong class="bold">NavMeshBoundsVolume</strong>. It is recommended that you try toggling each of the parameters under this category to see how they affect the display of the generated Nav Mesh.</li>
<li><code>2.0f</code> to get the full height.</li><li><code>44</code> degrees, and this is a parameter you will leave alone unless your game requires it to change.</li><li><strong class="bold">Agent Max Step Height</strong> refers to the height of steps, in terms of staircase steps, that can be navigated by the AI. Much like <strong class="bold">Agent Max Slope</strong>, this is a parameter that you will more than likely leave alone unless your game specifically requires this value to change.</li></ul></li>
</ul>
<p>Now that you have learned about the Recast Nav Mesh parameters, let’s put this knowledge into practice in the next exercise, which will walk you through changing a few of these parameters.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor278"/>Exercise 13.03 – recasting Nav Mesh Volume parameters</h2>
<p>Now that you have the <strong class="bold">Nav Mesh</strong> Volume in the<a id="_idIndexMarker1079"/> level, it is time to change the parameters of the <strong class="bold">Recast Nav Mesh</strong> actor so that the Nav Mesh allows the enemy AI to navigate across platforms that are thinner than others. This exercise will be performed within the UE5 editor.</p>
<p>Here, you will simply be updating <code>Cell Size</code> and <code>Agent Height</code> so that they fit the needs of your character and the accuracy needed for the Nav Mesh:</p>
<pre class="source-code">
Cell Size: 5.0f
Agent Height: 192.0f</pre>
<p>The following screenshot shows that the extended platform is now navigable because of the changes we made to <code>Cell Size</code>:</p>
<div><div><img alt="Figure 13.5 – Changing Cell Size from 19.0f to 5.0f allows for the narrow extended platform to be navigable " height="834" src="img/Figure_13.05_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Changing Cell Size from 19.0f to 5.0f allows for the narrow extended platform to be navigable</p>
<p>With <code>SuperSideScrollerExampleMap</code> set up with its own <code>NavMeshBoundsVolume</code> actor that you can use for the remainder of this project.</p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor279"/>Activity 13.01 – creating a new level</h2>
<p>Now that you<a id="_idIndexMarker1081"/> have added <code>NavMeshBoundsVolume</code> to the example map, it is time to create a map for the rest of the <code>Super SideScroller</code> game. By creating a map, you will have a better understanding of how <code>NavMeshBoundsVolume</code> and the properties of <code>RecastNavMesh</code> affect the environment they are placed in. </p>
<p class="callout-heading">Note</p>
<p class="callout">Before moving on to the solution for this activity, if you need an example level that will work for the remaining chapters that cover the <code>SuperSideScroller</code> game, then don’t worry – this chapter comes with the <code>SuperSideScroller.umap</code> asset, as well as a map called <code>SuperSideScroller_NoNavMesh</code>, which does not contain <code>NavMeshBoundsVolume</code>. You can use <code>SuperSideScroller.umap</code> as a reference for how to create a level or to get ideas on how to improve your level. You can download the map from <a href="https://packt.live/3lo7v2f">https://packt.live/3lo7v2f</a>.</p>
<p>Follow these steps to<a id="_idIndexMarker1082"/> create a simplistic map:</p>
<ol>
<li value="1">Create a <strong class="bold">New Level</strong>.</li>
<li>Name this level <code>SuperSideScroller</code>.</li>
<li>Using the <strong class="bold">Static Mesh</strong> assets provided by default in the <strong class="bold">Content Drawer</strong> interface of this project, create an interesting space with different elevations to navigate. Add your player character’s <strong class="bold">Blueprint</strong> to the level, and make sure it is possessed by <strong class="bold">Player Controller 0</strong>.</li>
<li>Add the <code>1000.0</code>, <code>5000.0</code>, and <code>2000.0</code> in the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> axes, respectively.</li>
<li>Make sure that you enable debug visualization for <strong class="bold">NavMeshBoundsVolume</strong> by pressing the <em class="italic">P</em> key.</li>
<li>Adjust the parameters of the <code>Cell Size</code> parameter is set to <code>5.0f</code>, <code>Agent Radius</code> is set to <code>42.0f</code>, and <code>Agent Height</code> is set to <code>192.0f</code>. Use these values as a reference.</li>
</ol>
<p><strong class="bold">Expected Output</strong></p>
<div><div><img alt="Figure 13.6 – The SuperSideScroller map " height="596" src="img/Figure_13.06_B18531.jpg" width="1193"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – The SuperSideScroller map</p>
<p>By the end of this activity, you will have a level that contains the required <code>NavMeshBoundsVolume</code> and settings for the <code>RecastNavMesh</code> actor. This will allow the AI we’ll develop in the <a id="_idIndexMarker1083"/>upcoming exercises to function correctly. Again, if you are unsure of how the level should look, please refer to the provided example map, <code>SuperSideScroller.umap</code>. Now, it is time to jump into developing the AI for the <code>SuperSideScroller</code> game.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor280"/>Behavior trees and Blackboards</h1>
<p>Behavior Trees and Blackboards work together to allow our AI to follow different logical paths and make decisions based on a variety of conditions and variables. </p>
<p>A <strong class="bold">behavior tree</strong> is a visual scripting tool that allows you to tell a pawn what to do based on certain factors and parameters. For <a id="_idIndexMarker1084"/>example, a Behavior Tree can tell an AI to move to a certain location based on whether the AI can see the player.</p>
<p>To give an example of how <code>Behavior Trees</code> and <code>Blackboards</code> are used in games, let’s look at the game <em class="italic">Gears of War 5</em>, which was developed with UE5. The AI in <code>Blackboard</code>. The logic that determines how these variables are used and how the AI will use this information is performed inside the Behavior Tree. </p>
<p>The <code>Blackboard</code> is where you define the <a id="_idIndexMarker1085"/>set of variables that are required to have the Behavior Tree perform actions and use those values for decision-making. </p>
<p>The <code>Behavior Tree</code> is where you create the tasks that you want the AI to perform, such as moving to a location or performing a custom task that you create. Like many of the in-editor tools in UE5, <code>Behavior Trees</code> are, for the most part, a very visual scripting experience. </p>
<p><code>Blackboards</code> are where you define the variables, also known as <code>Blackboard</code>, <code>Behavior Trees</code> would have no way of passing and storing information across different Tasks, Services, or Decorators, rendering it useless:</p>
<div><div><img alt="Figure 13.7 – An example set of variables inside a Blackboard that can be accessed in the behavior tree " height="200" src="img/Figure_13.07_B18531.jpg" width="603"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – An example set of variables inside a Blackboard that can be accessed in the behavior tree</p>
<p>Behavior Trees are composed of a set of <strong class="bold">objects</strong> – that is, <strong class="bold">Composites</strong>, <strong class="bold">Tasks</strong>, <strong class="bold">Decorators</strong>, and <strong class="bold">Services</strong> – that work together<a id="_idIndexMarker1086"/> to define how the AI will <a id="_idIndexMarker1087"/>behave and respond based on the conditions and logic flow that you set. All Behavior Trees begin <a id="_idIndexMarker1088"/>with what is called the Root where the<a id="_idIndexMarker1089"/> logic flow begins; this cannot be modified and has only one execution branch. Let’s take a look at these objects in more detail.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for <code>Behavior Tree</code> Behavior Tree, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites</a>. </p>
<p>Composite nodes tell the <code>Behavior Tree</code> how to go about performing tasks and other actions. The <a id="_idIndexMarker1090"/>following screenshot shows the full list of Composite nodes that Unreal Engine gives you by default: <strong class="bold">Selector</strong>, <strong class="bold">Sequence</strong>, and <strong class="bold">Simple Parallel</strong>.</p>
<p>Composite nodes can also have Decorators and Services attached to them so that optional conditions can be applied before a <code>Behavior Tree</code> branch is executed:</p>
<div><div><img alt="Figure 13.8 – Composite nodes – Selector, Sequence, and Simple Parallel " height="101" src="img/Figure_13.08_B18531.jpg" width="406"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Composite nodes – Selector, Sequence, and Simple Parallel</p>
<p>Let’s look at these nodes in more detail:</p>
<ul>
<li><code>FinishWithResult</code> task is successful, the parent <code>Root</code> to execute again and <code>FinishWithResult</code> to execute once more. This pattern will continue until <code>FinishWithResult</code> fails. The <code>MakeNoise</code>. If <code>MakeNoise</code> fails, the <code>Root</code> will execute again. If the <code>MakeNoise</code> task succeeds, then the Selector will succeed, and the <code>Root</code> will execute again. Depending on the flow of the behavior tree, if the Selector fails or succeeds, the next Composite branch will begin to execute. In the following screenshot, there are no other Composite nodes, so if the Selector fails or succeeds, the <code>Root</code> node will be executed again. However, if there were a <strong class="bold">Sequence</strong> Composite node with multiple <strong class="bold">Selector</strong> nodes underneath, each Selector would attempt to successfully execute its children. Regardless of success or failure, each <strong class="bold">Selector</strong> will attempt execution sequentially:</li>
</ul>
<div><div><img alt="Figure 13.9 – An example of how a Selector Composite node can be used in a behavior tree " height="530" src="img/Figure_13.09_B18531.jpg" width="1026"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – An example of how a Selector Composite node can be used in a behavior tree</p>
<p>Note that when adding tasks and <code>Composite</code> nodes, you will notice numeric values on the top-right corners of each node. These numbers indicate the order in which these nodes will be<a id="_idIndexMarker1092"/> executed. The pattern follows the <em class="italic">top</em> to <em class="italic">bottom</em>, <em class="italic">left</em> to <em class="italic">right</em> paradigm, and these values help you keep track of the ordering. Any disconnected task or <code>Composite</code> node will be given a value of <code>–1</code> to indicate that it is unused.</p>
<ul>
<li><code>Move To</code> task is successful, then the parent <code>Wait</code> task. If the <code>Wait</code> task is successful, then the Sequence is successful, and <code>Root</code> will execute again. If the <code>Move To</code> task fails, however, the <code>Root</code> will execute again, causing the <code>Wait</code> task to never execute:</li>
</ul>
<div><div><img alt="Figure 13.10 – An example of how a Sequence Composite node can be used in a behavior tree " height="486" src="img/Figure_13.10_B18531.jpg" width="1169"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – An example of how a Sequence Composite node can be used in a behavior tree</p>
<ul>
<li><code>5</code> seconds is being executed at the same time as a new <strong class="bold">Sequence</strong> of tasks is being executed:</li>
</ul>
<div><div><img alt="Figure 13.11 – An example of how a Selector Composite node can be used in a behavior tree " height="708" src="img/Figure_13.11_B18531.jpg" width="1520"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – An example of how a Selector Composite node can be used in a behavior tree</p>
<p>The <strong class="bold">Simple Parallel</strong> Composite <a id="_idIndexMarker1095"/>node is also the only <strong class="bold">Composite</strong> node that has a parameter in its <strong class="bold">Details</strong> panel, which is <strong class="bold">Finish Mode</strong>. There are two options:</p>
<ul>
<li><code>Wait</code> task finishes, the background tree Sequence will abort and the entire <strong class="bold">Simple Parallel</strong> will execute again.</li>
<li><code>Wait</code> task will finish after <code>5</code> seconds, but the entire <strong class="bold">Simple Parallel</strong> will wait for the <strong class="bold">Move To</strong> and <strong class="bold">PlaySound</strong> tasks to execute before restarting.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information <a id="_idIndexMarker1096"/>regarding the C++ API for Composites, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/</a>.</p>
<p>Now that we have a better understanding of Composite nodes, let’s take a look at a few examples of Task nodes.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor281"/>Tasks</h2>
<p>These are tasks that our AI can <a id="_idIndexMarker1097"/>perform. Unreal Engine provides us with built-in tasks for us to use by default, but we can also create our own in both Blueprints and C++. This includes tasks such as telling our AI to <strong class="bold">Move To</strong> a specific location, <strong class="bold">Rotate To Face Target</strong>, and even telling the AI to fire its weapon. It’s also important to know that you can create custom tasks using Blueprints. Let’s briefly discuss two of the tasks you will be using to develop the AI for the enemy character:</p>
<ul>
<li><code>Behavior Trees</code>, and you will be using this task in the upcoming exercises in this chapter. <strong class="bold">Move To task</strong> uses the navigation system to tell the AI how and where to move based on the location it is given. You will use this task to tell the AI enemy where to go.</li>
<li><code>Behavior Trees</code> because it allows a delay inbetween task execution if the logic requires it. This can be used to allow the AI to wait a few seconds before moving to a new location.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for tasks, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/</a>.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor282"/>Decorators</h2>
<p>Decorators are conditions that can be added to tasks or <strong class="bold">Composite</strong> nodes, such as a <strong class="bold">Sequence</strong> or <strong class="bold">Selector</strong>, that allow branching logic to occur. As an example, we can have a <strong class="bold">Decorator</strong> that checks whether or not the <a id="_idIndexMarker1098"/>enemy knows the location of the player. If so, we can tell that enemy to move toward that last known location. If not, we can tell our AI to generate a new location and move there instead. It is also important to know that you can create custom decorators using Blueprints.</p>
<p>Let’s also briefly discuss the decorator you will be using to develop the AI for the enemy character – the <code>Behavior Trees</code> is not executing until you know the AI has reached its given location.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for decorators, please refer to the following documentation: <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/</a>.</p>
<p>Now that we have a better understanding of Task nodes, let’s briefly discuss Service nodes.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor283"/>Services</h2>
<p>Services work a lot like decorators<a id="_idIndexMarker1099"/> because they can be linked with tasks and <code>Composite</code> nodes. The main difference is that a <strong class="bold">Service</strong> allows us to execute a branch of nodes based on the interval defined in the service. It is also important to know that you can create custom services using Blueprints. </p>
<p class="callout-heading">Note</p>
<p class="callout">For more information regarding the C++ API for services, please refer to the following documentation:  <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/</a>.</p>
<p>With knowledge of <a id="_idIndexMarker1100"/>Composite, Task, and Service nodes under our belt, let’s move on to the next exercise where we will create the <code>Behavior Tree</code> and <code>Blackboard</code> for the enemy.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor284"/>Exercise 13.04 – creating the AI behavior tree and Blackboard</h2>
<p>Now that you have had an <a id="_idIndexMarker1101"/>overview of <code>Behavior Trees</code> and <code>Blackboards</code>, this exercise will guide you through creating these assets, telling the AI Controller to use the <code>Behavior Tree</code> you<a id="_idIndexMarker1102"/> created, and assigning the <code>Blackboard</code> to the <code>Behavior Tree</code>. The <code>Blackboard</code> and <code>Behavior Tree</code> assets you will create here will be used for the <code>SuperSideScroller</code> game. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Within the <code>/Enemy/AI</code> directory. This is the same directory where you created the AI Controller. </li>
<li>In this directory, <em class="italic">right-click</em> within the blank area of the <code>Behavior Tree</code> asset. Name this asset <code>BT_EnemyAI</code>.</li>
<li>In the same directory as the previous step, <em class="italic">right-click</em> again within the blank area of the <code>Blackboard</code> asset. Name this asset <code>BB_EnemyAI</code>.</li>
</ol>
<p>Before we move on to telling the AI Controller to run this new <code>Behavior Tree</code>, let’s assign the <code>Blackboard</code> to this <code>Behavior Tree</code> so that they are connected.</p>
<ol>
<li value="4">Open <code>BT_EnemyAI</code> by <em class="italic">double-clicking</em> the asset in the <code>Blackboard Asset</code> parameter.</li>
<li><em class="italic">Left-click</em> the drop-down menu on this parameter and find the <code>BB_EnemyAI</code> <code>Blackboard</code> asset you created earlier. Compile and save the <code>Behavior Tree</code>before closing it.</li>
<li>Next, open the AI Controller’s <code>BP_AIController_Enemy</code> asset by <em class="italic">double-clicking</em> it inside the <code>Run Behavior Tree</code> function.</li>
</ol>
<p>The <code>Run Behavior Tree</code> function is <a id="_idIndexMarker1103"/>very straightforward: you assign a <code>Behavior Tree</code> successfully began its execution.</p>
<ol>
<li value="7">Lastly, connect the <code>Run Behavior Tree</code> function and assign <code>BT_EnemyAI</code>, which you created earlier in this exercise:</li>
</ol>
<div><div><img alt="Figure 13.12 – Assigning the BT_EnemyAI behavior tree " height="401" src="img/Figure_13.12_B18531.jpg" width="620"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Assigning the BT_EnemyAI behavior tree</p>
<ol>
<li value="8">With this exercise <a id="_idIndexMarker1105"/>complete, the enemy AI Controller now knows<a id="_idIndexMarker1106"/> to run the <strong class="bold">BT_EnemyAI</strong> Behavior Tree, and this Behavior Tree knows to use the Blackboard asset called <strong class="bold">BB_EnemyAI</strong>. With this in place, you can begin to use the Behavior Tree logic to develop the AI so that the enemy character can move around the level.</li>
</ol>
<h2 id="_idParaDest-257"><a id="_idTextAnchor285"/>Exercise 13.05 – creating a new behavior tree task</h2>
<p>The goal of this exercise is to <a id="_idIndexMarker1107"/>develop an AI task for the enemy AI that will allow the character to find a random point to move to within the bounds of the <strong class="bold">Nav Mesh</strong> Volume in your level.</p>
<p>Although the <code>SuperSideScroller</code> game will only allow two-dimensional movement, let’s get the AI to move anywhere within the 3D space of the level that you created in <em class="italic">Activity 13.01 – creating a new level</em>, and then work to constrain the enemy to two dimensions. </p>
<p>Follow these steps to create this new task for the enemy:</p>
<ol>
<li value="1">First, open the <code>Blackboard</code> asset you created in the previous exercise, <code>BB_EnemyAI</code>.</li>
<li><em class="italic">Left-click</em> on the <code>Blackboard</code> and select the <strong class="bold">Vector</strong> option. Name this vector <strong class="bold">MoveToLocation</strong>. You will use this <strong class="bold">vector</strong> variable to track the next move for the AI as it decides where to move to.</li>
</ol>
<p>For this enemy AI, you will need to create a new <strong class="bold">Task</strong> because the currently available tasks inside Unreal do not fit the needs of the enemy behavior.</p>
<ol>
<li value="3">Navigate to and open the <code>Behavior Tree</code> asset you created in the previous exercise, <code>BT_EnemyAI</code>.</li>
<li><em class="italic">Left-click</em> on the <code>Task</code>, it will automatically open the task asset for you. However, if you have already created a task, a <a id="_idIndexMarker1108"/>dropdown list of options will appear when selecting the <strong class="bold">New Task</strong> option. Before working on the logic of this <strong class="bold">Task</strong>, you must rename the asset.</li>
<li>Close the <code>BTTask_BlueprintBase_New</code>. Rename this asset <code>BTTask_FindLocation</code>.</li>
<li>With the new <strong class="bold">Task</strong> asset named, <em class="italic">double-click</em> to open <strong class="bold">Task Editor</strong>. New tasks will have empty Blueprint graphs and will not provide you with any default events to use in the graph. </li>
<li><em class="italic">Right-click</em> within the graph and from the context-sensitive search, find the <strong class="bold">Event Receive Execute AI</strong> option. </li>
<li><em class="italic">Left-click</em> the <strong class="bold">Event Receive Execute AI</strong> option to create the event node in the <strong class="bold">Task</strong> graph, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 13.13 – Event Receive Execute AI returns both Owner Controller and Controlled Pawn " height="186" src="img/Figure_13.13_B18531.jpg" width="665"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – Event Receive Execute AI returns both Owner Controller and Controlled Pawn</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>Event Receive Execute AI</code> event will give you access to both <strong class="bold">Owner Controller</strong> and <strong class="bold">Controlled Pawn</strong>. You will use <strong class="bold">Controlled Pawn</strong> for this task in the upcoming steps.</p>
<ol>
<li value="9">Each <code>Finish Execute</code> function so that the <code>Behavior Tree</code> asset knows when it can move on to the next <code>Task</code> or branches of the tree. <em class="italic">Right-click</em> in the graph and search for <code>Finish Execute</code> via the context-sensitive search.</li>
<li><em class="italic">Left-click</em> the <strong class="bold">Finish Execute</strong> option from the context-sensitive search to create the node inside the Blueprint graph of your <strong class="bold">Task</strong>, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 13.14 – The Finish Execute function, which has a Boolean parameter that determines whether the task is successful " height="180" src="img/Figure_13.14_B18531.jpg" width="293"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – The Finish Execute function, which has a Boolean parameter that determines whether the task is successful</p>
<ol>
<li value="11">The next function that you need is called <strong class="bold">GetRandomLocationInNavigableRadius</strong>. This function, as its name suggests, returns a random vector location within a defined radius of the navigable area. This will allow the enemy character to find random locations and move to those locations.</li>
<li><em class="italic">Right-click</em> in the graph and search for <code>GetRandomLocationInNavigableRadius</code> inside the context-sensitive search. <em class="italic">Left-click</em> the <strong class="bold">GetRandomLocationInNavigableRadius</strong> option to place this function inside the graph.</li>
</ol>
<p>With these two functions in<a id="_idIndexMarker1110"/> place, and with <strong class="bold">Event Receive Execute</strong> AI-ready, it is time to obtain the random location for the enemy AI.</p>
<ol>
<li value="13">From the <code>GetActorLocation</code> function via the context-sensitive search:</li>
</ol>
<div><div><img alt="Figure 13.15 – The enemy pawn’s location will serve as the origin of the random point selection " height="296" src="img/Figure_13.15_B18531.jpg" width="873"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – The enemy pawn’s location will serve as the origin of the random point selection</p>
<ol>
<li value="14">Connect the vector return value from <code>GetRandomLocationInNavigableRadius</code> function, as shown in the following screenshot. Now, this function will use the enemy AI pawn’s location as the origin for determining the next random point:</li>
</ol>
<div><div><img alt="Figure 13.16 – Now, the enemy pawn location will be used as the origin of the random point vector search " height="298" src="img/Figure_13.16_B18531.jpg" width="922"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – Now, the enemy pawn location will be used as the origin of the random point vector search</p>
<ol>
<li value="15">Next, you need to tell the <code>GetRandomLocationInNavigableRadius</code> function the radius in which to check for the random point in the navigable area of the level. Set this <a id="_idIndexMarker1111"/>value to <code>1000.0f</code>.</li>
</ol>
<p>The remaining parameters, <code>Nav Data</code> and <code>Filter Class</code>, can remain as is. Now that you are getting a random location from <code>GetRandomLocationInNavigableRadius</code>, you will need to be able to store this value in the <code>Blackboard</code> vector that you created earlier in this exercise.</p>
<ol>
<li value="16">To get a reference to the <code>Blackboard</code> vector variable, you need to create a new variable inside of this <code>Task</code> that’s of the <code>Blackboard Key Selector</code> type. Create this new variable and name it <code>NewLocation</code>.</li>
<li>Now, you need to make this variable a <code>Public</code> variable so that it can be exposed inside the <code>Behavior Tree</code>. <em class="italic">Left-click</em> on the “eye” icon so that the eye is visible.</li>
<li>With the <code>Blackboard Key Selector</code> variable ready, <em class="italic">left-click</em> and drag out a <code>Getter</code> of this variable. Then, pull from this variable and search for <code>Set Blackboard Value as Vector</code>, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 13.17 – Set Blackboard Value has a variety of different types to support the different variables that can exist inside the Blackboard " height="194" src="img/Figure_13.17_B18531.jpg" width="691"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.17 – Set Blackboard Value has a variety of different types to support the different variables that can exist inside the Blackboard</p>
<ol>
<li value="19">Connect the <code>RandomLocation</code> output vector from <code>GetRandomLocationInNavigableRadius</code> to the <code>Value</code> vector input parameter of <code>Set Blackboard Value as Vector</code>. Then, connect the execution pins of these<a id="_idIndexMarker1112"/> two function nodes. The result will look as follows:</li>
</ol>
<div><div><img alt="Figure 13.18 – Now, the Blackboard vector value is assigned to this new random location " height="254" src="img/Figure_13.18_B18531.jpg" width="898"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.18 – Now, the Blackboard vector value is assigned to this new random location</p>
<p>Lastly, you will use the <code>Return Value</code> Boolean output parameter of the <code>GetRandomLocationInNavigableRadius</code> function to determine whether the task executes successfully.</p>
<ol>
<li value="20">Connect the Boolean output parameter to the <code>Success</code> input parameter of the <code>Finish Execute</code> function and connect the execution pins of the <strong class="bold">Set Blackboard Value as Vector</strong> and <strong class="bold">Finish Execute</strong> function nodes. The following screenshot shows the final result of the <strong class="bold">Task</strong> logic:</li>
</ol>
<div><div><img alt="Figure 13.19 – The final setup for the task " height="345" src="img/Figure_13.19_B18531.jpg" width="1627"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.19 – The final setup for the task</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/3lmLyk5">https://packt.live/3lmLyk5</a>.</p>
<p>By completing this exercise, you <a id="_idIndexMarker1113"/>have created your first custom <code>Behavior Tree</code> and see the enemy AI move around your level.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor286"/>Exercise 13.06 – creating the behavior tree logic</h2>
<p>The goal of this exercise is to implement the <a id="_idIndexMarker1114"/>new task you created in the previous exercise inside the <code>Behavior Tree</code> to have the enemy AI find a random location within the navigable space of your level and then move to this location. You will use a combination of the <strong class="bold">Composite</strong>, <strong class="bold">Task</strong>, and <strong class="bold">Service</strong> nodes to accomplish this behavior. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">To start, open the <code>Behavior Trees</code> you created in <em class="italic">Exercise 13.04 – creating the AI behavior tree and Blackboard</em>, which is <code>BT_EnemyAI</code>. </li>
<li>Inside this <code>Behavior Tree</code>, <em class="italic">left-click</em> and drag from the bottom of the <code>Root</code> node and select the <code>Root</code> that’s connected to the <strong class="bold">Sequence</strong> Composite node.</li>
<li>Next, from the <strong class="bold">Sequence</strong> node, <em class="italic">left-click</em> and drag to bring up the context-sensitive menu. In this menu, search for the task you created in the previous exercise – that is, <strong class="bold">BTTask_FindLocation</strong>.</li>
<li>By default, the <code>Blackboard</code>. If this doesn’t happen, you can assign this Selector manually in the <strong class="bold">Details</strong> panel of the task.</li>
</ol>
<p>Now, <code>Blackboard</code>. This means that the random location that’s returned from the task will be assigned to the <code>Blackboard</code> variable<a id="_idIndexMarker1115"/> and you can reference this variable in other tasks.</p>
<p>Now that you have found a valid random location and assigned this location to the <code>Blackboard</code> variable – that is, <strong class="bold">MovetoLocation</strong> – you can use the <strong class="bold">Move To</strong> task to tell the AI to move to this location.</p>
<ol>
<li value="5"><em class="italic">Left-click</em> and pull from the <code>Behavior Tree</code> will now look as follows:</li>
</ol>
<div><div><img alt="Figure 13.20 – After selecting the random location, the Move To task will let the AI move to this new location " height="500" src="img/Figure_13.20_B18531.jpg" width="815"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.20 – After selecting the random location, the Move To task will let the AI move to this new location</p>
<ol>
<li value="6">By default, the <code>50.0f</code>.</li>
</ol>
<p>Now, the <code>Behavior Tree</code> finds the<a id="_idIndexMarker1116"/> random location using the <code>Blackboard</code> vector variable called <strong class="bold">MovetoLocation</strong>.</p>
<p>The last thing to do here is to add a decorator to the <strong class="bold">Sequence</strong> Composite node so that the enemy character is not at a random location before the tree is executed again to find and move it to that new location.</p>
<ol>
<li value="7"><em class="italic">Right-click</em> on the top area of the <strong class="bold">Sequence</strong> node and select <strong class="bold">Add Decorator</strong>. From the dropdown, <em class="italic">left-click</em> and select <strong class="bold">Is at Location</strong>.</li>
<li>Since you already have a vector parameter inside <code>Blackboard</code>, the <strong class="bold">Is at Location</strong> decorator should automatically assign the <strong class="bold">MoveToLocation</strong> vector variable as <strong class="bold">Blackboard Key</strong>. Verify this by selecting the decorator and making sure <strong class="bold">Blackboard Key</strong> is assigned to <strong class="bold">MoveToLocation</strong>.</li>
<li>With the decorator in place, you have completed the <code>Behavior Tree</code>. The final result will look as follows:</li>
</ol>
<div><div><img alt="Figure 13.21 – The final setup for the behavior tree for the AI enemy " height="554" src="img/Figure_13.21_B18531.jpg" width="947"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.21 – The final setup for the behavior tree for the AI enemy</p>
<p>This <code>Behavior Tree</code> is telling the AI to find a random location using <code>Blackboard</code> <code>Behavior Tree</code> will execute the <strong class="bold">Move To</strong> task, which will tell the AI to move to this new random location. The <strong class="bold">Sequence</strong> node is wrapped in a decorator that ensures that the enemy AI is at <strong class="bold">MoveToLocation</strong> before executing again, just as a safety net for the AI.</p>
<ol>
<li value="10">Before you can test the new AI behavior, make sure that you have placed <strong class="bold">BP_Enemy AI</strong> into your level if one is not already there from previous exercises and activities.</li>
<li>Now, if you use <strong class="bold">PIE</strong> or <strong class="bold">Simulate</strong>, you will see the enemy AI run around the map and move to random<a id="_idIndexMarker1118"/> locations within the <strong class="bold">Nav Mesh Volume</strong>:</li>
</ol>
<div><div><img alt="Figure 13.22 – The enemy AI will now move from location to location " height="651" src="img/Figure_13.22_B18531.jpg" width="1106"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.22 – The enemy AI will now move from location to location</p>
<p class="callout-heading">Note</p>
<p class="callout">There can be some cases where the enemy AI will not move. This can be caused by the GetRandomLocationInNavigableRadius function not returning <code>True</code>. This is a known issue, and if it occurs, please restart the editor and try again.</p>
<ol>
<li value="12">By completing this exercise, you have created a fully functional <code>Behavior Tree</code> that allows the enemy AI to find and move to a random location within the navigable bounds of your level using<strong class="bold"> </strong>the <strong class="bold">Nav Mesh Volume</strong>. The task you created in the previous exercise allows you to find this random point, while the <strong class="bold">Move To</strong> task allows the AI character to move toward this new location.</li>
</ol>
<p>Due to how the <code>Behavior Tree</code> start over and choose a new random location.</p>
<p>Now, you can move on to<a id="_idIndexMarker1119"/> the next activity, where you will add to this <code>Behavior Tree</code> to have the AI wait between selecting a new random point so that the enemy isn’t constantly moving.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor287"/>Activity 13.02 – AI moving to the player’s location</h2>
<p>In the previous exercise, you made the AI enemy character move to random locations within the bounds of <strong class="bold">Nav Mesh</strong> Volume <a id="_idIndexMarker1120"/>by using a custom <strong class="bold">Task</strong> and the <strong class="bold">Move To</strong> task together.</p>
<p>In this activity, you will continue from the previous exercise and update the <code>Behavior Tree</code>. You will take advantage of the <strong class="bold">Wait</strong> task by using a decorator, and also create a new custom task to have the AI follow the player character and update its position every few seconds. </p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Inside the <strong class="bold">BT_EnemyAI Behavior Tree</strong> that you created in the previous exercise, you will continue from where you left off and create a new task. Do this by selecting <strong class="bold">New Task</strong> from the toolbar and choosing <strong class="bold">BTTask_BlueprintBase</strong>. Name this new task <strong class="bold">BTTask_FindPlayer</strong>.</li>
<li>In the <strong class="bold">BTTask_FindPlayer</strong> task, create a new event called <strong class="bold">Event Receive Execute AI</strong>.</li>
<li>Find the <code>Get Player Character</code> function to get a reference to the player; make sure that you use <strong class="bold">Player Index 0</strong>. </li>
<li>From the player character, call the <code>Get Actor Location</code> function to find the player’s current location.</li>
<li>Create a new <code>Blackboard</code> Key <code>Selector</code> variable inside this task. Name this variable <code>NewLocation</code>.</li>
<li><em class="italic">Left-click</em> and drag the <code>NewLocation</code> variable into the graph. From this variable, search for the <code>Set Blackboard Value</code> function as a <code>Vector</code>.</li>
<li>Connect <code>Vector</code> function to the execution pin of the event’s <strong class="bold">Receive Execute AI</strong> node.</li>
<li>Add the <code>Finish Execute</code> function, ensuring that the Boolean <code>True</code>.</li>
<li>Lastly, connect <code>Vector</code> function to the <code>Finish Execute</code> function.</li>
<li>Save and compile the task Blueprint and return to the<code>BT_EnemyAI</code> <code>Behavior Tree</code>.</li>
<li>Replace the <strong class="bold">BTTask_FindLocation</strong> task with the new <strong class="bold">BTTask_FindPlayer</strong> task so that this new task is <a id="_idIndexMarker1121"/>now the first task underneath the <strong class="bold">Sequence</strong> Composite node.</li>
<li>Add a new <code>PlaySound</code> task as the third task underneath the <strong class="bold">Sequence</strong> Composite node by following the custom <strong class="bold">BTTask_FindLocation</strong> and <strong class="bold">Move To</strong> tasks.</li>
<li>In the <code>Sound to Play</code> parameter, add the <strong class="bold">Explosion_Cue SoundCue</strong> asset.</li>
<li>Add an <strong class="bold">Is At Location</strong> decorator to the <strong class="bold">PlaySound</strong> task and ensure that the <strong class="bold">MovetoLocation</strong> Key is assigned to this <strong class="bold">Decorator</strong>.</li>
<li>Add a new <strong class="bold">Wait</strong> task as the fourth task underneath the <strong class="bold">Sequence</strong> Composite node following the <strong class="bold">PlaySound</strong> tasks.</li>
<li>Set the <code>2.0f</code> seconds before completing successfully. </li>
</ol>
<p>The expected output is as follows:</p>
<div><div><img alt="Figure 13.23 – Enemy AI following the player and updating to the player’s location every 2 seconds " height="597" src="img/Figure_13.23_B18531.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.23 – Enemy AI following the player and updating to the player’s location every 2 seconds</p>
<p>The enemy AI character will move to the <a id="_idIndexMarker1122"/>player’s last known location in the navigable space of the level and pause for <code>2.0f</code> seconds between each player position. </p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity complete, you have learned how to create a new task that allows the AI to find the player’s location and move to the player’s last known position. Before moving on to the next set of exercises, remove the <code>Behavior</code> <code>Tree</code> is returned correctly. You will be using the <strong class="bold">BTTask_FindLocation</strong> task in the upcoming exercises.</p>
<p>In the next exercise, you will address this issue by developing a new Blueprint actor that will allow you to set up specific positions that the AI can move toward.</p>
<h2 id="_idParaDest-260">Exercise<a id="_idTextAnchor288"/> 13.07 – creating the enemy patrol locations</h2>
<p>The current issue <a id="_idIndexMarker1123"/>with the AI enemy character is that they can move freely around the 3D navigable space because the <code>Behavior Tree</code> allows them to find a random location within that space. Instead, the AI needs to be given patrol points that you can specify and change in the editor. Then, it will choose one of these patrol points at random to move to. This is what you will do for the <code>SuperSideScroller</code> game: create patrol points that the enemy AI can move to. This exercise will show you how to create these patrol points using a simple <strong class="bold">Blueprint</strong> actor. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, navigate to the <strong class="bold">/Enemy/Blueprints/</strong> directory. This is where you will create the new Blueprint actor that will be used for the AI patrol points.</li>
<li>In this directory, <em class="italic">right-click</em> and choose the <strong class="bold">Blueprint Class</strong> option by <em class="italic">left-clicking</em> this option from the menu.</li>
<li>From the <code>Actor</code> class:</li>
</ol>
<div><div><img alt="Figure 13.24 – The Actor class is the base class for all objects that can be placed or spawned in the game world " height="105" src="img/Figure_13.24_B18531.jpg" width="634"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.24 – The Actor class is the base class for all objects that can be placed or spawned in the game world</p>
<ol>
<li value="4">Name this new asset <strong class="bold">BP_AIPoints</strong> and open this Blueprint by <em class="italic">double-clicking</em> the asset in the <strong class="bold">Content Drawer</strong> interface.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The interface for Blueprints shares many of the same features and layouts as other systems, such as Animation Blueprints and tasks, so this should all look familiar to you.</p>
<ol>
<li value="5">Navigate to the <code>Points</code>.</li>
<li>From the <strong class="bold">Variable Type</strong> dropdown, <em class="italic">left-click</em> and select the <strong class="bold">Vector</strong> option.</li>
<li>Next, you will need to make this vector variable an <strong class="bold">Array</strong> so that you can store multiple patrol locations. <em class="italic">Left-click</em> the yellow icon next to <strong class="bold">Vector</strong> and <em class="italic">left-click</em> to select the <strong class="bold">Array</strong> option.</li>
<li>The last step for setting up the <code>Show</code> <strong class="bold">3D Widget</strong> option is only available for variables that involve an actor transform, such as vectors and transforms.</li></ul></li>
</ol>
<p>With the simple actor set up, it is time to place the actor in the level and begin setting up the patrol point locations.</p>
<ol>
<li value="9">Add the <strong class="bold">BP_AIPoints</strong> actor Blueprint to your level, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 13.25 – The BP_AIPoints actor is now in the level " height="681" src="img/Figure_13.25_B18531.jpg" width="1037"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.25 – The BP_AIPoints actor is now in the level</p>
<ol>
<li value="10">With the <strong class="bold">BP_AIPoints</strong> actor selected, navigate to its <strong class="bold">Details</strong> panel and find the <strong class="bold">Points</strong> variable.</li>
<li>Next, you can add a new <a id="_idIndexMarker1125"/>element to the vector array by <em class="italic">left-clicking</em> on the <strong class="bold">+</strong> symbol, as shown here:</li>
</ol>
<div><div><img alt="Figure 13.26 – You can have many elements inside an array, but the larger the array, the more memory is allocated " height="95" src="img/Figure_13.26_B18531.jpg" width="691"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.26 – You can have many elements inside an array, but the larger the array, the more memory is allocated</p>
<ol>
<li value="12">When you add a new element to the vector array, you will see a 3D widget appear that you can then <em class="italic">left-click</em> to select and move around the level, as shown here:</li>
</ol>
<div><div><img alt="Figure 13.27 – The first patrol point vector location " height="259" src="img/Figure_13.27_B18531.jpg" width="554"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.27 – The first patrol point vector location</p>
<p class="callout-heading">Note</p>
<p class="callout">As you update the position of the 3D widget that represents the element of the vector array, the 3D coordinates will update in the <strong class="bold">Details</strong> panel for the <strong class="bold">Points</strong> variable.</p>
<ol>
<li value="13">Finally, add as many<a id="_idIndexMarker1126"/> elements into the vector array as you would like for the context of your level. Keep in mind that the positions of these patrol points should line up so that they make a straight line along the horizontal axis, parallel to the direction in which the character will move. The following screenshot shows the setup in the example <code>SideScroller.umap</code> level that’s included in this exercise:</li>
</ol>
<div><div><img alt="Figure 13.28 – The example patrol point path, as seen in the SideScroller.umap example level " height="651" src="img/Figure_13.28_B18531.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.28 – The example patrol point path, as seen in the SideScroller.umap example level</p>
<ol>
<li value="14">Continue to repeat the previous step to create multiple patrol points and position the 3D widgets as you see fit. You can use the provided <strong class="bold">SideScroller.umap</strong> example level as a reference on how to set up these patrol points. </li>
</ol>
<p>By completing this exercise, you <a id="_idIndexMarker1127"/>have created a new <code>Behavior Tree</code> so that the AI can move between these patrol points. Before you set up this functionality, let’s learn a bit more about vectors and Vector Transformation, as this knowledge will prove useful in the next exercise.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor289"/>Vector Transformation</h1>
<p>Before you jump <a id="_idIndexMarker1128"/>into the next exercise, it is important that you learn about Vector Transformation and, more importantly, what the <code>Transform Location</code> function does. When it comes to an actor’s location, there are two ways of thinking of its position: in terms of world space and local space. An actor’s position in world space is its location relative to the world itself; in more simple terms, this is the location where you place the actor in the level. An actor’s local position is its location relative to either itself or a parent actor. </p>
<p>Let’s consider the <strong class="bold">BP_AIPoints</strong> actor as an example of what world space and local space are. Each of the locations of the <strong class="bold">Points</strong> array is a local-space vector because they are positions relative to the world-space position of the <strong class="bold">BP_AIPoints</strong> actor itself. The following screenshot shows the list of vectors in the <strong class="bold">Points</strong> array, as shown in the previous exercise. These values are positions relative to the location of the <strong class="bold">BP_AIPoints</strong> actor in your level:</p>
<div><div><img alt="Figure 13.29 – The local-space position vectors of the Points array, relative to the world-space position of the BP_AIPoints actor " height="287" src="img/Figure_13.29_B18531.jpg" width="881"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.29 – The local-space position vectors of the Points array, relative to the world-space position of the BP_AIPoints actor</p>
<p>To have the enemy AI <a id="_idIndexMarker1129"/>move to the correct world space location of these points, you need to use a function called <code>Transform Location</code>. This function takes in two parameters:</p>
<ul>
<li><code>T</code>: This is the supplied transform that you will use to convert the vector location parameter from a local-space value into a world-space value.</li>
<li><code>Location</code>: This is the location that is to be converted from local space into world space.</li>
</ul>
<p>The result of this Vector Transformation is then returned as the return value of the function. You will use this function in the next exercise to return a randomly selected vector point from the <code>Points</code> array and convert that value from a local-space vector into a world-space vector. This new world-space vector will then be used to tell the enemy AI where to move relative to <a id="_idIndexMarker1130"/>the world. Let’s implement this now. </p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor290"/>Exercise 13.08 – selecting a random point in an array</h2>
<p>Now that you know more about vectors <a id="_idIndexMarker1131"/>and Vector Transformation, in this exercise, you will create a simple <code>Blueprint</code> function to select one of the <em class="italic">patrol point</em> vector locations and transform its vector from a local space value into a world space value using a built-in function called <code>Behavior Tree</code> so that the AI will move to the correct position. This exercise will be performed within the UE5 editor.</p>
<p>Follow these steps to complete this exercise. Let’s start by creating the new function:</p>
<ol>
<li value="1">Navigate back to the <code>GetNextPoint</code>.</li>
<li>Before you add logic to this function, select this function by <em class="italic">left-clicking</em> it under the <strong class="bold">Functions</strong> category to access its <strong class="bold">Details</strong> panel.</li>
<li>In the <strong class="bold">Details</strong> panel, enable the <strong class="bold">Pure</strong> parameter so that this function is labeled as a <strong class="bold">Pure Function</strong>. You learned about <strong class="bold">Pure Functions</strong> in <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>, when working in the Animation Blueprint for the player character; the same thing is happening here.</li>
<li>Next, the <code>GetNextPoint</code> function needs to return a vector that the <code>Behavior Tree</code> can use to tell the enemy AI where to move to. Add this new output by <em class="italic">left-clicking</em> on the <code>NextPoint</code>, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 13.30 – Functions can return multiple variables of different types, depending on the needs of your logic " height="67" src="img/Figure_13.30_B18531.jpg" width="688"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.30 – Functions can return multiple variables of different types, depending on the needs of your logic</p>
<ol>
<li value="5">When adding an <strong class="bold">Output</strong> variable, the function will automatically generate a <strong class="bold">Return</strong> node and place it in the <a id="_idIndexMarker1132"/>function graph, as shown in the following screenshot. You will use this output to return the new vector patrol point for the enemy AI to move to:</li>
</ol>
<div><div><img alt="Figure 13.31 – The automatically generated Return Node for the function, including the Next Point vector output variable " height="202" src="img/Figure_13.31_B18531.jpg" width="690"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.31 – The automatically generated Return Node for the function, including the Next Point vector output variable</p>
<p>Now that the function’s groundwork is completed, let’s start adding the logic.</p>
<ol>
<li value="6">To pick a random position, first, you need to find the length of the <code>Points</code> array. Create a <code>Points</code> vector and from this vector variable, <em class="italic">left-click</em> and drag to search for the <code>Length</code> function, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 13.32 – The Length function is a pure function that returns the length of the array " height="256" src="img/Figure_13.32_B18531.jpg" width="892"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.32 – The Length function is a pure function that returns the length of the array</p>
<ol>
<li value="7">With the integer output of the <code>Length</code> function, <em class="italic">left-click</em> and drag out to use the context-sensitive <a id="_idIndexMarker1133"/>search to find the <code>Random Integer</code> function, as shown in the following screenshot. The <code>Random Integer</code> function returns a random integer between <code>0</code> and <code>Max value</code>; in this case, this is the length of the <code>Points</code> vector array:</li>
</ol>
<div><div><img alt="Figure 13.33 – Using Random Integer will allow the function to return a random vector from the Points vector array " height="268" src="img/Figure_13.33_B18531.jpg" width="1059"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.33 – Using Random Integer will allow the function to return a random vector from the Points vector array</p>
<p>Here, you are generating a random integer between 0 and the length of the <code>Points</code> vector array. Next, you need to find the element of the <code>Points</code> vector array at the index position of the returned <code>Random Integer</code> function.</p>
<ol>
<li value="8">Do this by creating a new <code>Getter of the Points</code> vector array. Then, <em class="italic">left-click</em> and drag to search for the <code>Get(a copy)</code>function.</li>
<li>Next, connect the return value of the <code>Random Integer</code> function to the input of the <code>Get (a copy)</code> function. This will tell the function to choose a random integer and use that integer as the index to return from the <code>Points</code> vector array.</li>
</ol>
<p>Now that you are getting a random vector from the <code>Points</code> vector array, you need to use the <code>Transform Location</code> function to convert the location from a local space vector into a world space vector.</p>
<p>As you have learned <a id="_idIndexMarker1134"/>already, the vectors in the <code>Points</code> vector array are local space positions relative to the position of the <code>BP_AIPoints</code> actor in the level. As a result, you need to use the <code>Transform Location</code> function to convert the randomly selected local space vector into a world space vector so that the AI enemy moves to the correct position.</p>
<ol>
<li value="10"><em class="italic">Left-click</em> and drag from the vector output of the <code>Get(a copy)</code>function and, via the context-sensitive search, find the <code>Transform Location</code> function.</li>
<li>Connect the vector output of the <code>Get(a copy)</code>function to the <code>Location</code> input of the <code>Transform Location</code> function.</li>
<li>The final step is to use the transform of the Blueprint actor itself as the <code>T</code> parameter of the <code>Transform Location</code> function. Do this by <em class="italic">right-clicking</em> inside the graph and, via the context-sensitive search, finding the <code>GetActorTransform</code> function and connecting it to the <code>Transform Location</code> parameter, <code>T</code>. </li>
<li>Finally, connect the <code>Return Value</code> vector from the <code>Transform Location</code> function and connect it to the <code>NewPoint</code> vector output of the function:</li>
</ol>
<div><div><img alt="Figure 13.34 – The final logic has been set up for the GetNextPoint function " height="481" src="img/Figure_13.34_B18531.jpg" width="1106"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.34 – The final logic has been set up for the GetNextPoint function</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/35jlilb">https://packt.live/35jlilb</a>.</p>
<p>By completing this exercise, you have created a new Blueprint function inside the <code>Points</code> array variable, transforms it into a world space vector value using the <code>Transform Location</code> function, and returns this new vector value. You will use this function inside the <code>Behavior Tree</code>, so that the enemy will move to one of the points you have set up. Before you can do this, the enemy AI needs a reference to the <strong class="bold">BP_AIPoints</strong> actor so that it knows which points it can select from and move to. We’ll do this in the following exercise.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor291"/>Exercise 13.09 – referencing the patrol point actor</h2>
<p>Now that the <code>Object Reference</code> variable to the enemy character Blueprint and assign the <code>Object Reference</code> variable.</p>
<p class="callout-heading">Note</p>
<p class="callout">An <code>Object Reference</code> variable stores a reference to a specific class object or actor. With this variable, you can get access to the publicly exposed variables, events, and functions that this class has available.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Navigate to the <code>/Enemy/Blueprints/</code> directory and open the enemy character Blueprint, <strong class="bold">BP_Enemy</strong>, by <em class="italic">double-clicking</em> the asset from <strong class="bold">the Content Drawer</strong> interface.</li>
<li>Create a new variable of the <code>BP_AIPoints</code> type and make sure the variable is of the <code>Object Reference</code> variable type.</li>
<li>To reference the existing <code>Instance Editable</code> parameter. Name this variable <code>Patrol Points</code>.</li>
<li>Now that you have set the object reference, navigate to your level and select your enemy AI. The following screenshot shows the enemy AI placed in the provided example level – that is, <code> SuperSideScroller.umap</code>. If you don’t have an enemy in your level, please place one now:</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Placing an enemy into a level works the same as it does for any other actor in UE5: <em class="italic">left-click</em> and drag the enemy AI Blueprint from the <strong class="bold">Content Drawer</strong> interface into the level.</p>
<div><div><img alt="Figure 13.35 – The enemy AI placed in the SuperSideScroller.umap level " height="471" src="img/Figure_13.35_B18531.jpg" width="1461"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.35 – The enemy AI placed in the SuperSideScroller.umap level</p>
<ol>
<li value="5">From its <code>Patrol Points</code> variable under the <code>BP_AIPoints</code> actor we already placed in the<a id="_idIndexMarker1137"/> level in <em class="italic">Exercise 13.07 – creating the enemy patrol locations</em>. Do this by <em class="italic">left-clicking</em> the dropdown menu for the <code>Patrol Points</code> variable and finding the actor from the list.</li>
</ol>
<p>With this exercise complete, the enemy AI in your level now has a reference to the <strong class="bold">BP_AIPoints</strong> actor in your level. With a valid reference in place, the enemy AI can use this actor to determine which set of points to move between inside the <strong class="bold">BTTask_FindLocation</strong> task. All that is left to do now is update the <strong class="bold">BTTask_FindLocation</strong> task so that it uses these points instead of finding a random location.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor292"/>Exercise 13.10 – updating BTTask_FindLocation</h2>
<p>The final step in completing the enemy AI patrolling behavior is to replace the logic inside <code>GetNextPoint</code> function from the <strong class="bold">BP_AIPoints</strong> actor instead of finding a random location within the navigable space of your level. This exercise will be performed within the UE5 editor.</p>
<p>As a reminder, go back to <em class="italic">Exercise 13.05 – creating a new behavior tree task</em>, and see what the <strong class="bold">BTTask_FindLocation</strong> task looked like before you start.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, you must take the returned <code>Patrol Points</code> object reference variable from the previous exercise:</li>
</ol>
<div><div><img alt="Figure 13.36 – Casting also ensures that the returned Controlled Pawn is of the BP_Enemy class type " height="222" src="img/Figure_13.36_B18531.jpg" width="1154"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.36 – Casting also ensures that the returned Controlled Pawn is of the BP_Enemy class type</p>
<ol>
<li value="2">Next, you can access the <code>Patrol Points</code> object reference variable by <em class="italic">left-clicking</em> and dragging from the <code>Patrol Points</code>. </li>
<li>From the <code>Patrol Points</code> reference, you can <em class="italic">left-click</em> and drag to search for the <code>GetNextPoint</code> function that you created in <em class="italic">Exercise 13.08 – selecting a random point in an array</em>.</li>
<li>Now, you can connect the <code>NextPoint</code> vector output parameter of the <code>GetNextPoint</code> function to the <code>Set Blackboard Value as Vector</code> function and connect the execution pins from the cast to the <code>Set Blackboard Value as Vector</code> function. Now, each time the <strong class="bold">BTTask_FindLocation</strong> task is executed, a new random patrol point will be set.</li>
<li>Lastly, connect the <code>Set Blackboard Value as Vector</code> function to the <code>Finish Execute</code> function and manually set the <code>Success</code> parameter to <code>True</code> so that this task will always succeed if the cast is successful.</li>
<li>As a failsafe, create a duplicate of <code>Cast</code> function. Then, set the <code>Success</code> parameter to <code>False</code>. This will act as a failsafe so that if, for any reason, <code>BP_Enemy</code> class, the task will fail. This is a good debugging practice to ensure the <a id="_idIndexMarker1139"/>functionality of the task for its intended AI class:</li>
</ol>
<div><div><img alt="Figure 13.37 – It is always good practice to account for any casting failures in your logic " height="365" src="img/Figure_13.37_B18531.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.37 – It is always good practice to account for any casting failures in your logic</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/3n58THA">https://packt.live/3n58THA</a>.</p>
<p>With the <strong class="bold">BTTask_FindLocation</strong> task updated to use the random patrol point from the <strong class="bold">BP_AIPoints</strong> actor reference in the enemy, the enemy AI will now move between the patrol points at random:</p>
<div><div><img alt="Figure 13.38 – The enemy AI is now moving between the patrol point locations in the level " height="536" src="img/Figure_13.38_B18531.jpg" width="1224"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.38 – The enemy AI is now moving between the patrol point locations in the level</p>
<p>With this exercise complete, the enemy AI now uses the reference to the <strong class="bold">BP_AIPoints</strong> actor in the level to find and move to the patrol points in the level. Each instance of the enemy character in the level <a id="_idIndexMarker1140"/>can have a reference to another unique instance of the <strong class="bold">BP_AIPoints</strong> actor or can share the same instance reference. It is up to you how you would like each enemy AI to move throughout the level.</p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor293"/>Player projectile</h1>
<p>For the last section of this chapter, you <a id="_idIndexMarker1141"/>will focus on creating the base of the player projectile, which can be used to destroy enemies. The goal is to create the appropriate actor class, introduce the required collision and projectile movement components to the class, and set up the necessary parameters for the projectile’s motion behavior.</p>
<p>For the sake of simplicity, the player projectile will not use gravity, will destroy enemies with one hit, and the projectile itself will be destroyed on hitting any surface; it will not bounce off walls, for example. The primary goal of the player projectile is to have a projectile that the player can spawn and use to destroy enemies throughout the level. In this chapter, you will set up the framework’s basic functionality, while in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, you will add sound and visual effects. Let’s get started by creating the <code>PlayerProjectile</code> class.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor294"/>Exercise 13.11 – creating the player projectile</h2>
<p>So far, we have been working in the UE5 editor to create our enemy AI. For the <code>player projectile</code> class, we will be using C++ and Visual Studio. The player projectile will allow the player to destroy enemies that <a id="_idIndexMarker1142"/>are placed in the level. This projectile will have a short lifespan, travel at a high speed, and collide with both enemies and the environment.</p>
<p>The goal of this exercise is to set up the base actor class for the player projectile and begin outlining the functions and components needed in the header file for the projectile.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, you will need to create a new C++ class by using the <code>Actor</code> class as the parent class for the player projectile. Next, name this new actor class <code>PlayerProjectile</code> and <em class="italic">left-click</em> on the <strong class="bold">Create Class</strong> option at the bottom right of the menu prompt.</li>
</ol>
<p>After creating the new class, Visual Studio will generate the required source and header files for the class and open these files for you. The <code>Actor</code> base class comes included with a handful of default functions that you will not need for the player projectile. </p>
<ol>
<li value="2">Find the following lines of code inside the <code>PlayerProjectile.h</code> file and remove them:<pre>protected:
  // Called when the game starts or when spawned
  virtual void BeginPlay() override;
public:
  // Called every frame
  virtual void Tick(float DeltaTime) override;</pre></li>
</ol>
<p>These lines of code represent the declarations of the <code>Tick()</code> and <code>BeginPlay()</code> functions that are included in every Actor-based class by default. The <code>Tick()</code> function is called on every frame and allows you to perform logic on every frame, which can get expensive, depending on what you are trying to do. The <code>BeginPlay() </code>function is called when this actor is initialized and play has started. This can be used to perform logic on the actor as soon as it enters the world. We are removing these functions because they are not required for the player projectile and will just clutter the code.</p>
<ol>
<li value="3">After removing these lines <a id="_idIndexMarker1143"/>from the <code>PlayerProjectile.h</code> header file, you can remove the following lines from the <code>PlayerProjectile.cpp</code> source files as well:<pre>// Called when the game starts or when spawned
void APlayerProjectile::BeginPlay()
{
  Super::BeginPlay();
}
// Called every frame
void APlayerProjectile::Tick(float DeltaTime)
{
  Super::Tick(DeltaTime);
}</pre></li>
</ol>
<p>These lines of code represent the function implementations of the two functions you removed in the previous step – that is, <code>Tick()</code> and <code>BeginPlay()</code>. Again, these are being removed because they serve no purpose for the player projectile and just add clutter to the code. Additionally, without the declarations inside the <code>PlayerProjectile.h</code> header file, you would receive a compilation error if you were to try to compile this code asis. The only remaining function will be the constructor for the projectile class, which you will use to initialize the components of the projectile in the next exercise. Now that you have <a id="_idIndexMarker1144"/>removed the unnecessary code from the <code>PlayerProjectile</code> class, let’s add the functions and components required for the projectile.</p>
<ol>
<li value="4">Inside the <code>PlayerProjectile.h</code> header file, add the following components:<pre>public:
  //Sphere collision component
  UPROPERTY(VisibleDefaultsOnly, Category = 
  Projectile)
  class USphereComponent* CollisionComp;
 
private:
  //Projectile movement component
  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, 
  Category = Movement, meta = 
  (AllowPrivateAccess = "true"))
  class UProjectileMovementComponent* 
  ProjectileMovement;
  //Static mesh component
  UPROPERTY(EditAnywhere, Category = Projectile)
  class UStaticMeshComponent* MeshComp;</pre></li>
</ol>
<p>You are adding three different components here. The first is the collision component, which you will use for the projectile to recognize collisions with enemies and environment assets. The next component is the projectile movement component, which you should be familiar with from the previous project. This will allow the projectile to behave like a projectile. The final component is <code>StaticMeshComponent</code>. You will use this to give the projectile a visual representation so that it can be seen in-game. </p>
<ol>
<li value="5">Next, add the following function signature code to the <code>PlayerProjectile.h</code> header file, under the <code>public</code> access modifier:<pre>UFUNCTION()
void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, 
  UPrimitiveComponent* OtherComp, FVector 
  NormalImpulse, const FHitResult&amp; 
  Hit);</pre></li>
</ol>
<p>This final event declaration will allow the player projectile to respond to <code>OnHit</code> events from the <code>CollisionComp</code> component you created in the previous step. </p>
<ol>
<li value="6">To have this code compile, you<a id="_idIndexMarker1145"/> will need to implement the function from the previous step in the <code>PlayerProjectile.cpp</code> source file. Add the following code:<pre>void APlayerProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* 
  OtherActor, UPrimitiveComponent* OtherComp, FVector 
  NormalImpulse, const 
  FHitResult&amp; Hit)
{
}</pre></li>
</ol>
<p>The <code>OnHit</code> event provides you with a lot of information about the collision that takes place. The most important parameter that you will be working with in the next exercise is the <code>OtherActor</code> parameter. The <code>OtherActor</code> parameter will tell you the actor that this <code>OnHit</code> event is responding to. This will allow you to know if this other actor is an enemy. You will use this information to destroy the enemies when the projectile hits them.</p>
<ol>
<li value="7">Lastly, navigate back into the Unreal Engine editor and <em class="italic">left-click</em> the <strong class="bold">Compile</strong> option to compile the new code.</li>
</ol>
<p>With this exercise complete, you<a id="_idIndexMarker1146"/> now have the framework ready for the <code>PlayerProjectile</code> class. The class contains the required components for <code>OnHit</code> collision so that the projectile can recognize collisions with other actors.</p>
<p>In the next exercise, you will continue to customize and enable parameters for <code>PlayerProjectile</code> so that it behaves the way you need it to for the <code>SuperSideScroller</code> project.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor295"/>Exercise 13.12 – initializing the PlayerProjectile class’s settings</h2>
<p>Now that the <a id="_idIndexMarker1147"/>framework of the <code>PlayerProjectile</code> class is in place, it’s time to update the constructor of this class with the default settings needed for the projectile so that it moves and behaves as you want it to. To do this, you will need to initialize the <strong class="bold">Projectile Movement</strong>, <strong class="bold">Collision</strong>, and <strong class="bold">Static Mesh</strong> components. </p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Open Visual Studio and navigate to the <code>PlayerProjectile.cpp</code> source file.</li>
<li>Before adding any code to the constructor, include the following files inside the <code>PlayerProjectile.cpp</code> source file:<pre>#include "GameFramework/ProjectileMovementComponent.h"
#include "Components/SphereComponent.h"
#include "Components/StaticMeshComponent.h"</pre></li>
</ol>
<p>These header files will allow you to initialize and update the parameters of the projectile movement component, the sphere collision component, and <code>StaticMeshComponent</code>, respectively. Without these files, the <code>PlayerProjectile</code> class wouldn’t know how to handle these components and how to access their functions and parameters. </p>
<ol>
<li value="3">By default, the <code>APlayerProjectile::APlayerProjectile()</code> constructor function includes the following line:<pre>PrimaryActorTick.bCanEverTick = true;</pre></li>
</ol>
<p>This line of code can be removed entirely because it is not required in the player projectile.</p>
<ol>
<li value="4">In the <code>PlayerProjectile.cpp</code> source file, add the following lines to the <code>APlayerProjectile::APlayerProjectile()</code> constructor:<pre>CollisionComp = CreateDefaultSubobject
  &lt;USphereComponent&gt;(TEXT("SphereComp"));
CollisionComp-&gt;InitSphereRadius(15.0f);
CollisionComp-&gt;BodyInstance.SetCollisionProfileName("BlockAll");
CollisionComp-&gt;OnComponentHit.AddDynamic(this, &amp;APlayerProjectile::OnHit);</pre></li>
</ol>
<p>The first line initializes the sphere collision component and assigns it to the <code>CollisionComp</code> variable you created in the previous exercise. The sphere collision component has a <a id="_idIndexMarker1148"/>parameter called <code>InitSphereRadius</code>. This will determine the size, or radius, of the collision actor by default; in this case, a value of <code>15.0f</code> works well. Next, <code>SetCollisionProfileName</code> sets the collision component to <code>BlockAll</code> so that the collision profile is set to <code>BlockAll</code>. This means this collision component will respond to <code>OnHit</code> when it collides with other objects. Lastly, the last line you added allows the <code>OnComponentHit</code> event to respond to the function you created in the previous exercise:</p>
<pre>void APlayerProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* 
  OtherActor, UPrimitiveComponent* OtherComp, FVector 
  NormalImpulse, const 
  FHitResult&amp; Hit)
{
}</pre>
<p>This means that when the collision component receives the <code>OnComponentHit</code> event from a collision event, it will respond with that function; however, this function<a id="_idIndexMarker1149"/> is empty at the moment. You will add code to this function later in this chapter.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more <a id="_idIndexMarker1150"/>about how to create custom collision profiles at <a href="https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/">https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/</a>.</p>
<ol>
<li value="5">The last thing you must do with <code>Collision Component</code> is set this component as the <code>Root Component</code> of the player projectile actor. Add the following line of code to the constructor, after the lines from <em class="italic">Step 4</em>:<pre>// Set as root component
RootComponent = CollisionComp;</pre></li>
<li>With the collision component set up and ready, let’s move on to the <code>Projectile Movement</code> component. Add the following lines to the constructor:<pre>// Use a ProjectileMovementComponent to govern this projectile's movement
ProjectileMovement = 
  CreateDefaultSubobject&lt;
  UProjectileMovementComponent&gt;(
  TEXT("ProjectileComp"))
  ;
ProjectileMovement-&gt;UpdatedComponent = CollisionComp;
ProjectileMovement-&gt;ProjectileGravityScale = 0.0f;
ProjectileMovement-&gt;InitialSpeed = 800.0f;
ProjectileMovement-&gt;MaxSpeed = 800.0f;</pre></li>
</ol>
<p>This first line initializes <code>ProjectileMovementComponent</code> and assigns it to the <code>ProjectileMovement</code> variable you created in the previous exercise. Next, we set <code>CollisionComp</code> as the updated component of the projectile movement component. The reason we’re doing this is that <code>ProjectileMovementComponent</code> will use the <code> Root</code> of the actor as the component to move. Then, we set the gravity scale of the projectile to <code>0.0f</code> because the player projectile should not be affected by gravity; this behavior should allow the projectile to <a id="_idIndexMarker1151"/>travel at the same speed, at the same height, and not be influenced by gravity. Lastly, we set both the <code>InitialSpeed</code> and <code>MaxSpeed</code> parameters to <code>500.0f</code>. This will allow the projectile to instantly start moving at this speed and remain at this speed for the duration of its lifetime. The player projectile will not support any kind of acceleration motion.</p>
<ol>
<li value="7">With the projectile movement component initialized and set up, it is time to do the same for <code>StaticMeshComponent</code>. Add the following code after the lines from the previous step:<pre>MeshComp = 
CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("MeshComp"));
MeshComp-&gt;AttachToComponent(RootComponent, 
  FAttachmentTransformRules::KeepWorldTransform);</pre></li>
</ol>
<p>This first line initializes <code>StaticMeshComponent</code> and assigns it to the <code>MeshComp</code> variable you created in the previous exercise. Then, it attaches this <code>StaticMeshComponent</code> to <code>RootComponent</code> using a struct called <code>FAttachmentTransformRules</code> to ensure that <code>StaticMeshComponent</code> keeps its world transform during the attachment, which is <code>CollisionComp</code> from <em class="italic">Step 5</em> of this exercise.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information about the <code>FAttachmentTransformRules</code> struct here: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml</a>.</p>
<ol>
<li value="8">Lastly, let’s give <code>PlayerProjectile</code> an initial life span of <code>3</code> seconds so that the projectile will automatically be<a id="_idIndexMarker1152"/> destroyed if it doesn’t collide with anything after this time. Add the following code to the end of the constructor:<pre>InitialLifeSpan = 3.0f;</pre></li>
<li>Lastly, navigate back into the Unreal Engine editor and <em class="italic">left-click</em> the <strong class="bold">Compile</strong> option to compile the new code.</li>
</ol>
<p>By completing this exercise, you have set up the groundwork for <strong class="bold">Player Projectile</strong> so that it can be created as a Blueprint actor inside the editor. All three required components have been initialized and contain the default parameters that you want for this projectile. All we need to do now is create the Blueprint from this class to see it in the level.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor296"/>Activity 13.03 – creating the player projectile Blueprint</h2>
<p>To conclude this chapter, you will create the <a id="_idIndexMarker1153"/>Blueprint actor from the new <code>PlayerProjectile</code> class and customize this actor so that it uses a placeholder shape for <code>UE_LOG()</code> function to the <code>APlayerProjectile::OnHit</code> function inside the <code>PlayerProjectile.cpp</code> source file so that you can ensure that this function is called when the projectile comes into contact with an object in the level. </p>
<p>Follow these steps:</p>
<ol>
<li value="1">Inside the <code>Projectile</code> in the <code>/MainCharacter</code> directory.</li>
<li>In this directory, create a new Blueprint from the <code>PlayerProjectile</code> class, which you created in <em class="italic">Exercise 13.11 – creating the player projectile</em>. Name this Blueprint <code>BP_PlayerProjectile</code>.</li>
<li>Open <code>MeshComp</code> component to access its settings.</li>
<li>Add the <code>Shape_Sphere</code> mesh to the <code>Static Mesh</code> parameter of the <code>MeshComp</code> component.</li>
<li>Update the transform of <code>MeshComp</code> so that it fits the <code>Scale and Location of the CollisionComp</code> component. Use the following values:<pre>Location:(X=0.000000,Y=0.000000,Z=-10.000000)
Scale: (X=0.200000,Y=0.200000,Z=0.200000)</pre></li>
<li>Compile and save the <strong class="bold">BP_PlayerProjectile</strong> Blueprint.</li>
<li>Navigate to the <code>PlayerProjectile.cpp</code> source file in Visual Studio and find the <code>APlayerProjectile::OnHit</code> function.</li>
<li>Inside the function, implement the <code>UE_LOG</code> call so that the logged line is of <code>HIT</code>. <code>UE_LOG</code> , as covered back in <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>.</li>
<li>Compile your code changes and navigate to the level where you placed the <strong class="bold">BP_PlayerProjectile</strong> actor in the previous exercise. If you haven’t added this actor to the level, do so now.</li>
<li>Before testing, make sure that you open <strong class="bold">Output Log</strong> under <strong class="bold">Window</strong>. From the <strong class="bold">Window</strong> dropdown, hover over the <strong class="bold">Developers Tools</strong> option and <em class="italic">left-click</em> to select <strong class="bold">Output Log</strong>.</li>
<li>Use <code>PIE</code> and watch out for<a id="_idIndexMarker1154"/> the log warning inside <strong class="bold">Output Log</strong> when the projectile collides with something.</li>
</ol>
<p>The following is the expected output:</p>
<div><div><img alt="Figure 13.39 – The scale of MeshComp fits the size of CollisionComp better " height="216" src="img/Figure_13.39_B18531.jpg" width="246"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.39 – The scale of MeshComp fits the size of CollisionComp better</p>
<p>The log warning should look as follows:</p>
<div><div><img alt="Figure 13.40 – When the projectile hits an object, HIT is shown in the Output Log area " height="196" src="img/Figure_13.40_B18531.jpg" width="1173"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.40 – When the projectile hits an object, HIT is shown in the Output Log area</p>
<p>With this final activity complete, <code>Throw</code> action. You will update the <code>APlayerProjectile::OnHit</code> function <a id="_idIndexMarker1155"/>so that it destroys the enemy that it collides with and becomes an effective offensive tool for the player to use against the enemies.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor297"/>Summary</h1>
<p>In this chapter, you learned how to use the different aspects of the AI tools offered by UE5, including <code>Blackboards</code>, <code>Behavior Trees</code>, and AI Controllers. By using a combination of both custom-created tasks and default tasks provided by UE5, as well as a decorator, you were able to have the enemy AI navigate within the bounds of the Nav Mesh you added to your level. </p>
<p>On top of this, you created a new <code>Blueprint</code> actor that allows you to add patrol points with the use of a <code>Vector</code> array variable. Then, you added a new function to this actor that selects one of these points at random, converts its location from local space into world space, and then returns this new value for use by the enemy character.</p>
<p>With the ability to randomly select a patrol point, you updated the custom <code>BTTask_FindLocation</code> task to find and move to the selected patrol point, allowing the enemy to move from each patrol point at random. This brought the enemy AI character to a whole new level of interaction in terms of the player and the environment.</p>
<p>Lastly, you created the <code>PlayerProjectile</code> class, which the player will be able to use to destroy enemies within the environment. You took advantage of both <code>Projectile Movement Component</code> and <code>Sphere Component</code> to allow for both projectile movement and to recognize and respond to collisions within the environment.</p>
<p>With the <code>PlayerProjectile</code> class in a functional state, it is time to move on to the next chapter, where you will use <code>Anim Notifies</code> to spawn the projectile when the player uses the <code>Throw</code> action.</p>
</div>
</div></body></html>