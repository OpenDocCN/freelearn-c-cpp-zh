- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: The “Make” Build System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “Make”构建系统
- en: In this chapter, we will learn how to automate our entire build process using
    build systems, specifically focusing on the **make** build system – an indispensable
    tool for automating the compilation and linking processes in software development.
    We start by defining what a build system is and then exploring its fundamental
    purpose, which primarily involves automatically transforming source code into
    deployable software, such as executables or libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用构建系统自动化我们的整个构建过程，特别是关注**make**构建系统——在软件开发中自动化编译和链接过程的不可或缺的工具。我们首先定义什么是构建系统，然后探讨其基本目的，这主要涉及自动将源代码转换为可部署的软件，如可执行文件或库。
- en: Throughout the chapter, we will systematically uncover the components of the
    `make` build system, starting with the essential elements of a **Makefile**, including
    *targets*, *prerequisites*, and *recipes*. In the latter part of the chapter,
    I will provide a step-by-step guide on writing a Makefile, highlighting the syntax
    and structure necessary to execute builds effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将系统地揭示`make`构建系统的组成部分，从**Makefile**的基本元素开始，包括*目标*、*依赖项*和*配方*。在章节的后半部分，我将提供编写Makefile的逐步指南，强调执行构建所需的有效语法和结构。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: An introduction to build systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建系统的简介
- en: The Make build system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make构建系统
- en: Writing Makefiles for firmware projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为固件项目编写Makefile
- en: By the end of this chapter, you will have a solid understanding of how to leverage
    the `make` build system to streamline your development process, improve build
    times, and reduce manual errors in building and deploying your firmware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将牢固地理解如何利用`make`构建系统来简化你的开发过程，提高构建时间，并减少在构建和部署固件时的手动错误。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: An introduction to build systems
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建系统的简介
- en: 'In the world of software development, build systems are pivotal tools that
    enable the transformation of source code into executable programs or other usable
    software formats. These systems automate the process of compiling and linking
    code, managing dependencies, and ensuring that software builds are reproducible
    and efficient. Simply put, a build system refers to a set of tools that automate
    the processes of compiling source code into binary code, linking binaries with
    libraries, and packaging the results into deployable software units. These systems
    are designed to handle complex dependency chains by tracking which parts of a
    software project need recompilation, thereby optimizing the build process. Build
    systems are responsible for a range of tasks. These include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的世界里，构建系统是关键的工具，它能够将源代码转换为可执行程序或其他可用的软件格式。这些系统自动化了编译和链接代码、管理依赖项以及确保软件构建可重复和高效的过程。简单来说，构建系统是指一组工具，它们自动化了将源代码编译成二进制代码、将二进制代码与库链接以及将结果打包成可部署软件单元的过程。这些系统旨在通过跟踪软件项目中哪些部分需要重新编译来处理复杂的依赖链，从而优化构建过程。构建系统负责一系列任务，包括以下内容：
- en: '**Dependency management**: This involves identifying and resolving interdependencies
    among various components or libraries that software requires.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：这涉及到识别和解决软件所需的各个组件或库之间的相互依赖关系。'
- en: '**Code compilation**: Converting source code, whether it’s written in C, C++,
    or another programming language, into machine-readable object code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编译**：将源代码（无论是用C、C++还是其他编程语言编写的）转换为机器可读的对象代码。'
- en: '**Linking**: This process integrates the compiled object files and necessary
    libraries into a unified executable or library file.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：这个过程将编译后的对象文件和必要的库集成到一个统一的可执行文件或库文件中。'
- en: '**Packaging**: This step prepares the software for deployment, which might
    include creating installer packages or compressing software into distributable
    archives.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**：这一步为软件的部署做准备，可能包括创建安装程序包或将软件压缩成可分发存档。'
- en: '**Testing and validation**: Executing automated tests to confirm that software
    adheres to the predefined quality benchmarks before its release.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation generation**: Build systems can also automate the creation
    of documentation. This is achieved by integrating with tools such as Doxygen for
    C/C++, Javadoc for Java, or Sphinx for Python, which extract annotated comments
    and metadata from source code to produce structured documentation. This automation
    ensures that documentation stays synchronized with changes in the source code,
    thereby maintaining consistency and reducing manual errors.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By incorporating these diverse functions, build systems significantly boost
    the efficiency and reliability of the software development process. Modern software
    projects often involve complex configurations, including thousands of source files
    and a wide array of external dependencies. Build systems provide a crucial framework
    to manage these complexities efficiently. They automate repetitive tasks, minimize
    the likelihood of human errors, and guarantee consistent builds across various
    environments. This streamlining not only enhances productivity but also supports
    the adoption of continuous integration and continuous delivery practices, which
    are essential for timely and effective software delivery.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a build system depends on various factors, including the programming
    language used in a project, the platform compatibility required, and the development
    team’s familiarity with the tool. Some of the commonly used build systems include
    `make` and `maven`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Make
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make is one of the oldest and most fundamental build systems available. It is
    primarily used for C and C++ projects. Make uses Makefiles to specify how to compile
    and link source files. Its primary advantage lies in its simplicity and broad
    support across different platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key features include the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: Make allows us to define explicit rules on how files should
    be compiled and linked.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make` can be used with a variety of compilers and programming languages. On
    Windows, `make` can be used in environments such as **Minimalist GNU for Windows**
    (**MinGW**) or Cygwin.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look at maven.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Maven
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Maven` is primarily used for Java projects. It is designed to provide a comprehensive
    and standard framework for building projects, handling documentation, reporting,
    dependencies, **Source Control Management** (**SCM**) systems, releases, and distribution.
    The key features include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Convention over configuration**: Maven uses a standard directory layout and
    a default build life cycle to decrease the time spent on configuring projects'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency management**: It can automatically download libraries and plugins
    from repositories and incorporate them into the build process'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project information management**: Maven can generate project documentation,
    reports, and other information from a project’s metadata'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build and release management**: Maven supports the entire build life cycle,
    from compilation, packaging, and testing to deployment and release management'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和发布管理**：Maven 支持整个构建生命周期，从编译、打包和测试到部署和发布管理。'
- en: '**Extensibility**: Maven’s plugin-based architecture allows it to be extended
    with custom plugins to support additional tasks'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Maven 的基于插件的架构允许它通过自定义插件进行扩展，以支持额外的任务。'
- en: Other notable build systems include `Apache Ant`, which is a Java-based build
    system, and `Gradle`, which supports multiple programming languages but is especially
    favored within the Java ecosystem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的构建系统包括基于 Java 的 `Apache Ant` 和支持多种编程语言的 `Gradle`，但 `Gradle` 在 Java 生态系统中特别受欢迎。
- en: 'Before exploring the specifics of the `make` build system, it is important
    to familiarize ourselves with the fundamental components of build systems. These
    components form the backbone of the build process and include the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 `make` 构建系统的具体细节之前，熟悉构建系统的基本组件非常重要。这些组件构成了构建过程的基础，包括以下内容：
- en: '**Source code**: The raw, human-readable code written in programming languages
    such as C, Java, and Python.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码**：用 C、Java、Python 等编程语言编写的原始、可读代码。'
- en: '`javac` for Java.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac` 用于 Java。'
- en: '**Linker**: The tool that combines object files into a single executable or
    library file.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接器**：将目标文件组合成单个可执行文件或库文件的工具。'
- en: '**Build scripts**: Scripts that describe the build process. They define what
    commands need to be run and their order.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建脚本**：描述构建过程的脚本。它们定义了需要运行的命令及其顺序。'
- en: '**Dependencies**: External code libraries or tools required by a project that
    need to be integrated during the build process.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：在构建过程中需要集成到项目中的外部代码库或工具。'
- en: '**Artifacts**: The output of build systems, which can include executables,
    libraries, or other formats needed to deploy or run software.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工件**：构建系统的输出，可以包括可执行文件、库或其他格式的软件部署或运行所需的文件。'
- en: In the upcoming section, we will explore the fundamentals of the `make` build
    system and learn how to write Makefiles that automate the build process for firmware
    projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨 `make` 构建系统的基本原理，并学习如何编写 Makefile 以自动化固件项目的构建过程。
- en: The Make build system
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Make 构建系统
- en: In this section, we will explore the Make build system, from its basic concepts
    to practical usage in firmware development.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Make 构建系统，从其基本概念到在固件开发中的实际应用。
- en: The basics of Make
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Make 的基础知识
- en: 'The primary component of the `make` build system is the Makefile, which contains
    a set of directives used by the tool to generate a *target*. At its core, a Makefile
    consists of **rules**. Each rule begins with a *target*, followed by *prerequisites*,
    and then a *recipe*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 构建系统的核心组件是 Makefile，它包含一组由工具使用的指令，用于生成 *目标*。在核心上，Makefile 由 **规则** 组成。每个规则以
    *目标* 开头，然后是 *先决条件*，最后是 *配方*：'
- en: '`main.o` or `app.exe`. The target can also be the name of the action to carry
    out.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.o` 或 `app.exe`。目标也可以是执行的动作名称。'
- en: '`main.c` and `adc.c`).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.c` 和 `adc.c`）。'
- en: '`make` executes in order to build the target.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make` 执行以构建目标。'
- en: 'The following diagram illustrates a simple make rule:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了简单的 make 规则：
- en: '![Figure 5.1: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe](img/B21914_05_1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：一个 Make 规则，以 main.o 作为目标文件，由先决条件 main.c 生成，使用 arm-none-eabi-gcc main.c
    –o main.o 脚本](img/B21914_05_1.jpg)'
- en: 'Figure 5.1: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：一个 Make 规则，以 main.o 作为目标文件，由先决条件 main.c 生成，使用 arm-none-eabi-gcc main.c
    –o main.o 脚本。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The line of the recipe must start with a tab.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 配方的行必须以制表符开头。
- en: 'Makefiles also allow us to use variables to simplify and manage complex build
    commands and configurations. For instance, we can define a variable name, `CC`,
    to represent the `compiler` command, as shown in *Figure 5**.2*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 还允许我们使用变量来简化和管理复杂的构建命令和配置。例如，我们可以定义一个变量名 `CC` 来表示 `编译器` 命令，如图 *图 5.2*
    所示：
- en: '![Figure 5.2: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, where the compiler command in the recipe is replaced
    by a variable](img/B21914_05_2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：一个 Make 规则，以 main.o 作为目标文件，由先决条件 main.c 生成，其中配方中的编译器命令被变量替换](img/B21914_05_2.jpg)'
- en: 'Figure 5.2: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, where the compiler command in the recipe is replaced
    by a variable'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in Makefiles allow us to store text strings that can be reused throughout
    a file. The most basic way to define a variable is by simple assignment (`=`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line sets the `CC` variable to the `arm-none-eabi-gcc` cross-compiler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, variables can be used throughout the Makefile to simplify commands
    and definitions. To use a variable, enclose its name in `$(...)` or `${...}`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The recipe uses the `$(CC)` variable to refer to the compiler set earlier (`arm-none-eabi-gcc`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Apart from user-defined variables, there are special variables related to targets
    and prerequisites that come in handy when writing Makefiles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In `make`, special variables related to targets help streamline the process
    of specifying filenames and file paths, making the rules within a Makefile more
    general and reusable. One of the most commonly used special variables for targets
    is `'$@' - Target Name`. This variable represents the name of the target for the
    rule. It is particularly useful when the target name is repeated multiple times
    within a rule, which is common in link and compile commands.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `$@` is replaced by `main.o`, which is the target of the rule.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Make also provides special variables to reference prerequisites. One of the
    most commonly used is `$^`. This variable lists all the prerequisites of a target,
    with spaces between them (if more than one). Let’s see an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the preceding snippet of the Makefile is executed, `$^` is replaced with
    `main.c`, effectively running the `arm-none-eabi-gcc main.c –o` `main.o` command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Special variables in Makefiles are very useful in improving efficiency and flexibility
    when defining build rules. By effectively using these variables, we can create
    more robust and maintainable build systems.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this section with *Figure 5**.3*. This figure illustrates the
    revised rule from *Figure 5**.2*, now incorporating our user-defined variable
    along with the special variables related to targets and prerequisites.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: A Make rule using a user-defined variable and two special variables](img/B21914_05_3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: A Make rule using a user-defined variable and two special variables'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will guide you through the process of setting up a `make`
    build system on your development computer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Make
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will go through the process of downloading, installing,
    and configuring the `make` build system on a Windows environment. Let’s begin:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**Download make**: We begin by navigating to the appropriate website to download
    GNU Make for Windows. For this example, we’ll use SourceForge, a popular repository
    for open source projects. Go to [https://gnuwin32.sourceforge.net/packages/make.htm](https://gnuwin32.sourceforge.net/packages/make.htm).'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Complete package, except sources** option description, click **Setup**
    under the **Download** column to start downloading.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make` on your computer. When you reach the step titled `C:\Program` `Files
    (x86)\GnuWin32`.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make` from any command line or script, we need to add its executable to our
    system environment variables, following the same process we used in [*Chapter
    1*](B21914_01.xhtml#_idTextAnchor015) to add OpenOCD to the environment variables.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do this by navigating to the `bin` folder where `make` was installed (`C:\Program
    Files (x86)\GnuWin32\bin`) and then copying the path.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we do the following:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on `make` path into this new row.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm your changes by clicking **OK** on the various pop-up windows.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To confirm that the `make` is properly set up, open command prompt and simply
    type `make`, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should return the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This confirms that the `make` build system is properly configured on the Windows
    machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'On many Linux distributions, `make` is readily available through the distribution’s
    package manager. For instance, on Ubuntu and other Debian-based distributions,
    we can install make (along with other build essentials, such as the GCC compiler)
    by running the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On macOS, `make` is part of the Command Line Tools package that comes with
    Xcode, Apple’s suite of development tools. This means that if you have installed
    Xcode, you will have `make` already installed. We can also install the standalone
    Command Line Tools package by running the following command in the terminal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we successfully set up the `make` build system on our development
    machine. In the following section, we will apply the concepts covered in this
    chapter to write our own Makefile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Writing Makefiles for firmware projects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this section is to write a Makefile and successfully test it. Let’s
    begin.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In our workspace folder, let’s make a new folder named `4_Makefiles`. In this
    folder, create a file called `Makefile`. This file must start with a capital **M**
    and should have **no extension**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Windows and it asks whether you really want to change the file
    extension, click **Yes**. Then, right-click the file and open it with a basic
    text editor, such as Notepad++.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objectives with the Makefile can be summarized as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`main.c` and `stm32f411_startup.c`) into object files (`main.o` and `stm32f411_startup.o`).'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stm32_ls.ld`) to create a final executable (`4_makefile_project.elf`).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*.o`, `*.elf.`, and `*.map`), allowing for a fresh start with no leftover
    artifacts from previous builds'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is our complete Makefile:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s break it down:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`final :` `4_makefile_project.elf`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This line deals with the creation of the final target.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we execute `make final`, `make` will check whether the `4_makefile_project.elf`
    target needs to be updated before executing it. This is a dependency relationship
    where `final` acts purely as an aggregation point to invoke all the build processes
    leading up to `4_makefile_project.elf`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`main.o :` `main.c`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -``o main.o`'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `make` rule compiles the `main.c` source file into an object file named
    `main.o.` Upon close inspection, you can see that the command employed here is
    identical to the one we used at the command prompt to manually compile `main.c`
    in the previous chapter.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stm32f411_startup.o :` `stm32f411_startup.c`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c
    -``o stm32f411_startup.o`'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This compiles the `stm32f411_startup.c` source file into an object file, named
    `stm32f411_startup.o`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4_makefile_project.elf :` `main.o stm32f411_startup.o`'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o` `4_makefile_project.elf
    -Wl,-Map=4_makefile_project.map`'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This rule links the `main.o` and `stm32f411_startup.o` object files to produce
    the final executable, `4_makefile_project.elf`. Additionally, it generates a map
    file named `4_makefile_project.map` that shows where each part of the code and
    data is loaded in memory, which is useful for debugging.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`load:`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`openocd -``f board/st_nucleo_f4.cfg`'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This rule initiates OpenOCD to begin the process of loading the final executable
    onto the target hardware. It executes OpenOCD, using a configuration file tailored
    for the STM32 Nucleo F4 board, specifically `st_nucleo_f4.cfg`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`clean:`'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`del` `-f *.o *.``elf *.map`'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This command cleans the build directory by removing all generated files, ensuring
    a clean environment for subsequent builds. The `del -f` command forcefully deletes
    files, preventing prompts that ask for deletion confirmation. The `*.o`, `*.elf`,
    and `*.map` patterns specify that all object files, ELF executables, and map files,
    respectively, should be deleted.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the Makefile ready, it is time to test it out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Makefile
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding to the command line, let’s ensure that the linker script,
    startup file, and all source files are placed in the correct directory. Additionally,
    we will slightly update the `main.c` file, which will allow us to validate that
    the most recent version of the firmware executes correctly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`main.c` file from the previous project (`3_LinkerscriptAndStartup`), which
    includes the foundational application code.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, locate `stm32_ls.ld` (the linker script) and `stm32f411_startup.c`
    (the startup file).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste these files (`stm32_ls.ld`, `stm32f411_startup.c`, and `main.c`)
    into the `4_Makefiles` folder.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file from slow to fast:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.c` file within the `4_ Makefiles` folder and select the option to open
    it with a simple text editor, such as Notepad++.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LED_PIN`). Adjust the delay intervals within this section to change the LED’s
    blink rate from its current slower pace to a rapid one. The current one should
    look like this:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the current code with the following snippet to toggle the state of
    PA5 to a faster rate:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let’s access our new folder through the command prompt, following the steps
    we used in the previous chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In the command prompt, simply execute the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create our final executable, `4_makefile_project.elf`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will begin uploading the final executable onto our microcontroller
    by executing the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will launch OpenOCD. The next step involves using the **GNU Debugger**
    (**GDB**) to upload the firmware to the microcontroller, as we did in the previous
    chapter. Let’s access another command prompt window (as OpenOCD should keep running
    in the first one) and enter the following command to start the GDB:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once GDB is open, we establish a connection to our microcontroller by running
    the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s reset and initialize the board, as we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080),
    using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we load the firmware onto the microcontroller using the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After successfully loading the firmware, we reset the board again with the
    same reset command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we resume the execution of the firmware on the microcontroller with
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should see the LED blinking at a rapid rate, indicating the successful upload
    and execution of our new firmware.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'We can stop the GDB by executing the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And then, we execute the following when asked if we want to quit anyway:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To clean our build directory, we will open the command prompt in the build
    directory and execute the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will delete all the `.o`, `.elf`, and `.map` files in the build directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Before concluding this chapter, let’s explore how our Makefile appears when
    we incorporate special and user-defined variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Applying special and user-defined variables
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s apply special variables and user-defined variables to our makefile:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this version, we’ve defined three essential variables to streamline our
    Makefile:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`CC`: This variable represents the compiler used to compile the source files.
    It simplifies the Makefile by centralizing the compiler definition, making it
    easier to update or change if needed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFLAGS`: This holds the compilation flags necessary to build the source files.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDFLAGS`: This contains the linker flags that dictate how an executable is
    linked from the object files.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we’ve used special variables for target names (`$@`) and prerequisite
    lists (`$^`) to replace explicit mentions of these components in the `make` recipes,
    further simplifying the Makefile structure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Update your current makefile to this new version and upload the new executable,
    named `5_makefile_project_v2.elf`, onto your microcontroller. This updated version
    should function seamlessly, just like the previous one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on an exploration of the `make` build system, a
    cornerstone tool for automating the build process in software development. The
    journey began with an introduction to what build systems are and their critical
    role in converting source code into deployable software, such as executables and
    libraries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始探索`make`构建系统，这是软件开发中自动化构建过程的一个基石工具。这次旅程从介绍构建系统是什么以及它们在将源代码转换为可部署软件（如可执行文件和库）中的关键作用开始。
- en: We then delved into the specific mechanics of the `make` build system, starting
    with the foundational elements of a Makefile, which include *targets*, *prerequisites*,
    and *recipes*. These components were thoroughly discussed to provide a clear understanding
    of how they interact within `make` to manage and streamline the compilation and
    linking of software projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了`make`构建系统的具体机制，从Makefile的基础元素开始，包括*目标*、*依赖项*和*配方*。这些组件被彻底讨论，以提供对它们如何在`make`中交互以管理和简化软件项目的编译和链接的清晰理解。
- en: This chapter wrapped up with a practical demonstration of writing Makefiles,
    effectively consolidating the theoretical concepts discussed throughout. This
    hands-on experience ensures that you are well-equipped to apply these strategies
    to your own firmware projects.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以编写Makefile的实际演示结束，有效地巩固了之前讨论的理论概念。这种动手经验确保您能够将这些策略应用到自己的固件项目中。
- en: In the next chapter, we will transition to another critical aspect of firmware
    development – the development of peripheral drivers, beginning with **General
    Purpose Input/Output** (**GPI/O**) drivers. This shift will introduce you to the
    fundamentals of interfacing with hardware components, a pivotal skill in embedded
    systems development.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将过渡到固件开发的关键方面之一——外设驱动程序的开发，从**通用输入/输出**（**GPI/O**）驱动程序开始。这一转变将向您介绍与硬件组件交互的基础知识，这是嵌入式系统开发中的一个关键技能。
