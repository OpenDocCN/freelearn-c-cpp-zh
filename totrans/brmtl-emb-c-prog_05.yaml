- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: The “Make” Build System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “Make”构建系统
- en: In this chapter, we will learn how to automate our entire build process using
    build systems, specifically focusing on the **make** build system – an indispensable
    tool for automating the compilation and linking processes in software development.
    We start by defining what a build system is and then exploring its fundamental
    purpose, which primarily involves automatically transforming source code into
    deployable software, such as executables or libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用构建系统自动化我们的整个构建过程，特别是关注**make**构建系统——在软件开发中自动化编译和链接过程的不可或缺的工具。我们首先定义什么是构建系统，然后探讨其基本目的，这主要涉及自动将源代码转换为可部署的软件，如可执行文件或库。
- en: Throughout the chapter, we will systematically uncover the components of the
    `make` build system, starting with the essential elements of a **Makefile**, including
    *targets*, *prerequisites*, and *recipes*. In the latter part of the chapter,
    I will provide a step-by-step guide on writing a Makefile, highlighting the syntax
    and structure necessary to execute builds effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将系统地揭示`make`构建系统的组成部分，从**Makefile**的基本元素开始，包括*目标*、*依赖项*和*配方*。在章节的后半部分，我将提供编写Makefile的逐步指南，强调执行构建所需的有效语法和结构。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: An introduction to build systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建系统的简介
- en: The Make build system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make构建系统
- en: Writing Makefiles for firmware projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为固件项目编写Makefile
- en: By the end of this chapter, you will have a solid understanding of how to leverage
    the `make` build system to streamline your development process, improve build
    times, and reduce manual errors in building and deploying your firmware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将牢固地理解如何利用`make`构建系统来简化你的开发过程，提高构建时间，并减少在构建和部署固件时的手动错误。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: An introduction to build systems
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建系统的简介
- en: 'In the world of software development, build systems are pivotal tools that
    enable the transformation of source code into executable programs or other usable
    software formats. These systems automate the process of compiling and linking
    code, managing dependencies, and ensuring that software builds are reproducible
    and efficient. Simply put, a build system refers to a set of tools that automate
    the processes of compiling source code into binary code, linking binaries with
    libraries, and packaging the results into deployable software units. These systems
    are designed to handle complex dependency chains by tracking which parts of a
    software project need recompilation, thereby optimizing the build process. Build
    systems are responsible for a range of tasks. These include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的世界里，构建系统是关键的工具，它能够将源代码转换为可执行程序或其他可用的软件格式。这些系统自动化了编译和链接代码、管理依赖项以及确保软件构建可重复和高效的过程。简单来说，构建系统是指一组工具，它们自动化了将源代码编译成二进制代码、将二进制代码与库链接以及将结果打包成可部署软件单元的过程。这些系统旨在通过跟踪软件项目中哪些部分需要重新编译来处理复杂的依赖链，从而优化构建过程。构建系统负责一系列任务，包括以下内容：
- en: '**Dependency management**: This involves identifying and resolving interdependencies
    among various components or libraries that software requires.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：这涉及到识别和解决软件所需的各个组件或库之间的相互依赖关系。'
- en: '**Code compilation**: Converting source code, whether it’s written in C, C++,
    or another programming language, into machine-readable object code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编译**：将源代码（无论是用C、C++还是其他编程语言编写的）转换为机器可读的对象代码。'
- en: '**Linking**: This process integrates the compiled object files and necessary
    libraries into a unified executable or library file.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：这个过程将编译后的对象文件和必要的库集成到一个统一的可执行文件或库文件中。'
- en: '**Packaging**: This step prepares the software for deployment, which might
    include creating installer packages or compressing software into distributable
    archives.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**：这一步为软件的部署做准备，可能包括创建安装程序包或将软件压缩成可分发存档。'
- en: '**Testing and validation**: Executing automated tests to confirm that software
    adheres to the predefined quality benchmarks before its release.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和验证**：在软件发布前执行自动化测试，以确认软件符合预定义的质量基准。'
- en: '**Documentation generation**: Build systems can also automate the creation
    of documentation. This is achieved by integrating with tools such as Doxygen for
    C/C++, Javadoc for Java, or Sphinx for Python, which extract annotated comments
    and metadata from source code to produce structured documentation. This automation
    ensures that documentation stays synchronized with changes in the source code,
    thereby maintaining consistency and reducing manual errors.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档生成**：构建系统还可以自动化文档的创建。这是通过集成工具如 C/C++ 的 Doxygen、Java 的 Javadoc 或 Python
    的 Sphinx 来实现的，这些工具从源代码中提取注释和元数据以生成结构化文档。这种自动化确保了文档与源代码的变化保持同步，从而保持一致性并减少人工错误。'
- en: By incorporating these diverse functions, build systems significantly boost
    the efficiency and reliability of the software development process. Modern software
    projects often involve complex configurations, including thousands of source files
    and a wide array of external dependencies. Build systems provide a crucial framework
    to manage these complexities efficiently. They automate repetitive tasks, minimize
    the likelihood of human errors, and guarantee consistent builds across various
    environments. This streamlining not only enhances productivity but also supports
    the adoption of continuous integration and continuous delivery practices, which
    are essential for timely and effective software delivery.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过整合这些多样化的功能，构建系统显著提高了软件开发过程的效率和可靠性。现代软件项目通常涉及复杂的配置，包括数千个源文件和广泛的外部依赖。构建系统提供了一个关键框架来有效地管理这些复杂性。它们自动化重复性任务，最小化人为错误的可能性，并确保在不同环境中构建的一致性。这种简化不仅提高了生产力，还支持持续集成和持续交付实践的采用，这对于及时和有效地交付软件至关重要。
- en: Choosing a build system depends on various factors, including the programming
    language used in a project, the platform compatibility required, and the development
    team’s familiarity with the tool. Some of the commonly used build systems include
    `make` and `maven`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 选择构建系统取决于各种因素，包括项目使用的编程语言、所需的平台兼容性以及开发团队对工具的熟悉程度。一些常用的构建系统包括 `make` 和 `maven`。
- en: Make
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Make
- en: Make is one of the oldest and most fundamental build systems available. It is
    primarily used for C and C++ projects. Make uses Makefiles to specify how to compile
    and link source files. Its primary advantage lies in its simplicity and broad
    support across different platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Make 是最古老且最基础的构建系统之一。它主要用于 C 和 C++ 项目。Make 使用 Makefiles 来指定如何编译和链接源文件。它的主要优势在于其简单性和在不同平台上的广泛支持。
- en: 'Its key features include the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其关键特性包括以下内容：
- en: '**Flexibility**: Make allows us to define explicit rules on how files should
    be compiled and linked.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：Make 允许我们定义如何编译和链接文件的明确规则。'
- en: '`make` can be used with a variety of compilers and programming languages. On
    Windows, `make` can be used in environments such as **Minimalist GNU for Windows**
    (**MinGW**) or Cygwin.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make` 可以与各种编译器和编程语言一起使用。在 Windows 上，`make` 可以在 **Minimalist GNU for Windows**（MinGW）或
    Cygwin 等环境中使用。'
- en: Next, let’s look at maven.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Maven。
- en: Maven
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maven
- en: '`Maven` is primarily used for Java projects. It is designed to provide a comprehensive
    and standard framework for building projects, handling documentation, reporting,
    dependencies, **Source Control Management** (**SCM**) systems, releases, and distribution.
    The key features include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maven` 主要用于 Java 项目。它旨在提供一个全面和标准的框架来构建项目、处理文档、报告、依赖项、**源代码管理（SCM**）系统、发布和分发。其关键特性包括以下内容：'
- en: '**Convention over configuration**: Maven uses a standard directory layout and
    a default build life cycle to decrease the time spent on configuring projects'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约定优于配置**：Maven 使用标准的目录布局和默认的构建生命周期，以减少在项目配置上花费的时间'
- en: '**Dependency management**: It can automatically download libraries and plugins
    from repositories and incorporate them into the build process'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：它可以自动从仓库下载库和插件，并将它们纳入构建过程'
- en: '**Project information management**: Maven can generate project documentation,
    reports, and other information from a project’s metadata'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目管理信息**：Maven 可以从项目的元数据生成项目文档、报告和其他信息'
- en: '**Build and release management**: Maven supports the entire build life cycle,
    from compilation, packaging, and testing to deployment and release management'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和发布管理**：Maven 支持整个构建生命周期，从编译、打包和测试到部署和发布管理。'
- en: '**Extensibility**: Maven’s plugin-based architecture allows it to be extended
    with custom plugins to support additional tasks'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Maven 的基于插件的架构允许它通过自定义插件进行扩展，以支持额外的任务。'
- en: Other notable build systems include `Apache Ant`, which is a Java-based build
    system, and `Gradle`, which supports multiple programming languages but is especially
    favored within the Java ecosystem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的构建系统包括基于 Java 的 `Apache Ant` 和支持多种编程语言的 `Gradle`，但 `Gradle` 在 Java 生态系统中特别受欢迎。
- en: 'Before exploring the specifics of the `make` build system, it is important
    to familiarize ourselves with the fundamental components of build systems. These
    components form the backbone of the build process and include the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 `make` 构建系统的具体细节之前，熟悉构建系统的基本组件非常重要。这些组件构成了构建过程的基础，包括以下内容：
- en: '**Source code**: The raw, human-readable code written in programming languages
    such as C, Java, and Python.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码**：用 C、Java、Python 等编程语言编写的原始、可读代码。'
- en: '`javac` for Java.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac` 用于 Java。'
- en: '**Linker**: The tool that combines object files into a single executable or
    library file.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接器**：将目标文件组合成单个可执行文件或库文件的工具。'
- en: '**Build scripts**: Scripts that describe the build process. They define what
    commands need to be run and their order.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建脚本**：描述构建过程的脚本。它们定义了需要运行的命令及其顺序。'
- en: '**Dependencies**: External code libraries or tools required by a project that
    need to be integrated during the build process.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：在构建过程中需要集成到项目中的外部代码库或工具。'
- en: '**Artifacts**: The output of build systems, which can include executables,
    libraries, or other formats needed to deploy or run software.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工件**：构建系统的输出，可以包括可执行文件、库或其他格式的软件部署或运行所需的文件。'
- en: In the upcoming section, we will explore the fundamentals of the `make` build
    system and learn how to write Makefiles that automate the build process for firmware
    projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨 `make` 构建系统的基本原理，并学习如何编写 Makefile 以自动化固件项目的构建过程。
- en: The Make build system
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Make 构建系统
- en: In this section, we will explore the Make build system, from its basic concepts
    to practical usage in firmware development.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Make 构建系统，从其基本概念到在固件开发中的实际应用。
- en: The basics of Make
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Make 的基础知识
- en: 'The primary component of the `make` build system is the Makefile, which contains
    a set of directives used by the tool to generate a *target*. At its core, a Makefile
    consists of **rules**. Each rule begins with a *target*, followed by *prerequisites*,
    and then a *recipe*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 构建系统的核心组件是 Makefile，它包含一组由工具使用的指令，用于生成 *目标*。在核心上，Makefile 由 **规则** 组成。每个规则以
    *目标* 开头，然后是 *先决条件*，最后是 *配方*：'
- en: '`main.o` or `app.exe`. The target can also be the name of the action to carry
    out.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.o` 或 `app.exe`。目标也可以是执行的动作名称。'
- en: '`main.c` and `adc.c`).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.c` 和 `adc.c`）。'
- en: '`make` executes in order to build the target.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make` 执行以构建目标。'
- en: 'The following diagram illustrates a simple make rule:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了简单的 make 规则：
- en: '![Figure 5.1: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe](img/B21914_05_1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：一个 Make 规则，以 main.o 作为目标文件，由先决条件 main.c 生成，使用 arm-none-eabi-gcc main.c
    –o main.o 脚本](img/B21914_05_1.jpg)'
- en: 'Figure 5.1: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：一个 Make 规则，以 main.o 作为目标文件，由先决条件 main.c 生成，使用 arm-none-eabi-gcc main.c
    –o main.o 脚本。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The line of the recipe must start with a tab.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 配方的行必须以制表符开头。
- en: 'Makefiles also allow us to use variables to simplify and manage complex build
    commands and configurations. For instance, we can define a variable name, `CC`,
    to represent the `compiler` command, as shown in *Figure 5**.2*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 还允许我们使用变量来简化和管理复杂的构建命令和配置。例如，我们可以定义一个变量名 `CC` 来表示 `编译器` 命令，如图 *图 5.2*
    所示：
- en: '![Figure 5.2: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, where the compiler command in the recipe is replaced
    by a variable](img/B21914_05_2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：一个 Make 规则，以 main.o 作为目标文件，由先决条件 main.c 生成，其中配方中的编译器命令被变量替换](img/B21914_05_2.jpg)'
- en: 'Figure 5.2: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, where the compiler command in the recipe is replaced
    by a variable'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：一个 Make 规则，其中 main.o 是目标文件，由先决条件 main.c 生成，其中配方中的编译器命令被一个变量替换
- en: 'Variables in Makefiles allow us to store text strings that can be reused throughout
    a file. The most basic way to define a variable is by simple assignment (`=`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 中的变量允许我们存储可以在整个文件中重用的文本字符串。定义变量的最基本方法是简单的赋值（`=`）：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line sets the `CC` variable to the `arm-none-eabi-gcc` cross-compiler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这行设置 `CC` 变量为 `arm-none-eabi-gcc` 交叉编译器。
- en: 'Once defined, variables can be used throughout the Makefile to simplify commands
    and definitions. To use a variable, enclose its name in `$(...)` or `${...}`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，变量就可以在整个 Makefile 中使用，以简化命令和定义。要使用变量，请将其名称用 `$(...)` 或 `${...}` 括起来：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The recipe uses the `$(CC)` variable to refer to the compiler set earlier (`arm-none-eabi-gcc`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 配方使用 `$(CC)` 变量来引用之前设置的编译器（`arm-none-eabi-gcc`）。
- en: Apart from user-defined variables, there are special variables related to targets
    and prerequisites that come in handy when writing Makefiles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户定义的变量外，还有与目标和先决条件相关的特殊变量，在编写 Makefile 时非常有用。
- en: In `make`, special variables related to targets help streamline the process
    of specifying filenames and file paths, making the rules within a Makefile more
    general and reusable. One of the most commonly used special variables for targets
    is `'$@' - Target Name`. This variable represents the name of the target for the
    rule. It is particularly useful when the target name is repeated multiple times
    within a rule, which is common in link and compile commands.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `make` 中，与目标相关的特殊变量有助于简化指定文件名和文件路径的过程，使 Makefile 中的规则更加通用和可重用。最常用的目标相关特殊变量之一是
    `'$@' - 目标名称`。这个变量代表规则的目标名称。当目标名称在规则中多次重复时，它特别有用，这在链接和编译命令中很常见。
- en: 'Let’s see an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `$@` is replaced by `main.o`, which is the target of the rule.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`$@` 被替换为 `main.o`，这是规则的目標。
- en: 'Make also provides special variables to reference prerequisites. One of the
    most commonly used is `$^`. This variable lists all the prerequisites of a target,
    with spaces between them (if more than one). Let’s see an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Make 还提供了特殊变量来引用先决条件。最常用的一个变量是 `$^`。这个变量列出了目标的所有先决条件，它们之间用空格分隔（如果有多个）。让我们看一个例子：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the preceding snippet of the Makefile is executed, `$^` is replaced with
    `main.c`, effectively running the `arm-none-eabi-gcc main.c –o` `main.o` command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的 Makefile 片段时，`$^` 被替换为 `main.c`，实际上运行了 `arm-none-eabi-gcc main.c –o main.o`
    命令。
- en: Special variables in Makefiles are very useful in improving efficiency and flexibility
    when defining build rules. By effectively using these variables, we can create
    more robust and maintainable build systems.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 中的特殊变量在定义构建规则时提高效率和灵活性非常有用。通过有效地使用这些变量，我们可以创建更健壮和可维护的构建系统。
- en: We will conclude this section with *Figure 5**.3*. This figure illustrates the
    revised rule from *Figure 5**.2*, now incorporating our user-defined variable
    along with the special variables related to targets and prerequisites.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 *图 5**.3* 来结束本节。这个图展示了 *图 5**.2* 中的修订规则，现在包括了我们的用户定义变量以及与目标和先决条件相关的特殊变量。
- en: '![Figure 5.3: A Make rule using a user-defined variable and two special variables](img/B21914_05_3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：使用用户定义变量和两个特殊变量的 Make 规则](img/B21914_05_3.jpg)'
- en: 'Figure 5.3: A Make rule using a user-defined variable and two special variables'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：使用用户定义变量和两个特殊变量的 Make 规则
- en: In the next section, I will guide you through the process of setting up a `make`
    build system on your development computer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将指导您在您的开发计算机上设置 `make` 构建系统。
- en: Installing and configuring Make
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Make
- en: 'In this section, we will go through the process of downloading, installing,
    and configuring the `make` build system on a Windows environment. Let’s begin:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在 Windows 环境中下载、安装和配置 `make` 构建系统的过程。让我们开始：
- en: '**Download make**: We begin by navigating to the appropriate website to download
    GNU Make for Windows. For this example, we’ll use SourceForge, a popular repository
    for open source projects. Go to [https://gnuwin32.sourceforge.net/packages/make.htm](https://gnuwin32.sourceforge.net/packages/make.htm).'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载 make**：我们首先导航到适当的网站下载适用于 Windows 的 GNU Make。在这个例子中，我们将使用 SourceForge，这是一个流行的开源项目存储库。请访问
    [https://gnuwin32.sourceforge.net/packages/make.htm](https://gnuwin32.sourceforge.net/packages/make.htm)。'
- en: Under the **Complete package, except sources** option description, click **Setup**
    under the **Download** column to start downloading.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**完整包，除源代码**选项描述下，点击**下载**列下的**设置**以开始下载。
- en: '`make` on your computer. When you reach the step titled `C:\Program` `Files
    (x86)\GnuWin32`.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算机上的`make`。当你达到标题为`C:\Program` `Files (x86)\GnuWin32`的步骤时。
- en: '`make` from any command line or script, we need to add its executable to our
    system environment variables, following the same process we used in [*Chapter
    1*](B21914_01.xhtml#_idTextAnchor015) to add OpenOCD to the environment variables.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何命令行或脚本中运行`make`，我们需要将其可执行文件添加到我们的系统环境变量中，遵循我们在[*第1章*](B21914_01.xhtml#_idTextAnchor015)中添加OpenOCD到环境变量的相同过程。
- en: We do this by navigating to the `bin` folder where `make` was installed (`C:\Program
    Files (x86)\GnuWin32\bin`) and then copying the path.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过导航到`make`安装的`bin`文件夹（`C:\Program Files (x86)\GnuWin32\bin`）并复制路径来完成这项操作。
- en: 'Then, we do the following:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们执行以下操作：
- en: Right-click on `make` path into this new row.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`make`路径到这个新行。
- en: Confirm your changes by clicking **OK** on the various pop-up windows.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在各个弹出窗口中点击**确定**来确认您的更改。
- en: 'To confirm that the `make` is properly set up, open command prompt and simply
    type `make`, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认`make`已正确设置，打开命令提示符并简单地输入`make`，如图所示：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should return the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下内容：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This confirms that the `make` build system is properly configured on the Windows
    machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了Windows机器上的`make`构建系统已正确配置。
- en: 'On many Linux distributions, `make` is readily available through the distribution’s
    package manager. For instance, on Ubuntu and other Debian-based distributions,
    we can install make (along with other build essentials, such as the GCC compiler)
    by running the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多Linux发行版中，`make`可以通过发行版的包管理器轻松获得。例如，在Ubuntu和其他基于Debian的发行版中，我们可以通过运行以下命令来安装`make`（以及其他构建基本工具，如GCC编译器）：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On macOS, `make` is part of the Command Line Tools package that comes with
    Xcode, Apple’s suite of development tools. This means that if you have installed
    Xcode, you will have `make` already installed. We can also install the standalone
    Command Line Tools package by running the following command in the terminal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，`make`是Xcode的一部分，这是苹果的开发工具套件。这意味着如果你已经安装了Xcode，那么你已经有`make`了。我们还可以通过在终端运行以下命令来安装独立的命令行工具包：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we successfully set up the `make` build system on our development
    machine. In the following section, we will apply the concepts covered in this
    chapter to write our own Makefile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在我们的开发机器上成功设置了`make`构建系统。在下一节中，我们将应用本章中介绍的概念来编写我们自己的Makefile。
- en: Writing Makefiles for firmware projects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为固件项目编写Makefile
- en: The focus of this section is to write a Makefile and successfully test it. Let’s
    begin.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的重点是编写一个Makefile并成功测试它。让我们开始吧。
- en: In our workspace folder, let’s make a new folder named `4_Makefiles`. In this
    folder, create a file called `Makefile`. This file must start with a capital **M**
    and should have **no extension**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作区文件夹中，让我们创建一个名为`4_Makefiles`的新文件夹。在这个文件夹中，创建一个名为`Makefile`的文件。这个文件必须以大写**M**开头，并且应该没有**扩展名**。
- en: If you’re using Windows and it asks whether you really want to change the file
    extension, click **Yes**. Then, right-click the file and open it with a basic
    text editor, such as Notepad++.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，并且它询问你是否真的想要更改文件扩展名，请点击**是**。然后，右键单击文件，使用基本文本编辑器（如Notepad++）打开它。
- en: 'Our objectives with the Makefile can be summarized as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Makefile的目标可以总结如下：
- en: '`main.c` and `stm32f411_startup.c`) into object files (`main.o` and `stm32f411_startup.o`).'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （`main.c`和`stm32f411_startup.c`）到目标文件（`main.o`和`stm32f411_startup.o`）。
- en: '`stm32_ls.ld`) to create a final executable (`4_makefile_project.elf`).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （`stm32_ls.ld`）来创建最终的可执行文件（`4_makefile_project.elf`）。
- en: '`*.o`, `*.elf.`, and `*.map`), allowing for a fresh start with no leftover
    artifacts from previous builds'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （`*.o`，`*.elf.`，和`*.map`），允许在没有遗留之前构建的任何残留物的情况下从头开始。
- en: 'This is our complete Makefile:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完整的Makefile：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s break it down:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解：
- en: '`final :` `4_makefile_project.elf`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`final :` `4_makefile_project.elf`'
- en: This line deals with the creation of the final target.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行处理的是最终目标的创建。
- en: When we execute `make final`, `make` will check whether the `4_makefile_project.elf`
    target needs to be updated before executing it. This is a dependency relationship
    where `final` acts purely as an aggregation point to invoke all the build processes
    leading up to `4_makefile_project.elf`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们执行`make final`时，`make`将检查`4_makefile_project.elf`目标是否需要更新，然后再执行它。这是一个依赖关系，其中`final`纯粹作为一个聚合点来调用所有导致`4_makefile_project.elf`的构建过程。
- en: '`main.o :` `main.c`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.o :` `main.c`'
- en: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -``o main.o`'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -``o` `main.o`'
- en: The `make` rule compiles the `main.c` source file into an object file named
    `main.o.` Upon close inspection, you can see that the command employed here is
    identical to the one we used at the command prompt to manually compile `main.c`
    in the previous chapter.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`make`规则将`main.c`源文件编译成名为`main.o`的对象文件。仔细检查后，你可以看到这里使用的命令与我们之前在命令提示符下手动编译`main.c`时使用的命令相同。'
- en: '`stm32f411_startup.o :` `stm32f411_startup.c`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stm32f411_startup.o :` `stm32f411_startup.c`'
- en: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c
    -``o stm32f411_startup.o`'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c
    -``o` `stm32f411_startup.o`'
- en: This compiles the `stm32f411_startup.c` source file into an object file, named
    `stm32f411_startup.o`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将`stm32f411_startup.c`源文件编译成名为`stm32f411_startup.o`的对象文件。
- en: '`4_makefile_project.elf :` `main.o stm32f411_startup.o`'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4_makefile_project.elf :` `main.o` `stm32f411_startup.o`'
- en: '`arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o` `4_makefile_project.elf
    -Wl,-Map=4_makefile_project.map`'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o` `4_makefile_project.elf
    -Wl,-Map=4_makefile_project.map`'
- en: This rule links the `main.o` and `stm32f411_startup.o` object files to produce
    the final executable, `4_makefile_project.elf`. Additionally, it generates a map
    file named `4_makefile_project.map` that shows where each part of the code and
    data is loaded in memory, which is useful for debugging.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此规则将`main.o`和`stm32f411_startup.o`目标文件链接起来生成最终的可执行文件`4_makefile_project.elf`。此外，它还生成一个名为`4_makefile_project.map`的映射文件，该文件显示了代码和数据中的每个部分在内存中的加载位置，这对于调试非常有用。
- en: '`load:`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`load:`'
- en: '`openocd -``f board/st_nucleo_f4.cfg`'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`openocd -``f` `board/st_nucleo_f4.cfg`'
- en: This rule initiates OpenOCD to begin the process of loading the final executable
    onto the target hardware. It executes OpenOCD, using a configuration file tailored
    for the STM32 Nucleo F4 board, specifically `st_nucleo_f4.cfg`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此规则启动OpenOCD，开始将最终可执行文件加载到目标硬件上的过程。它执行OpenOCD，使用针对STM32 Nucleo F4板定制的配置文件，具体为`st_nucleo_f4.cfg`。
- en: '`clean:`'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clean:`'
- en: '`del` `-f *.o *.``elf *.map`'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`del` `-f *.o *.elf *.map`'
- en: This command cleans the build directory by removing all generated files, ensuring
    a clean environment for subsequent builds. The `del -f` command forcefully deletes
    files, preventing prompts that ask for deletion confirmation. The `*.o`, `*.elf`,
    and `*.map` patterns specify that all object files, ELF executables, and map files,
    respectively, should be deleted.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令通过删除所有生成的文件来清理构建目录，确保为后续构建提供一个干净的环境。`del -f`命令强制删除文件，防止出现要求删除确认的提示。`*.o`、`*.elf`和`*.map`模式分别指定应删除所有对象文件、ELF可执行文件和映射文件。
- en: With the Makefile ready, it is time to test it out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当Makefile准备就绪时，是时候对其进行测试了。
- en: Testing our Makefile
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的Makefile
- en: 'Before proceeding to the command line, let’s ensure that the linker script,
    startup file, and all source files are placed in the correct directory. Additionally,
    we will slightly update the `main.c` file, which will allow us to validate that
    the most recent version of the firmware executes correctly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入命令行之前，让我们确保链接脚本、启动文件以及所有源文件都已放置在正确的目录中。此外，我们将稍微更新`main.c`文件，这将使我们能够验证固件最新版本的执行是否正确：
- en: '`main.c` file from the previous project (`3_LinkerscriptAndStartup`), which
    includes the foundational application code.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自上一个项目（`3_LinkerscriptAndStartup`）的`main.c`文件，其中包含基础应用程序代码。
- en: Additionally, locate `stm32_ls.ld` (the linker script) and `stm32f411_startup.c`
    (the startup file).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，找到`stm32_ls.ld`（链接脚本）和`stm32f411_startup.c`（启动文件）。
- en: Copy and paste these files (`stm32_ls.ld`, `stm32f411_startup.c`, and `main.c`)
    into the `4_Makefiles` folder.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些文件（`stm32_ls.ld`、`stm32f411_startup.c`和`main.c`）复制粘贴到`4_Makefiles`文件夹中。
- en: '`main.c` file from slow to fast:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.c`文件从慢到快：'
- en: '`main.c` file within the `4_ Makefiles` folder and select the option to open
    it with a simple text editor, such as Notepad++.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`4_ Makefiles`文件夹中找到`main.c`文件，并选择使用简单的文本编辑器，如Notepad++打开它的选项。
- en: '`LED_PIN`). Adjust the delay intervals within this section to change the LED’s
    blink rate from its current slower pace to a rapid one. The current one should
    look like this:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LED_PIN`）。调整此部分中的延迟间隔以改变LED的闪烁速率，从当前的较慢速度变为快速。当前的应该看起来像这样：'
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the current code with the following snippet to toggle the state of
    PA5 to a faster rate:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将当前代码替换为以下片段以将PA5的状态切换到更快的速率：
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let’s access our new folder through the command prompt, following the steps
    we used in the previous chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过命令提示符访问我们的新文件夹，按照我们在上一章中使用的步骤进行。
- en: 'In the command prompt, simply execute the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中，只需执行以下命令：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create our final executable, `4_makefile_project.elf`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的最终可执行文件，`4_makefile_project.elf`。
- en: 'Next, we will begin uploading the final executable onto our microcontroller
    by executing the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过执行以下命令开始将最终的可执行文件上传到我们的微控制器：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will launch OpenOCD. The next step involves using the **GNU Debugger**
    (**GDB**) to upload the firmware to the microcontroller, as we did in the previous
    chapter. Let’s access another command prompt window (as OpenOCD should keep running
    in the first one) and enter the following command to start the GDB:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动OpenOCD。下一步涉及使用**GNU调试器**（**GDB**）将固件上传到微控制器，就像我们在上一章中做的那样。让我们打开另一个命令提示符窗口（因为OpenOCD应该在第一个窗口中继续运行）并输入以下命令以启动GDB：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once GDB is open, we establish a connection to our microcontroller by running
    the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦GDB打开，我们通过运行以下命令与我们的微控制器建立连接：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s reset and initialize the board, as we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080),
    using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重置并初始化板子，就像我们在[*第3章*](B21914_03.xhtml#_idTextAnchor080)中学到的那样，使用以下命令：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we load the firmware onto the microcontroller using the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令将固件加载到微控制器上：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After successfully loading the firmware, we reset the board again with the
    same reset command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功加载固件后，我们再次使用相同的重置命令重置板子：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we resume the execution of the firmware on the microcontroller with
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令恢复微控制器上固件的执行：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should see the LED blinking at a rapid rate, indicating the successful upload
    and execution of our new firmware.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到LED以快速闪烁，这表明我们的新固件上传和执行成功。
- en: 'We can stop the GDB by executing the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令停止GDB：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And then, we execute the following when asked if we want to quit anyway:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们被问及是否真的要退出时，我们执行以下命令：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To clean our build directory, we will open the command prompt in the build
    directory and execute the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理我们的构建目录，我们将打开构建目录中的命令提示符并执行以下命令：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will delete all the `.o`, `.elf`, and `.map` files in the build directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除构建目录中的所有`.o`、`.elf`和`.map`文件。
- en: Before concluding this chapter, let’s explore how our Makefile appears when
    we incorporate special and user-defined variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们探索一下当我们引入特殊和用户定义变量时，我们的Makefile看起来是什么样的。
- en: Applying special and user-defined variables
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用特殊和用户定义变量
- en: 'Let’s apply special variables and user-defined variables to our makefile:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将特殊变量和用户定义变量应用到我们的makefile中：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this version, we’ve defined three essential variables to streamline our
    Makefile:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们已定义了三个基本变量以简化我们的Makefile：
- en: '`CC`: This variable represents the compiler used to compile the source files.
    It simplifies the Makefile by centralizing the compiler definition, making it
    easier to update or change if needed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC`：这个变量代表用于编译源文件的编译器。它通过集中定义编译器来简化Makefile，使得在需要时更新或更改变得更加容易。'
- en: '`CFLAGS`: This holds the compilation flags necessary to build the source files.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFLAGS`：这个变量包含构建源文件所需的编译标志。'
- en: '`LDFLAGS`: This contains the linker flags that dictate how an executable is
    linked from the object files.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDFLAGS`：这个变量包含控制如何从目标文件链接可执行文件的链接器标志。'
- en: Additionally, we’ve used special variables for target names (`$@`) and prerequisite
    lists (`$^`) to replace explicit mentions of these components in the `make` recipes,
    further simplifying the Makefile structure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已使用特殊变量（`$@`）和依赖项列表（`$^`）来替换`make`食谱中这些组件的明确提及，从而进一步简化了Makefile结构。
- en: Update your current makefile to this new version and upload the new executable,
    named `5_makefile_project_v2.elf`, onto your microcontroller. This updated version
    should function seamlessly, just like the previous one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的当前makefile更新到这个新版本，并将名为`5_makefile_project_v2.elf`的新可执行文件上传到你的微控制器。这个更新版本应该像上一个版本一样无缝运行。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on an exploration of the `make` build system, a
    cornerstone tool for automating the build process in software development. The
    journey began with an introduction to what build systems are and their critical
    role in converting source code into deployable software, such as executables and
    libraries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始探索`make`构建系统，这是软件开发中自动化构建过程的一个基石工具。这次旅程从介绍构建系统是什么以及它们在将源代码转换为可部署软件（如可执行文件和库）中的关键作用开始。
- en: We then delved into the specific mechanics of the `make` build system, starting
    with the foundational elements of a Makefile, which include *targets*, *prerequisites*,
    and *recipes*. These components were thoroughly discussed to provide a clear understanding
    of how they interact within `make` to manage and streamline the compilation and
    linking of software projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了`make`构建系统的具体机制，从Makefile的基础元素开始，包括*目标*、*依赖项*和*配方*。这些组件被彻底讨论，以提供对它们如何在`make`中交互以管理和简化软件项目的编译和链接的清晰理解。
- en: This chapter wrapped up with a practical demonstration of writing Makefiles,
    effectively consolidating the theoretical concepts discussed throughout. This
    hands-on experience ensures that you are well-equipped to apply these strategies
    to your own firmware projects.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以编写Makefile的实际演示结束，有效地巩固了之前讨论的理论概念。这种动手经验确保您能够将这些策略应用到自己的固件项目中。
- en: In the next chapter, we will transition to another critical aspect of firmware
    development – the development of peripheral drivers, beginning with **General
    Purpose Input/Output** (**GPI/O**) drivers. This shift will introduce you to the
    fundamentals of interfacing with hardware components, a pivotal skill in embedded
    systems development.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将过渡到固件开发的关键方面之一——外设驱动程序的开发，从**通用输入/输出**（**GPI/O**）驱动程序开始。这一转变将向您介绍与硬件组件交互的基础知识，这是嵌入式系统开发中的一个关键技能。
