- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The “Make” Build System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to automate our entire build process using
    build systems, specifically focusing on the **make** build system – an indispensable
    tool for automating the compilation and linking processes in software development.
    We start by defining what a build system is and then exploring its fundamental
    purpose, which primarily involves automatically transforming source code into
    deployable software, such as executables or libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we will systematically uncover the components of the
    `make` build system, starting with the essential elements of a **Makefile**, including
    *targets*, *prerequisites*, and *recipes*. In the latter part of the chapter,
    I will provide a step-by-step guide on writing a Makefile, highlighting the syntax
    and structure necessary to execute builds effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to build systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Make build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Makefiles for firmware projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how to leverage
    the `make` build system to streamline your development process, improve build
    times, and reduce manual errors in building and deploying your firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to build systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the world of software development, build systems are pivotal tools that
    enable the transformation of source code into executable programs or other usable
    software formats. These systems automate the process of compiling and linking
    code, managing dependencies, and ensuring that software builds are reproducible
    and efficient. Simply put, a build system refers to a set of tools that automate
    the processes of compiling source code into binary code, linking binaries with
    libraries, and packaging the results into deployable software units. These systems
    are designed to handle complex dependency chains by tracking which parts of a
    software project need recompilation, thereby optimizing the build process. Build
    systems are responsible for a range of tasks. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency management**: This involves identifying and resolving interdependencies
    among various components or libraries that software requires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code compilation**: Converting source code, whether it’s written in C, C++,
    or another programming language, into machine-readable object code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linking**: This process integrates the compiled object files and necessary
    libraries into a unified executable or library file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packaging**: This step prepares the software for deployment, which might
    include creating installer packages or compressing software into distributable
    archives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing and validation**: Executing automated tests to confirm that software
    adheres to the predefined quality benchmarks before its release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation generation**: Build systems can also automate the creation
    of documentation. This is achieved by integrating with tools such as Doxygen for
    C/C++, Javadoc for Java, or Sphinx for Python, which extract annotated comments
    and metadata from source code to produce structured documentation. This automation
    ensures that documentation stays synchronized with changes in the source code,
    thereby maintaining consistency and reducing manual errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By incorporating these diverse functions, build systems significantly boost
    the efficiency and reliability of the software development process. Modern software
    projects often involve complex configurations, including thousands of source files
    and a wide array of external dependencies. Build systems provide a crucial framework
    to manage these complexities efficiently. They automate repetitive tasks, minimize
    the likelihood of human errors, and guarantee consistent builds across various
    environments. This streamlining not only enhances productivity but also supports
    the adoption of continuous integration and continuous delivery practices, which
    are essential for timely and effective software delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a build system depends on various factors, including the programming
    language used in a project, the platform compatibility required, and the development
    team’s familiarity with the tool. Some of the commonly used build systems include
    `make` and `maven`.
  prefs: []
  type: TYPE_NORMAL
- en: Make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make is one of the oldest and most fundamental build systems available. It is
    primarily used for C and C++ projects. Make uses Makefiles to specify how to compile
    and link source files. Its primary advantage lies in its simplicity and broad
    support across different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: Make allows us to define explicit rules on how files should
    be compiled and linked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make` can be used with a variety of compilers and programming languages. On
    Windows, `make` can be used in environments such as **Minimalist GNU for Windows**
    (**MinGW**) or Cygwin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look at maven.
  prefs: []
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Maven` is primarily used for Java projects. It is designed to provide a comprehensive
    and standard framework for building projects, handling documentation, reporting,
    dependencies, **Source Control Management** (**SCM**) systems, releases, and distribution.
    The key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Convention over configuration**: Maven uses a standard directory layout and
    a default build life cycle to decrease the time spent on configuring projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency management**: It can automatically download libraries and plugins
    from repositories and incorporate them into the build process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project information management**: Maven can generate project documentation,
    reports, and other information from a project’s metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build and release management**: Maven supports the entire build life cycle,
    from compilation, packaging, and testing to deployment and release management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: Maven’s plugin-based architecture allows it to be extended
    with custom plugins to support additional tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other notable build systems include `Apache Ant`, which is a Java-based build
    system, and `Gradle`, which supports multiple programming languages but is especially
    favored within the Java ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before exploring the specifics of the `make` build system, it is important
    to familiarize ourselves with the fundamental components of build systems. These
    components form the backbone of the build process and include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code**: The raw, human-readable code written in programming languages
    such as C, Java, and Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javac` for Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linker**: The tool that combines object files into a single executable or
    library file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build scripts**: Scripts that describe the build process. They define what
    commands need to be run and their order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: External code libraries or tools required by a project that
    need to be integrated during the build process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifacts**: The output of build systems, which can include executables,
    libraries, or other formats needed to deploy or run software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming section, we will explore the fundamentals of the `make` build
    system and learn how to write Makefiles that automate the build process for firmware
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: The Make build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the Make build system, from its basic concepts
    to practical usage in firmware development.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary component of the `make` build system is the Makefile, which contains
    a set of directives used by the tool to generate a *target*. At its core, a Makefile
    consists of **rules**. Each rule begins with a *target*, followed by *prerequisites*,
    and then a *recipe*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.o` or `app.exe`. The target can also be the name of the action to carry
    out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.c` and `adc.c`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make` executes in order to build the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a simple make rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe](img/B21914_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The line of the recipe must start with a tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Makefiles also allow us to use variables to simplify and manage complex build
    commands and configurations. For instance, we can define a variable name, `CC`,
    to represent the `compiler` command, as shown in *Figure 5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, where the compiler command in the recipe is replaced
    by a variable](img/B21914_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A Make rule, with main.o as the target file to be generated from
    the prerequisite, main.c, where the compiler command in the recipe is replaced
    by a variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in Makefiles allow us to store text strings that can be reused throughout
    a file. The most basic way to define a variable is by simple assignment (`=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line sets the `CC` variable to the `arm-none-eabi-gcc` cross-compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, variables can be used throughout the Makefile to simplify commands
    and definitions. To use a variable, enclose its name in `$(...)` or `${...}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The recipe uses the `$(CC)` variable to refer to the compiler set earlier (`arm-none-eabi-gcc`).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from user-defined variables, there are special variables related to targets
    and prerequisites that come in handy when writing Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: In `make`, special variables related to targets help streamline the process
    of specifying filenames and file paths, making the rules within a Makefile more
    general and reusable. One of the most commonly used special variables for targets
    is `'$@' - Target Name`. This variable represents the name of the target for the
    rule. It is particularly useful when the target name is repeated multiple times
    within a rule, which is common in link and compile commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `$@` is replaced by `main.o`, which is the target of the rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make also provides special variables to reference prerequisites. One of the
    most commonly used is `$^`. This variable lists all the prerequisites of a target,
    with spaces between them (if more than one). Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the preceding snippet of the Makefile is executed, `$^` is replaced with
    `main.c`, effectively running the `arm-none-eabi-gcc main.c –o` `main.o` command.
  prefs: []
  type: TYPE_NORMAL
- en: Special variables in Makefiles are very useful in improving efficiency and flexibility
    when defining build rules. By effectively using these variables, we can create
    more robust and maintainable build systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this section with *Figure 5**.3*. This figure illustrates the
    revised rule from *Figure 5**.2*, now incorporating our user-defined variable
    along with the special variables related to targets and prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: A Make rule using a user-defined variable and two special variables](img/B21914_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: A Make rule using a user-defined variable and two special variables'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will guide you through the process of setting up a `make`
    build system on your development computer.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Make
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will go through the process of downloading, installing,
    and configuring the `make` build system on a Windows environment. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Download make**: We begin by navigating to the appropriate website to download
    GNU Make for Windows. For this example, we’ll use SourceForge, a popular repository
    for open source projects. Go to [https://gnuwin32.sourceforge.net/packages/make.htm](https://gnuwin32.sourceforge.net/packages/make.htm).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Complete package, except sources** option description, click **Setup**
    under the **Download** column to start downloading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make` on your computer. When you reach the step titled `C:\Program` `Files
    (x86)\GnuWin32`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make` from any command line or script, we need to add its executable to our
    system environment variables, following the same process we used in [*Chapter
    1*](B21914_01.xhtml#_idTextAnchor015) to add OpenOCD to the environment variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do this by navigating to the `bin` folder where `make` was installed (`C:\Program
    Files (x86)\GnuWin32\bin`) and then copying the path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on `make` path into this new row.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm your changes by clicking **OK** on the various pop-up windows.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To confirm that the `make` is properly set up, open command prompt and simply
    type `make`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that the `make` build system is properly configured on the Windows
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'On many Linux distributions, `make` is readily available through the distribution’s
    package manager. For instance, on Ubuntu and other Debian-based distributions,
    we can install make (along with other build essentials, such as the GCC compiler)
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, `make` is part of the Command Line Tools package that comes with
    Xcode, Apple’s suite of development tools. This means that if you have installed
    Xcode, you will have `make` already installed. We can also install the standalone
    Command Line Tools package by running the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we successfully set up the `make` build system on our development
    machine. In the following section, we will apply the concepts covered in this
    chapter to write our own Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Makefiles for firmware projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this section is to write a Makefile and successfully test it. Let’s
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: In our workspace folder, let’s make a new folder named `4_Makefiles`. In this
    folder, create a file called `Makefile`. This file must start with a capital **M**
    and should have **no extension**.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Windows and it asks whether you really want to change the file
    extension, click **Yes**. Then, right-click the file and open it with a basic
    text editor, such as Notepad++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objectives with the Makefile can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.c` and `stm32f411_startup.c`) into object files (`main.o` and `stm32f411_startup.o`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stm32_ls.ld`) to create a final executable (`4_makefile_project.elf`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*.o`, `*.elf.`, and `*.map`), allowing for a fresh start with no leftover
    artifacts from previous builds'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is our complete Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`final :` `4_makefile_project.elf`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This line deals with the creation of the final target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we execute `make final`, `make` will check whether the `4_makefile_project.elf`
    target needs to be updated before executing it. This is a dependency relationship
    where `final` acts purely as an aggregation point to invoke all the build processes
    leading up to `4_makefile_project.elf`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`main.o :` `main.c`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -``o main.o`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `make` rule compiles the `main.c` source file into an object file named
    `main.o.` Upon close inspection, you can see that the command employed here is
    identical to the one we used at the command prompt to manually compile `main.c`
    in the previous chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stm32f411_startup.o :` `stm32f411_startup.c`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c
    -``o stm32f411_startup.o`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This compiles the `stm32f411_startup.c` source file into an object file, named
    `stm32f411_startup.o`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4_makefile_project.elf :` `main.o stm32f411_startup.o`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o` `4_makefile_project.elf
    -Wl,-Map=4_makefile_project.map`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This rule links the `main.o` and `stm32f411_startup.o` object files to produce
    the final executable, `4_makefile_project.elf`. Additionally, it generates a map
    file named `4_makefile_project.map` that shows where each part of the code and
    data is loaded in memory, which is useful for debugging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`load:`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`openocd -``f board/st_nucleo_f4.cfg`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This rule initiates OpenOCD to begin the process of loading the final executable
    onto the target hardware. It executes OpenOCD, using a configuration file tailored
    for the STM32 Nucleo F4 board, specifically `st_nucleo_f4.cfg`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`clean:`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`del` `-f *.o *.``elf *.map`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This command cleans the build directory by removing all generated files, ensuring
    a clean environment for subsequent builds. The `del -f` command forcefully deletes
    files, preventing prompts that ask for deletion confirmation. The `*.o`, `*.elf`,
    and `*.map` patterns specify that all object files, ELF executables, and map files,
    respectively, should be deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the Makefile ready, it is time to test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Makefile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding to the command line, let’s ensure that the linker script,
    startup file, and all source files are placed in the correct directory. Additionally,
    we will slightly update the `main.c` file, which will allow us to validate that
    the most recent version of the firmware executes correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.c` file from the previous project (`3_LinkerscriptAndStartup`), which
    includes the foundational application code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, locate `stm32_ls.ld` (the linker script) and `stm32f411_startup.c`
    (the startup file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste these files (`stm32_ls.ld`, `stm32f411_startup.c`, and `main.c`)
    into the `4_Makefiles` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file from slow to fast:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.c` file within the `4_ Makefiles` folder and select the option to open
    it with a simple text editor, such as Notepad++.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LED_PIN`). Adjust the delay intervals within this section to change the LED’s
    blink rate from its current slower pace to a rapid one. The current one should
    look like this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the current code with the following snippet to toggle the state of
    PA5 to a faster rate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s access our new folder through the command prompt, following the steps
    we used in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the command prompt, simply execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create our final executable, `4_makefile_project.elf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will begin uploading the final executable onto our microcontroller
    by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch OpenOCD. The next step involves using the **GNU Debugger**
    (**GDB**) to upload the firmware to the microcontroller, as we did in the previous
    chapter. Let’s access another command prompt window (as OpenOCD should keep running
    in the first one) and enter the following command to start the GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once GDB is open, we establish a connection to our microcontroller by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s reset and initialize the board, as we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080),
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the firmware onto the microcontroller using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully loading the firmware, we reset the board again with the
    same reset command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we resume the execution of the firmware on the microcontroller with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You should see the LED blinking at a rapid rate, indicating the successful upload
    and execution of our new firmware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can stop the GDB by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we execute the following when asked if we want to quit anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To clean our build directory, we will open the command prompt in the build
    directory and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will delete all the `.o`, `.elf`, and `.map` files in the build directory.
  prefs: []
  type: TYPE_NORMAL
- en: Before concluding this chapter, let’s explore how our Makefile appears when
    we incorporate special and user-defined variables.
  prefs: []
  type: TYPE_NORMAL
- en: Applying special and user-defined variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s apply special variables and user-defined variables to our makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, we’ve defined three essential variables to streamline our
    Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CC`: This variable represents the compiler used to compile the source files.
    It simplifies the Makefile by centralizing the compiler definition, making it
    easier to update or change if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFLAGS`: This holds the compilation flags necessary to build the source files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDFLAGS`: This contains the linker flags that dictate how an executable is
    linked from the object files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we’ve used special variables for target names (`$@`) and prerequisite
    lists (`$^`) to replace explicit mentions of these components in the `make` recipes,
    further simplifying the Makefile structure.
  prefs: []
  type: TYPE_NORMAL
- en: Update your current makefile to this new version and upload the new executable,
    named `5_makefile_project_v2.elf`, onto your microcontroller. This updated version
    should function seamlessly, just like the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on an exploration of the `make` build system, a
    cornerstone tool for automating the build process in software development. The
    journey began with an introduction to what build systems are and their critical
    role in converting source code into deployable software, such as executables and
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We then delved into the specific mechanics of the `make` build system, starting
    with the foundational elements of a Makefile, which include *targets*, *prerequisites*,
    and *recipes*. These components were thoroughly discussed to provide a clear understanding
    of how they interact within `make` to manage and streamline the compilation and
    linking of software projects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter wrapped up with a practical demonstration of writing Makefiles,
    effectively consolidating the theoretical concepts discussed throughout. This
    hands-on experience ensures that you are well-equipped to apply these strategies
    to your own firmware projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will transition to another critical aspect of firmware
    development – the development of peripheral drivers, beginning with **General
    Purpose Input/Output** (**GPI/O**) drivers. This shift will introduce you to the
    fundamentals of interfacing with hardware components, a pivotal skill in embedded
    systems development.
  prefs: []
  type: TYPE_NORMAL
