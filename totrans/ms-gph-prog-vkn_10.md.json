["```cpp\nvec4 scattering_extinction_from_color_density( vec3 color,\n    float density ) {\n    const float extinction = scattering_factor * density;\n    return vec4( color * extinction, extinction );\n}\n```", "```cpp\nlayout (local_size_x = 8, local_size_y = 8, local_size_z =\n        1) in;\nvoid main() {\n    ivec3 froxel_coord = ivec3(gl_GlobalInvocationID.xyz);\n    vec3 world_position = world_from_froxel(froxel_coord);\n    vec4 scattering_extinction = vec4(0);\n```", "```cpp\n    vec3 sampling_coord = world_position *\n       volumetric_noise_position_multiplier +\n       vec3(1,0.1,2) * current_frame *\n       volumetric_noise_speed_multiplier; \n    vec4 sampled_noise = texture(\n       global_textures_3d[volumetric_noise_texture_index],\n       sampling_coord);\n    float fog_noise = sampled_noise.x;\n```", "```cpp\n    // Add constant fog\n    float fog_density = density_modifier * fog_noise;\n    scattering_extinction += \n       scattering_extinction_from_color_density( \n       vec3(0.5), fog_density ); \n```", "```cpp\n    // Add height fog\n    float height_fog = height_fog_density *\n       exp(-height_fog_falloff * max(world_position.y, 0)) *\n       fog_noise;\n    scattering_extinction += \n       scattering_extinction_from_color_density( \n       vec3(0.5), height_fog ); \n```", "```cpp\n    // Add density from box\n    vec3 box = abs(world_position - box_position);\n    if (all(lessThanEqual(box, box_size))) {\n        vec4 box_fog_color = unpack_color_rgba( box_color\n                                              );\n        scattering_extinction +=\n            scattering_extinction_from_color_density(\n                box_fog_color.rgb, box_fog_density *\n                    fog_noise);\n    }\n```", "```cpp\n    imageStore(global_images_3d[froxel_data_texture_index],\n               froxel_coord.xyz, scattering_extinction );\n}\n```", "```cpp\nlayout (local_size_x = 8, local_size_y = 8, local_size_z =\n        1) in;\nvoid main() {\n    ivec3 froxel_coord = ivec3(gl_GlobalInvocationID.xyz);\n    vec3 world_position = world_from_froxel(froxel_coord);\n    vec3 rcp_froxel_dim = 1.0f / froxel_dimensions.xyz;\n```", "```cpp\nvec4 scattering_extinction = texture(global_textures_3d \n   [nonuniformEXT(froxel_data_texture_index)], \n   froxel_coord * rcp_froxel_dim);\n   float extinction = scattering_extinction.a;\n```", "```cpp\nvec3 lighting = vec3(0);\nvec3 V = normalize(camera_position.xyz - world_position);\n// Read clustered lighting data\n// Calculate linear depth\nfloat linear_d = froxel_coord.z * 1.0f /\n   froxel_dimension_z;\nlinear_d = raw_depth_to_linear_depth(linear_d,\n   froxel_near, froxel_far) / froxel_far;\n// Select bin\nint bin_index = int( linear_d / BIN_WIDTH );\nuint bin_value = bins[ bin_index ];\n// As in calculate_lighting method, cycle through\n// lights to calculate contribution\nfor ( uint light_id = min_light_id;\n    light_id <= max_light_id;\n    ++light_id ) {\n    // Same as calculate_lighting method\n    // Calculate point light contribution\n    // Read shadow map for current light\n    float shadow = current_depth –\n       bias < closest_depth ? 1 : 0;\n    const vec3 L = normalize(light_position –\n       world_position);\n    float attenuation = attenuation_square_falloff(\n       L, 1.0f / light_radius) * shadow;\n```", "```cpp\n    lighting += point_light.color *\n       point_light.intensity *\n       phase_function(V, -L,\n         phase_anisotropy_01) *\n       attenuation;\n                    }\n```", "```cpp\nvec3 scattering = scattering_extinction.rgb * lighting;\nimageStore( global_images_3d\n            [light_scattering_texture_index],\n            ivec3(froxel_coord.xyz), vec4(scattering,\n            extinction) );\n}\n```", "```cpp\n// Dispatch with Z = 1 as we perform the integration.\nlayout (local_size_x = 8, local_size_y = 8, local_size_z =\n        1) in;\nvoid main() {\n    ivec3 froxel_coord = ivec3(gl_GlobalInvocationID.xyz);\n    vec3 integrated_scattering = vec3(0,0,0);\n    float integrated_transmittance = 1.0f;\n    float current_z = 0;\n    vec3 rcp_froxel_dim = 1.0f / froxel_dimensions.xyz;\n```", "```cpp\n    for ( int z = 0; z < froxel_dimension_z; ++z ) {\n        froxel_coord.z = z;\n         float next_z = slice_to_exponential_depth(\n                        froxel_near, froxel_far, z + 1,\n                        int(froxel_dimension_z) );\n        const float z_step = abs(next_z - current_z);\n        current_z = next_z;\n```", "```cpp\n        // Following equations from Physically Based Sky,\n           Atmosphere and Cloud Rendering by Hillaire\n        const vec4 sampled_scattering_extinction =\n        texture(global_textures_3d[\n        nonuniformEXT(light_scattering_texture_index)],\n        froxel_coord * rcp_froxel_dim);\n        const vec3 sampled_scattering =\n            sampled_scattering_extinction.xyz;\n        const float sampled_extinction =\n            sampled_scattering_extinction.w;\n        const float clamped_extinction =\n            max(sampled_extinction, 0.00001f);\n        const float transmittance = exp(-sampled_extinction\n                                        * z_step);\n        const vec3 scattering = (sampled_scattering –\n                                (sampled_scattering *\n                                transmittance)) /\n                                clamped_extinction;\n        integrated_scattering += scattering *\n                                 integrated_transmittance;\n        integrated_transmittance *= transmittance;\n        imageStore( global_images_3d[\n           integrated_light_scattering_texture_index],\n           froxel_coord.xyz,\n           vec4(integrated_scattering,\n              integrated_transmittance) );\n    }\n}\n```", "```cpp\nvec3 apply_volumetric_fog( vec2 screen_uv, float raw_depth,\n                           vec3 color ) {\n    const float near = volumetric_fog_near;\n    const float far = volumetric_fog_far;\n    // Fog linear depth distribution\n    float linear_depth = raw_depth_to_linear_depth(\n                         raw_depth, near, far );\n    // Exponential\n    float depth_uv = linear_depth_to_uv( near, far,\n        linear_depth, volumetric_fog_num_slices );\nvec4 scattering_transmittance =\n   texture(global_textures_3d\n   [nonuniformEXT(volumetric_fog_texture_index)], \n   froxel_uvw);\n```", "```cpp\n    color.rgb = color.rgb * scattering_transmittance.a +\n                scattering_transmittance.rgb;\n    return color;\n}\n```", "```cpp\n#define SIGMA_FILTER 4.0\n#define RADIUS 2\nfloat gaussian(float radius, float sigma) {\n    const float v = radius / sigma;\n    return exp(-(v*v));\n}\n```", "```cpp\n    vec4 scattering_extinction =\n       texture( global_textures_3d[\n       nonuniformEXT(light_scattering_texture_index)],\n       froxel_coord * rcp_froxel_dim );\n    if ( use_spatial_filtering == 1 ) {\n        float accumulated_weight = 0;\n        vec4 accumulated_scattering_extinction = vec4(0);\n        for (int i = -RADIUS; i <= RADIUS; ++i ) {\n            for (int j = -RADIUS; j <= RADIUS; ++j ) {\n                ivec3 coord = froxel_coord + ivec3(i, j,\n                                                   0);\n                // if inside\n                if (all(greaterThanEqual(coord, ivec3(0)))\n                    && all(lessThanEqual(coord,\n                    ivec3(froxel_dimension_x,\n                    froxel_dimension_y,\n                    froxel_dimension_z)))) {\n                    const float weight =\n                        gaussian(length(ivec2(i, j)),\n                            SIGMA_FILTER);\n                    const vec4 sampled_value =\n                      texture(global_textures_3d[\n                        nonuniformEXT(\n                          light_scattering_texture_index)],\n                            coord * rcp_froxel_dim);\n                  accumulated_scattering_extinction.rgba +=\n                      sampled_value.rgba * weight;\n                    accumulated_weight += weight;\n                }\n            }\n        }\n        scattering_extinction =\n           accumulated_scattering_extinction /\n           accumulated_weight;\n    }\n```", "```cpp\n    imageStore(global_images_3d[froxel_data_texture_index],\n               froxel_coord.xyz, scattering_extinction );\n}\n```", "```cpp\n    vec4 scattering_extinction =\n       texture( global_textures_3d[\n       nonuniformEXT(froxel_data_texture_index)],\n       froxel_coord * rcp_froxel_dim );\n```", "```cpp\n    // Temporal reprojection\n    if (use_temporal_reprojection == 1) {\n        vec3 world_position_no_jitter =\n            world_from_froxel_no_jitter(froxel_coord);\n        vec4 sceen_space_center_last =\n            previous_view_projection *\n                vec4(world_position_no_jitter, 1.0);\n        vec3 ndc = sceen_space_center_last.xyz /\n                   sceen_space_center_last.w;\n        float linear_depth = raw_depth_to_linear_depth(\n                             ndc.z, froxel_near, froxel_far\n                             );\n        float depth_uv = linear_depth_to_uv( froxel_near,\n                         froxel_far, linear_depth,\n                         int(froxel_dimension_z) );\n        vec3 history_uv = vec3( ndc.x * .5 + .5, ndc.y * -\n                                .5 + .5, depth_uv );\n```", "```cpp\n        // If history UV is outside the frustum, skip\n        if (all(greaterThanEqual(history_uv, vec3(0.0f)))\n             && all(lessThanEqual(history_uv, vec3(1.0f)))) {\n            // Fetch history sample\n            vec4 history = textureLod(global_textures_3d[\n               previous_light_scattering_texture_index],\n               history_uv, 0.0f);\n```", "```cpp\n            scattering_extinction.rgb = mix(history.rgb,\n                scattering_extinction.rgb,\n                    temporal_reprojection_percentage);\n            scattering_extinction.a = mix(history.a,\n                scattering_extinction.a,\n                    temporal_reprojection_percentage);\n        }\n    }\n```", "```cpp\n    imageStore(global_images_3d[light_scattering_texture_in\n               dex],\n               froxel_coord.xyz, scattering_extinction );\n}\n```", "```cpp\nlayout (local_size_x = 8, local_size_y = 8, local_size_z =\n        1) in;\nvoid main() {\n    ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);\n    vec3 xyz = pos / volumetric_noise_texture_size;\n    float perlin_data = get_perlin_7_octaves(xyz, 4.0);\n    imageStore( global_images_3d[output_texture_index],\n                pos, vec4(perlin_data, 0, 0, 0) );\n}\n```", "```cpp\nfloat triangular_mapping( float noise0, float noise1 ) {\n    return noise0 + noise1 - 1.0f;\n}\n```", "```cpp\nfloat generate_noise(vec2 pixel, int frame, float scale) {\n    vec2 uv = vec2(pixel.xy / blue_noise_dimensions.xy);\n    // Read blue noise from texture\n    vec2 blue_noise = texture(global_textures[\n        nonuniformEXT(blue_noise_128_rg_texture_index)],\n                      uv ).rg;\n    const float k_golden_ratio_conjugate = 0.61803398875;\n    float blue_noise0 = fract(ToLinear1(blue_noise.r) +\n        float(frame % 256) * k_golden_ratio_conjugate);\n    float blue_noise1 = fract(ToLinear1(blue_noise.g) +\n        float(frame % 256) * k_golden_ratio_conjugate);\n    return triangular_noise(blue_noise0, blue_noise1) *\n        scale;\n}\n```"]