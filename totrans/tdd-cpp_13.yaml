- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: How to Test Floating-Point and Custom Values
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何测试浮点数和自定义值
- en: We first encountered the need to test floating-point values in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045),
    *Adding More Confirm Types*, and created a simple solution that would let us compare
    floating-point values within a margin of error. We need the small margin because
    floating-point values that are close and might even look identical when displayed
    are almost always not exactly equal. These small differences make it hard to verify
    test results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次遇到测试浮点值的需求是在[*第5章*](B18567_05.xhtml#_idTextAnchor045)中，*添加更多确认类型*，我们创建了一个简单的解决方案，允许我们在误差范围内比较浮点值。我们需要小的误差范围，因为接近且可能看起来相同的浮点值几乎总是不完全相等。这些小的差异使得验证测试结果变得困难。
- en: 'The main topics in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容包括：
- en: More precise floating-point comparisons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更精确的浮点数比较
- en: Adding floating-point Hamcrest matchers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加浮点数 Hamcrest 匹配器
- en: Writing custom Hamcrest matchers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义 Hamcrest 匹配器
- en: We’re going to improve the simple solution developed earlier into a much better
    way to compare floating-point values that is more precise and works for both small
    and big values. We’ll use the better comparison for both the earlier classical-style
    confirmations and the new Hamcrest-style confirmations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改进之前开发的简单解决方案，使其成为一种更好的比较浮点数的方法，这种方法更精确，适用于小数和大数。我们将使用更好的比较方法来处理早期的经典风格确认和新
    Hamcrest 风格确认。
- en: You’ll also learn how to create your own Hamcrest matchers in this chapter.
    We’ll be creating a new matcher to test for inequality instead of always testing
    for equality, and you’ll see how to contain one matcher inside another so that
    you can better reuse a matcher without needing to duplicate all the matcher template
    specializations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将在本章中学习如何创建自己的 Hamcrest 匹配器。我们将创建一个新的匹配器来测试不等式，而不是始终测试相等性，你将看到如何将一个匹配器包含在另一个匹配器中，这样你就可以更好地重用匹配器，而无需重复所有匹配器模板特化。
- en: Finally, you’ll learn how to create another custom simple matcher that will
    be slightly different than the other matchers so far because the new matcher will
    not need an expected value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何创建另一个自定义简单匹配器，它将与其他匹配器略有不同，因为新的匹配器不需要预期值。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 20
    or later compiler and standard library. The code is based on and continues enhancing
    the testing library from *Part 1* of this book, *Testing MVP*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都使用基于任何现代 C++ 20 或更高版本编译器和标准库的标准 C++。代码基于并继续增强本书第一部分*测试 MVP*中的测试库。
- en: 'You can find all the code for this chapter in the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此 GitHub 仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP'
- en: )
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: More precise floating-point comparisons
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更精确的浮点数比较
- en: Whenever improvements are needed, one of the first things to look for is a way
    to measure the current design. Back in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045),
    *Adding More Confirm Types*, we examined floating-point numbers and I explained
    that comparing any floating-point type value—float, double, or long double—directly
    with another floating-point value is a bad idea. The comparison is too sensitive
    to small rounding errors and will usually result in the two values comparing not
    equal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要改进时，首先要寻找的是衡量当前设计的方法。在[*第5章*](B18567_05.xhtml#_idTextAnchor045)中，*添加更多确认类型*，我们探讨了浮点数，我解释说，直接将任何浮点类型值（float、double
    或 long double）与另一个浮点值进行比较是一个糟糕的想法。这种比较对小的舍入误差过于敏感，通常会导致两个值比较不相等。
- en: In [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045), I showed you how to add
    a small margin to the comparison so that an accumulation of errors would not throw
    off the comparison as long as the two numbers being compared were close enough
    in value to each other. In other words, two values can compare equal as long as
    they are close enough to each other.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18567_05.xhtml#_idTextAnchor045)中，我向你展示了如何给比较添加一个小范围，这样只要被比较的两个数值足够接近，误差的累积就不会影响比较。换句话说，只要两个值足够接近，它们就可以比较相等。
- en: But what margin should be used? We simply picked some small numbers, and that
    solution worked. We’re going to improve that solution. And now that you’re becoming
    familiar with `Hamcrest.cpp`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但应该使用多大的容差？我们只是挑选了一些小的数字，这个解决方案就有效了。我们将改进这个解决方案。现在，你已经熟悉了`Hamcrest.cpp`。
- en: 'The first function will convert a floating-point value into a fraction by dividing
    by a constant. We’ll divide by `10`, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数将通过除以一个常数将浮点数转换为分数。我们将除以`10`，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a template, so it will work for float, double, and long double types.
    The intent is for the input to be a whole number, and this function will turn
    the number into tenths. Remember from [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045)
    that tenths don’t have exact representations in binary. There will be a slight
    error introduced but not much because we only do one division calculation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模板，所以它适用于float、double和long double类型。意图是输入是一个整数，这个函数将数字转换为十分之一。记得从[*第五章*](B18567_05.xhtml#_idTextAnchor045)中，十分之一在二进制中没有精确的表示。将引入一点误差，但不会太多，因为我们只做一次除法计算。
- en: 'We’ll need another function that will generate bigger margins of error by doing
    more work, like this function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个函数，通过做更多的工作来生成更大的误差范围，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function adds `1` and then subtracts `1`, so the input should remain unchanged.
    But because we add many small amounts that will all equal `1`, the function introduces
    many errors during the calculations. The result that gets returned should be close
    to the original `input` but not the same.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数先加`1`然后减`1`，所以输入应该保持不变。但由于我们添加了许多等于`1`的小量，这个函数在计算过程中引入了许多错误。返回的结果应该接近原始的`input`，但并不相同。
- en: 'The last helper function will call the first two functions many times for many
    different values and count how many times the results are equal. The function
    looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的辅助函数将多次调用前两个函数，对许多不同的值进行计数，以查看结果相等多少次。函数看起来像这样：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function uses the fraction as the `expected` value since it should have
    the fewest errors. The `expected` value is compared with the `actual` value, which
    we get from accumulating many small errors. The two values should be close but
    not exactly equal. They should be close enough to be counted as equal, though.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用分数作为`预期`值，因为它应该有最少的误差。`预期`值与从累积许多小误差中得到的`实际`值进行比较。这两个值应该很接近，但并不完全相等。尽管如此，它们应该足够接近，以至于可以被认为是相等的。
- en: Who defines what is close enough? That’s really up to you to decide. The tests
    we’re creating in this book might be allowing more errors than your application
    can tolerate. You’ll understand after reading this section how to modify your
    code if you need more or less tolerance. There is no right answer for how to compare
    floating-point values that will work for all applications. The best you can do
    is to be aware of your own needs and adapt the code to fit those needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 谁定义了“足够接近”是什么意思？这完全取决于你自己的决定。在这本书中我们创建的测试可能允许比你的应用程序可以容忍的更多错误。阅读这一节后，你会了解如果需要更多或更少的容忍度，如何修改你的代码。对于如何比较浮点值，没有适用于所有应用程序的正确答案。你能做的最好的事情就是意识到自己的需求，并调整代码以适应这些需求。
- en: The `performComparisons` function also uses the `==` operator without any type
    of margin. The results should have a lot of unequal results. But how many? Let’s
    write a test to find out!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`performComparisons`函数也使用`==`运算符而不带任何类型的容差。结果应该有很多不相等的结果。但有多少呢？让我们写一个测试来找出答案！'
- en: 'Add this test to the end of `Hamcrest.cpp`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将此测试添加到`Hamcrest.cpp`的末尾：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The test will cycle through `1,000` values, turning each one into tenths, introducing
    errors, and counting how many compared equal. The results are really bad:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将循环通过`1,000`个值，将每个值转换为十分之一，引入错误，并计算有多少个比较相等。结果真的很糟糕：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Only four values were close enough to be considered equal with the standard
    equality operator. You might get slightly different results depending on your
    computer and your compiler. If you do get different results, then that should
    be more evidence about how unreliable floating-point comparisons are. How about
    double and long double types? Add these two tests to find out:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只有四个值足够接近，可以用标准相等运算符被认为是相等的。你可能根据你的计算机和编译器得到略微不同的结果。如果你得到不同的结果，那么这应该更有力地证明浮点比较是多么不可靠。那么双精度和长双精度类型呢？添加这两个测试来找出答案：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results are just as bad and look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果同样糟糕，看起来像这样：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s add a margin to the equality comparison to see how much better the comparisons
    become. We’ll start with the values used in the existing `confirm` overloads in
    `Test.h`. One of the overloads looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在相等比较中添加一个边缘值，看看比较会变得多好。我们将从`Test.h`中现有的`confirm`重载中使用的值开始。其中一个重载看起来像这样：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The value we are interested in is the hardcoded literal floating-point value.
    In this case, it’s `0.0001f`. All we need to do is create three more helper functions
    that return these values. Note that the double and long double overloads have
    a different value than the float type. Place these three helper functions in `Hamcrest.cpp`,
    right before the `performComparisons` function, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是硬编码的浮点字面值。在这种情况下，它是`0.0001f`。我们只需要创建三个额外的辅助函数来返回这些值。请注意，double和long double的重载与float类型有不同的值。将这些三个辅助函数放在`Hamcrest.cpp`中，在`performComparisons`函数之前，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These three helper functions will let us customize the margin for each type.
    They each take a floating-point type parameter that is only used to determine
    which function to call. We don’t actually need or use the parameter value passed
    to the function. We’ll call these helper functions from within the `performComparisons`
    template, which will know the type to be used based on how the template was constructed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个辅助函数将使我们能够为每种类型定制边缘值。它们各自接受一个浮点类型参数，该参数仅用于确定要调用的函数。我们实际上不需要或使用传递给函数的参数值。我们将在`performComparisons`模板内部调用这些辅助函数，该模板将根据模板的构建方式知道要使用哪种类型。
- en: 'We’re also going to slightly change how we compare with a margin. Here’s an
    example of how the confirm functions compare:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将稍微改变带有边缘值的比较方式。以下是一个确认函数如何比较的示例：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of this, we’re going to subtract the `expected` value from the `actual`
    value and then compare the absolute value of that subtraction result with the
    margin. We need to include `cmath` at the top of `Hamcrest.cpp` for the `abs`
    function, and we’re going to need `limits` soon also, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样，我们将从`expected`值中减去`actual`值，然后比较这个减法结果的绝对值与边缘值。我们需要在`Hamcrest.cpp`的顶部包含`cmath`以使用`abs`函数，并且我们很快也需要`limits`，如下所示：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now, we can change the `performComparisons` function to use the margin,
    like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`performComparisons`函数更改为使用边缘值，如下所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After making these changes, all the tests pass, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些更改后，所有的测试都通过了，如下所示：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This means that all `1,000` values are now matching within a small margin of
    error. This is the same solution explained in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045).
    We should be good, right? Not quite.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在所有`1,000`个值都在一个很小的误差范围内匹配。这是在[*第五章*](B18567_05.xhtml#_idTextAnchor045)中解释的相同解决方案。我们应该没问题，对吧？并不完全是这样。
- en: The problem is that the margin value is quite big for small numbers and too
    small for big numbers. All the tests are passing, but that’s just because we have
    a margin that’s big enough to let a lot of comparisons be treated as equal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，对于小数，边缘值很大，而对于大数，边缘值又太小。所有的测试都通过了，但这仅仅是因为我们有一个足够大的边缘值，使得很多比较都被视为相等。
- en: 'To see this, let’s refactor the comparison out of the `performComparisons`
    function so that the check is in its own function, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，让我们将比较从`performComparisons`函数中重构出来，使其检查在自己的函数中，如下所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then we can write a couple tests to call `compareEq` directly, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写一些测试来直接调用`compareEq`，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The test for small float values compares two numbers that are obviously different,
    yet the comparison function will consider them equal and the test fails. The fixed
    margin considers any float values within `0.0001f` to be equal. We want the two
    values to compare not equal, but our margin is big enough that they are considered
    to be equal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小浮点数的测试比较了两个明显不同的数字，但比较函数会将它们视为相等，测试失败。固定的边缘值将任何在`0.0001f`内的浮点值视为相等。我们希望这两个值比较时不相等，但我们的边缘值足够大，以至于它们被视为相等。
- en: What is the *epsilon* value that the comment refers to? We’ll start using the
    actual epsilon values in just a moment, and this is why I suggested that you include
    `limits`. Floating-point numbers have a concept called epsilon, which is a value
    defined in `limits` for each floating-point type. The epsilon value represents
    the smallest distance between adjacent floating-point values for values between
    1.0 and 2.0\. Remember that floating-point values can’t represent every possible
    fractional number, so there are gaps between the numbers that can be represented.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注释中提到的 *epsilon* 值是多少？我们很快就会开始使用实际的 epsilon 值，这就是为什么我建议你包含 `limits`。浮点数有一个称为
    epsilon 的概念，这是为每种浮点类型在 `limits` 中定义的值。epsilon 值表示在 1.0 和 2.0 之间的相邻浮点值之间的最小距离。记住，浮点数不能表示每个可能的分数数，因此在可以表示的数之间有间隙。
- en: You can see the same thing yourself if you write down numbers with only a fixed
    number of decimal places on paper. Let’s say that you limit yourself to only using
    two digits after the decimal point. You could write `1.00` and `1.01` and `1.02`.
    Those are adjacent values. In fact, `1.00` and `1.02` are the closest numbers
    you can represent to `1.01` by using only two digits after the decimal place.
    What about a number such as `1.011`? It’s definitely closer to `1.01` than `1.02`
    but we can’t write `1.011` because it needs three digits after the decimal point.
    The epsilon value for our experiment is `0.01`. Floating-point numbers have a
    similar problem except that the value of epsilon is smaller and not a simple value
    such as `0.01`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将只有固定小数位数的数字写在纸上，你也能看到相同的情况。比如说，你限制自己只使用小数点后两位数字。你可以写 `1.00`、`1.01` 和 `1.02`。这些都是相邻的值。实际上，`1.00`
    和 `1.02` 是你只能使用小数点后两位数字表示的，最接近 `1.01` 的数值。那么一个像 `1.011` 这样的数呢？它肯定比 `1.02` 更接近
    `1.01`，但我们不能写 `1.011`，因为它需要小数点后三位数字。我们实验中的 epsilon 值是 `0.01`。浮点数也有类似的问题，只是 epsilon
    的值更小，不是一个简单的值如 `0.01`。
- en: Another complication is that the distance between adjacent floating-point numbers
    increases as the numbers get larger, and the distance decreases as the numbers
    get smaller. The test for small float values uses small values, but the values
    are much bigger than epsilon. Because the numbers are much bigger than epsilon,
    we want the test to fail. The test passes because our fixed margin is even bigger
    than epsilon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个复杂的问题是，随着数值的增大，相邻浮点数之间的距离增加，而随着数值的减小，距离减小。小浮点数的测试使用的是小数值，但数值比 epsilon 大得多。因为数值比
    epsilon 大得多，我们希望测试失败。测试通过是因为我们的固定容限甚至比 epsilon 还大。
- en: The test for large float values also fails. It uses two values that are different
    by `0.001f`, which would be a really big difference if we were comparing `1.0f`
    with `1.001f`. At small values, a difference of `0.001f` would be enough to cause
    the values to compare not equal. But we’re not dealing with small values—we’re
    dealing with values that are almost 10,000! We now want the larger values to be
    considered equal because the fractional part makes up a smaller percentage of
    the larger numbers. The test fails because our fixed margin doesn’t consider that
    the values are larger and only looks at the difference, which is greater than
    the fixed margin allows.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大浮点数的测试也失败了。它使用了两个相差 `0.001f` 的值，如果我们比较 `1.0f` 和 `1.001f`，这将是一个很大的差异。在小数值的情况下，`0.001f`
    的差异足以使值比较结果不相等。但我们处理的是大数值——我们处理的是几乎 10,000 的数值！现在我们希望较大的数值被认为是相等的，因为小数部分在较大的数值中占的比例更小。测试失败是因为我们的固定容限没有考虑到数值较大，只关注了差异，而这个差异大于固定容限允许的范围。
- en: 'We can also test the other floating-point types. Add these two similar tests
    for double right after the two tests added for small and large float values, like
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以测试其他浮点类型。在为小浮点数和大浮点数添加的两个测试之后，立即添加这两个类似的测试，如下所示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the double type, we have a different epsilon value that’s much smaller than
    the epsilon for floats, and we also have many more significant digits to work
    with, so we can use numbers with more digits. We were limited to only about 7
    digits when working with floats. With doubles, we can use numbers with about 16
    digits. Notice that with doubles, we need a large value in the trillions in order
    to see a difference of `0.0003` that should be compared as equal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双精度类型，我们有一个比浮点数 epsilon 值小得多的不同 epsilon 值，并且我们可以使用更多的有效数字进行操作，因此我们可以使用更多位数的数字。当我们使用浮点数时，我们仅限于大约
    7 位数字。使用双精度，我们可以使用大约 16 位数字的数字。请注意，使用双精度时，我们需要一个以万亿为单位的较大值，才能看到应该视为相等的 `0.0003`
    的差异。
- en: If you are wondering how I arrived at these test numbers, I just picked small
    numbers just one decimal place bigger than epsilon for the small value tests.
    And for the large values, I choose a bigger number that I multiplied by (1 + epsilon)
    to arrive at the other number to be compared with. I then rounded the other number
    a bit so that it would be a bit closer. I had to choose a big number to start
    with that would stay within the number of digits allowed for each type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道我是如何得到这些测试数字的，我只是选择了比 epsilon 大一个小数位的较小值测试的小数。对于较大值，我选择了一个较大的数字，并将其乘以（1
    + epsilon）以得到要比较的另一个数字。然后我对另一个数字进行了一些四舍五入，使其更接近一些。我必须选择一个较大的起始数字，以确保它保持在每种类型允许的位数内。
- en: 'Since we’re using the double epsilon value for long doubles, the tests for
    small and large long doubles look similar to the tests for double. The long double
    tests look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用长双精度 epsilon 值，因此小长双精度和大长双精度的测试看起来与双精度的测试相似。长双精度的测试如下：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only difference between the double tests and the long double tests is the
    long double suffix `L` at the end of the long double literal values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度测试和长双精度测试之间的唯一区别是长双精度字面值末尾的 `L` 后缀。
- en: After adding all six tests for small and large floating-point type tests, they
    all fail when run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了所有六个针对小浮点数和大型浮点数类型测试之后，当运行时它们都失败了。
- en: The reason for the failures is the same for each type. The small value tests
    all fail because the fixed margin considers the values to be equal when they should
    not be equal, and the large value tests consider the values to be not equal when
    they really are close, considering the large value. In fact, the large values
    are all within a single epsilon value from each other. The large values are as
    close as they can possibly get without being exactly equal. Sure—the long double
    large values could have been closer, but we’re simplifying long doubles a bit
    by using the bigger epsilon from the double type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的原因对每种类型都是相同的。小值测试全部失败，因为固定的边距将值视为相等，而实际上它们不应该相等，并且大值测试在考虑大值时将值视为不相等，而实际上它们非常接近。事实上，大值彼此之间只有一个
    epsilon 值的距离。大值尽可能接近，但不是完全相等。当然——长双精度的大值可能更接近，但我们通过使用来自双精度类型的较大 epsilon 来简化长双精度。
- en: We need to enhance the `compareEq` function so that the margin can be smaller
    for small values and bigger for big values. The moment we take on the responsibilities
    of comparing floating-point values, there are a lot of details that need to be
    handled. We skipped the extra details in [*Chapter 5*](B18567_05.xhtml#_idTextAnchor045).
    We’re also going to skip some of the details even here. If you haven’t realized
    it yet, dealing with floating-point values is really hard. The moment you think
    everything is working is when another detail comes along that changes everything.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要增强 `compareEq` 函数，以便对于小值，边距可以更小，对于大值，边距可以更大。当我们承担比较浮点数值的责任时，有很多细节需要处理。我们在
    [*第五章*](B18567_05.xhtml#_idTextAnchor045) 中跳过了额外的细节。我们甚至在这里也会跳过一些细节。如果你还没有意识到，处理浮点数值真的很困难。当你认为一切都在正常工作时，另一个细节就会出现，从而改变一切。
- en: 'Let’s first fix the `getMargin` functions to return the real `epsilon` values
    modified slightly for each type, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先修复 `getMargin` 函数，使其返回每种类型的修改后的真实 epsilon 值，如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getMargin` functions now use the `epsilon` values for the types as defined
    in `numeric_limits`. The margins are tuned for our needs. You might want to multiply
    by different numbers, and you might want to use the real `epsilon` value for long
    doubles. The reason we want bigger margins than `epsilon` itself is that we want
    to consider values to be equal that are more than just one `epsilon` value greater
    or lesser away from each other. We want a little more room for the accumulation
    of at least a few calculation errors. We multiply `epsilon` by `4` to give that
    extra room, and we use the double `epsilon` for long doubles, which might really
    be too much already. But these margins work for what we need.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMargin`函数现在使用在`numeric_limits`中定义的类型`epsilon`值。边缘被调整以满足我们的需求。你可能想要乘以不同的数字，你可能想要为长双精度使用实际的`epsilon`值。我们想要比`epsilon`本身更大的边缘的原因是我们想要考虑那些彼此之间相差不止一个`epsilon`值的数值相等。我们想要为至少几个计算误差的累积留出更多空间。我们将`epsilon`乘以`4`以提供额外的空间，并且对于长双精度，我们使用双倍的`epsilon`，这可能已经足够了。但这些边缘对我们来说是有效的。'
- en: 'We’ll use the more accurate margin values in the new `compareEq` function,
    which looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在新的`compareEq`函数中使用更精确的边缘值，该函数看起来像这样：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I like to use parameter names `lhs` and `rhs` for operator-type functions such
    as this. The abbreviations stand for left-hand side and right-hand side, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢为像这样的操作符类型函数使用参数名称`lhs`和`rhs`。这些缩写分别代表左端和右端。
- en: 'Consider these two numbers:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这两个数字：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When making a comparison of these, `3` is on the left side of the operator and
    would be the `lhs` argument, while `4` is on the right and would be the `rhs`
    argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行这些比较时，`3`位于操作符的左侧，将是`lhs`参数，而`4`位于右侧，将是`rhs`参数。
- en: There’s always a chance that the two numbers being compared are exactly equal
    to each other. So, the first thing we check is for an exact match using the `==`
    operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有可能被比较的两个数值完全相等。所以，我们首先使用`==`操作符检查是否完全匹配。
- en: The `compareEq` function goes on to check the difference between the two numbers
    for a *subnormal* result. Remember I said that floating-point numbers are complicated?
    There could be an entire book written about floating-point math, and there are
    probably several books already written. I won’t go into much explanation about
    subnormal values except to say that this is how floating-point values are represented
    when they are extremely close to zero. We’ll consider any two subnormal values
    to be equal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareEq`函数继续检查两个数值之间的差异以获得一个*异常值*结果。记得我说过浮点数很复杂吗？可能有一整本书是关于浮点数学的，可能已经有几本书写过了。我不会过多解释异常值，只是说这是当浮点值非常接近零时如何表示的。我们将认为任何两个异常值都是相等的。'
- en: Subnormal values are also a good reason to *compare your numbers with each other*
    instead of *comparing their difference with zero*. You might wonder what the problem
    is. Doesn’t the code in the `compareEq` function subtract one value from the other
    to arrive at the difference? Yes, it does. But our `compareEq` function doesn’t
    try to compare the difference with zero directly. We figure out which of the two
    values is bigger and then scale the margin by multiplying the margin with the
    bigger value. We also avoid scaling the margin down when we are comparing values
    less than `1.0`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值也是用*比较你的数值之间*而不是*比较它们的差值与零*的一个很好的理由。你可能想知道问题是什么。`compareEq`函数中的代码不是从另一个值中减去一个值来得到差值吗？是的，它是这样做的。但我们的`compareEq`函数并不试图直接将差值与零进行比较。我们找出两个值中哪个更大，然后通过将边缘与较大的值相乘来缩放边缘。我们还在比较小于`1.0`的值时避免缩小边缘。
- en: If you have two values to compare and instead of passing them to `compareEq`,
    you pass their difference and compare the difference with zero, then you remove
    the ability of the `compareEq` function to do the scaling because the `compareEq`
    function would then only see a small difference and zero being compared.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个值需要比较，并且不是将它们传递给`compareEq`函数，而是传递它们的差值，并将差值与零进行比较，那么你就移除了`compareEq`函数进行缩放的能力，因为`compareEq`函数将只会看到一个很小的差值和与零的比较。
- en: The lesson here is to always pass your numbers to be compared directly to the
    `compareEq` function and let it figure out how much the two numbers are different
    by taking into account how big the numbers are. You’ll get more accurate comparisons.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是始终直接将你要比较的数值传递给`compareEq`函数，并让它通过考虑数值的大小来确定两个数值之间的差异。你会得到更准确的比较。
- en: We could make the `compareEq` function even more elaborate. Maybe we could consider
    the sign of subnormal values instead of considering all of them to be equal, or
    maybe we could scale the margin down more so that we get very precise when dealing
    with subnormal values. This is not a book about math, so we’re going to stop adding
    more to the `compareEq` function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使 `compareEq` 函数更加精细。也许我们可以考虑次正常值的符号，而不是将它们都视为相等，或者我们可以将边界值缩小更多，以便在处理次正常值时非常精确。这不是一本关于数学的书，所以我们将在
    `compareEq` 函数中停止添加更多内容。
- en: After making the changes to `compareEq`, all the tests pass. We now have a solution
    that allows small amounts of accumulated errors and lets two numbers compare equal
    when they are close enough. The solution works for both really small numbers and
    really big numbers. The next section will turn the code we explored here into
    a better Hamcrest equality matcher.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `compareEq` 进行更改后，所有测试都通过了。我们现在有一个解决方案，允许少量的累积误差，并且当两个数字足够接近时，它们可以比较相等。该解决方案适用于非常小的数字和非常大的数字。下一节将把在这里探索的代码转换成一个更好的
    Hamcrest 等价匹配器。
- en: Adding floating-point Hamcrest matchers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加浮点数 Hamcrest 匹配器
- en: We explored better floating-point comparisons in the previous section, and now
    it’s time to use the comparison code in the unit test library. Some of the code
    should be moved into `Test.h` where it fits better and can then be used by the
    test library. The rest of the code that was written should stay in `Hamcrest.cpp`
    because it’s code that supports the tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中探讨了更好的浮点数比较，现在是时候在单元测试库中使用比较代码了。一些代码应该移动到 `Test.h` 中，那里更适合，然后可以被测试库使用。其余的代码应该保留在
    `Hamcrest.cpp` 中，因为它是支持测试的代码。
- en: 'The code that needs to be moved is the `compareEq` function and the three `getMargin`
    functions that `compareEq` calls to get the margins. We also need to move the
    includes of `cmath` and `limits` into `Test.h`, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要移动的代码是 `compareEq` 函数和 `compareEq` 调用来获取边界的三个 `getMargin` 函数。我们还需要将 `cmath`
    和 `limits` 的包含文件移动到 `Test.h` 中，如下所示：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The three `getMargin` functions and the `compareEq` function can be moved into
    `Test.h`, right before the first override of the `confirm` function that accepts
    Booleans. None of the code in the moved functions needs to change. Just cut the
    includes and the functions out of `Hamcrest.cpp` and paste the code into `Test.h`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 三个 `getMargin` 函数和 `compareEq` 函数可以被移动到 `Test.h` 文件中，紧接在第一个接受布尔值的 `confirm`
    函数重写之前。移动的函数中的代码无需更改。只需从 `Hamcrest.cpp` 中剪切包含和函数，然后将代码粘贴到 `Test.h` 中。
- en: 'We might as well fix the existing floating-point classic `confirm` functions.
    This is why I had you move the `compareEq` function into `Test.h` immediately
    before the first `confirm` function. The change to the existing floating-point
    `confirm` functions is simple. They need to call `compareEq` instead of using
    hardcoded margins that don’t scale. The `confirm` function for float types looks
    like this after the change:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不妨修复现有的浮点数经典 `confirm` 函数。这就是为什么我让你立即将 `compareEq` 函数移动到 `Test.h` 中，紧接在第一个
    `confirm` 函数之前。对现有浮点数 `confirm` 函数的更改很简单。它们需要调用 `compareEq` 而不是使用硬编码的边界值，这些边界值不会缩放。更改后的浮点类型
    `confirm` 函数如下所示：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The other two `confirm` functions that accept double and long double types should
    be changed to look similar. All three `confirm` functions will create the correct
    template of `compareEq` based on the `expected` and `actual` parameter types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接受双精度浮点数和长双精度浮点数的其他两个 `confirm` 函数应该被修改得相似。所有三个 `confirm` 函数都将根据 `expected`
    和 `actual` 参数类型创建正确的 `compareEq` 模板。
- en: We should build and run the test application to make sure nothing broke with
    this small refactoring. And all the tests pass. We now have updated classic style
    `confirm` functions that will work better with floating-point comparisons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该构建并运行测试应用程序，以确保这次小的重构没有破坏任何东西。并且所有测试都通过了。我们现在有了更新的经典风格 `confirm` 函数，它们将更好地与浮点数比较一起工作。
- en: We can make the code slightly better, though. We have three almost identical
    functions that are different only by their parameter types. The only reason for
    the three functions is that we want to override the `confirm` function for floating-point
    types. But since we’re using C++20, let’s use *concepts* instead! Concepts are
    a new feature that we’ve already started using when we specialized the `Equals`
    matcher to work with char arrays and char pointers in the previous chapter. Concepts
    allow us to tell the compiler which types are acceptable for template parameters
    and even function parameters. In the previous chapter, we were only using the
    requires keyword to place some restrictions on the template parameters. We’ll
    be using more well-known concepts here in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以使代码稍微好一些。我们有三个几乎完全相同的函数，它们的不同之处仅在于它们的参数类型。这三个函数的唯一原因是我们想要覆盖浮点类型的 `confirm`
    函数。但是，由于我们正在使用 C++20，让我们使用 *concepts* 代替！Concepts 是一个新特性，我们在上一章专门化 `Equals` 匹配器以与字符数组和字符指针一起使用时已经开始使用它。Concepts
    允许我们告诉编译器哪些类型是模板参数和函数参数的可接受类型。在上一章中，我们只使用 `requires` 关键字对模板参数施加一些限制。在本章中，我们将使用更多知名的概念。
- en: 'We need to include `concepts` like this in `Test.h`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Test.h` 中包含这样的 `concepts`：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And then, we can replace the three `confirm` functions that accept float, double,
    and long double types with a single template that uses the `floating_point` concept,
    like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用单个模板替换接受 float、double 和 long double 类型的三个 `confirm` 函数，这个模板使用 `floating_point`
    概念，如下所示：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This new template will only accept floating-point types, and by making both
    `expected` and `actual` share the same type `T`, then both types must be the same.
    The definition of `floating_point` is one of the well-known concepts defined in
    the `concepts` header.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新模板将只接受浮点类型，通过使 `expected` 和 `actual` 共享相同的类型 `T`，那么这两种类型必须相同。`floating_point`
    的定义是 `concepts` 头文件中定义的已知概念之一。
- en: 'Now that we have the classic style confirmations working, let’s get the Hamcrest
    `Equals` matcher working for floating-point values. We can first change the three
    large floating-point tests in `Hamcrest.cpp` to stop calling `compareEq` directly
    and instead use the `CONFIRM_THAT` macro so that they look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使经典风格的确认工作正常，让我们让 Hamcrest 的 `Equals` 匹配器为浮点值工作。我们首先可以将 `Hamcrest.cpp`
    中的三个大型浮点测试更改，停止直接调用 `compareEq`，而是使用 `CONFIRM_THAT` 宏，使它们看起来像这样：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’re not going to change the tests for the small floating-point values yet
    because we don’t have a matcher that does inequality comparisons. The solution
    might be as simple as putting the `not` keyword in front of `Equals`, but let’s
    hold off on that for just a moment because we’ll be exploring our options in the
    next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会更改小浮点值的测试，因为我们还没有一个可以进行不等式比较的匹配器。解决方案可能很简单，只需在 `Equals` 前面加上 `not` 关键字，但让我们稍后再考虑这一点，因为我们将探索我们的选项在下一段中。
- en: 'With the change to the tests, they should fail because we haven’t yet specialized
    the `Equals` matcher to do anything different for floating-point types. Building
    and running the test application shows that the three tests do fail, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试的更改，它们应该会失败，因为我们还没有将 `Equals` 匹配器专门化以对浮点类型执行不同的操作。构建和运行测试应用程序显示，这三个测试确实失败了，如下所示：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how the expected values printed in the summary report don’t exactly match
    the literal values given in the tests for the float and the double types. The
    long double does display a value that matches the value given in the test. The
    discrepancy is because floating-point variables are unable to always match exact
    values. The differences become more visible with floats, a little less visible
    with doubles, and closer to the desired values with long doubles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，总结报告中打印的预期值并不完全匹配测试中给出的浮点类型和双精度类型的字面值。长双精度确实显示了一个与测试中给出的值匹配的值。这种差异是因为浮点变量无法始终匹配精确值。差异在浮点数中更为明显，在双精度数中稍微不明显，而在长双精度数中则更接近期望值。
- en: The steps we just went through follow TDD. We modified existing tests instead
    of creating new tests because we don’t expect callers to use `compareEq` directly.
    The tests were initially written to call `compareEq` directly to show that we
    had a solution for floating-point types that worked. Modifying the tests to the
    desired usage is the right thing to do, and then, by running the tests, we can
    see the failures. This is good because we expected the tests to fail. Had the
    tests passed instead, then we would need to find the reason for the unexpected
    success.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才采取的步骤遵循 TDD（测试驱动开发）。我们修改了现有测试而不是创建新测试，因为我们不期望调用者直接使用 `compareEq`。测试最初是编写来直接调用
    `compareEq` 以表明我们为浮点类型提供了一个解决方案。将测试修改为期望的使用方法是正确的事情，然后，通过运行测试，我们可以看到失败。这是好的，因为我们预计测试会失败。如果测试通过了，那么我们就需要找到意外成功的原因。
- en: 'Let’s get the tests to pass again! We need a version of `Equals` that knows
    how to work with floating-point types. We’ll use the concept `floating_point`
    that we just used for the classic style confirmations to create another version
    of `Equals` that will call `compareEq` for floating-point types. Place this new
    `Equals` specialization in `Test.h` right after `Equals` that works with char
    pointers, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次通过测试！我们需要一个能够处理浮点类型的 `Equals` 版本。我们将使用之前用于经典风格确认的 `floating_point` 概念来创建另一个版本的
    `Equals`，该版本将为浮点类型调用 `compareEq`。将这个新的 `Equals` 特化版本放在 `Test.h` 中，紧接在处理字符指针的 `Equals`
    之后，如下所示：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That’s all we need to change to get the tests passing again. The new `Equals`
    specialization accepts any floating-point type and will be preferred by the compiler
    for floating-point types instead of the general-purpose `Equals` template. The
    floating-point version of `Equals` calls `compareEq` to do the comparison. We
    also don’t need to worry about which types will be passed to `to_string` and can
    simply call `std::to_string` since we know that we will have one of the built-in
    floating-point types. The `to_string` assumption could fail if the user passes
    in some other type that has been created to be a `floating_point` concept type,
    but let’s keep the code as simple as it can be for now and not worry about custom
    floating-point types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有更改，以使测试再次通过。新的 `Equals` 特化版本接受任何浮点类型，并且编译器将优先选择它而不是通用 `Equals` 模板来处理浮点类型。`Equals`
    的浮点版本调用 `compareEq` 来进行比较。我们也不必担心将传递给 `to_string` 的类型，因为我们知道我们将有一个内置的浮点类型。如果用户传递了一个其他类型，该类型已被创建为
    `floating_point` 概念类型，则 `to_string` 假设可能会失败，但让我们现在保持代码尽可能简单，不要担心自定义浮点类型。
- en: The next section will start by creating a solution to test for inequality instead.
    We’ll use the solution we create in the next section to modify the small floating-point
    Hamcrest tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将首先创建一个用于测试不等式的解决方案。我们将使用下一节中创建的解决方案来修改小的浮点 Hamcrest 测试。
- en: Writing custom Hamcrest matchers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义的 Hamcrest 匹配器
- en: The previous section ended with the `Equals` matcher specialized to call `compareEq`
    for floating-point types. We also modified the tests for large floating-point
    values because they could use the Hamcrest style and the `Equals` matcher.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节以将 `Equals` 匹配器特化为调用 `compareEq` 以处理浮点类型结束。我们还修改了大的浮点值测试，因为它们可以使用 Hamcrest
    风格和 `Equals` 匹配器。
- en: We left the tests for small floating-point values unchanged because those tests
    need to make sure that the actual and expected values are not equal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有改变小的浮点值测试，因为这些测试需要确保实际值和预期值不相等。
- en: We want to update the small floating-point value tests and need a way to test
    for not equal values. Maybe we could create a new matcher called `NotEquals`,
    or we could put the `not` keyword in front of the `Equals` matcher.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要更新小的浮点值测试，并需要一个方法来测试不等值。也许我们可以创建一个新的匹配器，称为 `NotEquals`，或者我们可以在 `Equals`
    匹配器前面放置 `not` 关键字。
- en: 'I’d like to avoid the need for a new matcher if possible. We don’t really need
    any new behavior—we just need to flip the results of the existing `Equals` matcher.
    Let’s try modifying the small floating-point value tests to look like this in
    `Hamcrest.cpp`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，我想避免需要一个新的匹配器。我们并不真的需要任何新的行为——我们只需要翻转现有 `Equals` 匹配器的结果。让我们尝试修改小的浮点值测试，使其在
    `Hamcrest.cpp` 中看起来像这样：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The only changes are to stop calling `compareEq` directly and to use the `CONFIRM_THAT`
    macro with the `Equals` matcher. Notice that we flip the results of the `Equals`
    matcher by placing the `not` keyword in front.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是停止直接调用 `compareEq` 并使用 `CONFIRM_THAT` 宏和 `Equals` 匹配器。注意，我们通过在前面放置 `not`
    关键字来反转 `Equals` 匹配器的结果。
- en: 'Does it build? No. We get compile errors similar to this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它能构建吗？不。我们得到了类似的编译错误：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `not` keyword in C++ is a shortcut for `operator !`. Normally with TDD,
    the next step would be to modify the code so that the tests can build. But we
    have a problem. The `not` keyword expects the class to have an `operator !` method
    or some way to cast the class to a Boolean. Either option requires that the class
    be able to generate a bool value, and that’s not how the matchers work. In order
    for a matcher to know whether the result should pass or not, it needs to know
    the `actual` value. The `confirm_that` function passes the matcher the needed
    `actual` value as an argument to the `pass` method. We can’t turn a matcher by
    itself into a bool result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的 `not` 关键字是 `operator !` 的快捷方式。通常在使用 TDD（测试驱动开发）时，下一步是修改代码以便测试可以构建。但我们遇到了一个问题。`not`
    关键字期望类有一个 `operator !` 方法或者某种将类转换为布尔值的方式。这两种选择都需要类能够生成布尔值，但这并不是匹配器的工作方式。为了使匹配器知道结果是否应该通过，它需要知道
    `actual`（实际）值。`confirm_that` 函数通过将所需的 `actual` 值作为参数传递给 `pass` 方法，将匹配器传递给 `pass`
    方法。我们不能仅仅将匹配器本身转换为布尔结果。
- en: 'We’re going to have to create a `NotEquals` matcher. While not my first preference,
    a new matcher is acceptable from a test perspective. Let’s change the tests to
    look like this instead:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不创建一个 `NotEquals` 匹配器。虽然这不是我的首选，但从测试的角度来看，一个新的匹配器是可以接受的。让我们将测试改为如下所示：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another reason that I wanted to avoid a new matcher is to avoid the need to
    specialize the new matcher as we did for the `Equals` matcher, but there is a
    way to create a matcher called `NotEquals` and base its implementation on all
    the work we did for the `Equals` matcher. All we need to do is contain the `Equals`
    matcher and flip the `pass` result, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要避免创建一个新的匹配器另一个原因是避免像为 `Equals` 匹配器所做的那样专门化新的匹配器，但有一种方法可以创建一个名为 `NotEquals`
    的匹配器，并基于我们为 `Equals` 匹配器所做的所有工作来实现它。我们只需要包含 `Equals` 匹配器并反转 `pass` 结果，如下所示：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add the `NotEquals` matcher right after all the template specializations of
    the `Equals` matcher in `Test.h`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Test.h` 中，在 `Equals` 匹配器的所有模板专门化之后添加 `NotEquals` 匹配器。
- en: The `NotEquals` matcher is a new matcher type that contains an `Equals` matcher
    for its `mExpected` data member. This will give us all the specialization we did
    for the `Equals` matcher. Whenever the `NotEquals::pass` method is called, we
    just call the `mExpected.pass` method and flip the result. And whenever the `to_string`
    method is called, we just add `"not "` to whichever string `mExpected` provides.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotEquals` 匹配器是一个包含 `Equals` 匹配器作为其 `mExpected` 数据成员的新匹配器类型。这将给我们所有为 `Equals`
    匹配器所做的专门化。每当调用 `NotEquals::pass` 方法时，我们只需调用 `mExpected.pass` 方法并反转结果。每当调用 `to_string`
    方法时，我们只需将 `"not "` 添加到 `mExpected` 提供的任何字符串中。'
- en: One interesting thing to notice is that the `pass` method is itself a template
    based on a type `U`. This will let us construct a `NotEquals` matcher given a
    string literal and then call the `pass` method with `std::string`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的现象是，`pass` 方法本身就是一个基于类型 `U` 的模板。这将使我们能够根据一个字符串字面量构建一个 `NotEquals` 匹配器，然后使用
    `std::string` 调用 `pass` 方法。
- en: 'We should add a test for using the NotEquals matcher with a string literal
    and std::string or, even better, to extend an existing test. We have two tests
    already that work with strings, string literals, and char pointers. Both tests
    are in `Hamcrest.cpp`. The first test should look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加一个测试来使用 `NotEquals` 匹配器与字符串字面量和 `std::string`，或者更好的是，扩展现有的测试。我们已经有两个测试与字符串、字符串字面量和字符指针一起工作。这两个测试都在
    `Hamcrest.cpp` 中。第一个测试应该看起来像这样：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the second test should be modified to look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试应该修改为如下所示：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Building and running the test application shows that all the tests pass. Instead
    of adding new tests, we were able to modify the existing tests because the two
    existing tests were focused on the string and char pointer types. The `NotEquals`
    matcher fit right into the existing tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行测试应用程序显示所有测试都通过了。我们没有添加新的测试，而是能够修改现有的测试，因为这两个现有的测试都集中在字符串和字符指针类型上。`NotEquals`
    匹配器完美地融入了现有的测试中。
- en: 'Having both `Equals` and `NotEquals` matchers gives us more than we had with
    the classic style confirmations, and we can go further by creating another matcher.
    You can also create matchers to do whatever you want in your test projects. We’re
    going to create a new matcher in the `MereTDD` namespace but you can put yours
    in your own namespace. The matcher we’ll be creating will test to make sure that
    an integral number is even. We’ll call the matcher `IsEven`, and we can write
    a couple of tests in `Hamcrest.cpp` to look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`Equals`和`NotEquals`匹配器比经典风格的确认方式给我们提供了更多，我们可以通过创建另一个匹配器来更进一步。你还可以创建匹配器来在你的测试项目中执行任何你想要的操作。我们将在`MereTDD`命名空间中创建一个新的匹配器，但你也可以将你的匹配器放在你自己的命名空间中。我们将创建的匹配器将测试以确保一个整数是偶数。我们将称这个匹配器为`IsEven`，我们可以在`Hamcrest.cpp`中编写几个测试，如下所示：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You’ll notice something different about the `IsEven` matcher: it doesn’t require
    an expected value. The matcher only needs the actual value passed to it in order
    to confirm whether the actual value is even or not. Because there’s nothing to
    pass to the constructor when creating an `IsEven` matcher in the test, we need
    to specify the type, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`IsEven`匹配器的一个不同之处：它不需要预期的值。匹配器只需要传递给它的实际值，以确认实际值是否为偶数。因为创建测试中的`IsEven`匹配器时没有东西可以传递给构造函数，我们需要指定类型，如下所示：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second test should fail, and we’ll use the failure to get the exact error
    message so that we can turn the test into an expected failure. But we first need
    to create an `IsEven` matcher. The `IsEven` class can go in `Test.h` immediately
    after the `NotEquals` matcher, like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试应该失败，我们将利用这个失败来获取确切的错误信息，以便我们可以将测试转换为预期的失败。但首先我们需要创建一个`IsEven`匹配器。`IsEven`类可以放在`Test.h`中，紧随`NotEquals`匹配器之后，如下所示：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I wanted to show you an example of a really simple custom matcher so that you’ll
    know that they don’t all need to be complicated or have multiple template specializations.
    The `IsEven` matcher just tests the `actual` value in the `pass` method to make
    sure it’s even, and the `to_string` method returns a fixed string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你展示一个真正简单的自定义匹配器的例子，这样你就会知道它们并不都需要复杂或者有多个模板特化。`IsEven`匹配器只测试`pass`方法中的`actual`值以确保它是偶数，而`to_string`方法返回一个固定的字符串。
- en: 'Building and running shows the even value test passes while the intended failure
    test fails, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行显示，偶数值测试通过，而预期失败的测试失败，如下所示：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the error message, we can modify the even confirm failure test so that
    it will pass with an expected failure, like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有错误信息，我们可以修改偶数确认失败测试，使其以预期的失败通过，如下所示：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Building and running now shows that both tests pass. One passes successfully
    and the other passes with an expected failure, like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建和运行显示，两个测试都通过了。一个成功通过，另一个以预期的失败通过，如下所示：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That’s all there is to making custom matchers! You can make matchers for your
    own classes or add custom matchers for new behaviors. Maybe you want to verify
    that a number has only a certain number of digits, that a string begins with some
    given text prefix, or that a log message contains a certain tag. Remember how
    in [*Chapter 10*](B18567_10.xhtml#_idTextAnchor096), *The TDD Process in Depth*,
    we had to verify tags by writing to a file and then scanning the file to make
    sure the line just written contained a tag? We could have a custom matcher that
    looks for a tag instead.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是制作自定义匹配器的全部内容！你可以为你的类创建匹配器，或者为新的行为添加自定义匹配器。也许你想要验证一个数字只有一定数量的数字，一个字符串以某个给定的文本前缀开始，或者一个日志消息包含某个特定的标签。你还记得在[*第10章*](B18567_10.xhtml#_idTextAnchor096)，*深入理解TDD过程*中，我们不得不通过写入文件然后扫描文件来验证标签吗？我们可以有一个自定义匹配器来查找标签。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: One of the main benefits of the Hamcrest style confirmations is their ability
    to be extended through custom matchers. What better way to explore this ability
    than through floating-point confirmations? Because there is no single best way
    to compare floating-point values, you might need a solution that’s tuned to your
    specific needs. You learned about a good general-purpose floating-point comparison
    technique in this chapter that scales a small margin of error so that bigger floating-point
    values are allowed to differ by greater amounts as the values get bigger and still
    be considered to be equal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Hamcrest 风格确认的主要优点之一是它们可以通过自定义匹配器进行扩展。还有什么比通过浮点数确认来探索这种能力更好的方法呢？因为比较浮点值没有唯一最佳的方式，你可能需要一个针对你特定需求进行调优的解决方案。在本章中，你了解了一种良好的通用浮点数比较技术，它将小的误差范围进行缩放，使得较大的浮点值在值变大时可以允许有更大的差异，但仍被视为相等。
- en: If this general solution doesn’t meet your needs, you now know how to create
    your own matcher that will do exactly what you need.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个通用解决方案不能满足你的需求，你现在知道如何创建自己的匹配器，使其正好满足你的需求。
- en: And the ability to extend matchers doesn’t stop at floating-point values. You
    might have your own custom behavior that you need to confirm, and after reading
    this chapter, you now know how to create a custom matcher to do what you need.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而扩展匹配器的功能并不仅限于浮点值。你可能有自己的自定义行为需要确认，在阅读本章之后，你现在知道如何创建一个自定义匹配器来完成你所需要的工作。
- en: Not all matchers need to be big and complicated and have multiple template specializations.
    You saw an example of a very simple custom matcher that confirms whether a number
    is even or not.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有匹配器都需要庞大且复杂，以及拥有多个模板特化。你看到了一个非常简单的自定义匹配器的例子，它确认一个数字是否为偶数。
- en: We also made good use of the concepts feature, new in C++20, which allows you
    to easily specify requirements on your template types. We made good use of concepts
    in this chapter to make sure that the floating-point matcher only works for floating-point
    types and that the `IsEven` matcher only works for integral types. You can use
    concepts in your matchers too, which will help you control how your matchers can
    be used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还很好地利用了 C++20 中新引入的概念特性，该特性允许你轻松地指定对模板类型的约束。我们在本章中很好地利用了概念，以确保浮点数匹配器仅适用于浮点类型，并且
    `IsEven` 匹配器仅适用于整型类型。你同样可以在你的匹配器中使用概念，这有助于你控制匹配器的使用方式。
- en: The next chapter will explore how to test services and will introduce a new
    service project that uses all the code developed so far in this book.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨如何测试服务，并介绍一个使用本书迄今为止开发的所有代码的新服务项目。
