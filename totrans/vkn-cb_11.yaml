- en: Lighting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Rendering a geometry with a vertex diffuse lighting
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点漫反射光照渲染几何
- en: Rendering a geometry with a fragment specular lighting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用片段镜面光照渲染几何
- en: Rendering a normal mapped geometry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染法线贴图几何
- en: Drawing a reflective and refractive geometry using cubemaps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用立方体贴图绘制反射和折射几何
- en: Adding shadows to the scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加阴影
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Lighting is one of the most important factors influencing the way we perceive
    everything that surrounds us. Most of the information our brains gather about
    the world comes from our eyes. Human sight is very sensitive to even the slightest
    change in lighting conditions. That's why lighting is also very important for
    creators of 3D applications, games, and movies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 光照是我们感知周围一切的重要因素之一。我们的大脑从世界中收集的大部分信息都来自我们的眼睛。人类的视觉对光照条件的最轻微变化都非常敏感。这就是为什么光照对于3D应用程序、游戏和电影的制作者来说也非常重要。
- en: 'In the times when 3D graphics libraries supported only a fixed-function pipeline,
    lighting calculations were performed according to a predefined set of rules--developers
    could only select colors for a light source and a lit object. This led most games
    and applications that used a given library to have a similar look and feel. The
    next step in the evolution of graphics hardware was the introduction of fragment
    shaders: their main purpose was to calculate the final color of a fragment (pixel).
    Fragment shaders literally shaded the geometry, so the name shader was a natural
    choice. Their main advantage was that they were programmable. They could perform
    not only lighting calculations, but also realize almost any other algorithm. Nowadays,
    graphics hardware is much more sophisticated. There are other types of programmable
    parts of graphics hardware which have also adopted the term shaders for their
    names. There are many different algorithms and approaches which all use shaders
    to display interesting images in games, 3D applications, and movies. The basic
    purpose of shader programs is still very important even today--lighting calculations
    must be performed if we want to achieve interesting, eye-catching results.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D图形库仅支持固定功能管道的时代，光照计算是根据预定义的规则进行的--开发者只能选择光源和被照物体的颜色。这导致大多数使用给定库的游戏和应用看起来和感觉都相似。图形硬件演化的下一步是引入片段着色器：它们的主要目的是计算片段（像素）的最终颜色。片段着色器实际上着色了几何形状，因此着色器的名字是一个自然的选择。它们的主要优势是可编程。它们不仅可以执行光照计算，还可以实现几乎任何其他算法。如今，图形硬件要复杂得多。还有其他类型的可编程图形硬件部分，它们也采用了着色器的名称。有许多不同的算法和方法，它们都使用着色器在游戏、3D应用程序和电影中显示有趣的图像。着色器程序的基本目的即使在今天仍然非常重要--如果我们想要实现有趣、引人注目的结果，就必须执行光照计算。
- en: In this chapter, we will learn about commonly used lighting techniques from
    simple object diffuse lighting calculations, to a shadow mapping algorithm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习从简单的物体漫反射光照计算到阴影映射算法的常用光照技术。
- en: Rendering a geometry with a vertex diffuse lighting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点漫反射光照渲染几何
- en: A basic diffuse lighting algorithm lies at the core of most lighting calculations.
    It is used to simulate the appearance of matte surfaces that reflect the light,
    scattering it in many different directions. In this recipe, we will see how to
    achieve geometry rendering using vertex and fragment shaders that implement the
    diffuse lighting algorithm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的漫反射光照算法是大多数光照计算的核心。它用于模拟漫反射表面反射光线，并向许多不同方向散射。在本例中，我们将看到如何使用实现漫反射光照算法的顶点和片段着色器来渲染几何形状。
- en: 'An example of an image generated with this recipe looks like the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法生成的图像示例如下：
- en: '![](img/image_11_001.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_001.png)'
- en: The following recipe is very detailed so that you can understand and follow
    all the steps more easily. Further recipes will be based on the knowledge described
    here, so they are shorter but also more general.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱非常详细，以便您可以更容易地理解和跟随所有步骤。后续食谱将基于这里描述的知识，因此它们更短，但也更通用。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Diffuse lighting is based on a **cosine law** introduced by **Johann Heinrich
    Lambert**. It says that the lighting intensity of an observed surface is proportional
    to the cosine of the angle between the direction from the surface to the source
    of light (a light vector) and the surface normal vector:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射光照是基于由**约翰·海因里希·拉姆伯特**提出的**余弦定律**。它表明，观察到的表面光照强度与从表面到光源方向（光向量）与表面法线向量的夹角的余弦成正比：
- en: '![](img/image_11_002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_002.png)'
- en: 'This law is easily implemented inside shaders. Normal vectors are provided
    from the application as one of the vertex attributes. The positions of all vertices
    are also known, so we only need to provide a light direction or the position of
    a light source to calculate the light vector inside shaders. Both normal and light
    vectors must be normalized (both must have a length equal to `1.0`). The next
    step is to calculate a cosine of the angle between these two vectors. This is
    done with a single `dot()` function like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定律可以在着色器中轻松实现。法线向量作为顶点属性之一由应用程序提供。所有顶点的位置也是已知的，所以我们只需要提供一个光方向或光源的位置来在着色器内部计算光向量。正常向量和光向量都必须归一化（两者都必须长度等于`1.0`）。下一步是计算这两个向量之间角度的余弦值。这可以通过一个`dot()`函数来完成，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We must remember that a cosine can give negative results. This happens when
    we calculate lighting for points on a surface that point in the opposite direction
    to a light source. Such points cannot be lit by a given light source (they are
    in shadow from the perspective of a given light source), so we must disregard
    such results and clamp them to the `0` value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，余弦函数可以给出负值。这种情况发生在我们计算指向光源相反方向表面上的点光照时。这样的点不能被给定光源照亮（它们从给定光源的角度看处于阴影中），因此我们必须忽略这样的结果并将它们夹到`0`值。
- en: In all the following recipes we will use objects of a `VkDestroyer` class, which
    allow us to automatically destroy Vulkan resources. For convenience, a `InitVkDestroyer()`
    function is also introduced. Its purpose is to wrap a given resource in the `VkDestroyer`
    object and connect it to a created logical device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有后续的配方中，我们将使用`VkDestroyer`类的对象，这允许我们自动销毁 Vulkan 资源。为了方便，还引入了一个`InitVkDestroyer()`函数。它的目的是将给定的资源包装在`VkDestroyer`对象中，并将其连接到创建的逻辑设备。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a Vulkan instance and a logical device with a set of enabled swapchain
    extensions. Also store the handle of a physical device from which the logical
    device was created (refer to the *Creating a Vulkan Instance with WSI extensions
    enabled* and *Creating a logical device with WSI extensions enabled* recipes from
    [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一组启用的交换链扩展创建一个 Vulkan 实例和一个逻辑设备。同时存储从其中创建逻辑设备的物理设备的句柄（参考[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*启用
    WSI 扩展创建 Vulkan 实例*和*启用 WSI 扩展创建逻辑设备*配方）。
- en: Acquire handles of graphics and presentation queues from the logical device
    (refer to the *Getting a device queue* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从逻辑设备获取图形和呈现队列的句柄（参考[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)，*实例和设备*中的*获取设备队列*配方）。
- en: Create a swapchain with a desired set of parameters. Store the swapchain's size
    (image dimensions) and format (refer to the *Creating a swapchain with R8G8B8A8
    format and a MAILBOX present mode* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一组期望的参数创建一个交换链。存储交换链的大小（图像维度）和格式（参考[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*使用
    R8G8B8A8 格式和存在 MAILBOX 呈现模式的交换链创建*配方）。
- en: Get handles of all swapchain images (refer to the *Getting handles of swapchain
    images* recipe from [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image
    Presentation*).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有交换链图像的句柄（参考[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*获取交换链图像句柄*配方）。
- en: Create image views for all swapchain images (refer to the *Creating an image
    view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有交换链图像创建图像视图（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建图像视图*配方）。
- en: Create a set of resources required to generate frames of animation--command
    pool and command buffers, semaphores (at least two for acquiring a swapchain image
    and to indicate when a frame rendering is finished, which is required during swapchain
    image presentation), fences and framebuffers. Create at least one such set, but
    more can be created if we want to render more frames separately (refer to the
    *Increasing the performance through increasing the number of separately rendered
    frames* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command
    Recording and Drawing*).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组用于生成动画帧所需的资源——命令池和命令缓冲区、信号量（至少两个用于获取交换链图像和指示帧渲染完成，这在交换链图像呈现期间是必需的）、栅栏和帧缓冲区。至少创建一个这样的集合，但如果我们想分别渲染更多帧，则可以创建更多（请参阅[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*）中的*通过增加单独渲染的帧数来提高性能*配方）。
- en: Load a 3D model data with vertex positions and normal vectors into a variable
    of type `Mesh` named `Model` (refer to the *Loading a 3D model from an OBJ file*
    recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper
    Recipes*).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具有顶点位置和法向量的3D模型数据加载到名为`Model`的`Mesh`类型变量中（请参阅[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*）中的*从OBJ文件加载3D模型*配方）。
- en: Create a buffer that will serve as a vertex buffer and will support `VK_BUFFER_USAGE_TRANSFER_DST_BIT`
    and `VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` usages (refer to the *Creating a buffer
    recipe* from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将作为顶点缓冲区并支持`VK_BUFFER_USAGE_TRANSFER_DST_BIT`和`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT`用法的缓冲区（请参阅[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）中的*创建缓冲区配方*）。
- en: Allocate a memory object with a `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` property
    and bind it to the vertex buffer (refer to the *Allocating and binding memory
    object to a buffer* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个具有`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`属性的内存对象并将其绑定到顶点缓冲区（请参阅[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）中的*分配和绑定内存对象到缓冲区*配方）。
- en: Copy vertex data from the `Data` member of the `Model` variable into the vertex
    buffer using a staging buffer (refer to the *Using staging buffer to update buffer
    with a device-local memory bound* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用中间缓冲区将`Model`变量的`Data`成员中的顶点数据复制到顶点缓冲区（请参阅[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）中的*使用中间缓冲区更新绑定到设备本地内存的缓冲区*配方）。
- en: Create a uniform buffer with `VK_BUFFER_USAGE_TRANSFER_DST_BIT` and `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`
    usages that is big enough to hold data for two 16-element matrices of floating-point
    values (refer to the *Creating a uniform buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`VK_BUFFER_USAGE_TRANSFER_DST_BIT`和`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`用法的统一缓冲区，其大小足以容纳两个16元素浮点值矩阵的数据（请参阅[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）中的*创建统一缓冲区*配方）。
- en: Create a descriptor set layout with only one uniform buffer accessed by a vertex
    shader stage (refer to the *Creating a descriptor set layout* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符集布局，其中只有一个由顶点着色器阶段访问的统一缓冲区（请参阅[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）中的*创建描述符集布局*配方）。
- en: Create a descriptor pool from which a descriptor for one uniform buffer can
    be allocated (refer to the *Creating a descriptor pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从描述符池中创建一个描述符，该描述符可以分配一个统一缓冲区（请参阅[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）中的*创建描述符池*配方）。
- en: Allocate a descriptor set from the created pool using the prepared layout (refer
    to *Allocating descriptor sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用已准备的布局从创建的池中分配一个描述符集（请参阅[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）中的*分配描述符集*配方）。
- en: Update the descriptor set with the uniform buffer's handle (refer to the *Updating
    descriptor sets* recipes from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用统一缓冲区的句柄更新描述符集（请参阅[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）中的*更新描述符集*配方）。
- en: 'Prepare parameters for a render pass creation. First, specify descriptions
    of two attachments (refer to the *Specifying attachments descriptions* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备渲染通道创建的参数。首先，指定两个附加文件的描述（参考第6章中的*指定附加文件描述*配方，*渲染通道和帧缓冲区*）：
- en: The first attachment should have the same format as the swapchain images. It
    should be cleared on a render pass start and its contents should be stored at
    the end of the render pass. Its initial layout can be undefined, but a final layout
    must be a `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个附加文件应与swapchain图像具有相同的格式。它应在渲染通道开始时清除，并在渲染通道结束时存储其内容。其初始布局可以是未定义的，但最终布局必须为`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`。
- en: The second attachment should have one of the supported depth formats (`VK_FORMAT_D16_UNORM`
    format must always be supported, and at least one of `VK_FORMAT_X8_D24_UNORM_PACK32`
    or `VK_FORMAT_D32_SFLOAT` must be supported). It must be cleared on the render
    pass start, but its contents don't need to be preserved after the render pass.
    Its initial layout may be undefined and the final layout should be the same as
    a layout specified in a subpass (to avoid unnecessary layout transitions).
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个附加文件应具有支持的深度格式之一（`VK_FORMAT_D16_UNORM`格式必须始终支持，并且至少支持`VK_FORMAT_X8_D24_UNORM_PACK32`或`VK_FORMAT_D32_SFLOAT`中的一个）。它必须在渲染通道开始时清除，但渲染通道之后不需要保留其内容。其初始布局可能是未定义的，最终布局应与子通道中指定的布局相同（以避免不必要的布局转换）。
- en: Specify one subpass for the render pass, in which the first render pass attachment
    will be provided as a color attachment with a `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
    layout, and the second attachment will be used as a depth attachment with a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`
    layout (refer to the *Specifying subpass descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为渲染通道指定一个子通道，其中第一个渲染通道附加文件将作为具有`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`布局的颜色附加文件提供，第二个附加文件将用作具有`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`布局的深度附加文件（参考第6章中的*指定子通道描述*配方，*渲染通道和帧缓冲区*）。
- en: 'Specify two subpass dependencies for the render pass (refer to the *Specifying
    dependencies between subpasses* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*). Use the following values for the first dependency:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为渲染通道指定两个子通道依赖项（参考第6章中的*指定子通道之间的依赖项*配方，*渲染通道和帧缓冲区*）。第一个依赖项使用以下值：
- en: '`VK_SUBPASS_EXTERNAL` value for `srcSubpass`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcSubpass`的`VK_SUBPASS_EXTERNAL`值'
- en: '`0` value for `dstSubpass`'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstSubpass`的`0`值'
- en: '`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` value for `srcStageMask`'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcStageMask`的`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT`值'
- en: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `dstStageMask`'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstStageMask`的`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`值'
- en: '`VK_ACCESS_MEMORY_READ_BIT` value for `srcAccessMask`'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcAccessMask`的`VK_ACCESS_MEMORY_READ_BIT`值'
- en: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `dstAccessMask`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstAccessMask`的`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`值'
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencyFlags`的`VK_DEPENDENCY_BY_REGION_BIT`值'
- en: 'Use the following values for the second render pass dependency:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个渲染通道依赖项使用以下值：
- en: '`0` value for `srcSubpass`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcSubpass`的`0`值'
- en: '`VK_SUBPASS_EXTERNAL` value for `dstSubpass`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstSubpass`的`VK_SUBPASS_EXTERNAL`值'
- en: '`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` value for `srcStageMask`'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcStageMask`的`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`值'
- en: '`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` value for `dstStageMask`'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstStageMask`的`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT`值'
- en: '`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` value for `srcAccessMask`'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcAccessMask`的`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`值'
- en: '`VK_ACCESS_MEMORY_READ_BIT` value for `dstAccessMask`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dstAccessMask`的`VK_ACCESS_MEMORY_READ_BIT`值'
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencyFlags`的`VK_DEPENDENCY_BY_REGION_BIT`值'
- en: Create the render pass using the prepared parameters (refer to the *Creating
    a render pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用准备好的参数创建渲染通道（参考第6章中的*创建渲染通道*配方，*渲染通道和帧缓冲区*）。
- en: Create a pipeline layout using the prepared descriptor set layout with only
    a uniform buffer (refer to the *Creating a pipeline layout* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用仅包含统一缓冲区的已准备描述符集布局创建管线布局（请参阅第 8 章 *创建管线布局* 的配方，*图形和计算管线*）。
- en: 'Create a shader module for a vertex shader stage using a SPIR-V assembly generated
    from the following GLSL code (refer to the *Converting GLSL shaders to SPIR-V
    assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to the *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下 GLSL 代码生成的 SPIR-V 代码创建一个用于顶点着色器阶段的着色器模块（请参阅第 7 章 *将 GLSL 着色器转换为 SPIR-V
    代码* 的配方，*着色器*，以及第 8 章 *创建着色器模块* 的配方，*图形和计算管线*）。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下 GLSL 代码生成的 SPIR-V 代码创建一个用于片段着色器阶段的着色器模块：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from respective shader modules (refer to the *Specifying pipeline
    shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器指定管线着色器阶段，两者都使用各自着色器模块中的 `main` 函数（请参阅第 8 章 *指定管线着色器阶段* 的配方，*图形和计算管线*）。
- en: 'Specify a pipeline vertex input state with two attributes that are read from
    the same 0 binding. Binding should be created with data read per vertex and a
    stride equal to `6 * sizeof( float )` (refer to the *Specifying pipeline vertex
    input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). The first attribute should have the following
    parameters:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定管线顶点输入状态，包含两个从同一 0 绑定读取的属性。绑定应使用每个顶点读取的数据创建，步长等于 `6 * sizeof( float )`（请参阅第
    8 章 *指定管线顶点输入状态* 的配方，*图形和计算管线*）。第一个属性应具有以下参数：
- en: '`0` value for `location`'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location` 的值为 `0`。'
- en: '`0` value for `binding`'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding` 的值为 `0`。'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的值为 `VK_FORMAT_R32G32B32_SFLOAT`。'
- en: '`0` value for `offset`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `0`。'
- en: 'The second vertex attribute should be specified using the following values:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个顶点属性应使用以下值指定：
- en: '`1` value for `location`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location` 的值为 `1`。'
- en: '`0` value for `binding`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding` 的值为 `0`。'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的值为 `VK_FORMAT_R32G32B32_SFLOAT`。'
- en: '`3 * sizeof( float)` value for `offset`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `3 * sizeof( float)`。'
- en: Specify a pipeline input assembly state with a `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`
    topology and without primitive restart (refer to the *Specifying pipeline input
    assembly state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定管线输入装配状态，具有 `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST` 顶点类型和没有原语重启（请参阅第 8 章 *指定管线输入装配状态*
    的配方，*图形和计算管线*）。
- en: Specify a pipeline viewport and scissor test state with only one viewport and
    scissor test state. Initial values don't matter as they will be set dynamically
    (refer to the *Specifying pipeline viewport and scissor test state* recipe from
    [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用一个视口和裁剪测试状态指定管线视口和裁剪测试状态。初始值不重要，因为它们将被动态设置（请参阅第 8 章 *指定管线视口和裁剪测试状态* 的配方，*图形和计算管线*）。
- en: Specify a pipeline rasterization state without depth clamp, with no rasterization
    discard, with a `VK_POLYGON_MODE_FILL``,` `VK_CULL_MODE_BACK_BIT` and `VK_FRONT_FACE_COUNTER_CLOCKWISE`,
    without a depth bias and with line widths of `1.0f` (refer to the *Specifying
    pipeline rasterization state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无深度裁剪、无光栅化丢弃、`VK_POLYGON_MODE_FILL`、`VK_CULL_MODE_BACK_BIT` 和 `VK_FRONT_FACE_COUNTER_CLOCKWISE`，无深度偏差以及线宽为
    `1.0f` 的光栅化状态指定管线（请参阅第 8 章 *指定管线光栅化状态* 的配方，*图形和计算管线*）。
- en: Specify a pipeline multisample state with only a single sample and without sample
    shading, sample masks, alpha to coverage, or alpha to one (refer to the *Specifying
    pipeline multisample state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个仅包含单个样本且无样本阴影、样本掩码、alpha到覆盖或alpha到一的管线多采样状态（参考第8章中“指定管线多采样状态”的配方，*图形和计算管线*）。
- en: Specify a pipeline depth state with a depth test and depth writes enabled, with
    a `VK_COMPARE_OP_LESS_OR_EQUAL` operator and without depth bounds or stencil tests
    (refer to the *Specifying pipeline depth and stencil state* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个具有深度测试和深度写入启用的管线深度状态，使用`VK_COMPARE_OP_LESS_OR_EQUAL`运算符，且无深度界限或模板测试（参考第8章中“指定管线深度和模板状态”的配方，*图形和计算管线*）。
- en: Specify a pipeline blend state with both logical operations and blending disabled
    (refer to the *Specifying pipeline blend state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个具有逻辑运算和混合禁用的管线混合状态（参考第8章中“指定管线混合状态”的配方，*图形和计算管线*）。
- en: Specify the viewport and scissor test as dynamic states of a pipeline (refer
    to the *Specifying pipeline dynamic states* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视口和裁剪测试指定为管线的动态状态（参考第8章中“指定管线动态状态”的配方，*图形和计算管线*）。
- en: Create a graphics pipeline using the prepared parameters (refer to the *Creating
    graphics pipelines* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用准备好的参数创建图形管线（参考第8章中“创建图形管线”的配方，*图形和计算管线*）。
- en: Create a staging buffer supporting a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage,
    which can hold data of two matrices, each with 16 floating-point elements. The
    buffer's memory object should be allocated on a memory that is host-visible (refer
    to the *Creating a buffer* and *Allocating and binding memory object to a buffer*
    recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个支持`VK_BUFFER_USAGE_TRANSFER_SRC_BIT`使用的staging buffer，可以容纳两个矩阵的数据，每个矩阵包含16个浮点元素。该缓冲区的内存对象应在主机可见的内存上分配（参考第4章中“创建缓冲区”和“分配和绑定内存对象到缓冲区”的配方，*资源和内存*）。
- en: Create a 2D image (with an appropriate memory object) and an image view with
    the same format as the render pass's depth attachment, with the same size as the
    size of swapchain images, with one mipmap level and array layer. The image must
    support a `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` usage (refer to the *Creating
    a 2D image and view* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*). Remember that these resources (along with the swapchain)
    must be recreated each time the application's window is resized.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个2D图像（使用适当的内存对象）和一个与渲染通道深度附加相同格式的图像视图，大小与swapchain图像相同，包含一个mipmap级别和数组层。该图像必须支持`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`使用（参考第4章中“创建2D图像和视图”的配方，*资源和内存*）。记住，这些资源（连同swapchain）必须在应用程序窗口大小调整时重新创建。
- en: Prepare a model matrix, which can be a multiplication of rotation, scaling and
    translation matrices (refer to the *Preparing a translation matrix*, *Preparing
    a rotation matrix* and *Preparing a scaling matrix* recipes from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*). Copy the contents of the concatenated matrix to the staging
    buffer at a `0` offset (refer to the *Mapping, updating and unmapping host-visible
    memory* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个模型矩阵，它可以是一个旋转、缩放和变换矩阵的乘积（参考第10章中“准备变换矩阵”、“准备旋转矩阵”和“准备缩放矩阵”的配方，*辅助配方*）。将连接矩阵的内容复制到偏移量为`0`的staging
    buffer中（参考第4章中“映射、更新和取消映射主机可见内存”的配方，*资源和内存*）。
- en: Prepare a perspective projection matrix based on the aspect ratio of swapchain's
    dimensions (refer to the *Preparing a perspective projection matrix recipe* from
    [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*). Copy
    contents of the matrix to the staging buffer at an offset equal to the number
    of elements in the model matrix (16) multiplied by the size of a single element
    (`sizeof(float)`). Remember to recreate the projection matrix and copy it to the
    staging buffer each time the application's window is resized (refer to *Mapping,
    updating and unmapping host-visible memory* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据swapchain尺寸的纵横比准备透视投影矩阵（参考第10章中“准备透视投影矩阵配方”的配方[Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*）。将矩阵的内容复制到阶段缓冲区，偏移量等于模型矩阵元素数量（16）乘以单个元素的大小（`sizeof(float)`）。记住，每次应用程序窗口大小改变时，都要重新创建投影矩阵并将其复制到阶段缓冲区（参考第4章中“映射、更新和取消映射主机可见内存”的配方[Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）。
- en: Inside a rendering loop, for each loop iteration, prepare a frame of animation
    by acquiring one of the swapchain images, creating a framebuffer with the acquired
    swapchain image and the image serving as a depth attachment, recording the command
    buffer as described below, submitting it to the graphics queue and presenting
    the acquired image (refer to the *Preparing a single frame of animation* recipe
    from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染循环内部，对于每次循环迭代，通过获取swapchain图像之一，创建一个包含获取的swapchain图像和作为深度附加图像的framebuffer，记录下以下所述的命令缓冲区，将其提交到图形队列，并展示获取到的图像（参考第9章中“准备单个动画帧”的配方[Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘图*）。
- en: 'To record the command buffer:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要记录命令缓冲区：
- en: Begin recording the command buffer specifying a `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`
    usage (refer to the *Beginning a command buffer recording operation* recipe from
    [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and
    Synchronization*).
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始记录命令缓冲区，指定`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`使用（参考第3章中“开始命令缓冲区记录操作”的配方[Chapter
    3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*）。
- en: If the staging buffer has been updated since the last frame, set a buffer memory
    barrier for the uniform buffer to inform the driver that the buffer's memory will
    be accessed in a different way, copy data from the staging buffer to the uniform
    buffer, and set up another buffer memory barrier (refer to the *Setting a buffer
    memory barrier* and *Copying data between buffers* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果阶段缓冲区自上一帧以来已被更新，为统一缓冲区设置缓冲区内存屏障，通知驱动器该缓冲区的内存将以不同的方式被访问，从阶段缓冲区复制数据到统一缓冲区，并设置另一个缓冲区内存屏障（参考第4章中“设置缓冲区内存屏障”和“在缓冲区之间复制数据”的配方[Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）。
- en: When graphics and presentation queues are different, transform the ownership
    for the acquired swapchain image from the presentation queue to the graphics queue
    using an image memory barrier (refer to the *Setting an image memory barrier*
    from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图形和呈现队列不同时，使用图像内存屏障将获取到的swapchain图像的所有权从呈现队列转换到图形队列（参考第4章中“设置图像内存屏障”的配方[Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）。
- en: Begin the render pass (refer to the *Beginning a render pass* recipe from [Chapter
    6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and Framebuffers*).
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始渲染通道（参考第6章中“开始渲染通道”的配方[Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*）。
- en: Set the viewport and scissor test states dynamically providing the current swapchain
    dimensions (refer to the *Setting viewport state dynamically* and *Setting scissors
    state dynamically* recipes from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态设置视口和裁剪测试状态，提供当前swapchain的尺寸（参考第9章中“动态设置视口状态”和“动态设置裁剪状态”的配方[Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘图*）。
- en: Bind the vertex buffer to the `0` binding (refer to the *Binding vertex buffers*
    recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command
    Recording and Drawing*).
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶点缓冲区绑定到`0`绑定（参考第9章中“绑定顶点缓冲区”的配方[Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘图*）。
- en: Bind the descriptor set to the `0` index (refer to the *Binding descriptor sets*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将描述符集绑定到`0`索引（参考第5章的*绑定描述符集*配方，*描述符集*）。
- en: Bind the graphics pipeline (refer to the *Binding a pipeline object* recipe
    from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定图形管线（参考第8章的*绑定管线对象*配方，*图形和计算管线*）。
- en: Draw the model geometry (refer to the *Drawing a geometry* recipe from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制模型几何形状（参考第9章的*绘制几何形状*配方，*命令记录和绘制*）。
- en: End the render pass (refer to the *Ending a render pass* recipe from [Chapter
    6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and Framebuffers*).
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束渲染通道（参考第6章的*结束渲染通道*配方，*渲染通道和帧缓冲区*）。
- en: If the graphics and presentation queues are different, transform the ownership
    for the acquired swapchain image from the graphics queue to the presentation queue
    using an image memory barrier (refer to the *Setting an image memory barrier*
    from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图形和呈现队列不同，使用图像内存屏障将获取的交换链图像的所有权从图形队列转换为呈现队列（参考第4章的*设置图像内存屏障*，*资源和内存*）。
- en: End the command buffer's recording operation (refer to the *Ending a command
    buffer recording operation* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束命令缓冲区的记录操作（参考第3章的*结束命令缓冲区记录操作*配方，*命令缓冲区和同步*）。
- en: To increase the performance of an application, prepare multiple animation frames
    using separate sets of resources (refer to the *Increasing the performance through
    increasing the number of separately rendered frames* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提高应用程序的性能，使用不同的资源集准备多个动画帧（参考第9章的*通过增加单独渲染帧的数量来提高性能*配方，*命令记录和绘制*）。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Assume we have created a Vulkan Instance and a logical device with enabled WSI
    extensions. We also created a swapchain object (the full source code for these
    operations can be found in the accompanying code samples).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经创建了一个Vulkan实例和一个启用了WSI扩展的逻辑设备。我们还创建了一个交换链对象（这些操作的完整源代码可以在附带的代码示例中找到）。
- en: 'To render any geometry, we need to first load a 3D model. Its data needs to
    be copied to a vertex buffer, so we also need to create a vertex buffer, allocate
    and bind a memory to it, and we need to copy the model data using a staging buffer:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染任何几何形状，我们首先需要加载一个3D模型。其数据需要复制到顶点缓冲区中，因此我们还需要创建一个顶点缓冲区，为其分配和绑定内存，并需要使用阶段缓冲区来复制模型数据：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, a uniform buffer is required. Using the uniform buffer we will provide
    transformation matrices to the shaders:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要一个统一缓冲区。我们将使用统一缓冲区向着色器提供变换矩阵：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The uniform buffer will be accessed in a vertex shader. For this purpose, we
    need a descriptor set layout, a descriptor pool, and a single descriptor set,
    which will be updated (populated) with the created uniform buffer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 统一缓冲区将在顶点着色器中被访问。为此，我们需要一个描述符集布局、一个描述符池和一个单独的描述符集，该描述符集将更新（填充）以创建统一缓冲区：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Rendering operations can only be performed inside render passes. We need a
    render pass with two attachments: the first is a swapchain image; and second is
    an image created by us that will serve as a depth attachment. As we will render
    only a single model without any postprocessing techniques, it is enough for the
    render pass to have just one subpass.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染操作只能在渲染通道内执行。我们需要一个具有两个附件的渲染通道：第一个是一个交换链图像；第二个是我们创建的图像，它将作为深度附件。由于我们将只渲染一个模型而不使用任何后处理技术，渲染通道只需要一个子通道就足够了。
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also need a staging buffer. It will be used to transfer data from the application
    to the uniform buffer:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个阶段缓冲区。它将被用来从应用程序传输数据到统一缓冲区：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before we can render a frame, we need to do one last thing: create a graphics
    pipeline. As the code required to create one is pretty straightforward, we will
    skip it (it can be seen in the code samples accompanying this book).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以渲染一个帧之前，我们需要做最后一件事：创建一个图形管线。由于创建它的代码相当直接，我们将跳过它（可以在本书附带的代码示例中看到）。
- en: 'To see the model, we need to prepare model and projection matrices. A model
    matrix is used to place a model in a virtual world--it can be moved, scaled, or
    rotated. Such a matrix is usually combined with a view matrix, which is used to
    move a camera in our scene. Here, for simplicity, we won''t use a view transformation;
    but we still need a projection matrix. Because the values in the projection matrix
    depend on the framebuffer''s aspect ratio (in this case the size of the application''s
    window), it must be recomputed every time the application window''s dimensions
    are changed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到模型，我们需要准备模型和投影矩阵。模型矩阵用于将模型放置在虚拟世界中--它可以移动、缩放或旋转。这样的矩阵通常与视图矩阵结合使用，视图矩阵用于在场景中移动相机。在这里，为了简单起见，我们不会使用视图变换；但我们仍然需要一个投影矩阵。因为投影矩阵中的值取决于帧缓冲区的纵横比（在这种情况下是应用程序窗口的大小），所以每次应用程序窗口的尺寸改变时都必须重新计算：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, the last thing we need to do is to prepare an animation frame. This
    is usually performed inside a rendering loop, where for each loop iteration a
    separate (new) frame is rendered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要做的最后一件事是准备一个动画帧。这通常在渲染循环内部进行，其中对于每个循环迭代都会渲染一个单独的新帧。
- en: 'First, we need to check if the uniform buffer''s contents need to be updated
    and whether the data needs to be copied from the staging buffer to the uniform
    buffer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查统一缓冲区的内容是否需要更新，以及数据是否需要从阶段缓冲区复制到统一缓冲区：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we transfer queue ownership for swapchain images (in a situation when
    graphics and present queues are different). After that, we start the render pass
    and set up all the states required to render a geometry: we set viewport and scissor
    test states, bind the vertex buffer, descriptor set and the graphics pipeline.
    After that, the geometry is drawn and the render pass is finished. Once again,
    we need to transfer the queue ownership back to the presentation queue (if the
    graphics queue is different) and we stop recording the command buffer. Now it
    can be submitted to the queue:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转移交换链图像的队列所有权（在图形和呈现队列不同的情况下）。然后，我们开始渲染通道并设置渲染几何形状所需的所有状态：我们设置视口和剪裁测试状态，绑定顶点缓冲区、描述符集和图形管线。之后，绘制几何形状并完成渲染通道。再次，我们需要将队列所有权转回到呈现队列（如果图形队列不同）并停止记录命令缓冲区。现在它可以提交到队列：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we prepare the preceding frame, normal vectors and vertex positions are
    automatically fetched from the vertex buffer. Positions are used, not only to
    display a geometry, but along with the normal vectors, they are also used for
    lighting calculations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备前一个帧时，法向量和顶点位置会自动从顶点缓冲区获取。位置不仅用于显示几何形状，而且与法向量一起，它们也用于光照计算。
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For simplicity, the light vector is hardcoded in the vertex shader, but normally
    it should be provided using a uniform buffer or a push constant. In this case,
    the light vector always points in the same direction (for all vertices), so it
    simulates a directional light, which usually represents the sun.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，光向量在顶点着色器中是硬编码的，但通常它应该通过统一缓冲区或推送常量来提供。在这种情况下，光向量始终指向同一方向（对于所有顶点），因此它模拟了方向性光源，这通常代表太阳。
- en: In the preceding code, all lighting calculations are performed in the view space.
    We can perform such calculations in any coordinate system we want, but all vectors
    (normal, light vectors, view vectors, and so on) must be transformed to the same
    space in order for the calculations to be correct.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，所有光照计算都是在视图空间中进行的。我们可以在任何我们想要的坐标系中进行这样的计算，但为了使计算正确，所有向量（法线、光向量、视图向量等）都必须转换到同一空间。
- en: After calculating the diffuse term, we also add a constant value to the calculated
    color. Usually this is referred to as ambient lighting, which is used to brighten
    up the scene (otherwise all shadows/unlit surfaces would be too dark).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算漫反射项之后，我们还向计算出的颜色中添加一个常数值。这通常被称为环境光照，用于照亮场景（否则所有阴影/未照亮的表面都会太暗）。
- en: 'Below we can see diffuse lighting calculated at each vertex applied to geometry
    with a different number of polygons: on the left, a detailed geometry (high-polygon);
    and, on the right model, with a much smaller amount of detail (low-polygon):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们可以看到在每个顶点计算的漫反射光照应用于具有不同多边形数量的几何体：左侧，详细几何体（高多边形）；右侧模型，具有较少的细节（低多边形）：
- en: '![](img/image_11_003.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_003.png)'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image Presentation*,
    see the following recipes:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*图像展示*，查看以下配方：
- en: '*Creating a Vulkan Instance with WSI extensions enabled*'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用WSI扩展启用创建Vulkan实例*'
- en: '*Creating a logical device with WSI extensions enabled*'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用WSI扩展启用创建逻辑设备*'
- en: '*Creating a swapchain with R8G8B8A8 format and a MAILBOX present mode*'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用R8G8B8A8格式和存在MAILBOX显示模式创建交换链*'
- en: In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, the recipe *Beginning a command buffer recording operation*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，配方*开始命令缓冲区录制操作*
- en: In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, the recipe *Creating graphics pipelines*
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，配方*创建图形管线*
- en: In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, the recipe *increasing the performance by increasing the number
    of separately rendered frames*
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令录制与绘制*，配方*通过增加单独渲染的帧数来提高性能*
- en: In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    the recipe* Loading a 3D model from an OBJ file*
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*，配方*从OBJ文件加载3D模型*
- en: 'The following recipes in this chapter:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Rendering a geometry with a fragment specular lighting*'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用片段镜面反射光照渲染几何体*'
- en: '*Rendering a normal mapped geometry*'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渲染法线贴图几何体*'
- en: Rendering a geometry with a fragment specular lighting
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段镜面反射光照渲染几何体
- en: Specular lighting allows us to add bright highlights or reflections on the surface
    of a model. This way rendered geometry looks shinier and more glossy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面反射光照使我们能够在模型表面添加明亮的亮点或反射。这样渲染的几何体看起来更亮、更光滑。
- en: 'An example of an image generated with this recipe looks like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配方生成的图像示例如下：
- en: '![](img/image_11_004.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_004.png)'
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The most commonly used algorithm describing the way surfaces are lit is a **Blinn-Phong**
    model. It is an empirical model, which isn't physically correct but gives results
    that are more plausible in situations where rendered geometry is simplified. So
    it is well suited for 3D real-time graphics.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 描述表面光照方式最常用的算法是**Blinn-Phong**模型。它是一个经验模型，虽然不是物理上正确的，但在渲染几何体简化的情况下给出的结果更可信。因此，它非常适合3D实时图形。
- en: 'The **Blinn-Phong** model describes light leaving a given surface as a sum
    of four components:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blinn-Phong**模型描述了从给定表面发出的光作为四个分量的总和：'
- en: '**Emissive**: The amount of light emitted by the surface'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射**：表面发出的光量'
- en: ': The amount of reflected light that is scattered around the whole scene and
    doesn''t have any visible source (used to brighten up the geometry)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ': 在整个场景中散射的反射光量，没有明显的光源（用于照亮几何体）'
- en: 'Ambient: The amount of reflected light that is scattered around the whole scene
    and doesn''t have any visible source (used to brighten up the geometry) Diffuse:
    Describes the light reflected by rough surfaces (based on the Lambert lighting
    equation)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光：在整个场景中散射的反射光量，没有明显的光源（用于照亮几何体）漫反射：描述粗糙表面反射的光（基于朗伯光照方程）
- en: '**Specular**: Describes the light reflected by shiny, slick surfaces'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜面反射**：描述光滑表面反射的光'
- en: Each of the above components may have a different color, which describes the
    surface material (diffuse color is usually taken from a texture). Each light source
    may also be represented with a separate color for each component (except the emissive).
    We can interpret it as how much given light source influences the ambient light
    available in the scene, how much diffuse lighting is emitted by the light source,
    and so on. We can, of course, modify the preceding algorithm to adjust it to our
    needs. This way we can achieve various results that are easy to calculate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个组件可能具有不同的颜色，这描述了表面材料（漫反射颜色通常来自纹理）。每个光源也可以为每个组件（除了发射组件）使用单独的颜色表示。我们可以将其解释为给定光源对场景中可用环境光的影响程度，光源发出的漫反射光量等等。当然，我们可以修改前面的算法以调整它以满足我们的需求。这样我们可以得到易于计算的各种结果。
- en: 'In this recipe, we will focus on the diffuse lighting and specular reflections.
    The former are described in the *Rendering a geometry with a vertex diffuse lighting*
    recipe. The latter are calculated with a dot product of a surface normal vector
    and a half vector. A half vector is a vector that is halfway between a view vector
    (from the lit point to the viewer) and the light vector (from the lit point to
    the light source):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将重点关注漫反射光照和镜面反射。前者在*使用顶点漫反射光照渲染几何体*配方中描述。后者通过表面法线向量和半向量的点积来计算。半向量是一个位于视向量（从被照点到观察者）和光向量（从被照点到光源）之间的向量：
- en: '![](img/image_11_005.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_005.png)'
- en: 'The calculated dot product value is responsible for creating shinny light reflections
    on slick surfaces. As the area lit this way may be too big, the calculated value
    is then raised to the power. The higher the power value, the smaller and more
    concentrated are light reflexes on an object''s surface. In the shader, these
    are calculated like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的点积值负责在光滑表面上创建闪亮的光反射。由于以这种方式照亮的区域可能太大，因此计算出的值被提升到幂。幂值越高，物体表面的光反射就越小、越集中。在着色器中，这些计算如下：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Normal vector is usually loaded along the geometry and provided by the application.
    The half vector is calculated as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 法线向量通常沿着几何形状加载并由应用程序提供。半向量按以下方式计算：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To achieve correct results, all vectors must be normalized. Of course, specular
    highlights are not visible when the surface is not lit (or doesn't face the light
    source). So they should be calculated only when the diffuse component is greater
    than `0`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得正确的结果，所有向量都必须归一化。当然，当表面未照亮（或未面向光源）时，镜面高光是不可见的。因此，只有在漫反射分量大于`0`时才应计算它们。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare Vulkan resources as described in the *Rendering a geometry with a vertex
    diffuse lighting* recipe.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照所述的*使用顶点漫反射光照渲染几何体*配方准备Vulkan资源。
- en: Create a pipeline layout using the prepared descriptor set layout with only
    a uniform buffer and also with a single push constant range accessed by a fragment
    shader stage, beginning at a 0^(th) offset and of a `4 * sizeof( float )` size
    (refer to the *Creating a pipeline layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用准备好的描述符集布局创建一个仅包含统一缓冲区和由片段着色器阶段访问的单个推送常量范围（从0^(th)偏移开始，大小为`4 * sizeof( float
    )`）的管线布局（请参阅[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)中的*创建管线布局*配方，*图形和计算管线*）。
- en: 'Create a shader module for a vertex shader stage using a SPIR-V assembly generated
    from the following GLSL code (refer to the *Converting GLSL shaders to SPIR-V
    assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下GLSL代码生成的SPIR-V汇编创建一个用于顶点着色器阶段的着色器模块（请参阅[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)中的*将GLSL着色器转换为SPIR-V汇编*配方，*着色器*，以及[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)中的*创建着色器模块*配方，*图形和计算管线*）：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下GLSL代码生成的SPIR-V汇编创建一个用于片段着色器阶段的着色器模块：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Specify the pipeline shader stages with vertex and fragment shaders, both using
    a main function from the respective shader modules (refer to the *Specifying pipeline
    shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器指定管道着色器阶段，两者都使用各自着色器模块中的主函数（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中的*指定管道着色器阶段*配方）。
- en: Create a graphics pipeline using the pipeline layout and shader stages presented
    previously. The rest of pipeline parameters remain identical to those presented
    in the *Rendering a geometry with a vertex diffuse lighting* recipe.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前介绍的管道布局和着色器阶段创建一个图形管道。管道的其他参数与在*使用顶点漫反射光照渲染几何体*配方中展示的相同。
- en: Prepare a command buffer recording (or a rendering) function executed each frame.
    To do this, we need to begin a command buffer recording, copy data from the staging
    buffer to the uniform buffer (if needed), set an image memory barrier to transfer
    queue ownership for an image acquired from the swapchain, begin the render pass,
    set the viewport and scissor test states dynamically, bind the vertex buffers,
    descriptor sets and the graphics pipeline (refer to the *Rendering a geometry
    with a vertex diffuse lighting* recipe).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个每帧执行的命令缓冲区记录（或渲染）函数。为此，我们需要开始命令缓冲区记录，将数据从阶段缓冲区复制到统一缓冲区（如果需要），设置一个图像内存屏障以转移从交换链获取的图像的所有权，开始渲染通道，动态设置视口和剪裁测试状态，绑定顶点缓冲区、描述符集和图形管道（参考*使用顶点漫反射光照渲染几何体*配方）。
- en: Prepare a position of a light source and provide it to the shaders through push
    constants. For this operation, provide the pipeline layout, a `VK_SHADER_STAGE_FRAGMENT_BIT`
    shader stage, `0` offset and a size of `sizeof( float ) * 4`, and a pointer to
    the data, in which the light source's position is stored (refer to the *Providing
    data to shaders through push constants* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备光源的位置，并通过推送常量将其提供给着色器。为此操作，提供管道布局，一个`VK_SHADER_STAGE_FRAGMENT_BIT`着色器阶段，`0`偏移量，大小为`sizeof(
    float ) * 4`，以及指向数据的指针，其中存储了光源的位置（参考[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*通过推送常量向着色器提供数据*配方）。
- en: Finalize the command buffer by recording the model drawing operation, ending
    the render pass, setting another image memory barrier for the swapchain image
    and ending the command buffer.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过记录模型绘制操作、结束渲染通道、为交换链图像设置另一个图像内存屏障以及结束命令缓冲区来最终化命令缓冲区。
- en: Submit the command buffer to the graphics queue and present an image (refer
    to the *Preparing a single frame of animation* and *Increasing the performance
    through increasing the number of separately rendered frames* recipes from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令缓冲区提交到图形队列，并呈现一个图像（参考[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*准备单个动画帧*和*通过增加单独渲染帧的数量来提高性能*配方）。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The whole source code is almost identical to the one presented in the *Rendering
    a geometry with a vertex diffuse lighting* recipe. The most important difference
    is in the vertex and fragment shaders, which perform lighting calculations based
    on data provided from the application. This time a light vector is not hardcoded
    in the shader. Instead, it is calculated using the data provided from the application.
    Positions and normal vectors are automatically read as vertex attributes. The
    position of a light source is read using a push constant, so we need to include
    a push constant range, when we create a pipeline layout:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 整个源代码几乎与*使用顶点漫反射光照渲染几何体*配方中展示的相同。最重要的区别在于顶点和片段着色器，它们根据应用程序提供的数据执行光照计算。这次光照向量不是硬编码在着色器中的。相反，它使用应用程序提供的数据进行计算。位置和法向量自动作为顶点属性读取。使用推送常量读取光源的位置，因此当我们创建管道布局时需要包含推送常量范围：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Data to a push constant is provided during the command buffer recording operation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令缓冲区记录操作期间提供推送常量数据：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Through the push constant, we provide a position of a light source. This way
    our shaders becomes more universal, as we can calculate light vector directly
    in a shader and use it for lighting calculations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过推送常量，我们提供了一个光源的位置。这样我们的着色器就变得更加通用，因为我们可以直接在着色器中计算光照向量并将其用于光照计算。
- en: In the following image, we can see the results of rendering a geometry lit with
    a diffuse and specular lighting calculated inside a fragment shader. The results
    of lighting calculations performed in the fragment shader are much better than
    if the same calculations were performed in the vertex shader. The lighting looks
    good even if the geometry is quite simple. But, of course, this comes with reduced
    performance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们可以看到使用在片段着色器内计算出的漫反射和镜面光照渲染几何体的结果。在片段着色器中执行的光照计算结果比在顶点着色器中执行相同计算的结果要好得多。即使几何体相当简单，光照看起来也很不错。但当然，这伴随着性能的降低。
- en: '![](img/image_11_006.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_006.png)'
- en: See also
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, the recipe
    *Converting GLSL shaders to SPIR-V assemblies*
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，食谱*将GLSL着色器转换为SPIR-V汇编*
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying pipeline shader stages*'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线着色器阶段*'
- en: '*Creating a pipeline layout*'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes::'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录与绘制*中，查看以下食谱：
- en: '*Providing data to shaders through push constants*'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: 'The following recipe in this chapter:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Rendering a geometry with a vertex diffuse lighting*'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点漫反射光照渲染几何体*'
- en: Rendering a normal mapped geometry
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染法线贴图几何体
- en: Normal mapping is a technique that allows us to increase the details of a model's
    surface without increasing its geometrical complexity. Using this technique, normal
    vectors associated with vertices are not used during lighting calculations. They
    are replaced with normal vectors read from an image (a texture). This way, the
    shape of a model is unchanged, so we don't need additional processing power to
    transform vertices. However, the lighting quality is much better and depends only
    on the quality of a normal map image instead of the complexity of the model.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图是一种技术，允许我们在不增加模型几何复杂性的情况下增加模型表面的细节。使用这种技术，与顶点关联的法线向量在光照计算期间不被使用。它们被从图像（纹理）中读取的法线向量所替代。这样，模型的形状保持不变，因此我们不需要额外的处理能力来转换顶点。然而，光照质量要好得多，并且仅取决于法线贴图图像的质量，而不是模型复杂性。
- en: 'An example of an image generated with this recipe looks like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此食谱生成的图像示例如下：
- en: '![](img/image_11_007.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_007.png)'
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Normal map is an image, in which normal vectors acquired from a highly detailed
    geometry are stored. It is used to simulate the high amount of surface details
    on a simple (low-polygon) geometry.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图是一种图像，其中存储了从高度详细几何体获取的法线向量。它用于模拟简单（低多边形）几何体上的大量表面细节。
- en: '![](img/image_11_008-1.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_008-1.png)'
- en: 'For simple lighting calculations, we just need to load positions and normal
    vectors, but normal mapping requires us to load (or generate) much more data for
    a given 3D model. Apart from the above attributes, we also need texture coordinates,
    so we can sample a normal map inside fragment shaders, and two additional vectors:
    tangent and bitangent. The normal vector is perpendicular to the surface at a
    given point and points in a direction that is away from the surface. Tangent and
    bitangent vectors are tangential to the surface. Tangent vector points in the
    direction on object''s surface, in which texture image advances *horizontally*,
    from left to right (`s` component of texture coordinates is increasing). Bitangent
    points in the direction on object''s surface, in which the texture image advances
    *vertically*, from top to bottom (`t` component of texture coordinates is decreasing).
    Additionally, all three vectors - a normal, tangent and bitangent - should be
    perpendicular to each other (small deviations are acceptable) and have a length
    equal to `1.0`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的光照计算，我们只需要加载位置和法向量，但法线贴图需要我们为给定的3D模型加载（或生成）更多的数据。除了上述属性外，我们还需要纹理坐标，这样我们就可以在片段着色器中采样法线贴图，还需要两个额外的向量：切线和副切线。法向量在给定点的表面上垂直于表面，并指向远离表面的方向。切线和副切线向量与表面相切。切线向量指向物体表面的方向，其中纹理图像水平前进，从左到右（纹理坐标的`s`分量增加）。副切线指向物体表面的方向，其中纹理图像垂直前进，从上到下（纹理坐标的`t`分量减少）。此外，所有三个向量——法线、切线和副切线——应相互垂直（允许有小的偏差）并且长度等于`1.0`。
- en: Normal, tangent and bitangent vectors are not used directly for lighting calculations.
    Instead, they form a rotation matrix, which can be used to convert a vector from
    texture (or tangent) space to a local model space or vice versa. This way we don't
    need to create a texture with normal vectors that can only be applied to a dedicated
    model, but we can prepare a general normal map and use it with an arbitrary geometry.
    Using the so called TBN matrix, we can load a normal vector from the texture and
    use it for lighting calculations performed in a coordinate system that is more
    convenient for us.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 法线、切线和副切线向量不是直接用于光照计算的。相反，它们形成一个旋转矩阵，可以用来将向量从纹理（或切线）空间转换为局部模型空间，反之亦然。这样我们就不需要创建一个只能应用于特定模型的法线向量纹理，而可以准备一个通用的法线贴图，并用它来处理任意几何体。使用所谓的TBN矩阵，我们可以从纹理中加载法线向量，并用于在更方便的坐标系中执行的光照计算。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Prepare Vulkan resources as described in the *Rendering a geometry with a vertex
    diffuse lighting* recipe.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第10章*使用顶点漫反射光照渲染几何体*食谱中描述的方式准备Vulkan资源。
- en: Load texture data from a file with a normal map (refer to the *Loading texture
    data from a file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载具有法线贴图的纹理数据（参考第10章的*从文件加载纹理数据*食谱，*辅助食谱*）。
- en: Create a two-dimensional combined image sampler that has a color aspect and
    format (in example `VK_FORMAT_R8G8B8A8_UNORM`) and supports `VK_IMAGE_USAGE_SAMPLED_BIT`
    and `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usages (refer to the *Creating a combined
    image sampler* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有颜色方面和格式（例如`VK_FORMAT_R8G8B8A8_UNORM`）的二维组合图像采样器，并支持`VK_IMAGE_USAGE_SAMPLED_BIT`和`VK_IMAGE_USAGE_TRANSFER_DST_BIT`使用（参考第5章的*创建组合图像采样器*食谱，*描述符集*）。
- en: Copy data loaded from a normal map into the created image using a staging buffer
    (refer to the *Using staging buffer to update an image with a device-local memory
    bound* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用阶段缓冲区将加载的法线图数据复制到创建的图像中（参考第4章的*使用阶段缓冲区更新绑定到设备本地内存的图像*食谱，*资源和内存*）。
- en: Load a 3D model from a file. Apart from the vertex positions and normal vectors,
    load also texture coordinates and load or generate tangent and bitangent vectors.
    Create a (vertex) buffer and copy loaded model data to the buffer's memory using
    a staging buffer (refer to the *Loading a 3D model from an OBJ file* from [Chapter
    10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载3D模型。除了顶点位置和法向量外，还需要加载纹理坐标，并加载或生成切线和副切线向量。创建一个（顶点）缓冲区，并使用阶段缓冲区将加载的模型数据复制到缓冲区的内存中（参考第10章的*从OBJ文件加载3D模型*，*辅助食谱*）。
- en: Create a descriptor set layout with one uniform buffer accessed by a vertex
    shader at 0^(th) binding and with one combined image sampler accessed by a fragment
    shader at 1^(st) binding (refer to the *Creating a descriptor set layout* recipe
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符集布局，其中包含一个由顶点着色器在0^(th)绑定处访问的统一缓冲区，以及一个由片段着色器在1^(st)绑定处访问的联合图像采样器（参考第5章中*创建描述符集布局*的配方，*描述符集*）。
- en: Create a descriptor pool from which one uniform buffer descriptor and one combined
    image sampler descriptor can be allocated (refer to the *Creating a descriptor
    pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建的描述符池中分配一个统一缓冲区描述符和一个联合图像采样器描述符（参考第5章中*创建描述符池*的配方，*描述符集*）。
- en: Allocate one descriptor set from the created pool using a descriptor set layout
    with one uniform buffer and one combined image sampler (refer to *Allocating descriptor
    sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包含一个统一缓冲区和一个联合图像采样器的描述符集布局从创建的池中分配一个描述符集（参考第5章中*分配描述符集*的配方，*描述符集*）。
- en: Update the descriptor set with the uniform buffer accessed at the 0^(th) binding
    and with the created combined image sampler with normal map data accessed at the
    1^(st) binding. Provide a `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value as
    the image's layout (refer to the *Updating descriptor sets* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在0^(th)绑定处访问的统一缓冲区和在1^(st)绑定处访问的创建的联合图像采样器（具有正常图数据）更新描述符集。提供`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`作为图像的布局（参考第5章中*更新描述符集*的配方，*描述符集*）。
- en: Create a pipeline layout using the prepared descriptor set layout that also
    specifies a single push constant range accessed by a fragment shader stage, beginning
    at a 0^(th) offset and of a `4 * sizeof( float )` size (refer to the *Creating
    a pipeline layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用准备好的描述符集布局创建一个管线布局，该布局还指定了一个由片段着色器阶段访问的单个推送常量范围，起始位置为第0个偏移量，大小为`4 * sizeof(
    float )`（参考第8章中*创建管线布局*的配方，*图形和计算管线*）。
- en: 'Create a shader module for a vertex shader stage using a SPIR-V assembly generated
    from the following GLSL code (refer to the *Converting GLSL shaders to SPIR-V
    assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders and to Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下GLSL代码生成的SPIR-V汇编创建一个用于顶点着色器阶段的着色器模块（参考第7章中*将GLSL着色器转换为SPIR-V汇编*的配方，以及第8章中*创建着色器模块*的配方，*图形和计算管线*）：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下GLSL代码生成的SPIR-V汇编创建一个用于片段着色器阶段的着色器模块：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from respective shader modules (refer to the *Specifying pipeline
    shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定使用顶点和片段着色器的管线着色器阶段，两者都使用各自着色器模块中的`main`函数（参考第8章中*指定管线着色器阶段*的配方，*图形和计算管线*）。
- en: 'Specify a pipeline vertex input state with five attributes that are read from
    the same 0^(th) binding. The binding should be created with data read per vertex
    and a stride equal to `14 * sizeof( float )` (refer to the *Specifying pipeline
    vertex input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). The first attribute should have the following
    parameters:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个具有五个属性的管线顶点输入状态，这些属性从相同的0^(th)绑定读取。绑定应使用每个顶点读取的数据和等于`14 * sizeof( float
    )`的步长创建（参考第8章中*指定管线顶点输入状态*的配方，*图形和计算管线*）。第一个属性应具有以下参数：
- en: '`0` value for `location`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`的值为`0`'
- en: '`0` value for `binding`'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`的值为`0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`的值为`VK_FORMAT_R32G32B32_SFLOAT`'
- en: '`0` value for `offset`'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`的值为`0`'
- en: 'The second attribute should be defined as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个属性应定义为以下内容：
- en: '`1` value for `location`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`的值为`1`'
- en: '`0` value for `binding`'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding` 的值为 `0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的值为 `VK_FORMAT_R32G32B32_SFLOAT`'
- en: '`3 * sizeof( float )` value for `offset`'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `3 * sizeof( float )`'
- en: 'The third attribute should have the following definition:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个属性应具有以下定义：
- en: '`2` value for `location`'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location` 的值为 `2`'
- en: '`0` value for `binding`'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding` 的值为 `0`'
- en: '`VK_FORMAT_R32G32_SFLOAT` value for `format`'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的值为 `VK_FORMAT_R32G32_SFLOAT`'
- en: '`6 * sizeof( float )` value for `offset`'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `6 * sizeof( float )`'
- en: 'The fourth attribute should be specified as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个属性应指定如下：
- en: '`3` value for `location`'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location` 的值为 `3`'
- en: '`0` value for `binding`'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding` 的值为 `0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的值为 `VK_FORMAT_R32G32B32_SFLOAT`'
- en: '`8 * sizeof( float )` value for `offset`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `8 * sizeof( float )`'
- en: 'The fifth attribute should use these values:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五个属性应使用以下值：
- en: '`4` value for `location`'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location` 的值为 `4`'
- en: '`0` value for `binding`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding` 的值为 `0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 的值为 `VK_FORMAT_R32G32B32_SFLOAT`'
- en: '`11 * sizeof( float )` value for `offset`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 的值为 `11 * sizeof( float )`'
- en: In each frame of animation, record a command buffer, inside which copy data
    from the staging buffer to the uniform buffer, begin the render pass, set the
    viewport and scissor test state dynamically, bind the vertex buffer, the descriptor
    set and the graphics pipeline (refer to the *Rendering a geometry with a vertex
    diffuse lighting recipe*).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画的每一帧中，记录一个命令缓冲区，在其中将数据从阶段缓冲区复制到统一缓冲区，开始渲染过程，动态设置视口和裁剪测试状态，绑定顶点缓冲区、描述符集和图形管道（参考
    *使用顶点漫反射光照渲染几何体菜谱*）。
- en: Prepare the position of a light source and provide it to shaders through push
    constants. For this operation, provide the pipeline layout, a `VK_SHADER_STAGE_FRAGMENT_BIT`
    shader stage, `0` offset and a size of `sizeof( float ) * 4`, and a pointer to
    the data, in which light source's position is stored (refer to the *Providing
    data to shaders through push constants* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备光源的位置，并通过推送常量将其提供给着色器。为此操作，提供管道布局，一个 `VK_SHADER_STAGE_FRAGMENT_BIT` 着色器阶段，`0`
    偏移量，大小为 `sizeof( float ) * 4`，以及指向数据的指针，其中存储了光源的位置（参考第 9 章 *通过推送常量向着色器提供数据* 菜谱，*命令记录和绘制*)。
- en: Draw the model, record the rest of the required operations into the command
    buffer, submit the command buffer to the graphics queue, and present an image
    (refer to the P*reparing a single frame of animation and Increasing the performance
    through increasing the number of separately rendered frames* recipes from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制模型，将所需的其他操作记录到命令缓冲区中，将命令缓冲区提交到图形队列，并呈现图像（参考第 9 章 *准备单个动画帧和通过增加单独渲染帧的数量来提高性能*
    菜谱，*命令记录和绘制*)。
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To use normal mapping in our application, we need to prepare an image, in which
    normal vectors are stored. We must load the image''s contents, create an image,
    and copy the data to the image''s memory. We also need to create a sampler that,
    along with the image, will form a combined image sampler:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用法线贴图，我们需要准备一个存储法向量的图像。我们必须加载图像的内容，创建一个图像，并将数据复制到图像的内存中。我们还需要创建一个采样器，它与图像一起将形成一个组合图像采样器：
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, we need to load a 3D model. We need to load positions, normal vectors,
    and texture coordinates. Tangent and bitangent vectors must also be loaded, but
    as the `.obj` format cannot store so many different attributes, we must generate
    them (this is performed inside the `Load3DModelFromObjFile()`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要加载一个 3D 模型。我们需要加载位置、法向量以及纹理坐标。切线向量和双切线向量也必须加载，但由于 `.obj` 格式无法存储这么多不同的属性，我们必须生成它们（这是在
    `Load3DModelFromObjFile()` 内部执行的）：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we need to modify the descriptor set described in the *Rendering a geometry
    with a vertex diffuse lighting* recipe. First, we start by creating a proper layout:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改在 *使用顶点漫反射光照渲染几何体* 菜谱中描述的描述符集。首先，我们开始创建一个合适的布局：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, a descriptor pool is required. From it a descriptor set is allocated:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要一个描述符池。从它分配一个描述符集：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the descriptor set is allocated, we can update it with handles of the
    uniform buffer and the combined image sampler:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当描述符集被分配时，我们可以使用统一缓冲区和组合图像采样器的句柄来更新它：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time we have not two but five vertex attributes, so we also need to modify
    the vertex input state:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们有两个而不是五个顶点属性，因此我们还需要修改顶点输入状态：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding attributes are read in the vertex shader, which transforms the
    vertex position to a clip space using the model-view and projection matrices.
    Additionally, the view-space position and unmodified texture coordinates are passed
    to the fragment shader. Normal, tangent and bitangent vectors are also passed
    to the fragment shader, but they are first transformed to a view space with the
    model-view matrix:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述属性在顶点着色器中读取，使用模型视图和投影矩阵将顶点位置转换到裁剪空间。此外，视图空间位置和未修改的纹理坐标被传递到片段着色器。法线、切线和二切向量也被传递到片段着色器，但它们首先使用模型视图矩阵转换到视图空间：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The most important part, from the normal mapping perspective, takes place in
    the fragment shader. It first reads the normal vector from the texture. Usually,
    textures store values that are in the `0.0` - `1.0` range inclusive (unless we
    use signed-normalized texture formats: `SNORM`). However, all the components of
    normal vectors may have values in the `-1.0` - `1.0` range, so we need to expand
    the loaded normal vector like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从正常映射的角度来看，最重要的部分发生在片段着色器中。它首先从纹理中读取法线向量。通常，纹理存储的值在 `0.0` - `1.0` 范围内（除非我们使用有符号归一化纹理格式：`SNORM`）。然而，法线向量的所有分量可能具有
    `-1.0` - `1.0` 范围内的值，因此我们需要像这样扩展加载的法线向量：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The fragment shader calculates diffuse and specular lighting in the same way
    as described in the *Rendering a geometry with a fragment specular lighting* recipe.
    It just takes the normal vector loaded from the texture instead of the one provided
    from the vertex shader. There is just one additional thing it needs to perform:
    all the vectors (light and view) are in the view space, but the normal vector
    stored in the normal map is in the tangent space, so it also needs to be converted
    to the same view space. This is done with a TBN matrix formed from the normal,
    tangent and bitangent vectors. They are provided from the vertex shader. Because
    the vertex shader transforms them from the model space into a view space (by multiplying
    them by the model-view matrix), the created TBN matrix converts the normal vector
    from the tangent space directly into the view space:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器以与*使用片段镜面照明渲染几何体*食谱中描述的相同方式计算漫反射和镜面照明。它只是使用从纹理中加载的法线向量代替从顶点着色器提供的法线向量。它还需要执行一个额外的操作：所有向量（光和视图）都在视图空间中，但存储在正常映射中的法线向量在切线空间中，因此它也需要转换到相同的视图空间。这是通过使用由法线、切线和二切向量形成的
    TBN 矩阵来完成的。它们由顶点着色器提供。因为顶点着色器通过乘以模型视图矩阵将它们从模型空间转换到视图空间，所以创建的 TBN 矩阵将法线向量直接从切线空间转换到视图空间：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`mat3()` is a constructor for creating a 3x3 matrix from three-component vectors.
    Using such a matrix, we can perform rotations and scaling, but no translation.
    Since we want to transform directions (unit-length vectors), this is exactly what
    we need in this situation.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`mat3()` 是一个从三个分量向量创建 3x3 矩阵的构造函数。使用这样的矩阵，我们可以执行旋转和缩放，但不能平移。由于我们想要变换方向（单位长度向量），这正是这种情况所需要的。'
- en: Normal mapping can give us impressive lighting even on very simple (low-poly)
    geometry. In the image below, on the left we can see normal mapped geometry with
    many polygons; while on the right, similar geometry is presented but with fewer
    vertices.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正常映射可以在非常简单的（低多边形）几何体上为我们提供令人印象深刻的照明效果。在下面的图片中，左侧我们可以看到带有许多多边形的正常映射几何体；而右侧，相似的几何体以更少的顶点呈现。
- en: '![](img/image_11_009.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_009.png)'
- en: See also
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*,
    the recipe *Using staging buffer to update an image with a device local memory
    bound*
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)的*资源和内存*中，查看*使用阶段缓冲区更新绑定到设备本地内存的图像*的食谱
- en: In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    the recipe *Creating a combined image sampler*
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)的*描述符集*中，查看*创建组合图像采样器*的食谱
- en: 'In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    see the following recipes:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)的*辅助食谱*中，查看以下食谱：
- en: '*Loading texture data from a file*'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从文件中加载纹理数据*'
- en: '*Loading a 3D model from an OBJ file*'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 OBJ 文件中加载 3D 模型*'
- en: 'Also, look at the following recipes in the same chapter:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，查看同一章节中的以下食谱：
- en: '*Rendering a geometry with a vertex diffuse lighting*'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点漫反射照明渲染几何体*'
- en: '*Rendering a geometry with a fragment specular lighting*'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用片段镜面照明渲染几何体*'
- en: Drawing a reflective and refractive geometry using cubemaps
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用立方体贴图绘制反射和折射几何体
- en: In real-life, transparent objects both transmit light rays, and also reflect
    them. If an object's surface is viewed from high angles, we see more light being
    reflected. Looking at an object's surface more directly, we see more light being
    transmitted through the object. Simulating such an effect may generate very plausible
    results. In this recipe, we will see how to render a geometry that is both refractive
    and reflective.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，透明物体既会传播光线，也会反射光线。如果从高角度观察物体的表面，我们会看到更多的反射光。如果更直接地观察物体的表面，我们会看到更多的光线通过物体传播。模拟这种效果可能会产生非常逼真的结果。在本配方中，我们将了解如何渲染既具有折射性又具有反射性的几何体。
- en: 'An example of an image generated with this recipe looks like:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配方生成的图像示例如下：
- en: '![](img/image_11_010.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片示例](img/image_11_010.png)'
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Cubemaps are textures with images covering six sides of a cube. They usually
    store the view of a scene from a given position. The most common use for cubemaps
    are skyboxes. They are also handy when we want to map reflections on a surface
    of a given model. Another example of common use is to simulate transparent objects
    (that is made of glass), which refract light rays. Very low resolution cubemaps
    (in example 4x4 pixels) can even be used directly for ambient lighting.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图是覆盖立方体六个面的图像纹理。它们通常存储从给定位置观察到的场景视图。立方体贴图最常见的使用是天空盒。当我们要在给定模型的表面上映射反射时，它们也非常方便。另一个常见用途是模拟透明物体（即玻璃制成的物体），这些物体可以折射光线。非常低分辨率的立方体贴图（例如4x4像素）甚至可以直接用于环境光照。
- en: 'Cubemaps contain six two-dimensional images. All of them are square and have
    the same size. In Vulkan, cubemaps are created using 2D images with six array
    layers, for which a cubemap image view is created. Through it, the six array layers
    are interpreted as cubemap faces in the following order: `+X`, `-X`, `+Y`, `-Y`,
    `+Z`, `-Z`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图包含六个二维图像。它们都是正方形，并且大小相同。在Vulkan中，使用具有六个数组层的2D图像创建立方体贴图，为这些数组层创建一个立方体贴图图像视图。通过它，六个数组层被解释为以下顺序的立方体贴图面：`+X`、`-X`、`+Y`、`-Y`、`+Z`、`-Z`。
- en: '![](img/image_11_011.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片示例](img/image_11_011.png)'
- en: Images courtesy of Emil Persson ([h t t p ://w w w . h u m u s . n a m e](http://www.humus.name))
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Emil Persson提供([h t t p ://w w w . h u m u s . n a m e](http://www.humus.name))
- en: Six sides of a cubemap correspond to six directions, as if we stayed in one
    position, turned around, and took photos of the world around us. Using such a
    texture, we can simulate the world being reflected from the surface of the object
    or being transmitted through the object. However, when an object moves too far
    from the place the texture was created for, the illusion is broken until we apply
    a new texture that is valid for the new position.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图的六个面对应于六个方向，就像我们站在一个位置，转身，并拍摄周围的世界的照片一样。使用这种纹理，我们可以模拟世界从物体表面反射或通过物体传播。然而，当物体移动得太远，远离纹理创建的位置时，这种幻觉就会破裂，直到我们应用一个新的、适用于新位置的纹理。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Prepare Vulkan resources as described in the *Rendering a geometry with a vertex
    diffuse lighting* recipe.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照*使用顶点漫反射光照渲染几何体*配方中描述的步骤准备Vulkan资源。
- en: Load a 3D model data from file with vertex positions and normal vectors. This
    model will be displayed as the one reflecting and transmitting the environment
    (refer to the *Loading a 3D model from an OBJ file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper
    Recipes*).
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载包含顶点位置和法向量的3D模型数据。此模型将显示为反射和传播环境的模型（参考第10章的*从OBJ文件加载3D模型*配方，*辅助配方*）。
- en: Create a (vertex) buffer with a memory object and use it store the vertex data
    for our model (refer to the *Creating a buffer, Allocating and binding memory
    object to a buffer* and *Using staging buffer to update buffer with a device-local
    memory bound* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内存对象创建一个（顶点）缓冲区，并使用它存储我们模型的顶点数据（参考第4章的*创建缓冲区、分配和绑定内存对象到缓冲区*以及*使用阶段缓冲区更新绑定到设备本地内存的缓冲区*配方，*资源和内存*）。
- en: Load a 3D model containing vertex positions of a cube. This model will be used
    to display the environment being reflected (refer to the *Drawing a skybox* recipe
    from [Chapter 12](82938796-18a3-413b-b05d-47816d70e49a.xhtml), *Advanced Rendering
    Techniques*).
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载包含立方体顶点位置的3D模型。此模型将用于显示被反射的环境（参考第12章的*绘制天空盒*配方，*高级渲染技术*）。
- en: Create a buffer, along with a memory object bound it, to hold the vertex data
    of the environment (skybox).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个缓冲区，以及一个与其绑定的内存对象，以存储环境的顶点数据（天空盒）。
- en: Create a two-dimensional combined image sampler with six array layers and a
    cube image view. It must support `VK_IMAGE_USAGE_SAMPLED_BIT` and `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
    uses. A `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` sampler address mode must be used
    for all addressing dimensions (refer to the *Creating a combined image sampler*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有六个数组层和一个立方体贴图视图的两维组合图像采样器。它必须支持`VK_IMAGE_USAGE_SAMPLED_BIT`和`VK_IMAGE_USAGE_TRANSFER_DST_BIT`使用。必须对所有寻址维度使用`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`采样器寻址模式（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)中的*创建组合图像采样器*配方，*描述符集*）。
- en: Load texture data for all six sides of a cubemap from files (refer to the *Loading
    texture data from a file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载立方体贴图的六个面的纹理数据（参考[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)中的*从文件加载纹理数据*配方，*辅助配方*）。
- en: 'Upload each loaded texture to a separate array layer of a created combined
    image sampler. Textures should be uploaded in the following order: positive and
    negative X, positive and negative Y, positive and negative Z (refer to the *Using
    staging buffer to update an image with a device-local memory bound* from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个加载的纹理上传到创建的组合图像采样器的单独数组层。纹理应按以下顺序上传：正负X、正负Y、正负Z（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)中的*使用阶段缓冲区更新具有设备本地内存绑定的图像*配方，*资源和内存*）。
- en: 'Create a descriptor set layout with two descriptor resources: a uniform buffer
    accessed in a vertex shader at 0^(th) binding and with a combined image sampler
    accessed in a fragment shader at 1^(st) binding (refer to the *Creating a descriptor
    set layout* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个描述符资源的描述符集布局：一个在顶点着色器中以0^(th)绑定访问的统一缓冲区，以及一个在片段着色器中以1^(st)绑定访问的组合图像采样器（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)中的*创建描述符集布局*配方，*描述符集*）。
- en: Create a descriptor pool, from which one uniform buffer descriptor and one combined
    image sampler descriptor can be allocated (refer to the *Creating a descriptor
    pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符池，从中可以分配一个统一缓冲区描述符和一个组合图像采样器描述符（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)中的*创建描述符池*配方，*描述符集*）。
- en: Allocate a descriptor set from the created pool using the descriptor set layout
    with a uniform buffer and a combined image sampler resources (refer to the *Allocating
    descriptor sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用描述符集布局和统一缓冲区以及组合图像采样器资源从创建的池中分配一个描述符集（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)中的*分配描述符集*配方，*描述符集*）。
- en: Update (populate) the descriptor set with the uniform buffer accessed at the
    0^(th) binding and with the created combined image sampler (cubemap) accessed
    at the 1^(st) binding. Provide a `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` value
    as the cubemap's layout (refer to the *Updating descriptor sets* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在0^(th)绑定访问的统一缓冲区和在1^(st)绑定访问的已创建的组合图像采样器（立方体贴图）更新（填充）描述符集。将`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`值作为立方体贴图的布局（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)中的*更新描述符集*配方，*描述符集*）。
- en: Create a pipeline layout using the prepared descriptor set layout that also
    specifies a single push constant range accessed by a fragment shader stage, beginning
    at a 0^(th) offset and of a `4 * sizeof( float )` size (refer to the *Creating
    a pipeline layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用准备好的描述符集布局创建一个管线布局，该布局还指定了一个由片段着色器阶段访问的单个推送常量范围，从0^(th)偏移开始，大小为`4 * sizeof(
    float )`（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)中的*创建管线布局*配方，*图形和计算管线*）。
- en: 'Create a graphics pipeline used for drawing a reflective and refractive model.
    Start by creating a shader module for a vertex shader stage using a SPIR-V assembly
    generated from the following GLSL code (refer to the *Converting GLSL shaders
    to SPIR-V assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to Creating a shader module recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于绘制反射和折射模型的图形管道。首先，使用以下 GLSL 代码生成的 SPIR-V 汇编创建一个用于顶点着色器阶段的着色器模块（参考第 7 章
    *将 GLSL 着色器转换为 SPIR-V 汇编* 的配方，*着色器* 以及第 8 章 *图形和计算管道* 中的 *创建着色器模块* 配方）：
- en: '[PRE29]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 GLSL 代码生成的 SPIR-V 汇编创建一个用于片段着色器阶段的着色器模块：
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from the respective shader modules (refer to the *Specifying
    pipeline shader stages* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器指定管道着色器阶段，两者都使用各自着色器模块中的 `main` 函数（参考第 8 章 *图形和计算管道* 中的 *指定管道着色器阶段*
    配方）。
- en: Create a graphics pipeline for drawing a model using the preceding pipeline
    shader stages definition, with the rest of the pipeline's parameters defined in
    the same way as in the *Rendering a geometry with a vertex diffuse lighting* recipe.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面定义的管道着色器阶段创建一个用于绘制模型的图形管道，其余管道参数的设置方式与 *使用顶点漫反射光照渲染几何体* 配方中的方式相同。
- en: Create a graphics pipeline for drawing an environment being reflected--a skybox
    (refer to the *Drawing a skybox* recipe from [Chapter 12](82938796-18a3-413b-b05d-47816d70e49a.xhtml),
    *Advanced Rendering Techniques*).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于绘制被反射的环境——天空盒的图形管道（参考第 12 章 *高级渲染技术* 中的 *绘制天空盒* 配方）。
- en: To render a frame, record a command buffer in each iteration of a rendering
    loop. In the command buffer, copy data from the staging buffer to the uniform
    buffer, begin the render pass, set the viewport and scissor test states dynamically
    and bind the descriptor set (refer to the *Rendering a geometry with a vertex
    diffuse lighting* recipe).
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要渲染一帧，在每个渲染循环的迭代中记录一个命令缓冲区。在命令缓冲区中，将数据从阶段缓冲区复制到统一缓冲区，开始渲染过程，动态设置视口和裁剪测试状态，并绑定描述符集（参考
    *使用顶点漫反射光照渲染几何体* 的配方）。
- en: Bind the graphics pipeline and the vertex buffer created for the reflective/refractive
    model.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定用于反射/折射模型的图形管道和顶点缓冲区。
- en: Prepare the position of a camera, from which the scene is observed and provide
    it to shaders through push constants. For this operation, provide the pipeline
    layout, a `VK_SHADER_STAGE_FRAGMENT_BIT` shader stage, `0` offset and a size of
    `sizeof( float ) * 4`, and a pointer to the data, in which the camera's position
    is stored (refer to the *Providing data to shaders through push constants* recipe
    from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备相机的位置，从该位置观察场景，并通过推送常量将其提供给着色器。为此操作，提供管道布局、`VK_SHADER_STAGE_FRAGMENT_BIT`
    着色器阶段、`0` 偏移量和 `sizeof( float ) * 4` 的大小，以及存储相机位置的数据的指针（参考第 9 章 *通过推送常量向着色器提供数据*
    的配方，*命令记录和绘图*）。
- en: Draw the model (refer to the *Drawing a geometry* recipe from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制模型（参考第 9 章 *绘制几何体* 的配方，*命令记录和绘图*）。
- en: Bind the graphics pipeline and the vertex buffer created for the skybox and
    draw it.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定用于天空盒的图形管道和顶点缓冲区，并绘制它。
- en: Record the rest of the required operations into the command buffer, submit the
    command buffer to the graphics queue, and present an image (refer to the *Preparing
    a single frame of animation and Increasing the performance through increasing
    the number of separately rendered frames* recipes from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其余所需操作记录到命令缓冲区中，将命令缓冲区提交到图形队列，并呈现一个图像（参考第 9 章 *准备单个动画帧和通过增加单独渲染帧的数量来提高性能* 的配方，*命令记录和绘图*）。
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start this recipe by loading and preparing buffers for two models: the first
    being the one simulating our main scene (reflective/refractive model); and second
    being used to draw the environment itself (a skybox). We need to copy vertex data
    using staging buffers to both vertex buffers.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个配方开始，加载和准备两个模型的缓冲区：第一个是模拟我们的主场景（反射/折射模型）的模型；第二个用于绘制环境本身（一个天空盒）。我们需要使用阶段缓冲区将顶点数据复制到两个顶点缓冲区中。
- en: 'Next, we need to create a cubemap. We do this by creating a combined image
    sampler. The image must be of a 2D type, must have six array layers, and must
    support `VK_IMAGE_USAGE_SAMPLED_BIT` and `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usages.
    The format of the image depends on the case, but usually a `VK_FORMAT_R8G8B8A8_UNORM`
    would be a good choice. The created sampler must use a `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`
    addressing mode for all sampling dimensions (`u`, `v`, and `w`), otherwise we
    might see the edges of all cubemap faces:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个立方体贴图。我们通过创建一个组合图像采样器来完成此操作。图像必须是2D类型，必须具有六个数组层，并且必须支持`VK_IMAGE_USAGE_SAMPLED_BIT`和`VK_IMAGE_USAGE_TRANSFER_DST_BIT`用法。图像的格式取决于具体情况，但通常`VK_FORMAT_R8G8B8A8_UNORM`是一个不错的选择。创建的采样器必须对所有采样维度（`u`、`v`和`w`）使用`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`寻址模式，否则我们可能会看到所有立方体贴图面的边缘：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we need to upload data to the cubemap image. In this sample we load data
    from six separate files and copy it to six layers of an image like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将数据上传到立方体贴图图像。在这个示例中，我们从六个单独的文件中加载数据并将其复制到图像的六个层中，如下所示：
- en: '[PRE32]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also need a descriptor set through which a fragment shader will be able
    to access the cubemap. To allocate a descriptor set its layout is required:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个描述符集，通过它片段着色器能够访问立方体贴图。为了分配描述符集，需要其布局：
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Descriptor sets are allocated from pools. So now we create one and allocate
    the descriptor set itself:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集是从池中分配的。因此现在我们创建一个，并分配描述符集本身：
- en: '[PRE34]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One last step connected with descriptor resources is to update the created
    set with handles of resources that should be accessed in shaders:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与描述符资源相关联的最后一步是更新创建的集，包括在着色器中应访问的资源句柄：
- en: '[PRE35]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After descriptor sets, it''s time to create a render pass and a graphics pipeline,
    or rather two pipelines: one for drawing the model, and one for drawing the environment
    (a skybox). A graphics pipeline used for the model is very similar to the one
    created in the *Rendering a geometry with a vertex diffuse lighting* recipe, except
    it uses different shader programs and a push constant range, so we need to include
    it during pipeline layout creation:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述符集之后，是时候创建渲染通道和图形管线了，或者说两个管线：一个用于绘制模型，另一个用于绘制环境（一个天空盒）。用于模型的图形管线与*使用顶点漫反射光照渲染几何体*配方中创建的图形管线非常相似，除了它使用不同的着色器程序和推送常量范围，因此我们需要在管线布局创建时包含它：
- en: '[PRE36]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The vertex shader, as usual, calculates the clip space position of a vertex
    and passes the unmodified position and normal vector to the fragment shader:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器，像往常一样，计算顶点的裁剪空间位置，并将未修改的位置和法线向量传递到片段着色器：
- en: '[PRE37]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Calculating reflections or refractions is most easily done in the world space
    and we should transform both vectors to this coordinate system. However, to simplify
    the recipe, the above vertex shader makes an assumption that the model is already
    provided in the world space, that''s why unmodified vectors (position and normal)
    are passed to the fragment shader. It then takes these vectors and uses them to
    calculate both reflected and refracted vectors with built-in `reflect()` and `refract()`
    functions. Calculated vectors are used to read values from the cubemap. They are
    then mixed together based on the viewing angle:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在世界空间中计算反射或折射是最容易的，我们应该将这两个向量转换到这个坐标系。然而，为了简化配方，上面的顶点着色器假设模型已经以世界空间提供，这就是为什么未修改的向量（位置和法线）被传递到片段着色器。然后它使用这些向量并使用内置的`reflect()`和`refract()`函数来计算反射和折射向量。计算出的向量用于从立方体贴图中读取值。然后根据观察角度将它们混合在一起：
- en: '[PRE38]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As for the creation of a graphics pipeline used for the skybox rendering, there
    is a dedicated *Drawing a skybox* recipe in [Chapter 12](82938796-18a3-413b-b05d-47816d70e49a.xhtml),
    *Advanced Rendering Techniques*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 至于创建用于天空盒渲染的图形管线，[第12章](82938796-18a3-413b-b05d-47816d70e49a.xhtml)中有一个专门的*绘制天空盒*配方，*高级渲染技术*。
- en: 'One last thing we should focus on is a command buffer recording. Here we render
    two objects, not one, so first we need to set an appropriate state required to
    properly draw the model:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们应该关注的是命令缓冲区记录。在这里我们渲染两个对象，而不是一个，因此首先我们需要设置一个适当的州，以便正确绘制模型：
- en: '[PRE39]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Immediately after the preceding code, we render the skybox:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码之后，我们立即渲染天空盒：
- en: '[PRE40]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course, we don't need to render the environment--the reflections (and refractions)
    are stored in the texture. However, usually we also want to see the environment
    being reflected, not only the reflections.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不需要渲染环境--反射（和折射）存储在纹理中。然而，通常我们还想看到环境被反射，而不仅仅是反射。
- en: 'All the knowledge in this recipe combined with the *Rendering a geometry with
    a vertex diffuse lighting* recipe, should generate the results seen in the following
    image:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中所有知识的综合，加上*使用顶点漫反射灯光渲染几何体*配方，应该生成以下图像中看到的结果：
- en: '![](img/image_11_012.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_012.png)'
- en: See also
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    the recipe *Creating a combined image sampler*
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，配方*创建一个组合图像采样器*
- en: In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, the recipe *Providing data to shaders through push constants*
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录与绘制*中，配方*通过推送常量向着色器提供数据*
- en: 'In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    see the following recipes:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*中，查看以下配方：
- en: '*Loading texture data from a file*'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从文件加载纹理数据*'
- en: '*Loading a 3D model from an OBJ file*'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从OBJ文件加载3D模型*'
- en: The recipe *Rendering a geometry with a vertex diffuse lighting*, in this chapter
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的配方*使用顶点漫反射灯光渲染几何体*
- en: Adding shadows to the scene
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向场景添加阴影
- en: Lighting is one of the most important operations performed by 3D applications.
    Unfortunately, due to the specifics of graphics libraries and the graphics hardware
    itself, lighting calculations have one major drawback--they don't have information
    about positions of all drawn objects. That's why generating shadows requires a
    special approach and advanced rendering algorithms.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光是3D应用程序执行的最重要操作之一。不幸的是，由于图形库和图形硬件本身的特性，灯光计算有一个主要的缺点--它们没有所有绘制对象位置的信息。这就是为什么生成阴影需要特殊的方法和高级渲染算法。
- en: There are several popular techniques targeted at efficient generation of natural
    looking shadows. Now we will learn about a technique called shadow mapping.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 针对高效生成自然外观阴影，存在几种流行的技术。现在我们将学习一种称为阴影映射的技术。
- en: 'An example of an image generated with this recipe looks like:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配方生成的图像示例如下：
- en: '![](img/image_11_013.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_013.png)'
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The shadow mapping technique requires us to render a scene twice. Firstly, we
    render objects that cast shadows. They are rendered from the light's point of
    view. This way we store depth values in a depth attachment (color values are not
    required).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影映射技术要求我们渲染场景两次。首先，我们渲染投射阴影的对象。它们从灯光的视角进行渲染。这样我们就在深度附加中存储深度值（不需要颜色值）。
- en: Then, in the second step, we render the scene as we normally do, from the camera's
    point of view. Inside shaders we use the shadow map generated in the first step.
    The vertex position is projected onto the shadow map and its distance from the
    light position is compared with the value read from the shadow map. If it is greater,
    it means a given point is covered in shadow, otherwise it is normally lit.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二步中，我们以通常的方式渲染场景，从摄像机的视角。在着色器内部，我们使用第一步中生成的阴影映射。顶点位置被投影到阴影映射上，并与其与灯光位置的距离与从阴影映射中读取的值进行比较。如果它更大，这意味着给定点被阴影覆盖，否则它被正常照亮。
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Prepare the Vulkan resources as described in the *Rendering a geometry with
    a vertex diffuse lighting* recipe.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照配方*使用顶点漫反射灯光渲染几何体*中描述的步骤准备Vulkan资源。
- en: Load the 3D models with vertex positions and normal vectors. Store loaded data
    in a (vertex) buffer.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载带有顶点位置和法向量的3D模型。将加载的数据存储在（顶点）缓冲区中。
- en: Create a uniform buffer with `VK_BUFFER_USAGE_TRANSFER_DST_BIT` and `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`
    usages that are big enough to hold data for three 16-element matrices of floating-point
    values (refer to the *Creating a uniform buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`VK_BUFFER_USAGE_TRANSFER_DST_BIT`和`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`用法的统一缓冲区，其大小足以容纳三个16元素浮点值矩阵的数据（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建统一缓冲区*配方）。
- en: Create a staging buffer supporting a `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage,
    which is able to hold data for three matrices each with 16 floating-point elements.
    The buffer's memory object should be allocated on a memory that is host-visible
    (refer to the *Creating a buffer and Allocating and binding memory object to a
    buffer* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个支持`VK_BUFFER_USAGE_TRANSFER_SRC_BIT`使用的暂存缓冲区，该缓冲区能够容纳三个矩阵，每个矩阵有16个浮点元素。缓冲区的内存对象应在主机可见的内存上分配（参考第4章的*创建缓冲区和分配以及将内存对象绑定到缓冲区*配方[f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml]，*资源和内存*）。
- en: Create a combined image sampler that should act as a shadow map. The image should
    be two-dimensional with one of the supported depth formats (`VK_FORMAT_D16_UNORM`
    must always be supported), and should support `VK_IMAGE_USAGE_SAMPLED_BIT` and
    `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` usages (refer to the *Creating a
    combined image sampler* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个应作为阴影贴图使用的组合图像采样器。图像应为二维的，并支持一种支持的深度格式（`VK_FORMAT_D16_UNORM`必须始终支持），并且应支持`VK_IMAGE_USAGE_SAMPLED_BIT`和`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`使用（参考第5章的*创建组合图像采样器*配方[fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml]，*描述符集*）。
- en: 'Create a descriptor set layout with two descriptor resources: a uniform buffer
    accessed in a vertex shader at 0^(th) binding and with a combined image sampler
    accessed in a fragment shader at 1^(st) binding (refer to the *Creating a descriptor
    set layout* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个描述符资源的描述符集布局：一个在顶点着色器中以0^(th)绑定访问的统一缓冲区，以及一个在片段着色器中以1^(st)绑定访问的组合图像采样器（参考第5章的*创建描述符集布局*配方[fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml]，*描述符集*）。
- en: Create a descriptor pool, from which one uniform buffer descriptor and one combined
    image sampler descriptor can be allocated (refer to the *Creating a descriptor
    pool* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符池，从中可以分配一个统一缓冲区描述符和一个组合图像采样器描述符（参考第5章的*创建描述符池*配方[fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml]，*描述符集*）。
- en: A descriptor set from the created pool using the descriptor set layout with
    a uniform buffer and a combined image sampler resources (refer to the *Allocating
    descriptor sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建的池中使用具有统一缓冲区和组合图像采样器资源（参考第5章的*分配描述符集*配方[fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml]，*描述符集*）的描述符集布局。
- en: Update (populate) the descriptor set with the uniform buffer accessed at the
    0^(th) binding and with the created combined image sampler (shadow map) accessed
    at the 1^(st) binding. Provide a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
    value as the image's layout (refer to the *Updating descriptor sets* recipe from
    [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在0^(th)绑定访问的统一缓冲区和在1^(st)绑定访问的创建的组合图像采样器（阴影贴图）更新（填充）描述符集。提供`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`值作为图像的布局（参考第5章的*更新描述符集*配方[fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml]，*描述符集*）。
- en: Prepare data for a render pass used for drawing the whole scene into the shadow
    map. This render pass should have only one attachment, which has the same format
    as the combined image sampler's format. The image should be cleared on load, its
    initial layout may be undefined. The image contents should be stored at the end
    of the render pass and the final layout should be set to a `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
    (refer to the *Specifying attachments descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备用于将整个场景绘制到阴影贴图中的渲染通道的数据。此渲染通道应只有一个附件，其格式与组合图像采样器的格式相同。图像在加载时应该清除，其初始布局可能未定义。图像内容应在渲染通道结束时存储，最终布局应设置为`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`（参考第6章的*指定附件描述*配方[2de4339d-8912-440a-89a6-fd1f84961448.xhtml]，*渲染通道和帧缓冲区*）。
- en: The render pass used for shadow map generation should have just one subpass
    with only a depth attachment, for which framebuffer's 0^(th) attachment with a
    `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` layout should be used (refer
    to the *Specifying subpass descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于生成阴影图的渲染通道应只有一个子通道，并且只有一个深度附件，应使用帧缓冲区的 0^(th) 附件，其布局为 `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`（参考
    [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的 *指定子通道描述* 菜谱）。
- en: 'Specify two subpass dependencies for the render pass (refer to the *Specifying
    dependencies between subpasses* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*). Use the following values for the first dependency:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为渲染通道指定两个子通道依赖项（参考 [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的
    *指定子通道之间的依赖项* 菜谱）。对于第一个依赖项使用以下值：
- en: '`VK_SUBPASS_EXTERNAL` value for `srcSubpass`'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SUBPASS_EXTERNAL` 对应于 `srcSubpass` 的值'
- en: '`0` value for `dstSubpass`'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 对应于 `dstSubpass`'
- en: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` value for `srcStageMask`'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` 对应于 `srcStageMask` 的值'
- en: '`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` value for `dstStageMask`'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` 对应于 `dstStageMask` 的值'
- en: '`VK_ACCESS_SHADER_READ_BIT` value for `srcAccessMask`'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_SHADER_READ_BIT` 对应于 `srcAccessMask` 的值'
- en: '`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` value for `dstAccessMask`'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` 对应于 `dstAccessMask` 的值'
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DEPENDENCY_BY_REGION_BIT` 对应于 `dependencyFlags` 的值'
- en: 'Use the following values for the second render pass dependency:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下值设置第二个渲染通道的依赖项：
- en: '`0` value for `srcSubpass`'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 对应于 `srcSubpass`'
- en: '`VK_SUBPASS_EXTERNAL` value for `dstSubpass`'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SUBPASS_EXTERNAL` 对应于 `dstSubpass` 的值'
- en: '`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` value for `srcStageMask`'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` 对应于 `srcStageMask` 的值'
- en: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` value for `dstStageMask`'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` 对应于 `dstStageMask` 的值'
- en: '`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` value for `srcAccessMask`'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` 对应于 `srcAccessMask` 的值'
- en: '`VK_ACCESS_SHADER_READ_BIT` value for `dstAccessMask`'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_ACCESS_SHADER_READ_BIT` 对应于 `dstAccessMask` 的值'
- en: '`VK_DEPENDENCY_BY_REGION_BIT` value for `dependencyFlags`'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DEPENDENCY_BY_REGION_BIT` 对应于 `dependencyFlags` 的值'
- en: Create a render pass using the above parameters (refer to the *Creating a render
    pass* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render
    Passes and Framebuffers*).
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上述参数创建一个渲染通道（参考 [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的
    *创建渲染通道* 菜谱）。
- en: Create a framebuffer compatible with the created render pass. The Framebuffer
    should have one attachment, for which the image view created along with the shadow
    map's combined image sampler should be used. Framebuffer should also have the
    same dimensions as the shadow map image (refer to the *Creating a framebuffer*
    recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*).
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与创建的渲染通道兼容的帧缓冲区。帧缓冲区应有一个附件，应使用与阴影图组合图像采样器一起创建的图像视图。帧缓冲区还应具有与阴影图图像相同的尺寸（参考
    [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的 *创建帧缓冲区* 菜谱）。
- en: Create a second render pass used for drawing the scene normally into a swapchain
    (refer to the *Rendering a geometry with a vertex diffuse lighting* recipe).
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于将场景正常绘制到交换链中的第二个渲染通道（参考 *使用顶点漫反射光照渲染几何体* 菜谱）。
- en: Create a pipeline layout using the prepared descriptor set layout. Also, specify
    a single push constant range accessed by a vertex shader stage, beginning at a
    0^(th) offset and of a `4 * sizeof( float )` size (refer to the *Creating a pipeline
    layout* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*).
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用准备好的描述符集布局创建一个管道布局。同时，指定一个由顶点着色器阶段访问的单个推送常量范围，从 0^(th) 偏移开始，大小为 `4 * sizeof(
    float )`（参考 [第 8 章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中的 *创建管道布局*
    菜谱）。
- en: 'Create a graphics pipeline used for drawing a scene into the shadow map. Start
    by creating a shader module for a vertex shader stage using a SPIR-V assembly
    generated from the following GLSL code (refer to the *Converting GLSL shaders
    to SPIR-V assemblies* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders* and to *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于将场景绘制到阴影图中的图形管线。首先，使用从以下GLSL代码生成的SPIR-V汇编创建一个用于顶点着色器阶段的着色器模块（参考第7章中*将GLSL着色器转换为SPIR-V汇编*的配方，[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*和*创建着色器模块*的配方，[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）：
- en: '[PRE41]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Specify pipeline shader stages with a vertex shader only, which uses a `main`
    function from the prepared shader module (refer to the *Specifying pipeline shader*
    stages recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics
    and Compute Pipelines*).
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用顶点着色器指定管线着色器阶段，它使用已准备的着色器模块中的`main`函数（参考第8章中*指定管线着色器阶段*的配方，[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）。
- en: 'Specify a pipeline vertex input state with one attribute that is read from
    the 0^(th) binding. The binding should be created with data read per vertex and
    a stride equal to `6 * sizeof( float )` (refer to the *Specifying pipeline vertex
    input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*). The attribute should have the following parameters:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个具有从0^(th)绑定读取的一个属性的管线顶点输入状态。绑定应使用每个顶点读取的数据和等于`6 * sizeof( float )`的步长创建（参考第8章中*指定管线顶点输入状态*的配方，[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）。该属性应具有以下参数：
- en: '`0` value for `location`'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`的值为`0`'
- en: '`0` value for `binding`'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`的值为`0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`的值为`VK_FORMAT_R32G32B32_SFLOAT`'
- en: '`0` value for `offset`'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`的值为`0`'
- en: Specify the viewport and scissor test parameters with one viewport, whose dimensions
    match the size of the shadow map image (refer to the *Specifying pipeline viewport
    and scissor test state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个与阴影图大小匹配的视口和裁剪测试参数指定视口和裁剪测试参数，参考第8章中*指定管线视口和裁剪测试状态*的配方（[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）。
- en: Create a graphics pipeline using the previously specified parameters. Skip the
    blending state, because the render pass used for the shadow map generation doesn't
    have any color attachments (rasterization must be enabled though, because otherwise
    no fragments will be generated and their depth won't be stored in the shadow map).
    Also, don't use dynamic states, because the size of the shadow map doesn't change
    (refer to the *Creating graphics pipelines* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前指定的参数创建一个图形管线。跳过混合状态，因为用于阴影图生成的渲染通道没有任何颜色附件（尽管必须启用光栅化，否则不会生成片段，并且它们的深度不会存储在阴影图中）。另外，不要使用动态状态，因为阴影图的大小不会改变（参考第8章中*创建图形管线*的配方，[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）。
- en: 'Create another graphics pipeline used for rendering a shadowed scene. This
    time, create a shader module for a vertex shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个用于渲染阴影场景的图形管线。这次，使用从以下GLSL代码生成的SPIR-V汇编创建一个用于顶点着色器阶段的着色器模块：
- en: '[PRE42]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a shader module for a fragment shader stage using a SPIR-V assembly
    generated from the following GLSL code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从以下GLSL代码生成的SPIR-V汇编创建一个用于片段着色器阶段的着色器模块：
- en: '[PRE43]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Specify pipeline shader stages with vertex and fragment shaders, both using
    a `main` function from a respective shader modules.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器指定管线着色器阶段，两者都使用相应着色器模块中的`main`函数。
- en: 'Specify a pipeline vertex input state with two attributes that are read from
    the same 0^(th) binding. The binding should be created with data read per vertex
    and a stride equal to `6 * sizeof( float )`. The first attribute should have the
    following parameters:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个具有从同一0^(th)绑定读取的两个属性的管线顶点输入状态。绑定应使用每个顶点读取的数据和等于`6 * sizeof( float )`的步长创建。第一个属性应具有以下参数：
- en: '`0` value for `location`'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`的值为`0`'
- en: '`0` value for `binding`'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`的值为`0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`的值为`VK_FORMAT_R32G32B32_SFLOAT`'
- en: 0 value for `offset`
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`的值为`0`'
- en: 'The second attribute should have the following definition:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个属性应具有以下定义：
- en: '`1` value for `location`'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`的值为`1`'
- en: '`0` value for `binding`'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`的值为`0`'
- en: '`VK_FORMAT_R32G32B32_SFLOAT` value for `format`'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`的值为`VK_FORMAT_R32G32B32_SFLOAT`'
- en: '`3 * sizeof( float )` value for `offset`'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`的值为`3 * sizeof( float )`'
- en: Create a graphics pipeline for rendering the shadowed scene using the above
    shader stages and two attributes, with the rest of the parameters similar to those
    defined in the *Rendering a geometry with a vertex diffuse lighting* recipe.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上述着色阶段和两个属性创建一个用于渲染阴影场景的图形管线，其余参数与*使用顶点漫反射光照渲染几何体*配方中定义的类似。
- en: Prepare a view matrix, which can be a multiplication of rotation, scaling and
    translation matrices used to draw the scene from the light's perspective (refer
    to the *Preparing a translation matrix*, *Preparing a rotation matrix* and *Preparing
    a scaling matrix* recipes from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*). Copy the contents of the concatenated matrix to the staging
    buffer at a `0` offset (refer to the *Mapping, updating and unmapping host-visible
    memory* recipe from [Chapter 4](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Resources
    and Memory*).
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个视图矩阵，这可以是旋转、缩放和平移矩阵的乘积，用于从光的角度绘制场景（参考第10章的*准备平移矩阵*、*准备旋转矩阵*和*准备缩放矩阵*配方，*辅助配方*）。将连接矩阵的内容复制到偏移量为`0`的暂存缓冲区（参考第4章的*映射、更新和取消映射主机可见内存*配方，*资源和内存*）。
- en: Prepare a view matrix used to draw the scene normally, from the camera's perspective.
    Copy the contents of this matrix to the staging buffer at a `16 * sizeof( float
    )` offset.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个用于从相机视角正常绘制场景的视图矩阵。将此矩阵的内容复制到偏移量为`16 * sizeof( float )`的暂存缓冲区。
- en: Prepare a perspective projection matrix based on the aspect ratio of the swapchain's
    dimensions (refer to the *Preparing a perspective projection matrix* recipe from
    [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*). Copy
    the contents of the matrix to the staging buffer at a `32 * sizeof( float )`.
    Remember to recreate the projection matrix and copy it to the staging buffer each
    time the application's window is resized (refer to the *Mapping, updating and
    unmapping host-visible memory* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据交换链尺寸的纵横比准备一个透视投影矩阵（参考第10章的*准备透视投影矩阵*配方，*辅助配方*）。将矩阵的内容复制到偏移量为`32 * sizeof(
    float )`的暂存缓冲区。记住，每次应用程序窗口大小调整时，都要重新创建投影矩阵并将其复制到暂存缓冲区（参考第4章的*映射、更新和取消映射主机可见内存*配方，*资源和内存*）。
- en: 'In each frame of animation, record a command buffer. Start by checking whether
    any of the view or projection matrices were modified: if they were, copy the contents
    of the staging buffer to the uniform buffer, guarded by the proper pipeline barriers
    (refer to the *Copying data between buffers* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画的每一帧中，记录一个命令缓冲区。首先检查视图或投影矩阵是否被修改：如果被修改，则将暂存缓冲区的内容复制到统一缓冲区，由适当的管线屏障保护（参考第4章的*在缓冲区之间复制数据*配方，*资源和内存*）。
- en: Begin a render pass used for drawing the scene from the light's perspective
    into the shadow map. Bind the vertex buffer, descriptor set, and the pipeline
    used to fill the shadow map. Draw the geometry and end the render pass.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从光的角度绘制场景到阴影图的渲染通道开始。绑定顶点缓冲区、描述符集以及用于填充阴影图的管线。绘制几何体并结束渲染通道。
- en: Transfer ownership of the acquired swapchain image if necessary. Set the viewport
    and scissor test states dynamically, bind the graphics pipeline created for rendering
    the shadowed scene, and draw the geometry once again. End the command buffer recording,
    submit the command buffer to the queue, and present an image.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，转让获取的交换链图像的所有权。动态设置视口和裁剪测试状态，绑定用于渲染阴影场景的图形管线，并再次绘制几何体。结束命令缓冲区记录，将命令缓冲区提交到队列，并呈现图像。
- en: How it works...
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by creating a combined image sampler, in which depth information from
    the light''s perspective will be stored:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个组合图像采样器，其中将存储来自光的角度的深度信息：
- en: '[PRE44]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The combined image sampler, along with uniform buffer, will be accessed in
    shaders, so we need a descriptor set through which shaders will have access to
    both. Despite the fact that we render the scene twice using two different pipelines,
    we can use one descriptor set to avoid unnecessary state switching:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 组合图像采样器，连同统一缓冲区，将在着色器中被访问，因此我们需要一个描述符集，通过它着色器可以访问两者。尽管我们使用两个不同的管线渲染场景两次，但我们仍然可以使用一个描述符集来避免不必要的状态切换：
- en: '[PRE45]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We also need to populate the descriptor set with the handles of a uniform buffer
    and the combined image sampler:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要用统一缓冲区和组合图像采样器的句柄填充描述符集：
- en: '[PRE46]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step is to create a dedicated render pass for storing the depth information
    in the shadow map. It doesn''t use any color attachments, because we only need
    depth data. We also create a framebuffer. It can have fixed dimensions as we don''t
    change the size of the shadow map:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为存储阴影图中的深度信息创建一个专门的渲染通道。它不使用任何颜色附件，因为我们只需要深度数据。我们还创建了一个帧缓冲区。它可以具有固定尺寸，因为我们不会改变阴影图的大小：
- en: '[PRE47]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we create two graphics pipelines. They both use the same push constant
    range to lower the number of variables (though only the second pipeline uses it
    in shaders):'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个图形管线。它们都使用相同的推送常量范围来降低变量的数量（尽管只有第二个管线在着色器中使用它）：
- en: '[PRE48]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first pipeline is for the shadow map generation. It uses very simple shaders
    that read only vertex positions and render the scene from the light's point of
    view.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管线用于生成阴影图。它使用非常简单的着色器，只读取顶点位置，并从光源的角度渲染场景。
- en: 'The second pipeline renders the scene normally into the swapchain image. Its
    shaders are more complicated. A vertex shader calculates the position normally,
    but also converts the normal vector and the light vector into the view space for
    correct lighting calculations:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个管线将场景正常渲染到交换链图像中。其着色器更复杂。顶点着色器正常计算位置，但还将法线向量和光向量转换为视图空间，以进行正确的光照计算：
- en: '[PRE49]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The most important thing that the vertex shader does is to calculate the vertex''s
    position in the light source''s view space. To do this, we multiply it by the
    light''s model-view and projection matrices (perspective division is done in the
    fragment shader). The acquired result is used to fetch data from the shadow map.
    However, the calculated position values (after perspective division) are in the
    `-1.0 - 1.0` range and reading data from textures using normalized texture coordinates
    requires providing the values in the `0.0 - 1.0` range. That''s why we need to
    bias the result:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器最重要的任务是计算顶点在光源视图空间中的位置。为此，我们将其乘以光源的模型视图和投影矩阵（透视除法在片段着色器中完成）。获得的结果用于从阴影图中获取数据。然而，计算出的位置值（在透视除法之后）位于`-1.0
    - 1.0`范围内，使用归一化纹理坐标从纹理中读取数据需要提供`0.0 - 1.0`范围内的值。这就是为什么我们需要偏置结果：
- en: '[PRE50]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This way the fragment shader can project the interpolated position onto the
    shadow map and read the value from a proper coordinate:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，片段着色器可以将插值后的位置投影到阴影图上，并从适当的坐标读取值：
- en: '[PRE51]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The value read from the shadow map is compared with the point's distance from
    the light's position (offset by a small value). If the distance is greater than
    the value stored in the shadow map, the point is lying in a shadow and shouldn't
    be lit. We need to add the small offset, so the surface of an object doesn't cast
    shadows on itself (only on parts that are further away). We also don't fully discard
    the lighting to avoid the shadows being too dark, hence the value `0.5` assigned
    to the shadow variable.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 从阴影图中读取的值与点与光源位置的距离（偏移一个小值）进行比较。如果距离大于阴影图中存储的值，则该点位于阴影中，不应该被照亮。我们需要添加这个小偏移，这样物体的表面就不会对自己产生阴影（只对更远的部分产生阴影）。我们也不完全丢弃光照，以避免阴影过于黑暗，因此将`0.5`分配给阴影变量。
- en: The above calculations can be performed using a `textureProj()`and a `sampler2DShadow`.
    This way perspective division, offsetting the distance and comparing it to a reference
    value is performed automatically.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 上述计算可以使用`textureProj()`和`sampler2DShadow`执行。这样，透视除法、偏移距离并将其与参考值比较是自动完成的。
- en: 'The rest of the resources created in this recipe are similar to those presented
    in the *Rendering a geometry with a vertex diffuse lighting* recipe. Rendering/recording
    a command buffer requires us, apart from the usual stuff, to render the scene
    twice. Firstly, we fill the shadow map by drawing all objects from the light''s
    perspective. The shadow map is then used during the rendering of all the objects
    normally from the camera''s perspective:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中创建的其他资源与*使用顶点漫反射光照渲染几何体*食谱中展示的资源类似。渲染/记录命令缓冲区需要我们，除了常规内容外，还要将场景渲染两次。首先，我们从光源的角度绘制所有对象以填充阴影图。然后，在从相机视角渲染所有对象的过程中使用阴影图：
- en: '[PRE52]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following image shows different models casting shadows on a flat plane:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了不同模型在平坦平面上投射的阴影：
- en: '![](img/image_11_014.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_11_014.png)'
- en: See also
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，“描述符集”，查看以下食谱：
- en: '*Creating a combined image sampler*'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组合图像采样器*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，“渲染通道和帧缓冲区”，查看以下食谱：
- en: '*Creating a render pass*'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Creating a framebuffer*'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: The recipe *Rendering a geometry with a vertex diffuse lighting*, in this chapter
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的食谱*使用顶点漫反射光照渲染几何体*
