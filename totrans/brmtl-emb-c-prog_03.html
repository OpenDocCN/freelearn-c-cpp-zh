<html><head></head><body>
<div><div><div><h1 id="_idParaDest-56" class="chapter-number"><a id="_idTextAnchor080"/>3</h1>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor081"/>Understanding the Build Process and Exploring the GNU Toolchain</h1>
			<p>Bare-metal programming is <a id="_idIndexMarker209"/>a journey of deep understanding and precision, and in this chapter, we will navigate the complex realm of the embedded firmware build process. Our focus is the GNU Arm Toolchain, an important element in firmware development. Through a blend of theory and hands-on programming exercises, you will gain insights into how <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>) streamline the build process and how these processes can be manually replicated using the GNU Arm Toolchain.</p>
			<p>As the chapter progresses, we delve into the nuances of the compiler and its various options, tailored for Arm Cortex microcontrollers. The programming exercise in this chapter is designed to help you understand and effectively utilize the GNU tools, from compiling and linking to analyzing the depths of the output object files.</p>
			<p>In this chapter, we shall cover the following main topics:<a id="_idTextAnchor082"/></p>
			<ul>
				<li>The foundations – understanding the embedded build process<a id="_idTextAnchor083"/></li>
				<li>A tour of GNU binary tools for embedded systems</li>
				<li>From IDE to command-line – watching the build process unfold</li>
			</ul>
			<p>By the end of the chapter, you will have an understanding of the embedded firmware build process and have developed the skills to fluidly switch between IDEs and command-line interfaces, enhancing your versatility as a firmware developer.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.<a id="_idTextAnchor085"/></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor086"/>The foundations – understanding the embedded build process</h1>
			<p>The<a id="_idIndexMarker210"/> journey from high-level source code in embedded firmware development to an executable binary image is intricate and multilayered. This process is<a id="_idIndexMarker211"/> commonly referred to as the firmware build process and involves several critical stages – pre-processing, compilation, assembly, linking, and locating. Each of these stages plays an important role in transforming human-readable code into machine-executable instructions. <em class="italic">Figure 3</em><em class="italic">.1</em> shows the entire build process and the tools involved at each stage of the process.</p>
			<div><div><img src="img/B21914_03_01.jpg" alt="Figure 3.1: The build process, detailing the input and output files for each stage and the specific tools used" width="1171" height="474"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: The build process, detailing the input and output files for each stage and the specific tools used</p>
			<p>Let’s examine the stages.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor087"/>The pre-processing stage</h2>
			<p>Pre-processing is<a id="_idIndexMarker212"/> the initial stage in the firmware build process. In this stage, the source code undergoes a series of transformations to prepare it for compilation. Typically, source files in embedded systems are written in C (<code>.c</code> files) and accompanied by header files (<code>.h</code> files). The preprocessor is the specialized tool in the build process whose task is to handle these input files.</p>
			<p>During pre-processing, the preprocessor executes several key operations:</p>
			<ul>
				<li><strong class="bold">Stripping comments</strong>: Comments, which are crucial for human readability but irrelevant for machines, are removed from code.</li>
				<li><code>#</code> symbol, known as preprocessor directives, are processed. These directives often include macro definitions (<code>#define</code>), conditional compilation instructions (<code>#ifdef</code>, <code>#ifndef</code>, <code>#endif</code>), and file inclusion commands (<code>#include</code>). The preprocessor <a id="_idIndexMarker213"/>replaces these directives with their defined values or corresponding code segments.</li>
				<li><code>.i</code> extension. These files represent the transformed source code, devoid of comments and with all directives evaluated.</li>
			</ul>
			<p>The next stage is the compilation sta<a id="_idTextAnchor088"/>ge.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor089"/>The compilation stage</h2>
			<p>Compilation starts<a id="_idIndexMarker214"/> immediately after pre-processing. The compiler’s role is to take <code>.i</code> files and convert them into architecture-specific assembly code. This phase is where the high-level constructs of <code>C</code> are translated into the lower-level, more granular assembly instructions understood by the target processor architecture.</p>
			<p>This stage involves the following:</p>
			<ul>
				<li><code>.</code><code>i</code> files</li>
				<li><strong class="bold">Process</strong>: The compiler analyzes the code structure, optimizes it for performance and space, and translates it into assembly language</li>
				<li><code>.</code><code>s</code> extension</li>
			</ul>
			<p>The next stage makes use of the <code>.</code><code>s</code> files.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor090"/>The assembly stage</h2>
			<p>Assembly is <a id="_idIndexMarker215"/>the stage where the <code>.s</code> files containing assembly code are converted into machine code, in the form of <strong class="bold">object files</strong>. This<a id="_idIndexMarker216"/> stage translates the human-readable assembly instructions into a binary format.</p>
			<p>This stage involves the following:</p>
			<ul>
				<li><code>.s</code>).</li>
				<li><strong class="bold">Process</strong>: The assembler interprets each assembly instruction and converts it into corresponding machine code.</li>
				<li><code>.o</code> extension. These files contain binary code and are ready for the next stage of li<a id="_idTextAnchor091"/>nking.</li>
			</ul>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor092"/>The linking stage</h2>
			<p>Linking<a id="_idIndexMarker217"/> is the stage where all individual object files are combined to form a cohesive program. This stage also integrates any necessary standard library files and resolves references between different code m<a id="_idTextAnchor093"/>odules.</p>
			<p>This stage involves the following:</p>
			<ul>
				<li><code>.o</code>) and C standard library files.</li>
				<li><strong class="bold">Process</strong>: The linker stitches together all object files, resolving symbolic references and addresses. It handles tasks such as memory allocation for variables and functions.</li>
				<li><strong class="bold">Output</strong>: The linker generates a <strong class="bold">relocatable file</strong>, which<a id="_idIndexMarker218"/> is comprehensive but not yet final executable code.</li>
			</ul>
			<p>A relocatable file is intermediate output in the firmware build process, which is created during the linking stage. It’s a comprehensive file that combines all individual object files <code>(.o)</code> and the necessary library. However, it is not yet a final executable. The concept of <strong class="bold">relocation</strong> plays an important role here. Relocation involves adjusting the symbolic addresses in the relocatable file to actual, specific memory locations. This process ensures that when the firmware runs on a target device, each part of the code and data is correctly placed in memory. The relocatable file contains all the necessary components of the firmware, but with addresses that are still “relative” – they need further adjustment <a id="_idIndexMarker219"/>during the locating stage to fit the unique memory map of the target microcontroller, leading to the creation of the final executable.</p>
			<p>The next stage is where we finally get our executable code.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor094"/>The locating stage</h2>
			<p>This is <a id="_idIndexMarker220"/>the last stage; it involves converting the relocatable file into the final executable binary. This stage is guided by a linker script, which provides essential information about the memory layout of the target device.</p>
			<p>This stage involves the following:</p>
			<ul>
				<li><strong class="bold">Input</strong>: A relocatable file and a linker script.</li>
				<li><strong class="bold">Process</strong>: The locator uses the linker script to place code and data sections into their designated memory locations. It adjusts addresses and offsets to fit the target’s memory map.</li>
				<li><strong class="bold">Output</strong>: An executable binary file, typically in formats such as <strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>) or a<a id="_idIndexMarker221"/> plain binary format.</li>
			</ul>
			<p>With this knowledge in hand, we are well-equipped to delve into the GNU Toolchain for Arm. Our goal is to effectively utilize specific tools within the toolchain to execute the various stages of the build process. This will be the focus of the next section.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor095"/>A tour of GNU binary tools for embedded systems</h1>
			<p>In this<a id="_idIndexMarker222"/> section, we’ll delve into the GNU Bin tools, a suite of tools that come with the installation of the GNU Toolchain for Arm. These tools (commands) are essential for the various stages of the firmware build process, as well as additional tasks such as debugging.</p>
			<p>The first command we’ll explore is <code>arm-no<a id="_idTextAnchor096"/>ne-eabi-gcc</code>.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor097"/>arm-none-eabi-gcc</h2>
			<p>Let’s break<a id="_idIndexMarker223"/> down<a id="_idIndexMarker224"/> the components of the command:</p>
			<ul>
				<li><code>arm</code>: This specifies the target architecture.</li>
				<li><code>none</code>: This component indicates the operating system for which the code is being compiled. Here, <code>none</code> signifies that the code is meant for a bare-metal environment, meaning it will run directly on the hardware without an underlying operating system.</li>
				<li><code>eabi</code>: This stands<a id="_idIndexMarker225"/> for <strong class="bold">Embedded Application Binary Interface</strong>. EABI defines a standard for the binary layout of system and user programs, libraries, and so on. It ensures that the compiled code will work correctly on any Arm processor that adheres to the EABI standard.</li>
				<li><code>gcc</code>: This is <a id="_idIndexMarker226"/>short for <strong class="bold">GNU </strong><strong class="bold">Compiler Collection</strong>.</li>
			</ul>
			<p>This single command compiles, assembles, and links our input code in one go. To use it, type <code>arm-none-eabi-gcc</code> in the command prompt or terminal, followed by the source file, then <code>-o</code>, and the desired output filename.</p>
			<p>See <em class="italic">Figure 3</em><em class="italic">.2</em> for an example:</p>
			<div><div><img src="img/B21914_03_02.jpg" alt="Figure 3.2: Usage of the arm-none-eabi-gcc command" width="1191" height="394"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Usage of the arm-none-eabi-gcc command</p>
			<p>In this example, we specify the source file as <code>main.c</code> and the output file as <code>main.o.</code></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor098"/>Some common compiler flags</h2>
			<p>Since<a id="_idIndexMarker227"/> we have just introduced the <code>-o</code> compiler flag, let’s take this opportunity to introduce some of the other commonly used compiler flags. These compiler flags are used to modify command behavior as well as add options to commands:</p>
			<ul>
				<li><code>-c</code>: This flag is used to compile and assemble but not link. When added to the command, it processes the code up to the assembly stage but stops before linking.</li>
				<li><code>-o file</code>: As mentioned earlier, this specifies the name of the output file.</li>
				<li><code>-g</code>: Generates debugging information in the executable.</li>
				<li><code>-Wall</code>: Enables all warning messages, helping us identify potential issues in the code.</li>
				<li><code>-Werror</code>: Treats all warnings as errors, ensuring code quality and stability.</li>
				<li><code>-I [DIR]</code>: Includes a specified directory to search for header files; it’s useful for organizing large projects.</li>
				<li><code>-ansi</code> and <code>-std=STANDARD</code>: These flags specify which standard version of the c language should be used.</li>
				<li><code>-v</code>: Provides verbose output from GCC, giving us detailed information about the comp<a id="_idTextAnchor099"/>ilation process.</li>
			</ul>
			<p><em class="italic">Table 3.1</em> provides a summary of the flags and example usage for each flag.</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Flag</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Purpose</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Example usage</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-c</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Compile and assemble but don’t link</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>c source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>o file</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Link to the output file, named file</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc source_file -</code><code>o output_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-g</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate debugging info in the executable</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>g source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>Wall</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Enable all warning messages</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>Wall source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>Werror</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Treat warnings as errors</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>Werror source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>I [DIR]</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Include a directory for header files</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -I </code><code>directory_path source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>ansi</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Use the <strong class="bold">American National Standards Institute</strong> (<strong class="bold">ANSI</strong>) standard</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>ansi source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>std</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Specify a standard version (e.g., C11)</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>std=c11 source_file</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-v</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Verbose output from GCC</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-gcc -</code><code>v source_file</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1: Some compiler flags and their example usage</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor100"/>Some architecture-specific flags</h2>
			<p>In addition<a id="_idIndexMarker228"/> to the general compiler flags, there are several architecture-specific flags that enable precise configuration for various processor architectures. These flags are integral for tailoring the build process to specific ARM processors and their respective architectures. Let’s delve into some of the most frequently used architecture-specific flags:</p>
			<ul>
				<li><code>-mcpu=[NAME]</code>: Specifies the target ARM processor. Using this option configures the compiler to optimize the code for a specific processor.</li>
				<li><code>march=[NAME]</code>: Specifies the target ARM architecture. It configures the compiler for a particular ARM architecture version.</li>
				<li><code>-mtune=[NAME]</code>: Similar to <code>-mcpu</code>, this specifies the target ARM processor for optimization purposes.</li>
				<li><code>-thumb</code>: Configures the compiler to generate code for the Thumb instruction set, which is a compressed version of the standard ARM instruction set, providing more code density and efficiency.</li>
				<li><code>-marm</code>: Instructs the compiler to generate code for the ARM instruction set.</li>
				<li><code>-mlittle-endian</code>/<code>-mbig-endian</code>: These options specify the endianness for the generated code. Little-endian is the most common format in ARM processors.</li>
			</ul>
			<p>Let’s see an <a id="_idIndexMarker229"/>example involving some of these flags:</p>
			<div><div><img src="img/B21914_03_03.jpg" alt="Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific flags" width="1556" height="337"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific flags</p>
			<p>In this example, we say the following:</p>
			<ul>
				<li><code>-c</code>: Compile and assemble but do not link</li>
				<li><code>-mcpu=cortex-m4</code>: Build for the Cortex-M4 processor</li>
				<li><code>-mthumb</code>: Use the Thumb instruction set</li>
				<li><code>-o main.o</code>: Output the compiled file as <code>main.o</code><code><a id="_idTextAnchor101"/></code></li>
			</ul>
			<p><em class="italic">Table 3.2</em> provides a summary of the architecture-specific flags and example usage for each flag.</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Flag</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Purpose</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Example usage</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>mcpu=[NAME]</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Specify the target ARM processor</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>mcpu=cortex-m4</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>march=[NAME]</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Specify the target ARM architecture</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>march=armv7-m</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>mtune=[NAME]</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Optimize for a specific ARM processor</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>mtune=cortex-m4</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>thumb</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for the Thumb instruction set</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>mthumb</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>marm</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for the ARM instruction set</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>marm</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>mlittle-endian</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for little-endian mode</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>mlittle-endian</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>mbig-endian</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for big-endian mode</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>mbig-endian</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2: Some architecture-specific compiler flags and their example usage</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor102"/>Other commands in the GNU Toolchain for Arm</h2>
			<p>Apart from the <code>arm-none-eabi-gcc</code> command, there are other important commands that we will<a id="_idIndexMarker230"/> frequently use when building with the GNU toolchain for Arm. Let’s examine some of these commands:</p>
			<ul>
				<li><code>arm-none-eabi-nm</code>: The <code>arm-none-eabi-nm</code> command is a handy tool for listing the<a id="_idIndexMarker231"/> symbols from an object file. Symbols in this context refer to various identifiers in a program, such as function names, variable names, and constants. This tool is invaluable for examining the contents of compiled files, offering us insights into the structure and components of our program. This can be particularly useful for debugging purposes.</li>
				<li><code>arm-none-eabi-size</code>: In<a id="_idIndexMarker232"/> embedded firmware development, where memory resources are often limited, understanding the memory footprint of different sections of our code is crucial. This tool provides valuable insights into how much memory the various parts of our code consume, allowing us to make informed decisions about optimization and memory management.</li>
				<li><code>arm-none-eabi-objdump</code>: This<a id="_idIndexMarker233"/> tool is used to extract and display detailed information from object files. It offers an in-depth view of the machine instructions, making it an invaluable resource for thorough analysis of object files. This includes capabilities such as disassembling code, presenting section headers, and revealing symbol tables. Its utility becomes crucial when we need to delve into the intricate details of compiled code, providing clarity on a file’s structure, content, and operational mechanics. This helps us to both debug and optimize our code.<p class="list-inset">Disassembling<a id="_idIndexMarker234"/> code refers to the process of converting machine code, which is a set of binary instructions that a computer’s processor can execute directly, back into assembly language. Assembly language is a more human-readable form of instructions, although it’s still quite low-level compared to the C language. <em class="italic">Figure 3</em><em class="italic">.4</em> presents a comparison of C-language code, its corresponding assembly language translation, and the resulting machine code.</p></li>
			</ul>
			<div><div><img src="img/B21914_03_04.jpg" alt="Figure 3.4: C-language code, its corresponding assembly language code, and the resulting machine code" width="883" height="204"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: C-language code, its corresponding assembly language code, and the resulting machine code</p>
			<ul>
				<li><code>arm-none-eabi-reade<a id="_idTextAnchor103"/>lf</code>: This tool provides detailed information about the <a id="_idIndexMarker235"/>output ELF file, including section headers, program headers, and symbol tables. It is useful when we work with ELF files, as it offers insights into how an executable is structured and prepared to run on a system.</li>
				<li><code>: arm-none-eabi-objcopy</code>: We <a id="_idIndexMarker236"/>use this tool to convert object files from one format to another or to make a copy of an object file.</li>
			</ul>
			<p><em class="italic">Table 3.3</em> provides a summary of these additional tools and example usage for each tool.</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Tool</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Example Usage</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-nm</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists symbols from object files</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-nm [</code><code>object file]</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-size</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists section sizes of object/executable files</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-size [file]</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code><a id="_idTextAnchor104"/></code><code>arm-none-eabi-objdump</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Dumps information about object files</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-objdump [options] [</code><code>object file]</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-readelf</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays information about ELF files</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-readelf [options] [</code><code>ELF file]</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-objcopy</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Converts/copies object files between formats</p>
						</td>
						<td class="No-Table-Style">
							<p><code>arm-none-eabi-objcopy [options] [input file] [</code><code>output file]</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.3: Some common commands in the GNU toolchain for Arm and their example usage</p>
			<p>In this section, we explored the GNU Binary Tools that are essential for embedded firmware development. These tools, including commands such as <code>arm-none-eabi-gcc</code>, play important roles in various stages of the firmware build process and are invaluable for tasks such as compiling, linking, and debugging. The next section will further expand our understanding of these tools; we’ll dive into their practical applications, demonstrating their utility in the embedded firmware build process.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor105"/>From IDE to the command line – watching the build process unfold</h1>
			<p>In this section, our aim is to understand how the compiler within the IDE handles our code when we initiate a build. Additionally, we will delve into the practical applications of some of the GNU Binary Tools we discussed in the previous section.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor106"/>Observing the build process from the IDE’s perspective</h2>
			<p>Let’s start by revisiting<a id="_idIndexMarker237"/><a id="_idIndexMarker238"/><a id="_idIndexMarker239"/> the bare-metal GPIO driver we developed in the previous chapter.</p>
			<p>Begin by launching your STM32CubeIDE. To conduct a proper analysis of the build commands that the IDE executes, it’s necessary to first clean the project and then build again. The reason for this is straightforward – we’ve already built the project, in a previous chapter. Without any modifications to the source code since then, a new build attempt would skip the detailed command execution we aim to scrutinize, since the source code hasn’t changed.</p>
			<p>Let’s clean the project:</p>
			<ol>
				<li>Locate the project in the <strong class="bold">Projects</strong> pane.</li>
				<li>Right-click on the name of the project.</li>
				<li>A menu will appear. From this menu, select the <strong class="bold">Clean </strong><strong class="bold">Project</strong> option.</li>
				<li>The IDE will now clear any already compiled data from the project. This action resets the build state of the project to its initial condition, erasing any previous build results.</li>
			</ol>
			<p>Now, let’s build it again:</p>
			<ol>
				<li>Right-click once more on the same project’s name in the <strong class="bold">Projects</strong> pane.</li>
				<li>Again, a menu will appear. This time, select the <strong class="bold">Build </strong><strong class="bold">Project</strong> option.</li>
				<li>By selecting this option, the IDE will start the process of building the project from scratch.</li>
			</ol>
			<p>To observe the build commands in the STM32CubeIDE, we must find the <strong class="bold">Console</strong> pane, which is usually positioned at the bottom area of the IDE’s interface. The <strong class="bold">Console</strong> pane is an important component that displays real-time outputs and logs for various actions, including the build process. This makes it an invaluable tool to monitor the commands and actions undertaken during the compilation of our projects.</p>
			<p>If the <strong class="bold">Console</strong> pane is not readily visible in your current IDE layout, you can access it through the menu bar located at the top of the IDE. Simply click on the <strong class="bold">Window</strong> menu to reveal a drop-down list of options. From there, navigate to <strong class="bold">Show View</strong>, which will expand to show more choices. Among these, select <strong class="bold">Console</strong> to bring the pane into view within your workspace.</p>
			<p><a id="_idTextAnchor107"/>Once you have the <code>2_RegisterManipulation</code> bare-metal GPIO driver project. <em class="italic">Figure 3</em><em class="italic">.5</em> shows some of the content of the <code>2_RegisterManipulation</code> bare-metal GPIO driver project:</p>
			<div><div><img src="img/B21914_03_05.jpg" alt="Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal GPIO driver project." width="1621" height="725"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal GPIO driver project.</p>
			<p><em class="italic">Figure 3</em><em class="italic">.5</em> provides a snapshot<a id="_idIndexMarker240"/><a id="_idIndexMarker241"/> of the build process steps, although it only displays a segment of each step. For a comprehensive view of all the steps, including the full lines of commands and responses, you should refer to the <strong class="bold">Console</strong> pane in your STM32CubeIDE.</p>
			<p>Let's analyze the console pane in <em class="italic">Figure 3</em><em class="italic">.5</em>, according to the line numbering..</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor108"/>Compilation of assembly and C files</h2>
			<p><strong class="bold">Line (1)</strong></p>
			<p><code>make -j8 all</code>: This is a command<a id="_idIndexMarker242"/><a id="_idIndexMarker243"/> to the <code>make</code> build automation tool, requesting it to execute the build. We shall learn about <code>make</code> in the upcoming<a id="_idIndexMarker244"/><a id="_idIndexMarker245"/> chapters.</p>
			<p><strong class="bold">Lines (2)(3)(4)(5)</strong></p>
			<p>The following lines are specific <code>arm-none-eabi-gcc</code> commands to compile individual source files such as <code>main.c</code>, <code>syscalls.c</code>, and <code>sysmem.c</code>. These commands specify the target CPU (<code>-mcpu=cortex-m4</code>) and other compiler flags. Each source file is compiled into an object file (<code>.o</code>).</p>
			<h3>Linking process</h3>
			<p><strong class="bold">Line (6)</strong></p>
			<p>The <code>arm-none-eabi-gcc</code> command with a list<a id="_idIndexMarker246"/><a id="_idIndexMarker247"/> of object files (<code>@"objects.list")</code> and a linker script (<code>STM32F411RETX_FLASH.ld</code>) links these object files into an executable file (<code>2_RegisterManipulation.elf</code>). The linker script guides how different sections of the code and data are placed in the final executable. We shall discuss linker scripts in the next chapter.</p>
			<h3>Size calculation:</h3>
			<p><strong class="bold">Line (8)</strong></p>
			<p><code>arm-none-eabi-size 2_RegisterManipulation.elf:</code> This command calculates the size of the compiled program, breaking it down<a id="_idIndexMarker248"/><a id="_idIndexMarker249"/><a id="_idIndexMarker250"/> into text (code), data (initialized data), and bss (uninitialized data) sections. The output shows the size of these sections in bytes and their total in both decimal (<strong class="bold">dec</strong>) and hexadecimal (<strong class="bold">hex</strong>) formats.</p>
			<h3>Creation of a list file:</h3>
			<p><strong class="bold">Line (9)</strong></p>
			<p><code>arm-none-eabi-objdump -h -S 2_RegisterManipulation.elf &gt; "2_RegisterManipulation.list"</code>: This command disassembles the executable and outputs a detailed list file. The <code>-h</code> flag shows the header<a id="_idIndexMarker251"/><a id="_idIndexMarker252"/> information, and <code>-S</code> intersperses source code with disassembly. A list file is a detailed textual representation of compiled code, containing both the assembly language instructions and their corresponding machine code, often with annotations of the original high-level source code.</p>
			<p>As we can observe from these logs, it is clear that our STM32CubeIDE employs the same GNU Binary Tools previously discussed. In our forthcoming section, we will manually execute these commands via the command line. This approach will teach us how to build our firmware without using an IDE, simply using the source text files, the command-line interface, and our suite of GNU Bin Tools.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor109"/>Working with the GNU bin tools</h2>
			<p>In this section, our focus is to execute<a id="_idIndexMarker253"/><a id="_idIndexMarker254"/> some of the GNU Bin Tools directly, using our command line. To start I want to show you why I use the words <em class="italic">commands</em> and <em class="italic">tools</em> interchangeably to describe the GNU Bin Tools.</p>
			<p>Locate the installation folder for the GNU Arm Embedded Toolchain on your computer. On my computer, this is <code>C:/Program Files(x86)/GNU Arm </code><code>Embedded Toolchain.</code></p>
			<p>Once you’ve located the GNU Arm Embedded Toolchain folder, the next step involves accessing the <code>bin</code> folder within it.</p>
			<p>Upon opening the <code>bin</code> folder, you’ll be greeted with a plethora of tools, each represented by an executable file (<code>.exe</code>). Looking closely, you will find <code>arm-none-eabi-gcc.exe</code>, our compiler, along with other tools we previously discussed. When we input a command corresponding to these tools in the command line, the associated <code>.exe</code> file is executed. For instance, entering <code>arm-none-eabi-gcc</code> in the command line will run the <code>arm-none-eabi-gcc.exe</code> executable.</p>
			<p>Now that we have clarified that, it’s time to shift our focus toward practical testing. However, before diving into this testing phase, a few essential preparatory steps are required. Let’s create a backup of our current project, <code>2_RegisterManipulation</code>:</p>
			<ol>
				<li><code>2_RegisterManipulation</code> project is stored.</li>
				<li><code>2_RegisterManipulation</code> project folder, select <strong class="bold">Copy</strong>, and then <strong class="bold">Paste</strong> within the same directory.</li>
				<li><code>2_RegisterManipulation-old</code>.</li>
			</ol>
			<p>With the backup in place, our next<a id="_idIndexMarker255"/><a id="_idIndexMarker256"/> move is to modify the <code>main.c</code> file in the <code>2_Register</code><strong class="source-inline">
Manipulation</strong> project, changing the LED’s behavior from a constant <em class="italic">on</em> state to a blinking one:</p>
			<ol>
				<li><code>2_RegisterManipulation/Src</code> directory.</li>
				<li><code>main.c</code> file and choose to open it in a simple text editor, such as Notepad.</li>
				<li><code>PA5 (LED_PIN)</code> high. It should look like this:<pre class="source-code">
//  22: Set PA5(LED_PIN) high
GPIOA_OD_R |= LED_PIN;</pre><p class="list-inset">Replace this code with the following to toggle the state of <code>PA5</code> and create a blinking effect:</p><pre class="source-code">//  22: Toggle PA5(LED_PIN)
GPIOA_OD_R ^= LED_PIN;
for(int i = 0; i &lt; 100000; i++){} // Delay loop for visible blinking</pre></li>				<li><code>main.c</code> file.</li>
			</ol>
			<p>Let’s go back to our project folder and access the <code>2_RegisterManipulation/Debug</code> directory through the command prompt. This specific folder is important because it’s where STM32CubeIDE automatically places the project’s <code>makefile</code>. Understanding the role and structure of <strong class="bold">makefiles</strong> is crucial in embedded firmware development, and we will delve<a id="_idIndexMarker257"/><a id="_idIndexMarker258"/> into this topic in more detail in upcoming chapters.</p>
			<p>We can access the folder through the command prompt in multiple ways:</p>
			<p>Windows users can choose between these methods:</p>
			<ul>
				<li><code>2_RegisterManipulation/Debug</code> folder in Windows Explorer. Once there, hold down the <em class="italic">Shift</em> key, right-click in an empty space within the folder, and select <code>Debug</code> folder.</li>
				<li><code>2_RegisterManipulation/Debug</code> folder and then copy the folder path. Then, open Command Prompt from the <code>cmd</code> in the <code>cd</code> (note the space after ‘cd’), paste the copied path, and press <em class="italic">Enter</em>. This will change the directory to the <code>Debug</code> folder.</li>
			</ul>
			<p>Users of other operating systems can choose<a id="_idIndexMarker259"/><a id="_idIndexMarker260"/> between these methods:</p>
			<ul>
				<li>Navigate to the folder, and open the terminal specific to your operating system.</li>
				<li> Use the <code>cd</code> (change directory) command, followed by the absolute path to the <code>2_RegisterManipulation/Debug</code> folder to navigate to it. The exact path may vary, based on where the project is located on your system.</li>
			</ul>
			<div><div><img src="img/B21914_03_06.jpg" alt="Figure 3.6: Accessing the Debug folder through the Windows Command Prompt" width="996" height="287"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Accessing the Debug folder through the Windows Command Prompt</p>
			<p>In this practical exercise, we’ll replicate the commands used by STM32CubeIDE, extracting them directly from its console pane. We’ll execute them one by one, as depicted in <em class="italic">Figure 3</em><em class="italic">.5</em>, starting with line number 2 (since our current focus isn’t on makefiles).</p>
			<p>To do this, follow these steps:</p>
			<ol>
				<li>Copy line number 2 from the STM32CubeIDE console pane and paste it into the command prompt. This line compiles the startup file using <code>arm-none-eabi-gcc</code>, referencing paths specific to my system setup:<pre class="source-code">
<code>main.c</code> file. However, before pasting this command into the command prompt, remove the <code>-fcyclomatic-complexity</code> flag, as it is not supported by some versions of the GNU Toolchain for Arm. Paste the command into a text editor, delete the flag, and then copy the modified command into the command prompt. The command for line number 3 should look like this:<pre class="source-code">
<code>syscalls.c</code> and <code>system.c</code> files, respectively.</li>
				<li>We will proceed to link these files. To do this, copy the linking command, which is on line number 6 in the STM32CubeIDE console pane, and paste it into the command prompt, like this:<pre class="source-code">
<code>arm-none-eabi-size</code> command to display the size of our output <code>.elf</code> file. This will give us insights into the sizes of various sections, such as <strong class="bold">text</strong>, <strong class="bold">data</strong>, and <strong class="bold">bss</strong>. We will discuss these sections in detail later in the book, particularly when we delve into writing linker scripts.</li>
			</ol>
			<p>To execute this, copy line number 8 from the STM32CubeIDE console pane and paste it into the command prompt. Running the following command:</p>
			<pre class="console">
C:<a id="_idTextAnchor112"/>\Users\Ninsaw\Documents\tempWorkspace\2_RegisterManipulation\Debug&gt;arm-none-eabi-size   2_RegisterManipulation.elf</pre>			<p>It will display the size details of the <code>.</code><code>elf</code> file:</p>
			<div><div><img src="img/B21914_03_07.jpg" alt="Figure 3.7: Output produced by executing the arm-none-eabi-size command" width="1091" height="99"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Output produced by executing the arm-none-eabi-size command</p>
			<p>Observing the results, we can confirm that the output<a id="_idIndexMarker263"/><a id="_idIndexMarker264"/> matches exactly what is displayed in the STM32CubeIDE console pane.</p>
			<p>At this stage, we can choose to convert our <code>.elf</code> file into the <code>.bin</code> format using the <code>arm-none-eabi-objcopy</code> tool, with the appropriate flags.</p>
			<p>Type the following in the command prompt and press <em class="italic">Enter</em>:</p>
			<pre class="console">
arm-none-eabi-objcopy -O binary 2_RegisterManipulation.elf 2_RegisterManipulation.bin</pre>			<p>Let’s break down this snippet:</p>
			<ul>
				<li><code>-O binary</code> specifies the output format, which in this case is a binary file</li>
				<li><code>2_RegisterManipulation.elf</code> is the source ELF file you are converting</li>
				<li><code>2_R<a id="_idTextAnchor113"/>egisterManipulation.bin</code> is the name of the output binary file that will be created</li>
			</ul>
			<p>This final step marks the completion of our first build process. We have successfully compiled and linked all necessary files, resulting in the creation of our final executable in two formats. The next process involves uploading the firmware to our microcontroller using <em class="italic">OpenOCD</em>. This will be covered in the next section.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor114"/>Uploading firmware to the microcontroller using OpenOCD</h2>
			<p><code>2_RegisterManipulation</code> executable file into our microcontroller.</p>
			<p>We will start by locating the correct<a id="_idIndexMarker269"/><a id="_idIndexMarker270"/> OpenOCD script for our development board. OpenOCD comes with a variety of scripts, each tailored to different microcontrollers and development boards. In our case, the focus is on the <strong class="bold">st_nucleo_f4 series</strong>. To find the right <a id="_idIndexMarker271"/><a id="_idIndexMarker272"/>script, follow these steps:</p>
			<ol>
				<li>Navigate to the OpenOCD installation directory, typically found in the <code>Program Files</code> folder for Windows users. The OpenOCD folder is usually named <code>xpack-openocd</code>. Once there, enter the <code>openocd</code> subfolder, then the <code>scripts</code> subfolder, and finally, the <code>board</code> subfolder. You will find a file named <code>st_nucleo_f4.cfg</code>; this is the OpenOCD file we have to execute for our NUCLEO-F4 development board.</li>
				<li>To launch OpenOCD, connect your development board, open the command prompt window, and enter the following command:<pre class="source-code">
<code>st_nucleo_f4.cfg</code>, contains all the necessary settings for OpenOCD to communicate with the development board.</p></li>			</ol>
			<p>This is a snippet of the output from the command<a id="_idIndexMarker273"/><a id="_idIndexMarker274"/> prompt after executing the command:</p>
			<div><div><img src="img/B21914_03_08.jpg" alt="Figure 3.8: OpenOCD’s first output" width="933" height="478"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: OpenOCD’s first output</p>
			<p>The information presented here includes the following:</p>
			<ul>
				<li><code>6666</code> for Tcl connections and port <code>4444</code> for Telnet connections. These ports are used to send commands to OpenOCD and interact with it during debugging sessions.</li>
				<li><strong class="bold">Processor and debug capabilities</strong>: The debugger has identified the Cortex-M4 r0p1 processor in the STM32F4 series microcontroller. Additionally, it notes that the target has six breakpoints and four watchpoints, which are crucial for setting breakpoints and watchpoints during debugging.</li>
				<li><code>3333</code>. This server allows a <strong class="bold">GDB</strong> (<strong class="bold">GNU Debugger</strong>) client to connect for debugging<a id="_idIndexMarker275"/><a id="_idIndexMarker276"/> purposes.</li>
			</ul>
			<p>With OpenOCD running, the next step involves using the GDB to upload the firmware to the microcontroller. Let’s access another command prompt window, still from the Debug folder (as OpenOCD should keep running in the first one), and enter the following command to start the GDB:</p>
			<pre class="console">
arm-none-eabi-gdb</pre>			<p>Once the GDB is open, we establish a connection to the microcontroller by running the following:</p>
			<pre class="console">
target remote localhost:3333</pre>			<p>This command connects GDB<a id="_idIndexMarker277"/><a id="_idIndexMarker278"/> to the OpenOCD server running<a id="_idIndexMarker279"/><a id="_idIndexMarker280"/> on the local machine (<code>localhost</code>) on port <code>3333</code>, which is the default port for OpenOCD.</p>
			<p>Upon executing this command, both command prompt windows return outputs telling us that debugging has started:</p>
			<div><div><img src="img/B21914_03_09.jpg" alt="Figure 3.9: Output from the command prompt window running the GDB" width="901" height="548"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Output from the command prompt window running the GDB</p>
			<p>This is the output from the command prompt window running <code>st_nucleo_f4.cfg</code> :</p>
			<div><div><img src="img/B21914_03_10.jpg" alt="Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg" width="843" height="536"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg</p>
			<p>Before<a id="_idIndexMarker281"/> loading the<a id="_idIndexMarker282"/> firmware, we have to reset and initialize the board using the following command:</p>
			<pre class="console">
monitor reset init</pre>			<p>Let’s break down the command into its components:</p>
			<ul>
				<li><code>monitor</code>: This prefix is used in the GDB to indicate that the following command is not a GDB command but is meant for the debugging server (in this case, OpenOCD)</li>
				<li><code>reset</code>: This part of the command instructs OpenOCD to reset the target device</li>
				<li><code>init</code>: This tells OpenOCD to execute its initialization sequence for the target device</li>
			</ul>
			<p>Then, we load the firmware onto the microcontroller using the following command:<a id="_idTextAnchor115"/></p>
			<pre class="console">
monitor flash write_image erase 2_RegisterManipulation.el<a id="_idTextAnchor116"/>f</pre>			<p>This command erases the existing firmware on the microcontroller and writes the new firmware (in this case, <code>2_RegisterManipulation.elf</code>) onto it. This command erases the<a id="_idIndexMarker283"/> existing firmware on the microcontroller and writes the new firmware (in this case, <code>2_RegisterManipulation.elf</code>) onto it:</p>
			<ul>
				<li><code>flash write_image</code>: This is an OpenOCD command that tells it to write an image to the flash memory of the target microcontroller – in effect, programming the microcontroller with a new firmware image.</li>
				<li><code>erase</code>: This option tells OpenOCD to erase the flash memory before writing the new image. Erasing the flash is a common requirement in microcontroller programming, as it clears any previous program and ensures that the new firmware is written to a clean memory space.</li>
			</ul>
			<p>After <a id="_idIndexMarker284"/>successfully loading the firmware, we reset the board again with the same <code>reset</code> command.</p>
			<pre class="console">
monitor reset init</pre>			<p>Then, we resume the execution of the code on the microcontroller with the following:</p>
			<pre class="console">
monitor resume</pre>			<p>Voila! The firmware should now be running on the microcontroller. You should see the LED on the board blinking, indicating the successful upload and execution of the new firmware.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor117"/>Summary</h1>
			<p>In this chapter, we explored the intricacies of the embedded firmware build process, with a specific focus on the GNU Toolchain.</p>
			<p>We began by getting to know the embedded build process, exploring its multiple stages – pre-processing, compilation, assembly, linking, and locating. Each stage was analyzed, clarifying its significance in transforming human-readable source code into executable machine instructions. We delved into the roles of pre-processing in preparing code, the nuances of compilation and assembly in translating and converting code, and the intricate tasks of linking and locating in forming a cohesive, executable binary.</p>
			<p>Transitioning to practical application, the chapter introduced the GNU Binary Tools for Embedded Systems. By revisiting our previously developed bare-metal GPIO driver, we observed the build commands executed by the STM32CubeIDE, replicating these steps manually using our command-line interface. This approach gave us a deeper appreciation of the underlying processes and commands that IDEs automate. In the latter part of the chapter, we went through the step-by-step process of uploading our firmware to the microcontroller using OpenOCD, from locating the correct OpenOCD script for the development board to executing commands to reset, initialize, and run the firmware on the microcontroller. This practical exercise demonstrated the successful application of the theoretical knowledge we gained earlier, marking a significant milestone in our journey.</p>
			<p>In the next chapter, we shall learn how to write our own linker scripts and startup files. This important step will represent another significant milestone in our journey toward mastering the art of developing entirely bare-metal firmware from the ground up.</p>
		</div>
	</div>
</div>
</body></html>