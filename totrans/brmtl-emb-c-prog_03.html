<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer059">
			<h1 id="_idParaDest-56" class="chapter-number"><a id="_idTextAnchor080"/>3</h1>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor081"/>Understanding the Build Process and Exploring the GNU Toolchain</h1>
			<p>Bare-metal programming is <a id="_idIndexMarker209"/>a journey of deep understanding and precision, and in this chapter, we will navigate the complex realm of the embedded firmware build process. Our focus is the GNU Arm Toolchain, an important element in firmware development. Through a blend of theory and hands-on programming exercises, you will gain insights into how <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>) streamline the build process and how these processes can be manually replicated using the GNU <span class="No-Break">Arm Toolchain.</span></p>
			<p>As the chapter progresses, we delve into the nuances of the compiler and its various options, tailored for Arm Cortex microcontrollers. The programming exercise in this chapter is designed to help you understand and effectively utilize the GNU tools, from compiling and linking to analyzing the depths of the output <span class="No-Break">object files.</span></p>
			<p>In this chapter, we shall cover the following <span class="No-Break">main topics:</span><a id="_idTextAnchor082"/></p>
			<ul>
				<li>The foundations – understanding the embedded <span class="No-Break">build process</span><a id="_idTextAnchor083"/></li>
				<li>A tour of GNU binary tools for <span class="No-Break">embedded systems</span></li>
				<li>From IDE to command-line – watching the build <span class="No-Break">process unfold</span></li>
			</ul>
			<p>By the end of the chapter, you will have an understanding of the embedded firmware build process and have developed the skills to fluidly switch between IDEs and command-line interfaces, enhancing your versatility as a <span class="No-Break">firmware developer.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span><a id="_idTextAnchor085"/></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor086"/>The foundations – understanding the embedded build process</h1>
			<p>The<a id="_idIndexMarker210"/> journey from high-level source code in embedded firmware development to an executable binary image is intricate and multilayered. This process is<a id="_idIndexMarker211"/> commonly referred to as the firmware build process and involves several critical stages – pre-processing, compilation, assembly, linking, and locating. Each of these stages plays an important role in transforming human-readable code into machine-executable instructions. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> shows the entire build process and the tools involved at each stage of <span class="No-Break">the process.</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B21914_03_01.jpg" alt="Figure 3.1: The build process, detailing the input and output files for each stage and the specific tools used" width="1171" height="474"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: The build process, detailing the input and output files for each stage and the specific tools used</p>
			<p>Let’s examine <span class="No-Break">the stages.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor087"/>The pre-processing stage</h2>
			<p>Pre-processing is<a id="_idIndexMarker212"/> the initial stage in the firmware build process. In this stage, the source code undergoes a series of transformations to prepare it for compilation. Typically, source files in embedded systems are written in C (<strong class="source-inline">.c</strong> files) and accompanied by header files (<strong class="source-inline">.h</strong> files). The preprocessor is the specialized tool in the build process whose task is to handle these <span class="No-Break">input files.</span></p>
			<p>During pre-processing, the preprocessor executes several <span class="No-Break">key operations:</span></p>
			<ul>
				<li><strong class="bold">Stripping comments</strong>: Comments, which are crucial for human readability but irrelevant for machines, are removed <span class="No-Break">from code.</span></li>
				<li><strong class="bold">Evaluating preprocessor directives</strong>: Lines starting with the <strong class="source-inline">#</strong> symbol, known as preprocessor directives, are processed. These directives often include macro definitions (<strong class="source-inline">#define</strong>), conditional compilation instructions (<strong class="source-inline">#ifdef</strong>, <strong class="source-inline">#ifndef</strong>, <strong class="source-inline">#endif</strong>), and file inclusion commands (<strong class="source-inline">#include</strong>). The preprocessor <a id="_idIndexMarker213"/>replaces these directives with their defined values or corresponding <span class="No-Break">code segments.</span></li>
				<li><strong class="bold">Output generation</strong>: The output of this stage is a set of intermediate files, typically with the <strong class="source-inline">.i</strong> extension. These files represent the transformed source code, devoid of comments and with all <span class="No-Break">directives evaluated.</span></li>
			</ul>
			<p>The next stage is the <span class="No-Break">compilation sta<a id="_idTextAnchor088"/>ge.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor089"/>The compilation stage</h2>
			<p>Compilation starts<a id="_idIndexMarker214"/> immediately after pre-processing. The compiler’s role is to take <strong class="source-inline">.i</strong> files and convert them into architecture-specific assembly code. This phase is where the high-level constructs of <strong class="source-inline">C</strong> are translated into the lower-level, more granular assembly instructions understood by the target <span class="No-Break">processor architecture.</span></p>
			<p>This stage involves <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Input</strong>: The pre-processed <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">i</strong></span><span class="No-Break"> files</span></li>
				<li><strong class="bold">Process</strong>: The compiler analyzes the code structure, optimizes it for performance and space, and translates it into <span class="No-Break">assembly language</span></li>
				<li><strong class="bold">Output</strong>: The result of the compilation stage is a set of assembly code files, typically with the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break"> extension</span></li>
			</ul>
			<p>The next stage makes use of the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break"> files.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor090"/>The assembly stage</h2>
			<p>Assembly is <a id="_idIndexMarker215"/>the stage where the <strong class="source-inline">.s</strong> files containing assembly code are converted into machine code, in the form of <strong class="bold">object files</strong>. This<a id="_idIndexMarker216"/> stage translates the human-readable assembly instructions into a <span class="No-Break">binary format.</span></p>
			<p>This stage involves <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Input</strong>: Assembly code <span class="No-Break">files (</span><span class="No-Break"><strong class="source-inline">.s</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Process</strong>: The assembler interprets each assembly instruction and converts it into corresponding <span class="No-Break">machine code.</span></li>
				<li><strong class="bold">Output</strong>: Object files, usually with the <strong class="source-inline">.o</strong> extension. These files contain binary code and are ready for the next stage <span class="No-Break">of li<a id="_idTextAnchor091"/>nking.</span></li>
			</ul>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor092"/>The linking stage</h2>
			<p>Linking<a id="_idIndexMarker217"/> is the stage where all individual object files are combined to form a cohesive program. This stage also integrates any necessary standard library files and resolves references between different <span class="No-Break">code m<a id="_idTextAnchor093"/>odules.</span></p>
			<p>This stage involves <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Input</strong>: Object files (<strong class="source-inline">.o</strong>) and C standard <span class="No-Break">library files.</span></li>
				<li><strong class="bold">Process</strong>: The linker stitches together all object files, resolving symbolic references and addresses. It handles tasks such as memory allocation for variables <span class="No-Break">and functions.</span></li>
				<li><strong class="bold">Output</strong>: The linker generates a <strong class="bold">relocatable file</strong>, which<a id="_idIndexMarker218"/> is comprehensive but not yet final <span class="No-Break">executable code.</span></li>
			</ul>
			<p>A relocatable file is intermediate output in the firmware build process, which is created during the linking stage. It’s a comprehensive file that combines all individual object files <strong class="source-inline">(.o)</strong> and the necessary library. However, it is not yet a final executable. The concept of <strong class="bold">relocation</strong> plays an important role here. Relocation involves adjusting the symbolic addresses in the relocatable file to actual, specific memory locations. This process ensures that when the firmware runs on a target device, each part of the code and data is correctly placed in memory. The relocatable file contains all the necessary components of the firmware, but with addresses that are still “relative” – they need further adjustment <a id="_idIndexMarker219"/>during the locating stage to fit the unique memory map of the target microcontroller, leading to the creation of the <span class="No-Break">final executable.</span></p>
			<p>The next stage is where we finally get our <span class="No-Break">executable code.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor094"/>The locating stage</h2>
			<p>This is <a id="_idIndexMarker220"/>the last stage; it involves converting the relocatable file into the final executable binary. This stage is guided by a linker script, which provides essential information about the memory layout of the <span class="No-Break">target device.</span></p>
			<p>This stage involves <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Input</strong>: A relocatable file and a <span class="No-Break">linker script.</span></li>
				<li><strong class="bold">Process</strong>: The locator uses the linker script to place code and data sections into their designated memory locations. It adjusts addresses and offsets to fit the target’s <span class="No-Break">memory map.</span></li>
				<li><strong class="bold">Output</strong>: An executable binary file, typically in formats such as <strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>) or a<a id="_idIndexMarker221"/> plain <span class="No-Break">binary format.</span></li>
			</ul>
			<p>With this knowledge in hand, we are well-equipped to delve into the GNU Toolchain for Arm. Our goal is to effectively utilize specific tools within the toolchain to execute the various stages of the build process. This will be the focus of the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor095"/>A tour of GNU binary tools for embedded systems</h1>
			<p>In this<a id="_idIndexMarker222"/> section, we’ll delve into the GNU Bin tools, a suite of tools that come with the installation of the GNU Toolchain for Arm. These tools (commands) are essential for the various stages of the firmware build process, as well as additional tasks such <span class="No-Break">as debugging.</span></p>
			<p>The first command we’ll explore <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">arm-no<a id="_idTextAnchor096"/>ne-eabi-gcc</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor097"/>arm-none-eabi-gcc</h2>
			<p>Let’s break<a id="_idIndexMarker223"/> down<a id="_idIndexMarker224"/> the components of <span class="No-Break">the command:</span></p>
			<ul>
				<li><strong class="source-inline">arm</strong>: This specifies the <span class="No-Break">target architecture.</span></li>
				<li><strong class="source-inline">none</strong>: This component indicates the operating system for which the code is being compiled. Here, <strong class="source-inline">none</strong> signifies that the code is meant for a bare-metal environment, meaning it will run directly on the hardware without an underlying <span class="No-Break">operating system.</span></li>
				<li><strong class="source-inline">eabi</strong>: This stands<a id="_idIndexMarker225"/> for <strong class="bold">Embedded Application Binary Interface</strong>. EABI defines a standard for the binary layout of system and user programs, libraries, and so on. It ensures that the compiled code will work correctly on any Arm processor that adheres to the <span class="No-Break">EABI standard.</span></li>
				<li><strong class="source-inline">gcc</strong>: This is <a id="_idIndexMarker226"/>short for <strong class="bold">GNU </strong><span class="No-Break"><strong class="bold">Compiler Collection</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>This single command compiles, assembles, and links our input code in one go. To use it, type <strong class="source-inline">arm-none-eabi-gcc</strong> in the command prompt or terminal, followed by the source file, then <strong class="source-inline">-o</strong>, and the desired <span class="No-Break">output filename.</span></p>
			<p>See <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em> for <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B21914_03_02.jpg" alt="Figure 3.2: Usage of the arm-none-eabi-gcc command" width="1191" height="394"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Usage of the arm-none-eabi-gcc command</p>
			<p>In this example, we specify the source file as <strong class="source-inline">main.c</strong> and the output file <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.o.</strong></span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor098"/>Some common compiler flags</h2>
			<p>Since<a id="_idIndexMarker227"/> we have just introduced the <strong class="source-inline">-o</strong> compiler flag, let’s take this opportunity to introduce some of the other commonly used compiler flags. These compiler flags are used to modify command behavior as well as add options <span class="No-Break">to commands:</span></p>
			<ul>
				<li><strong class="source-inline">-c</strong>: This flag is used to compile and assemble but not link. When added to the command, it processes the code up to the assembly stage but stops <span class="No-Break">before linking.</span></li>
				<li><strong class="source-inline">-o file</strong>: As mentioned earlier, this specifies the name of the <span class="No-Break">output file.</span></li>
				<li><strong class="source-inline">-g</strong>: Generates debugging information in <span class="No-Break">the executable.</span></li>
				<li><strong class="source-inline">-Wall</strong>: Enables all warning messages, helping us identify potential issues in <span class="No-Break">the code.</span></li>
				<li><strong class="source-inline">-Werror</strong>: Treats all warnings as errors, ensuring code quality <span class="No-Break">and stability.</span></li>
				<li><strong class="source-inline">-I [DIR]</strong>: Includes a specified directory to search for header files; it’s useful for organizing <span class="No-Break">large projects.</span></li>
				<li><strong class="source-inline">-ansi</strong> and <strong class="source-inline">-std=STANDARD</strong>: These flags specify which standard version of the c language should <span class="No-Break">be used.</span></li>
				<li><strong class="source-inline">-v</strong>: Provides verbose output from GCC, giving us detailed information about the <span class="No-Break">comp<a id="_idTextAnchor099"/>ilation process.</span></li>
			</ul>
			<p><em class="italic">Table 3.1</em> provides a summary of the flags and example usage for <span class="No-Break">each flag.</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flag</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Example usage</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-c</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Compile and assemble but <span class="No-Break">don’t link</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">c source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">o file</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Link to the output file, <span class="No-Break">named file</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc source_file -</strong><span class="No-Break"><strong class="source-inline">o output_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-g</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate debugging info in <span class="No-Break">the executable</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">g source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Wall</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Enable all <span class="No-Break">warning messages</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">Wall source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Werror</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Treat warnings <span class="No-Break">as errors</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">Werror source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">I [DIR]</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Include a directory for <span class="No-Break">header files</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -I </strong><span class="No-Break"><strong class="source-inline">directory_path source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">ansi</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Use the <strong class="bold">American National Standards Institute</strong> (<span class="No-Break"><strong class="bold">ANSI</strong></span><span class="No-Break">) standard</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">ansi source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">std</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Specify a standard version (<span class="No-Break">e.g., C11)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">std=c11 source_file</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-v</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Verbose output <span class="No-Break">from GCC</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-gcc -</strong><span class="No-Break"><strong class="source-inline">v source_file</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1: Some compiler flags and their example usage</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor100"/>Some architecture-specific flags</h2>
			<p>In addition<a id="_idIndexMarker228"/> to the general compiler flags, there are several architecture-specific flags that enable precise configuration for various processor architectures. These flags are integral for tailoring the build process to specific ARM processors and their respective architectures. Let’s delve into some of the most frequently used <span class="No-Break">architecture-specific flags:</span></p>
			<ul>
				<li><strong class="source-inline">-mcpu=[NAME]</strong>: Specifies the target ARM processor. Using this option configures the compiler to optimize the code for a <span class="No-Break">specific processor.</span></li>
				<li><strong class="bold">-</strong><strong class="source-inline">march=[NAME]</strong>: Specifies the target ARM architecture. It configures the compiler for a particular ARM <span class="No-Break">architecture version.</span></li>
				<li><strong class="source-inline">-mtune=[NAME]</strong>: Similar to <strong class="source-inline">-mcpu</strong>, this specifies the target ARM processor for <span class="No-Break">optimization purposes.</span></li>
				<li><strong class="source-inline">-thumb</strong>: Configures the compiler to generate code for the Thumb instruction set, which is a compressed version of the standard ARM instruction set, providing more code density <span class="No-Break">and efficiency.</span></li>
				<li><strong class="source-inline">-marm</strong>: Instructs the compiler to generate code for the ARM <span class="No-Break">instruction set.</span></li>
				<li><strong class="source-inline">-mlittle-endian</strong>/<strong class="source-inline">-mbig-endian</strong>: These options specify the endianness for the generated code. Little-endian is the most common format in <span class="No-Break">ARM processors.</span></li>
			</ul>
			<p>Let’s see an <a id="_idIndexMarker229"/>example involving some of <span class="No-Break">these flags:</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B21914_03_03.jpg" alt="Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific flags" width="1556" height="337"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific flags</p>
			<p>In this example, we say <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">-c</strong>: Compile and assemble but do <span class="No-Break">not link</span></li>
				<li><strong class="source-inline">-mcpu=cortex-m4</strong>: Build for the <span class="No-Break">Cortex-M4 processor</span></li>
				<li><strong class="source-inline">-mthumb</strong>: Use the Thumb <span class="No-Break">instruction set</span></li>
				<li><strong class="source-inline">-o main.o</strong>: Output the compiled file <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.o</strong></span><strong class="source-inline"><a id="_idTextAnchor101"/></strong></li>
			</ul>
			<p><em class="italic">Table 3.2</em> provides a summary of the architecture-specific flags and example usage for <span class="No-Break">each flag.</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flag</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Example usage</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mcpu=[NAME]</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Specify the target <span class="No-Break">ARM processor</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mcpu=cortex-m4</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">march=[NAME]</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Specify the target <span class="No-Break">ARM architecture</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">march=armv7-m</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mtune=[NAME]</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Optimize for a specific <span class="No-Break">ARM processor</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mtune=cortex-m4</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">thumb</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for the Thumb <span class="No-Break">instruction set</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mthumb</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">marm</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for the ARM <span class="No-Break">instruction set</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">marm</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mlittle-endian</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for <span class="No-Break">little-endian mode</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mlittle-endian</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mbig-endian</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generate code for <span class="No-Break">big-endian mode</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">mbig-endian</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2: Some architecture-specific compiler flags and their example usage</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor102"/>Other commands in the GNU Toolchain for Arm</h2>
			<p>Apart from the <strong class="source-inline">arm-none-eabi-gcc</strong> command, there are other important commands that we will<a id="_idIndexMarker230"/> frequently use when building with the GNU toolchain for Arm. Let’s examine some of <span class="No-Break">these commands:</span></p>
			<ul>
				<li><strong class="source-inline">arm-none-eabi-nm</strong>: The <strong class="source-inline">arm-none-eabi-nm</strong> command is a handy tool for listing the<a id="_idIndexMarker231"/> symbols from an object file. Symbols in this context refer to various identifiers in a program, such as function names, variable names, and constants. This tool is invaluable for examining the contents of compiled files, offering us insights into the structure and components of our program. This can be particularly useful for <span class="No-Break">debugging purposes.</span></li>
				<li><strong class="source-inline">arm-none-eabi-size</strong>: In<a id="_idIndexMarker232"/> embedded firmware development, where memory resources are often limited, understanding the memory footprint of different sections of our code is crucial. This tool provides valuable insights into how much memory the various parts of our code consume, allowing us to make informed decisions about optimization and <span class="No-Break">memory management.</span></li>
				<li><strong class="source-inline">arm-none-eabi-objdump</strong>: This<a id="_idIndexMarker233"/> tool is used to extract and display detailed information from object files. It offers an in-depth view of the machine instructions, making it an invaluable resource for thorough analysis of object files. This includes capabilities such as disassembling code, presenting section headers, and revealing symbol tables. Its utility becomes crucial when we need to delve into the intricate details of compiled code, providing clarity on a file’s structure, content, and operational mechanics. This helps us to both debug and optimize <span class="No-Break">our code.</span><p class="list-inset">Disassembling<a id="_idIndexMarker234"/> code refers to the process of converting machine code, which is a set of binary instructions that a computer’s processor can execute directly, back into assembly language. Assembly language is a more human-readable form of instructions, although it’s still quite low-level compared to the C language. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em> presents a comparison of C-language code, its corresponding assembly language translation, and the resulting <span class="No-Break">machine code.</span></p></li>
			</ul>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B21914_03_04.jpg" alt="Figure 3.4: C-language code, its corresponding assembly language code, and the resulting machine code" width="883" height="204"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: C-language code, its corresponding assembly language code, and the resulting machine code</p>
			<ul>
				<li><strong class="source-inline">arm-none-eabi-reade<a id="_idTextAnchor103"/>lf</strong>: This tool provides detailed information about the <a id="_idIndexMarker235"/>output ELF file, including section headers, program headers, and symbol tables. It is useful when we work with ELF files, as it offers insights into how an executable is structured and prepared to run on <span class="No-Break">a system.</span></li>
				<li><strong class="source-inline">: arm-none-eabi-objcopy</strong>: We <a id="_idIndexMarker236"/>use this tool to convert object files from one format to another or to make a copy of an <span class="No-Break">object file.</span></li>
			</ul>
			<p><em class="italic">Table 3.3</em> provides a summary of these additional tools and example usage for <span class="No-Break">each tool.</span></p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Function</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Example Usage</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">arm-none-eabi-nm</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists symbols from <span class="No-Break">object files</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-nm [</strong><span class="No-Break"><strong class="source-inline">object file]</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">arm-none-eabi-size</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists section sizes of <span class="No-Break">object/executable files</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">arm-none-eabi-size [file]</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline"><a id="_idTextAnchor104"/></strong><span class="No-Break"><strong class="source-inline">arm-none-eabi-objdump</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Dumps information about <span class="No-Break">object files</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-objdump [options] [</strong><span class="No-Break"><strong class="source-inline">object file]</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">arm-none-eabi-readelf</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays information about <span class="No-Break">ELF files</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-readelf [options] [</strong><span class="No-Break"><strong class="source-inline">ELF file]</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">arm-none-eabi-objcopy</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Converts/copies object files <span class="No-Break">between formats</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">arm-none-eabi-objcopy [options] [input file] [</strong><span class="No-Break"><strong class="source-inline">output file]</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.3: Some common commands in the GNU toolchain for Arm and their example usage</p>
			<p>In this section, we explored the GNU Binary Tools that are essential for embedded firmware development. These tools, including commands such as <strong class="source-inline">arm-none-eabi-gcc</strong>, play important roles in various stages of the firmware build process and are invaluable for tasks such as compiling, linking, and debugging. The next section will further expand our understanding of these tools; we’ll dive into their practical applications, demonstrating their utility in the embedded firmware <span class="No-Break">build process.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor105"/>From IDE to the command line – watching the build process unfold</h1>
			<p>In this section, our aim is to understand how the compiler within the IDE handles our code when we initiate a build. Additionally, we will delve into the practical applications of some of the GNU Binary Tools we discussed in the <span class="No-Break">previous section.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor106"/>Observing the build process from the IDE’s perspective</h2>
			<p>Let’s start by revisiting<a id="_idIndexMarker237"/><a id="_idIndexMarker238"/><a id="_idIndexMarker239"/> the bare-metal GPIO driver we developed in the <span class="No-Break">previous chapter.</span></p>
			<p>Begin by launching your STM32CubeIDE. To conduct a proper analysis of the build commands that the IDE executes, it’s necessary to first clean the project and then build again. The reason for this is straightforward – we’ve already built the project, in a previous chapter. Without any modifications to the source code since then, a new build attempt would skip the detailed command execution we aim to scrutinize, since the source code <span class="No-Break">hasn’t changed.</span></p>
			<p>Let’s clean <span class="No-Break">the project:</span></p>
			<ol>
				<li>Locate the project in the <span class="No-Break"><strong class="bold">Projects</strong></span><span class="No-Break"> pane.</span></li>
				<li>Right-click on the name of <span class="No-Break">the project.</span></li>
				<li>A menu will appear. From this menu, select the <strong class="bold">Clean </strong><span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break"> option.</span></li>
				<li>The IDE will now clear any already compiled data from the project. This action resets the build state of the project to its initial condition, erasing any previous <span class="No-Break">build results.</span></li>
			</ol>
			<p>Now, let’s build <span class="No-Break">it again:</span></p>
			<ol>
				<li>Right-click once more on the same project’s name in the <span class="No-Break"><strong class="bold">Projects</strong></span><span class="No-Break"> pane.</span></li>
				<li>Again, a menu will appear. This time, select the <strong class="bold">Build </strong><span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break"> option.</span></li>
				<li>By selecting this option, the IDE will start the process of building the project <span class="No-Break">from scratch.</span></li>
			</ol>
			<p>To observe the build commands in the STM32CubeIDE, we must find the <strong class="bold">Console</strong> pane, which is usually positioned at the bottom area of the IDE’s interface. The <strong class="bold">Console</strong> pane is an important component that displays real-time outputs and logs for various actions, including the build process. This makes it an invaluable tool to monitor the commands and actions undertaken during the compilation of <span class="No-Break">our projects.</span></p>
			<p>If the <strong class="bold">Console</strong> pane is not readily visible in your current IDE layout, you can access it through the menu bar located at the top of the IDE. Simply click on the <strong class="bold">Window</strong> menu to reveal a drop-down list of options. From there, navigate to <strong class="bold">Show View</strong>, which will expand to show more choices. Among these, select <strong class="bold">Console</strong> to bring the pane into view within <span class="No-Break">your workspace.</span></p>
			<p><a id="_idTextAnchor107"/>Once you have the <strong class="bold">Console</strong> pane visible, you can monitor the execution of the build commands. Whenever we initiate the build process, each command used during the build – encompassing compilation, linking, and other stages – will be displayed in this pane. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> shows some of the content of <strong class="bold">Console</strong> pane after building our <strong class="source-inline">2_RegisterManipulation</strong> bare-metal GPIO driver project. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> shows some of the content of the <strong class="bold">Console</strong> pane after building our <strong class="source-inline">2_RegisterManipulation</strong> bare-metal GPIO <span class="No-Break">driver project:</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B21914_03_05.jpg" alt="Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal GPIO driver project." width="1621" height="725"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal GPIO driver project.</p>
			<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> provides a snapshot<a id="_idIndexMarker240"/><a id="_idIndexMarker241"/> of the build process steps, although it only displays a segment of each step. For a comprehensive view of all the steps, including the full lines of commands and responses, you should refer to the <strong class="bold">Console</strong> pane in <span class="No-Break">your STM32CubeIDE.</span></p>
			<p>Let's analyze the console pane in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em>, according to the <span class="No-Break">line numbering..</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor108"/>Compilation of assembly and C files</h2>
			<p><span class="No-Break"><strong class="bold">Line (1)</strong></span></p>
			<p><strong class="source-inline">make -j8 all</strong>: This is a command<a id="_idIndexMarker242"/><a id="_idIndexMarker243"/> to the <strong class="source-inline">make</strong> build automation tool, requesting it to execute the build. We shall learn about <strong class="source-inline">make</strong> in the <span class="No-Break">upcoming</span><span class="No-Break"><a id="_idIndexMarker244"/><a id="_idIndexMarker245"/></span><span class="No-Break"> chapters.</span></p>
			<p><span class="No-Break"><strong class="bold">Lines (2)(3)(4)(5)</strong></span></p>
			<p>The following lines are specific <strong class="source-inline">arm-none-eabi-gcc</strong> commands to compile individual source files such as <strong class="source-inline">main.c</strong>, <strong class="source-inline">syscalls.c</strong>, and <strong class="source-inline">sysmem.c</strong>. These commands specify the target CPU (<strong class="source-inline">-mcpu=cortex-m4</strong>) and other compiler flags. Each source file is compiled into an object <span class="No-Break">file (</span><span class="No-Break"><strong class="source-inline">.o</strong></span><span class="No-Break">).</span></p>
			<h3>Linking process</h3>
			<p><span class="No-Break"><strong class="bold">Line (6)</strong></span></p>
			<p>The <strong class="source-inline">arm-none-eabi-gcc</strong> command with a list<a id="_idIndexMarker246"/><a id="_idIndexMarker247"/> of object files (<strong class="source-inline">@"objects.list")</strong> and a linker script (<strong class="source-inline">STM32F411RETX_FLASH.ld</strong>) links these object files into an executable file (<strong class="source-inline">2_RegisterManipulation.elf</strong>). The linker script guides how different sections of the code and data are placed in the final executable. We shall discuss linker scripts in the <span class="No-Break">next chapter.</span></p>
			<h3>Size calculation:</h3>
			<p><span class="No-Break"><strong class="bold">Line (8)</strong></span></p>
			<p><strong class="source-inline">arm-none-eabi-size 2_RegisterManipulation.elf:</strong> This command calculates the size of the compiled program, breaking it down<a id="_idIndexMarker248"/><a id="_idIndexMarker249"/><a id="_idIndexMarker250"/> into text (code), data (initialized data), and bss (uninitialized data) sections. The output shows the size of these sections in bytes and their total in both decimal (<strong class="bold">dec</strong>) and hexadecimal (<span class="No-Break"><strong class="bold">hex</strong></span><span class="No-Break">) formats.</span></p>
			<h3>Creation of a list file:</h3>
			<p><span class="No-Break"><strong class="bold">Line (9)</strong></span></p>
			<p><strong class="source-inline">arm-none-eabi-objdump -h -S 2_RegisterManipulation.elf &gt; "2_RegisterManipulation.list"</strong>: This command disassembles the executable and outputs a detailed list file. The <strong class="source-inline">-h</strong> flag shows the header<a id="_idIndexMarker251"/><a id="_idIndexMarker252"/> information, and <strong class="source-inline">-S</strong> intersperses source code with disassembly. A list file is a detailed textual representation of compiled code, containing both the assembly language instructions and their corresponding machine code, often with annotations of the original high-level <span class="No-Break">source code.</span></p>
			<p>As we can observe from these logs, it is clear that our STM32CubeIDE employs the same GNU Binary Tools previously discussed. In our forthcoming section, we will manually execute these commands via the command line. This approach will teach us how to build our firmware without using an IDE, simply using the source text files, the command-line interface, and our suite of GNU <span class="No-Break">Bin Tools.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor109"/>Working with the GNU bin tools</h2>
			<p>In this section, our focus is to execute<a id="_idIndexMarker253"/><a id="_idIndexMarker254"/> some of the GNU Bin Tools directly, using our command line. To start I want to show you why I use the words <em class="italic">commands</em> and <em class="italic">tools</em> interchangeably to describe the GNU <span class="No-Break">Bin Tools.</span></p>
			<p>Locate the installation folder for the GNU Arm Embedded Toolchain on your computer. On my computer, this is <strong class="source-inline">C:/Program Files(x86)/GNU Arm </strong><span class="No-Break"><strong class="source-inline">Embedded Toolchain.</strong></span></p>
			<p>Once you’ve located the GNU Arm Embedded Toolchain folder, the next step involves accessing the <strong class="source-inline">bin</strong> folder <span class="No-Break">within it.</span></p>
			<p>Upon opening the <strong class="source-inline">bin</strong> folder, you’ll be greeted with a plethora of tools, each represented by an executable file (<strong class="source-inline">.exe</strong>). Looking closely, you will find <strong class="source-inline">arm-none-eabi-gcc.exe</strong>, our compiler, along with other tools we previously discussed. When we input a command corresponding to these tools in the command line, the associated <strong class="source-inline">.exe</strong> file is executed. For instance, entering <strong class="source-inline">arm-none-eabi-gcc</strong> in the command line will run the <span class="No-Break"><strong class="source-inline">arm-none-eabi-gcc.exe</strong></span><span class="No-Break"> executable.</span></p>
			<p>Now that we have clarified that, it’s time to shift our focus toward practical testing. However, before diving into this testing phase, a few essential preparatory steps are required. Let’s create a backup of our current <span class="No-Break">project, </span><span class="No-Break"><strong class="source-inline">2_RegisterManipulation</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li><strong class="bold">Locate your project</strong>: Navigate to your workspace or the folder where the <strong class="source-inline">2_RegisterManipulation</strong> project <span class="No-Break">is stored.</span></li>
				<li><strong class="bold">Copy the project</strong>: Right-click on the <strong class="source-inline">2_RegisterManipulation</strong> project folder, select <strong class="bold">Copy</strong>, and then <strong class="bold">Paste</strong> within the <span class="No-Break">same directory.</span></li>
				<li><strong class="bold">Rename the Backup</strong>: Rename the newly pasted folder <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">2_RegisterManipulation-old</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>With the backup in place, our next<a id="_idIndexMarker255"/><a id="_idIndexMarker256"/> move is to modify the <strong class="source-inline">main.c</strong> file in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">2_Register</strong></span><strong class="source-inline">
Manipulation</strong> project, changing the LED’s behavior from a constant <em class="italic">on</em> state to a <span class="No-Break">blinking one:</span></p>
			<ol>
				<li><strong class="bold">A<a id="_idTextAnchor110"/>ccess the source File</strong>: Go to the <span class="No-Break"><strong class="source-inline">2_RegisterManipulation/Src</strong></span><span class="No-Break"> directory.</span></li>
				<li><strong class="bold">Edit the main.c file</strong>: Right-click on the <strong class="source-inline">main.c</strong> file and choose to open it in a simple text editor, such <span class="No-Break">as Notepad.</span></li>
				<li><strong class="bold">Update the code</strong>: Find the section of code that sets <strong class="source-inline">PA5 (LED_PIN)</strong> high. It should look <span class="No-Break">like this:</span><pre class="source-code">
//  22: Set PA5(LED_PIN) high
GPIOA_OD_R |= LED_PIN;</pre><p class="list-inset">Replace this code with the following to toggle the state of <strong class="source-inline">PA5</strong> and create a <span class="No-Break">blinking effect:</span></p><pre class="source-code">//  22: Toggle PA5(LED_PIN)
GPIOA_OD_R ^= LED_PIN;
for(int i = 0; i &lt; 100000; i++){} // Delay loop for visible blinking</pre></li>				<li><strong class="bold">Save the changes</strong>: After updating the code, save the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></li>
			</ol>
			<p>Let’s go back to our project folder and access the <strong class="source-inline">2_RegisterManipulation/Debug</strong> directory through the command prompt. This specific folder is important because it’s where STM32CubeIDE automatically places the project’s <strong class="source-inline">makefile</strong>. Understanding the role and structure of <strong class="bold">makefiles</strong> is crucial in embedded firmware development, and we will delve<a id="_idIndexMarker257"/><a id="_idIndexMarker258"/> into this topic in more detail in <span class="No-Break">upcoming chapters.</span></p>
			<p>We can access the folder through the command prompt in <span class="No-Break">multiple ways:</span></p>
			<p>Windows users can choose between <span class="No-Break">these methods:</span></p>
			<ul>
				<li><strong class="bold">Method 1 – using the context menu</strong>: Navigate to the <strong class="source-inline">2_RegisterManipulation/Debug</strong> folder in Windows Explorer. Once there, hold down the <em class="italic">Shift</em> key, right-click in an empty space within the folder, and select <strong class="bold">Open Command Window Here</strong>. This action will open a Command Prompt window directly in the <span class="No-Break"><strong class="source-inline">Debug</strong></span><span class="No-Break"> folder.</span></li>
				<li><strong class="bold">Method 2 – copying the path</strong>: Alternatively, click on the address bar in Windows Explorer while in the <strong class="source-inline">2_RegisterManipulation/Debug</strong> folder and then copy the folder path. Then, open Command Prompt from the <strong class="bold">Start</strong> menu or by typing <strong class="source-inline">cmd</strong> in the <strong class="bold">Run</strong> dialog (<em class="italic">Win</em> + <em class="italic">R</em>). In the Command Prompt, type <strong class="source-inline">cd</strong> (note the space after ‘cd’), paste the copied path, and press <em class="italic">Enter</em>. This will change the directory to the <span class="No-Break"><strong class="source-inline">Debug</strong></span><span class="No-Break"> folder.</span></li>
			</ul>
			<p>Users of other operating systems can choose<a id="_idIndexMarker259"/><a id="_idIndexMarker260"/> between <span class="No-Break">these methods:</span></p>
			<ul>
				<li>Navigate to the folder, and open the terminal specific to your <span class="No-Break">operating system.</span></li>
				<li> Use the <strong class="source-inline">cd</strong> (change directory) command, followed by the absolute path to the <strong class="source-inline">2_RegisterManipulation/Debug</strong> folder to navigate to it. The exact path may vary, based on where the project is located on <span class="No-Break">your system.</span></li>
			</ul>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B21914_03_06.jpg" alt="Figure 3.6: Accessing the Debug folder through the Windows Command Prompt" width="996" height="287"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Accessing the Debug folder through the Windows Command Prompt</p>
			<p>In this practical exercise, we’ll replicate the commands used by STM32CubeIDE, extracting them directly from its console pane. We’ll execute them one by one, as depicted in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em>, starting with line number 2 (since our current focus isn’t <span class="No-Break">on makefiles).</span></p>
			<p>To do this, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Copy line number 2 from the STM32CubeIDE console pane and paste it into the command prompt. This line compiles the startup file using <strong class="source-inline">arm-none-eabi-gcc</strong>, referencing paths specific to my <span class="No-Break">system setup:</span><pre class="source-code">
<strong class="bold">C:\Users\Ninsaw\Documents\tempWorkspace\2_RegisterManipulation\Debug&gt;arm-none-eabi-gcc -mcpu=cortex-m4 -g3 -DDEBUG -c -x assembler-with-cpp -MMD -MP -MF"Startup/startup_stm32f411retx.d" -MT"Startup/startup_stm32f411retx.o" --specs=nano.specs -mfpu=fpv4-sp-d16 -mfloat-abi=hard -mthumb -o "Startup/startup_stm32f411retx.o" "../Startup/startup_stm32f411retx.s"</strong></pre><p class="list-inset">Successful execution will not result in any <span class="No-Break">error messages.</span></p></li>				<li>P<a id="_idTextAnchor111"/>roceed with line number 3, which compiles the <strong class="source-inline">main.c</strong> file. However, before pasting this command into the command prompt, remove the <strong class="source-inline">-fcyclomatic-complexity</strong> flag, as it is not supported by some versions of the GNU Toolchain for Arm. Paste the command into a text editor, delete the flag, and then copy the modified command into the command prompt. The command for line number 3 should look <span class="No-Break">like this:</span><pre class="source-code">
<strong class="bold"> C:\Users\Ninsaw\Documents\tempWorkspace\2_RegisterManipulation\Debug&gt;arm-none-eabi-gcc "../Src/main.c" -mcpu=cortex-m4 -std=gnu11 -g3 -DDEBUG -DNUCLEO_F411RE -DSTM32 -DSTM32F4 -DSTM32F411RETx -c -I../Inc -O0 -ffunction-sections -fdata-sections -Wall -fstack-usage -MMD -MP -MF"Src/main.d" -MT"Src/main.o" --specs=nano.specs -mfpu=fpv4-sp-d16 -mfloat-abi=hard -mthumb -o "Src/main.o"</strong></pre></li>				<li>Follow the same procedure for lines<a id="_idIndexMarker261"/><a id="_idIndexMarker262"/> 4 and 5 to compile the <strong class="source-inline">syscalls.c</strong> and <strong class="source-inline">system.c</strong> <span class="No-Break">files, respectively.</span></li>
				<li>We will proceed to link these files. To do this, copy the linking command, which is on line number 6 in the STM32CubeIDE console pane, and paste it into the command prompt, <span class="No-Break">like this:</span><pre class="source-code">
<strong class="bold">C:\Users\Ninsaw\Documents\tempWorkspace\2_RegisterManipulation\Debug&gt;arm-none-eabi-gcc -o "2_RegisterManipulation.elf" @"objects.list"</strong><strong class="bold">   -mcpu=cortex-m4 -T"C:\Users\Ninsaw\Documents\tempWorkspace\2_RegisterManipulation\STM32F411RETX_FLASH.ld" --specs=nosys.specs -Wl,-Map="2_RegisterManipulation.map" -Wl,--gc-sections -static --specs=nano.specs -mfpu=fpv4-sp-d16 -mfloat-abi=hard -mthumb -Wl,--start-group -lc -lm -Wl,--end-group</strong></pre><p class="list-inset">A successful linking process will not result in any <span class="No-Break">error messages.</span></p></li>				<li>We can use the <strong class="source-inline">arm-none-eabi-size</strong> command to display the size of our output <strong class="source-inline">.elf</strong> file. This will give us insights into the sizes of various sections, such as <strong class="bold">text</strong>, <strong class="bold">data</strong>, and <strong class="bold">bss</strong>. We will discuss these sections in detail later in the book, particularly when we delve into writing <span class="No-Break">linker scripts.</span></li>
			</ol>
			<p>To execute this, copy line number 8 from the STM32CubeIDE console pane and paste it into the command prompt. Running the <span class="No-Break">following command:</span></p>
			<pre class="console">
C:<a id="_idTextAnchor112"/>\Users\Ninsaw\Documents\tempWorkspace\2_RegisterManipulation\Debug&gt;arm-none-eabi-size   2_RegisterManipulation.elf</pre>			<p>It will display the size details of the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">elf</strong></span><span class="No-Break"> file:</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B21914_03_07.jpg" alt="Figure 3.7: Output produced by executing the arm-none-eabi-size command" width="1091" height="99"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Output produced by executing the arm-none-eabi-size command</p>
			<p>Observing the results, we can confirm that the output<a id="_idIndexMarker263"/><a id="_idIndexMarker264"/> matches exactly what is displayed in the STM32CubeIDE <span class="No-Break">console pane.</span></p>
			<p>At this stage, we can choose to convert our <strong class="source-inline">.elf</strong> file into the <strong class="source-inline">.bin</strong> format using the <strong class="source-inline">arm-none-eabi-objcopy</strong> tool, with the <span class="No-Break">appropriate flags.</span></p>
			<p>Type the following in the command prompt and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></p>
			<pre class="console">
arm-none-eabi-objcopy -O binary 2_RegisterManipulation.elf 2_RegisterManipulation.bin</pre>			<p>Let’s break down <span class="No-Break">this snippet:</span></p>
			<ul>
				<li><strong class="source-inline">-O binary</strong> specifies the output format, which in this case is a <span class="No-Break">binary file</span></li>
				<li><strong class="source-inline">2_RegisterManipulation.elf</strong> is the source ELF file you <span class="No-Break">are converting</span></li>
				<li><strong class="source-inline">2_R<a id="_idTextAnchor113"/>egisterManipulation.bin</strong> is the name of the output binary file that will <span class="No-Break">be created</span></li>
			</ul>
			<p>This final step marks the completion of our first build process. We have successfully compiled and linked all necessary files, resulting in the creation of our final executable in two formats. The next process involves uploading the firmware to our microcontroller using <em class="italic">OpenOCD</em>. This will be covered in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor114"/>Uploading firmware to the microcontroller using OpenOCD</h2>
			<p><strong class="bold">Open On-Chip Debugger</strong> (<strong class="bold">OpenOCD</strong>) plays an important<a id="_idIndexMarker265"/><a id="_idIndexMarker266"/> role in embedded firmware programming. It not only facilitates the transfer of executable<a id="_idIndexMarker267"/><a id="_idIndexMarker268"/> firmware code to a microcontroller but also provides robust debugging capabilities. In this section, we shall go through a step-by-step process to upload the <strong class="source-inline">2_RegisterManipulation</strong> executable file into <span class="No-Break">our microcontroller.</span></p>
			<p>We will start by locating the correct<a id="_idIndexMarker269"/><a id="_idIndexMarker270"/> OpenOCD script for our development board. OpenOCD comes with a variety of scripts, each tailored to different microcontrollers and development boards. In our case, the focus is on the <strong class="bold">st_nucleo_f4 series</strong>. To find the right <a id="_idIndexMarker271"/><a id="_idIndexMarker272"/>script, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Navigate to the OpenOCD installation directory, typically found in the <strong class="source-inline">Program Files</strong> folder for Windows users. The OpenOCD folder is usually named <strong class="source-inline">xpack-openocd</strong>. Once there, enter the <strong class="source-inline">openocd</strong> subfolder, then the <strong class="source-inline">scripts</strong> subfolder, and finally, the <strong class="source-inline">board</strong> subfolder. You will find a file named <strong class="source-inline">st_nucleo_f4.cfg</strong>; this is the OpenOCD file we have to execute for our NUCLEO-F4 <span class="No-Break">development board.</span></li>
				<li>To launch OpenOCD, connect your development board, open the command prompt window, and enter the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">openocd -f board/st_nucleo_f4.cfg</strong></pre><p class="list-inset">This command starts OpenOCD with the configuration file specific to the STM32 NUCLEO F4 development board. The configuration file, <strong class="source-inline">st_nucleo_f4.cfg</strong>, contains all the necessary settings for OpenOCD to communicate with the <span class="No-Break">development board.</span></p></li>			</ol>
			<p>This is a snippet of the output from the command<a id="_idIndexMarker273"/><a id="_idIndexMarker274"/> prompt after executing <span class="No-Break">the command:</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B21914_03_08.jpg" alt="Figure 3.8: OpenOCD’s first output" width="933" height="478"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: OpenOCD’s first output</p>
			<p>The information presented here includes <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Communication ports</strong>: OpenOCD reports that it is listening on port <strong class="source-inline">6666</strong> for Tcl connections and port <strong class="source-inline">4444</strong> for Telnet connections. These ports are used to send commands to OpenOCD and interact with it during <span class="No-Break">debugging sessions.</span></li>
				<li><strong class="bold">Processor and debug capabilities</strong>: The debugger has identified the Cortex-M4 r0p1 processor in the STM32F4 series microcontroller. Additionally, it notes that the target has six breakpoints and four watchpoints, which are crucial for setting breakpoints and watchpoints <span class="No-Break">during debugging.</span></li>
				<li><strong class="bold">GDB server initiation</strong>: The last two lines in the output indicate that a GDB server has been started for the STM32F4 series CPU on port <strong class="source-inline">3333</strong>. This server allows a <strong class="bold">GDB</strong> (<strong class="bold">GNU Debugger</strong>) client to connect for <span class="No-Break">debugging</span><span class="No-Break"><a id="_idIndexMarker275"/><a id="_idIndexMarker276"/></span><span class="No-Break"> purposes.</span></li>
			</ul>
			<p>With OpenOCD running, the next step involves using the GDB to upload the firmware to the microcontroller. Let’s access another command prompt window, still from the Debug folder (as OpenOCD should keep running in the first one), and enter the following command to start <span class="No-Break">the GDB:</span></p>
			<pre class="console">
arm-none-eabi-gdb</pre>			<p>Once the GDB is open, we establish a connection to the microcontroller by running <span class="No-Break">the following:</span></p>
			<pre class="console">
target remote localhost:3333</pre>			<p>This command connects GDB<a id="_idIndexMarker277"/><a id="_idIndexMarker278"/> to the OpenOCD server running<a id="_idIndexMarker279"/><a id="_idIndexMarker280"/> on the local machine (<strong class="source-inline">localhost</strong>) on port <strong class="source-inline">3333</strong>, which is the default port <span class="No-Break">for OpenOCD.</span></p>
			<p>Upon executing this command, both command prompt windows return outputs telling us that debugging <span class="No-Break">has started:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B21914_03_09.jpg" alt="Figure 3.9: Output from the command prompt window running the GDB" width="901" height="548"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Output from the command prompt window running the GDB</p>
			<p>This is the output from the command prompt window running <span class="No-Break"><strong class="source-inline">st_nucleo_f4.cfg</strong></span><span class="No-Break"> :</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B21914_03_10.jpg" alt="Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg" width="843" height="536"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg</p>
			<p>Before<a id="_idIndexMarker281"/> loading the<a id="_idIndexMarker282"/> firmware, we have to reset and initialize the board using the <span class="No-Break">following command:</span></p>
			<pre class="console">
monitor reset init</pre>			<p>Let’s break down the command into <span class="No-Break">its components:</span></p>
			<ul>
				<li><strong class="source-inline">monitor</strong>: This prefix is used in the GDB to indicate that the following command is not a GDB command but is meant for the debugging server (in this <span class="No-Break">case, OpenOCD)</span></li>
				<li><strong class="source-inline">reset</strong>: This part of the command instructs OpenOCD to reset the <span class="No-Break">target device</span></li>
				<li><strong class="source-inline">init</strong>: This tells OpenOCD to execute its initialization sequence for the <span class="No-Break">target device</span></li>
			</ul>
			<p>Then, we load the firmware onto the microcontroller using the <span class="No-Break">following command:</span><a id="_idTextAnchor115"/></p>
			<pre class="console">
monitor flash write_image erase 2_RegisterManipulation.el<a id="_idTextAnchor116"/>f</pre>			<p>This command erases the existing firmware on the microcontroller and writes the new firmware (in this case, <strong class="source-inline">2_RegisterManipulation.elf</strong>) onto it. This command erases the<a id="_idIndexMarker283"/> existing firmware on the microcontroller and writes the new firmware (in this case, <strong class="source-inline">2_RegisterManipulation.elf</strong>) <span class="No-Break">onto it:</span></p>
			<ul>
				<li><strong class="source-inline">flash write_image</strong>: This is an OpenOCD command that tells it to write an image to the flash memory of the target microcontroller – in effect, programming the microcontroller with a new <span class="No-Break">firmware image.</span></li>
				<li><strong class="source-inline">erase</strong>: This option tells OpenOCD to erase the flash memory before writing the new image. Erasing the flash is a common requirement in microcontroller programming, as it clears any previous program and ensures that the new firmware is written to a clean <span class="No-Break">memory space.</span></li>
			</ul>
			<p>After <a id="_idIndexMarker284"/>successfully loading the firmware, we reset the board again with the same <span class="No-Break"><strong class="source-inline">reset</strong></span><span class="No-Break"> command.</span></p>
			<pre class="console">
monitor reset init</pre>			<p>Then, we resume the execution of the code on the microcontroller with <span class="No-Break">the following:</span></p>
			<pre class="console">
monitor resume</pre>			<p>Voila! The firmware should now be running on the microcontroller. You should see the LED on the board blinking, indicating the successful upload and execution of the <span class="No-Break">new firmware.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor117"/>Summary</h1>
			<p>In this chapter, we explored the intricacies of the embedded firmware build process, with a specific focus on the <span class="No-Break">GNU Toolchain.</span></p>
			<p>We began by getting to know the embedded build process, exploring its multiple stages – pre-processing, compilation, assembly, linking, and locating. Each stage was analyzed, clarifying its significance in transforming human-readable source code into executable machine instructions. We delved into the roles of pre-processing in preparing code, the nuances of compilation and assembly in translating and converting code, and the intricate tasks of linking and locating in forming a cohesive, <span class="No-Break">executable binary.</span></p>
			<p>Transitioning to practical application, the chapter introduced the GNU Binary Tools for Embedded Systems. By revisiting our previously developed bare-metal GPIO driver, we observed the build commands executed by the STM32CubeIDE, replicating these steps manually using our command-line interface. This approach gave us a deeper appreciation of the underlying processes and commands that IDEs automate. In the latter part of the chapter, we went through the step-by-step process of uploading our firmware to the microcontroller using OpenOCD, from locating the correct OpenOCD script for the development board to executing commands to reset, initialize, and run the firmware on the microcontroller. This practical exercise demonstrated the successful application of the theoretical knowledge we gained earlier, marking a significant milestone in <span class="No-Break">our journey.</span></p>
			<p>In the next chapter, we shall learn how to write our own linker scripts and startup files. This important step will represent another significant milestone in our journey toward mastering the art of developing entirely bare-metal firmware from the <span class="No-Break">ground up.</span></p>
		</div>
	</div>
</div>
</body></html>