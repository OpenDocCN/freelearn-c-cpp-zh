["```cpp\nclass Cell { \n  private: \n    Cell(double value, Cell *previous, Cell *next); \n    friend class LinkedList; \n\n  public: \n    double getValue() const { return m_value; } \n    void setValue(double value) { m_value = value; } \n\n    Cell *getPrevious() const { return m_previous; } \n    void setPrevious(Cell *previous) { m_previous = previous; } \n\n    Cell *getNext() const { return m_next; } \n    void setNext(Cell *getNext) { m_next = getNext; } \n\n  private: \n    double m_value; \n    Cell *m_previous, *m_next; \n}; \n```", "```cpp\n#include \"Cell.h\" \n\nCell::Cell(double value, Cell *previous, Cell *next) \n :m_value(value), \n  m_previous(previous), \n  m_next(next) { \n  // Empty. \n} \n```", "```cpp\nclass Iterator { \n  private: \n    Iterator(Cell *cellPtr); \n    friend class LinkedList; \n\n  public: \n    Iterator(); \n```", "```cpp\n    Iterator(const Iterator& iterator); \n\n    double getValue() { return m_cellPtr->getValue(); } \n    void setValue(double value) { m_cellPtr->setValue(value); } \n```", "```cpp\n    bool hasNext() const { return (m_cellPtr != nullptr); } \n    void next() { m_cellPtr = m_cellPtr->getNext(); } \n```", "```cpp\n    bool hasPrevious() const { return (m_cellPtr != nullptr); } \n    void previous() { m_cellPtr = m_cellPtr->getPrevious(); } \n\n  private: \n    Cell *m_cellPtr; \n}; \n```", "```cpp\n#include \"Cell.h\" \n#include \"Iterator.h\" \n\nIterator::Iterator(Cell *cellPtr) \n :m_cellPtr(cellPtr) { \n  // Empty. \n}  \n\nIterator::Iterator() \n :m_cellPtr(nullptr) { \n  // Empty. \n} \n\nIterator::Iterator(const Iterator& iterator) \n :m_cellPtr(iterator.m_cellPtr) { \n  // Empty. \n} \n```", "```cpp\nclass LinkedList { \n  public: \n    LinkedList(); \n```", "```cpp\n    LinkedList(const LinkedList& list); \n    void assign(const LinkedList& list); \n```", "```cpp\n    ~LinkedList(); \n\n    int size() const {return m_size;} \n    bool empty() const {return (m_size == 0);} \n```", "```cpp\n    bool find(double value, Iterator& findIterator); \n```", "```cpp\n    bool equal(const LinkedList& list) const; \n    bool notEqual(const LinkedList& list) const; \n```", "```cpp\n    void add(double value); \n    void add(const LinkedList& list); \n\n    void insert(const Iterator& insertPosition, double value); \n    void insert(const Iterator& insertPosition, \n                const LinkedList& list); \n```", "```cpp\n    void erase(const Iterator& erasePosition); \n    void clear(); \n```", "```cpp\n    void remove(const Iterator& firstPosition, \n                const Iterator& lastPosition = Iterator(nullptr)); \n```", "```cpp\n    Iterator first() const { return Iterator(m_firstCellPtr); } \n    Iterator last() const { return Iterator(m_lastCellPtr); } \n```", "```cpp\n    void read(istream& inStream); \n    void write(ostream& outStream); \n```", "```cpp\n  private: \n    int m_size; \n    Cell *m_firstCellPtr, *m_lastCellPtr; \n}; \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"Cell.h\" \n#include \"Iterator.h\" \n#include \"List.h\" \n\nLinkedList::LinkedList() \n :m_size(0), \n  m_firstCellPtr(nullptr), \n  m_lastCellPtr(nullptr) { \n  // Empty. \n} \n```", "```cpp\nLinkedList::LinkedList(const LinkedList& list) { \n  assign(list); \n} \n```", "```cpp\nvoid LinkedList::assign(const LinkedList& list) { \n  m_size = 0; \n  m_firstCellPtr = nullptr; \n  m_lastCellPtr = nullptr; \n  Cell *listCellPtr = list.m_firstCellPtr;\n  add(list);\n} \n```", "```cpp\nLinkedList::~LinkedList() { \n  clear(); \n} \n```", "```cpp\nvoid LinkedList::clear() { \n  Cell *currCellPtr = m_firstCellPtr; \n```", "```cpp\n  while (currCellPtr != nullptr) { \n    Cell *deleteCellPtr = currCellPtr; \n    currCellPtr = currCellPtr->getNext(); \n    delete deleteCellPtr; \n  } \n```", "```cpp\n  m_firstCellPtr = nullptr; \n  m_lastCellPtr = nullptr; \n  m_size = 0; \n} \n```", "```cpp\nbool LinkedList::find(double value, Iterator& findIterator) { \n  Iterator iterator = first(); \n\n  while (iterator.hasNext()) { \n    if (value == iterator.getValue()) { \n      findIterator = iterator; \n      return true; \n    } \n\n    iterator.next(); \n  } \n\n  return false; \n} \n```", "```cpp\nbool LinkedList::equal(const LinkedList& list) const { \n  if (m_size != list.m_size) { \n    return false; \n  } \n\n  Iterator thisIterator = first(), listIterator = list.first(); \n\n  while (thisIterator.hasNext()) { \n    if (thisIterator.getValue() != listIterator.getValue()) { \n      return false; \n    } \n\n    thisIterator.next(); \n    listIterator.next(); \n  } \n```", "```cpp\n  return true; \n} \n```", "```cpp\nbool LinkedList::notEqual(const LinkedList& list) const { \n  return !equal(list); \n} \n```", "```cpp\nvoid LinkedList::add(double value) { \n  Cell *newCellPtr = new Cell(value, m_lastCellPtr, nullptr); \n```", "```cpp\n  if (m_firstCellPtr == nullptr) { \n    m_firstCellPtr = newCellPtr; \n  } \n```", "```cpp\n  else { \n    m_lastCellPtr->setNext(newCellPtr); \n  } \n```", "```cpp\n  m_lastCellPtr = newCellPtr; \n  ++m_size; \n} \n```", "```cpp\nvoid LinkedList::add(const LinkedList& list) { \n  Cell *listCellPtr = list.m_firstCellPtr; \n```", "```cpp\n  while (listCellPtr != nullptr) { \n    double value = listCellPtr->getValue(); \n    Cell *newCellPtr = new Cell(value, m_lastCellPtr, nullptr);  \n```", "```cpp\n    if (m_firstCellPtr == nullptr) { \n      m_firstCellPtr = newCellPtr; \n    } \n```", "```cpp\n    else {       \n      m_lastCellPtr->setNext(newCellPtr); \n    } \n```", "```cpp\n    m_lastCellPtr = newCellPtr; \n```", "```cpp\n    listCellPtr = listCellPtr->getNext(); \n  } \n\n  m_size += list.m_size; \n} \n```", "```cpp\nvoid LinkedList::insert(const Iterator& insertPosition, \n                        double value) { \n  Cell *insertCellPtr = insertPosition.m_cellPtr; \n  Cell *newCellPtr = \n    new Cell(value, insertCellPtr->getPrevious(), insertCellPtr);  \n  insertCellPtr->setPrevious(newCellPtr); \n\n  if (insertCellPtr == m_firstCellPtr) { \n    m_firstCellPtr = newCellPtr; \n  } \n  else { \n    newCellPtr->getPrevious()->setNext(newCellPtr); \n  } \n\n  ++m_size; \n} \n```", "```cpp\nvoid LinkedList::insert(const Iterator& insertPosition, \n                        const LinkedList& list) { \n  Cell *insertCellPtr = insertPosition.m_cellPtr; \n\n  if (insertCellPtr == nullptr) { \n    add(list); \n  } \n  else { \n    Cell *firstInsertCellPtr = nullptr, \n         *lastInsertCellPtr = nullptr, \n         *listCellPtr = list.m_firstCellPtr; \n\n    while (listCellPtr != nullptr) { \n      Cell *newCellPtr = new Cell(listCellPtr->getValue(), \n                                  lastInsertCellPtr, nullptr); \n\n      if (firstInsertCellPtr == nullptr) { \n        firstInsertCellPtr = newCellPtr; \n      } \n      else { \n        lastInsertCellPtr->setNext(newCellPtr); \n      } \n\n      lastInsertCellPtr = newCellPtr; \n      listCellPtr = listCellPtr->getNext(); \n    } \n```", "```cpp\n    if (firstInsertCellPtr != nullptr) { \n      if (insertCellPtr->getPrevious() != nullptr) { \n        insertCellPtr->getPrevious()->setNext(firstInsertCellPtr); \n        firstInsertCellPtr-> \n          setPrevious(insertCellPtr->getPrevious()); \n      } \n      else { \n        m_firstCellPtr = firstInsertCellPtr; \n      } \n    } \n\n    if (lastInsertCellPtr != nullptr) { \n      lastInsertCellPtr->setNext(insertCellPtr); \n      insertCellPtr->setPrevious(lastInsertCellPtr); \n    } \n\n    m_size += list.m_size; \n  } \n} \n```", "```cpp\nvoid LinkedList::erase(const Iterator& removePosition) { \n  remove(removePosition, removePosition); \n} \n```", "```cpp\nvoid LinkedList::remove(const Iterator& firstPosition, \n           const Iterator& lastPosition /*= Iterator(nullptr)*/) { \n  Cell *firstCellPtr = firstPosition.m_cellPtr, \n       *lastCellPtr = lastPosition.m_cellPtr; \n  lastCellPtr = (lastCellPtr == nullptr) \n                ? m_lastCellPtr : lastCellPtr; \n\n  Cell *previousCellPtr = firstCellPtr->getPrevious(), \n       *nextCellPtr = lastCellPtr->getNext(); \n\n  Cell *currCellPtr = firstCellPtr; \n  while (currCellPtr != nextCellPtr) { \n    Cell *deleteCellPtr = currCellPtr; \n    currCellPtr = currCellPtr->getNext(); \n    delete deleteCellPtr; \n    --m_size; \n  } \n```", "```cpp\n  if (previousCellPtr != nullptr) { \n    previousCellPtr->setNext(nextCellPtr); \n  } \n  else { \n    m_firstCellPtr = nextCellPtr; \n  } \n```", "```cpp\n  if (nextCellPtr != nullptr) { \n    nextCellPtr->setPrevious(previousCellPtr); \n  } \n  else { \n    m_lastCellPtr = previousCellPtr; \n  } \n} \n```", "```cpp\nvoid LinkedList::read(istream& inStream) { \n  int size; \n  inStream >> size; \n\n  int count = 0; \n  while (count < size) { \n    double value; \n    inStream >> value; \n    add(value); \n    ++count; \n  } \n} \n```", "```cpp\nvoid LinkedList::write(ostream& outStream) { \n  outStream << \"[\"; \n  bool firstValue = true; \n\n  Iterator iterator = first(); \n  while (iterator.hasNext()) { \n    outStream << (firstValue ? \"\" : \",\") << iterator.getValue(); \n    firstValue = false; \n    iterator.next(); \n  } \n\n  outStream << \"]\"; \n} \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"Cell.h\" \n#include \"Iterator.h\" \n#include \"List.h\" \n\nvoid main() { \n  LinkedList list; \n  list.add(1); \n  list.add(2); \n  list.add(3); \n  list.add(4); \n  list.add(5); \n  list.write(cout); \n  cout << endl; \n\n  { Iterator iterator = list.first(); \n    while (iterator.hasNext()) { \n      cout << iterator.getValue() << \" \"; \n      iterator.next(); \n    } \n    cout << endl; \n  } \n\n  { Iterator iterator = list.last(); \n    while (iterator.hasPrevious()) { \n      cout << iterator.getValue() << \" \"; \n      iterator.previous(); \n    } \n    cout << endl; \n  } \n} \n```", "```cpp\nclass Set : private LinkedList { \n  public: \n    Set(); \n    Set(double value); \n    Set(const Set& set); \n    void assign(const Set& set); \n    ~Set(); \n```", "```cpp\n    bool equal(const Set& set) const; \n    bool notEqual(const Set& set) const; \n```", "```cpp\n    bool exists(double value) const; \n    bool exists(const Set& set) const; \n```", "```cpp\n    bool insert(double value); \n    bool insert(const Set& set); \n```", "```cpp\n    bool remove(double value); \n    bool remove(const Set& set); \n```", "```cpp\n    int size() const { return LinkedList::size(); } \n    bool empty() const { return LinkedList::empty(); } \n    Iterator first() const { return LinkedList::first(); } \n```", "```cpp\n    friend Set unionSet(const Set& leftSet, const Set& rightSet); \n    friend Set intersection(const Set& leftSet, \n                            const Set& rightSet); \n    friend Set difference(const Set& leftSet, \n                          const Set& rightSet); \n```", "```cpp\n    void read(istream& inStream); \n    void write(ostream& outStream); \n}; \n```", "```cpp\nSet unionSet(const Set& leftSet, const Set& rightSet);\nSet intersection(const Set& leftSet, const Set& rightSet);\nSet difference(const Set& leftSet, const Set& rightSet);\n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"..\\ListBasic\\Cell.h\" \n#include \"..\\ListBasic\\Iterator.h\" \n#include \"..\\ListBasic\\List.h\" \n#include \"Set.h\" \n```", "```cpp\nSet::Set() { \n  // Empty. \n} \n\nSet::Set(double value) { \n  add(value); \n} \n\nSet::Set(const Set& set) \n :LinkedList(set) { \n  // Empty. \n} \n```", "```cpp\nSet::~Set() { \n  // Empty. \n} \n```", "```cpp\nvoid Set::assign(const Set& set) { \n  clear(); \n  add(set); \n} \n```", "```cpp\nbool Set::equal(const Set& set) const { \n  if (size() != set.size()) { \n    return false; \n  } \n\n  Iterator iterator = first(); \n  while (iterator.hasNext()) { \n    if (!set.exists(iterator.getValue())) { \n      return false; \n    } \n\n    iterator.next(); \n  } \n\n  return true;          \n} \n\nbool Set::notEqual(const Set& set) const { \n  return !equal(set); \n} \n```", "```cpp\nbool Set::exists(double value) const { \n  Iterator iterator = first(); \n\n  while (iterator.hasNext()) { \n    if (value == iterator.getValue()) { \n      return true; \n    } \n\n    iterator.next(); \n  } \n\n  return false; \n} \n```", "```cpp\nbool Set::exists(const Set& set) const { \n  Iterator iterator = set.first(); \n\n  while (iterator.hasNext()) { \n    if (!exists(iterator.getValue())) { \n      return false; \n    } \n\n    iterator.next(); \n  } \n\n  return true; \n} \n```", "```cpp\nbool Set::insert(double value) { \n  if (!exists(value)) { \n    add(value); \n    return true; \n  } \n\n  return false; \n} \n```", "```cpp\nbool Set::insert(const Set& set) { \n  bool inserted = false; \n  Iterator iterator = set.first(); \n\n  while (iterator.hasNext()) { \n    double value = iterator.getValue(); \n\n    if (insert(value)) { \n      inserted = true; \n    } \n\n    iterator.next(); \n  } \n\n  return inserted; \n} \n```", "```cpp\nbool Set::remove(double value) { \n  Iterator iterator; \n\n  if (find(value, iterator)) { \n    erase(iterator); \n    return true; \n  } \n\n  return false; \n} \n```", "```cpp\nbool Set::remove(const Set& set) { \n  bool removed = false; \n  Iterator iterator = set.first(); \n\n  while (iterator.hasNext()) { \n    double value = iterator.getValue(); \n\n    if (remove(value)) { \n      removed = true; \n    } \n\n    iterator.next(); \n  } \n\n  return removed; \n} \n```", "```cpp\nSet unionSet(const Set& leftSet, const Set& rightSet) { \n  Set result(leftSet); \n  result.insert(rightSet); \n  return result; \n} \n```", "```cpp\nSet intersection(const Set& leftSet, const Set& rightSet) { \n  return difference(difference(unionSet(leftSet, rightSet), \n                               difference(leftSet, rightSet)), \n                    difference(rightSet, leftSet)); \n} \n```", "```cpp\nSet difference(const Set& leftSet, const Set& rightSet) { \n  Set result(leftSet); \n  result.remove(rightSet); \n  return result; \n} \n```", "```cpp\nvoid Set::read(istream& inStream) { \n  int size; \n  inStream >> size; \n\n  int count = 0; \n  while (count < size) { \n    double value; \n    inStream >> value; \n    insert(value); \n    ++count; \n  } \n} \n```", "```cpp\nvoid Set::write(ostream& outStream) { \n  outStream << \"{\"; \n  bool firstValue = true; \n  Iterator iterator = first(); \n\n  while (iterator.hasNext()) { \n    outStream << (firstValue ? \"\" : \",\") << iterator.getValue(); \n    firstValue = false; \n    iterator.next(); \n  } \n\n  outStream << \"}\"; \n} \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"..\\ListBasic\\Cell.h\" \n#include \"..\\ListBasic\\Iterator.h\" \n#include \"..\\ListBasic\\List.h\" \n#include \"Set.h\" \n\nvoid main() { \n  Set s, t; \n  s.read(cin); \n  t.read(cin); \n\n  cout << endl << \"s = \"; \n  s.write(cout); \n  cout << endl; \n\n  cout << endl << \"t = \"; \n  t.write(cout); \n  cout << endl << endl; \n\n  cout << \"union: \"; \n  unionSet(s, t).write(cout); \n  cout << endl; \n\n  cout << \"intersection: \"; \n  unionSet(s, t).write(cout); \n  cout << endl; \n\n  cout << \"difference: \"; \n  unionSet(s, t).write(cout); \n  cout << endl; \n} \n```", "```cpp\nint linarySearch(double value, const LinkedList& list); \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"..\\ListBasic\\Cell.h\" \n#include \"..\\ListBasic\\Iterator.h\" \n#include \"..\\ListBasic\\List.h\" \n#include \"Search.h\" \n\nint linarySearch(double value, const LinkedList& list) { \n  int index = 0; \n```", "```cpp\n  Iterator iterator = list.first(); \n\n  while (iterator.hasNext()) { \n    if (iterator.getValue() == value) { \n      return index; \n    } \n\n    ++index; \n    iterator.next(); \n  } \n\n  return -1; \n} \n```", "```cpp\nvoid selectSort(LinkedList& list); \nvoid insertSort(LinkedList& list); \nvoid bubbleSort(LinkedList& list); \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"..\\ListBasic\\Cell.h\" \n#include \"..\\ListBasic\\Iterator.h\" \n#include \"..\\ListBasic\\List.h\" \n#include \"Sort.h\" \n\nvoid insert(double value, LinkedList& list); \nvoid swap(Iterator iterator1, Iterator iterator2); \n```", "```cpp\nvoid selectSort(LinkedList& list) { \n  LinkedList result; \n\n  while (!list.empty()) { \n    Iterator minIterator = list.first(); \n    double minValue = minIterator.getValue(); \n\n    Iterator iterator = list.first(); \n\n    while (iterator.hasNext()) { \n      if (iterator.getValue() < minValue) { \n        minIterator = iterator; \n        minValue = iterator.getValue(); \n      } \n\n      iterator.next(); \n    } \n\n    list.erase(minIterator); \n    result.add(minValue); \n  } \n\n  list.assign(result); \n} \n```", "```cpp\nvoid insertSort(LinkedList& list) { \n  LinkedList result; \n  Iterator iterator = list.first(); \n\n  while (iterator.hasNext()) { \n    insert(iterator.getValue(), result); \n    iterator.next(); \n  } \n\n  list.assign(result); \n} \n```", "```cpp\nvoid insert(double value, LinkedList& list) { \n  Iterator iterator = list.first(); \n\n  while (iterator.hasNext()) { \n    if (value < iterator.getValue()) { \n      list.insert(iterator, value); \n      return; \n    } \n\n    iterator.next(); \n  } \n\n  list.add(value); \n} \n```", "```cpp\nvoid bubbleSort(LinkedList& list) { \n  int listSize = list.size(); \n\n  if (listSize > 1) { \n    int currSize = listSize - 1; \n    int outerCount = 0; \n    while (outerCount < (listSize - 1)) { \n      Iterator currIterator = list.first(); \n      Iterator nextIterator = currIterator; \n      nextIterator.next(); \n      bool changed = false; \n\n      int innerCount = 0; \n      while (innerCount < currSize) { \n        if (currIterator.getValue() > nextIterator.getValue()) { \n          swap(currIterator, nextIterator); \n          changed = true; \n        } \n\n        ++innerCount; \n        currIterator.next(); \n        nextIterator.next(); \n      } \n\n      if (!changed) { \n        break; \n      } \n\n      --currSize; \n      ++outerCount; \n    } \n  } \n} \n```", "```cpp\nvoid swap(Iterator iterator1, Iterator iterator2) { \n  double tempValue = iterator1.getValue(); \n  iterator1.setValue(iterator2.getValue()); \n  iterator2.setValue(tempValue); \n} \n```", "```cpp\n#include <IOStream> \n#include <CStdLib> \n\nusing namespace std; \n\n#include \"..\\ListBasic\\Cell.h\" \n#include \"..\\ListBasic\\Iterator.h\" \n#include \"..\\ListBasic\\List.h\" \n\n#include \"Search.h\" \n#include \"Sort.h\" \n\nvoid main() { \n  cout << \"LinkedList\" << endl; \n\n  LinkedList list; \n  list.add(9); \n  list.add(7); \n  list.add(5); \n  list.add(3); \n  list.add(1); \n\n  list.write(cout); \n  cout << endl; \n```", "```cpp\n  Iterator iterator = list.first(); \n  while (iterator.hasNext()) { \n    cout << \"<\" << iterator.getValue() << \",\" \n         << linarySearch(iterator.getValue(), list) << \"> \"; \n    iterator.next(); \n  } \n```", "```cpp\n  cout << \"<0,\" << linarySearch(0, list) << \"> \"; \n  cout << \"<6,\" << linarySearch(6, list) << \"> \"; \n  cout << \"<10,\" << linarySearch(10, list) << \">\" \n       << endl; \n```", "```cpp\n  cout << \"Bubble Sort \"; \n  bubbleSort(list); \n  list.write(cout); \n  cout << endl; \n\n  cout << \"Select Sort \"; \n  selectSort(list); \n  list.write(cout); \n  cout << endl; \n\n  cout << \"Insert Sort \"; \n  insertSort(list); \n  list.write(cout); \n  cout << endl; \n} \n```", "```cpp\nclass OutOfMemoryException : public exception { \n  // Empty. \n}; \n```", "```cpp\ntemplate <class T> \nclass LinkedList { \n  private: \n    class Cell { \n      private: \n        Cell(const T& value, Cell* previous, Cell* next); \n```", "```cpp\n      public: \n        const T value() const { return m_value; } \n        T& value() { return m_value; } \n```", "```cpp\n        const Cell* previous() const { return m_previous; } \n        Cell*& previous() { return m_previous; } \n\n        const Cell* next() const { return m_next; } \n        Cell*& next() { return m_next; } \n\n        friend class LinkedList; \n\n    private: \n      T m_value; \n      Cell *m_previous, *m_next; \n  }; \n\n  public: \n    class Iterator { \n      public: \n        Iterator(); \n\n      private: \n        Iterator(Cell* cellPtr); \n\n      public: \n        Iterator(const Iterator& iterator); \n        Iterator& operator=(const Iterator& iterator); \n```", "```cpp\n        bool operator==(const Iterator& iterator); \n        bool operator!=(const Iterator& iterator); \n```", "```cpp\n        bool operator++();    // prefix: ++i \n        bool operator++(int); // postfix: i++ \n\n        bool operator--();    // prefix: --i \n        bool operator--(int); // postfix: i-- \n```", "```cpp\n        T operator*() const; \n        T& operator*(); \n\n        friend class LinkedList; \n\n      private: \n        Cell *m_cellPtr; \n    }; \n```", "```cpp\n    class ReverseIterator { \n      public: \n        ReverseIterator(); \n\n      private: \n        ReverseIterator(Cell* cellPtr); \n\n      public: \n        ReverseIterator(const ReverseIterator& iterator); \n        const ReverseIterator& \n              operator=(const ReverseIterator& iterator); \n\n        bool operator==(const ReverseIterator& iterator); \n        bool operator!=(const ReverseIterator& iterator); \n\n        bool operator++();    // prefix: ++i \n        bool operator++(int); // postfix: i++ \n\n        bool operator--(); \n        bool operator--(int); \n\n        T operator*() const; \n        T& operator*(); \n\n        friend class LinkedList; \n\n      private: \n        Cell *m_cellPtr; \n  }; \n\n  public: \n    LinkedList(); \n    LinkedList(const LinkedList& list); \n    LinkedList& operator=(const LinkedList& list); \n    ~LinkedList(); \n    void clear(); \n\n    int size() const {return m_size;} \n    bool empty() const {return (m_size == 0);} \n\n    bool operator==(const LinkedList& list) const; \n    bool operator!=(const LinkedList& list) const; \n\n    void add(const T& value); \n    void add(const LinkedList& list); \n\n    void insert(const Iterator& insertPosition, const T& value); \n    void insert(const Iterator& insertPosition, \n                const LinkedList& list); \n\n    void erase(const Iterator& erasePosition); \n    void remove(const Iterator& firstPosition, \n                const Iterator& lastPosition = Iterator(nullptr)); \n```", "```cpp\n    Iterator begin() const { return Iterator(m_firstCellPtr); } \n    Iterator end() const { return Iterator(nullptr); } \n    ReverseIterator rbegin() const \n      {return ReverseIterator(m_lastCellPtr);} \n    ReverseIterator rend() const \n      { return ReverseIterator(nullptr); } \n```", "```cpp\n    template <class U> \n    friend istream& operator>>(istream& outStream, \n                               LinkedList<U>& list); \n\n    template <class U> \n    friend ostream& operator<<(ostream& outStream, \n                               const LinkedList<U>& list); \n\n  private: \n    int m_size; \n    Cell *m_firstCellPtr, *m_lastCellPtr; \n}; \n```", "```cpp\ntemplate <class T> \nLinkedList<T>::Cell::Cell(const T& value, Cell* previous, \n                          Cell* next) \n :m_value(value), \n  m_previous(previous), \n  m_next(next) { \n  // Empty. \n} \n\ntemplate <class T> \nLinkedList<T>::Iterator::Iterator() \n :m_cellPtr(nullptr) { \n  // Empty. \n}  \n```", "```cpp\ntemplate <class T> \nLinkedList<T>::Iterator::Iterator(Cell* cellPtr) \n :m_cellPtr(cellPtr) { \n  // Empty. \n}  \n\ntemplate <class T> \nLinkedList<T>::Iterator::Iterator(const Iterator& position) \n :m_cellPtr(position.m_cellPtr) { \n  // Empty. \n} \n```", "```cpp\ntemplate <class T> \ntypename LinkedList<T>::Iterator& \nLinkedList<T>::Iterator::operator=(const Iterator& iterator) { \n  m_cellPtr = iterator.m_cellPtr; \n  return *this; \n} \n```", "```cpp\ntemplate <class T> \nbool LinkedList<T>::Iterator::operator==(const Iterator&position){ \n  return (m_cellPtr == position.m_cellPtr); \n} \n\ntemplate <class T> \nbool LinkedList<T>::Iterator::operator!=(const Iterator&position){ \n  return !(*this == position); \n} \n```", "```cpp\ntemplate <class T> \nbool LinkedList<T>::Iterator::operator++() { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->next(); \n    return true; \n  } \n\n  return false; \n} \n\ntemplate <class T> \nbool LinkedList<T>::Iterator::operator++(int) { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->next(); \n    return true; \n  } \n\n  return false; \n} \n```", "```cpp\ntemplate <class T> \nbool LinkedList<T>::Iterator::operator--() { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->previous(); \n    return true; \n  } \n\n  return false; \n} \n\ntemplate <class T> \nbool LinkedList<T>::Iterator::operator--(int) { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->previous(); \n    return true; \n  } \n\n  return false; \n} \n```", "```cpp\ntemplate <class T> \nT LinkedList<T>::Iterator::operator*() const { \n  return m_cellPtr->value(); \n} \n\ntemplate <class T> \nT& LinkedList<T>::Iterator::operator*() { \n  return m_cellPtr->value(); \n} \n```", "```cpp\ntemplate <class T> \nLinkedList<T>::ReverseIterator::ReverseIterator() \n :m_cellPtr(nullptr) { \n  // Empty. \n}  \n\ntemplate <class T> \nLinkedList<T>::ReverseIterator::ReverseIterator(Cell* currCellPtr) \n :m_cellPtr(currCellPtr) { \n  // Empty. \n}  \n\ntemplate <class T> \nLinkedList<T>::ReverseIterator::ReverseIterator \n                                (const ReverseIterator& position) \n :m_cellPtr(position.m_cellPtr) { \n  // Empty. \n} \n```", "```cpp\ntemplate <class T> \nconst typename LinkedList<T>::ReverseIterator& \nLinkedList<T>::ReverseIterator::operator=(const ReverseIterator& position) { \n  m_cellPtr = position.m_cellPtr; \n  return *this; \n} \n```", "```cpp\ntemplate <class T> \nbool LinkedList<T>::ReverseIterator::operator== \n                           (const ReverseIterator& position) { \n  return (m_cellPtr == position.m_cellPtr); \n} \n\ntemplate <class T> \nbool LinkedList<T>::ReverseIterator::operator!= \n                           (const ReverseIterator& position) { \n  return !(*this == position); \n} \n```", "```cpp\ntemplate <class T> \nbool LinkedList<T>::ReverseIterator::operator++() { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->previous(); \n    return true; \n  } \n\n  return false; \n} \n\ntemplate <class T> \nbool LinkedList<T>::ReverseIterator::operator++(int) { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->previous(); \n    return true; \n  } \n\n  return false; \n} \n\ntemplate <class T> \nbool LinkedList<T>::ReverseIterator::operator--() { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->next(); \n    return true; \n  } \n\n  return false; \n} \n\ntemplate <class T> \nbool LinkedList<T>::ReverseIterator::operator--(int) { \n  if (m_cellPtr != nullptr) { \n    m_cellPtr = m_cellPtr->next(); \n    return true; \n  } \n\n  return false; \n} \n\ntemplate <class T> \nT LinkedList<T>::ReverseIterator::operator*() const { \n  return m_cellPtr->value(); \n} \n\ntemplate <class T> \nT& LinkedList<T>::ReverseIterator::operator*() { \n  return m_cellPtr->value(); \n} \n```", "```cpp\ntemplate <class T> \nLinkedList<T>::LinkedList() \n :m_size(0), \n  m_firstCellPtr(nullptr), \n  m_lastCellPtr(nullptr) { \n  // Empty. \n} \n\ntemplate <class T> \nLinkedList<T>::LinkedList(const LinkedList<T>& list) { \n *this = list; \n} \n```", "```cpp\ntemplate <class T> \nLinkedList<T>& LinkedList<T>::operator=(const LinkedList<T>&list){ \n  m_size = 0; \n  m_firstCellPtr = nullptr; \n  m_lastCellPtr = nullptr; \n\n  if (list.m_size > 0) { \n    for (Cell *listCellPtr = list.m_firstCellPtr, \n              *nextCellPtr = list.m_lastCellPtr->next(); \n         listCellPtr != nextCellPtr; \n         listCellPtr = listCellPtr->next()) { \n      Cell *newCellPtr = new Cell(listCellPtr->value(), \n                                  m_lastCellPtr, nullptr); \n\n      if (m_firstCellPtr == nullptr) { \n        m_firstCellPtr = newCellPtr; \n      } \n```", "```cpp\n      else { \n        m_lastCellPtr->next() = newCellPtr; \n      } \n\n      m_lastCellPtr = newCellPtr; \n      ++m_size; \n    } \n  } \n\n  return *this; \n} \n```", "```cpp\ntemplate <class T> \nLinkedList<T>::~LinkedList() { \n  clear(); \n} \n\ntemplate <class T> \nvoid LinkedList<T>::clear() { \n  Cell *currCellPtr = m_firstCellPtr; \n\n  while (currCellPtr != nullptr) { \n    Cell *deleteCellPtr = currCellPtr; \n    currCellPtr = currCellPtr->next(); \n    delete deleteCellPtr; \n  } \n```", "```cpp\n  m_size = 0; \n  m_firstCellPtr = nullptr; \n  m_lastCellPtr = nullptr; \n} \n```", "```cpp\ntemplate <class T> \nbool LinkedList<T>::operator==(const LinkedList<T>& list) const { \n  if (m_size != list.m_size) { \n    return false; \n  } \n\n  for (Iterator thisIterator = begin(), \n                listIterator = list.begin(); \n       thisIterator != end(); ++thisIterator, ++listIterator) { \n    if (*thisIterator != *listIterator) { \n      return false; \n    } \n  } \n\n  return true; \n} \n\ntemplate <class T> \nbool LinkedList<T>::operator!=(const LinkedList<T>& list) const { \n  return !(*this == list); \n} \n```", "```cpp\ntemplate <class T> \nvoid LinkedList<T>::add(const T& value) { \n  Cell *newCellPtr = new Cell(value, m_lastCellPtr, nullptr); \n\n  if (m_lastCellPtr == nullptr) { \n    m_firstCellPtr = newCellPtr; \n    m_lastCellPtr = newCellPtr; \n  } \n  else { \n    m_lastCellPtr->next() = newCellPtr; \n    m_lastCellPtr = newCellPtr; \n  } \n\n  ++m_size; \n} \n```", "```cpp\ntemplate <class T> \nvoid LinkedList<T>::add(const LinkedList<T>& list) { \n  for (Cell *listCellPtr = list.m_firstCellPtr; \n       listCellPtr != nullptr; listCellPtr = listCellPtr->next()){ \n    const T& value = listCellPtr->value(); \n    Cell *newCellPtr = new Cell(value, m_lastCellPtr, nullptr); \n\n    if (m_lastCellPtr == nullptr) { \n      m_firstCellPtr = newCellPtr; \n    } \n    else {       \n      m_lastCellPtr->next() = newCellPtr; \n    } \n\n    m_lastCellPtr = newCellPtr; \n  } \n\n  m_size += list.m_size; \n} \n```", "```cpp\ntemplate <class T> \nvoid LinkedList<T>::insert(const Iterator& insertPosition, \n                           const T& value) { \n  if (insertPosition.m_cellPtr == nullptr) { \n    add(value); \n  } \n  else { \n    Cell *insertCellPtr = insertPosition.m_cellPtr; \n    Cell *newCellPtr = \n      new Cell(value, insertCellPtr->previous(), insertCellPtr); \n\n    insertCellPtr->previous() = newCellPtr; \n\n    if (insertCellPtr == m_firstCellPtr) { \n      m_firstCellPtr = newCellPtr; \n    } \n    else { \n      newCellPtr->previous()->next() = newCellPtr; \n    } \n\n    ++m_size; \n  } \n} \n\ntemplate <class T> \nvoid LinkedList<T>::insert(const Iterator& insertPosition, \n                           const LinkedList<T>& list) { \n  if (insertPosition.m_cellPtr == nullptr) { \n    add(list); \n  } \n  else { \n    Cell *insertCellPtr = insertPosition.m_cellPtr; \n\n    Cell *firstInsertCellPtr = nullptr, \n         lastInsertCellPtr = nullptr; \n    for (Cell *listCellPtr = list.m_firstCellPtr; \n         listCellPtr != nullptr;listCellPtr=listCellPtr->next()) { \n      double value = listCellPtr->value(); \n      Cell *newCellPtr = \n        new Cell(value, lastInsertCellPtr, nullptr); \n\n      if (firstInsertCellPtr == nullptr) { \n        firstInsertCellPtr = newCellPtr; \n      } \n      else { \n        lastInsertCellPtr->next() = newCellPtr; \n      } \n\n      lastInsertCellPtr = newCellPtr; \n    } \n\n    if (firstInsertCellPtr != nullptr) { \n      if (insertCellPtr->previous() != nullptr) { \n        insertCellPtr->previous()->next() = firstInsertCellPtr; \n        firstInsertCellPtr->previous() = \n          insertCellPtr->previous(); \n      } \n      else { \n        m_firstCellPtr = firstInsertCellPtr; \n      } \n    } \n\n    if (lastInsertCellPtr != nullptr) { \n      lastInsertCellPtr->next() = insertCellPtr; \n      insertCellPtr->previous() = lastInsertCellPtr; \n    } \n\n    m_size += list.m_size; \n  } \n} \n\n```", "```cpp\ntemplate <class T> \nvoid LinkedList<T>::erase(const Iterator& removePosition) { \n  remove(removePosition, removePosition); \n} \n\ntemplate <class T> \nvoid LinkedList<T>::remove(const Iterator& firstPosition, \n           const Iterator& lastPosition /*= Iterator(nullptr)*/) { \n  Cell *firstCellPtr = firstPosition.m_cellPtr, \n      *lastCellPtr = lastPosition.m_cellPtr; \n  lastCellPtr = (lastCellPtr == nullptr) \n                ? m_lastCellPtr : lastCellPtr; \n\n  Cell *previousCellPtr = firstCellPtr->previous(), \n      *nextCellPtr = lastCellPtr->next(); \n\n  Cell *currCellPtr = firstCellPtr; \n  while (currCellPtr != nextCellPtr) { \n    Cell *deleteCellPtr = currCellPtr; \n    currCellPtr = currCellPtr->next(); \n    delete deleteCellPtr; \n    --m_size; \n  } \n\n  if (previousCellPtr != nullptr) { \n    previousCellPtr->next() = nextCellPtr;   \n  } \n  else { \n    m_firstCellPtr = nextCellPtr; \n  } \n\n  if (nextCellPtr != nullptr) { \n    nextCellPtr->previous() = previousCellPtr; \n  } \n  else { \n    m_lastCellPtr = previousCellPtr; \n  } \n} \n```", "```cpp\ntemplate <class T> \nistream& operator>>(istream& inStream, LinkedList<T>& list) { \n  int size; \n  inStream >> size; \n\n  for (int count = 0; count < size; ++count) { \n    T value; \n    inStream >> value; \n    list.add(value); \n  } \n\n  return inStream; \n} \n```", "```cpp\ntemplate <class T> \nostream& operator<<(ostream& outStream,const LinkedList<T>& list){ \n  outStream << \"[\"; \n\n  bool first = true; \n  for (const T& value : list) { \n    outStream << (first ? \"\" : \",\") << value; \n    first = false; \n  } \n\n  outStream << \"]\"; \n  return outStream; \n} \n```", "```cpp\n#include <IOStream> \n#include <Exception> \nusing namespace std; \n\n#include \"List.h\" \n\nvoid main() { \n  LinkedList<double> list; \n  cin >> list; \n  cout << list <&amp;lt; endl; \n```", "```cpp\n  for (double value : list) { \n    cout << value << \" \"; \n  } \n  cout << endl; \n```", "```cpp\n  for (LinkedList<double>::Iterator iterator = list.begin(); \n       iterator != list.end(); ++iterator) { \n    cout << *iterator << \" \"; \n  } \n  cout << endl; \n```", "```cpp\n  for (LinkedList<double>::ReverseIterator iterator = \n       list.rbegin(); iterator != list.rend(); ++iterator) { \n    cout << *iterator << \" \"; \n  } \n  cout << endl; \n} \n```", "```cpp\ntemplate <class T> \nclass Set : private LinkedList<T> { \n  public: \n    typedef LinkedList<T>::Iterator Iterator; \n\n    Set(); \n    Set(const T& value); \n    Set(const Set& set); \n    Set& operator=(const Set& set); \n    ~Set(); \n```", "```cpp\n    bool operator==(const Set& set) const; \n    bool operator!=(const Set& set) const; \n\n    int size() const { return LinkedList<T>::size(); } \n    bool empty() const { return LinkedList<T>::empty(); } \n    Iterator begin() const { return LinkedList<T>::begin(); } \n```", "```cpp\n    Set operator+(const Set& set) const; \n    Set operator*(const Set& set) const; \n    Set operator-(const Set& set) const; \n```", "```cpp\n  private: \n    template <class U> \n    friend Set<U> \n      merge(const Set<U>& leftSet, const Set<U>& rightSet, \n            bool addLeft, bool addEqual, bool addRight); \n\n  public: \n    Set& operator+=(const Set& set); \n    Set& operator*=(const Set& set); \n    Set& operator-=(const Set& set); \n```", "```cpp\n    template <class U> \n    friend istream& operator>>(istream& inStream, Set<U>& set); \n\n    template <class U> \n    friend ostream& operator<<(ostream& outStream, \n                               const Set<U>& set); \n}; \n```", "```cpp\ntemplate <class T> \nSet<T>::Set() { \n  // Empty. \n} \n\ntemplate <class T> \nSet<T>::Set(const T& value) { \n  add(value); \n} \n\ntemplate <class T> \nSet<T>::Set(const Set& set) \n :LinkedList(set) { \n  // Empty. \n} \n\ntemplate <class T> \nSet<T>::~Set() { \n  // Empty. \n} \n\ntemplate <class T> \nSet<T>& Set<T>::operator=(const Set& set) { \n  clear(); \n  add(set); \n  return *this; \n} \n```", "```cpp\ntemplate <class T> \nbool Set<T>::operator==(const Set& set) const { \n  return LinkedList::operator==(set); \n} \n```", "```cpp\ntemplate <class T> \nbool Set<T>::operator!=(const Set& set) const { \n  return !(*this == set); \n} \n```", "```cpp\ntemplate <class T> \nSet<T> Set<T>::operator+(const Set& set) const { \n  return merge(*this, set, true, true, true); \n} \n```", "```cpp\ntemplate <class T> \nSet<T> Set<T>::operator*(const Set& set) const { \n  return merge(*this, set, false, true, false); \n} \n```", "```cpp\ntemplate <class T> \nSet<T> Set<T>::operator-(const Set& set) const { \n  return merge(*this, set, true, false, false); \n} \n```", "```cpp\ntemplate <class T> \nSet<T> merge(const Set<T>& leftSet, const Set<T>& rightSet, \n             bool addLeft, bool addEqual, bool addRight) { \n  Set<T> result; \n  Set<T>::Iterator leftIterator = leftSet.begin(), \n                   rightIterator = rightSet.begin(); \n```", "```cpp\n  while ((leftIterator != leftSet.end()) && \n         (rightIterator != rightSet.end())) { \n```", "```cpp\n    if (*leftIterator < *rightIterator) { \n      if (addLeft) { \n        result.add(*leftIterator); \n      } \n\n      ++leftIterator; \n    } \n```", "```cpp\n    else if (*leftIterator > *rightIterator) { \n      if (addRight) { \n        result.add(*rightIterator); \n      } \n\n      ++rightIterator; \n    } \n```", "```cpp\n    else { \n      if (addEqual) { \n        result.add(*leftIterator); \n      } \n\n      ++leftIterator; \n      ++rightIterator; \n    } \n  } \n```", "```cpp\n  if (addLeft) { \n    while (leftIterator != leftSet.end()) { \n      result.add(*leftIterator); \n      ++leftIterator; \n    } \n  } \n```", "```cpp\n  if (addRight) { \n    while (rightIterator != rightSet.end()) { \n      result.add(*rightIterator); \n      ++rightIterator; \n    } \n  } \n```", "```cpp\n  return result; \n} \n```", "```cpp\ntemplate <class T> \nSet<T>& Set<T>::operator+=(const Set& set) { \n *this = *this + set; \n  return *this; \n} \n```", "```cpp\ntemplate <class T> \nSet<T>& Set<T>::operator*=(const Set& set) { \n *this = *this * set; \n  return *this; \n} \n\ntemplate <class T> \nSet<T>& Set<T>::operator-=(const Set& set) { \n *this = *this - set; \n  return *this; \n} \n```", "```cpp\ntemplate <class T> \nistream& operator>>(istream& inStream, Set<T>& set) { \n  int size; \n  inStream >> size; \n\n  for (int count = 0; count < size; ++count) { \n    T value; \n    inStream >> value; \n    set += value; \n  } \n\n  return inStream; \n} \n```", "```cpp\ntemplate <class T> \nostream& operator<<(ostream& outStream, const Set<T>& set) { \n  outStream << \"{\"; \n  bool first = true; \n\n  for (const T& value : set) { \n    outStream << (first ? \"\" : \",\") << value; \n    first = false; \n  } \n\n  outStream << \"}\"; \n  return outStream; \n} \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n\n#include \"..\\ListAdvanced\\List.h\" \n#include \"Set.h\" \n\nvoid main() { \n  Set<double> s, t; \n  cin >> s >> t; \n\n  cout << endl << \"s: \" << s << endl; \n  cout << \"t: \" << t << endl; \n\n  cout << endl << \"s: \"; \n  for (double value : s) { \n    cout << value << \" \"; \n  } \n\n  cout << endl << \"t: \"; \n  for (Set<double>::Iterator iterator = t.begin(); \n       iterator != t.end(); ++iterator) { \n    cout << *iterator << \" \"; \n  } \n\n  cout << endl << endl << \"union: \" << (s + t) << endl; \n  cout << \"intersection: \" << (s *t) << endl; \n  cout << \"difference: \" << (s - t) << endl << endl; \n} \n```", "```cpp\ntemplate <class ListType, class ValueType> \nint binarySearch(const ValueType& value, const ListType& list) { \n  ListType::Iterator* positionBuffer = \n    new ListType::Iterator[list.size()]; \n\n  int index = 0; \n  for (ListType::Iterator position = list.begin(); \n       position != list.end(); ++position) { \n    positionBuffer[index++] = position; \n  } \n\n  int minIndex = 0, maxIndex = list.size() - 1; \n\n  while (minIndex <= maxIndex) { \n    int middleIndex = (maxIndex + minIndex) / 2; \n    ListType::Iterator iterator = positionBuffer[middleIndex]; \n    const ValueType& middleValue = *iterator; \n\n    if (value == middleValue) { \n      return middleIndex; \n    } \n    else if (value < middleValue) { \n      maxIndex = middleIndex - 1; \n    } \n    else { \n      minIndex = middleIndex + 1; \n    } \n  } \n\n  return -1; \n} \n```", "```cpp\ntemplate <class ListType, class ValueType> \nvoid mergeSort(ListType& list) { \n  int size = list.size(); \n\n  if (size > 1) { \n    int middle = list.size() / 2; \n    ListType::Iterator iterator = list.begin(); \n\n    ListType leftList; \n    for (int count = 0; count < middle; ++count) { \n      leftList.add(*iterator); \n      ++iterator; \n    } \n\n    ListType rightList; \n    for (; iterator != list.end(); ++iterator) { \n      rightList.add(*iterator); \n    } \n\n    mergeSort<ListType, ValueType>(leftList); \n    mergeSort<ListType,ValueType>(rightList); \n\n    ListType resultList; \n    merge<ListType,ValueType>(leftList, rightList, resultList); \n    list = resultList; \n  } \n} \n```", "```cpp\ntemplate <class ListType, class ValueType> \nvoid merge(ListType& leftList, ListType& rightList, \n           ListType& result) { \n  ListType::Iterator leftPosition = leftList.begin(); \n  ListType::Iterator rightPosition = rightList.begin(); \n\n  while ((leftPosition != leftList.end()) && \n         (rightPosition != rightList.end())) { \n    if (*leftPosition < *rightPosition) { \n      result.add(*leftPosition); \n      ++leftPosition; \n    } \n    else { \n      result.add(*rightPosition); \n      ++rightPosition; \n    } \n  } \n\n  while (leftPosition != leftList.end()) { \n    result.add(*leftPosition); \n    ++leftPosition; \n  } \n\n  while (rightPosition != rightList.end()) { \n    result.add(*rightPosition); \n    ++rightPosition; \n  } \n} \n```", "```cpp\ntemplate <class ListType, class ValueType> \nvoid quickSort(ListType& list) { \n  if (list.size() > 1) { \n    ListType smaller, larger; \n    ValueType pivotValue = *list.begin(); \n\n    ListType::Iterator position = list.begin(); \n    ++position; \n\n    for (;position != list.end(); ++position) { \n      if (*position < pivotValue) { \n        smaller.add(*position); \n      } \n      else { \n        larger.add(*position); \n      } \n    } \n\n    quickSort<ListType,ValueType>(smaller); \n    quickSort<ListType,ValueType>(larger); \n    list = smaller; \n    list.add(pivotValue); \n    list.add(larger); \n  } \n} \n```"]