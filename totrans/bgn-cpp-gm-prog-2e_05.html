<html><head></head><body>
		<div><h1 id="_idParaDest-108"><a id="_idTextAnchor110"/><em class="italic">Chapter 4</em>: Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</h1>
			<p>This chapter probably has more C++ information in it than any other chapter in this book. It is packed with fundamental concepts that will move our understanding on enormously. It will also begin to shed light on some of the murky areas we have been skipping over a little bit, such as functions and the game loop.</p>
			<p>Once we have explored a whole list of C++ language necessities, we will then use everything we know to make the main game mechanic—the tree branches—move. By the end of this chapter, we will be ready for the final phase and the completion of Timber!!!.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Loops</li>
				<li>Arrays</li>
				<li>Making decisions with <code>switch</code></li>
				<li>Enumerations</li>
				<li>Getting started with functions</li>
				<li>Creating and moving the tree branches</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Loops</h1>
			<p>In programming, we often need to do the same thing more than once. The obvious example that we have seen so far is the game loop. With all the code stripped out, our game loop looks like this:</p>
			<pre>while (window.isOpen())
{
}</pre>
			<p>There are a few different types of loops, and we will look at the most commonly used ones here. The correct term for this type of loop is a <strong class="bold">while</strong> loop.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>while loops</h2>
			<p>The <code>while</code> loop is quite straightforward. Think back to the <code>if</code> statements and their expressions that evaluated to either <code>true</code> or <code>false</code>. We can use the exact same combination of operators and variables in the conditional expressions of our <code>while</code> loops.</p>
			<p>Like <code>if</code> statements, if the expression is <code>true</code>, the code executes. The difference with a <code>while</code> loop, however, is that the C++ code within it will repeatedly execute until the condition is false. Take a look at the following code.</p>
			<pre>int numberOfZombies = 100;
while(numberOfZombies &gt; 0)
{
    // Player kills a zombie
    numberOfZombies--;
    // numberOfZombies decreases each pass through the loop
}
// numberOfZombies is no longer greater than 0</pre>
			<p>Let's go over what's happening in the previous code. Outside of the <code>while</code> loop, <code>int numberOfZombies</code> is declared and initialized to <code>100</code>. Then, the <code>while</code> loop begins. Its conditional expression is <code>numberOfZombies &gt; 0</code>. Consequently, the <code>while</code> loop will continue looping through the code in its body until the condition evaluates to <code>false</code>. This means that the preceding code will execute 100 times.</p>
			<p>On the first pass through the loop, <code>numberOfZombies</code> equals 100, then 99, then 98, and so on. But once <code>numberOfZombies</code> is equal to zero, it is, of course, no longer <em class="italic">greater</em> than zero. Then, the code will break out of the <code>while</code> loop and continue to run, after the closing curly brace.</p>
			<p>Just like an <code>if</code> statement, it is possible that the <code>while</code> loop will not execute even once. Take a look at the following code:</p>
			<pre>int availableCoins = 10;
while(availableCoins &gt; 10)
{
    // more code here.
    // Won't run unless availableCoins is greater than 10
}</pre>
			<p>The preceding code inside the <code>while</code> loop will not execute because the condition is false. </p>
			<p>Note that there is no limit to the complexity of the expression or the amount of code that can go in the loop body. Consider the following hypothetical variation of our game loop:</p>
			<pre>int playerLives = 3;
int alienShips = 10;
while(playerLives !=0 &amp;&amp; alienShips !=0 )
{
    // Handle input
    // Update the scene
    // Draw the scene
}
// continue here when either playerLives or alienShips equals 0</pre>
			<p>The previous <code>while</code> loop would continue to execute until either <code>playerLives</code> or <code>alienShips</code> was equal to zero. As soon as one of those conditions occurred, the expression would evaluate to <code>false</code> and the program would continue to execute from the first line of code after the <code>while</code> loop.</p>
			<p>It is worth noting that once the body of the loop has been entered, it will always complete at least once, even if the expression evaluates to false partway through, as it is not tested again until the code tries to start another pass. Let's take a look at an example of this:</p>
			<pre>int x = 1;
while(x &gt; 0)
{
    x--;
    // x is now 0 so the condition is false
    // But this line still runs
    // and this one
    // and me!
}
// Now I'm done!</pre>
			<p>The previous loop body will execute once. We can also set up a <code>while</code> loop that will run forever, and unsurprisingly is called an <strong class="bold">infinite loop</strong>. Here is an example:</p>
			<pre>int y = 0;
while(true)
{
    y++; // Bigger... Bigger...
}</pre>
			<p>If you find the preceding loop confusing, just think of it literally. A loop executes when its condition is <code>true</code>. Well, <code>true</code> is always <code>true</code>, and will therefore keep executing.</p>
			<h3>Breaking out of a while loop</h3>
			<p>We might use an infinite loop so that we can decide when to exit the loop from within its body rather than in the expression. We would do this by using the <strong class="bold">break</strong> keyword when we are ready to leave the loop body, perhaps like this:</p>
			<pre>int z = 0;
while(true)
{
    z++; // Bigger... Bigger...
<strong class="bold">    break; // No you're not</strong>
    
    // Code doesn't reach here
}</pre>
			<p>In the preceding code, the code inside the loop will execute once, upto and including the <code>break</code> statement, and then execution will continue after the closing curly brace of the <code>while</code> loop.</p>
			<p>As you may have been able to guess, we can combine any of the C++ decision-making tools such as <code>if</code>, <code>else</code>, and another that we will learn about shortly, known as <code>switch</code>, within our <code>while</code> loops and other loop types as well. Consider the following example:</p>
			<pre>int x = 0;
int max = 10;
while(true)
{
    x++; // Bigger... Bigger...
<strong class="bold">    if(x == max){</strong>
<strong class="bold">        break;</strong>
<strong class="bold">    } // No you're not</strong>
    // code reaches here only until max = 10
}</pre>
			<p>In the preceding code, the <code>if</code> condition decides if and when the <code>break</code> statement is executed. In this case, the code will keep looping until <code>max</code> reaches 10.</p>
			<p>We could go on for a long time looking at the various permutations of C++ <code>while</code> loops, but, at some point, we want to get back to making games. So, let's move on to another type of loop: the <code>for</code> loop.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>for loops</h2>
			<p>The <code>while</code> loop because it takes three parts to set one up. Take a look at the following code first. We will break it apart after:</p>
			<pre>for(int x = 0; x &lt; 100; x ++)
{
    // Something that needs to happen 100 times goes here
}</pre>
			<p>Here is what all the parts of the <code>for</code> loop condition do:</p>
			<pre><code>for(</code><code>;</code> <code>;</code> <code>)</code></pre>
			<p>To clarify this further, here is a table to explain each of the three key parts, as they appear in the previous <code>for</code> loop example:</p>
			<div><div><img src="img/B14278_03_1.jpg" alt=""/>
				</div>
			</div>
			<p>We can vary <code>for</code> loops so that they do many more things. Here is another simple example that counts down from 10:</p>
			<pre>for(int i = 10; i &gt; 0; i--)
{
    // countdown
}
// blast off</pre>
			<p>The <code>for</code> loop takes control of initialization, condition evaluation, and the control variable. We will use <code>for</code> loops in our game, later in this chapter.</p>
			<p>Now, we can move on to the topic of C++ arrays, which help us store large amounts of related data.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor114"/>Arrays</h1>
			<p>If a variable is a box in which we can store a value of a specific type, such as <code>int</code>, <code>float</code>, or <code>char</code>, then we can think of an array as a row of boxes. The rows of boxes can be of almost any size and type, including objects made from classes. However, all the boxes must be of the same type.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The limitation of having to use the same type in each box can be circumvented to an extent once we learn some more advanced C++ in the penultimate project.</p>
			<p>This array sounds like it could have been useful for our clouds in <a href="B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 2</em></a><em class="italic">, Variables, Operators, and Decisions – Animating Sprites</em>. So, how do we go about creating and using an array?</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Declaring an array</h2>
			<p>We can declare an array of <code>int</code> type variables like this:</p>
			<pre>int someInts[10];</pre>
			<p>Now, we have an array called <code>someInts</code> that can store ten <code>int</code> values. Currently, however, it is empty.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor116"/>Initializing the elements of an array</h2>
			<p>To add values to the elements of an array, we can use the type of syntax we are already familiar with while introducing some new syntax, known as <code>99</code> in the first <strong class="bold">element</strong> of the array:</p>
			<pre>someInts[0] = 99;</pre>
			<p>In order to store a value of 999 in the second element, we need to use the following code:</p>
			<pre>someInts[1] = 999;</pre>
			<p>We can store a value of 3 in the last element like this:</p>
			<pre>someInts[9] = 3;</pre>
			<p>Note that the elements of an array always start at zero and go upto the size of the array minus one. Similar to ordinary variables, we can manipulate the values stored in an array. The only difference is that we would use the array notation to do so because although our array has a name— <code>someInts</code>— the individual elements do not.</p>
			<p>In the following code, we add the first and second elements together and store the answer in the third:</p>
			<pre>someInts[2] = someInts[0] + someInts[1];</pre>
			<p>Arrays can also interact seamlessly with regular variables, for example:</p>
			<pre>int a = 9999;
someInts[4] = a;</pre>
			<p>There are more ways we can initialize arrays, so let's look at one way now.</p>
			<h3>Quickly initializing the elements of an array</h3>
			<p>We can quickly add values to the elements as follows. This example uses a <code>float</code> array:</p>
			<pre>float myFloatingPointArray[3] {3.14f, 1.63f, 99.0f};</pre>
			<p>Now, the <code>3.14</code>, <code>1.63</code>, and <code>99.0</code> values are stored in the first, second, and third positions, respectively. Remember that, when using an array notation to access these values, we would use [0], [1], and [2].</p>
			<p>There are other ways to initialize the elements of an array. This slightly abstract example shows using a <code>for</code> loop to put the values 0 through 9 into the <code>uselessArray</code> array:</p>
			<pre>for(int i = 0; i &lt; 10; i++)
{
    uselessArray[i] = i;
}</pre>
			<p>The preceding code assumes that <code>uslessArray</code> had previously been initialized to hold at least 10 <code>int</code> variables.</p>
			<p>But why do we need arrays?</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor117"/>What do these arrays really do for our games?</h2>
			<p>We can use arrays anywhere a regular variable can be used – perhaps in an expression like this:</p>
			<pre>// someArray[4] is declared and initialized to 9999
for(int i = 0; <strong class="bold">i &lt; someArray[4]</strong>; i++)
{
    // Loop executes 9999 times
}</pre>
			<p>One of the biggest benefits of arrays in game code was hinted at at the start of this section. Arrays can hold objects (instances of classes). Let's imagine that we have a <code>Zombie</code> class and we want to store a whole bunch of them. We can do so like this:</p>
			<pre>Zombie horde [5] {zombie1, zombie2, zombie3}; // etc...</pre>
			<p>The <code>horde</code> array now holds a load of instances of the <code>Zombie </code>class. Each one is a separate, living (kind of), breathing, self-determining <code>Zombie</code> object. We could then loop through the <code>horde</code> array, each of which passes through the game loop, move the zombies, and check if their heads have met with an axe or if they have managed to catch the player.</p>
			<p>Arrays, had we known about them at the time, would have been perfect for handling our clouds in <a href="B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 2</em></a>, <em class="italic">Variables, Operators, and Decisions – Animating Sprites</em>. We could have had as many clouds as we wanted and written less code than we did for our three measly clouds.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To check out this improved cloud code in full and in action, look at the enhanced version of Timber!!! (code and playable game) in the download bundle. Alternatively, you can try to implement the clouds using arrays yourself before looking at the code.</p>
			<p>The best way to get a feel for all of this array stuff is to see it in action. We will do this when we implement our tree branches.</p>
			<p>For now, we will leave our cloud code as it is so that we can get back to adding features to the game as soon as possible. But first, let's do a bit more C++ decision-making with <strong class="bold">switch</strong>.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Making decisions with switch</h1>
			<p>We have already looked at <code>if</code>, which allows us to decide whether to execute a block of code based upon the result of its expression. But sometimes, a decision in C++ can be made in other ways that are better.</p>
			<p>When we must make a decision based on a clear list of possible outcomes that don't involve complex combinations or wide ranges of values, then <code>switch</code> is usually the way to go. We can start a <code>switch</code> decision as follows:</p>
			<pre>switch(<strong class="bold">expression</strong>)
{
    // More code here
}</pre>
			<p>In the previous example, <code>expression</code> could be an actual expression or just a variable. Then, within the curly braces, we can make decisions based on the result of the expression or value of the variable. We do this with the <code>case</code> and <code>break</code> keywords:</p>
			<pre>case x:
    //code for x
    break;
 
case y:
    //code for y
    break;</pre>
			<p>As you can see, each <code>case</code> states a possible result and each <code>break</code> denotes the end of that <code>case</code> and the point that the execution leaves the <code>switch</code> block.</p>
			<p>Optionally, we can also use the <code>default</code> keyword without a value to run some code in case none of the <code>case</code> statements evaluate to <code>true</code>, as follows:</p>
			<pre>default: // Look no value
    // Do something here if no other case statements are true
    break;</pre>
			<p>As a final and less abstract example for <code>switch</code>, consider a retro text adventure where the player enters a letter such as "n", "e", "s", or "w" to move North, East, South, or West. A <code>switch</code> block could be used to handle each possible input from the player:</p>
			<pre>// get input from user in a char called command
switch(command){
    case 'n':
        // Handle move here
        break;
    case 'e':
        // Handle move here
        break;
    case 's':
        // Handle move here
        break;
    case 'w':
        // Handle move here
        break;
    
    // more possible cases
    default:
        // Ask the player to try again
        break;
}</pre>
			<p>The best way of understanding all we have seen regarding <code>switch</code> is by putting it into action, along with all the other new concepts we are learning about.</p>
			<p>Next, we will learn about another C++ concept we need to understand before we write some more code. Let's look at class enumerations.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Class enumerations</h1>
			<p>An <strong class="bold">enumeration</strong> is a list of all the possible values in a logical collection. C++ enumerations are a great way of, well, enumerating things. For example, if our game uses variables that can only be in a specific range of values and if those values could logically form a collection or a set, then enumerations are probably appropriate to use. They will make your code clearer and less error-prone.</p>
			<p>To declare a class enumeration in C++, we can use these two keywords, <code>enum class</code>, together, followed by the name of the enumeration, followed by the values the enumeration can contain, enclosed in a pair of curly braces <code>{...}</code>.</p>
			<p>As an example, examine the following enumeration declaration. Note that it is convention to declare the possible values from the enumeration in uppercase:</p>
			<pre>enum class zombieTypes {
   REGULAR, RUNNER, 
   CRAWLER, SPITTER, BLOATER 
};</pre>
			<p>Note that, at this point, we have not declared any instances of <code>zombieType</code>, just the type itself. If that sounds odd, think about it like this. SFML created the <code>Sprite</code>, <code>RectangleShape</code>, and <code>RenderWindow</code> classes, but to use any of those classes, we had to declare an object/instance of the class.</p>
			<p>At this point, we have created a new type called <code>zombieTypes</code>, but we have no instances of it. So, let's do that now:</p>
			<pre>zombieType jeremy = zombieTypes::CRAWLER;
zombieType anna = zombieTypes::SPITTER;
zombieType diane = zombieTypes::BLOATER;
/*
    Zombies are fictional creatures and any resemblance
    to real people is entirely coincidental
*/</pre>
			<p>Next is a sneak preview of the type of code we will soon be adding to Timber!!!. We will want to track which side of the tree a branch or the player is on, so we will declare an enumeration called <code>side</code>, like this:</p>
			<pre>enum class side { LEFT, RIGHT, NONE };</pre>
			<p>We could position the player on the left like this:</p>
			<pre>// The player starts on the left
side playerSide = side::LEFT;</pre>
			<p>We could make the fourth level (arrays start from zero) of an array of branch positions have no branch at all, like this:</p>
			<pre>branchPositions[3] = side::NONE;</pre>
			<p>We can use enumerations in expressions as well:</p>
			<pre>if(branchPositions[5] == playerSide)
{
    // The lowest branch is the same side as the player
    // SQUISHED!!
}</pre>
			<p>The preceding code tests whether the branch in position [5] element of the array is on the same side as the player.</p>
			<p>We will look at one more vital C++ topic, that is, functions, and then we will get back to coding the game. When we want to compartmentalize some code that does one specific thing, we can use a function.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>Getting started with functions</h1>
			<p>What exactly are C++ functions? A function is a collection of variables, expressions, and <strong class="bold">control flow statements</strong> (loops and branches). In fact, any of the code we have learned about in this book so far can be used in a function. The first part of a function that we write is called the <strong class="bold">signature</strong>. Here is an example function signature:</p>
			<pre>void shootLazers(int power, int direction);</pre>
			<p>If we add an opening and closing pair of curly braces <code>{...}</code> along with some code that the function performs, we will have a complete function, that is, a <strong class="bold">definition</strong>:</p>
			<pre>void shootLazers(int power, int direction)
{
    // ZAPP!
}</pre>
			<p>We could then use our new function from another part of our code, perhaps like this:</p>
			<pre>// Attack the player
shootLazers(50, 180) // Run the code in the function
// I'm back again - code continues here after the function ends</pre>
			<p>When we use a function, we say that we <code>shootLazers</code>, our program's execution branches to the code contained within that function. The function will run until it reaches the end or is told to <code>return</code>. Then, the code will continue running from the first line after the function call. We have already been using the functions that SFML provides. What is different here is that we will learn to write and call our own functions.</p>
			<p>Here is another example of a function, complete with the code to make the function return to the code that called it:</p>
			<pre>int addAToB(int a, int b)
{
    int answer = a + b;
    return answer;
}</pre>
			<p>The call so that we can use the preceding function may look like this:</p>
			<pre>int myAnswer = addAToB(2, 4);</pre>
			<p>Obviously, we don't need to write functions to add two variables together, but this example helps us look into the workings of functions. First, we pass in the values <code>2</code> and <code>4</code>. In the function signature, the value <code>2</code> is assigned to <code>int a</code>, and the value <code>4</code> is assigned to <code>int b</code>.</p>
			<p>Within the function body, the <code>a</code> and <code>b</code> variables are added together and used to initialize the new variable, <code>int answer</code>. The <code>return answer;</code> line does just that. It returns the value stored in <code>answer</code> to the calling code, causing <code>myAnswer</code> to be initialized with the value <code>6</code>.</p>
			<p>Notice that each of the function signatures in the preceding examples vary a little. The reason for this is that the C++ function signature is quite flexible, allowing us to build exactly the functions we require.</p>
			<p>Exactly how the function signature defines how the function must be called and if/how the function must return a value deserves further discussion. Let's give each part of that signature a name so that we can break it into parts and learn about them.</p>
			<p>Here is a function signature with its parts described by their formal/technical term:</p>
			<pre><strong class="bold">return type | name of function | (parameters)</strong></pre>
			<p>Here are a few examples that we can use for each of those parts:</p>
			<ul>
				<li><code>void</code>,  <code>bool</code>, <code>float</code>, <code>int</code>, and so on, or any C++ type or expression</li>
				<li><code>shootLazers</code>, <code>addAToB</code>, and so on</li>
				<li><code>(int number, bool hitDetected)</code>, <code>(int x, int y)</code>, <code>(float a, float b)</code></li>
			</ul>
			<p>Now, let's look at each part in turn, starting with the return type.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>Function return types</h2>
			<p>The return type, as its name suggests, is the type of the value that will be returned from the function to the calling code:</p>
			<pre>int addAToB(int a, int b){
 
    int answer = a + b;
    return answer;
 
}</pre>
			<p>In our slightly dull but useful <code>addAtoB</code> example that we looked at previously, the return type in the signature is <code>int</code>. The <code>addAToB</code> function sends back and returns  a value that will fit in an <code>int</code> variable to the code that called it. The return type can be any C++ type we have seen so far or one of the ones we haven't seen yet.</p>
			<p>A function does not have to return a value at all, however. In this case, the signature must use the <code>void</code> keyword as the return type. When the <code>void</code> keyword is used, the function body must not attempt to return a value as this will cause an error. It can, however, use the <code>return</code> keyword without a value. Here are some combinations of the return type and use of the <code>return</code> keyword that are valid:</p>
			<pre>void doWhatever(){
 
    // our code
    // I'm done going back to calling code here
    // no return is necessary
 
}</pre>
			<p>Another possibility is as follows:</p>
			<pre>void doSomethingCool(){
 
    // our code
 
    // I can do this if I don't try and use a value
    return;
}</pre>
			<p>The following code is yet more examples of possible functions. Be sure to read the comments as well as the code:</p>
			<pre>void doYetAnotherThing(){
    // some code
 
    if(someCondition){
 
        // if someCondition is true returning to calling code
        // before the end of the function body
        return;
    }
 
    // More code that might or might not get executed
 
    return;
 
    // As I'm at the bottom of the function body
    // and the return type is void, I'm
    // really not necessary but I suppose I make it
    // clear that the function is over.
}
 
bool detectCollision(Ship a, Ship b){
 
    // Detect if collision has occurred
    if(collision)
    {
        // Bam!!!
        return true;
    }
    else
    {
        // Missed
        return false;
    }
 
}</pre>
			<p>The last function example in the preceding code, which is for <code>detectCollision</code>, is a glimpse into the near future of our C++ code and demonstrates that we can also pass in user-defined types known as objects into functions so that we can perform calculations on them.</p>
			<p>We could call each of the functions, in turn, like this:</p>
			<pre>// OK time to call some functions
doWhatever();
doSomethingCool();
doYetAnotherThing();
 
if (detectCollision(milleniumFalcon, lukesXWing))
{
    // The jedi are doomed!
    // But there is always Leia.
    // Unless she was on the Falcon?
}
else
{
    // Live to fight another day
}
 
// Continue with code from here</pre>
			<p>Don't worry about the odd-looking syntax regarding the <code>detectCollision</code> function; we will see real code like this soon. Simply, we are using the return value (<code>true</code> or <code>false</code>) as the expression directly in an <code>if </code>statement.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Function names</h2>
			<p>The function name that we use when we design our own function can be almost anything at all. But it is best to use words, usually verbs, that clearly explain what the function will do. For example, take a look at the following function:</p>
			<pre>void functionaroonieboonie(int blibbityblob, float floppyfloatything)
{
    //code here
}</pre>
			<p>The preceding function is perfectly legal and will work, but the following function names are much clearer:</p>
			<pre>void doSomeVerySpecificTask()
{
    //code here
}
 
int getMySpaceShipHealth()
{
    //code here
}
 
void startNewGame()
{
    //code here
}</pre>
			<p>Using clear and descriptive function names such as in the preceding three examples is good practice, but, as we saw from the <code>functionaroonieboonie</code> function, this is not a rule that the compiler enforces. Next, we will take a closer look at how we share some values with a function.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Function parameters</h2>
			<p>We know that a function can return a result to the calling code. But what if we need to share some data values from the calling code with the function? <strong class="bold">Parameters</strong> allow us to share values with the function. We have already seen examples of parameters while looking at return types. We will look at the same example but a little more closely:</p>
			<pre>int addAToB(<strong class="bold">int a, int b</strong>)
{ 
    int answer = a + b;
    return answer; 
}</pre>
			<p>Here, the parameters are <code>int a</code> and <code>int b</code>. Notice that, in the first line of the function body, we use <code>a + b</code> as if they are already declared and initialized variables. Well, that's because they are. The parameters in the function signature is their declaration, and the code that calls the function initializes them.</p>
			<p class="callout-heading">Important jargon note</p>
			<p class="callout">Note that we are referring to the variables in the function signature brackets <code>(int a, int b)</code> as parameters. When we pass values into the function from the calling code, these values are called arguments. When the arguments arrive, they are used by the parameters to initialize real, usable variables, like:</p>
			<p class="callout"><code>int returnedAnswer = addAToB(10,5);</code></p>
			<p>Also, as we have partly seen in previous examples, we don't have to just use <code>int</code> in our parameters. We can use any C++ type. We can also use as many parameters as is necessary to solve our problem, but it is good practice to keep the parameter list as short and therefore as manageable as possible.</p>
			<p>As we will see in future chapters, we have left a few of the cooler uses of functions out of this introductory tutorial so that we can learn about related C++ concepts before we take the topic of functions further.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>The function body</h2>
			<p>The body is the part we have been kind of avoiding and has comments such as the following:</p>
			<pre>// code here
// some code</pre>
			<p>Actually, we already know exactly what to do here! Any C++ code we have learned about so far will work in the body of a function.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Function prototypes</h2>
			<p>So far, we have seen how to code a function and we have seen how to call one as well. There is one more thing we need to do, however, to make them work. All functions must have a <strong class="bold">prototype</strong>. A prototype is what makes the compiler aware of our function, and without a prototype the entire game will fail to compile. Fortunately, prototypes are straightforward.</p>
			<p>We can simply repeat the function's signature, followed by a semicolon. The caveat is that the prototype must appear <em class="italic">before</em> any attempt to call or define the function. So, the absolute most simple example of a fully usable function in action is as follows. Look carefully at the comments and the location in the code that the different parts of the function appear in:</p>
			<pre>// The prototype
// Notice the semicolon on the end
int addAToB(int a, int b);
 
int main()
{ 
    // Call the function
    // Store the result in answer
    int answer = addAToB(2,2);
 
    // Called before the definition
    // but that's OK because of the prototype
 
    // Exit main
    return 0;
 
}// End of main
 
// The function definition
int addAToB(int a, int b)
{
    return a + b;
}</pre>
			<p>What the previous code demonstrates is the following:</p>
			<ul>
				<li>The prototype is before the <code>main</code> function.</li>
				<li>The call to use the function is as we might expect, inside the <code>main</code> function.</li>
				<li>The definition is after/outside the <code>main</code> function.<p class="callout-heading">Important note</p><p class="callout">Note that we can omit the function prototype and go straight to the definition when the definition occurs before the function is used. As our code becomes longer and spread across multiple files, however, this will almost never happen. We will use separate prototypes and definitions all the time.</p></li>
			</ul>
			<p>Let's see how we can keep our functions organized.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Organizing functions</h2>
			<p>It's well worth pointing out that if we have multiple functions, especially if they are fairly long, our <code>.cpp</code> file will quickly become unwieldy. This defeats part of the objective that functions are intended for. The solution that we will see in the next project is that we can add all our function prototypes to our very own header file (<code>.hpp </code>or<code> .h</code>). Then, we can code all our functions in another <code>.cpp</code> file and simply add another <code>#include...</code> directive in our main <code>.cpp</code> file. This way, we can use any number of functions without adding any of their code (prototype or definition) to our main code file.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Function gotcha!</h2>
			<p>Another point that we should discuss about functions is <strong class="bold">scope</strong>. If we declare a variable in a function, either directly or in one of the parameters, that variable is not usable/visible outside of that function. Furthermore, any variables declared inside other functions cannot be seen/used inside the function.</p>
			<p>The way that we should share values between function code and calling code is through the parameters/arguments and the return value.</p>
			<p>When a variable is not available because it is from another function, it is said to be out of scope. When it is available and usable, it is said to be in scope.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Variables declared within any block in C++ are only in scope within that block! This includes loops and <code>if</code> blocks as well. A variable that's declared at the top of <code>main</code> is in scope anywhere in <code>main</code>, a variable that's declared in the game loop is only in scope within the game loop, and so on. A variable that's declared within a function or other block is called a <strong class="bold">local</strong> variable. The more code we write, the more this will make sense. Every time we come across an issue in our code regarding scope, I will discuss it to make things clear. There will be one such issue coming up in the next section. There are also some more C++ staples that blow this issue wide open. They are called <strong class="bold">references</strong> and <strong class="bold">pointers</strong>, and we will learn about them in <a href="B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200"><em class="italic">Chapter 9</em></a>, <em class="italic">C++ References, Sprite Sheets, and Vertex Arrays</em> and<em class="italic"> </em><a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>, <em class="italic">Pointers, the Standard Template Library, and Texture Management</em> respectively.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>More on functions</h2>
			<p>There is even more we could learn about functions, but we know enough about them already to implement the next part of our game. And don't worry if all the technical terms such as parameters, signatures, and definitions have not completely sunk in yet. These concepts will become clearer when we start to use them.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor129"/>An absolute final word on functions – for now</h2>
			<p>It has probably not escaped your attention that we have been calling functions, especially the SFML functions, by appending the name of an object and a period before the function name, like this:</p>
			<pre>spriteBee.setPosition...
window.draw...
// etc</pre>
			<p>And yet, our entire discussion of functions saw us calling functions without any objects. We can write functions as part of a class or simply as a standalone function. When we write a function as part of a class, we need an object of that class to call the function, but when we have a standalone function, we don't.</p>
			<p>We will write a standalone function in a minute and we will write classes with functions starting from <a href="B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 6</em></a>,<em class="italic"> Object-Oriented Programming – Starting the Pong Game</em>. Everything we know so far about functions is relevant in both cases.</p>
			<p>Now, we can get back to coding the branches in the Timber!!! game.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Growing the branches</h1>
			<p>Next, as I have been promising for the last 20 pages, we will use all the new C++ techniques we've learned about to draw and move some branches on our tree.</p>
			<p>Add the following code outside of the <code>main</code> function. Just to be absolutely clear, I mean <em class="italic">before</em> the code for <code>int main()</code>:</p>
			<pre>#include &lt;sstream&gt;
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
<strong class="bold">// Function declaration</strong>
<strong class="bold">void updateBranches(int seed);</strong>
<strong class="bold">const int NUM_BRANCHES = 6;</strong>
<strong class="bold">Sprite branches[NUM_BRANCHES];</strong>
<strong class="bold">// Where is the player/branch?</strong>
<strong class="bold">// Left or Right</strong>
<strong class="bold">enum class side { LEFT, RIGHT, NONE };</strong>
<strong class="bold">side branchPositions[NUM_BRANCHES];</strong>
int main()</pre>
			<p>We just achieved quite a few things with that new code:</p>
			<ul>
				<li>First, we wrote a function prototype for a function called <code>updateBranches</code>. We can see that it does not return a value (<code>void</code>) and that it takes an <code>int</code> argument called <code>seed</code>. We will write the function definition soon, and we will then see exactly what it does.</li>
				<li>Next, we declare an <code>int</code> constant called <code>NUM_BRANCHES</code> and initialize it to <code>6</code>. There will be six moving branches on the tree, and we will soon see how <code>NUM_BRANCHES</code> is useful to us.</li>
				<li>Following this, we declare an array of <code>Sprite</code> objects called <code>branches</code> that can hold six <code>Sprite</code> instances.</li>
				<li>After that, we declare a new enumeration called <code>side</code> with three possible values: <code>LEFT</code>, <code>RIGHT</code>, and <code>NONE</code>. This will be used to describe the position of individual branches, as well as the player, in a few places throughout our code.</li>
				<li>Finally, in the preceding code, we initialize an array of <code>side</code> types with a size of <code>NUM_BRANCHES</code> (6). To be clear about what this achieves, we will have an array called <code>branchPositions</code> with six values in it. Each of these values is of the <code>side</code> type and can be either <code>LEFT</code>, <code>RIGHT</code>, or <code>NONE</code>.<p class="callout-heading">Important note</p><p class="callout">Of course, what you really want to know is why the constant, two arrays, and the enumeration were declared <em class="italic">outside</em> of the <code>main</code> function. By declaring them above <code>main</code>, they now have <code>main</code> function and the <code>updateBranches</code> function. Note that it is good practice to make all the variables as local to where they are actually used as possible. It might seem useful to make everything global, but this leads to hard-to-read and error-prone code.</p></li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor131"/>Preparing the branches</h2>
			<p>Now, we will prepare our six <code>Sprite</code> objects and load them into the <code>branches</code> array. Add the following highlighted code just before our game loop:</p>
			<pre>// Position the text
FloatRect textRect = messageText.getLocalBounds();
messageText.setOrigin(textRect.left +
    textRect.width / 2.0f,
    textRect.top +
    textRect.height / 2.0f);
messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);
scoreText.setPosition(20, 20);
<strong class="bold">// Prepare 6 branches</strong>
<strong class="bold">Texture textureBranch;</strong>
<strong class="bold">textureBranch.loadFromFile("graphics/branch.png");</strong>
<strong class="bold">// Set the texture for each branch sprite</strong>
<strong class="bold">for (int i = 0; i &lt; NUM_BRANCHES; i++) {</strong>
<strong class="bold">    branches[i].setTexture(textureBranch);</strong>
<strong class="bold">    branches[i].setPosition(-2000, -2000);</strong>
<strong class="bold">    // Set the sprite's origin to dead centre</strong>
<strong class="bold">    // We can then spin it round without changing its position</strong>
<strong class="bold">    branches[i].setOrigin(220, 20);</strong>
<strong class="bold">}</strong>
while (window.isOpen())</pre>
			<p>In the preceding code, we are doing the following:</p>
			<ol>
				<li>First, we declare an SFML <code>Texture</code> object and load the <code>branch.png</code> graphic into it.</li>
				<li>Next, we create a <code>for</code> loop that sets <code>i</code> to zero and increments <code>i</code> by one on each pass through the loop until <code>i</code> is no longer less than <code>NUM_BRANCHES</code>. This is exactly right because <code>NUM_BRANCHES</code> is 6 and the <code>branches</code> array has positions 0 through 5.</li>
				<li>Inside the <code>for</code> loop, we set the <code>Texture</code> for each <code>Sprite</code> in the <code>branches</code> array with <code>setTexture</code> and then hide it off-screen with <code>setPosition</code>.</li>
				<li>Finally, we set the origin (the point that is used to locate the sprite when it is drawn) with <code>setOrigin</code>, to the center of the sprite. Soon, we will be rotating these sprites. Having the origin in the center means they will spin nicely around, without moving the sprite out of position.</li>
			</ol>
			<p>Now that we have prepared all the branches, we can write some code to update them all each frame.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor132"/>Updating the branch sprites each frame</h2>
			<p>In the following code, we will set the position of all the sprites in the <code>branches</code> array, based upon their position in the array and the value of <code>side</code> in the corresponding <code>branchPositions</code> array. Add the following highlighted code and try to understand it first before we go through it in detail:</p>
			<pre>    // Update the score text
    std::stringstream ss;
    ss &lt;&lt; "Score: " &lt;&lt; score;
    scoreText.setString(ss.str());
<strong class="bold">    // update the branch sprites</strong>
<strong class="bold">    for (int i = 0; i &lt; NUM_BRANCHES; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        float height = i * 150;</strong>
<strong class="bold">        if (branchPositions[i] == side::LEFT)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // Move the sprite to the left side</strong>
<strong class="bold">            branches[i].setPosition(610, height);</strong>
<strong class="bold">            // Flip the sprite round the other way</strong>
<strong class="bold">            branches[i].setRotation(180);</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else if (branchPositions[i] == side::RIGHT)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // Move the sprite to the right side</strong>
<strong class="bold">            branches[i].setPosition(1330, height);</strong>
<strong class="bold">            // Set the sprite rotation to normal</strong>
<strong class="bold">            branches[i].setRotation(0);</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // Hide the branch</strong>
<strong class="bold">            branches[i].setPosition(3000, height);</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
} // End if(!paused)
/*
****************************************
Draw the scene
****************************************</pre>
			<p>The code we just added is one big <code>for</code> loop that sets <code>i</code> to zero and increments <code>i</code> by one each time through the loop and keeps going until <code>i</code> is no longer less than 6.</p>
			<p>Inside the <code>for</code> loop, a new <code>float</code> variable called <code>height</code> is set to <code>i * 150</code>. This means that the first branch will have a height of 0, the second a height of 150, and the sixth a height of 750.</p>
			<p>Next, we have a structure of <code>if</code> and <code>else</code> blocks. Take a look at the structure with the code stripped out:</p>
			<pre>if()
{
}
else if()
{
}
else
{
}</pre>
			<p>The first <code>if</code> statement uses the <code>branchPositions</code> array to see whether the current branch should be on the left. If it is, it sets the corresponding <code>Sprite</code> from the <code>branches</code> array to a position on the screen, appropriate for the left (610 pixels) and whatever the current <code>height</code> is. It then flips the Sprite by 180 degrees because the <code>branch.png</code> graphic "hangs" to the right by default.</p>
			<p>Note that <code>else if</code> only executes if the branch is not on the left. It uses the same method to see if it is on the right. If it is, then the branch is drawn on the right (1,330 pixels). Then, the sprite rotation is set to zero degrees, just in case it had previously been at 180 degrees. If the x coordinate seems a little bit strange, just remember that we set the origin for the branch sprites to their center.</p>
			<p>The final <code>else</code> statement correctly assumes that the current <code>branchPosition</code> must be <code>NONE</code> and hides the branch off-screen at 3,000 pixels.</p>
			<p>At this point, our branches are in position and ready to be drawn.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor133"/>Drawing the branches</h2>
			<p>Here, we will use another <code>for</code> loop to step through the entire <code>branches</code> array from 0 to 5 and draw each branch sprite. Add the following highlighted code:</p>
			<pre>// Draw the clouds
window.draw(spriteCloud1);
window.draw(spriteCloud2);
window.draw(spriteCloud3);
<strong class="bold">// Draw the branches</strong>
<strong class="bold">for (int i = 0; i &lt; NUM_BRANCHES; i++) {</strong>
<strong class="bold">    window.draw(branches[i]);</strong>
<strong class="bold">}</strong>
// Draw the tree
window.draw(spriteTree);</pre>
			<p>Of course, we still haven't written the function that moves all the branches. Once we have written that function, we will also need to work out when and how to call it. Let's solve the first problem and write the function.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor134"/>Moving the branches</h2>
			<p>We have already added the function prototype, above the <code>main</code> function. Now, we can code the actual definition of the function that will move all the branches down by one position each time it is called. We will code this function in two parts so that we can easily examine what is happening.</p>
			<p>Add the first part of the <code>updateBranches</code> function <em class="italic">after</em> the closing curly brace of the <code>main</code> function:</p>
			<pre>// Function definition
void updateBranches(int seed)
{
    // Move all the branches down one place
    for (int j = NUM_BRANCHES-1; j &gt; 0; j--) {	
        branchPositions[j] = branchPositions[j - 1];
    }
}</pre>
			<p>In this first part of the function, we simply move all the branches down one position, one at a time, starting with the sixth branch. This is achieved by making the <code>for</code> loop count from 5 through to 0. Note that <code>branchPositions[j] = branchPositions[j - 1]; </code>makes the actual move.  </p>
			<p>The other thing to note with this previous code is that after we have moved the branch in position 4 to position 5, then the branch in position 3 to position 4, and so on, we will need to add a new branch at position 0, which is the top of the tree.</p>
			<p>Now, we can spawn a new branch at the top of the tree. Add the following highlighted code, and then we will talk about it:</p>
			<pre>// Function definition
void updateBranches(int seed)
{
    // Move all the branches down one place
    for (int j = NUM_BRANCHES-1; j &gt; 0; j--) {	
        branchPositions[j] = branchPositions[j - 1];
    }
<strong class="bold">    // Spawn a new branch at position 0</strong>
<strong class="bold">    // LEFT, RIGHT or NONE</strong>
<strong class="bold">    srand((int)time(0)+seed);</strong>
<strong class="bold">    int r = (rand() % 5);</strong>
<strong class="bold">    switch (r) {</strong>
<strong class="bold">    case 0:</strong>
<strong class="bold">        branchPositions[0] = side::LEFT;</strong>
<strong class="bold">        break;</strong>
<strong class="bold">    case 1:</strong>
<strong class="bold">        branchPositions[0] = side::RIGHT;</strong>
<strong class="bold">        break;</strong>
<strong class="bold">    default:</strong>
<strong class="bold">        branchPositions[0] = side::NONE;</strong>
<strong class="bold">        break;</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>In the final part of the <code>updateBranches</code> function, we use the integer <code>seed</code> variable that gets passed in with the function call. We do this to guarantee that the random number seed is always different. We will see how we arrived at this value in the next chapter.</p>
			<p>Next, we generate a random number between zero and four and store the result in the <code>int</code> variable called <code>r</code>. Now, we <code>switch</code>, using <code>r</code> as the expression.</p>
			<p>The <code>case</code> statements mean that if <code>r</code> is equal to zero, then we add a new branch to the left-hand side, at the top of the tree. If <code>r</code> is equal to 1, then the branch goes to the right. If <code>r</code> is anything else, (2, 3, or 4), then <code>default</code> ensures no branch will be added at the top. This balance of left, right, and none makes the tree seem realistic and the game work quite well. You could easily change the code to make the branches more frequent or less so.</p>
			<p>Even after all this code for our branches, we still can't see a single one of them in the game. This is because we have more work to do before we can call the <code>updateBranches</code> function.</p>
			<p>If you want to see a branch now, you can add some temporary code and call the function five times with a unique seed each time, just before the game loop:</p>
			<pre><strong class="bold">updateBranches(1);</strong>
<strong class="bold">updateBranches(2);</strong>
<strong class="bold">updateBranches(3);</strong>
<strong class="bold">updateBranches(4);</strong>
<strong class="bold">updateBranches(5);</strong>
while (window.isOpen())
{</pre>
			<p>You can now see the branches in place. But if the branches are to actually move, we will need to call <code>updateBranches</code> on a regular basis:</p>
			<div><div><img src="img/B14278_04_01.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor135"/></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't forget to remove the temporary code before moving on.</p>
			<p>Now, we can turn our attention to the player as well, as calling the <code>updateBranches</code> function for real. We will do so in the next chapter.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor136"/>Summary</h1>
			<p>Although not quite the longest, this was probably the chapter where we've covered the most C++ so far. We looked at the different types of loops we can use, such as <code>for</code> and <code>while</code> loops. We then studied arrays that we can use them to handle large amounts of variables and objects without breaking a sweat. We also learned about enumerations and <code>switch</code>. Probably the biggest concept in this chapter was functions, which allow us to organize and abstract our game's code. We will be looking more deeply at functions in a few more places in this book.</p>
			<p>Now that we have a fully "working" tree, we can finish the game off, which we will do in the next and final chapter for this project.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor137"/>FAQ</h1>
			<p>Q) You mentioned there were a few more types of C++ loops. Where can I find out about them?</p>
			<p>A) Yes, take a look at this tutorial and explanation for the <code>do while</code> loops: <a href="http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm">http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm</a>.</p>
			<p>Q) Can I assume I am now an expert on arrays?</p>
			<p>A) Like many of the topics in this book, there is always more to learn. You know enough about arrays to proceed, but if you're hungry for more, take a look at this fuller arrays tutorial: <a href="http://www.cplusplus.com/doc/tutorial/arrays/">http://www.cplusplus.com/doc/tutorial/arrays/</a>.</p>
			<p>Q) Can I assume that I am an expert on functions?</p>
			<p>A) Like many of the topics in this book, there is always more to learn. You know enough about functions to proceed, but if want to know even more, take a look at this tutorial: <a href="http://www.cplusplus.com/doc/tutorial/functions/">http://www.cplusplus.com/doc/tutorial/functions/</a>.</p>
		</div>
	</body></html>