<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/><em class="italic">Chapter 4</em>: Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</h1>
			<p>This chapter probably has more C++ information in it than any other chapter in this book. It is packed with fundamental concepts that will move our understanding on enormously. It will also begin to shed light on some of the murky areas we have been skipping over a little bit, such as functions and the game loop.</p>
			<p>Once we have explored a whole list of C++ language necessities, we will then use everything we know to make the main game mechanic—the tree branches—move. By the end of this chapter, we will be ready for the final phase and the completion of Timber!!!.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Loops</li>
				<li>Arrays</li>
				<li>Making decisions with <strong class="source-inline">switch</strong></li>
				<li>Enumerations</li>
				<li>Getting started with functions</li>
				<li>Creating and moving the tree branches</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Loops</h1>
			<p>In programming, we often need to do the same thing more than once. The obvious example that we have seen so far is the game loop. With all the code stripped out, our game loop looks like this:</p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>There are a few different types of loops, and we will look at the most commonly used ones here. The correct term for this type of loop is a <strong class="bold">while</strong> loop.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>while loops</h2>
			<p>The <strong class="source-inline">while</strong> loop is quite straightforward. Think back to the <strong class="source-inline">if</strong> statements and their expressions that evaluated to either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. We can use the exact same combination of operators and variables in the conditional expressions of our <strong class="source-inline">while</strong> loops.</p>
			<p>Like <strong class="source-inline">if</strong> statements, if the expression is <strong class="source-inline">true</strong>, the code executes. The difference with a <strong class="source-inline">while</strong> loop, however, is that the C++ code within it will repeatedly execute until the condition is false. Take a look at the following code.</p>
			<p class="source-code">int numberOfZombies = 100;</p>
			<p class="source-code">while(numberOfZombies &gt; 0)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Player kills a zombie</p>
			<p class="source-code">    numberOfZombies--;</p>
			<p class="source-code">    // numberOfZombies decreases each pass through the loop</p>
			<p class="source-code">}</p>
			<p class="source-code">// numberOfZombies is no longer greater than 0</p>
			<p>Let's go over what's happening in the previous code. Outside of the <strong class="source-inline">while</strong> loop, <strong class="source-inline">int numberOfZombies</strong> is declared and initialized to <strong class="source-inline">100</strong>. Then, the <strong class="source-inline">while</strong> loop begins. Its conditional expression is <strong class="source-inline">numberOfZombies &gt; 0</strong>. Consequently, the <strong class="source-inline">while</strong> loop will continue looping through the code in its body until the condition evaluates to <strong class="source-inline">false</strong>. This means that the preceding code will execute 100 times.</p>
			<p>On the first pass through the loop, <strong class="source-inline">numberOfZombies</strong> equals 100, then 99, then 98, and so on. But once <strong class="source-inline">numberOfZombies</strong> is equal to zero, it is, of course, no longer <em class="italic">greater</em> than zero. Then, the code will break out of the <strong class="source-inline">while</strong> loop and continue to run, after the closing curly brace.</p>
			<p>Just like an <strong class="source-inline">if</strong> statement, it is possible that the <strong class="source-inline">while</strong> loop will not execute even once. Take a look at the following code:</p>
			<p class="source-code">int availableCoins = 10;</p>
			<p class="source-code">while(availableCoins &gt; 10)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // more code here.</p>
			<p class="source-code">    // Won't run unless availableCoins is greater than 10</p>
			<p class="source-code">}</p>
			<p>The preceding code inside the <strong class="source-inline">while</strong> loop will not execute because the condition is false. </p>
			<p>Note that there is no limit to the complexity of the expression or the amount of code that can go in the loop body. Consider the following hypothetical variation of our game loop:</p>
			<p class="source-code">int playerLives = 3;</p>
			<p class="source-code">int alienShips = 10;</p>
			<p class="source-code">while(playerLives !=0 &amp;&amp; alienShips !=0 )</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Handle input</p>
			<p class="source-code">    // Update the scene</p>
			<p class="source-code">    // Draw the scene</p>
			<p class="source-code">}</p>
			<p class="source-code">// continue here when either playerLives or alienShips equals 0</p>
			<p>The previous <strong class="source-inline">while</strong> loop would continue to execute until either <strong class="source-inline">playerLives</strong> or <strong class="source-inline">alienShips</strong> was equal to zero. As soon as one of those conditions occurred, the expression would evaluate to <strong class="source-inline">false</strong> and the program would continue to execute from the first line of code after the <strong class="source-inline">while</strong> loop.</p>
			<p>It is worth noting that once the body of the loop has been entered, it will always complete at least once, even if the expression evaluates to false partway through, as it is not tested again until the code tries to start another pass. Let's take a look at an example of this:</p>
			<p class="source-code">int x = 1;</p>
			<p class="source-code">while(x &gt; 0)</p>
			<p class="source-code">{</p>
			<p class="source-code">    x--;</p>
			<p class="source-code">    // x is now 0 so the condition is false</p>
			<p class="source-code">    // But this line still runs</p>
			<p class="source-code">    // and this one</p>
			<p class="source-code">    // and me!</p>
			<p class="source-code">}</p>
			<p class="source-code">// Now I'm done!</p>
			<p>The previous loop body will execute once. We can also set up a <strong class="source-inline">while</strong> loop that will run forever, and unsurprisingly is called an <strong class="bold">infinite loop</strong>. Here is an example:</p>
			<p class="source-code">int y = 0;</p>
			<p class="source-code">while(true)</p>
			<p class="source-code">{</p>
			<p class="source-code">    y++; // Bigger... Bigger...</p>
			<p class="source-code">}</p>
			<p>If you find the preceding loop confusing, just think of it literally. A loop executes when its condition is <strong class="source-inline">true</strong>. Well, <strong class="source-inline">true</strong> is always <strong class="source-inline">true</strong>, and will therefore keep executing.</p>
			<h3>Breaking out of a while loop</h3>
			<p>We might use an infinite loop so that we can decide when to exit the loop from within its body rather than in the expression. We would do this by using the <strong class="bold">break</strong> keyword when we are ready to leave the loop body, perhaps like this:</p>
			<p class="source-code">int z = 0;</p>
			<p class="source-code">while(true)</p>
			<p class="source-code">{</p>
			<p class="source-code">    z++; // Bigger... Bigger...</p>
			<p class="source-code"><strong class="bold">    break; // No you're not</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">    // Code doesn't reach here</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the code inside the loop will execute once, upto and including the <strong class="source-inline">break</strong> statement, and then execution will continue after the closing curly brace of the <strong class="source-inline">while</strong> loop.</p>
			<p>As you may have been able to guess, we can combine any of the C++ decision-making tools such as <strong class="source-inline">if</strong>, <strong class="source-inline">else</strong>, and another that we will learn about shortly, known as <strong class="source-inline">switch</strong>, within our <strong class="source-inline">while</strong> loops and other loop types as well. Consider the following example:</p>
			<p class="source-code">int x = 0;</p>
			<p class="source-code">int max = 10;</p>
			<p class="source-code">while(true)</p>
			<p class="source-code">{</p>
			<p class="source-code">    x++; // Bigger... Bigger...</p>
			<p class="source-code"><strong class="bold">    if(x == max){</strong></p>
			<p class="source-code"><strong class="bold">        break;</strong></p>
			<p class="source-code"><strong class="bold">    } // No you're not</strong></p>
			<p class="source-code">    // code reaches here only until max = 10</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">if</strong> condition decides if and when the <strong class="source-inline">break</strong> statement is executed. In this case, the code will keep looping until <strong class="source-inline">max</strong> reaches 10.</p>
			<p>We could go on for a long time looking at the various permutations of C++ <strong class="source-inline">while</strong> loops, but, at some point, we want to get back to making games. So, let's move on to another type of loop: the <strong class="source-inline">for</strong> loop.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>for loops</h2>
			<p>The <strong class="bold">for</strong> loop has a slightly more complicated syntax than the <strong class="source-inline">while</strong> loop because it takes three parts to set one up. Take a look at the following code first. We will break it apart after:</p>
			<p class="source-code">for(int x = 0; x &lt; 100; x ++)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Something that needs to happen 100 times goes here</p>
			<p class="source-code">}</p>
			<p>Here is what all the parts of the <strong class="source-inline">for</strong> loop condition do:</p>
			<p class="source-code"><strong class="source-inline">for(</strong><strong class="bold">declaration and initialization</strong><strong class="source-inline">;</strong> <strong class="bold">condition</strong><strong class="source-inline">;</strong> <strong class="bold">change before each iteration</strong><strong class="source-inline">)</strong></p>
			<p>To clarify this further, here is a table to explain each of the three key parts, as they appear in the previous <strong class="source-inline">for</strong> loop example:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B14278_03_1.jpg" alt=""/>
				</div>
			</div>
			<p>We can vary <strong class="source-inline">for</strong> loops so that they do many more things. Here is another simple example that counts down from 10:</p>
			<p class="source-code">for(int i = 10; i &gt; 0; i--)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // countdown</p>
			<p class="source-code">}</p>
			<p class="source-code">// blast off</p>
			<p>The <strong class="source-inline">for</strong> loop takes control of initialization, condition evaluation, and the control variable. We will use <strong class="source-inline">for</strong> loops in our game, later in this chapter.</p>
			<p>Now, we can move on to the topic of C++ arrays, which help us store large amounts of related data.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor114"/>Arrays</h1>
			<p>If a variable is a box in which we can store a value of a specific type, such as <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, or <strong class="source-inline">char</strong>, then we can think of an array as a row of boxes. The rows of boxes can be of almost any size and type, including objects made from classes. However, all the boxes must be of the same type.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The limitation of having to use the same type in each box can be circumvented to an extent once we learn some more advanced C++ in the penultimate project.</p>
			<p>This array sounds like it could have been useful for our clouds in <a href="B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 2</em></a><em class="italic">, Variables, Operators, and Decisions – Animating Sprites</em>. So, how do we go about creating and using an array?</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Declaring an array</h2>
			<p>We can declare an array of <strong class="source-inline">int</strong> type variables like this:</p>
			<p class="source-code">int someInts[10];</p>
			<p>Now, we have an array called <strong class="source-inline">someInts</strong> that can store ten <strong class="source-inline">int</strong> values. Currently, however, it is empty.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor116"/>Initializing the elements of an array</h2>
			<p>To add values to the elements of an array, we can use the type of syntax we are already familiar with while introducing some new syntax, known as <strong class="bold">array notation</strong>. In the following code, we store the value of <strong class="source-inline">99</strong> in the first <strong class="bold">element</strong> of the array:</p>
			<p class="source-code">someInts[0] = 99;</p>
			<p>In order to store a value of 999 in the second element, we need to use the following code:</p>
			<p class="source-code">someInts[1] = 999;</p>
			<p>We can store a value of 3 in the last element like this:</p>
			<p class="source-code">someInts[9] = 3;</p>
			<p>Note that the elements of an array always start at zero and go upto the size of the array minus one. Similar to ordinary variables, we can manipulate the values stored in an array. The only difference is that we would use the array notation to do so because although our array has a name— <strong class="source-inline">someInts</strong>— the individual elements do not.</p>
			<p>In the following code, we add the first and second elements together and store the answer in the third:</p>
			<p class="source-code">someInts[2] = someInts[0] + someInts[1];</p>
			<p>Arrays can also interact seamlessly with regular variables, for example:</p>
			<p class="source-code">int a = 9999;</p>
			<p class="source-code">someInts[4] = a;</p>
			<p>There are more ways we can initialize arrays, so let's look at one way now.</p>
			<h3>Quickly initializing the elements of an array</h3>
			<p>We can quickly add values to the elements as follows. This example uses a <strong class="source-inline">float</strong> array:</p>
			<p class="source-code">float myFloatingPointArray[3] {3.14f, 1.63f, 99.0f};</p>
			<p>Now, the <strong class="source-inline">3.14</strong>, <strong class="source-inline">1.63</strong>, and <strong class="source-inline">99.0</strong> values are stored in the first, second, and third positions, respectively. Remember that, when using an array notation to access these values, we would use [0], [1], and [2].</p>
			<p>There are other ways to initialize the elements of an array. This slightly abstract example shows using a <strong class="source-inline">for</strong> loop to put the values 0 through 9 into the <strong class="source-inline">uselessArray</strong> array:</p>
			<p class="source-code">for(int i = 0; i &lt; 10; i++)</p>
			<p class="source-code">{</p>
			<p class="source-code">    uselessArray[i] = i;</p>
			<p class="source-code">}</p>
			<p>The preceding code assumes that <strong class="source-inline">uslessArray</strong> had previously been initialized to hold at least 10 <strong class="source-inline">int</strong> variables.</p>
			<p>But why do we need arrays?</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor117"/>What do these arrays really do for our games?</h2>
			<p>We can use arrays anywhere a regular variable can be used – perhaps in an expression like this:</p>
			<p class="source-code">// someArray[4] is declared and initialized to 9999</p>
			<p class="source-code">for(int i = 0; <strong class="bold">i &lt; someArray[4]</strong>; i++)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Loop executes 9999 times</p>
			<p class="source-code">}</p>
			<p>One of the biggest benefits of arrays in game code was hinted at at the start of this section. Arrays can hold objects (instances of classes). Let's imagine that we have a <strong class="source-inline">Zombie</strong> class and we want to store a whole bunch of them. We can do so like this:</p>
			<p class="source-code">Zombie horde [5] {zombie1, zombie2, zombie3}; // etc...</p>
			<p>The <strong class="source-inline">horde</strong> array now holds a load of instances of the <strong class="source-inline">Zombie </strong>class. Each one is a separate, living (kind of), breathing, self-determining <strong class="source-inline">Zombie</strong> object. We could then loop through the <strong class="source-inline">horde</strong> array, each of which passes through the game loop, move the zombies, and check if their heads have met with an axe or if they have managed to catch the player.</p>
			<p>Arrays, had we known about them at the time, would have been perfect for handling our clouds in <a href="B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 2</em></a>, <em class="italic">Variables, Operators, and Decisions – Animating Sprites</em>. We could have had as many clouds as we wanted and written less code than we did for our three measly clouds.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To check out this improved cloud code in full and in action, look at the enhanced version of Timber!!! (code and playable game) in the download bundle. Alternatively, you can try to implement the clouds using arrays yourself before looking at the code.</p>
			<p>The best way to get a feel for all of this array stuff is to see it in action. We will do this when we implement our tree branches.</p>
			<p>For now, we will leave our cloud code as it is so that we can get back to adding features to the game as soon as possible. But first, let's do a bit more C++ decision-making with <strong class="bold">switch</strong>.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Making decisions with switch</h1>
			<p>We have already looked at <strong class="source-inline">if</strong>, which allows us to decide whether to execute a block of code based upon the result of its expression. But sometimes, a decision in C++ can be made in other ways that are better.</p>
			<p>When we must make a decision based on a clear list of possible outcomes that don't involve complex combinations or wide ranges of values, then <strong class="source-inline">switch</strong> is usually the way to go. We can start a <strong class="source-inline">switch</strong> decision as follows:</p>
			<p class="source-code">switch(<strong class="bold">expression</strong>)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // More code here</p>
			<p class="source-code">}</p>
			<p>In the previous example, <strong class="source-inline">expression</strong> could be an actual expression or just a variable. Then, within the curly braces, we can make decisions based on the result of the expression or value of the variable. We do this with the <strong class="source-inline">case</strong> and <strong class="source-inline">break</strong> keywords:</p>
			<p class="source-code">case x:</p>
			<p class="source-code">    //code for x</p>
			<p class="source-code">    break;</p>
			<p class="source-code"> </p>
			<p class="source-code">case y:</p>
			<p class="source-code">    //code for y</p>
			<p class="source-code">    break;</p>
			<p>As you can see, each <strong class="source-inline">case</strong> states a possible result and each <strong class="source-inline">break</strong> denotes the end of that <strong class="source-inline">case</strong> and the point that the execution leaves the <strong class="source-inline">switch</strong> block.</p>
			<p>Optionally, we can also use the <strong class="source-inline">default</strong> keyword without a value to run some code in case none of the <strong class="source-inline">case</strong> statements evaluate to <strong class="source-inline">true</strong>, as follows:</p>
			<p class="source-code">default: // Look no value</p>
			<p class="source-code">    // Do something here if no other case statements are true</p>
			<p class="source-code">    break;</p>
			<p>As a final and less abstract example for <strong class="source-inline">switch</strong>, consider a retro text adventure where the player enters a letter such as "n", "e", "s", or "w" to move North, East, South, or West. A <strong class="source-inline">switch</strong> block could be used to handle each possible input from the player:</p>
			<p class="source-code">// get input from user in a char called command</p>
			<p class="source-code">switch(command){</p>
			<p class="source-code">    case 'n':</p>
			<p class="source-code">        // Handle move here</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 'e':</p>
			<p class="source-code">        // Handle move here</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 's':</p>
			<p class="source-code">        // Handle move here</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 'w':</p>
			<p class="source-code">        // Handle move here</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // more possible cases</p>
			<p class="source-code">    default:</p>
			<p class="source-code">        // Ask the player to try again</p>
			<p class="source-code">        break;</p>
			<p class="source-code">}</p>
			<p>The best way of understanding all we have seen regarding <strong class="source-inline">switch</strong> is by putting it into action, along with all the other new concepts we are learning about.</p>
			<p>Next, we will learn about another C++ concept we need to understand before we write some more code. Let's look at class enumerations.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Class enumerations</h1>
			<p>An <strong class="bold">enumeration</strong> is a list of all the possible values in a logical collection. C++ enumerations are a great way of, well, enumerating things. For example, if our game uses variables that can only be in a specific range of values and if those values could logically form a collection or a set, then enumerations are probably appropriate to use. They will make your code clearer and less error-prone.</p>
			<p>To declare a class enumeration in C++, we can use these two keywords, <strong class="source-inline">enum class</strong>, together, followed by the name of the enumeration, followed by the values the enumeration can contain, enclosed in a pair of curly braces <strong class="source-inline">{...}</strong>.</p>
			<p>As an example, examine the following enumeration declaration. Note that it is convention to declare the possible values from the enumeration in uppercase:</p>
			<p class="source-code">enum class zombieTypes {</p>
			<p class="source-code">   REGULAR, RUNNER, </p>
			<p class="source-code">   CRAWLER, SPITTER, BLOATER </p>
			<p class="source-code">};</p>
			<p>Note that, at this point, we have not declared any instances of <strong class="source-inline">zombieType</strong>, just the type itself. If that sounds odd, think about it like this. SFML created the <strong class="source-inline">Sprite</strong>, <strong class="source-inline">RectangleShape</strong>, and <strong class="source-inline">RenderWindow</strong> classes, but to use any of those classes, we had to declare an object/instance of the class.</p>
			<p>At this point, we have created a new type called <strong class="source-inline">zombieTypes</strong>, but we have no instances of it. So, let's do that now:</p>
			<p class="source-code">zombieType jeremy = zombieTypes::CRAWLER;</p>
			<p class="source-code">zombieType anna = zombieTypes::SPITTER;</p>
			<p class="source-code">zombieType diane = zombieTypes::BLOATER;</p>
			<p class="source-code">/*</p>
			<p class="source-code">    Zombies are fictional creatures and any resemblance</p>
			<p class="source-code">    to real people is entirely coincidental</p>
			<p class="source-code">*/</p>
			<p>Next is a sneak preview of the type of code we will soon be adding to Timber!!!. We will want to track which side of the tree a branch or the player is on, so we will declare an enumeration called <strong class="source-inline">side</strong>, like this:</p>
			<p class="source-code">enum class side { LEFT, RIGHT, NONE };</p>
			<p>We could position the player on the left like this:</p>
			<p class="source-code">// The player starts on the left</p>
			<p class="source-code">side playerSide = side::LEFT;</p>
			<p>We could make the fourth level (arrays start from zero) of an array of branch positions have no branch at all, like this:</p>
			<p class="source-code">branchPositions[3] = side::NONE;</p>
			<p>We can use enumerations in expressions as well:</p>
			<p class="source-code">if(branchPositions[5] == playerSide)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // The lowest branch is the same side as the player</p>
			<p class="source-code">    // SQUISHED!!</p>
			<p class="source-code">}</p>
			<p>The preceding code tests whether the branch in position [5] element of the array is on the same side as the player.</p>
			<p>We will look at one more vital C++ topic, that is, functions, and then we will get back to coding the game. When we want to compartmentalize some code that does one specific thing, we can use a function.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>Getting started with functions</h1>
			<p>What exactly are C++ functions? A function is a collection of variables, expressions, and <strong class="bold">control flow statements</strong> (loops and branches). In fact, any of the code we have learned about in this book so far can be used in a function. The first part of a function that we write is called the <strong class="bold">signature</strong>. Here is an example function signature:</p>
			<p class="source-code">void shootLazers(int power, int direction);</p>
			<p>If we add an opening and closing pair of curly braces <strong class="source-inline">{...}</strong> along with some code that the function performs, we will have a complete function, that is, a <strong class="bold">definition</strong>:</p>
			<p class="source-code">void shootLazers(int power, int direction)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // ZAPP!</p>
			<p class="source-code">}</p>
			<p>We could then use our new function from another part of our code, perhaps like this:</p>
			<p class="source-code">// Attack the player</p>
			<p class="source-code">shootLazers(50, 180) // Run the code in the function</p>
			<p class="source-code">// I'm back again - code continues here after the function ends</p>
			<p>When we use a function, we say that we <strong class="bold">call </strong>it. At the point where we call <strong class="source-inline">shootLazers</strong>, our program's execution branches to the code contained within that function. The function will run until it reaches the end or is told to <strong class="source-inline">return</strong>. Then, the code will continue running from the first line after the function call. We have already been using the functions that SFML provides. What is different here is that we will learn to write and call our own functions.</p>
			<p>Here is another example of a function, complete with the code to make the function return to the code that called it:</p>
			<p class="source-code">int addAToB(int a, int b)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int answer = a + b;</p>
			<p class="source-code">    return answer;</p>
			<p class="source-code">}</p>
			<p>The call so that we can use the preceding function may look like this:</p>
			<p class="source-code">int myAnswer = addAToB(2, 4);</p>
			<p>Obviously, we don't need to write functions to add two variables together, but this example helps us look into the workings of functions. First, we pass in the values <strong class="source-inline">2</strong> and <strong class="source-inline">4</strong>. In the function signature, the value <strong class="source-inline">2</strong> is assigned to <strong class="source-inline">int a</strong>, and the value <strong class="source-inline">4</strong> is assigned to <strong class="source-inline">int b</strong>.</p>
			<p>Within the function body, the <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> variables are added together and used to initialize the new variable, <strong class="source-inline">int answer</strong>. The <strong class="source-inline">return answer;</strong> line does just that. It returns the value stored in <strong class="source-inline">answer</strong> to the calling code, causing <strong class="source-inline">myAnswer</strong> to be initialized with the value <strong class="source-inline">6</strong>.</p>
			<p>Notice that each of the function signatures in the preceding examples vary a little. The reason for this is that the C++ function signature is quite flexible, allowing us to build exactly the functions we require.</p>
			<p>Exactly how the function signature defines how the function must be called and if/how the function must return a value deserves further discussion. Let's give each part of that signature a name so that we can break it into parts and learn about them.</p>
			<p>Here is a function signature with its parts described by their formal/technical term:</p>
			<p class="source-code"><strong class="bold">return type | name of function | (parameters)</strong></p>
			<p>Here are a few examples that we can use for each of those parts:</p>
			<ul>
				<li><strong class="bold">Return-type</strong>: <strong class="source-inline">void</strong>,  <strong class="source-inline">bool</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">int</strong>, and so on, or any C++ type or expression</li>
				<li><strong class="bold">Name of function</strong>: <strong class="source-inline">shootLazers</strong>, <strong class="source-inline">addAToB</strong>, and so on</li>
				<li><strong class="bold">Parameters</strong>: <strong class="source-inline">(int number, bool hitDetected)</strong>, <strong class="source-inline">(int x, int y)</strong>, <strong class="source-inline">(float a, float b)</strong></li>
			</ul>
			<p>Now, let's look at each part in turn, starting with the return type.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>Function return types</h2>
			<p>The return type, as its name suggests, is the type of the value that will be returned from the function to the calling code:</p>
			<p class="source-code">int addAToB(int a, int b){</p>
			<p class="source-code"> </p>
			<p class="source-code">    int answer = a + b;</p>
			<p class="source-code">    return answer;</p>
			<p class="source-code"> </p>
			<p class="source-code">}</p>
			<p>In our slightly dull but useful <strong class="source-inline">addAtoB</strong> example that we looked at previously, the return type in the signature is <strong class="source-inline">int</strong>. The <strong class="source-inline">addAToB</strong> function sends back and returns  a value that will fit in an <strong class="source-inline">int</strong> variable to the code that called it. The return type can be any C++ type we have seen so far or one of the ones we haven't seen yet.</p>
			<p>A function does not have to return a value at all, however. In this case, the signature must use the <strong class="source-inline">void</strong> keyword as the return type. When the <strong class="source-inline">void</strong> keyword is used, the function body must not attempt to return a value as this will cause an error. It can, however, use the <strong class="source-inline">return</strong> keyword without a value. Here are some combinations of the return type and use of the <strong class="source-inline">return</strong> keyword that are valid:</p>
			<p class="source-code">void doWhatever(){</p>
			<p class="source-code"> </p>
			<p class="source-code">    // our code</p>
			<p class="source-code">    // I'm done going back to calling code here</p>
			<p class="source-code">    // no return is necessary</p>
			<p class="source-code"> </p>
			<p class="source-code">}</p>
			<p>Another possibility is as follows:</p>
			<p class="source-code">void doSomethingCool(){</p>
			<p class="source-code"> </p>
			<p class="source-code">    // our code</p>
			<p class="source-code"> </p>
			<p class="source-code">    // I can do this if I don't try and use a value</p>
			<p class="source-code">    return;</p>
			<p class="source-code">}</p>
			<p>The following code is yet more examples of possible functions. Be sure to read the comments as well as the code:</p>
			<p class="source-code">void doYetAnotherThing(){</p>
			<p class="source-code">    // some code</p>
			<p class="source-code"> </p>
			<p class="source-code">    if(someCondition){</p>
			<p class="source-code"> </p>
			<p class="source-code">        // if someCondition is true returning to calling code</p>
			<p class="source-code">        // before the end of the function body</p>
			<p class="source-code">        return;</p>
			<p class="source-code">    }</p>
			<p class="source-code"> </p>
			<p class="source-code">    // More code that might or might not get executed</p>
			<p class="source-code"> </p>
			<p class="source-code">    return;</p>
			<p class="source-code"> </p>
			<p class="source-code">    // As I'm at the bottom of the function body</p>
			<p class="source-code">    // and the return type is void, I'm</p>
			<p class="source-code">    // really not necessary but I suppose I make it</p>
			<p class="source-code">    // clear that the function is over.</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">bool detectCollision(Ship a, Ship b){</p>
			<p class="source-code"> </p>
			<p class="source-code">    // Detect if collision has occurred</p>
			<p class="source-code">    if(collision)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Bam!!!</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Missed</p>
			<p class="source-code">        return false;</p>
			<p class="source-code">    }</p>
			<p class="source-code"> </p>
			<p class="source-code">}</p>
			<p>The last function example in the preceding code, which is for <strong class="source-inline">detectCollision</strong>, is a glimpse into the near future of our C++ code and demonstrates that we can also pass in user-defined types known as objects into functions so that we can perform calculations on them.</p>
			<p>We could call each of the functions, in turn, like this:</p>
			<p class="source-code">// OK time to call some functions</p>
			<p class="source-code">doWhatever();</p>
			<p class="source-code">doSomethingCool();</p>
			<p class="source-code">doYetAnotherThing();</p>
			<p class="source-code"> </p>
			<p class="source-code">if (detectCollision(milleniumFalcon, lukesXWing))</p>
			<p class="source-code">{</p>
			<p class="source-code">    // The jedi are doomed!</p>
			<p class="source-code">    // But there is always Leia.</p>
			<p class="source-code">    // Unless she was on the Falcon?</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Live to fight another day</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">// Continue with code from here</p>
			<p>Don't worry about the odd-looking syntax regarding the <strong class="source-inline">detectCollision</strong> function; we will see real code like this soon. Simply, we are using the return value (<strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>) as the expression directly in an <strong class="source-inline">if </strong>statement.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Function names</h2>
			<p>The function name that we use when we design our own function can be almost anything at all. But it is best to use words, usually verbs, that clearly explain what the function will do. For example, take a look at the following function:</p>
			<p class="source-code">void functionaroonieboonie(int blibbityblob, float floppyfloatything)</p>
			<p class="source-code">{</p>
			<p class="source-code">    //code here</p>
			<p class="source-code">}</p>
			<p>The preceding function is perfectly legal and will work, but the following function names are much clearer:</p>
			<p class="source-code">void doSomeVerySpecificTask()</p>
			<p class="source-code">{</p>
			<p class="source-code">    //code here</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">int getMySpaceShipHealth()</p>
			<p class="source-code">{</p>
			<p class="source-code">    //code here</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">void startNewGame()</p>
			<p class="source-code">{</p>
			<p class="source-code">    //code here</p>
			<p class="source-code">}</p>
			<p>Using clear and descriptive function names such as in the preceding three examples is good practice, but, as we saw from the <strong class="source-inline">functionaroonieboonie</strong> function, this is not a rule that the compiler enforces. Next, we will take a closer look at how we share some values with a function.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Function parameters</h2>
			<p>We know that a function can return a result to the calling code. But what if we need to share some data values from the calling code with the function? <strong class="bold">Parameters</strong> allow us to share values with the function. We have already seen examples of parameters while looking at return types. We will look at the same example but a little more closely:</p>
			<p class="source-code">int addAToB(<strong class="bold">int a, int b</strong>)</p>
			<p class="source-code">{ </p>
			<p class="source-code">    int answer = a + b;</p>
			<p class="source-code">    return answer; </p>
			<p class="source-code">}</p>
			<p>Here, the parameters are <strong class="source-inline">int a</strong> and <strong class="source-inline">int b</strong>. Notice that, in the first line of the function body, we use <strong class="source-inline">a + b</strong> as if they are already declared and initialized variables. Well, that's because they are. The parameters in the function signature is their declaration, and the code that calls the function initializes them.</p>
			<p class="callout-heading">Important jargon note</p>
			<p class="callout">Note that we are referring to the variables in the function signature brackets <strong class="source-inline">(int a, int b)</strong> as parameters. When we pass values into the function from the calling code, these values are called arguments. When the arguments arrive, they are used by the parameters to initialize real, usable variables, like:</p>
			<p class="callout"><strong class="source-inline">int returnedAnswer = addAToB(10,5);</strong></p>
			<p>Also, as we have partly seen in previous examples, we don't have to just use <strong class="source-inline">int</strong> in our parameters. We can use any C++ type. We can also use as many parameters as is necessary to solve our problem, but it is good practice to keep the parameter list as short and therefore as manageable as possible.</p>
			<p>As we will see in future chapters, we have left a few of the cooler uses of functions out of this introductory tutorial so that we can learn about related C++ concepts before we take the topic of functions further.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>The function body</h2>
			<p>The body is the part we have been kind of avoiding and has comments such as the following:</p>
			<p class="source-code">// code here</p>
			<p class="source-code">// some code</p>
			<p>Actually, we already know exactly what to do here! Any C++ code we have learned about so far will work in the body of a function.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Function prototypes</h2>
			<p>So far, we have seen how to code a function and we have seen how to call one as well. There is one more thing we need to do, however, to make them work. All functions must have a <strong class="bold">prototype</strong>. A prototype is what makes the compiler aware of our function, and without a prototype the entire game will fail to compile. Fortunately, prototypes are straightforward.</p>
			<p>We can simply repeat the function's signature, followed by a semicolon. The caveat is that the prototype must appear <em class="italic">before</em> any attempt to call or define the function. So, the absolute most simple example of a fully usable function in action is as follows. Look carefully at the comments and the location in the code that the different parts of the function appear in:</p>
			<p class="source-code">// The prototype</p>
			<p class="source-code">// Notice the semicolon on the end</p>
			<p class="source-code">int addAToB(int a, int b);</p>
			<p class="source-code"> </p>
			<p class="source-code">int main()</p>
			<p class="source-code">{ </p>
			<p class="source-code">    // Call the function</p>
			<p class="source-code">    // Store the result in answer</p>
			<p class="source-code">    int answer = addAToB(2,2);</p>
			<p class="source-code"> </p>
			<p class="source-code">    // Called before the definition</p>
			<p class="source-code">    // but that's OK because of the prototype</p>
			<p class="source-code"> </p>
			<p class="source-code">    // Exit main</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code"> </p>
			<p class="source-code">}// End of main</p>
			<p class="source-code"> </p>
			<p class="source-code">// The function definition</p>
			<p class="source-code">int addAToB(int a, int b)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return a + b;</p>
			<p class="source-code">}</p>
			<p>What the previous code demonstrates is the following:</p>
			<ul>
				<li>The prototype is before the <strong class="source-inline">main</strong> function.</li>
				<li>The call to use the function is as we might expect, inside the <strong class="source-inline">main</strong> function.</li>
				<li>The definition is after/outside the <strong class="source-inline">main</strong> function.<p class="callout-heading">Important note</p><p class="callout">Note that we can omit the function prototype and go straight to the definition when the definition occurs before the function is used. As our code becomes longer and spread across multiple files, however, this will almost never happen. We will use separate prototypes and definitions all the time.</p></li>
			</ul>
			<p>Let's see how we can keep our functions organized.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Organizing functions</h2>
			<p>It's well worth pointing out that if we have multiple functions, especially if they are fairly long, our <strong class="source-inline">.cpp</strong> file will quickly become unwieldy. This defeats part of the objective that functions are intended for. The solution that we will see in the next project is that we can add all our function prototypes to our very own header file (<strong class="source-inline">.hpp </strong>or<strong class="source-inline"> .h</strong>). Then, we can code all our functions in another <strong class="source-inline">.cpp</strong> file and simply add another <strong class="source-inline">#include...</strong> directive in our main <strong class="source-inline">.cpp</strong> file. This way, we can use any number of functions without adding any of their code (prototype or definition) to our main code file.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Function gotcha!</h2>
			<p>Another point that we should discuss about functions is <strong class="bold">scope</strong>. If we declare a variable in a function, either directly or in one of the parameters, that variable is not usable/visible outside of that function. Furthermore, any variables declared inside other functions cannot be seen/used inside the function.</p>
			<p>The way that we should share values between function code and calling code is through the parameters/arguments and the return value.</p>
			<p>When a variable is not available because it is from another function, it is said to be out of scope. When it is available and usable, it is said to be in scope.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Variables declared within any block in C++ are only in scope within that block! This includes loops and <strong class="source-inline">if</strong> blocks as well. A variable that's declared at the top of <strong class="source-inline">main</strong> is in scope anywhere in <strong class="source-inline">main</strong>, a variable that's declared in the game loop is only in scope within the game loop, and so on. A variable that's declared within a function or other block is called a <strong class="bold">local</strong> variable. The more code we write, the more this will make sense. Every time we come across an issue in our code regarding scope, I will discuss it to make things clear. There will be one such issue coming up in the next section. There are also some more C++ staples that blow this issue wide open. They are called <strong class="bold">references</strong> and <strong class="bold">pointers</strong>, and we will learn about them in <a href="B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200"><em class="italic">Chapter 9</em></a>, <em class="italic">C++ References, Sprite Sheets, and Vertex Arrays</em> and<em class="italic"> </em><a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>, <em class="italic">Pointers, the Standard Template Library, and Texture Management</em> respectively.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>More on functions</h2>
			<p>There is even more we could learn about functions, but we know enough about them already to implement the next part of our game. And don't worry if all the technical terms such as parameters, signatures, and definitions have not completely sunk in yet. These concepts will become clearer when we start to use them.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor129"/>An absolute final word on functions – for now</h2>
			<p>It has probably not escaped your attention that we have been calling functions, especially the SFML functions, by appending the name of an object and a period before the function name, like this:</p>
			<p class="source-code">spriteBee.setPosition...</p>
			<p class="source-code">window.draw...</p>
			<p class="source-code">// etc</p>
			<p>And yet, our entire discussion of functions saw us calling functions without any objects. We can write functions as part of a class or simply as a standalone function. When we write a function as part of a class, we need an object of that class to call the function, but when we have a standalone function, we don't.</p>
			<p>We will write a standalone function in a minute and we will write classes with functions starting from <a href="B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 6</em></a>,<em class="italic"> Object-Oriented Programming – Starting the Pong Game</em>. Everything we know so far about functions is relevant in both cases.</p>
			<p>Now, we can get back to coding the branches in the Timber!!! game.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Growing the branches</h1>
			<p>Next, as I have been promising for the last 20 pages, we will use all the new C++ techniques we've learned about to draw and move some branches on our tree.</p>
			<p>Add the following code outside of the <strong class="source-inline">main</strong> function. Just to be absolutely clear, I mean <em class="italic">before</em> the code for <strong class="source-inline">int main()</strong>:</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code"><strong class="bold">// Function declaration</strong></p>
			<p class="source-code"><strong class="bold">void updateBranches(int seed);</strong></p>
			<p class="source-code"><strong class="bold">const int NUM_BRANCHES = 6;</strong></p>
			<p class="source-code"><strong class="bold">Sprite branches[NUM_BRANCHES];</strong></p>
			<p class="source-code"><strong class="bold">// Where is the player/branch?</strong></p>
			<p class="source-code"><strong class="bold">// Left or Right</strong></p>
			<p class="source-code"><strong class="bold">enum class side { LEFT, RIGHT, NONE };</strong></p>
			<p class="source-code"><strong class="bold">side branchPositions[NUM_BRANCHES];</strong></p>
			<p class="source-code">int main()</p>
			<p>We just achieved quite a few things with that new code:</p>
			<ul>
				<li>First, we wrote a function prototype for a function called <strong class="source-inline">updateBranches</strong>. We can see that it does not return a value (<strong class="source-inline">void</strong>) and that it takes an <strong class="source-inline">int</strong> argument called <strong class="source-inline">seed</strong>. We will write the function definition soon, and we will then see exactly what it does.</li>
				<li>Next, we declare an <strong class="source-inline">int</strong> constant called <strong class="source-inline">NUM_BRANCHES</strong> and initialize it to <strong class="source-inline">6</strong>. There will be six moving branches on the tree, and we will soon see how <strong class="source-inline">NUM_BRANCHES</strong> is useful to us.</li>
				<li>Following this, we declare an array of <strong class="source-inline">Sprite</strong> objects called <strong class="source-inline">branches</strong> that can hold six <strong class="source-inline">Sprite</strong> instances.</li>
				<li>After that, we declare a new enumeration called <strong class="source-inline">side</strong> with three possible values: <strong class="source-inline">LEFT</strong>, <strong class="source-inline">RIGHT</strong>, and <strong class="source-inline">NONE</strong>. This will be used to describe the position of individual branches, as well as the player, in a few places throughout our code.</li>
				<li>Finally, in the preceding code, we initialize an array of <strong class="source-inline">side</strong> types with a size of <strong class="source-inline">NUM_BRANCHES</strong> (6). To be clear about what this achieves, we will have an array called <strong class="source-inline">branchPositions</strong> with six values in it. Each of these values is of the <strong class="source-inline">side</strong> type and can be either <strong class="source-inline">LEFT</strong>, <strong class="source-inline">RIGHT</strong>, or <strong class="source-inline">NONE</strong>.<p class="callout-heading">Important note</p><p class="callout">Of course, what you really want to know is why the constant, two arrays, and the enumeration were declared <em class="italic">outside</em> of the <strong class="source-inline">main</strong> function. By declaring them above <strong class="source-inline">main</strong>, they now have <strong class="bold">global scope</strong>. To describe this in another way, the constant, two arrays, and the enumeration have scope for the entire game. This means we can access and use them all anywhere in the <strong class="source-inline">main</strong> function and the <strong class="source-inline">updateBranches</strong> function. Note that it is good practice to make all the variables as local to where they are actually used as possible. It might seem useful to make everything global, but this leads to hard-to-read and error-prone code.</p></li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor131"/>Preparing the branches</h2>
			<p>Now, we will prepare our six <strong class="source-inline">Sprite</strong> objects and load them into the <strong class="source-inline">branches</strong> array. Add the following highlighted code just before our game loop:</p>
			<p class="source-code">// Position the text</p>
			<p class="source-code">FloatRect textRect = messageText.getLocalBounds();</p>
			<p class="source-code">messageText.setOrigin(textRect.left +</p>
			<p class="source-code">    textRect.width / 2.0f,</p>
			<p class="source-code">    textRect.top +</p>
			<p class="source-code">    textRect.height / 2.0f);</p>
			<p class="source-code">messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);</p>
			<p class="source-code">scoreText.setPosition(20, 20);</p>
			<p class="source-code"><strong class="bold">// Prepare 6 branches</strong></p>
			<p class="source-code"><strong class="bold">Texture textureBranch;</strong></p>
			<p class="source-code"><strong class="bold">textureBranch.loadFromFile("graphics/branch.png");</strong></p>
			<p class="source-code"><strong class="bold">// Set the texture for each branch sprite</strong></p>
			<p class="source-code"><strong class="bold">for (int i = 0; i &lt; NUM_BRANCHES; i++) {</strong></p>
			<p class="source-code"><strong class="bold">    branches[i].setTexture(textureBranch);</strong></p>
			<p class="source-code"><strong class="bold">    branches[i].setPosition(-2000, -2000);</strong></p>
			<p class="source-code"><strong class="bold">    // Set the sprite's origin to dead centre</strong></p>
			<p class="source-code"><strong class="bold">    // We can then spin it round without changing its position</strong></p>
			<p class="source-code"><strong class="bold">    branches[i].setOrigin(220, 20);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p>In the preceding code, we are doing the following:</p>
			<ol>
				<li>First, we declare an SFML <strong class="source-inline">Texture</strong> object and load the <strong class="source-inline">branch.png</strong> graphic into it.</li>
				<li>Next, we create a <strong class="source-inline">for</strong> loop that sets <strong class="source-inline">i</strong> to zero and increments <strong class="source-inline">i</strong> by one on each pass through the loop until <strong class="source-inline">i</strong> is no longer less than <strong class="source-inline">NUM_BRANCHES</strong>. This is exactly right because <strong class="source-inline">NUM_BRANCHES</strong> is 6 and the <strong class="source-inline">branches</strong> array has positions 0 through 5.</li>
				<li>Inside the <strong class="source-inline">for</strong> loop, we set the <strong class="source-inline">Texture</strong> for each <strong class="source-inline">Sprite</strong> in the <strong class="source-inline">branches</strong> array with <strong class="source-inline">setTexture</strong> and then hide it off-screen with <strong class="source-inline">setPosition</strong>.</li>
				<li>Finally, we set the origin (the point that is used to locate the sprite when it is drawn) with <strong class="source-inline">setOrigin</strong>, to the center of the sprite. Soon, we will be rotating these sprites. Having the origin in the center means they will spin nicely around, without moving the sprite out of position.</li>
			</ol>
			<p>Now that we have prepared all the branches, we can write some code to update them all each frame.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor132"/>Updating the branch sprites each frame</h2>
			<p>In the following code, we will set the position of all the sprites in the <strong class="source-inline">branches</strong> array, based upon their position in the array and the value of <strong class="source-inline">side</strong> in the corresponding <strong class="source-inline">branchPositions</strong> array. Add the following highlighted code and try to understand it first before we go through it in detail:</p>
			<p class="source-code">    // Update the score text</p>
			<p class="source-code">    std::stringstream ss;</p>
			<p class="source-code">    ss &lt;&lt; "Score: " &lt;&lt; score;</p>
			<p class="source-code">    scoreText.setString(ss.str());</p>
			<p class="source-code"><strong class="bold">    // update the branch sprites</strong></p>
			<p class="source-code"><strong class="bold">    for (int i = 0; i &lt; NUM_BRANCHES; i++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        float height = i * 150;</strong></p>
			<p class="source-code"><strong class="bold">        if (branchPositions[i] == side::LEFT)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // Move the sprite to the left side</strong></p>
			<p class="source-code"><strong class="bold">            branches[i].setPosition(610, height);</strong></p>
			<p class="source-code"><strong class="bold">            // Flip the sprite round the other way</strong></p>
			<p class="source-code"><strong class="bold">            branches[i].setRotation(180);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else if (branchPositions[i] == side::RIGHT)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // Move the sprite to the right side</strong></p>
			<p class="source-code"><strong class="bold">            branches[i].setPosition(1330, height);</strong></p>
			<p class="source-code"><strong class="bold">            // Set the sprite rotation to normal</strong></p>
			<p class="source-code"><strong class="bold">            branches[i].setRotation(0);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // Hide the branch</strong></p>
			<p class="source-code"><strong class="bold">            branches[i].setPosition(3000, height);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">} // End if(!paused)</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p>The code we just added is one big <strong class="source-inline">for</strong> loop that sets <strong class="source-inline">i</strong> to zero and increments <strong class="source-inline">i</strong> by one each time through the loop and keeps going until <strong class="source-inline">i</strong> is no longer less than 6.</p>
			<p>Inside the <strong class="source-inline">for</strong> loop, a new <strong class="source-inline">float</strong> variable called <strong class="source-inline">height</strong> is set to <strong class="source-inline">i * 150</strong>. This means that the first branch will have a height of 0, the second a height of 150, and the sixth a height of 750.</p>
			<p>Next, we have a structure of <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> blocks. Take a look at the structure with the code stripped out:</p>
			<p class="source-code">if()</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p class="source-code">else if()</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>The first <strong class="source-inline">if</strong> statement uses the <strong class="source-inline">branchPositions</strong> array to see whether the current branch should be on the left. If it is, it sets the corresponding <strong class="source-inline">Sprite</strong> from the <strong class="source-inline">branches</strong> array to a position on the screen, appropriate for the left (610 pixels) and whatever the current <strong class="source-inline">height</strong> is. It then flips the Sprite by 180 degrees because the <strong class="source-inline">branch.png</strong> graphic "hangs" to the right by default.</p>
			<p>Note that <strong class="source-inline">else if</strong> only executes if the branch is not on the left. It uses the same method to see if it is on the right. If it is, then the branch is drawn on the right (1,330 pixels). Then, the sprite rotation is set to zero degrees, just in case it had previously been at 180 degrees. If the x coordinate seems a little bit strange, just remember that we set the origin for the branch sprites to their center.</p>
			<p>The final <strong class="source-inline">else</strong> statement correctly assumes that the current <strong class="source-inline">branchPosition</strong> must be <strong class="source-inline">NONE</strong> and hides the branch off-screen at 3,000 pixels.</p>
			<p>At this point, our branches are in position and ready to be drawn.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor133"/>Drawing the branches</h2>
			<p>Here, we will use another <strong class="source-inline">for</strong> loop to step through the entire <strong class="source-inline">branches</strong> array from 0 to 5 and draw each branch sprite. Add the following highlighted code:</p>
			<p class="source-code">// Draw the clouds</p>
			<p class="source-code">window.draw(spriteCloud1);</p>
			<p class="source-code">window.draw(spriteCloud2);</p>
			<p class="source-code">window.draw(spriteCloud3);</p>
			<p class="source-code"><strong class="bold">// Draw the branches</strong></p>
			<p class="source-code"><strong class="bold">for (int i = 0; i &lt; NUM_BRANCHES; i++) {</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(branches[i]);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">// Draw the tree</p>
			<p class="source-code">window.draw(spriteTree);</p>
			<p>Of course, we still haven't written the function that moves all the branches. Once we have written that function, we will also need to work out when and how to call it. Let's solve the first problem and write the function.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor134"/>Moving the branches</h2>
			<p>We have already added the function prototype, above the <strong class="source-inline">main</strong> function. Now, we can code the actual definition of the function that will move all the branches down by one position each time it is called. We will code this function in two parts so that we can easily examine what is happening.</p>
			<p>Add the first part of the <strong class="source-inline">updateBranches</strong> function <em class="italic">after</em> the closing curly brace of the <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">// Function definition</p>
			<p class="source-code">void updateBranches(int seed)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Move all the branches down one place</p>
			<p class="source-code">    for (int j = NUM_BRANCHES-1; j &gt; 0; j--) {	</p>
			<p class="source-code">        branchPositions[j] = branchPositions[j - 1];</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this first part of the function, we simply move all the branches down one position, one at a time, starting with the sixth branch. This is achieved by making the <strong class="source-inline">for</strong> loop count from 5 through to 0. Note that <strong class="source-inline">branchPositions[j] = branchPositions[j - 1]; </strong>makes the actual move.  </p>
			<p>The other thing to note with this previous code is that after we have moved the branch in position 4 to position 5, then the branch in position 3 to position 4, and so on, we will need to add a new branch at position 0, which is the top of the tree.</p>
			<p>Now, we can spawn a new branch at the top of the tree. Add the following highlighted code, and then we will talk about it:</p>
			<p class="source-code">// Function definition</p>
			<p class="source-code">void updateBranches(int seed)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Move all the branches down one place</p>
			<p class="source-code">    for (int j = NUM_BRANCHES-1; j &gt; 0; j--) {	</p>
			<p class="source-code">        branchPositions[j] = branchPositions[j - 1];</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Spawn a new branch at position 0</strong></p>
			<p class="source-code"><strong class="bold">    // LEFT, RIGHT or NONE</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0)+seed);</strong></p>
			<p class="source-code"><strong class="bold">    int r = (rand() % 5);</strong></p>
			<p class="source-code"><strong class="bold">    switch (r) {</strong></p>
			<p class="source-code"><strong class="bold">    case 0:</strong></p>
			<p class="source-code"><strong class="bold">        branchPositions[0] = side::LEFT;</strong></p>
			<p class="source-code"><strong class="bold">        break;</strong></p>
			<p class="source-code"><strong class="bold">    case 1:</strong></p>
			<p class="source-code"><strong class="bold">        branchPositions[0] = side::RIGHT;</strong></p>
			<p class="source-code"><strong class="bold">        break;</strong></p>
			<p class="source-code"><strong class="bold">    default:</strong></p>
			<p class="source-code"><strong class="bold">        branchPositions[0] = side::NONE;</strong></p>
			<p class="source-code"><strong class="bold">        break;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>In the final part of the <strong class="source-inline">updateBranches</strong> function, we use the integer <strong class="source-inline">seed</strong> variable that gets passed in with the function call. We do this to guarantee that the random number seed is always different. We will see how we arrived at this value in the next chapter.</p>
			<p>Next, we generate a random number between zero and four and store the result in the <strong class="source-inline">int</strong> variable called <strong class="source-inline">r</strong>. Now, we <strong class="source-inline">switch</strong>, using <strong class="source-inline">r</strong> as the expression.</p>
			<p>The <strong class="source-inline">case</strong> statements mean that if <strong class="source-inline">r</strong> is equal to zero, then we add a new branch to the left-hand side, at the top of the tree. If <strong class="source-inline">r</strong> is equal to 1, then the branch goes to the right. If <strong class="source-inline">r</strong> is anything else, (2, 3, or 4), then <strong class="source-inline">default</strong> ensures no branch will be added at the top. This balance of left, right, and none makes the tree seem realistic and the game work quite well. You could easily change the code to make the branches more frequent or less so.</p>
			<p>Even after all this code for our branches, we still can't see a single one of them in the game. This is because we have more work to do before we can call the <strong class="source-inline">updateBranches</strong> function.</p>
			<p>If you want to see a branch now, you can add some temporary code and call the function five times with a unique seed each time, just before the game loop:</p>
			<p class="source-code"><strong class="bold">updateBranches(1);</strong></p>
			<p class="source-code"><strong class="bold">updateBranches(2);</strong></p>
			<p class="source-code"><strong class="bold">updateBranches(3);</strong></p>
			<p class="source-code"><strong class="bold">updateBranches(4);</strong></p>
			<p class="source-code"><strong class="bold">updateBranches(5);</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p>You can now see the branches in place. But if the branches are to actually move, we will need to call <strong class="source-inline">updateBranches</strong> on a regular basis:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B14278_04_01.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor135"/></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't forget to remove the temporary code before moving on.</p>
			<p>Now, we can turn our attention to the player as well, as calling the <strong class="source-inline">updateBranches</strong> function for real. We will do so in the next chapter.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor136"/>Summary</h1>
			<p>Although not quite the longest, this was probably the chapter where we've covered the most C++ so far. We looked at the different types of loops we can use, such as <strong class="source-inline">for</strong> and <strong class="source-inline">while</strong> loops. We then studied arrays that we can use them to handle large amounts of variables and objects without breaking a sweat. We also learned about enumerations and <strong class="source-inline">switch</strong>. Probably the biggest concept in this chapter was functions, which allow us to organize and abstract our game's code. We will be looking more deeply at functions in a few more places in this book.</p>
			<p>Now that we have a fully "working" tree, we can finish the game off, which we will do in the next and final chapter for this project.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor137"/>FAQ</h1>
			<p>Q) You mentioned there were a few more types of C++ loops. Where can I find out about them?</p>
			<p>A) Yes, take a look at this tutorial and explanation for the <strong class="source-inline">do while</strong> loops: <a href="http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm">http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm</a>.</p>
			<p>Q) Can I assume I am now an expert on arrays?</p>
			<p>A) Like many of the topics in this book, there is always more to learn. You know enough about arrays to proceed, but if you're hungry for more, take a look at this fuller arrays tutorial: <a href="http://www.cplusplus.com/doc/tutorial/arrays/">http://www.cplusplus.com/doc/tutorial/arrays/</a>.</p>
			<p>Q) Can I assume that I am an expert on functions?</p>
			<p>A) Like many of the topics in this book, there is always more to learn. You know enough about functions to proceed, but if want to know even more, take a look at this tutorial: <a href="http://www.cplusplus.com/doc/tutorial/functions/">http://www.cplusplus.com/doc/tutorial/functions/</a>.</p>
		</div>
	</body></html>