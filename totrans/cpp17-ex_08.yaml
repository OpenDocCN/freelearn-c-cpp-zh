- en: The Computer Plays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continue to work on the Othello and Noughts and Crosses games.
    The new part of this chapter is the computer playing against the human; instead
    of two human players, the computer plays against a human.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Game-theory reasoning. In both games, the human or the computer can make the
    first move, and we add code for the computer to play against the human.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Othello, for each move, we scan the game grid and try to find the move that
    causes the highest number of the human's marks to be swapped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Noughts and Crosses, we try to find the position in the game grid that gives
    us the highest number of marks in a row, or, if the human is about to get five
    in row, we have to place the computer’s mark in a position that prevents that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to random number generation. If the computer can choose between
    several equivalent moves, it shall randomly select one of the moves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We continue to use C++ features such as classes, fields, and methods. We also
    continue to use Qt features such as windows and widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Othello
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Othello application of this chapter, we reuse the `MainWindow` and `GameWidget` classes
    of the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The OthelloWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OthelloWindow` class is rather similar to its counterpart in the previous
    chapter. However, in addition to the menus and items, the window of this version
    also holds submenus. The submenus will be added by calling the `addAction` method
    in the `OthelloWindow.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWindow.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `OthelloWindow.cpp` file holds the definitions of the methods of the `OthelloWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWindow.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The title of the window has been changed to `Othello Advanced`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two submenus of the Game menu, `Computer Starts` and `Human Starts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Computer Starts` submenu holds the two items `Computer Black` and `Computer
    White`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Human Starts` submenu holds two items, `Human Black` and `Human White`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The OthelloWidget Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `OthelloWidget` class holds the functionality of Othello. It allows the
    computer to play against a human:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWidget.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OthelloWidget.cpp` file holds the definitions of the methods of the `OthelloWidget` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OthelloWidget.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isComputerStartsBlackEnabled`, `isComputerStartsWhiteEnabled`, `isHumanStartsBlackEnabled`,
    and `isHumanStartsWhiteEnabled` methods are called before the `Computer Starts`
    and `Human Starts` submenus. They become enabled if there is no game in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onComputerStartsBlack` and `onComputerStartsWhite` methods are called
    when the user selects one of the items of the `Computer Starts` submenu. They
    set the computer mark to black or white, start the game by setting the mark in
    the middle of the game grid, and update the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onHumanStartsBlack` and `onHumanStartsWhite` methods are called when the
    user selects one of the items of the `Human Starts` submenu. They set the computer
    mark to black or white and update the window. They do not set any mark in the
    game grid. Instead, the human is to make the first move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMark` method is called when the user clicks one empty position in
    the game grid. We start by setting the next mark at the position, and turn the
    marks as a result of the move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the human''s move did not cause the game grid to become full, we call to
    `calculateComputerMove` to set the computer mark to the position, causing the
    maximum number of opposite marks to be turned. We then update the window and call
    `checkWinner` again to decide if the computer move caused the game grid to become
    full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `drawMark` method is called when a position in the game grid needs to be
    repainted. It draws the mark in the same way as in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkWinner` method of this chapter is also similar to its counterpart
    in the previous chapter. It checks whether the game grid is full. If it is full,
    the winner is announced, or else it is a draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `calculateComputerMove` method calculates the move of the computer that
    generates the highest number of turned opposite marks. We iterate through the
    computer marks and, for each mark, call `calculateTurns` to obtain the maximum
    number of opposite marks that would be turned if we placed the marks at that position.
    For each mark, we also obtain the number of neighbours, which is valuable if we
    do not find any marks to turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `maxTurnSetSize` and `maxNeighbours` fields hold the maximum number of
    turnable marks and neighbours; `maxTurnSetList` holds a list of the maximum sets
    of positions of turnable marks, and `maxNeighboursList` holds a list of the maximum
    number of neighbours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through all the positions in the game grid. For each empty position,
    we obtain the number of opposite marks to be turned if we were to place our mark
    in that position. We also obtain the number of opposite neighbours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we find a set of turnable marks that is larger than the current maximum set,
    we set the `maxTurnSetSize` field to the size of the new turnable set, insert
    the current position in the set, clear `maxTurnSetList` (since we do not want
    its previous smaller sets), and add the new set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the current set for the sake of simplicity; it is easier to add it to
    the set than to store it in any other way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new set is not empty and of equal size to the maximum set, then we simply
    add it to `maxTurnSetList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also check the number of neighbours of the current position. We work in
    the same way as in the `turnable` set case. If the neighbours are more than the
    maximum number of neighbours, we clear `maxNeighboursList` and add the new position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is at least one neighbour, and the neighbours is equal to the maximum
    number of neighbours, we add it to the `maxNeighboursList` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If there is at least one position where we will turn at least one opposite mark,
    we choose it. If there are several positions that will turn the same amount of
    opposite marks, we randomly select one of them. We use the C standard functions
    `srand`, `rand`, and `time` to obtain a random integer number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The random number generator algorithm takes a start value and then generates
    a sequence of random numbers. The `srand` function initializes the generator with
    a start value, and then `rand` is called repeatedly in order to obtain new random
    numbers. In order to not call `srand` with the same start value every time (which
    would result in the same random number sequence), we call `srand` with the result
    of a call to the `time` standard C function, which returns the number of seconds
    since January 1, 1970\. In this way, the random number generator is initialized
    with a new value for each game, and we obtain a new sequence of random numbers
    by repeatedly calling `rand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have obtained the set of positions to be turned, we iterate through
    the set and set the computer mark to all its positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no position that would cause opposite marks to be turned, we look
    at the neighbours instead. In the same way, we randomly select one of the positions
    with the maximum number of neighbours. Note that we do not need to iterate through
    any set; in this case, we only set one mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `turn` method is called when the human has made a move. It calls `calculateMark`
    to obtain a set of turnable opposite marks, and then iterates through the set
    and sets each position in the game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculateTurns` method calculates the set of turnable opposite marks and
    number of neighbours of the given position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each integer pair in `directionArray` refers to a direction in accordance with
    the compass rising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of an array can be decided by dividing its total size (in bytes) by
    the size of its first value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the directions and, for each direction, keep moving as long
    as we find the mark of the opponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `row` and `column` fields hold the current row and column as long as we
    iterate through a direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check if we have a neighbor of the opponent mark in the closest position.
    If we have not reached one of the borders of the game grid, and if there is an
    opponent mark in the position, we increase `neighbours`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We gather the marks we find during the iteration in `directionSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we reach one of the borders of the game grid, or if we find an empty position,
    we break the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find the player''s mark, we add the `directionSet` to the total set and
    break the iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do find the player''s mark or an empty position, we have found the opponent''s
    mark, and we add its position to the direction set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, the `main` function creates an application, shows the window, and
    executes the application until the user closes the window or selects the Exit
    menu item.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Noughts and Crosses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Noughts and Crosses application of this chapter is based on the version
    in the previous chapter. The difference is that in this version the computer plays
    against a human.
  prefs: []
  type: TYPE_NORMAL
- en: The NaCWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NaCWindow` class is similar to the `OthelloWindow` class in the previous
    section (NaC is an abbreviation for Noughts and Crosses). It adds two submenus
    to the game menu, where the computer or human makes the first move and selects
    a nought or cross:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWindow.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NaCWindow.cpp` file holds the definitions of the methods of the `NaCWindow` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWindow.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The title has been changed to `Noughts and Crosses Advanced`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The NaCWidget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NaCWidget` class has been improved compared to the version in the previous
    chapter. It holds the `calculateComputerMove` and `calculateMarkValue` methods
    for the computer to play against the human:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWidget.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NaCWidget.cpp` file holds the definitions of the methods of the `NaCWidget` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NaCWidget.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isComputerStartsNoughtEnabled`, `isComputerStartsCrossEnabled`, `isHumanStartsNoughtEnabled`,
    and `isHumanStartsCrossEnabled` methods decide whether to enable the `Computer
    Nought`, `Computer Cross`, `Human Nought`, and `Human cross` menu items. They
    are all enabled when there is no game in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onComputerStartsNought`, `onComputerStartsCross`, `onHumanStartsNought`,
    and `onHumanStartsCross` are called when the user selects the `Computer Noughts`,
    `Computer Cross`, `Human Noughts`, and `Human Cross` menu items. They set the
    game in progress, set the computer and human marks to nought and cross, and update
    the window. In cases where the computer makes the first move, it is placed in
    the middle of the game grid in order to use the game grid as effectively as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMark` method is called when the human player clicks an empty position
    in the game grid. We start by setting the mark to the position and updating the
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the human''s move did not cause them to win the game, we calculate the next
    move of the computer, set the position, check if the move has caused the computer
    to win the game, and update the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `drawMark` method is called when a position needs to be repainted. It is
    similar to its counterpart in the previous chapter. It draws a nought or a cross:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkWinner` method is also similar to its counterpart in the previous
    chapter. It decides if the latest move has caused five marks in a row. If it has,
    the winner is announced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `countMarks` method counts the number of marks in a row. It has been improved
    compared to its counterpart in the previous chapter. In this version, we also
    count the highest possible number of marks in a row that the move can lead to.
    Since `countMarks` is called by `calculateComputerMove`, we need to know how many
    marks in a row the move may lead to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `markCount` field holds the number of marks in a row that we would get
    if we placed our mark at the given position; `freeCount` holds the number of marks
    in a row we possibly can get if we continue to add marks in that row. The reason
    is that the computer will not add marks to a row that cannot become five in a
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the game grid in the given direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as we find the mark, we increase both `markCount` and `freeCount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find an empty position, we add `0.4` (since a free row is better than
    a closed row) to the `markCount`, and continue to increase the `freeCount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find neither the computer mark nor an empty position, we must have found
    the human''s mark, and we break the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of each iteration, we add the row and columns steps to the current
    row and column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We perform a similar iteration in the opposite direction. The only difference
    is that we subtract the row and columns steps at the end of each iteration, instead
    of adding to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If the free count is at least five, we return the mark count. If it is less
    than five, we return zero, since we cannot obtain five in a row in this direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `calculateComputerMove` method calculates the computer move that causes
    the maximum numbers of marks in a row. We count both the computer and human's
    rows, since we may be facing a situation where we need to stop the human from
    winning instead of maximizing the computer's chance to win.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `maxComputerValue` and `maxHumanValue` fields hold the maximum number of
    marks in a row that we have found so far. The `maxComputerList` and `maxHumanList`
    hold the position that causes the maximum number of marks in a row for the computer
    and the human:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the game grid. For each empty position, we try to set the
    computer and human mark and see how many marks in a row that would cause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the maximum number of marks in a row for the computer and human mark.
    If it is larger than the previous maximum number, we clear the list and add the
    position to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new number of marks in a row is greater than zero or equals the maximum
    number, we just add the position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same for the human mark as the computer mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we reset the position to the empty value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The computer or human must have at least one in a row for a position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the computer''s value is at least two and larger the human value, or if
    the human value is less the four, we randomly select one of the computer''s maximum
    moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the computer cannot make at least two in a row, or if the human
    is about to get five in a row, we randomly select one of the human''s maximum
    moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculateMarkValue` method calculates the maximum number of marks in a
    row that the given position may cause by calculating the larger value of its four
    directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the `main` function works at it always does in the Qt applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed more advanced versions of the games of the
    previous chapter. In both Othello and Noughts and Crosses, we have added code
    that lets the computer play against the human. In Othello, we looked for the position
    in the game grid that would cause the highest number of the opponent’s marks to
    be changed. In Noughts and Crosses, we searched for the move that gave the computer
    the highest possible number of marks in a row, preferably five in a row. However,
    we also had to search for the potential number of marks in a row for the opponent,
    and prevent their next move if it led to victory. Now, I suggest that you sit
    back and enjoy a couple of rounds with the computer before moving on to the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start developing a **Domain-Specific Language**
    (**DSL**), which is a language intended for a specific domain. We will develop
    a DSL for specifying the drawings of graphical objects, such as lines, rectangles,
    ellipses, and text, as well as the settings for color, font, pen and brush style,
    and alignment. We will also write a viewer that displays the graphical objects.
  prefs: []
  type: TYPE_NORMAL
