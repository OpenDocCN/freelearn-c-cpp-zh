- en: '*Chapter 6*: Extending the Preprocessor'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：扩展预处理器'
- en: 'In the previous chapter, we went through the structure of Clang—the official
    frontend of **Low-Level Virtual Machine (LLVM)** for C-family languages—and some
    of its most important components. We also introduced a variety of Clang''s tooling
    and extension options. In this chapter, we''re diving into the first phase in
    Clang''s frontend pipeline: the preprocessor.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Clang 的结构——C 家族语言的官方前端 **低级虚拟机 (LLVM)**，以及其中一些最重要的组件。我们还介绍了 Clang
    的各种工具和扩展选项。在这一章中，我们将深入 Clang 前端管道的第一个阶段：预处理器。
- en: For C-family programming languages, `#`) character—`#include` and `#define`,
    to name but a few—with some other textual contents (or non-textual *tokens*, in
    some rare cases). For example, the preprocessor will basically *copy and paste*
    contents of header files designated by the `#include` directive into the current
    compilation unit before parsing it. This technique has the advantage of extracting
    common code and reusing it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C 家族编程语言，`#`) 字符——例如 `#include` 和 `#define`——与一些其他文本内容（或某些罕见情况下的非文本 *令牌*）。例如，预处理器基本上会
    *复制和粘贴* 由 `#include` 指令指定的头文件的内容，在解析它之前将其放入当前编译单元中。这种技术的好处是提取常用代码并重用它。
- en: 'In this chapter, we will briefly explain how Clang''s `#pragma` syntax—such
    as that used by OpenMP (`#pragma omp loop`, for example) —in an easier way. Learning
    these techniques yields you more options when solving problems of different abstraction
    levels. Here is the list of sections in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要解释 Clang 的 `#pragma` 语法——例如 OpenMP 中使用的语法（例如 `#pragma omp loop`）——以更简单的方式。学习这些技术将在解决不同抽象层次的问题时为您提供更多选项。以下是本章各节的内容列表：
- en: Working with `SourceLocation` and `SourceManager`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `SourceLocation` 和 `SourceManager` 一起工作
- en: Learning preprocessor and lexer essentials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习预处理器和词法分析器的基础知识
- en: Developing custom preprocessor plugins and callbacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自定义预处理器插件和回调
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter expects you to have a build of the Clang executable. You can obtain
    this by running the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您有一个 Clang 可执行文件的构建。您可以通过运行以下命令来获取：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is a useful command to print textual content right after preprocessing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的命令，可以在预处理后打印文本内容：
- en: 'The `-E` command-line option for `clang` is pretty useful for printing textual
    content right after preprocessing. As an example, `foo.c` has the following content:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang` 的 `-E` 命令行选项在打印预处理后的文本内容方面非常有用。例如，`foo.c` 包含以下内容：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will give you this output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将给出以下输出：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, `HELLO` was replaced by `4` in the code. You might be able to
    use this trick to debug when developing custom extensions in later sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码中的 `HELLO` 被替换为 `4`。您可能可以使用这个技巧在后续章节开发自定义扩展时进行调试。
- en: 'Code used in this chapter can be found at this link: [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter06](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter06).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在以下链接找到：[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter06](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter06)。
- en: Working with SourceLocation and SourceManager
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 SourceLocation 和 SourceManager 一起工作
- en: 'When working closely with source files, one of the most fundamental questions
    is how a compiler frontend would be able to *locate* a piece of string in the
    file. On one hand, printing format messages well (compilation error and warning
    messages, for example) is a crucial job, in which accurate line and column numbers
    must be displayed. On the other hand, the frontend might need to manage multiple
    files at a time and access their in-memory content in an efficient way. In Clang,
    these questions are primarily handled by two classes: `SourceLocation` and `SourceManager`.
    We''re going to give you a brief introduction to them and show how to use them
    in practice in the rest of this section.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当与源文件紧密工作时，最基本的问题之一是编译器前端如何能够 *定位* 文件中的一段字符串。一方面，打印格式消息（例如编译错误和警告消息）是一项至关重要的工作，其中必须显示准确的行和列号。另一方面，前端可能需要同时管理多个文件，并以高效的方式访问它们的内存内容。在
    Clang 中，这些问题主要是由两个类 `SourceLocation` 和 `SourceManager` 处理的。我们将简要介绍它们，并在本节余下的部分展示如何在实践中使用它们。
- en: Introducing SourceLocation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 SourceLocation
- en: The `SourceLocation` class is used for representing the location of a piece
    of code in its file. When it comes to its implementation, using `SourceLocation`
    instances are *extensively* used in Clang's code base and basically live through
    the entire frontend compilation pipeline. Therefore, it's important to use a concise
    way to store its information rather than two 32-bit integers (and this might not
    even be sufficient since we also want to know the origin file!), which can easily
    bloat Clang's runtime-memory footprint.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`SourceLocation` 类用于表示代码片段在其文件中的位置。在其实施方面，`SourceLocation` 实例在 Clang 的代码库中被广泛使用，并且基本上贯穿整个前端编译管道。因此，使用简洁的方式存储其信息而不是两个
    32 位整数（这甚至可能不够，因为我们还想知道原始文件！）是很重要的，这可以轻易地增加 Clang 的运行时内存占用。'
- en: Clang solves this problem by using the elegantly designed `SourceLocation` as
    the `SourceLocation` only uses a single unsigned integer under the hood, which
    also means its instances are `SourceLocation` is merely a pointer, it will only
    be meaningful and useful when put side by side with the *data buffer* we just
    mentioned, which is managed by the second main character in this story, `SourceManager`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 通过优雅设计的 `SourceLocation` 解决了这个问题，因为 `SourceLocation` 只在底层使用单个无符号整数，这也意味着其实例仅仅是
    `SourceLocation` 的指针，它只有在与我们所提到的 *数据缓冲区* 放在一起时才有意义和有用，该缓冲区由故事中的第二位主要角色 `SourceManager`
    管理。
- en: Other useful utilities
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的工具
- en: '`SourceRange` is a pair of `SourceLocation` objects that represents the starting
    and ending of a source code range; `FullSourceLocation` encapsulates the normal
    `SourceLocation` class and its associated `SourceManager` class into one class
    so that you only need to carry a single `FullSourceLocation` instance instead
    of two objects (a `SourceLocation` object and a `SourceManager` object).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`SourceRange` 是一对表示源代码范围起始和结束的 `SourceLocation` 对象；`FullSourceLocation` 将正常的
    `SourceLocation` 类及其关联的 `SourceManager` 类封装到一个类中，这样你只需要携带一个 `FullSourceLocation`
    实例而不是两个对象（一个 `SourceLocation` 对象和一个 `SourceManager` 对象）。'
- en: Trivially copyable
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单可复制
- en: We were usually taught that unless there is a good reason, you should avoid
    passing an object by its value (as a function call argument, for example) in normal
    situations when writing C++. Since it involves lots of *copying* on the data members
    under the hood, you should pass by pointers or references instead. However, if
    carefully designed, a class type instance can be copied back and forth without
    lots of effort—for example, a class with no member variable or few member variables,
    plus a default copy constructor. If an instance is trivially copyable, you're
    encouraged to pass it by its value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常被教导，除非有充分的理由，否则在编写 C++ 时，你应该避免在正常情况下通过值传递对象（例如作为函数调用参数）。因为这涉及到底层数据成员的大量
    *复制*，你应该通过指针或引用来传递。然而，如果设计得很好，一个类类型实例可以轻松地来回复制，例如，没有成员变量或只有少量成员变量的类，加上默认的复制构造函数。如果一个实例是简单可复制的，你被鼓励通过其值来传递它。
- en: Introducing SourceManager
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 SourceManager
- en: 'The `SourceManager` class manages all of the source files stored inside the
    memory and provides interfaces to access them. It also provides APIs to deal with
    source code locations, via `SourceLocation` instances we just introduced. For
    example, to get the line and column number from a `SourceLocation` instance, run
    the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`SourceManager` 类管理存储在内存中的所有源文件，并提供访问它们的接口。它还提供了通过我们刚刚介绍的 `SourceLocation`
    实例处理源代码位置的 API。例如，要从 `SourceLocation` 实例获取行号和列号，请运行以下代码：'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Line` and `Column` variables in the preceding code snippet are the line
    and column number of the source location pointed by `SLoc`, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的 `Line` 和 `Column` 变量分别是 `SLoc` 所指向的源位置行号和列号。
- en: You might wonder why we are using the term `spellingLineNumber` instead of just
    `LineNumber` in the preceding code snippet. It turns out that in the cases of
    macro expansion (or any expansion happening during preprocessing), Clang keeps
    track of the macro content's `SourceLocation` instance before and after the expansion.
    A spelling location represents the location where the source code was originally
    *written*, whereas an expansion location is where the macro is expanded.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们在上一段代码片段中使用 `spellingLineNumber` 而不是简单的 `LineNumber`。结果是，在宏展开（或在预处理期间发生的任何展开）的情况下，Clang
    在展开前后跟踪宏内容的 `SourceLocation` 实例。拼写位置表示源代码最初被 *编写* 的位置，而展开位置是宏被展开的位置。
- en: 'You can also create a new spelling and expansion association using the following
    API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下 API 创建新的拼写和扩展关联：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The returned `NewSLoc` is now associated with both the spelling and expanded
    locations that can be queried using `SourceManager`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `NewSLoc` 现在关联了拼写和扩展位置，可以使用 `SourceManager` 进行查询。
- en: These are the important concepts and APIs that will help you dealing with source
    code locations— especially when working with the preprocessor—in later chapters.
    The next section will give you some background on preprocessor and lexer development
    in Clang, which will be useful when working on the project in the later, *Developing
    custom preprocessor plugins and callbacks* section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是帮助您处理源代码位置的重要概念和 API，尤其是在后续章节中与预处理器一起工作时。下一节将为您介绍 Clang 中预处理器和词法分析器开发的一些背景知识，这对于在后续的“开发自定义预处理器插件和回调”部分工作将很有用。
- en: Learning preprocessor and lexer essentials
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习预处理器和词法分析器的基础知识
- en: In the previous, *Working with SourceLocation and SourceManager* section, we've
    learned how source locations, which are an important part of the preprocessor,
    are represented in Clang. In this section, we will first explain the principle
    of Clang's preprocessor and lexer, along with their working flow. Then, we'll
    go into some of the important components in this flow and briefly explain their
    usage in the code. These will also prepare you for the project in the, *Developing
    custom preprocessor plugins and callbacks* section later in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的“使用 SourceLocation 和 SourceManager”部分，我们学习了源位置，它是预处理器的一个重要部分，在 Clang 中的表示方式。在本节中，我们将首先解释
    Clang 预处理器和词法分析器的原理，以及它们的工作流程。然后，我们将深入探讨这个流程中的一些重要组件，并简要说明它们在代码中的使用。这些内容也将为您在本书后面的“开发自定义预处理器插件和回调”部分的项目做好准备。
- en: Understanding the role of the preprocessor and lexer in Clang
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解预处理器和词法分析器在 Clang 中的作用
- en: 'The roles and primary actions performed by Clang''s preprocessor and lexer,
    represented by the `Preprocessor` and `Lexer` classes respectively, are illustrated
    in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 的预处理器和词法分析器（分别由 `Preprocessor` 和 `Lexer` 类表示）所扮演的角色和执行的主要操作，如下面的图所示：
- en: '![Figure 6.1 – Role of the Clang preprocessor and lexer'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – Clang 预处理器和词法分析器的角色'
- en: '](img/Figure_6.01_B14590.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.01_B14590.jpg)'
- en: Figure 6.1 – Role of the Clang preprocessor and lexer
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Clang 预处理器和词法分析器的角色
- en: We believe most readers here will be familiar with the concept of a **token**
    in the context of the lexer—a substring from the original source code that acts
    as the minimum building block for semantic reasoning. In some of the traditional
    compilers, the lexer is responsible for chopping the input source code into a
    sequence of tokens or a **token stream**, as shown in the preceding diagram. This
    token stream will later be fed into the parser to construct the semantic structure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信大多数读者都会熟悉在词法分析器上下文中“标记”的概念——原始源代码的一个子串，它作为语义推理的最小构建块。在一些传统的编译器中，词法分析器负责将输入源代码切割成一系列标记或标记流，如前图所示。这个标记流随后将被送入解析器以构建语义结构。
- en: 'Implementation-wise, Clang takes a slightly different path from traditional
    compilers (or those from textbooks): `Lexer`, employed by `Preprocessor`, is still
    the primary performer to cut source code into tokens. However, `Lexer` keeps its
    hands off whenever encountering a preprocessor directive (that is, anything that
    starts with a `#`) or a symbol, and relays that task to either the macro expansion,
    the header file resolver, or pragma handlers that are organized by the `Preprocessor`.
    These assisting components inject extra tokens, if needed, into the main token
    stream, which would eventually be returned back to the user of `Preprocessor`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，Clang 与传统的编译器（或教科书中的编译器）采取了一条略有不同的路径：`Preprocessor` 使用的 `Lexer` 仍然是将源代码切割成标记的主要执行者。然而，当遇到预处理器指令（即以
    `#` 开头的任何内容）或符号时，`Lexer` 会停止操作，并将该任务转交给 `Preprocessor` 组织的宏扩展、头文件解析器或预处理指令处理器。这些辅助组件在需要时向主标记流中注入额外的标记，这些标记最终会返回给
    `Preprocessor` 的用户。
- en: 'In other words, most consumers of the token stream don''t directly interact
    with `Lexer`, but with the `Preprocessor` instances. This makes people call the
    `Lexer` class a *raw* lexer (as shown in the previous diagram), since `Lexer`
    by itself only generates a token stream that hasn''t been preprocessed. To give
    you a more concrete idea of how to use `Preprocessor` to retrieve a token (stream),
    the following simple code snippet has been provided. This shows a way to get the
    next token from the source code currently processing it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，大多数标记流消费者并不直接与 `Lexer` 交互，而是与 `Preprocessor` 实例交互。这使得人们将 `Lexer` 类称为 *原始*
    lexer（如前图所示），因为 `Lexer` 本身只生成未经预处理的标记流。为了给您一个更具体的使用 `Preprocessor` 来检索标记（流）的例子，以下简单的代码片段已经提供。这显示了从当前正在处理的源代码中获取下一个标记的方法：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you might have guessed, `Token` is the class representing a single token
    in Clang, which we're going to introduce shortly in the next paragraph.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，`Token` 是 Clang 中表示单个标记的类，我们将在下一段落中简要介绍。
- en: Understanding Token
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解标记
- en: The `Token` class is the representation of a single token, either from the source
    code or a *virtual* one that served a special purpose. It is also used extensively
    by the preprocessing/lexing framework, just like `SourceLocation` that we introduced
    earlier. Thus, it is designed to be very concise in memory and trivially copyable
    as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Token` 类是单个标记的表示，无论是来自源代码的还是具有特殊用途的 *虚拟* 标记。它也被预处理/词法分析框架广泛使用，就像我们之前介绍的 `SourceLocation`
    一样。因此，它被设计得在内存中非常简洁，并且可以轻易地复制。'
- en: 'For the `Token` class, there are two things we want to highlight here, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Token` 类，这里有两点我们想要强调，如下所述：
- en: '**Token kind** tells you what this token is.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记类型**告诉您这个标记是什么。'
- en: '`IdentifierInfo` class to carry extra identifier information, which we''re
    going to cover later in this section.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IdentifierInfo` 类用于携带额外的标识符信息，这部分内容我们将在本节稍后进行介绍。'
- en: Token kind
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记类型
- en: 'The token kind tells you *what* this `Token` is. Clang''s `Token` is designed
    to represent not just concrete, physical-language constructions such as keywords
    and symbols, but also virtual concepts that are inserted by the parser in order
    to encode as much information as possible using a single `Token`. To visualize
    the token stream''s token kinds, you can use the following command-line option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 标记类型告诉您这个 `Token` 是什么。Clang 的 `Token` 被设计用来表示不仅仅是具体的、物理语言结构，如关键字和符号，还包括解析器插入的虚拟概念，以便使用单个
    `Token` 尽可能地编码尽可能多的信息。为了可视化标记流中标记的类型，您可以使用以下命令行选项：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`foo.cc` has the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo.cc` 包含以下内容：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the output of the preceding command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面命令的输出：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The highlighted parts are the token kinds for each token. The full list of token
    kinds can be found in `clang/include/clang/Basic/TokenKinds.def`. This file is
    a useful reference to know the mapping between any language construction (for
    example, the `return` keyword) and its token kind counterpart (`kw_return`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分是每个标记的标记类型。完整的标记类型列表可以在 `clang/include/clang/Basic/TokenKinds.def` 文件中找到。这个文件是了解任何语言结构（例如，`return`
    关键字）与其标记类型对应（`kw_return`）之间映射的有用参考。
- en: 'Although we can''t visualize the virtual tokens—or `::` (the `coloncolon` token
    kind in the preceding directive) has several different usages. For example, it
    can either be for namespace resolution (more formally called *scope resolution*
    in *C++*), as shown in the code snippet earlier, or it can be (optionally) used
    with the `new` and `delete` operators, as illustrated in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们无法可视化虚拟标记——或者 `::`（在前面指令中称为 `coloncolon` 的标记类型）有几种不同的用法。例如，它可以用于命名空间解析（在
    *C++* 中更正式地称为 *作用域解析*），如前面代码片段所示，或者它可以（可选地）与 `new` 和 `delete` 操作符一起使用，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To make the parsing processing more efficient, the parser will first try to
    resolve whether the `coloncolon` token is a scope resolution or not. If it is,
    the token will be replaced by an `annot_cxxscope` annotation token.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使解析处理更高效，解析器将首先尝试解决 `coloncolon` 标记是否是作用域解析。如果是，则标记将被替换为 `annot_cxxscope`
    注解标记。
- en: 'Now, let''s see the API to retrieve the token kind. The `Token` class provides
    a `getKind` function to retrieve its token kind, as illustrated in the following
    code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看检索标记类型的 API。`Token` 类提供了一个 `getKind` 函数来检索其标记类型，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, if you''re only doing checks, just like in the preceding snippet,
    a more concise function is available, as illustrated here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您只是进行检查，就像前面的代码片段一样，有一个更简洁的函数可用，如下所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Though many times, knowing the token kind of a `Token` is sufficient for processing,
    some language structures require more evidence to judge (for example, tokens that
    represent a function name, in which case the token kind, `identifier`, is not
    as important as the name string). Clang uses a specialized class, `IdentifierInfo`,
    to carry extra information such as the symbol name for any identifier in the language,
    which we're going to cover in the next paragraph.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很多时候，知道`Token`的类型就足以进行处理，但某些语言结构需要更多的证据来判断（例如，代表函数名的标记，在这种情况下，标记类型`identifier`并不像名称字符串那样重要）。Clang使用一个专门的类`IdentifierInfo`来携带有关任何标识符的额外信息，我们将在下一段中介绍。
- en: Identifier
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符
- en: 'Standard C/C++ uses the word `Token` that fit into the language''s standard
    definition of an identifier with an auxiliary `IdentifierInfo` object. This object
    encloses properties such as the underlying string content or whether this identifier
    is associated with a macro function. Here is how you would retrieve the `IdentifierInfo`
    instance from a `Token` type variable `Tok`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C/C++使用`Token`这个词，它符合语言对标识符的标准定义，并辅以`IdentifierInfo`对象。此对象包含诸如底层字符串内容或此标识符是否与宏函数相关联等属性。以下是从`Token`类型变量`Tok`检索`IdentifierInfo`实例的方法：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding `getIdentifierInfo` function returns null if `Tok` is not representing
    an identifier by the language standard's definition. Note that if two identifiers
    have the *same textual content*, they are represented by the same `IdentifierInfo`
    object. This comes in handy when you want to compare whether different identifier
    tokens have the same textual contents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`getIdentifierInfo`函数如果`Tok`不是按照语言标准的定义表示标识符时将返回null。请注意，如果两个标识符具有相同的文本内容，它们将由相同的`IdentifierInfo`对象表示。这在您想要比较不同的标识符标记是否具有相同的文本内容时非常有用。
- en: 'Using a dedicated `IdentifierInfo` type on top of various token kinds has the
    following advantages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种标记类型之上使用专门的`IdentifierInfo`类型有以下优点：
- en: For a `Token` with an `identifier` token kind, we sometimes want to know if
    it has been associated with a macro. You can find this out with the `IdentifierInfo::hasMacroDefinition`
    function.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有`identifier`标记类型的`Token`，我们有时想知道它是否与宏相关联。您可以使用`IdentifierInfo::hasMacroDefinition`函数来找出这一点。
- en: For a token with an `identifier` token kind, storing underlying string content
    in auxiliary storage (that is, the `IdentifierInfo` object) can save a `Token`
    object's memory footprint, which is on the hot path of the frontend. You can retrieve
    the underlying string content with the `IdentifierInfo::getName` function.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有`identifier`标记类型的标记，将底层字符串内容存储在辅助存储（即`IdentifierInfo`对象）中可以节省`Token`对象的内存占用，这在前端的热路径上。您可以使用`IdentifierInfo::getName`函数检索底层字符串内容。
- en: 'For a `Token` that represents language keywords, though the framework already
    provides dedicated token kinds for these sorts of tokens (for example, `kw_return`
    for the `return` keyword), some of these tokens only become language keywords
    in later language standards. For example, the following snippet is legal in standards
    before C++11:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于代表语言关键字的`Token`，尽管框架已经为这些类型的标记提供了专门的标记类型（例如，`kw_return`用于`return`关键字），但其中一些标记只有在后来的语言标准中才成为语言关键字。例如，以下代码片段在C++11之前的标准中是合法的：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You could compile it with the following command:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令进行编译：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the next sub-section, we''re going to introduce the last important `Preprocessor`
    concept of this section: how `Preprocessor` handles *macros* in C-family languages.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将介绍本节最后一个重要的`Preprocessor`概念：`Preprocessor`如何处理C系列语言的`macros`。
- en: Handling macros
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理宏
- en: 'Implementations for **macros** of C-family languages are non-trivial. In addition
    to challenges on source locations as we introduced earlier—how do we carry source
    locations of both the macro definitions and the place they''re expanded—the ability
    to re-define and undefine a macro name complicates the whole story. Have a look
    at the following code snippet for an example of this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: C系列语言的宏实现非同寻常。除了我们之前介绍过的源位置挑战——如何携带宏定义及其展开位置的双重源位置——能够重新定义和取消定义宏名称的能力使得整个问题更加复杂。以下是一个示例代码片段：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding C code showed that the definition of `FOO` (if `FOO` is defined)
    varies on different lexical locations (different lines).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 C 代码显示，`FOO` 的定义（如果已定义）在不同词法位置（不同行）上有所不同。
- en: Local versus Module macros
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本地宏与模块宏的区别
- en: C++20 has introduced a new language concept called `export`. We only cover local
    macros in this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了一个新的语言概念，称为 `export`。本书中我们只涵盖局部宏。
- en: 'To model this concept, Clang has constructed a system to record the chain of
    definitions and un-definitions. Before explaining how it works, here are three
    of the most important components of this system:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个概念，Clang 构建了一个系统来记录定义和取消定义的链。在解释其工作原理之前，以下是该系统最重要的三个组件：
- en: '`MacroDirective`: This class is the logical representation of a `#define` or
    a `#undef` *statement* of a given macro identifier. As shown in the preceding
    code example, there can be multiple `#define` (and `#undef`) statements on the
    same macro identifier, so eventually these `MacroDirective` objects will form
    a chain ordered by their lexical appearances. To be more specific, the `#define`
    and `#undef` directives are actually represented by subclasses of `MacroDirective`,
    `DefMacroDirective`, and `UndefMacroDirective`, respectively.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MacroDirective`：此类是给定宏标识符的 `#define` 或 `#undef` *语句*的逻辑表示。如前代码示例所示，同一个宏标识符上可以有多个
    `#define`（和 `#undef`）语句，因此最终这些 `MacroDirective` 对象将形成一个按其词法出现顺序排列的链。更具体地说，`#define`
    和 `#undef` 指令实际上分别由 `MacroDirective` 的子类 `DefMacroDirective` 和 `UndefMacroDirective`
    表示。'
- en: '`MacroDefinition`: This class represents the *definition* of a macro identifier
    at the current time point. Rather than containing the full macro definition body,
    this instance is more like a pointer pointing to different macro bodies, which
    are represented by the `MacroInfo` class that will be introduced shortly, upon
    resolving a different `MacroDirective` class. This class can also tell you the
    (latest) `DefMacroDirective` class that defines this `MacroDefinition` class.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MacroDefinition`：此类代表当前时间点宏标识符的*定义*。而不是包含完整的宏定义体，此实例更像是一个指针，指向不同的宏体，这些宏体将由稍后介绍的
    `MacroInfo` 类表示，在解析不同的 `MacroDirective` 类时。此类还可以告诉你定义此 `MacroDefinition` 类的（最新）`DefMacroDirective`
    类。'
- en: '`MacroInfo`: This class contains the body, including tokens in the body and
    macro arguments (if any) of a macro definition.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MacroInfo`：此类包含宏定义的体，包括体中的标记和宏参数（如果有）。'
- en: 'Here is a diagram illustrating the relationship of these classes in regard
    to the sample code earlier:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个图解，说明了这些类与前面示例代码之间的关系：
- en: '![Figure 6.2 – How different C++ classes for a macro are related to the previous
    code example'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 不同 C++ 宏类与前面代码示例的关系'
- en: '](img/Figure_6.02_B14590.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B14590.jpg)'
- en: Figure 6.2 – How different C++ classes for a macro are related to the previous
    code example
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 不同 C++ 宏类与前面代码示例的关系
- en: 'To retrieve the `MacroInfo` class and its `MacroDefinition` class, we can use
    the following `Preprocessor` APIs, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索 `MacroInfo` 类及其 `MacroDefinition` 类，我们可以使用以下 `Preprocessor` API，如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `IdentifierInfo` type argument, `MacroII`, shown in the preceding code
    snippet, represents the macro name. To further examine the macro body, run the
    following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentifierInfo` 类型参数 `MacroII`，如前代码片段所示，代表宏名称。要进一步检查宏体，请运行以下代码：'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From this section, you''ve learned the working flow of `Preprocessor`, as well
    as two important components: the `Token` class and the sub-system that handles
    macros. Learning these two gives you a better picture of how Clang''s preprocessing
    works and prepares you for the `Preprocessor` plugin and custom callbacks development
    in the next section.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节中，你已经了解了 `Preprocessor` 的工作流程，以及两个重要组件：`Token` 类和负责宏的子系统。学习这两个组件将帮助你更好地理解
    Clang 的预处理工作方式，并为下一节中 `Preprocessor` 插件和自定义回调函数的开发做好准备。
- en: Developing custom preprocessor plugins and callbacks
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义预处理器插件和回调函数
- en: As flexible as other parts of LLVM and Clang, Clang's preprocessing framework
    also provides a way to insert custom logic via plugins. More specifically, it
    allows developers to write plugins to handle custom `#pragma my_awesome_feature`).
    In addition, the `Preprocessor` class also provides a more general way to define
    custom callback functions in reaction to arbitrary `#include` directive is resolved,
    to name but a couple of examples. In this section, we're going to use a simple
    project that leverages both techniques to demonstrate their usage.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LLVM 和 Clang 的其他部分一样灵活，Clang 的预处理框架也提供了一种通过插件插入自定义逻辑的方法。更具体地说，它允许开发者编写插件来处理自定义
    `#pragma my_awesome_feature`)。此外，`Preprocessor` 类还提供了一个更通用的方法来定义在任意 `#include`
    指令被解析时触发的自定义回调函数，仅举几个例子。在本节中，我们将使用一个简单项目来利用这两种技术来演示它们的用法。
- en: The project goal and preparation
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目目标和准备
- en: 'Macros in C/C++ have always been notorious for poor *design hygiene* that could
    easily lead to coding errors when used without care. Have a look at the following
    code snippet for an example of this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中的宏一直因其糟糕的 *设计卫生* 而臭名昭著，如果不小心使用，很容易导致编码错误。看看以下代码片段，看看这个例子：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`PRINT` in the preceding code snippet looks just like a normal function, thus
    it''s easy to believe that this program will print out `8`. However, `PRINT` is
    a macro function rather than a normal function, so when it''s expanded, the `main`
    function is equivalent to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段中的 `PRINT` 看起来就像一个普通函数，因此很容易相信这个程序将打印出 `8`。然而，`PRINT` 是一个宏函数而不是普通函数，所以当它展开时，`main`
    函数相当于以下内容：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Therefore, the program actually prints `7`. This ambiguity can of course be
    solved by wrapping every occurrence of the `val` macro argument in the macro body
    with parenthesis, as illustrated in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上程序打印的是 `7`。当然，可以通过将宏体中 `val` 宏参数的每个出现都用括号括起来来解决这个问题，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Therefore, after macro expansion, the `main` function will look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在宏展开后，`main` 函数将看起来像这样：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The project we''re going to do here is to develop a custom `#pragma` syntax
    to warn developers if a certain macro argument, designated by programmers, is
    not properly enclosed in parentheses, for the sake of preventing the preceding
    *hygiene* problems from happening. Here is an example of this new syntax:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的项目是开发一个自定义的 `#pragma` 语法，以警告开发者如果某个由程序员指定的宏参数没有被正确地用括号包围，从而防止前面提到的 *卫生*
    问题发生。以下是这个新语法的示例：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similar to previous example, if an occurrence of the preceding `val` argument
    is not enclosed in parentheses, this might introduce potential bugs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，如果前面 `val` 参数的出现没有被括号包围，这可能会引入潜在的错误。
- en: 'In the new `macro_arg_guard` pragma syntax, tokens following the pragma name
    are the macro argument names to check in the next macro function. Since `val`
    in the `val * 94` expression from the preceding code snippet is not enclosed in
    parentheses, it will print the following warning message:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `macro_arg_guard` 预处理指令语法中，紧跟在指令名称后面的标记是下一个宏函数中要检查的宏参数名称。由于前一个代码片段中的 `val
    * 94` 表达式中的 `val` 没有被括号包围，它将打印以下警告信息：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This project, albeit being a *toy example*, is actually pretty useful when the
    macro function becomes pretty big or complicated, in which case manually adding
    parentheses on *every* macro argument occurrence might be an error-prone task.
    A tool to catch this kind of mistake would definitely be helpful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目，尽管是一个 *玩具示例*，但在宏函数变得相当大或复杂时实际上非常有用，在这种情况下，手动在每个宏参数出现处添加括号可能是一个容易出错的任务。一个能够捕捉这种错误的工具肯定会很有帮助。
- en: 'Before we dive into the coding part, let''s set up the project folder. Here
    is the folder structure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入编码部分之前，让我们设置项目文件夹。以下是文件夹结构：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `MacroGuardPragama.cpp` file includes a custom `PragmaHandler` function,
    which we're going to cover in the next section, *Implementing a custom pragma
    handler*. For `MacroGuardValidator.h/.cpp`, this includes a custom `PPCallbacks`
    function used to check if the designated macro body and arguments conform to our
    rules here. We will introduce this in the later, *Implementing custom preprocessor
    callbacks* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`MacroGuardPragama.cpp` 文件包含一个自定义的 `PragmaHandler` 函数，我们将在下一节中介绍，*实现自定义预处理指令处理器*。对于
    `MacroGuardValidator.h/.cpp`，这包括一个自定义的 `PPCallbacks` 函数，用于检查指定的宏体和参数是否符合我们这里的规则。我们将在后面的
    *实现自定义预处理器回调函数* 部分介绍。'
- en: 'Since we''re setting up an out-of-tree project here, please refer to the *Understanding
    CMake integration for out-of-tree projects* section of [*Chapter 2*](B14590_02_Final_JC_ePub.xhtml#_idTextAnchor029),
    *Exploring LLVM''s Build System Features*, in case you don''t know how to import
    LLVM''s own CMake directives (such as the `add_llvm_library` and `add_llvm_executable`
    CMake functions). And because we''re also dealing with Clang here, we need to
    use a similar way to import Clang''s build configurations, such as the `include`
    folder path shown in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里设置的是一个树外项目，如果你不知道如何导入 LLVM 自身的 CMake 指令（例如 `add_llvm_library` 和 `add_llvm_executable`
    CMake 函数），请参阅 [*第 2 章*](B14590_02_Final_JC_ePub.xhtml#_idTextAnchor029) 的 *理解树外项目的
    CMake 集成* 部分，*探索 LLVM 的构建系统功能*。并且因为我们在这里也处理 Clang，我们需要使用类似的方法来导入 Clang 的构建配置，如下面的代码片段中所示的
    `include` 文件夹路径：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The reason we don't need to set up Clang's library path here is because normally,
    plugins will dynamically link against libraries' implementations provided by the
    loader program (in our case, the `clang` executable) rather than linking those
    libraries explicitly during build time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要设置 Clang 的库路径，是因为通常情况下，插件会动态链接到由加载程序（在我们的例子中是 `clang` 可执行文件）提供的库实现，而不是在构建时显式链接这些库。
- en: 'Finally, we''re adding the plugin''s build target, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了插件的构建目标，如下所示：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The PLUGIN_TOOL argument
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PLUGIN_TOOL 参数
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After setting up the `CMake` script and building the plugin, you can use the
    following command to run the plugin:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 `CMake` 脚本并构建插件后，你可以使用以下命令来运行插件：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, we haven't currently written any code, so nothing is printed out.
    In the next section, we will first develop a custom `PragmaHandler` instance to
    implement our new `#pragma macro_arg_guard` syntax.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们目前还没有编写任何代码，所以没有输出任何内容。在下一节中，我们将首先开发一个自定义的 `PragmaHandler` 实例来实现我们的新 `#pragma
    macro_arg_guard` 语法。
- en: Implementing a custom pragma handler
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义的预处理指令处理器
- en: 'The first step of implementing the aforementioned features is to create a custom
    `#pragma` handler. To do so, we first create a `MacroGuardHandler` class that
    derives from the `PragmaHandler` class inside the `MacroGuardPragma.cpp` file,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实现上述功能的第一步是创建一个自定义的 `#pragma` 处理器。为此，我们首先在 `MacroGuardPragma.cpp` 文件中创建一个从 `PragmaHandler`
    类派生的 `MacroGuardHandler` 类，如下所示：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `HandlePragma` callback function will be invoked whenever the `Preprocessor`
    encounters a non-standard pragma directive. We''re going to do two things in this
    function, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Preprocessor` 遇到非标准预处理指令时，将调用 `HandlePragma` 回调函数。在这个函数中，我们将做两件事，如下所示：
- en: Retrieve any supplement tokens—treated as the `macro_arg_guard`).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取任何补充标记——被视为 `macro_arg_guard`）。
- en: Register a `PPCallbacks` instance that scans the body of the next macro function
    definition to see if specific macro arguments are properly enclosed by parentheses
    in there. We will outline the details of this task next.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个 `PPCallbacks` 实例，该实例将扫描下一个宏函数定义的主体，以查看特定的宏参数是否被正确地用括号封装。我们将在下一节中概述这个任务的细节。
- en: 'For the first task, we are leveraging `Preprocessor` to help us parse the pragma
    arguments, which are macro argument names to be enclosed. When `HandlePragma`
    is called, the `Preprocessor` is stopped at the place right after the pragma name
    token, as illustrated in the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个任务，我们正在利用 `Preprocessor` 来帮助我们解析要封装的宏参数，即宏参数名称。当调用 `HandlePragma` 时，`Preprocessor`
    将在宏名称标记之后立即停止，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So, all we need to do is keep lexing and storing those tokens until hitting
    the end of this line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所需做的只是继续解析和存储这些标记，直到遇到这一行的末尾：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `eod` token kind in the preceding code snippet means **end of directive**.
    It is exclusively used to mark the end of a preprocessor directive.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的 `eod` 标记类型表示 **指令结束**。它专门用于标记预处理器指令的结束。
- en: 'For the `ArgsToEscped` variable, the following global array stores the designated
    macro argument''s `IdentifierInfo` objects:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ArgsToEscped` 变量，以下全局数组存储了指定的宏参数的 `IdentifierInfo` 对象：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The reason we're declaring `ArgsToEnclosed` in a global scope is that we're
    using it to *communicate* with our `PPCallbacks` instance later, which will use
    that array content to perform the validations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在全局范围内声明 `ArgsToEnclosed` 的原因是，我们稍后需要用它来与我们的 `PPCallbacks` 实例进行通信，该实例将使用该数组内容来执行验证。
- en: 'Though the implementation details of our `PPCallbacks` instance, the `MacroGuardValidator`
    class, will not be covered until the next section, it needs to be registered with
    the `Preprocessor` when the `HandlePragma` function is called for the first time,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的`PPCallbacks`实例，即`MacroGuardValidator`类的实现细节将在下一节中介绍，但它需要在第一次调用`HandlePragma`函数时与`Preprocessor`注册，如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We also use a flag to make sure it is only registered once. After this, whenever
    a preprocessing event happens, our `MacroGuardValidator` class will be invoked
    to handle it. In our case, we are only interested in the `macro definition` event,
    which signals to `MacroGuardValidator` to validate the macro body that it just
    defined.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用一个标志来确保它只注册一次。在此之后，每当发生预处理事件时，我们的`MacroGuardValidator`类将被调用以处理它。在我们的情况下，我们只对`宏定义`事件感兴趣，这会向`MacroGuardValidator`发出信号以验证它刚刚定义的宏体。
- en: 'Before wrapping up on `PragmaHandler`, we need some extra code to transform
    the handler into a plugin, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束`PragmaHandler`之前，我们需要一些额外的代码将处理程序转换为插件，如下所示：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After declaring this variable, when this plugin is loaded into `clang`, a `MacroGuardHandler`
    instance is inserted into a global `PragmaHandler` registry, which will be queried
    by the `Preprocessor` whenever it encounters a non-standard `#pragma` directive.
    Now, Clang is able to recognize our custom `macro_arg_guard` pragma when the plugin
    is loaded.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明这个变量之后，当这个插件被加载到`clang`中时，一个`MacroGuardHandler`实例被插入到一个全局的`PragmaHandler`注册表中，该注册表将在`Preprocessor`遇到非标准的`#pragma`指令时被查询。现在，当插件加载时，Clang能够识别我们的自定义`macro_arg_guard`指令。
- en: Implementing custom preprocessor callbacks
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义预处理器回调
- en: '`Preprocessor` provides a set of callbacks, the `PPCallbacks` class, which
    will be triggered when certain preprocessor events (such as a macro being expanded)
    happen. The previous, *Implementing a custom pragma handler* section, showed you
    how to register your own `PPCallbacks` implementations, the `MacroGuardValidator`,
    with `Preprocessor`. Here, we''re going to show you how `MacroGuardValidator`
    validates the macro argument-escaping rule in macro functions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Preprocessor`提供了一组回调，`PPCallbacks`类，当某些预处理器事件（例如宏展开）发生时将被触发。前面的*实现自定义指令处理程序*部分展示了如何将你自己的`PPCallbacks`实现，即`MacroGuardValidator`，注册到`Preprocessor`。在这里，我们将展示`MacroGuardValidator`如何验证宏函数中的宏参数逃逸规则。'
- en: 'First, in `MacroGuardValidator.h/.cpp`, we put the following skeleton:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`MacroGuardValidator.h/.cpp`中，我们放入以下骨架：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Among all the callback functions in `PPCallbacks`, we're only interested in
    `MacroDefined`, which will be invoked when a macro definition is processed, represented
    by the `MacroDirective` type function argument (`MD`). The `SourceManager` type
    member variable (`SM`) is used for printing `SourceLocation` when we need to show
    some warning messages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PPCallbacks`中的所有回调函数中，我们只对`MacroDefined`感兴趣，当处理宏定义时将被调用，由`MacroDirective`类型函数参数（`MD`）表示。`SourceManager`类型成员变量（`SM`）用于在需要显示一些警告消息时打印`SourceLocation`。
- en: 'Focusing on `MacroGuardValidator::MacroDefined`, the logic here is pretty simple:
    for each identifier in the `ArgsToEnclosed` array, we''re scanning macro body
    tokens to check if its occurrences have parentheses as its predecessor and successor
    tokens. First, let''s put in the loop''s skeleton, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于`MacroGuardValidator::MacroDefined`，这里的逻辑相当简单：对于`ArgsToEnclosed`数组中的每个标识符，我们正在扫描宏体标记以检查其出现是否有括号作为其前驱和后继标记。首先，让我们放入循环的骨架，如下所示：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If a macro body token''s `IdentifierInfo` argument matches `ArgII`, this means
    there is a macro argument occurrence, and we check that token''s previous and
    next tokens, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果宏体标记的`IdentifierInfo`参数匹配`ArgII`，这意味着存在一个宏参数出现，我们将检查该标记的前一个和下一个标记，如下所示：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Uniqueness of `IdentifierInfo` instances
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentifierInfo`实例的唯一性'
- en: Recall that same identifier strings are always represented by the same `IdentifierInfo`
    object. That's the reason we can simply use pointer comparison here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，相同的标识符字符串总是由相同的`IdentifierInfo`对象表示。这就是我们为什么可以在这里简单地使用指针比较的原因。
- en: The `MacroInfo::tokens_begin` function returns an iterator pointing to the beginning
    of an array carrying all the macro body tokens.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`MacroInfo::tokens_begin`函数返回一个迭代器，指向包含所有宏体标记的数组的开始。'
- en: 'Finally, we print a warning message if the macro argument token is not enclosed
    by parentheses, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果宏参数标记没有被括号包围，我们打印一条警告消息，如下所示：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And that's all for this section. You're now able to develop a `PragmaHandler`
    plugin that can be dynamically loaded into Clang to handle custom `#pragma` directives.
    You've also learned how to implement `PPCallbacks` to insert custom logic whenever
    a preprocessor event happens.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容到此结束。你现在可以开发一个可以动态加载到 Clang 中以处理自定义 `#pragma` 指令的 `PragmaHandler` 插件。你还学会了如何实现
    `PPCallbacks` 以便在预处理程序事件发生时插入自定义逻辑。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The preprocessor and lexer mark the beginning of a frontend. The former replaces
    preprocessor directives with other textual contents, while the latter cuts source
    code into more meaningful tokens. In this chapter, we've learned how these two
    components cooperate with each other to provide a single view of token streams
    to work on in later stages. In addition, we've also learned about various important
    APIs—such as the `Preprocessor` class, the `Token` class, and how macros are represented
    in Clang—that can be used for the development of this part, especially for creating
    handler plugins to support custom `#pragma` directives, as well as creating custom
    preprocessor callbacks for deeper integration with preprocessing events.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理程序和词法分析器标志着前端的开端。前者将预处理程序指令替换为其他文本内容，而后者将源代码切割成更有意义的标记。在本章中，我们学习了这两个组件如何相互协作以提供单个标记流视图，以便在后续阶段进行工作。此外，我们还了解了各种重要的
    API，例如 `Preprocessor` 类、`Token` 类以及宏在 Clang 中的表示方式，这些 API 可以用于该部分的开发，特别是用于创建支持自定义
    `#pragma` 指令的处理程序插件以及创建用于与预处理事件更深入集成的自定义预处理程序回调。
- en: Following the order of Clang's compilation stages, the next chapter will show
    you how to work with an **abstract syntax tree** (**AST**) and how to develop
    an AST plugin to insert custom logic into it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 Clang 的编译阶段顺序，下一章将向你展示如何处理抽象语法树（**AST**）以及如何开发一个可以将其逻辑插入其中的 AST 插件。
- en: Exercises
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are some simple questions and exercises that you might want to play around
    with by yourself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的问题和练习，你可能想自己尝试一下：
- en: Though most of the time `Tokens` are harvested from provided source code, in
    some cases, `Tokens` might be generated dynamically inside the `Preprocessor`.
    For example, the `__LINE__` built-in macro is expanded to the current line number,
    and the `__DATE__` macro is expanded to the current calendar date. How does Clang
    put that generated textual content into the source code buffer of `SourceManager`?
    How does Clang assign `SourceLocation` to these tokens?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管大多数时候 `Tokens` 都是从提供的源代码中收集的，但在某些情况下，`Tokens` 可能会在 `Preprocessor` 内部动态生成。例如，内置宏
    `__LINE__` 被展开为当前行号，而宏 `__DATE__` 被展开为当前的日历日期。Clang 如何将这些生成的文本内容放入 `SourceManager`
    的源代码缓冲区中？Clang 如何将这些 `SourceLocation` 分配给这些标记？
- en: When we were talking about implementing a custom `PragmaHandler`, we were leveraging
    `Preprocessor::Lex` to fetch `Tokens` followed after the pragma name, until we
    hit the `eod` token kind. Can we keep lexing *beyond* the `eod` token? What interesting
    things will you do if you can consume arbitrary tokens after the `#pragma` directive?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们谈论实现自定义 `PragmaHandler` 时，我们正在利用 `Preprocessor::Lex` 来获取 `Tokens`，直到遇到 `eod`
    标记类型。我们能否在 `eod` 标记之后继续进行词法分析？如果你可以在 `#pragma` 指令之后消费任意标记，你会做些什么有趣的事情？
- en: 'In the `macro guard` project from the *Developing custom preprocessor plugins
    and callbacks* section, the warning message has the format of `[WARNING] In <source
    location>: ….`. Apparently, this is not a typical compiler warning we see from
    `clang`, which looks like `<source location>: warning: …`, as shown in the following
    code snippet:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在“*开发自定义预处理程序插件和回调*”部分的 `macro guard` 项目中，警告信息的格式为 `[WARNING] In <source location>:
    ….`。显然，这并不是我们从 `clang` 看到的典型编译器警告，它看起来像 `<source location>: warning: …`，如下代码片段所示：'
- en: '[PRE40]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `warning` string is even colored in supported terminals. How can we print
    a warning message such as that? Is there an infrastructure in Clang for doing
    that?
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`warning` 字符串甚至在支持的终端中被着色。我们如何打印这样的警告信息？Clang 中是否有基础设施来做这件事？'
