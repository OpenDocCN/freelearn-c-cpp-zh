["```cpp\nEMULATE_LONG_COMP_OP [s]<LF>\n```", "```cpp\n\"EMULATE_LONG_COMP_OP 10\\n\"\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nclass SyncTCPClient {\npublic:\n  SyncTCPClient(const std::string& raw_ip_address,\n    unsigned short port_num) :\n    m_ep(asio::ip::address::from_string(raw_ip_address),\n    port_num),\n    m_sock(m_ios) {\n\n    m_sock.open(m_ep.protocol());\n  }\n\n  void connect() {\n    m_sock.connect(m_ep);\n  }\n\n  void close() {\n    m_sock.shutdown(\n      boost::asio::ip::tcp::socket::shutdown_both);\n    m_sock.close();\n  }\n\n  std::string emulateLongComputationOp(\n    unsigned int duration_sec) {\n\n    std::string request = \"EMULATE_LONG_COMP_OP \"\n      + std::to_string(duration_sec)\n      + \"\\n\";\n\n    sendRequest(request);\n    return receiveResponse();\n  };\n\nprivate:\n  void sendRequest(const std::string& request) {\n    asio::write(m_sock, asio::buffer(request));\n  }\n\n  std::string receiveResponse() {\n    asio::streambuf buf;\n    asio::read_until(m_sock, buf, '\\n');\n\n    std::istream input(&buf);\n\n    std::string response;\n    std::getline(input, response);\n\n    return response;\n  }\n\nprivate:\n  asio::io_service m_ios;\n\n  asio::ip::tcp::endpoint m_ep;\n  asio::ip::tcp::socket m_sock;\n};\n\nint main()\n{\n  const std::string raw_ip_address = \"127.0.0.1\";\n  const unsigned short port_num = 3333;\n\n  try {\n    SyncTCPClient client(raw_ip_address, port_num);\n\n    // Sync connect.\n    client.connect();\n\n    std::cout << \"Sending request to the server... \"\n      << std::endl;\n\n    std::string response =\n      client.emulateLongComputationOp(10);\n\n    std::cout << \"Response received: \" << response\n      << std::endl;\n\n    // Close the connection and free resources.\n    client.close();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\nvoid sendRequest(const std::string& request)\n```", "```cpp\nasio::streambuf buf;\nasio::read_until(m_sock, buf, '\\n');\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nclass SyncUDPClient {\npublic:\n  SyncUDPClient() :\n    m_sock(m_ios) {\n\n    m_sock.open(asio::ip::udp::v4());\n  }\n\n  std::string emulateLongComputationOp(\n    unsigned int duration_sec,\n    const std::string& raw_ip_address,\n    unsigned short port_num) {\n\n    std::string request = \"EMULATE_LONG_COMP_OP \"\n      + std::to_string(duration_sec)\n      + \"\\n\";\n\n    asio::ip::udp::endpoint ep(\n      asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    sendRequest(ep, request);\n    return receiveResponse(ep);\n  };\n\nprivate:\n  void sendRequest(const asio::ip::udp::endpoint& ep,\n    const std::string& request) {\n\n    m_sock.send_to(asio::buffer(request), ep);\n  }\n\n  std::string receiveResponse(asio::ip::udp::endpoint& ep) {\n    char response[6];\n    std::size_t bytes_recieved =\n      m_sock.receive_from(asio::buffer(response), ep);\n\n    m_sock.shutdown(asio::ip::udp::socket::shutdown_both);\n    return std::string(response, bytes_recieved);\n  }\n\nprivate:\n  asio::io_service m_ios;\n\n  asio::ip::udp::socket m_sock;\n};\n\nint main()\n{\n  const std::string server1_raw_ip_address = \"127.0.0.1\";\n  const unsigned short server1_port_num = 3333;\n\n  const std::string server2_raw_ip_address = \"192.168.1.10\";\n  const unsigned short server2_port_num = 3334;\n\n  try {\n    SyncUDPClient client;\n\n    std::cout << \"Sending request to the server #1 ... \"\n      << std::endl;\n\n    std::string response =\n      client.emulateLongComputationOp(10,\n      server1_raw_ip_address, server1_port_num);\n\n    std::cout << \"Response from the server #1 received: \"\n      << response << std::endl;\n\n    std::cout << \"Sending request to the server #2... \"\n      << std::endl;\n\n    response =\n      client.emulateLongComputationOp(10,\n      server2_raw_ip_address, server2_port_num);\n\n    std::cout << \"Response from the server #2 received: \"\n      << response << std::endl;\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\nstd::string emulateLongComputationOp(\n         unsigned int duration_sec,\n         const std::string& raw_ip_address,\n         unsigned short port_num)\n```", "```cpp\n  template <typename ConstBufferSequence>\n  std::size_t send_to(const ConstBufferSequence& buffers,\n      const endpoint_type& destination)\n```", "```cpp\n  template <typename MutableBufferSequence>\n  std::size_t receive_from(const MutableBufferSequence& buffers,\n      endpoint_type& sender_endpoint) \n```", "```cpp\n#include <boost/predef.h> // Tools to identify the OS.\n\n// We need this to enable cancelling of I/O operations on\n// Windows XP, Windows Server 2003 and earlier.\n// Refer to \"http://www.boost.org/doc/libs/1_58_0/\n// doc/html/boost_asio/reference/basic_stream_socket/\n// cancel/overload1.html\" for details.\n#ifdef BOOST_OS_WINDOWS\n#define _WIN32_WINNT 0x0501\n\n#if _WIN32_WINNT <= 0x0502 // Windows Server 2003 or earlier.\n  #define BOOST_ASIO_DISABLE_IOCP\n  #define BOOST_ASIO_ENABLE_CANCELIO  \n#endif\n#endif\n```", "```cpp\n#include <boost/asio.hpp>\n\n#include <thread>\n#include <mutex>\n#include <memory>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\n// Function pointer type that points to the callback\n// function which is called when a request is complete.\ntypedef void(*Callback) (unsigned int request_id,\n  const std::string& response,\n  const system::error_code& ec);\n```", "```cpp\n// Structure represents a context of a single request.\nstruct Session {\n  Session(asio::io_service& ios,\n  const std::string& raw_ip_address,\n  unsigned short port_num,\n  const std::string& request,\n  unsigned int id,\n  Callback callback) :\n  m_sock(ios),\n  m_ep(asio::ip::address::from_string(raw_ip_address),\n  port_num),\n  m_request(request),\n  m_id(id),\n  m_callback(callback),\n  m_was_cancelled(false) {}\n\n  asio::ip::tcp::socket m_sock; // Socket used for communication\n  asio::ip::tcp::endpoint m_ep; // Remote endpoint.\n  std::string m_request;        // Request string.\n\n  // streambuf where the response will be stored.\n  asio::streambuf m_response_buf;\n  std::string m_response; // Response represented as a string.\n\n  // Contains the description of an error if one occurs during\n  // the request life cycle.\n  system::error_code m_ec;\n\n  unsigned int m_id; // Unique ID assigned to the request.\n\n  // Pointer to the function to be called when the request\n  // completes.\n  Callback m_callback;\n\n  bool m_was_cancelled;\n  std::mutex m_cancel_guard;\n};\n```", "```cpp\nclass AsyncTCPClient : public boost::noncopyable {\nclass AsyncTCPClient : public boost::noncopyable {\npublic:\n   AsyncTCPClient(){\n      m_work.reset(new boost::asio::io_service::work(m_ios));\n\n      m_thread.reset(new std::thread([this](){\n         m_ios.run();\n      }));\n   }\n\n   void emulateLongComputationOp(\n      unsigned int duration_sec,\n      const std::string& raw_ip_address,\n      unsigned short port_num,\n      Callback callback,\n      unsigned int request_id) {\n\n      // Preparing the request string.\n      std::string request = \"EMULATE_LONG_CALC_OP \"\n         + std::to_string(duration_sec)\n         + \"\\n\";\n\n      std::shared_ptr<Session> session =\n         std::shared_ptr<Session>(new Session(m_ios,\n         raw_ip_address,\n         port_num,\n         request,\n         request_id,\n         callback));\n\n      session->m_sock.open(session->m_ep.protocol());\n\n      // Add new session to the list of active sessions so\n      // that we can access it if the user decides to cancel\n      // the corresponding request before it completes.\n      // Because active sessions list can be accessed from \n      // multiple threads, we guard it with a mutex to avoid \n      // data corruption.\n      std::unique_lock<std::mutex>\n         lock(m_active_sessions_guard);\n      m_active_sessions[request_id] = session;\n      lock.unlock();\n\n      session->m_sock.async_connect(session->m_ep, \n         [this, session](const system::error_code& ec) \n         {\n         if (ec != 0) {\n            session->m_ec = ec;\n            onRequestComplete(session);\n            return;\n         }\n\n         std::unique_lock<std::mutex>\n            cancel_lock(session->m_cancel_guard);\n\n         if (session->m_was_cancelled) {\n            onRequestComplete(session);\n            return;\n         }\n\n                asio::async_write(session->m_sock, \n                             asio::buffer(session->m_request),\n         [this, session](const boost::system::error_code& ec,\n                            std::size_t bytes_transferred) \n         {\n         if (ec != 0) {\n            session->m_ec = ec;\n            onRequestComplete(session);\n            return;\n         }\n\n         std::unique_lock<std::mutex>\n            cancel_lock(session->m_cancel_guard);\n\n         if (session->m_was_cancelled) {\n            onRequestComplete(session);\n            return;\n         }\n\n                asio::async_read_until(session->m_sock,\n                                  session->m_response_buf, \n                                  '\\n', \n         [this, session](const boost::system::error_code& ec,\n              std::size_t bytes_transferred) \n         {\n         if (ec != 0) {\n            session->m_ec = ec;\n         } else {\n            std::istream strm(&session->m_response_buf);\n            std::getline(strm, session->m_response);\n         }\n\n         onRequestComplete(session);\n      });});});\n   };\n\n   // Cancels the request.  \n   void cancelRequest(unsigned int request_id) {\n      std::unique_lock<std::mutex>\n         lock(m_active_sessions_guard);\n\n      auto it = m_active_sessions.find(request_id);\n      if (it != m_active_sessions.end()) {\n         std::unique_lock<std::mutex>\n            cancel_lock(it->second->m_cancel_guard);\n\n         it->second->m_was_cancelled = true;\n         it->second->m_sock.cancel();\n      }\n   }\n\n   void close() {\n      // Destroy work object. This allows the I/O thread to\n      // exits the event loop when there are no more pending\n      // asynchronous operations. \n      m_work.reset(NULL);\n\n      // Wait for the I/O thread to exit.\n      m_thread->join();\n   }\n\nprivate:\n   void onRequestComplete(std::shared_ptr<Session> session) {\n      // Shutting down the connection. This method may\n      // fail in case socket is not connected. We don’t care \n      // about the error code if this function fails.\n      boost::system::error_code ignored_ec;\n\n      session->m_sock.shutdown(\n         asio::ip::tcp::socket::shutdown_both,\n         ignored_ec);\n\n      // Remove session form the map of active sessions.\n      std::unique_lock<std::mutex>\n         lock(m_active_sessions_guard);\n\n      auto it = m_active_sessions.find(session->m_id);\n      if (it != m_active_sessions.end())\n         m_active_sessions.erase(it);\n\n      lock.unlock();\n\n      boost::system::error_code ec;\n\n      if (session->m_ec == 0 && session->m_was_cancelled)\n         ec = asio::error::operation_aborted;\n      else\n         ec = session->m_ec;\n\n      // Call the callback provided by the user.\n      session->m_callback(session->m_id, \n         session->m_response, ec);\n   };\n\nprivate:\n   asio::io_service m_ios;\n   std::map<int, std::shared_ptr<Session>> m_active_sessions;\n   std::mutex m_active_sessions_guard;\n   std::unique_ptr<boost::asio::io_service::work> m_work;\n   std::unique_ptr<std::thread> m_thread;\n};\n```", "```cpp\nvoid handler(unsigned int request_id,\n         const std::string& response, \n                const system::error_code& ec) \n{\n  if (ec == 0) {\n    std::cout << \"Request #\" << request_id\n      << \" has completed. Response: \"\n      << response << std::endl;\n  } else if (ec == asio::error::operation_aborted) {\n    std::cout << \"Request #\" << request_id\n      << \" has been cancelled by the user.\" \n            << std::endl;\n  } else {\n    std::cout << \"Request #\" << request_id\n      << \" failed! Error code = \" << ec.value()\n      << \". Error message = \" << ec.message() \n             << std::endl;\n  }\n\n  return;\n}\n```", "```cpp\nint main()\n{\n  try {\n    AsyncTCPClient client;\n\n    // Here we emulate the user's behavior.\n\n    // User initiates a request with id 1.\n    client.emulateLongComputationOp(10, \"127.0.0.1\", 3333,\n      handler, 1);\n    // Then does nothing for 5 seconds.\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n    // Then initiates another request with id 2.\n    client.emulateLongComputationOp(11, \"127.0.0.1\", 3334,\n      handler, 2);\n    // Then decides to cancel the request with id 1.\n    client.cancelRequest(1);\n    // Does nothing for another 6 seconds.\n    std::this_thread::sleep_for(std::chrono::seconds(6));\n    // Initiates one more request assigning ID3 to it.\n    client.emulateLongComputationOp(12, \"127.0.0.1\", 3335,\n      handler, 3);\n    // Does nothing for another 15 seconds.\n    std::this_thread::sleep_for(std::chrono::seconds(15));\n    // Decides to exit the application.\n    client.close();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n};\n```", "```cpp\nsession->m_sock.async_connect(session->m_ep,\n  [this, session](const system::error_code& ec)\n  { \n         // ...\n  });\n```", "```cpp\n[this, session](const system::error_code&ec)\n{\n  if (ec != 0) {\n    session->m_ec = ec;\n    onRequestComplete(session);\n    return;\n  }\n\n  std::unique_lock<std::mutex>\n    cancel_lock(session->m_cancel_guard);\n\n  if (session->m_was_cancelled) {\n     onRequestComplete(session);\n     return;\n  }\n\n  asio::async_write(session->m_sock,\n  asio::buffer(session->m_request),\n        [this, session](const boost::system::error_code& ec,\n              std::size_t bytes_transferred)\n              {\n                    //...\n        });\n}\n```", "```cpp\n[this, session](const boost::system::error_code& ec,\n         std::size_t bytes_transferred){\n  if (ec != 0) {\n    session->m_ec = ec;\n    onRequestComplete(session);\n    return;\n  }\n\n  std::unique_lock<std::mutex>\n    cancel_lock(session->m_cancel_guard);\n\n  if (session->m_was_cancelled) {\n    onRequestComplete(session);\n    return;\n  }\n\n  asio::async_read_until(session->m_sock,\n        session->m_response_buf, '\\n', \n     [this, session](const boost::system::error_code& ec,\n              std::size_t b'ytes_transferred) \n        {\n      // ...\n        });\n}\n```", "```cpp\n[this, session](const boost::system::error_code& ec,\n    std::size_t bytes_transferred) \n{\n  if (ec != 0) {\n    session->m_ec = ec;\n  } else {\n    std::istream strm(&session->m_response_buf);\n    std::getline(strm, session->m_response);\n  }\n\n  onRequestComplete(session);\n}\n```", "```cpp\nstd::list<std::unique_ptr<std::thread>> m_threads;\n```", "```cpp\nAsyncTCPClient(unsigned char num_of_threads){\n  m_work.reset(new boost::asio::io_service::work(m_ios));\n\n  for (unsigned char i = 1; i <= num_of_threads; i++) {\n         std::unique_ptr<std::thread> th(\n               new std::thread([this](){\n        m_ios.run();\n      }));\n\n      m_threads.push_back(std::move(th));\n    }\n  }\n```", "```cpp\nvoid close() {\n  // Destroy work object. This allows the I/O threads to\n  // exit the event loop when there are no more pending\n  // asynchronous operations. \n  m_work.reset(NULL);\n\n  // Waiting for the I/O threads to exit.\n  for (auto& thread : m_threads) {\n    thread->join();\n  }\n}\n```"]