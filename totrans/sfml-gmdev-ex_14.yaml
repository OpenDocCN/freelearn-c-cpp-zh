- en: Chapter 14. Come Play with Us! – Multiplayer Subtleties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章.一起来玩吧！ – 多玩家细微差别
- en: Lots of great things in this world have incredibly humble beginnings. The contents
    of this book, from cover to cover, tell a story of a journey that began with nothing
    more than an interest and the will to create. Now that we're at the climax of
    our tale, why not end with a bang? Let's bring things back full circle and combine
    the framework we've developed with capabilities of networking to bring the third
    project of this book into new light! Let's connect our players not just through
    means of simple information exchange, but also through gameplay.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个世界上有很多伟大的事物有着极其谦逊的起点。这本书从封面到封底，讲述了一个从兴趣和创造意志开始的旅程。现在我们已经到达故事的顶点，为什么不来个高潮呢？让我们将我们开发的框架与网络功能结合起来，为这本书的第三个项目带来新的视角！让我们通过游戏玩法将我们的玩家连接起来，而不仅仅是通过简单的信息交换。
- en: 'In this chapter, we''re going to cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building a game server that supports previously implemented mechanics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建支持先前实现机制的游戏服务器
- en: Exchanging entity data over a network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上交换实体数据
- en: Transforming existing game code into a client application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有游戏代码转换为客户端应用程序
- en: Implementing player versus player combat
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现玩家对战玩家战斗
- en: Hiding network latency by smoothing out entity movement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过平滑实体移动来隐藏网络延迟
- en: There's a lot of code to cover, so let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多代码需要覆盖，让我们开始吧！
- en: Use of copyrighted resources
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的利用
- en: 'As always, it''s fair to credit the artists who made the amazing graphics and
    sound effects that we''re going to be using for our final project:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们应该感谢那些为我们最终项目制作了惊人的图形和音效的艺术家：
- en: '*Simple small pixel hearts* by *C.Nilsson* under the CC-BY-SA 3.0 license:
    [http://opengameart.org/content/simple-small-pixel-hearts](http://opengameart.org/content/simple-small-pixel-hearts)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*C.Nilsson*创作的*简单的像素心形*，根据CC-BY-SA 3.0许可：[http://opengameart.org/content/simple-small-pixel-hearts](http://opengameart.org/content/simple-small-pixel-hearts)
- en: '*Grunt* by *n3b* under the CC-BY 3.0 license: [http://opengameart.org/content/grunt](http://opengameart.org/content/grunt)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*n3b*创作的*Grunt*，根据CC-BY 3.0许可：[http://opengameart.org/content/grunt](http://opengameart.org/content/grunt)
- en: '*Swishes sound pack* by *artisticdude* under the CC0 license (public domain):
    [http://opengameart.org/content/swishes-sound-pack](http://opengameart.org/content/swishes-sound-pack)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*artisticdude*创作的*Swishes声音包*，根据CC0许可（公共领域）：[http://opengameart.org/content/swishes-sound-pack](http://opengameart.org/content/swishes-sound-pack)
- en: '*3 Item sounds* by *Michel Baradari* under the CC-BY 3.0 license: [http://opengameart.org/content/3-item-sounds](http://opengameart.org/content/3-item-sounds)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Michel Baradari*创作的*3个物品声音*，根据CC-BY 3.0许可：[http://opengameart.org/content/3-item-sounds](http://opengameart.org/content/3-item-sounds)
- en: Shared code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享代码
- en: Since there are many instances where code we write is going to exist on both
    the client and the server side, let's discuss that first, starting with the way
    data exchange between both sides is made.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们编写的代码将存在于客户端和服务器端，让我们首先讨论这一点，从双方数据交换的方式开始。
- en: 'The most important part of our information exchange is updating entities on
    any and all connected clients. We do this by sending specialized structures back
    and forth, which contains relevant entity information. From now on, these structures
    are going to be referred to as snapshots. Let''s see how they can be implemented,
    by taking a look at the `EntitySnapshot.h` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们信息交换最重要的部分是更新所有连接客户端上的实体。我们通过发送包含相关实体信息的专业结构来做到这一点。从现在开始，这些结构将被称为快照。让我们看看它们是如何实现的，通过查看`EntitySnapshot.h`文件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The information we're going to be updating constantly for any given entity consists
    of its position and elevation, velocity, acceleration, the direction it's facing
    as well as the state it's in, and the entity's health and name. The type of an
    entity is also sent in a snapshot and used when creating the entity on the client
    side.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不断更新任何给定实体的信息，包括其实体位置和海拔，速度，加速度，其面向的方向以及其实体的状态，以及实体的健康和名称。实体的类型也会在快照中发送，并在客户端创建实体时使用。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this example, the order of the data members in the `EntitySnapshot` structure
    may not be the most efficient. Ordering data in your structures from biggest to
    smallest can help reduce their size, and therefore the bandwidth overhead. Structure
    alignment and packing are not going to be covered here, but it's a worthy subject
    to look into.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`EntitySnapshot`结构中数据成员的顺序可能不是最有效的。从大到小对结构中的数据进行排序可以帮助减小它们的大小，从而减少带宽开销。结构对齐和打包在这里不会讨论，但它是一个值得研究的主题。
- en: 'Something that helps a great deal in making our code more readable is overloading
    the *bitwise shift* operators of `sf::Packet` to support custom data types, such
    as `EntitySnapshot`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在使我们的代码更易读方面，重载`sf::Packet`的位运算符以支持自定义数据类型，如`EntitySnapshot`，非常有帮助：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Actual implementation of these overloads exists inside the `EntitySnapshot.cpp`
    file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重载的实际实现位于`EntitySnapshot.cpp`文件中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Other data exchanges are going to be more specific to the situation, so we''re
    going to cover them later on. One thing we can do to prepare for that now, however,
    is updating the `Network` enumeration in the `NetworkDefinitions.h` file with
    a new value that is going to be used as a delimiter between different types of
    data in a specific packet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据交换将更具体地针对特定情况，所以我们将在稍后讨论它们。然而，现在我们可以做的一件事是，更新`NetworkDefinitions.h`文件中的`Network`枚举，添加一个新值，该值将用作特定数据包中不同类型数据之间的分隔符：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we're going to work with the specific packet type that uses this delimiter
    on both the client and the server, its place is within the shared code space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在客户端和服务器上使用使用此分隔符的特定数据包类型，所以它的位置在共享代码空间中。
- en: Additional components
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外组件
- en: 'First and foremost, entities that need to be synchronized between the server
    and client need to be marked and assigned a unique identifier. This is where the
    `C_Client` component comes in:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先且最重要的是，需要在服务器和客户端之间同步的实体需要被标记并分配一个唯一的标识符。这就是`C_Client`组件发挥作用的地方：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It would also be nice to support entity names, in order to be able to store
    player nicknames. This can be accomplished by implementing a name component:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 支持实体名称也会很方便，以便能够存储玩家昵称。这可以通过实现一个名称组件来完成：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s a common thing in games to have a small cooldown period where an entity
    cannot be attacked, possibly also defining how long its hurting/death animation
    should last. Components that allow and define such functionality would ideally
    have to inherit from a base class, which simplifies the process of timing such
    events:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，有一个小冷却期，在这个期间实体不能被攻击，可能还会定义其受伤/死亡动画应该持续多长时间。允许并定义此类功能的组件理想情况下需要从基类继承，这样可以简化此类事件的时间处理过程：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One component that will make use of the base timed class will be `C_Health`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用基定时类的`C_Health`组件：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, it holds values for the current entity health, its maximum health
    value, and a few data members that hold the expected duration of being hurt and
    dying.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它包含当前实体的健康值、其最大健康值以及一些数据成员，这些成员持有预期受伤和死亡的时间长度。
- en: 'Naturally, we''re going to need more entity message and event types in order
    to express the process of combat. The newly added types are highlighted in the
    following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们需要更多的实体消息和事件类型来表示战斗过程。以下代码片段中突出显示了新添加的类型：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `EntityManager` class is also going to be shared between both sides. Some
    adjustments have to be made to its `AddEntity` and `RemoveEntity` methods in order
    to let the rest of the entity component system know when an entity has been added
    or removed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager`类也将被双方共享。为了让实体组件系统知道何时添加或删除实体，需要对它的`AddEntity`和`RemoveEntity`方法进行一些调整：'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot more of the code we've written in previous chapters is actually going
    to need to be shared as well. Some of these classes, like the entity manager for
    example, have been slightly modified to serve as parents for derivatives of client
    and server implementations. We're not going to discuss that at length here, as
    the code files of this chapter should be more than helpful for familiarizing yourself
    with the code structure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中编写的很多代码实际上也需要共享。例如，一些类，如实体管理器，已经稍作修改，作为客户端和服务器实现派生类的父类。我们在这里不会详细讨论这个问题，因为本章的代码文件应该足以帮助你熟悉代码结构。
- en: Building our game server
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的游戏服务器
- en: In [Chapter 13](ch13.html "Chapter 13. We Have Contact! – Networking Basics"),
    *We Have Contact! – Networking Basics*, we took a look at a very basic chat service
    that was supported by a server application and multiple clients connecting to
    it. Building a game server is quite similar to that. We have a piece of software
    that acts as a central point of interest to all its clients by doing all of the
    calculations and sending the results back to them in order to ensure proper and
    identical simulation is taking place across the board. Naturally, since we're
    not simply exchanging text messages, there is going to be a lot more data being
    sent back and forth, as well as more calculation on the server side.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "Chapter 13. We Have Contact! – Networking Basics")《我们有了联系！——网络基础》中，我们查看了一个由服务器应用程序支持并由多个客户端连接的基本聊天服务。构建游戏服务器与此非常相似。我们有一块软件，它通过执行所有计算并将结果发送回客户端，作为所有客户端的中心兴趣点，以确保整个系统的正确和一致的模拟。自然地，由于我们不仅仅是交换文本消息，因此将会有更多的数据在客户端和服务器之间来回发送，以及服务器端更多的计算。
- en: 'First, we need to decide on a time interval value of sending entity snapshots.
    It has to be often enough to maintain smooth updates, but send as little information
    as possible to remain efficient. After some testing and tweaking, a sweet spot
    can be found pretty easily. For this particular project, let''s say that an entity
    snapshot will be sent once every 100 milliseconds, which will be defined in `NetSettings.h`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定发送实体快照的时间间隔值。它必须足够频繁以保持平滑更新，但发送尽可能少的信息以保持效率。经过一些测试和调整，可以很容易地找到一个最佳点。对于这个特定的项目，让我们假设实体快照将每100毫秒发送一次，这将在`NetSettings.h`中定义：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sending 10 snapshots a second is enough to keep the clients happy and the server
    maintaining a relatively low bandwidth.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒发送10个快照就足以让客户满意，同时服务器也能保持相对较低的带宽。
- en: Additions to the entity component system
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体组件系统的补充
- en: 'The majority of combat logic is going to take place on the server side. In
    order to support entities attacking one another, we need a new component to work
    with the `C_Attacker`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数战斗逻辑将在服务器端进行。为了支持实体相互攻击，我们需要一个新的组件与`C_Attacker`一起工作：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The attacker component holds information about the size and location of the
    entity's attack area and possible offset, a flag to check if the entity has hit
    something while attacking, the force of knockback that is to be applied to another
    entity being attacked by this one, and the duration of the attack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击组件包含有关实体攻击区域的大小和位置以及可能的偏移量的信息，一个标志用于检查实体在攻击时是否击中了某个东西，对另一个被攻击实体的击退力，以及攻击的持续时间。
- en: Implementing combat
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现战斗
- en: 'Entity-on-entity combat is going to be a fairly simple addition, since we already
    have a nice collision system in place. It only requires a few additional lines
    of code inside the `EntityCollisions` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实体间的战斗将是一个相当简单的补充，因为我们已经有一个很好的碰撞系统。它只需要在`EntityCollisions`方法内部添加几行代码：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, both entities being checked get their attacker components fetched. If
    neither one of them has one, the iteration is skipped. Otherwise, a new message
    of type `Being_Attacked` is constructed. If the attacking entity's area of attach
    actually intersects the bounding box of another entity, this message is filled
    in with receiver and sender information and sent out.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，被检查的两个实体都会获取其攻击组件。如果它们中没有一个有，则跳过迭代。否则，会构建一个新的类型为`Being_Attacked`的消息。如果攻击实体的攻击区域实际上与另一个实体的边界框相交，则该消息会填充接收者和发送者信息并发送出去。
- en: 'In order to process and react properly to these collisions, as well as update
    all the entities that have potential to be in combat, we''re going to need a new
    system: `S_Combat`! It doesn''t have any additional methods other than the ones
    required to be implemented by the base system class, so there''s really no need
    for us to examine its header. Let''s take a look at its constructor and destructor
    instead:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理和反应这些碰撞，以及更新所有可能处于战斗状态的实体，我们需要一个新的系统：`S_Combat`！它除了需要实现基本系统类所需的方法外，没有其他额外的方法，所以我们实际上没有必要检查其头文件。让我们看看它的构造函数和析构函数：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This system will hold any entity that has position, is a movable entity with
    a state, and has a health component or attack component or both. It also subscribes
    to the `Being_Attacked` message in order to process attack area collisions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统将保留任何具有位置、是具有状态的移动实体，并且具有健康组件或攻击组件或两者都有的实体。它还订阅了`Being_Attacked`消息，以便处理攻击区域碰撞。
- en: 'Naturally, the same attack area cannot be positioned identically for all four
    directions that an entity is facing. Consider the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，不能为实体面向的四个方向中的任何一个以相同的方式定位相同的攻击区域。考虑以下示例：
- en: '![Implementing combat](img/B04284_14_01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![实施战斗](img/B04284_14_01.jpg)'
- en: 'Repositioning the attack area for each entity based on its current direction
    is done inside the `Update` method of this system:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据每个实体的当前方向重新定位攻击区域是在该系统的`Update`方法中完成的：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the current entity being checked has no `C_Attacker` component, the iteration
    is simply skipped. Otherwise, both the entity's area of attack and its offset
    are obtained, in addition to its current direction and position. In order to first
    center the attack area, half of its width and height is subtracted from the entity's
    position. The offset is then adjusted based on the direction the entity is facing,
    and the area of attack is moved to the latest position with it applied.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前正在检查的实体没有`C_Attacker`组件，则简单地跳过迭代。否则，除了当前方向和位置外，还获取实体的攻击区域和偏移量。为了首先使攻击区域居中，从实体的位置中减去其宽度和高度的一半。然后根据实体面向的方向调整偏移量，并将攻击区域移动到应用偏移量的最新位置。
- en: 'Let''s take a look at a possible response to the message our collision system
    sends out:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对碰撞系统发出的消息的可能响应：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we check if the combat system has both the sender and receiver of this
    message. If that's the case, the `Being_Attacked` message is processed by first
    obtaining the health component of the entity being attacked, as well as the attacker
    component of the aggressor. The state of the attacking entity is then checked.
    If it is not currently attacking or if the entity has already attacked something
    else, the method is terminated by returning. Otherwise, the attack is initiated
    by first reducing the victim's health by *1*. The attacker is then flagged for
    having already attacked an entity. If the victim's health is at value 0, its state
    is changed to `Dying`. Otherwise, a `Hurt` message is dispatched.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查战斗系统是否具有此消息的发送者和接收者。如果是这样，首先获取被攻击实体的健康组件以及攻击者的攻击组件。然后检查攻击实体的状态。如果它目前没有攻击或实体已经攻击了其他东西，方法通过返回来终止。否则，通过首先减少受害者的健康值*1*来开始攻击。然后标记攻击者已经攻击了一个实体。如果受害者的健康值为0，其状态将更改为`Dying`。否则，发送一个`Hurt`消息。
- en: The remaining few lines of code deal with the victim entity being knocked back
    slightly, as it's being attacked. Both the attacker's direction and knockback
    force are obtained and a `sf::Vector2f` variable, signifying the applied force
    is created. If the attacker is facing either left or up, the knockback value is
    inverted. Also, if the attacking entity is facing either left or right, the knockback
    is applied on the *X* axis. Otherwise, the *Y* axis is used. Then, the force is
    simply applied as velocity through the victim's `C_Movable` component.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的几行代码处理被攻击实体被轻微击退的情况。同时获取攻击者的方向和击退力，并创建一个表示施加力的`sf::Vector2f`变量。如果攻击者面向左或上，击退值将被反转。此外，如果攻击实体面向左或右，击退力将应用于*X*轴。否则，使用*Y*轴。然后，通过受害者的`C_Movable`组件将力简单地应用于速度。
- en: Server action timing
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器动作时间
- en: One major difference between running the same code on a server and a client
    is how certain actions and events are timed. Since we have no animations happening,
    there is no way to simply check when the last frame was reached and terminate
    an attack or death, for example. This is where manually setting certain time values
    comes in. For this, we're going to need the `S_Timers` system. Since it also doesn't
    have any additional methods other than the required ones, the class definition
    is not necessary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上运行相同的代码与在客户端运行之间的一大区别是某些动作和事件的计时方式。由于我们没有动画发生，因此无法简单地检查何时达到最后一帧并终止攻击或死亡，例如。这就是手动设置某些时间值的作用。为此，我们需要`S_Timers`系统。由于它也没有任何除必需方法之外的其他方法，因此不需要类定义。
- en: 'Let''s start by taking a look at the constructor and destructor of this system:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个系统的构造函数和析构函数：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once again, we simply subscribe to the state component as well as the attacker
    component, health component, or both. Nothing interesting happens here, so let''s
    move on to the `Update` method that makes timing on the server side possible:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只是订阅了状态组件以及攻击者组件、健康组件或两者。这里没有发生什么有趣的事情，所以让我们继续到`Update`方法，它使得服务器端的计时成为可能：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this system, both the attacker and health components are checked to see whether
    they have reached specific time values that are provided in the entity file. If
    the entity is in an attacking state, the attacker component is obtained and the
    elapsed time is added to it. If the attack duration is passed, the timer is reset
    and the "attacked" flag is set back to false, making another attack possible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，攻击者和健康组件都会被检查，看它们是否达到了实体文件中提供的特定时间值。如果实体处于攻击状态，则获取攻击者组件并将经过的时间添加到其中。如果攻击持续时间已过，计时器将被重置，并将“攻击”标志设置回false，从而允许进行另一次攻击。
- en: If the entity is in either the hurting or dying state, the respectful time values
    are checked against predetermined durations and the timer is reset once again.
    If the entity is actually in a dying state, a `Respawn` message is sent out as
    well, in order to reset its animation, health and move the entity to a specific
    location where it "respawns".
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体处于受伤或死亡状态，将检查相应的计时器值是否与预定的持续时间相符，并在必要时重置计时器。如果实体实际上处于死亡状态，还会发送一个`Respawn`消息，以便重置其动画、生命值并将实体移动到特定的复活位置。
- en: Server network system
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器网络系统
- en: Handling entity networking on the server side can be made a lot easier by simply
    building a dedicated system that would already have access to entity data by design.
    This is where the server network system comes in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地构建一个专门系统，该系统设计上就已经可以访问实体数据，可以大大简化服务器端实体网络的处理。这就是服务器网络系统的作用所在。
- en: 'Let''s start with how entities are going to be controlled by players. In previous
    chapters, we simply used messaging to move entities around on the client side.
    Obviously, due to network delays and bandwidth restrictions, it would be problematic
    to simply send out a bunch of messages whenever a client moves. It''s much more
    efficient to simply keep track of a player''s input state, as this simple structure
    demonstrates:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从玩家如何控制实体开始。在前面的章节中，我们只是简单地使用消息在客户端移动实体。显然，由于网络延迟和带宽限制，每当客户端移动时发送大量消息将会很成问题。简单地保持跟踪玩家的输入状态会更有效率，如下面的简单结构所示：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first two data members will contain the amount of times a player has been
    moved along either axis. On the client side, we're going to be sending input states
    to the server at a specific interval, which means we have the benefit of combining
    messages into neat packets, as well as process out redundant movement, such as
    moving left and right by the same amount. Additionally, clients are also going
    to be sending their attacking states. All of this information will be held in
    a container, which tethers it to a specific entity ID.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个数据成员将包含玩家在任一轴上移动的次数。在客户端，我们将以特定间隔向服务器发送输入状态，这意味着我们可以将消息组合成整洁的数据包，并处理掉冗余的移动，例如左右移动相同的距离。此外，客户端还将发送他们的攻击状态。所有这些信息都将保存在一个容器中，并将其与特定的实体ID绑定。
- en: 'Now, let''s take a look at the header file of the network system we''re going
    to implement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们将要实现的网络系统的头文件：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As usual, we have the required methods implemented, as well as a few additional
    ones. Since we're going to link behavior between clients and entities, we have
    a few methods that help us register and obtain this relationship information.
    On top of that, a few helper methods exist for creating snapshots of entity states
    and updating a specific client's information from an incoming packet.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们已经实现了所需的方法，以及一些额外的辅助方法。由于我们将在客户端和实体之间链接行为，因此有几个方法帮助我们注册和获取这种关系信息。除此之外，还有一些辅助方法用于创建实体状态的快照以及从接收到的数据包中更新特定客户端的信息。
- en: Implementing the network system
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现网络系统
- en: 'Let''s start with the constructor and destructor of the network system:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从网络系统的构造函数和析构函数开始：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This particular system is only going to require a single component: `C_Client`.
    It also subscribes to entity removal, hurt, and respawn messages.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的系统只需要一个组件：`C_Client`。它还订阅了实体移除、受伤和复活消息。
- en: 'Next, the `Update` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Update`方法：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is where we process the current control state of a client and apply it
    to the entity. Relevant messages are constructed and sent out, based on the state
    of a client's input.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们处理客户端当前控制状态并将其应用于实体的地方。根据客户端输入的状态构建并发送相关消息。
- en: 'Next, let''s deal with those three message types that this system is subscribed
    to:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理这个系统订阅的三个消息类型：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, if the entity is being removed, the player input information of the corresponding
    client in control of that entity gets erased. If a message about an entity getting
    hurt is received, a hurt packet is constructed and sent to all clients to notify
    them of an entity taking damage. Lastly, an entity respawn message is handled
    by resetting its position and elevation to some pre-defined values. These coordinates
    can easily be randomized or read in from the map file, but for demonstration purposes
    this works just fine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果实体正在被移除，那么控制该实体的相应客户端的玩家输入信息将被删除。如果收到有关实体受伤的消息，将构建一个受伤包并发送给所有客户端，以通知它们实体正在受到伤害。最后，通过重置其位置和高度到一些预定义的值来处理实体重生消息。这些坐标可以很容易地随机化或从地图文件中读取，但为了演示目的，这样做就足够了。
- en: 'When a client connects to our server and an entity for it is created, we need
    to have a method that allows us to express that relationship by binding the two
    values together, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个客户端连接到我们的服务器并为它创建一个实体时，我们需要一个方法来允许我们通过绑定这两个值来表达这种关系，如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since we're going to be storing the client ID inside the client component, it's
    obtained through the entity manager and used in exactly that manner.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在客户端组件中存储客户端ID，因此通过实体管理器获取它，并按这种方式使用。
- en: 'The network class is also going to need access to an instance of the `Server`
    class, hence the following method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 网络类也需要访问`Server`类的一个实例，因此有如下方法：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, a few methods of convenience for obtaining client and entity IDs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一些方便获取客户端和实体ID的方法：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Snapshot creation itself also deserves its own method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 快照的创建本身也值得有一个自己的方法：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because we're accessing entity information that could be changed, the server
    mutex has to be locked before we access it. After assigning a snapshot type to
    the packet provided as an argument, we write the number of entities into it as
    well. If the number is above zero, a `DumpEntityInfo` method is invoked. This
    method is defined within our `ServerEntityManager` class and will be covered shortly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要访问可能会被更改的实体信息，所以在访问之前必须锁定服务器互斥锁。在将快照类型分配给作为参数提供的包之后，我们还将实体数量写入其中。如果这个数字大于零，就会调用`DumpEntityInfo`方法。这个方法定义在我们的`ServerEntityManager`类中，稍后将会介绍。
- en: 'Lastly, let''s handle the incoming player update packets:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们处理传入的玩家更新包：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before anything can be done, we must make sure that the server mutex is locked
    and the client sending this packet has a valid entity attached to it. This is
    done by obtaining the entity ID and checking its validity in the next two lines.
    A local variable named `entity_message` is then created in order to hold the message
    type that the client is going to be sending to us. The attack state of the entity
    is then set to `false` by default and iterating over the packet's information
    begins.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何操作之前，我们必须确保服务器互斥锁被锁定，并且发送此包的客户端附有一个有效的实体。这是通过获取实体ID并在接下来的两行中检查其有效性来完成的。然后创建一个名为`entity_message`的局部变量，以便保存客户端将要发送给我们的消息类型。然后默认将实体的攻击状态设置为`false`，并开始遍历包的信息。
- en: Encountering a `Move` message is dealt with by extracting the X and Y values
    from the packet and overwriting our player movement information for the given
    entity with them. The `Attack` message has one less value to worry about. The
    player's `m_attacking` flag is set to `true` if the incoming player state contains
    anything else but zero.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到`Move`消息时，通过从包中提取X和Y值，并用它们覆盖给定实体的玩家移动信息来处理。`Attack`消息有一个更少的值需要关注。如果传入的玩家状态包含的不是零，则玩家的`m_attacking`标志被设置为`true`。
- en: Server entity and system management
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器实体和系统管理
- en: 'The components and systems supported on the server side are obviously going
    to differ from those on the client side. On top of that, custom methods for both
    ends help out a great deal by allowing the base class to remain unmodified, while
    the derivatives can deal with side-specific logic. Let''s take a look at our simple
    extension to the `EntityManager` class that runs on the server side:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端支持的组件和系统显然将与客户端的不同。除此之外，两端的自定义方法通过允许基类保持不变，而派生类处理特定逻辑，大大帮助了这一点。让我们看看我们在服务器端运行的简单扩展`EntityManager`类：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We're obviously not going to need any graphics or sound related component types
    here. It's the client's job to deal with those.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们这里不需要任何与图形或声音相关的组件类型。处理这些是客户端的工作。
- en: 'This class will also be useful when creating entity snapshots. All of the entity
    information is dumped into a provided instance of `sf::Packet` by using this method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在创建实体快照时也非常有用。所有实体信息都通过这个方法被倒入提供的`sf::Packet`实例中：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The entity ID is written into the packet instance first. An `EntitySnapshot`
    variable is created afterwards, and it is filled with relevant component information,
    provided these components exist at all. Once that's done, the snapshot instance
    is written to the packet, which is made incredibly easy thanks to its overloaded
    `<<` and `>>` operators.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实体ID首先写入数据包实例。之后创建一个`EntitySnapshot`变量，并填充相关的组件信息，前提是这些组件确实存在。完成这些后，快照实例被写入数据包，这得益于其重载的`<<`和`>>`运算符，变得非常简单。
- en: 'For system management on the server side, we only need to handle the systems
    that are added:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端的管理系统，我们只需要处理添加的系统：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Similar to what we did for components, we simply exclude anything graphical
    or sound related.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对组件所做的一样，我们简单地排除了所有与图形或声音相关的任何内容。
- en: Main server class
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要服务器类
- en: 'Similar to the client side''s `Game` class, a supervisor object is going to
    be needed on the server side as well. We''re going to be keeping instances of
    the game map, entity, and server managers, and the `Server` class itself in a
    new class, simply called `World`. Let''s start by taking a look at the header
    file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端的`Game`类类似，服务器端也需要一个管理对象。我们将保持游戏地图、实体、服务器管理器和`Server`类本身的实例在一个新类中，简单地称为`World`。让我们先看看头文件：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similar to `Game`, it has an `Update` method where all of the time-related magic
    is going to happen. It also has methods for handling custom packet types, handling
    a client leaving, and processing command-line input.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Game`类似，它有一个`Update`方法，所有与时间相关的魔法都将在这里发生。它还有处理自定义数据包类型、处理客户端离开和处理命令行输入的方法。
- en: Data member wise, we're looking at a few `sf::Time` instances for keeping track
    of the current server time, as well as delivery time for snapshots. A `sf::Thread`
    instance for the command line is also quite handy to have around.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据成员方面，我们关注几个`sf::Time`实例，用于跟踪当前服务器时间和快照的交付时间。还有一个用于命令行的`sf::Thread`实例也非常方便。
- en: Last but not least, the `m_tpsTime`, `m_tick` and `m_tps` data members exist
    for the simple convenience of measuring the update rate on the server. The number
    of updates per second, also known as ticks, is quite useful for tracking down
    and resolving performance issues.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`m_tpsTime`、`m_tick`和`m_tps`数据成员存在是为了简单方便地测量服务器上的更新率。每秒的更新次数，也称为tick，对于追踪和解决性能问题非常有用。
- en: Implementing the world class
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现世界级
- en: 'Let''s kick this class into gear, starting with the constructor and destructor:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动这个类，从构造函数和析构函数开始：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our `Server` instance is set up by providing a valid packet handler in the initializer
    list, where the command thread is also set up. In the actual body of the constructor,
    we first attempt to start the server and catch a possible failure in an `if` statement.
    Upon a successful start, the `m_running` flag is set to `true` and both the entity
    manager and system manager are provided with pointers to each other. The game
    map is then loaded and relevant systems are provided with its instance. After
    our network system is made available with an instance of `Server`, the `ClientLeave`
    method is fed in as the timeout handler and the command line thread is launched.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在初始化列表中提供一个有效的数据包处理程序来设置`Server`实例，其中也设置了命令线程。在构造函数的实际主体中，我们首先尝试启动服务器，并在`if`语句中捕获可能的失败。启动成功后，将`m_running`标志设置为`true`，并将实体管理器和系统管理器相互提供指针。然后加载游戏地图，并将其实例提供给相关系统。在我们的网络系统通过`Server`实例可用后，将`ClientLeave`方法作为超时处理程序传入，并启动命令行线程。
- en: Upon destruction of the `World` class, all we really have to worry about is
    taking away the entity manager's access to the system manager.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`World`类被销毁时，我们真正需要担心的是移除实体管理器对系统管理器的访问权限。
- en: 'Next, let''s keep the action rolling by updating everything:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过更新一切来保持动作的连续性：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The server instance is first checked for having stopped. If that's the case,
    the world class itself is stopped and the `Update` method is returned from. Otherwise,
    all of our time values are updated alongside the server class. The system manager's
    `Update` method is then invoked in order to update all of the entity information.
    The server mutex has to be locked while that happens, as entity information could
    potentially be changed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查服务器实例是否已停止。如果是这样，则`World`类本身停止，并返回`Update`方法。否则，所有的时间值都会与服务器类一起更新。在此期间，必须锁定服务器互斥锁，因为实体信息可能会被更改。
- en: Once everything is up to date, the snapshot timer is checked to see if it has
    exceeded the snapshot interval. With that being the case, a snapshot packet is
    created and filled in by using the `CreateSnapshot` method of `S_Network`. The
    packet is then broadcasted to every single client and the snapshot timer is reset
    to zero.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一切更新完毕后，检查快照计时器以查看它是否超过了快照间隔。如果是这样，使用`S_Network`的`CreateSnapshot`方法创建并填充快照数据包。然后，将数据包广播到每个客户端，并将快照计时器重置为零。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Ticks Per Second** (**TPS**) are measured by increasing the `m_tick` data
    member every update, provided the TPS timer hasn''t exceeded one second. If that''s
    the case, `m_tps` is assigned the value of `m_tick`, which in turn gets set back
    to zero, alongside the TPS timer.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**每秒滴答数**（**TPS**）通过在每次更新时增加`m_tick`数据成员来测量，前提是TPS计时器没有超过一秒。如果是这样，`m_tps`被分配`m_tick`的值，然后`m_tick`及其TPS计时器都会被重置为零。'
- en: 'Handling incoming packets is the next piece of the puzzle:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 处理传入的数据包是下一个难题：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The client ID is first obtained from the originating IP address and port number.
    If a client with that information exists, we're interested in three packet types
    that can be received from it. First, the client disconnect packet is handled by
    invoking the `ClientLeave` method with the client ID passed in as the only argument.
    Next, the actual client is removed from the server class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端ID首先从源IP地址和端口号中获取。如果存在具有该信息的客户端，我们对其可以接收的三个数据包类型感兴趣。首先，客户端断开连接数据包通过调用`ClientLeave`方法处理，该客户端ID作为唯一参数传入。接下来，实际的客户端从服务器类中移除。
- en: The next packet type, `Message`, is left unimplemented for now. We're not going
    to send chat messages between clients just yet, but this is where it would be
    implemented in the future. Following that is the player update packet type, in
    which case the packet is simply passed into the network system to be processed.
    We have already covered this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个数据包类型，`Message`，目前尚未实现。我们目前不会在客户端之间发送聊天消息，但这是未来实现的地方。接下来是玩家更新数据包类型，在这种情况下，数据包只是简单地传递到网络系统中进行处理。我们已经讨论了这一点。
- en: If the origin information of the incoming data does not yield us a valid client
    ID, we're only interested in communications that attempt to connect. First, we
    attempt to extract a string from the packet, which would be the player nickname.
    If that fails, this method is returned from. Next, the client information is added
    and its success is checked by analyzing the returned client ID. In case of a failure,
    a `Disconnect` packet is sent back to the originating source and the method is
    returned from. Otherwise, the server mutex is locked and we attempt to add a new
    player entity. Failure to do that, once again, would result in returning from
    this method. The client ID is then registered in the network system and the position
    of our newly added player entity is set to some pre-defined values. The name component
    of the player entity is also adjusted to reflect the entered nickname. At this
    point, a connect packet is constructed as a response. It contains the entity ID
    of the player, as well as its spawn position. The packet is then sent out to our
    new client.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入数据的源信息没有为我们提供一个有效的客户端ID，我们只对尝试连接的通信感兴趣。首先，我们尝试从数据包中提取一个字符串，这将作为玩家的昵称。如果失败，则从这个方法返回。接下来，添加客户端信息，并通过分析返回的客户端ID来检查其成功。如果失败，则向原始源发送一个`Disconnect`数据包，并从这个方法返回。否则，服务器互斥锁被锁定，我们尝试添加一个新的玩家实体。如果无法做到这一点，则再次返回此方法。然后将客户端ID注册到网络系统中，并将我们新添加的玩家实体的位置设置为一些预定义的值。玩家实体的名称组件也被调整，以反映输入的昵称。此时，构建一个连接数据包作为响应。它包含玩家的实体ID以及其出生位置。然后，将数据包发送到我们的新客户端。
- en: 'Leaving the server is a much simpler procedure in comparison to this. Let''s
    take a look:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，离开服务器的过程要简单得多。让我们看看：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The server mutex gets locked before this operation is performed. The network
    system is then obtained and the `RemoveEntity` method of our entity manager is
    invoked with the return value of network system's `GetEntityID` method. This effectively
    removes the entity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，服务器互斥锁被锁定。然后获取网络系统，并调用我们实体管理器的`RemoveEntity`方法，该方法使用网络系统`GetEntityID`方法的返回值。这实际上移除了实体。
- en: 'Implementing some basic commands on the server side proves to be more than
    useful. Let''s take a look at a very basic setup of a command-line thread:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端实现一些基本命令证明是非常有用的。让我们看看一个命令行线程的非常基本的设置：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, a loop is entered and kept alive as long as the server is running. Next,
    the command line is prompted to obtain a line of input. The first command we process
    is `"terminate"`. This stops the server and breaks out of the command line loop,
    which is helpful. The following command disconnects every single client and purges
    all entities that currently exist. Notice that the server mutex gets locked before
    the purge. The next command simply displays the current tick per second rate.
    Typing in `"clients"` would result in a list of clients currently connected that
    contains their IP addresses, port numbers, and latency values. Lastly, the `"entities"`
    command simply prints out the number of entities that are currently in the world.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入一个循环，只要服务器正在运行，就保持其活跃。接下来，提示命令行以获取一行输入。我们处理的第一个命令是`"terminate"`。这停止了服务器，并从命令行循环中跳出，这很有帮助。接下来的命令断开所有客户端的连接，并清除当前存在的所有实体。注意，在清除之前，服务器互斥锁被锁定。下一个命令简单地显示当前的每秒滴答率。输入`"clients"`将显示当前连接的客户端列表，包括它们的IP地址、端口号和延迟值。最后，`"entities"`命令简单地打印出当前世界中实体的数量。
- en: 'The last and definitely the least interesting method is useful for obtaining
    the current status of the world:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个，当然也是最不有趣的方法，用于获取世界的当前状态：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Server entry point
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器入口点
- en: 'Now let''s put all of this effort to work. The following are the contents of
    our `Server_Main.cpp` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把所有的努力都付诸实践。以下是我们`Server_Main.cpp`文件的内容：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It couldn't get simpler than this. A new instance of the `World` class is created,
    alongside a clock that is promptly restarted. Our main `while` loop is entered
    with the condition that the world instance has to keep running. It gets updated
    every iteration with the return value of `clock.restart()`. After the loop is
    terminated, zero is returned to end the program successfully.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经不能再简单了。创建了一个新的`World`类实例，并立即重新启动了时钟。我们进入主要的`while`循环，条件是必须让世界实例持续运行。它每次迭代都会使用`clock.restart()`的返回值进行更新。循环结束后，返回零以成功结束程序。
- en: 'All of this brings us a very nice looking and capable console window that''s
    ready to handle some incoming connections:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些为我们带来一个非常漂亮且功能强大的控制台窗口，准备好处理一些传入的连接：
- en: '![Server entry point](img/B04284_14_02.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![服务器入口点](img/B04284_14_02.jpg)'
- en: This by itself is, of course, completely useless without the client that draws
    all of the pretty images as a result of the server communicating with it. That
    is the next major task on our list.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有客户端通过与服务器的通信绘制所有漂亮的图像，这本身是完全无用的。这是我们列表中的下一个主要任务。
- en: Developing the game client
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发游戏客户端
- en: 'With proper backend support from the server, we can now focus entirely on client-side
    details and spoil ourselves a little with pretty visuals that always yield that
    sense of accomplishment a lot quicker than anything that runs in the background.
    Let''s start by creating the client''s own version of `NetSettings.h`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器提供适当的后端支持后，我们现在可以完全专注于客户端的细节，并享受一些漂亮的视觉效果，这些视觉效果总是能比后台运行的内容更快地带来成就感。让我们首先创建客户端自己的`NetSettings.h`版本：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have a couple of macros to work with here. First is the expected delay between
    what's being rendered on screen and real time. This means that technically we're
    going to be rendering all action about 100 milliseconds in the past. The second
    macro is the interval at which we're going to be sending updates to the server.
    50 milliseconds gives us plenty of time to gather a few input states and let the
    server know what's going on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个宏可以在这里使用。第一个是屏幕上渲染的内容与真实时间之间的预期延迟。这意味着技术上我们将大约100毫秒前渲染所有动作。第二个宏是我们将发送到服务器的更新间隔。50毫秒给我们足够的时间收集一些输入状态，并让服务器知道发生了什么。
- en: Entity component system expansions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体组件系统扩展
- en: 'As in the case of the server, additional components and systems are necessary
    if we want to realize any of our goals. Unlike the server, however, these additions
    to the client entity component system are going to serve an entirely different
    purpose. It''s going to be important for us to see the names and health values
    of all players in the game. We''re going to shoot for something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务器的情况一样，如果我们想实现我们的任何目标，就需要额外的组件和系统。然而，与服务器不同的是，这些添加到客户端实体组件系统中的内容将服务于一个完全不同的目的。对我们来说，看到游戏中所有玩家的名称和健康值将非常重要。我们将努力实现如下：
- en: '![Entity component system expansions](img/B04284_14_03.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![实体组件系统扩展](img/B04284_14_03.jpg)'
- en: 'In order to easily maintain these glyphs floating above an entity, we''re going
    to need a new type of component that describes exactly where they''re supposed
    to be rendered:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松维护这些漂浮在实体上方的符号，我们需要一种新的组件类型，它精确描述了它们应该渲染的位置：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `C_UI_Element` component will read in two offset values, one for X and one
    for Y, from the entity file. This way, characters of different sizes can define
    their own rules of where this information will appear. We also included a couple
    of Boolean flags in case the health or name information ever needs to be disabled
    for some reason.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`C_UI_Element`组件将从实体文件中读取两个偏移值，一个用于X轴，一个用于Y轴。这样，不同大小的角色可以定义自己的规则，确定这些信息将出现在哪里。我们还包含了一些布尔标志，以防健康或名称信息因某些原因需要被禁用。'
- en: 'The component alone isn''t going to do anything fancy, so let''s create a new
    system that actually makes something happen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的组件本身不会做任何复杂的事情，所以让我们创建一个新的系统，真正让事情发生：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that this system has a `Render` method. We're not only going to update
    the position of the graphical elements, but also draw them on the screen. This
    includes a sprite that will be bound to whatever texture is chosen to represent
    health, an instance of `sf::Text` that will hold the entity's name, a rectangle
    background that will be rendered behind the name, and a data member that holds
    the size of the health bar texture.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个系统有一个`Render`方法。我们不仅要更新图形元素的位置，还要在屏幕上绘制它们。这包括一个将绑定到表示健康的任何纹理上的精灵，一个将包含实体名称的`sf::Text`实例，一个将在名称后面渲染的矩形背景，以及一个包含健康条纹理大小的数据成员。
- en: With that out of the way, let's start implementing this system!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们开始实现这个系统！
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first order of business here is, of course, setting up the component requirements.
    An entity has to have a position component and a UI element component, in addition
    to some combination of the health and name components. The rest of the constructor
    is used to set up the texture and font resources for our graphics. Our health
    bar texture is set to be repeated so we can represent any health value. The actual
    texture is only the size of a single heart.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里的首要任务是设置组件需求。一个实体必须有一个位置组件和一个UI元素组件，此外还需要一些健康和名称组件的组合。构造函数的其余部分用于设置我们图形的纹理和字体资源。我们的健康条纹理被设置为可重复的，这样我们就可以表示任何健康值。实际的纹理只有单个心形的大小。
- en: 'The resources for these elements obviously have to be released when they''re
    no longer needed. That''s where the destructor comes in:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当这些元素不再需要时，必须释放它们的资源。这就是析构函数的作用所在：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Lastly, the most important part of this system is contained within the `Render`
    method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个系统的最重要部分包含在`Render`方法中：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For each entity, we obtain all four components that we're going to be working
    with. Since there can be instances where either the name or health components
    exist without the other one present, both of them must be checked before we commit
    to rendering them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个实体，我们获取我们将要使用的所有四个组件。由于可能存在名称或健康组件存在而另一个不存在的实例，因此在我们承诺渲染它们之前，必须检查这两个组件。
- en: 'The health bar portion is drawn by first resetting the texture rectangle of
    the sprite. Its width is changed to the result of multiplying the width of a single
    heart in the texture by the health value an entity has. The *Y* value is left
    unchanged. The origin of the sprite is then changed to be in the middle of it
    on the *X* axis and on the very bottom of the *Y* axis. Its position is then set
    to that of the entity''s, but with the UI element''s offset factored in. Because
    the texture is set up to repeat itself, this allows us to represent ridiculous
    amounts of health:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 健康条部分是通过首先重置精灵的纹理矩形来绘制的。其宽度被更改为纹理中单个心形宽度的健康值。Y值保持不变。然后，精灵的原点被更改为它在X轴上的中间位置和Y轴的底部。其位置被设置为实体的位置，但考虑了UI元素的偏移。因为纹理被设置为重复，这使我们能够表示大量的健康值：
- en: '![Entity component system expansions](img/B04284_14_04.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![实体组件系统扩展](img/B04284_14_04.jpg)'
- en: When an entity's name is rendered, the `sf::Text` instance is first set up by
    changing the string and its origin is manipulated to be exactly in the middle.
    Since we want our information to be nicely stacked and not drawn on top of each
    other, checking if the health was rendered is necessary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实体的名称被渲染时，`sf::Text`实例首先通过更改字符串来设置，然后其原点被操作以正好位于中间。由于我们希望信息整齐堆叠，而不是相互覆盖，因此检查是否渲染了健康值是必要的。
- en: If the health component is present, the name's position is obtained from the
    `m_heartBar` data member. The Y value of that position is modified by subtracting
    the height of the health bar in order to render the player name on top. Otherwise,
    the name's position is set to match the entity with the offset included. The name
    background is then set up to be slightly larger than the text that it will be
    drawn behind and its origin is set to the exact center. The position of the name
    background is slightly offset by a single pixel from the position of the actual
    name. The values used here can be perfected by simply trying out different things
    and getting the feel for the best result.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在健康组件，名称的位置是从`m_heartBar`数据成员中获得的。该位置Y值通过减去健康条的宽度来修改，以便在顶部渲染玩家名称。否则，名称的位置被设置为与包含偏移的实体相匹配。名称背景被设置为比将要绘制在其后面的文本稍大，其原点设置为精确的中心。名称背景的位置稍微偏离实际名称的位置。这里使用的值可以通过简单地尝试不同的事情并找到最佳结果来完善。
- en: Lastly, the background and the entity's name are drawn in that order on screen.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，背景和实体的名称按照这个顺序在屏幕上绘制。
- en: Network class and interpolation
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络类和插值
- en: 'Showing our entities simply appearing on the screen isn''t satisfactory at
    all. Even if we get them to move, you will quickly notice that due to the delay
    between the server and client, players would look more like they''re skipping
    across the screen, rather than walking. A little more work has to be done on the
    client side in order to smooth it out. For that, we''re going to rely on something
    called interpolation. Consider the following illustration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地显示我们的实体出现在屏幕上根本不能令人满意。即使我们让它们移动，你也会很快注意到，由于服务器和客户端之间的延迟，玩家看起来更像是跳过屏幕，而不是行走。客户端需要做更多的工作来使其平滑。为此，我们将依赖于一种称为插值的方法。考虑以下插图：
- en: '![Network class and interpolation](img/B04284_14_05.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![网络类和插值](img/B04284_14_05.jpg)'
- en: What is interpolation? It's an estimation between two known data points. There
    are many different types of interpolation out there, all with a different philosophy
    of use. For our purposes, interpolating data simply comes down to finding a weighted
    average between two values at a given time. In the preceding diagram, we have
    two snapshots representing different places in time. Interpolating helps us find
    the state of an entity somewhere in the middle of those two snapshots, and, in
    turn, smooths out their movement by adjusting attributes such as position, velocity,
    and acceleration based on the estimation, rather than actual snapshot data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是插值？它是在两个已知数据点之间的估计。有许多不同类型的插值，它们都有不同的使用哲学。就我们的目的而言，插值数据简单来说就是找到给定时间两个值之间的加权平均值。在前面的图中，我们有两个快照代表不同时间点。插值帮助我们找到两个快照之间的某个中间位置的状态，进而通过根据估计调整位置、速度和加速度等属性来平滑它们的移动，而不是实际快照数据。
- en: 'Finding a value at a specific point in time between two snapshots can be expressed
    this way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个快照之间在特定时间点找到值可以表示为：
- en: '![Network class and interpolation](img/B04284_14_06.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![网络类和插值](img/B04284_14_06.jpg)'
- en: 'A value we want to find at a given time, tx, is simply the difference of the
    value between both snapshots divided by the difference in time, multiplied by
    the time that has passed since the first snapshot and then added to the value
    of the first snapshot. In code, it can be expressed like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在给定时间tx找到的值，简单地说，是两个快照之间值的差除以时间差，乘以自第一个快照以来经过的时间，然后加到第一个快照的值上。在代码中，它可以表示如下：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Having a few extra methods for actually handling the snapshot and time types,
    as well as comparing two snapshots together, would be useful:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际处理快照和时间类型，以及比较两个快照，有一些额外的方法将是有用的：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''re going to need some way of containing these snapshots, so it''s time
    to define our data types:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来包含这些快照，因此是时候定义我们的数据类型了：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All of the snapshots are first stored with the entity ID being the key. The
    actual map itself is being held by a `SnapshotDetails` struct, which may prove
    to be useful later if we decide to add any additional snapshot information. All
    of the entity data is then stored in a map structure, where the timestamp of the
    snapshot is the key value. Notice that we're using a regular map here, as opposed
    to an unordered map. What's the benefit, you may ask. The regular map type may
    be a little bit slower, but it automatically sorts its entries by key. This means
    that newer snapshots will always go towards the end of the map. The reason why
    that's important will become apparent when we're performing entity interpolation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有快照首先以实体ID作为键进行存储。实际的映射本身由一个`SnapshotDetails`结构体持有，这可能在以后如果我们决定添加任何额外的快照信息时变得有用。然后，所有实体数据都存储在一个映射结构中，其中快照的时间戳是键值。请注意，我们在这里使用的是常规映射，而不是无序映射。你可能会问，这有什么好处。常规映射类型可能稍微慢一点，但它会自动按键对条目进行排序。这意味着新的快照总是会映射到映射的末尾。为什么这很重要，当我们进行实体插值时会变得明显。
- en: The last data type we're going to need for the network class is some sort of
    container that holds outgoing messages we're going to send to the server. In this
    case, an unordered map works just fine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为网络类需要的最后一个数据类型是某种容器，用于存储我们将发送到服务器的出站消息。在这种情况下，无序映射就足够了。
- en: 'So, what is our network system class going to look like? Let''s take a look:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的网络系统类将是什么样子呢？让我们看看：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Apart from the normal methods a system has to implement, we have a few setters
    for registering a `Client` instance, as well as keeping track of the entity ID
    that our client is going to be controlling as a player. A few helper methods for
    adding a received entity snapshot, as well as sending out player messages to the
    server also exist to make life just a little bit easier. For our private method
    selection, we have a total of two: one for applying a specific snapshot to an
    entity and another for performing interpolation. This is met by a standard number
    of data members that are responsible for containing received snapshots, keeping
    track of the player ID, containing outgoing messages to the server before they''re
    sent out, and having access to the `Client` instance. To top that off, we''re
    going to use another `sf::Time` data type in order to keep track of time passage
    for sending player updates to the server.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统必须实现的常规方法外，我们还有一些用于注册`Client`实例的setter，以及跟踪我们的客户端作为玩家将要控制的实体ID。还有一些辅助方法用于添加接收到的实体快照，以及向服务器发送玩家消息，以使生活变得稍微容易一些。对于我们的私有方法选择，我们总共有两个：一个用于将特定快照应用于实体，另一个用于执行插值。这需要一定数量的数据成员，它们负责包含接收到的快照，跟踪玩家ID，在发送之前包含要发送到服务器的输出消息，以及访问`Client`实例。为了锦上添花，我们还将使用另一个`sf::Time`数据类型来跟踪时间流逝，以便向服务器发送玩家更新。
- en: Implementing the client network class
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现客户端网络类
- en: 'Before we get to actually implementing the network system, let''s complete
    the last two functions related to interpolation and comparison of entity snapshots:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际实现网络系统之前，让我们完成与插值和实体快照比较相关的最后两个函数：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We begin by overwriting some values that don't need to be interpolated. Note
    that the direction, health, and name values are overwritten with the latest available
    information from the second entity snapshot, rather than the first. This provides
    an overall smoother feel to entity movement and interactions. For the rest of
    the snapshot data, we use our handy `Interpolate` function, which provides a smooth
    transition between the two updates.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先覆盖了一些不需要插值的数据。请注意，方向、健康和名称值是用来自第二个实体快照的最新信息覆盖的，而不是第一个。这为实体移动和交互提供了整体更平滑的感觉。对于其余的快照数据，我们使用我们方便的`Interpolate`函数，它提供了两个更新之间的平滑过渡。
- en: 'It''s also quite useful to have a function that can compare two snapshots together,
    so we can know if any data has changed. `CompareSnapshots` comes to the rescue
    here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个能够比较两个快照的功能是非常有用的，这样我们就可以知道是否有任何数据已更改。"CompareSnapshots"在这里提供了帮助：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It's not really necessary to check every single aspect of a snapshot here. All
    we really care about is the positional, kinematic, and state information of the
    entity. Three additional Boolean arguments can also be provided, telling this
    function which data is relevant.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里检查快照的每个方面并不是真的有必要。我们真正关心的是实体的位置、运动学和状态信息。还可以提供三个额外的布尔参数，告诉此函数哪些数据是相关的。
- en: 'With this out of the way, we can finally begin implementing the network system
    class, starting, of course, with the constructor and destructor:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们最终可以开始实现网络系统类，当然是从构造函数和析构函数开始：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Much like on the server class, we only care about the entities that have client
    components in this system. Messages for entity movement and attacks are also subscribed
    to in order to properly store them and update the server later on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器类类似，我们只关心这个系统中具有客户端组件的实体。我们还订阅了实体移动和攻击的消息，以便正确存储它们并在稍后更新服务器。
- en: 'Next up, we have the `Update` method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`Update`方法：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, a check is made to make sure we have a valid pointer to the client class.
    If so, we lock the client mutex and add time to the player update timer. The `SendPlayerOutgoing`
    method is then invoked and the timer is reset if enough time has passed to update
    the server. Lastly, we call the private helper method of this class, which is
    responsible for interpolating between snapshots. Keeping this functionality separate
    from the actual update loop leaves us with nicer looking code and allows early
    return while interpolating.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一次检查以确保我们有一个指向客户端类的有效指针。如果是这样，我们锁定客户端互斥锁并给玩家更新计时器添加时间。如果经过足够的时间来更新服务器，则调用`SendPlayerOutgoing`方法并重置计时器。最后，我们调用这个类的私有辅助方法，该方法负责在快照之间进行插值。将此功能与实际的更新循环分开，使我们拥有更美观的代码，并允许在插值时提前返回。
- en: 'Handling the messages this system is subscribed to is quite simple, as you
    will see here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个系统订阅的消息相当简单，正如你在这里看到的：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: At this point, all we care about is adding the message into our outgoing container,
    since we're not dealing with more complex types just yet. An additional check
    is performed in case an attack message is received. There really is no point of
    having multiple attack messages in this container at the same time, so the `Notify`
    method simply returns if an attack message is attempted to be inserted while one
    already exists in the container.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们只关心将消息添加到我们的输出容器中，因为我们目前还没有处理更复杂类型。如果收到攻击消息，还会进行额外的检查。在这个容器中同时存在多个攻击消息实际上没有意义，所以`Notify`方法会在容器中已经存在攻击消息的情况下简单地返回。
- en: 'Next, we have some helper methods:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些辅助方法：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There''s nothing too special going on here. One thing to note is that when
    a new snapshot is being added, the client mutex probably should be locked. Speaking
    of snapshots, let''s look at how one could be applied to an entity:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有什么特别的事情发生。需要注意的是，当添加新的快照时，客户端互斥锁可能应该被锁定。说到快照，让我们看看如何将一个快照应用到实体上：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After we obtain a pointer to the entity manager and set up empty pointers to
    various components that the entity snapshot might contain information about, the
    client mutex is locked and we begin manipulating the component information carefully,
    by first attempting to retrieve a valid component address inside the `if` statements.
    This method also takes in a flag to let it know whether physics information, such
    as acceleration or velocity, should be applied, which can come in handy.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得实体管理器的指针并设置指向实体快照可能包含信息的各种组件的空指针之后，客户端互斥锁被锁定，我们开始仔细操作组件信息，首先尝试在`if`语句中检索一个有效的组件地址。此方法还接受一个标志，以告知它是否应该应用物理信息，如加速度或速度，这可能很有用。
- en: 'The following method is executed while updating the network system class, and
    it is responsible for sending player updates to the server:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法在更新网络系统类时执行，它负责将玩家更新发送到服务器：
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We begin by setting up some local variables that are going to be holding the
    number of times our player has moved in the X and Y directions. A smaller variable
    is also set up for the attack state. The next step is to iterate over all outgoing
    messages and process each type individually. In a case of a `Move` type, every
    single one of them is counted. If an `Attack` message is found, the attack state
    is simply set to 1.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一些局部变量，这些变量将用于存储玩家在X和Y方向上移动的次数。同时，还设置了一个较小的变量用于攻击状态。下一步是遍历所有发出的消息，并逐个处理每种类型。在`Move`类型的情况下，每个消息都会被计数。如果发现`Attack`消息，攻击状态就简单地设置为1。
- en: The last step is, of course, sending this information out. A new packet is then
    constructed and marked as a player update. The movement and attack state information
    is then fed into the packet. Notice that we're adding in the `PlayerUpdateDelim`
    value at the end of each update type. Enforcing specific communication rules as
    such decreases the chances of our server processing invalid or damaged data. Once
    the update packet is sent in, the outgoing message container is cleared for the
    next time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步当然是发送这些信息。然后构建一个新的数据包，并将其标记为玩家更新。然后将移动和攻击状态信息输入到数据包中。注意，我们在每个更新类型的末尾添加了`PlayerUpdateDelim`值。通过执行此类特定的通信规则，可以降低服务器处理无效或损坏数据的机会。一旦发送了更新数据包，输出消息容器就会被清空，以便下一次使用。
- en: 'Lastly, we arrive at the key method for ensuring smooth entity movement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达确保实体平滑移动的关键方法：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First and foremost, we must deal with the possibility of our client not having
    any snapshots at all. If that happens, this method is returned from immediately.
    If we have snapshots available, the next step is iterating over the snapshot container
    and finding two snapshots that we''re currently between (time wise). Normally,
    this wouldn''t be a likely outcome, but keep in mind that we''re rendering things
    slightly in the past:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先最重要的是处理客户端没有任何快照的可能性。如果发生这种情况，这个方法会立即返回。如果我们有可用的快照，下一步是遍历快照容器，找到我们目前处于其中的两个快照（从时间上讲）。通常情况下，这不太可能发生，但请记住，我们渲染的是稍早之前的事情：
- en: '![Implementing the client network class](img/B04284_14_07.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![实现客户端网络类](img/B04284_14_07.jpg)'
- en: The benefit of rendering slightly in the past is that we will actually have
    more data that has arrived from the server, which in turn will allow us to smooth
    it out and provide nicer entity movement. This wouldn't be possible if we simply
    rendered everything in real time. This delay is represented by the `NET_RENDER_DELAY`
    macro.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时稍微滞后带来的好处是，我们实际上将拥有更多来自服务器的数据，这反过来又允许我们平滑处理并提供更佳的实体移动效果。如果我们只是实时渲染一切，这是不可能实现的。这种延迟由`NET_RENDER_DELAY`宏表示。
- en: Once we find the pair of snapshots that we're looking for, a local variable
    called `SortDrawables` is set up to keep track of whether or not we need to worry
    about re-sorting drawable components to represent depth correctly. All of the
    entities from the first (earlier) snapshot are then iterated over. Our first concern
    is making sure that an entity that exists in the snapshot also exists on our client.
    If it doesn't, a new entity is created from the type that the snapshot provides.
    All of its information is then applied to the newly created entity and we skip
    the current iteration of the snapshot loop as there's no need to interpolate anything.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了我们正在寻找的快照对，就设置一个名为`SortDrawables`的局部变量来跟踪我们是否需要担心重新排序可绘制组件以正确表示深度。然后迭代第一个（较早的）快照中的所有实体。我们的首要任务是确保快照中存在的实体也在我们的客户端存在。如果不存在，就根据快照提供的类型创建一个新的实体。然后将其所有信息应用于新创建的实体，并跳过当前快照循环的迭代，因为没有必要进行任何插值。
- en: The next step is making sure that the entity that exists in the earlier snapshot
    also exists in the later one, so an attempt to find it in the second snapshot
    container is made. Provided the entity has not been found, the client mutex is
    locked and the entity is removed from our client, prior to actually being erased
    from the snapshot container as well. The current iteration is then skipped, as
    we have no reason to interpolate once again.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确保在较早的快照中存在的实体也在较后的快照中存在，因此尝试在第二个快照容器中找到它的尝试被做出。如果实体尚未找到，客户端互斥锁被锁定，实体从我们的客户端移除，在实际上从快照容器中删除之前。然后跳过当前迭代，因为我们没有理由再次进行插值。
- en: If all of these checks yield no reason for us to skip an iteration, a new instance
    of `EntitySnapshot` is created. This is going to be our target for holding interpolated
    data. `InterpolateSnapshot` is then called with both snapshots and their time
    values, as well as the target snapshot and the current time *with the interpolation
    delay* factored in is passed in as arguments. After the target snapshot is filled
    in with the interpolated data, it is applied to the current entity. We also want
    to compare both snapshots we're interpolating between and set the `SortDrawables`
    variable to `true` if they have different positions. After all of the entity interpolation
    code, this variable is checked and the system renderer is instructed to re-sort
    the drawable components if it was indeed set to `true` at some point.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些检查都没有给出我们跳过迭代的理由，就会创建一个新的`EntitySnapshot`实例。这将是我们用来保存插值数据的对象。然后，使用两个快照及其时间值，以及考虑了插值延迟的目标快照和当前时间作为参数调用`InterpolateSnapshot`。在目标快照用插值数据填充后，它被应用于当前实体。我们还想比较我们正在插值之间的两个快照，如果它们的位置不同，则将`SortDrawables`变量设置为`true`。在所有实体插值代码之后，检查这个变量，并指示系统渲染器如果它确实在某处被设置为`true`，则重新排序可绘制组件。
- en: One last thing to take away from this is that if the time checking conditional
    in the very first loop ends up not being satisfied, the first element in the snapshot
    container is erased and the iterator is reset to point to the second value in
    it, ensuring a proper disposal of irrelevant snapshots.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点我们可以得到的最后一点是，如果第一个循环中的时间检查条件最终没有得到满足，快照容器中的第一个元素将被删除，迭代器将被重置，指向其中的第二个值，确保无关快照得到适当的处理。
- en: Client entity and system management
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端实体和系统管理
- en: 'Quite predictably, we''re going to have different types of components and systems
    available on the client side than the server side, starting with component types:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易预测，我们在客户端侧将拥有与服务器侧不同的组件和系统类型，首先是组件类型：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After making sure all client-relevant component types are registered, let''s
    implement our own version of loading an entity here, as it involves manipulating
    the renderable components it may have:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保所有与客户端相关的组件类型都已注册后，让我们在这里实现我们自己的加载实体版本，因为它涉及到操作它可能具有的可渲染组件：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have already seen this code in previous chapters, but it's still fair to
    emphasize that the highlighted snippet does not exist on the server side at all,
    yet is necessary here.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中看到了这段代码，但仍然有理由强调，高亮显示的代码片段在服务器端根本不存在，但在这里是必要的。
- en: 'Next, the client''s version of a system manager:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，客户端的系统管理器版本：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Naturally, the only additions we have here are, once again, related to graphics.
    We wouldn't need to draw anything on the server side, but it's necessary here.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们在这里所做的唯一添加，再次强调，与图形相关。我们不需要在服务器端绘制任何东西，但在这里是必要的。
- en: 'The constructor of our client system manager handles adding systems that are
    relevant to the client performing as intended:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端系统管理器的构造函数处理添加与客户端预期表现相关的系统：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note the placement of the network system here. The order of adding these systems
    directly dictates the order in which they are updated. We don't want our network
    system sending or receiving any data before we get a chance to process our own.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意网络系统在这里的放置。添加这些系统的顺序直接决定了它们更新的顺序。我们不希望我们的网络系统在我们有机会处理我们自己的数据之前发送或接收任何数据。
- en: 'Naturally, getters for texture and font managers would be useful on this side:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，在这个方面，纹理和字体管理器的获取器将是有用的：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, we have a few systems that need to render something on screen:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一些需要在屏幕上渲染的系统：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After the renderer system draws all of the entities on screen, we want to overlay
    their names and health graphics on top of that.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染系统绘制屏幕上的所有实体之后，我们希望在它们上面叠加它们的名称和健康图形。
- en: Putting the pieces into place
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将各个部分放在一起
- en: 'Because all of the networking and action is going to take place solely within
    the confines of the game state, that''s the main class we''re going to adjust,
    starting with the header file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有的网络和动作都将仅在网络状态范围内发生，所以我们将调整的主要类是，从头文件开始：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After making sure that the game state has a pointer to a `Client` instance,
    we must provide a way for the game to handle incoming packets:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保游戏状态有一个指向`Client`实例的指针之后，我们必须为游戏提供处理传入数据包的方法：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: First, we handle the connect packet that the server sends back to us after the
    client tries to reach it. If the entity ID and position were successfully extracted
    from the packet, the client mutex is locked while the player entity is added and
    its position is updated. The entity ID of our player is then stored in the `m_player`
    data member and passed in to our network system, which needs it. Note the very
    last line of code in this segment before we return. After the entity is successfully
    constructed, we're adding in a sound listener component to it. Naturally, there
    can only be one single sound listener on the client side, which is our player.
    This means that the `player.entity` file *does not* have its own sound listener
    component anymore. Instead, it must be added here in order to have correct audio
    positioning.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理服务器在客户端尝试连接后发送回我们的连接数据包。如果成功从数据包中提取了实体ID和位置，则在添加玩家实体并更新其位置时锁定客户端互斥锁。然后，我们的玩家实体的实体ID存储在`m_player`数据成员中，并传递给需要它的网络系统。注意在这个段落的最后几行代码，在我们返回之前。在实体成功构建后，我们向其添加一个声音监听器组件。自然地，客户端只能有一个声音监听器，那就是我们的玩家。这意味着`player.entity`文件*不再*有自己的声音监听器组件。相反，它必须在这里添加，以便正确进行音频定位。
- en: Next, if our client is already connected to the server, we're ready to process
    snapshot, hurt, and disconnect packets. If a snapshot is received, we first attempt
    to read the number of entities it contains and return if the reading fails. The
    client mutex is then locked and the current time is obtained in order to maintain
    continuity of entity snapshots. A new `for` loop is then constructed to run for
    each individual entity in the packet and extract its ID and snapshot data, which
    in turn is added to the network system for later processing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们的客户端已经连接到服务器，我们就准备好处理快照、伤害和断开连接的数据包。如果收到快照，我们首先尝试读取其中包含的实体数量，如果读取失败则返回。然后锁定客户端互斥锁并获取当前时间，以保持实体快照的连续性。接着构建一个新的`for`循环，为数据包中的每个单独实体运行，提取其ID和快照数据，这些数据随后被添加到网络系统中以供后续处理。
- en: If a disconnect packet is received from the server, we simply remove the game
    state and switch back to the main menu. Also, upon receiving a hurt packet, the
    entity ID in it is extracted and a `Hurt` message that is to be received by that
    entity is created and sent out.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从服务器接收到断开连接的数据包，我们只需移除游戏状态并切换回主菜单。此外，在接收到伤害数据包时，从中提取实体ID，并创建一个要由该实体接收的`Hurt`消息，然后发送出去。
- en: 'Now, it''s time to adjust the existing methods of our game state in order to
    have it try to establish a connection to the server upon creation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候调整我们游戏状态中的现有方法，以便它在创建时尝试连接到服务器：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, the client's packet handler is assigned. We then attempt to connect to
    the server with whatever IP and port information exist inside the client class
    at this point. If the connection attempt was successful, we can start initializing
    our data members and add callbacks, one of which is a callback to a new method
    that handles the player attack button being pressed. If the connection wasn't
    successful, the game state is removed and we switch back to the main menu state
    instead.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，分配客户端的数据包处理器。然后，我们尝试使用客户端类中现有的IP和端口信息连接到服务器。如果连接尝试成功，我们可以开始初始化我们的数据成员并添加回调，其中一个回调是处理玩家攻击按钮被按下的新方法。如果连接尝试失败，则移除游戏状态并切换回主菜单状态。
- en: 'If the game state is removed, some cleanup is in order:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移除游戏状态，需要进行一些清理工作：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In addition to the rest of the code that cleans up the game state, we must now
    also disconnect from the server and unregister the packet handler that is being
    used by the client class. The network system is also cleared of all snapshots
    it may currently hold, as well as any player information and pointers to the client
    class. The player attack callback is also removed here.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除了清理游戏状态的其余代码之外，我们现在还必须断开与服务器的连接并注销客户端类使用的包处理器。网络系统也被清除了它可能持有的所有快照，以及任何玩家信息和指向客户端类的指针。玩家攻击回调也在这里被移除。
- en: 'Naturally, we''re going to want to alter the `Update` method of the game state
    a little as well:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们还想稍微调整游戏状态的`Update`方法：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The connection status of our client is first checked. Not being connected means
    we get to exit the game state and switch back to the main menu once again. Otherwise,
    we continue on with the updating. Note the curly brackets surrounding the system
    manager update call. They create a scope for any variables defined inside, which
    is useful for locking the client mutex with a `sf::Lock` instance, as it will
    fall out of scope once we're outside the brackets, in turn unlocking it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查客户端的连接状态。未连接意味着我们可以退出游戏状态并再次切换回主菜单。否则，我们继续更新。注意系统管理器更新调用周围的括号。它们为内部定义的任何变量创建了一个作用域，这对于使用`sf::Lock`实例锁定客户端互斥锁很有用，因为一旦我们离开括号，它就会超出作用域，从而解锁。
- en: 'Drawing things on screen also needs a slight adjustment:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制东西也需要稍作调整：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The only addition here is the client mutex lock right before we draw entities
    on different elevations in a `for` loop. We don't want another thread to manipulate
    any data that we may be currently accessing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的添加是在`for`循环中绘制不同高度的实体之前，添加客户端互斥锁。我们不希望另一个线程操作我们可能正在访问的任何数据。
- en: 'Lastly, the player attack button being pressed needs to be handled like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要像这样处理玩家攻击按钮被按下的事件：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: It's quite simple. When an attack key is pressed, the entity component system
    has a new attack message sent to it. Our network system is subscribed to this
    message type and adds it to the player update container, which is going to be
    sent out to the server at a specific interval.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。当按下攻击键时，实体组件系统会收到一个新的攻击消息。我们的网络系统订阅了这种消息类型，并将其添加到玩家更新容器中，该容器将在特定的时间间隔内发送到服务器。
- en: Main menu adjustments
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主菜单调整
- en: 'Our client-server setup is now functional, but we are missing one more small
    addition in order to really make it work. We have no way of putting in our server
    information! Let''s fix that by modifying the main menu interface file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的客户端-服务器设置已经可以正常工作，但我们还需要添加一个小功能才能使其真正运作。我们无法输入服务器信息！让我们通过修改主菜单界面文件来解决这个问题：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Quite a few new elements are added to the main menu here. We have three new
    text fields and some text labels that go next to them to let the user know what
    they''re for. This is how server information, as well as the player nickname,
    is going to be entered. Let''s make this happen by adding a few callbacks for
    the new buttons:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，主菜单中添加了许多新元素。我们有三个新的文本字段和一些与之相邻的文本标签，以便让用户知道它们的作用。这就是服务器信息和玩家昵称将被输入的方式。让我们通过为这些新按钮添加一些回调来实现这一点：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To make the main menu feel interactive, we''re going to want to update this
    interface each time the menu state is activated:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让主菜单感觉更具互动性，我们希望在每次激活菜单状态时更新这个界面：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Depending on whether a game state exists or not, we set up the elements in our
    interface to reflect the current state of our connection.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 根据是否存在游戏状态，我们在界面中设置元素以反映我们当前连接的状态。
- en: 'Lastly, let''s look at the callback methods of both connect and disconnect
    buttons:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看连接和断开连接按钮的回调方法：
- en: '[PRE74]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The first check in the `Play` method is made to ensure the text field information
    is properly passed in to where it needs to go. Because we have the same button
    that's going to be pressed to both connect to the server and switch back to the
    game state once it exists, making sure the client instance's server and player
    name information is updated is important. We then switch to the game state, which
    could either mean that it has to be created, at which time the information we
    just passed in is used, or that it's simply brought back to being the dominant
    application state.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Play`方法中的第一次检查是为了确保文本字段信息被正确传递到需要的地方。因为我们有一个相同的按钮，既可以用来连接服务器，也可以在存在游戏状态时切换回游戏状态，确保客户端实例的服务器和玩家名称信息得到更新是很重要的。然后我们切换到游戏状态，这可能意味着需要创建它，这时我们会使用刚刚传递的信息，或者它只是简单地恢复为占主导地位的应用程序状态。
- en: The disconnect button callback only invokes the client's `Disconnect` method,
    which in turn results to the game state terminating itself.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 断开连接按钮的回调函数仅调用客户端的`Disconnect`方法，这反过来会导致游戏状态自行终止。
- en: With that, we have a fully functional 2D multiplayer game where players can
    attack one another!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就拥有了一个功能齐全的2D多人游戏，玩家可以互相攻击了！
- en: '![Main menu adjustments](img/B04284_14_08.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![主菜单调整](img/B04284_14_08.jpg)'
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You have made it to the end! It has been quite a journey to
    take. With nothing more than some basic tools and concentrated effort, we have
    managed to create a small world. It may not have that much content in it, but
    that's where you come in. Just because you are done reading this book doesn't
    mean that either one of the three projects we covered is finished. In fact, this
    is only the beginning. Although we have covered a lot, there's still a plethora
    of features that you can implement on your own, such as different types of enemies,
    selectable player skins for the last project, magic and ranged attacks, animated
    map tiles, map transitions for the last project, a chat system, levels and experience
    for our RPG, and much more. Undoubtedly, you must have your own ideas and mechanics
    in mind that should instead be brought forth and realized in your games. Don't
    stop now; keep the flow going and get to coding!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经到达了终点！这是一段相当漫长的旅程。我们凭借一些基本工具和集中精力，成功地创造了一个小世界。它可能内容并不多，但这就是您的用武之地。仅仅因为您读完了这本书，并不意味着我们讨论的三个项目中的任何一个已经完成。实际上，这只是一个开始。尽管我们已经覆盖了很多内容，但仍有大量功能等待您自己实现，例如不同类型的敌人、可选的玩家皮肤、最后项目的魔法和远程攻击、动画地图块、最后项目的地图过渡、聊天系统、我们的RPG的等级和经验值，以及更多。毫无疑问，您一定有自己的想法和机制，这些想法和机制应该被提出并在您的游戏中实现。现在不要停下来；保持流畅并开始编码！
- en: Thank you so much for reading, and remember that ultimately whatever becomes
    of the world we created is in your hands, so make it a good one. Goodbye!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢您阅读，请记住，最终我们创造的这个世界的走向掌握在您的手中，所以请让它变得美好。再见！
