- en: Chapter 1. LLVM Design and Use
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. LLVM设计和使用
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding modular design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块化设计
- en: Cross-compiling Clang/LLVM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译Clang/LLVM
- en: Converting a C source code to LLVM assembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将C源代码转换为LLVM汇编
- en: Converting IR to LLVM bitcode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将IR转换为LLVM位码
- en: Converting LLVM bitcode to target machine assembly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将LLVM位码转换为目标机器汇编
- en: Converting LLVM bitcode back to LLVM assembly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将LLVM位码转换回LLVM汇编
- en: Transforming LLVM IR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换LLVM IR
- en: Linking LLVM bitcode
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接LLVM位码
- en: Executing LLVM bitcode
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行LLVM位码
- en: Using C frontend Clang
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C前端Clang
- en: Using the GO frontend
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GO前端
- en: Using DragonEgg
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DragonEgg
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this recipe, you get to know about **LLVM**, its design, and how we can make
    multiple uses out of the various tools it provides. You will also look into how
    you can transform a simple C code to the LLVM intermediate representation and
    how you can transform it into various forms. You will also learn how the code
    is organized within the LLVM source tree and how can you use it to write a compiler
    on your own later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解**LLVM**，它的设计和如何利用它提供的各种工具进行多种用途。你还将了解如何将简单的C代码转换为LLVM中间表示，以及如何将其转换为各种形式。你还将学习代码如何在LLVM源树中组织，以及如何使用它来编写你自己的编译器。
- en: Understanding modular design
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块化设计
- en: LLVM is designed as a set of libraries unlike other compilers such as **GNU
    Compiler Collection** (**GCC**). In this recipe, LLVM optimizer will be used to
    understand this design. As LLVM optimizer's design is library-based, it allows
    you to order the passes to be run in a specified order. Also, this design allows
    you to choose which optimization passes you can run—that is, there might be a
    few optimizations that might not be useful to the type of system you are designing,
    and only a few optimizations will be specific to the system. When looking at traditional
    compiler optimizers, they are built as a tightly interconnected mass of code,
    that is difficult to break down into small parts that you can understand and use
    easily. In LLVM, you need not know about how the whole system works to know about
    a specific optimizer. You can just pick one optimizer and use it without having
    to worry about other components attached to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM被设计成一套库，与其他编译器（如**GNU编译器集合**（**GCC**））不同。在这个菜谱中，我们将使用LLVM优化器来理解这个设计。由于LLVM优化器的设计是基于库的，它允许你以指定的顺序排列要运行的传递。此外，这种设计允许你选择可以运行的优化传递——也就是说，可能有一些优化对于你正在设计的系统类型可能没有用，只有少数优化是特定于该系统的。在查看传统的编译器优化器时，它们被构建成一个紧密相连的代码块，这使得很难将其分解成你可以轻松理解和使用的较小部分。在LLVM中，你不需要了解整个系统的工作原理，就可以了解一个特定的优化器。你可以只选择一个优化器并使用它，而无需担心与之相连的其他组件。
- en: 'Before we go ahead and look into this recipe, we must also know a little about
    LLVM assembly language. The LLVM code is represented in three forms: in memory
    compiler **Intermediate Representation** (**IR**), on disk bitcode representation,
    and as human readable assembly. LLVM is a **Static Single Assignment** (**SSA**)-based
    representation that provides type safety, low level operations, flexibility, and
    the capability to represent all the high-level languages cleanly. This representation
    is used throughout all the phases of LLVM compilation strategy. The LLVM representation
    aims to be a universal IR by being at a low enough level that high-level ideas
    may be cleanly mapped to it. Also, LLVM assembly language is well formed. If you
    have any doubts about understanding the LLVM assembly mentioned in this recipe,
    refer to the link provided in the *See* *also* section at the end of this recipe.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入了解这个菜谱之前，我们还必须了解一些关于LLVM汇编语言的知识。LLVM代码以三种形式表示：内存中的编译器**中间表示**（**IR**）、磁盘上的位码表示，以及人类可读的汇编。LLVM是一个基于**静态单赋值**（**SSA**）的表示，它提供了类型安全、低级操作、灵活性和表示所有高级语言的清洁能力。这种表示在整个LLVM编译策略的所有阶段都得到使用。LLVM表示旨在成为一个通用的IR，因为它处于足够低的级别，使得高级思想可以干净地映射到它。此外，LLVM汇编语言是格式良好的。如果你对菜谱中提到的LLVM汇编有任何疑问，请参考菜谱末尾的*也见*部分提供的链接。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We must have installed the LLVM toolchain on our host machine. Specifically,
    we need the `opt` tool.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在我们的主机机器上安装LLVM工具链。具体来说，我们需要`opt`工具。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will run two different optimizations on the same code, one-by-one, and see
    how it modifies the code according to the optimization we choose.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对相同的代码运行两种不同的优化，一个接一个，看看它如何根据我们选择的优化来修改代码。
- en: First of all, let us write a code we can input for these optimizations. Here
    we will write it into a file named `testfile.ll:`
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个可以输入这些优化的代码。这里我们将将其写入一个名为 `testfile.ll:` 的文件中。
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, run the `opt` tool for one of the optimizations—that is, for combining
    the instruction:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行 `opt` 工具进行其中一个优化——即，用于合并指令：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'View the output to see how `instcombine` has worked:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出以了解 `instcombine` 的工作情况：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the opt command for dead argument elimination optimization:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `opt` 命令进行无效参数消除优化：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'View the output, to see how `deadargelim` has worked:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出，以了解 `deadargelim` 的工作情况：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the preceding example, we can see that, for the first command, the `instcombine`
    pass is run, which combines the instructions and hence optimizes `%B = add i32
    %A, 0; ret i32 %B` to `ret i32 %A` without affecting the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到，对于第一个命令，运行了 `instcombine` 过滤器，它合并了指令，因此将 `%B = add i32 %A, 0;
    ret i32 %B` 优化为 `ret i32 %A`，而不影响代码。
- en: In the second case, when the `deadargelim pass` is run, we can see that there
    is no modification in the first function, but the part of code that was not modified
    last time gets modified with the function arguments that are not used getting
    eliminated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，当运行 `deadargelim 过滤器` 时，我们可以看到第一个函数没有修改，但上次未修改的代码部分现在被修改了，未使用的函数参数被消除。
- en: LLVM optimizer is the tool that provided the user with all the different passes
    in LLVM. These passes are all written in a similar style. For each of these passes,
    there is a compiled object file. Object files of different passes are archived
    into a library. The passes within the library are not strongly connected, and
    it is the LLVM **PassManager** that has the information about dependencies among
    the passes, which it resolves when a pass is executed. The following image shows
    how each pass can be linked to a specific object file within a specific library.
    In the following figure, the **PassA** references **LLVMPasses.a** for **PassA.o**,
    whereas the custom pass refers to a different library **MyPasses.a** for the **MyPass.o**
    object file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 优化器是提供给用户所有不同过滤步骤的工具。这些过滤步骤都是用类似风格编写的。对于这些过滤步骤中的每一个，都有一个编译后的目标文件。不同过滤步骤的目标文件被存档到一个库中。库中的过滤步骤不是强连接的，LLVM
    **PassManager** 拥有关于过滤步骤之间依赖关系的信息，它在执行过滤步骤时解决这些依赖关系。以下图像显示了每个过滤步骤如何链接到特定库中的特定目标文件。在以下图中，**PassA**
    引用了 **LLVMPasses.a** 中的 **PassA.o**，而自定义过滤步骤则引用了不同的库 **MyPasses.a** 中的 **MyPass.o**
    目标文件。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: '![How it works...](img/image00251.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image00251.jpeg)'
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Similar to the optimizer, the LLVM code generator also makes use of its modular
    design, splitting the code generation problem into individual passes: instruction
    selection, register allocation, scheduling, code layout optimization, and assembly
    emission. Also, there are many built-in passes that are run by default. It is
    up to the user to choose which passes to run.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与优化器类似，LLVM 代码生成器也利用其模块化设计，将代码生成问题分解为单个过滤步骤：指令选择、寄存器分配、调度、代码布局优化和汇编输出。此外，还有许多默认运行的内置过滤步骤。用户可以选择运行哪些过滤步骤。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: In the upcoming chapters, we will see how to write our own custom pass, where
    we can choose which of the optimization passes we want to run and in which order.
    Also, for a more detailed understanding, refer to [http://www.aosabook.org/en/llvm.html](http://www.aosabook.org/en/llvm.html).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何编写我们自己的自定义过滤步骤，其中我们可以选择运行哪些优化过滤步骤以及它们的顺序。此外，为了更深入的了解，请参阅 [http://www.aosabook.org/en/llvm.html](http://www.aosabook.org/en/llvm.html)。
- en: To understand more about LLVM assembly language, refer to [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关 LLVM 汇编语言的更多信息，请参阅 [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html)。
- en: Cross-compiling Clang/LLVM
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译 Clang/LLVM
- en: By cross-compiling we mean building a binary on one platform (for example, x86)
    that will be run on another platform (for example, ARM). The machine on which
    we build the binary is called the host, and the machine on which the generated
    binary will run is called the target. The compiler that builds code for the same
    platform on which it is running (the host and target platforms are the same) is
    called a **native assembler**, whereas the compiler that builds code for a target
    platform different from the host platform is called a **cross**-**compiler**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交叉编译，我们指的是在一个平台上（例如，x86）构建一个将在另一个平台上（例如，ARM）运行的二进制文件。我们构建二进制文件的机器称为宿主，而生成二进制文件将要运行的机器称为目标。为运行在其上的同一平台构建代码的编译器（宿主和目标平台相同）称为**原生汇编器**，而为宿主平台不同的目标平台构建代码的编译器称为**交叉**编译器。
- en: In this recipe, cross-compilation of LLVM for a platform different than the
    host platform will be shown, so that you can use the built binaries for the required
    target platform. Here, cross-compiling will be shown using an example where cross-compilation
    from host platform x86_64 for target platform ARM will be done. The binaries thus
    generated can be used on a platform with ARM architecture.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，将展示为不同于宿主平台的平台交叉编译 LLVM，这样您就可以使用为所需目标平台构建的二进制文件。在这里，将通过一个示例来展示交叉编译，即从宿主平台
    x86_64 交叉编译到目标平台 ARM。生成的二进制文件可以在具有 ARM 架构的平台中使用。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following packages need to be installed on your system (host platform):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件包需要在您的系统（宿主平台）上安装：
- en: '`cmake`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`'
- en: '`ninja-build` (from backports in Ubuntu)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ninja-build`（来自 Ubuntu 的 backports）'
- en: '`gcc-4.x-arm-linux-gnueabihf`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc-4.x-arm-linux-gnueabihf`'
- en: '`gcc-4.x-multilib-arm-linux-gnueabihf`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc-4.x-multilib-arm-linux-gnueabihf`'
- en: '`binutils-arm-linux-gnueabihf`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binutils-arm-linux-gnueabihf`'
- en: '`libgcc1-armhf-cross`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libgcc1-armhf-cross`'
- en: '`libsfgcc1-armhf-cross`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libsfgcc1-armhf-cross`'
- en: '`libstdc++6-armhf-cross`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libstdc++6-armhf-cross`'
- en: '`libstdc++6-4.x-dev-armhf-cross`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libstdc++6-4.x-dev-armhf-cross`'
- en: '`install llvm on your host platform`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`在您的宿主平台上安装 llvm`'
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To compile for the ARM target from the host architecture, that is **X86_64**
    here, you need to perform the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要从宿主架构（即此处为 **X86_64**）编译 ARM 目标，需要执行以下步骤：
- en: 'Add the following `cmake` flags to the normal `cmake` build for LLVM:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `cmake` 标志添加到 LLVM 的正常 `cmake` 构建中：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If using your platform compiler, run:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用你的平台编译器，请运行：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If using Clang as the cross-compiler, run:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果使用 Clang 作为交叉编译器，请运行：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you have clang/Clang++ on the path, it should work fine.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的路径上有 clang/Clang++，它应该可以正常工作。
- en: 'To build LLVM, simply type:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建 LLVM，只需输入：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the LLVM/Clang has built successfully, install it with the following
    command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 LLVM/Clang 构建成功后，使用以下命令安装它：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create a `sysroot` on the `install-dir` location if you have specified
    the `DCMAKE_INSTALL_PREFIX` options
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已指定 `DCMAKE_INSTALL_PREFIX` 选项，这将创建 `install-dir` 位置的 `sysroot`。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `cmake` package builds the toolchain for the required platform by making
    the use of option flags passed to `cmake`, and the `tblgen` tools are used to
    translate the target description files into C++ code. Thus, by using it, the information
    about targets is obtained, for example—what instructions are available on the
    target, the number of registers, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake` 软件包通过使用传递给 `cmake` 的选项标志来构建所需平台的工具链，并且使用 `tblgen` 工具将目标描述文件转换为 C++
    代码。因此，通过使用它，可以获得有关目标的信息，例如——目标上可用的指令、寄存器数量等等。'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If Clang is used as the cross-compiler, there is a problem in the LLVM ARM backend
    that produces absolute relocations on **position-independent code** (**PIC**),
    so as a workaround, disable PIC at the moment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Clang 作为交叉编译器，LLVM ARM 后端存在一个问题，在**位置无关代码**（**PIC**）上产生绝对重定位，因此作为解决方案，暂时禁用
    PIC。
- en: The ARM libraries will not be available on the host system. So, either download
    a copy of them or build them on your system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 库在宿主系统上不可用。因此，要么下载它们的副本，要么在您的系统上构建它们。
- en: Converting a C source code to LLVM assembly
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 C 源代码转换为 LLVM 汇编代码
- en: Here we will convert a C code to intermediate representation in LLVM using the
    C frontend Clang.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 C 前端 Clang 将 C 代码转换为 LLVM 的中间表示。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Clang must be installed in the PATH.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 必须安装到 PATH 中。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Lets create a C code in the `multiply.c` file, which will look something like
    the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `multiply.c` 文件中创建一个 C 代码，它看起来可能如下所示：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the following command to generate LLVM IR from the C code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从 C 代码生成 LLVM IR：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Have a look at the generated IR:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看生成的 IR：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use the `cc1` for generating IR:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用 `cc1` 生成 IR：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process of C code getting converted to IR starts with the process of lexing,
    wherein the C code is broken into a token stream, with each token representing
    an Identifier, Literal, Operator, and so on. This stream of tokens is fed to the
    parser, which builds up an abstract syntax tree with the help of **Context free
    grammar** (**CFG**) for the language. Semantic analysis is done afterwards to
    check whether the code is semantically correct, and then we generate code to IR.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C 代码转换为 IR 的过程始于词法分析过程，其中 C 代码被分解成一个标记流，每个标记代表一个标识符、字面量、运算符等。这个标记流被送入解析器，在语言的帮助下使用**上下文无关文法**（**CFG**）构建一个抽象语法树。之后进行语义分析以检查代码是否语义正确，然后我们生成代码到
    IR。
- en: Here we use the Clang frontend to generate the IR file from C code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 Clang 前端从 C 代码生成 IR 文件。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In the next chapter, we will see how the lexer and parser work and how code
    generation is done. To understand the basics of LLVM IR, you can refer to [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到词法分析和解析器是如何工作的，以及代码生成是如何进行的。要了解 LLVM IR 的基础知识，可以参考 [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html)。
- en: Converting IR to LLVM bitcode
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 IR 转换为 LLVM 位码
- en: 'In this recipe, you will learn to generate LLVM bit code from IR. The LLVM
    bit code file format (also known as bytecode) is actually two things: a bitstream
    container format and an encoding of LLVM IR into the container format.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何从 IR 生成 LLVM 位码。LLVM 位码文件格式（也称为字节码）实际上是两件事：一个位流容器格式和将 LLVM IR 编码到容器格式中的编码。
- en: Getting Ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `llvm-as` tool must be installed in the PATH.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-as` 工具必须安装到 PATH 中。'
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Do the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First create an IR code that will be used as input to `llvm-as`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个将被用作 `llvm-as` 输入的 IR 代码：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To convert LLVM IR in `test.ll` to bitcode format, you need to use the following
    command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `test.ll` 中的 LLVM IR 转换为位码格式，你需要使用以下命令：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output is generated in the `test.bc` file, which is in bit stream format;
    so, when we want to have a look at output in text format, we get it as shown in
    the following screenshot:![How to do it...](img/image00252.jpeg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出生成在 `test.bc` 文件中，该文件为位流格式；因此，当我们想以文本格式查看输出时，我们得到如下截图所示：![如何做...](img/image00252.jpeg)
- en: 'Since this is a bitcode file, the best way to view its content would be by
    using the `hexdump` tool. The following screenshot shows the output of `hexdump`:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这是一个位码文件，查看其内容最好的方式是使用 `hexdump` 工具。以下截图显示了 `hexdump` 的输出：
- en: '![How to do it...](img/image00253.jpeg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image00253.jpeg)'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `llvm-as` is the LLVM assembler. It converts the LLVM assembly file that
    is the LLVM IR into LLVM bitcode. In the preceding command, it takes the `test.ll`
    file as the input and outputs, and `test.bc` as the bitcode file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-as` 是 LLVM 汇编器。它将 LLVM 汇编文件（即 LLVM IR）转换为 LLVM 位码。在上面的命令中，它以 `test.ll`
    文件作为输入和输出，并以 `test.bc` 作为位码文件。'
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To encode LLVM IR into bitcode, the concept of blocks and records is used. Blocks
    represent regions of bitstream, for example—a function body, symbol table, and
    so on. Each block has an ID specific to its content (for example, function bodies
    in LLVM IR are represented by ID 12). Records consist of a record code and an
    integer value, and they describe the entities within the file such as instructions,
    global variable descriptors, type descriptions, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 LLVM IR 编码为位码，使用了块和记录的概念。块代表位流的区域，例如——函数体、符号表等。每个块都有一个特定于其内容的 ID（例如，LLVM
    IR 中的函数体由 ID 12 表示）。记录由一个记录代码和一个整数值组成，它们描述了文件中的实体，如指令、全局变量描述符、类型描述等。
- en: Bitcode files for LLVM IR might be wrapped in a simple wrapper structure. This
    structure contains a simple header that indicates the offset and size of the embedded
    BC file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR 的位码文件可能被一个简单的包装结构所封装。这个结构包含一个简单的头部，指示嵌入的 BC 文件的偏移量和大小。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To get a detailed understanding of the LLVM the bitstream file format, refer
    to [http://llvm.org/docs/BitCodeFormat.html#abstract](http://llvm.org/docs/BitCodeFormat.html#abstract)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要详细了解 LLVM 位流文件格式，请参阅 [http://llvm.org/docs/BitCodeFormat.html#abstract](http://llvm.org/docs/BitCodeFormat.html#abstract)
- en: Converting LLVM bitcode to target machine assembly
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 LLVM 位码转换为目标机器汇编
- en: In this recipe, you will learn how to convert the LLVM bitcode file to target
    specific assembly code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何将 LLVM 位码文件转换为特定目标的汇编代码。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The LLVM static compiler `llc` should be in installed from the LLVM toolchain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: The LLVM 静态编译器 `llc` 应该是从 LLVM 工具链中安装的。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Do the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The bitcode file created in the previous recipe, `test.bc,` can be used as
    input to `llc` here. Using the following command, we can convert LLVM bitcode
    to assembly code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的食谱中创建的位码文件 `test.bc`，可以用作 `llc` 的输入。使用以下命令，我们可以将 LLVM 位码转换为汇编代码：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is generated in the `test.s` file, which is the assembly code. To
    have a look at that, use the following command lines:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出文件生成在 `test.s` 文件中，这是汇编代码。要查看它，请使用以下命令行：
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also use Clang to dump assembly code from the bitcode file format.
    By passing the `–S` option to Clang, we get `test.s` in assembly format when the
    `test.bc` file is in bitstream file format:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用 Clang 从位码文件格式中转储汇编代码。通过传递 `–S` 选项给 Clang，当 `test.bc` 文件处于位流文件格式时，我们得到
    `test.s` 的汇编格式：
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `test.s` file output is the same as that of the preceding example. We use
    the additional option `fomit-frame-pointer`, as Clang by default does not eliminate
    the frame pointer whereas `llc` eliminates it by default.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出的 `test.s` 文件与前面的示例相同。我们使用额外的选项 `fomit-frame-pointer`，因为 Clang 默认不消除帧指针，而
    `llc` 默认消除它。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `llc` command compiles LLVM input into assembly language for a specified
    architecture. If we do not mention any architecture as in the preceding command,
    the assembly will be generated for the host machine where the `llc` command is
    being used. To generate executable from this assembly file, you can use assembler
    and linker.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`llc` 命令将指定架构的 LLVM 输入编译成汇编语言。如果我们没有在前面命令中提及任何架构，汇编代码将为 `llc` 命令正在使用的宿主机器生成。要从汇编文件生成可执行文件，您可以使用汇编器和链接器。'
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: By specifying `-march=architecture flag` in the preceding command, you can specify
    the target architecture for which the assembly needs to be generated. Using the
    `-mcpu=cpu flag` setting, you can specify a CPU within the architecture to generate
    code. Also by specifying `-regalloc=basic/greedy/fast/pbqp,` you can specify the
    type of register allocation to be used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在前面命令中指定 `-march=architecture` 标志，您可以指定需要生成汇编代码的目标架构。使用 `-mcpu=cpu` 标志设置，您可以指定架构内的
    CPU 以生成代码。还可以通过指定 `-regalloc=basic/greedy/fast/pbqp` 来指定要使用的寄存器分配类型。
- en: Converting LLVM bitcode back to LLVM assembly
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 LLVM 位码转换回 LLVM 汇编
- en: In this recipe, you will convert LLVM bitcode back to LLVM IR. Well, this is
    actually possible using the LLVM disassembler tool called `llvm-dis.`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将把 LLVM 位码转换回 LLVM IR。实际上，这是通过使用名为 `llvm-dis` 的 LLVM 反汇编工具来实现的。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To do this, you need the `llvm-dis` tool installed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，您需要安装 `llvm-dis` 工具。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To see how the bitcode file is getting converted to IR, use the `test.bc` file
    generated in the recipe *Converting IR to LLVM Bitcode*. The `test.bc` file is
    provided as the input to the `llvm-dis` tool. Now proceed with the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看位码文件如何转换为 IR，请使用在“将 IR 转换为 LLVM Bitcode”食谱中生成的 `test.bc` 文件。`test.bc` 文件作为输入提供给
    `llvm-dis` 工具。现在按照以下步骤进行：
- en: 'Using the following command shows how to convert a bitcode file to an the one
    we had created in the IR file:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令显示如何将位码文件转换为我们在 IR 文件中创建的文件：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Have a look at the generated LLVM IR by the following:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是如何生成 LLVM IR：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output `test.ll` file is the same as the one we created in the recipe *Converting
    IR to LLVM Bitcode*.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出文件 `test.ll` 与我们在“将 IR 转换为 LLVM Bitcode”食谱中创建的文件相同。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `llvm-dis` command is the LLVM disassembler. It takes an LLVM bitcode file
    and converts it into LLVM assembly language.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-dis` 命令是 LLVM 反汇编器。它接受一个 LLVM 位码文件并将其转换为 LLVM 汇编语言。'
- en: Here, the input file is `test.bc`, which is transformed to `test.ll` by `llvm-dis`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，输入文件是 `test.bc`，它通过 `llvm-dis` 转换为 `test.ll`。
- en: If the filename is omitted, `llvm-dis` reads its input from standard input.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了文件名，`llvm-dis` 将从标准输入读取其输入。
- en: Transforming LLVM IR
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换 LLVM IR
- en: In this recipe, we will see how we can transform the IR from one form to another
    using the opt tool. We will see different optimizations being applied to IR code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将看到如何使用opt工具将IR从一种形式转换为另一种形式。我们将看到应用于IR代码的不同优化。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have the opt tool installed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装opt工具。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `opt` tool runs the transformation pass as in the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`opt`工具按照以下命令运行变换传递：'
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s take an actual example now. We create the LLVM IR equivalent to the
    C code used in the recipe *Converting a C source code to LLVM assembly*:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一个实际的例子来。我们创建与配方*将C源代码转换为LLVM汇编*中使用的C代码等价的LLVM IR：
- en: '[PRE22]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Converting and outputting it, we get the unoptimized output:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换并输出后，我们得到未优化的输出：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now use the opt tool to transform it to a form where memory is promoted to
    register:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用opt工具将其转换为将内存提升到寄存器的形式：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `opt`, LLVM optimizer, and analyzer tools take the `input.ll` file as the
    input and run the pass `passname` on it. The output after running the pass is
    obtained in the `output.ll` file that contains the IR code after the transformation.
    There can be more than one pass passed to the opt tool.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`opt`、LLVM优化器和分析工具将`input.ll`文件作为输入，并在其上运行`passname`传递。运行传递后的输出保存在包含变换后IR代码的`output.ll`文件中。opt工具可以传递多个传递。'
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: When the `–analyze` option is passed to opt, it performs various analyses of
    the input source and prints results usually on the standard output or standard
    error. Also, the output can be redirected to a file when it is meant to be fed
    to another program.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递`-analyze`选项给opt时，它对输入源执行各种分析，并将结果通常打印到标准输出或标准错误。此外，当输出要被馈送到另一个程序时，可以将输出重定向到文件。
- en: When the –analyze option is not passed to opt, it runs the transformation passes
    meant to optimize the input file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有传递`-analyze`选项给opt时，它运行旨在优化输入文件的变换传递。
- en: 'Some of the important transformations are listed as follows, which can be passed
    as a flag to the opt tool:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的变换，可以作为标志传递给opt工具：
- en: '`adce`: Aggressive Dead Code Elimination'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adce`：激进死代码消除'
- en: '`bb-vectorize`: Basic-Block Vectorization'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bb-vectorize`：基本块向量化'
- en: '`constprop`: Simple constant propagation'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constprop`：简单的常量传播'
- en: '`dce`: Dead Code Elimination'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dce`：删除死代码'
- en: '`deadargelim`: Dead Argument Elimination'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deadargelim`：删除死参数'
- en: '`globaldce`: Dead Global Elimination'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`globaldce`：删除死全局变量'
- en: '`globalopt`: Global Variable Optimizer'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`globalopt`：全局变量优化器'
- en: '`gvn`: Global Value Numbering'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gvn`：全局值编号'
- en: '`inline`: Function Integration/Inlining'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inline`：函数集成/内联'
- en: '`instcombine`: Combine redundant instructions'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instcombine`：合并冗余指令'
- en: '`licm`: Loop Invariant Code Motion'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`licm`：循环不变代码移动'
- en: '`loop`: unswitch: Unswitch loops'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`：unswitch：取消切换循环'
- en: '`loweratomic`: Lower atomic intrinsics to non-atomic form'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loweratomic`：将原子内联函数降低为非原子形式'
- en: '`lowerinvoke`: Lower invokes to calls, for unwindless code generators'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerinvoke`：降低调用到调用，用于无回滚代码生成器'
- en: '`lowerswitch`: Lower SwitchInsts to branches'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerswitch`：将SwitchInsts降低为分支'
- en: '`mem2reg`: Promote Memory to Register'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem2reg`：提升内存到寄存器'
- en: '`memcpyopt`: MemCpy Optimization'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memcpyopt`：MemCpy优化'
- en: '`simplifycfg`: Simplify the CFG'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simplifycfg`：简化CFG'
- en: '`sink`: Code sinking'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sink`：代码下沉'
- en: '`tailcallelim`: Tail Call Elimination'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tailcallelim`：尾调用消除'
- en: Run at least some of the preceding passes to get an understanding of how they
    work. To get to the appropriate source code on which these passes might be applicable,
    go to the `llvm/test/Transforms` directory. For each of the above mentioned passes,
    you can see the test codes. Apply the relevant pass and see how the test code
    is getting modified.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 至少运行前面的一些传递，以了解它们是如何工作的。要到达可能适用于这些传递的适当源代码，请转到`llvm/test/Transforms`目录。对于上述提到的每个传递，您都可以看到测试代码。应用相关的传递，并查看测试代码是如何被修改的。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see the mapping of how C code is converted to IR, after converting the C
    code to IR, as discussed in an earlier recipe *Converting a C source code to LLVM
    assembly*, run the `mem2reg` pass. It will then help you understand how a C instruction
    is getting mapped into IR instructions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看C代码如何转换为IR的映射，在将C代码转换为IR后，如在前面的配方*将C源代码转换为LLVM汇编*中讨论的那样，运行`mem2reg`传递。然后它将帮助您了解C指令是如何映射到IR指令的。
- en: Linking LLVM bitcode
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接LLVM位代码
- en: In this section, you will link previously generated `.bc` files to get one single
    bitcode file containing all the needed references.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将链接之前生成的`.bc`文件，以获得包含所有所需引用的单个位代码文件。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To link the `.bc` files, you need the `llvm-link` tool.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要链接 `.bc` 文件，你需要 `llvm-link` 工具。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Do the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'To show the working of `llvm-link`, first write two codes in different files,
    where one makes a reference to the other:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要展示 `llvm-link` 的工作原理，首先在两个不同的文件中编写两个代码，其中一个引用另一个：
- en: '[PRE25]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the following formats to convert this C code to bitstream file format,
    first convert to `.ll` files, then from `.ll` files to `.bc` files:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下格式将此 C 代码转换为位流文件格式，首先转换为 `.ll` 文件，然后从 `.ll` 文件转换为 `.bc` 文件：
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We get `test1.bc` and `test2.bc` with `test2.bc` making a reference to `func`
    syntax in the `test1.bc` file.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `test1.bc` 和 `test2.bc`，其中 `test2.bc` 引用了 `test1.bc` 文件中的 `func` 语法。
- en: 'Invoke the `llvm-link` command in the following way to link the two LLVM bitcode
    files:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下方式调用 `llvm-link` 命令来链接两个 LLVM 位码文件：
- en: '[PRE27]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We provide multiple bitcode files to the `llvm-link` tool, which links them
    together to generate a single bitcode file. Here, `output.bc` is the generated
    output file. We will execute this bitcode file in the next recipe *Executing LLVM
    bitcode*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `llvm-link` 工具提供多个位码文件，它将它们链接在一起以生成单个位码文件。这里，`output.bc` 是生成的输出文件。我们将在下一个步骤
    *执行 LLVM 位码* 中执行此位码文件。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `llvm-link` works using the basic functionality of a linker—that is, if
    a function or variable referenced in one file is defined in the other file, it
    is the job of linker to resolve all the references made in a file and defined
    in the other file. But note that this is not the traditional linker that links
    various object files to generate a binary. The `llvm-link` tool links bitcode
    files only.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-link` 使用链接器的基本功能——也就是说，如果一个文件中引用的函数或变量在另一个文件中定义，那么链接器的任务是解决文件中所有引用和在另一个文件中定义的内容。但请注意，这并不是传统链接器，它将各种目标文件链接起来生成二进制文件。`llvm-link`
    工具仅链接位码文件。'
- en: In the preceding scenario, it is linking `test1.bc` and `test2.bc` files to
    generate the `output.bc` file, which has references resolved.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的场景中，它是将 `test1.bc` 和 `test2.bc` 文件链接起来生成 `output.bc` 文件，其中引用已解决。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After linking the bitcode files, we can generate the output as an IR file by
    giving `–S` option to the `llvm-link` tool.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接位码文件后，我们可以通过给 `llvm-link` 工具提供 `–S` 选项来生成输出作为 IR 文件。
- en: Executing LLVM bitcode
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 LLVM 位码
- en: In this recipe, you will execute the LLVM bitcode that was generated in previous
    recipes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本步骤中，你将执行先前步骤中生成的 LLVM 位码。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To execute the LLVM bitcode, you need the `lli` tool.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 LLVM 位码，你需要 `lli` 工具。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We saw in the previous recipe how to create a single bitstream file after linking
    the two `.bc` files with one referencing the other to define `func`. By invoking
    the `lli` command in the following way, we can execute the `output.bc` file generated.
    It will display the output on the standard output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的步骤中，我们看到了如何通过将两个 `.bc` 文件链接起来并定义 `func` 来创建单个位流文件。通过以下方式调用 `lli` 命令，我们可以执行生成的
    `output.bc` 文件。它将在标准输出上显示输出：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`The output.bc` file is the input to `lli`, which will execute the bitcode
    file and display the output, if any, on the standard output. Here the output is
    generated as number is `10`, which is a result of the execution of the `output.bc`
    file formed by linking `test1.c` and `test2.c` in the previous recipe. The main
    function in the `test2.c` file calls the function `func` in the `test1.c` file
    with integer 5 as the argument to the function. The `func` function doubles the
    input argument and returns the result to main the function that outputs it on
    the standard output.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`The output.bc` 文件是 `lli` 的输入，它将执行位码文件，并在标准输出上显示任何输出。在这里，输出生成了数字 `10`，这是在先前的步骤中将
    `test1.c` 和 `test2.c` 链接形成的 `output.bc` 文件执行的结果。`test2.c` 文件中的主函数以整数 5 作为参数调用
    `test1.c` 文件中的 `func` 函数。`func` 函数将输入参数加倍，并将结果返回给主函数，主函数将其输出到标准输出。'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `lli` tool command executes the program present in LLVM bitcode format.
    It takes the input in LLVM bitcode format and executes it using a just-in-time
    compiler, if there is one available for the architecture, or an interpreter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`lli` 工具命令执行以 LLVM 位码格式存在的程序。它接受以 LLVM 位码格式输入，并使用即时编译器执行它，如果架构有可用的即时编译器，或者使用解释器。'
- en: If `lli` is making use of a just-in-time compiler, then it effectively takes
    all the code generator options as that of `llc`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `lli` 正在使用即时编译器，那么它实际上将所有代码生成器选项视为 `llc` 的选项。
- en: See also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding JIT support for a language* recipe in [Chapter 3](part0041.xhtml#aid-173721
    "Chapter 3. Extending the Frontend and Adding JIT Support"), *Extending the Frontend
    and Adding JIT support*.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](part0041.xhtml#aid-173721 "第3章。扩展前端和添加JIT支持")的*扩展前端和添加JIT支持*的*为语言添加JIT支持*菜谱中。
- en: Using the C frontend Clang
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C前端Clang
- en: In this recipe, you will get to know how the Clang frontend can be used for
    different purposes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解如何使用Clang前端实现不同的目的。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need Clang tool.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要Clang工具。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Clang can be used as the high-level compiler driver. Let us show it using an
    example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Clang可以用作高级编译器驱动程序。让我们用一个例子来展示它：
- en: 'Create a `hello world` C code, `test.c`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`hello world` C代码，`test.c`：
- en: '[PRE29]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use Clang as a compiler driver to generate the executable `a.out` file, which
    on execution gives the output as expected:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Clang作为编译器驱动程序生成可执行文件`a.out`，执行时给出预期的输出：
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here the `test.c` file containing C code is created. Using Clang we compile
    it and produce an executable that on execution gives the desired result.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里创建了包含C代码的`test.c`文件。使用Clang编译它并生成一个可执行文件，执行时给出期望的结果。
- en: 'Clang can be used in preprocessor only mode by providing the `–E` flag. In
    the following example, create a C code having a #define directive defining the
    value of MAX and use this MAX as the size of the array you are going to create:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过提供`–E`标志来仅使用Clang的预处理器模式。在以下示例中，创建一个包含`#define`指令定义MAX值的C代码，并使用此MAX作为你将要创建的数组的大小：
- en: '[PRE31]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the preprocessor using the following command, which gives the output on
    standard output:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行预处理器，该命令在标准输出上显示输出：
- en: '[PRE32]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `test.c` file, which will be used in all the subsequent sections of this
    recipe, MAX is defined to be `100`, which on preprocessing is substituted to MAX
    in `a[MAX]`, which becomes `a[100]`.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本菜谱的所有后续部分中都将使用的`test.c`文件中，MAX被定义为`100`，在预处理过程中被替换为`a[MAX]`中的MAX，变为`a[100]`。
- en: 'You can print the AST for the `test.c` file from the preceding example using
    the following command, which displays the output on standard output:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令从先前的示例中打印`test.c`文件的AST，该命令在标准输出上显示输出：
- en: '[PRE33]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the `–cc1` option ensures that only the compiler front-end should be run,
    not the driver, and it prints the AST corresponding to the `test.c` file code.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`–cc1`选项确保只运行编译器前端，而不是驱动程序，并打印与`test.c`文件代码对应的AST。
- en: 'You can generate the LLVM assembly for the `test.c` file in previous examples,
    using the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令为先前示例中的`test.c`文件生成LLVM汇编代码：
- en: '[PRE34]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `–S` and `–emit-llvm` flag ensure the LLVM assembly is generated for the
    `test.c` code.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`–S`和`–emit-llvm`标志确保为`test.c`代码生成LLVM汇编。'
- en: 'To get machine code use for the same `test.c` testcode, pass the `–S` flag
    to Clang. It generates the output on standard output because of the option `–o
    –`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取相同`test.c`测试代码的机器代码，将`–S`标志传递给Clang。由于`–o –`选项，它将在标准输出上生成输出：
- en: '[PRE35]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the `–S` flag is used alone, machine code is generated by the code generation
    process of the compiler. Here, on running the command, machine code is output
    on the standard output as we use `–o –` options.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独使用`–S`标志时，编译器的代码生成过程将生成机器代码。在这里，运行命令时，由于使用了`–o –`选项，机器代码将在标准输出上输出。
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Clang works as a preprocessor, compiler driver, frontend, and code generator
    in the preceding examples, thus giving the desired output as per the input flag
    given to it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，Clang作为预处理器、编译器驱动程序、前端和代码生成器工作，因此根据给定的输入标志给出期望的输出。
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: This was a basic introduction to how Clang can be used. There are also many
    other flags that can be passed to Clang, which makes it perform different operation.
    To see the list, use Clang `–help`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是对如何使用Clang的基本介绍。还有许多其他可以传递给Clang的标志，使其执行不同的操作。要查看列表，使用Clang `–help`。
- en: Using the GO frontend
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GO前端
- en: The `llgo` compiler is the LLVM-based frontend for Go written in Go language
    only. Using this frontend, we can generate the LLVM assembly code from a program
    written in Go.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`llgo`编译器是仅用Go语言编写的基于LLVM的Go语言前端。使用此前端，我们可以从用Go编写的程序中生成LLVM汇编代码。'
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to download the `llgo` binaries or build `llgo` from the source code
    and add the binaries in the `PATH` file location as configured.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载`llgo`的二进制文件或从源代码构建`llgo`，并将二进制文件添加到配置的`PATH`文件位置。
- en: How to do it…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Do the following steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a Go source file, for example, that will be used for generating the
    LLVM assembly using `llgo`. Create `test.go`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Go 源文件，例如，该文件将用于使用 `llgo` 生成 LLVM 汇编。创建 `test.go`：
- en: '[PRE36]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, use `llgo` to get the LLVM assembly:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `llgo` 获取 LLVM 汇编：
- en: '[PRE37]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `llgo` compiler is the frontend for the Go language; it takes the `test.go`
    program as its input and emits the LLVM IR.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`llgo` 编译器是 Go 语言的接口；它将 `test.go` 程序作为其输入并输出 LLVM IR。'
- en: See also
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For information about how to get and install `llgo,` refer to [https://github.com/go-llvm/llgo](https://github.com/go-llvm/llgo)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何获取和安装 `llgo` 的信息，请参阅 [https://github.com/go-llvm/llgo](https://github.com/go-llvm/llgo)
- en: Using DragonEgg
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DragonEgg
- en: Dragonegg is a gcc plugin that allows gcc to make use of the LLVM optimizer
    and code generator instead of gcc's own optimizer and code generator.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Dragonegg 是一个 gcc 插件，允许 gcc 使用 LLVM 优化器和代码生成器，而不是使用 gcc 自身的优化器和代码生成器。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have gcc 4.5 or above, with the target machine being `x86-32/x86-64`
    and an ARM processor. Also, you need to download the dragonegg source code and
    build the `dragonegg.so` file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备 gcc 4.5 或更高版本，目标机器为 `x86-32/x86-64` 和 ARM 处理器。此外，您还需要下载 Dragonegg 源代码并构建
    `dragonegg.so` 文件。
- en: How to do It…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Do the following steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a simple `hello world` program:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的 `hello world` 程序：
- en: '[PRE38]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Compile this program with your gcc; here we use gcc-4.5:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的 gcc 编译此程序；这里我们使用 gcc-4.5：
- en: '[PRE39]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using the `-fplugin=path/dragonegg.so` flag in the command line of gcc makes
    gcc use LLVM''s optimizer and LLVM codegen:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 gcc 的命令行中使用 `-fplugin=path/dragonegg.so` 标志使 gcc 使用 LLVM 的优化器和 LLVM 代码生成器：
- en: '[PRE40]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To know about how to get the source code and installation procedure, refer to
    [http://dragonegg.llvm.org/](http://dragonegg.llvm.org/)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何获取源代码和安装过程的信息，请参阅 [http://dragonegg.llvm.org/](http://dragonegg.llvm.org/)
