- en: '*Chapter 4*: Advanced Template Concepts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：高级模板概念'
- en: 'In the previous chapters, we learned the core fundamentals of C++ templates.
    At this point, you should be able to write templates that are perhaps not very
    complex. However, there are many more details concerning templates, and this chapter
    is dedicated to these more advanced topics. These include the following topics
    that we address next:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了C++模板的核心基础。到这一点，你应该能够编写可能不是非常复杂的模板。然而，关于模板还有很多细节，本章专门讨论这些更高级的话题。接下来我们将讨论以下主题：
- en: Understanding name binding and dependent names
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解名称绑定和依赖名称
- en: Exploring template recursion
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模板递归
- en: Understanding template argument deduction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模板参数推导
- en: Learning forwarding references and perfect forwarding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习前向引用和完美前向
- en: Using the `decltype` specifier and the `std::declval` type operator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`decltype`指定符和`std::declval`类型操作符
- en: Understanding friendship in templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模板中的友谊
- en: On completing this chapter, you will acquire a deeper knowledge of these advanced
    template concepts and be able to understand and write more complex template code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你将获得对这些高级模板概念的更深入理解，并能够理解和编写更复杂的模板代码。
- en: We will start this chapter by learning about name binding and dependent names.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始学习名称绑定和依赖名称。
- en: Understanding name binding and dependent names
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解名称绑定和依赖名称
- en: 'The term **name binding** refers to the process of finding the declaration
    of each name that is used within a template. There are two kinds of names used
    within a template: **dependent names** and **non-dependent names**. The former
    are names that depend on the type or value of a template parameter that can be
    a type, non-type, or template parameter. Names that don’t depend on template parameters
    are called *non-dependent*. The name lookup is performed differently for dependent
    and non-dependent names:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**名称绑定**指的是在模板中使用每个名称的声明查找过程。在模板中使用两种类型的名称：**依赖名称**和**非依赖名称**。前者是依赖于模板参数类型或值的名称，该参数可以是类型、非类型或模板参数。不依赖于模板参数的名称称为*非依赖*。对于依赖和非依赖名称，名称查找的方式不同：
- en: For dependent names, it is performed at *the point of template instantiation*.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于依赖名称，它在**模板实例化的点**进行。
- en: For non-dependent names, it is performed at *the point of the template definition*.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非依赖名称，它在**模板定义的点**进行。
- en: 'We will first look at non-dependent names. As previously mentioned, name lookup
    happens at the point of the template definition. This is located immediately before
    the template definition. To understand how this works, let’s consider the following
    example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看非依赖名称。如前所述，名称查找发生在模板定义的点。这位于模板定义之前立即。为了理解它是如何工作的，让我们考虑以下示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are several points of reference that are marked in the comments on the
    right side. At point `[1]`, we have the declaration of a class template called
    `parser`. This is followed at point `[2]` by the definition of a function called
    `handle` that takes a `double` as its argument. The definition of the class template
    follows at point `[3]`. This class contains a single method called `run` that
    invokes a function called `handle` with the value `42` as its argument, at point
    `[4]`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的注释中有几个标记的参考点。在点 `[1]`，我们有一个名为 `parser` 的类模板的声明。在点 `[2]` 后，定义了一个名为 `handle`
    的函数，它接受一个 `double` 类型的参数。类模板的定义在点 `[3]`。这个类包含一个名为 `run` 的单一方法，该方法使用值 `42` 作为参数调用
    `handle` 函数，在点 `[4]`。
- en: 'The name `handle` is a non-dependent name because it does not depend on any
    template parameter. Therefore, name lookup and binding are performed at this point.
    `handle` must be a function known at point `[3]` and the function defined at `[2]`
    is the only match. After the class template definition, at point `[5]` we have
    the definition of an overload for the function `handle`, which takes an integer
    as its argument. This is a better match for `handle(42)`, but it comes after the
    name binding has been performed, and therefore it will be ignored. In the `main`
    function, at point `[6]`, we have an instantiation of the `parser` class template
    for the type `int`. Upon calling the `run` function, the text `processing a double:
    42` will be printed to the console output.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `handle` 是一个非依赖名称，因为它不依赖于任何模板参数。因此，名称查找和绑定在此处进行。`handle` 必须是在点 `[3]` 处已知的函数，并且
    `[2]` 处定义的函数是唯一的匹配项。在类模板定义之后，在点 `[5]` 我们有 `handle` 函数的重载定义，它接受一个整数作为其参数。这对于 `handle(42)`
    是一个更好的匹配，但它是在名称绑定之后进行的，因此将被忽略。在 `main` 函数中，在点 `[6]`，我们为 `int` 类型实例化了 `parser`
    类模板。在调用 `run` 函数时，文本 `处理一个双精度数：42` 将被打印到控制台输出。
- en: 'The next example is designed to introduce you to the concept of dependent names.
    Let’s look at the code first:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子旨在向您介绍依赖名称的概念。让我们首先看看代码：
- en: '[PRE23]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example is slightly different from the previous one. The `parser` class
    template is very similar, but the `handle` functions have become members of another
    class template. Let’s analyze it point by point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子略有不同。`parser` 类模板非常相似，但 `handle` 函数已成为另一个类模板的成员。让我们一点一点地分析它。
- en: 'At the point mark with `[1]` in the comments, we have the definition of a class
    template called `handler`. This contains a single, public method called `handle`
    that takes an argument of the `T` type and prints its value to the console. Next,
    at point `[2]`, we have the definition of the class template called `parser`.
    This is similar to the previous one, except for one key aspect: at point `[3]`,
    it invokes a method called `handle` on its argument. Because the type of the argument
    is the template parameter `T`, it makes `handle` a dependent name. Dependent names
    are looked up at the point of template instantiation, so `handle` is not bound
    at this point. Continuing with the code, at point `[4]`, there is a template specialization
    for the `handler` class template for the type `int`. As a specialization, this
    is a better match for the dependent name. Therefore, when the template instantiation
    happens at point `[6]`, `handler<int>::handle` is the name that is bound to the
    dependent name used at `[3]`. Running this program will print `handler<int>: 42`
    to the console.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '在注释中标记的 `[1]` 点处，我们有名为 `handler` 的类模板的定义。它包含一个名为 `handle` 的单个公共方法，该方法接受 `T`
    类型的参数并将它的值打印到控制台。接下来，在点 `[2]`，我们有名为 `parser` 的类模板的定义。这与上一个例子相似，但有一个关键方面：在点 `[3]`，它在其参数上调用名为
    `handle` 的方法。因为参数的类型是模板参数 `T`，这使得 `handle` 成为一个依赖名称。依赖名称在模板实例化点进行查找，因此 `handle`
    在此点未绑定。继续代码，在点 `[4]`，有一个 `handler` 类模板针对 `int` 类型的模板特化。作为一个特化，这是对依赖名称的一个更好的匹配。因此，当模板在点
    `[6]` 实例化时，`handler<int>::handle` 是绑定到 `[3]` 处使用的依赖名称的名称。运行此程序将在控制台打印 `handler<int>:
    42`。'
- en: Now that we’ve seen how name binding occurs, let’s learn how this relates to
    template instantiation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了名称绑定是如何发生的，让我们学习一下这与模板实例化有何关联。
- en: Two-phase name lookup
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两阶段名称查找
- en: 'The key takeaway from the previous section is that name lookup happens differently
    for dependent names (those that depend on a template parameter) and non-dependent
    names (those that do not depend on a template parameter, plus the template name
    and names defined in the current template instantiation). When the compiler passes
    through the definition of a template it needs to figure out whether a name is
    dependent or non-dependent. Further name lookup depends on this categorization
    and happens either at the template definition point (for non-dependent names)
    or the template instantiation point (for dependent names). Therefore, instantiation
    of a template happens in two phases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节的关键要点是，对于依赖名称（依赖于模板参数的名称）和非依赖名称（不依赖于模板参数的名称，以及当前模板实例化中定义的名称），名称查找的方式不同。当编译器通过模板的定义时，它需要确定一个名称是依赖的还是非依赖的。进一步的名字查找依赖于这种分类，并且要么在模板定义点（对于非依赖名称）要么在模板实例化点（对于依赖名称）发生。因此，模板的实例化发生在两个阶段：
- en: The first phase occurs at the point of the definition when the template syntax
    is checked and names are categorized as dependent or non-dependent.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一阶段发生在定义点，当模板语法被检查并且名称被分类为依赖或非依赖时。
- en: The second phase occurs at the point of instantiation when the template arguments
    are substituted for the template parameters. Name binding for dependent names
    happens at this point.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二阶段发生在实例化点，当模板参数被替换为模板参数时。依赖名称的名称绑定发生在这一点。
- en: 'This process in two steps is called **two-phase name lookup**. To understand
    it better, let’s consider another example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个两步过程被称为**两阶段名称查找**。为了更好地理解它，让我们考虑另一个例子：
- en: '[PRE53]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this snippet, we have two class templates: `base_parser`, which contains
    a public method called `init`, and `parser`, which derives from `base_parser`
    and contains a public method called `parse`. The `parse` member function calls
    a function called `init` and the intention is that it’s the base-class method
    `init` that is invoked here. However, the compiler will issue an error, because
    it’s not able to find `init`. The reason this happens is that `init` is a non-dependent
    name (as it does not depend on a template parameter). Therefore, it must be known
    at the point of the definition of the `parser` template. Although a `base_parser<T>::init`
    exists, the compiler cannot assume it’s what we want to call because the primary
    template `base_parser` can be later specialized and `init` can be defined as something
    else (such as a type, or a variable, or another function, or it may be missing
    entirely). Therefore, name lookup does not happen in the base class, only on its
    enclosing scope, and there is no function called `init` in `parser`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们有两个类模板：`base_parser`，它包含一个名为`init`的公共方法，以及`parser`，它从`base_parser`派生并包含一个名为`parse`的公共方法。`parse`成员函数调用一个名为`init`的函数，并且意图是调用这里的基类方法`init`。然而，编译器将发出错误，因为它找不到`init`。这种情况发生的原因是`init`是一个非依赖名称（因为它不依赖于模板参数）。因此，它必须在`parser`模板的定义点已知。尽管存在`base_parser<T>::init`，但编译器不能假设这就是我们想要调用的，因为主模板`base_parser`可以稍后特化，`init`可以定义为其他内容（例如类型、变量、另一个函数，或者它可能完全不存在）。因此，名称查找不会在基类中发生，而是在其封装作用域中发生，并且在`parser`中没有名为`init`的函数。
- en: 'This problem can be fixed by making `init` a dependent name. This can be done
    either by prefixing with `this->` or with `base_parser<T>::`. By turning `init`
    into a dependent name, its name binding is moved from the point of template definition
    to the point of template instantiation. In the following snippet, this problem
    is solved by invoking `init` through the `this` pointer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过将`init`改为依赖名称来解决。这可以通过在前面加上`this->`或`base_parser<T>::`来实现。通过将`init`变成依赖名称，其名称绑定从模板定义点移动到模板实例化点。在下面的片段中，这个问题通过通过`this`指针调用`init`来解决：
- en: '[PRE75]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Continuing this example, let’s consider that a specialization of `base_parser`
    for the `int` type is made available after the definition of the `parser` class
    template. This can look as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个例子，让我们考虑在定义`parser`类模板之后，为`int`类型提供了一个`base_parser`的特化。这可以看起来如下所示：
- en: '[PRE84]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Furthermore, let’s consider the following use of the `parser` class template:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们考虑以下`parser`类模板的使用：
- en: '[PRE92]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When you run this program, the following text will be printed to the console:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，以下文本将被打印到控制台：
- en: '[PRE99]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The reason for this behavior is that `p1` is an instance of `parser<int>` and
    there is a specialization of its base class, `base_parser<int>` that implements
    the `init` function and prints `specialized init` to the console. On the other
    hand, `p2` is an instance of `parser<double>`. Since a specialization of `base_parser`
    for the `double` type is not available, the `init` function from the primary template
    is being called and this only prints `init` to the console.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因是`p1`是`parser<int>`的一个实例，并且它的基类`base_parser<int>`有一个特化实现了`init`函数，并将`specialized
    init`打印到控制台。另一方面，`p2`是`parser<double>`的一个实例。由于没有为`double`类型提供`base_parser`的特化，因此正在调用主模板中的`init`函数，这只会将`init`打印到控制台。
- en: The next subject of this broader topic is using dependent names that are types.
    Let’s learn how that works.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更广泛主题的下一个主题是使用类型依赖的名称。让我们学习它是如何工作的。
- en: Dependent type names
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖类型名称
- en: 'In the examples seen so far, the dependent name was a function or a member
    function. However, there are cases when a dependent name is a type. This is demonstrated
    with the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止看到的示例中，依赖名称是一个函数或成员函数。然而，也存在依赖名称是类型的情况。以下示例展示了这一点：
- en: '[PRE103]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In this snippet, `base_parser` is a class template that defines a type alias
    for `T` called `value_type`. The `parser` class template, which derives from `base_parser`,
    needs to use this type within its `parse` method. However, both `value_type` and
    `base_parser<T>::value_type` do not work, and the compiler is issuing an error.
    `value_type` does not work because it’s a non-dependent name and therefore it
    will not be looked up in the base class, only in the enclosing scope. `base_parser<T>::value_type`
    does not work either because the compiler cannot assume this is actually a type.
    A specialization of `base_parser` may follow and `value_type` could be defined
    as something else than a type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`base_parser` 是一个定义了 `T` 的类型别名 `value_type` 的类模板。从 `base_parser` 派生的
    `parser` 类模板需要在它的 `parse` 方法中使用此类型。然而，`value_type` 和 `base_parser<T>::value_type`
    都不起作用，编译器正在发出错误。`value_type` 不起作用，因为它是一个非依赖名称，因此它不会在基类中查找，只会在封装作用域中查找。`base_parser<T>::value_type`
    也不起作用，因为编译器无法假设这实际上是一个类型。`base_parser` 的一个特化可能随后出现，`value_type` 可能被定义为不是类型的东西。
- en: 'In order to fix this problem, we need to tell the compiler the name refers
    to a type. Otherwise, by default, the compiler assumes it’s not a type. This is
    done with the `typename` keyword, at the point of definition, shown as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要告诉编译器该名称指的是一个类型。否则，默认情况下，编译器假设它不是一个类型。这是通过 `typename` 关键字在定义点完成的，如下所示：
- en: '[PRE119]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'There are actually two exceptions to this rule:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个规则有两个例外：
- en: When specifying a base class
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定基类时
- en: When initializing class members
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始化类成员时
- en: 'Let’s see an example for these two exceptions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个异常的示例：
- en: '[PRE128]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The `dictionay_traits` is a class used as the template argument for the `dictionary`
    class template. This class derives from `T::map_type` (see line `[1]`) but the
    use of the `typename` keyword is not required here. The dictionary class defines
    a member called `start_key`, which is an `int` initialized with the value of `T::identity`
    (see line `[2]`). Again, the `typename` keyword is not needed here. However, if
    we want to define yet another member of the type `T::key_type` (see line `[3]`)
    we do need to use `typename`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`dictionay_traits` 是一个用作 `dictionary` 类模板模板参数的类。这个类从 `T::map_type` 派生（见行 `[1]`），但在这里不需要使用
    `typename` 关键字。字典类定义了一个名为 `start_key` 的成员，它是一个初始化为 `T::identity` 值的 `int`（见行 `[2]`）。同样，这里也不需要
    `typename` 关键字。然而，如果我们想定义类型 `T::key_type`（见行 `[3]`）的另一个成员，我们确实需要使用 `typename`。'
- en: The requirements for using `typename` have been relaxed in `[3]` previously
    no longer requires prefixing with the `typename` keyword.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[3]` 中使用 `typename` 的要求已经放宽，之前不再需要使用 `typename` 关键字作为前缀。
- en: 'In C++20, `typename` is implicit (can be deduced by the compiler) in the following
    contexts:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，`typename` 在以下上下文中是隐式的（可以由编译器推导）：
- en: In using declarations
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用声明中
- en: In the declaration of data members
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据成员的声明中
- en: In the declaration or definition of function parameters
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数参数的声明或定义中
- en: In trailing return types
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尾随返回类型中
- en: In default arguments of type-parameters of a template
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板的泛型参数的默认参数中
- en: In the type-id of a `static_cast`, `const_cast`, `reinterpret_cast`, or `dynamic_cast`
    statement
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `static_cast`、`const_cast`、`reinterpret_cast` 或 `dynamic_cast` 语句的类型标识符中
- en: 'Some of these contexts are exemplified in the following snippet:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中展示了这些上下文的一些示例：
- en: '[PRE144]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: At all the lines marked with `[1]`, `[2]`, and `[3]` in this snippet, prior
    to C++20, the `typename` keyword was required to indicate a type name (such as
    `T::key_type` or `T::map_type::mapped_type`). When compiled with C++20, this is
    no longer necessary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中所有标记为 `[1]`、`[2]` 和 `[3]` 的行上，在 C++20 之前，需要使用 `typename` 关键字来指示类型名称（如
    `T::key_type` 或 `T::map_type::mapped_type`）。当用 C++20 编译时，这不再是必要的。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In [*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), *Template Fundamentals*,
    we have seen that the keywords `typename` and `class` can be used to introduce
    type template parameters and they are interchangeable. The keyword `typename`
    here, although it has a similar purpose, cannot be substituted with the keyword
    `class`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18367_02_ePub.xhtml#_idTextAnchor024)，*模板基础* 中，我们了解到 `typename`
    和 `class` 关键字可以用来引入类型模板参数，并且它们是可以互换的。这里的 `typename` 虽然有类似的目的，但不能用 `class` 关键字替换。
- en: Not only types can be dependent names but other templates too. We look at this
    topic in the next subsection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅类型可以是依赖名称，其他模板也可以。我们将在下一小节中探讨这个主题。
- en: Dependent template names
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖模板名称
- en: 'There are cases when the dependent name is a template, such as a function template
    or a class template. However, the default behavior of the compiler is to interpret
    the dependent name as a non-type, which leads to errors concerning the usage of
    the comparison operator `<`. Let’s demonstrate this with an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，依赖名称是一个模板，例如函数模板或类模板。然而，编译器的默认行为是将依赖名称解释为非类型，这会导致与比较运算符 `<` 的使用相关的错误。让我们用一个例子来演示这一点：
- en: '[PRE152]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This is similar to the previous snippets, but the `init` function in `base_parser`
    is also a template. The attempt to call it using the `base_parser<T>::init<int>()`
    syntax, as seen at point `[1]`, results in a compiler error. Therefore, we must
    use the `template` keyword to tell the compiler the dependent name is a template.
    This is done as shown at point `[2]`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的代码片段类似，但 `base_parser` 中的 `init` 函数也是一个模板。尝试使用 `base_parser<T>::init<int>()`
    语法调用它，如点 `[1]` 所见，会导致编译器错误。因此，我们必须使用 `template` 关键字来告诉编译器依赖名称是一个模板。这如点 `[2]` 所示进行。
- en: Keep in mind that the `template` keyword can only follow the scope resolution
    operator (`::`), member access through pointer (`->`), and the member access (`.`).
    Examples of correct usage are `X::template foo<T>()`, `this->template foo<T>()`,
    and `obj.template foo<T>()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`template` 关键字只能跟在作用域解析运算符 (`::`)、通过指针的成员访问 (`->`) 和成员访问 (`.`) 之后。正确使用的例子有
    `X::template foo<T>()`、`this->template foo<T>()` 和 `obj.template foo<T>()`。
- en: 'The dependent name does not have to be a function template. It can also be
    a class template, shown as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖名称不一定是函数模板。它也可以是类模板，如下所示：
- en: '[PRE171]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The `token` class is an inner class template of the `base_parser` class template.
    It can be either used as in the line marked with `[1]`, where a type alias is
    defined (which is then used to instantiate an object) or as at line `[2]`, where
    it is used directly to declare a variable. Notice that the `typename` keyword
    is not necessary at `[1]`, where the using declaration indicates we are dealing
    with a type, but is required at `[2]` because the compiler would otherwise assume
    it’s a non-type name.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`token` 类是 `base_parser` 类模板的内联类模板。它可以像在标记为 `[1]` 的行中那样使用，其中定义了一个类型别名（然后用于实例化一个对象），或者像在行
    `[2]` 中那样直接使用来声明一个变量。请注意，在 `[1]` 处不需要 `typename` 关键字，因为使用声明表明我们正在处理一个类型，但在 `[2]`
    处是必需的，因为否则编译器会假设它是一个非类型名称。'
- en: The use of the `typename` and `template` keywords is not required in some contexts
    of the current template instantiation being observed. This will be the topic of
    the next subsection.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察当前模板实例化的某些上下文中，不需要使用 `typename` 和 `template` 关键字。这将是下一小节的主题。
- en: Current instantiation
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前实例化
- en: The requirement to use the `typename` and `template` keywords to disambiguate
    dependent names may be avoided in the context of a class template definition where
    the compiler is able to deduce some dependent names (such as the name of a nested
    class) to refer to the current instantiation. This means some errors can be identified
    sooner, at the point of definition instead of the point of instantiation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在类模板定义的上下文中，可能避免使用 `typename` 和 `template` 关键字来区分依赖名称，因为编译器能够推断出一些依赖名称（例如嵌套类的名称）来引用当前实例化。这意味着一些错误可以在定义点而不是实例化点更早地识别出来。
- en: 'The complete list of names that can refer to the current instantiation, according
    to the C++ *Standard, §13.8.2.1 - Dependent Types*, is presented in the following
    table:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 根据C++ *标准，§13.8.2.1 - 依赖类型*，以下表格展示了可以引用当前实例化的名称的完整列表：
- en: '![Table 4.1'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.1'
- en: '](img/B18367_04_Table_4.1.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18367_04_Table_4.1.jpg)'
- en: Table 4.1
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1
- en: 'The following are the rules for considering a name as part of the current instantiation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则用于考虑一个名称是否是当前实例化的一部分：
- en: An unqualified name (that does not appear on the right side of the scope resolution
    operator `::`) found in the current instantiation or its non-dependent base
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前实例化或其非依赖基中找到的无限定名称（不在作用域解析运算符 `::` 的右侧出现）
- en: A qualified name (that appears on the right side of the scope resolution operator
    `::`) if its qualifier (the part that appears on the left side of the scope resolution
    operator) names the current instantiation and is found in the current instantiation
    or its non-dependent base
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其限定符（位于作用域解析运算符 `::` 左侧的部分）命名了当前实例化，并且在该实例化或其非依赖基中找到，则该限定符为作用域解析运算符右侧出现的作用域限定名称
- en: A name used in a class member access expression where the object expression
    is the current instantiation and the name is found in the current instantiation
    or its non-dependent base
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类成员访问表达式中使用的名称，其中对象表达式是当前实例化，且该名称在当前实例化或其非依赖基中找到
- en: Note
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It is said that a base class is a **dependent class** if it is a dependent type
    (depends on a template parameter) and is not in the current instantiation. Otherwise,
    a base class is said to be a **non-dependent class**.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 据说，如果一个基类是一个依赖于模板参数的依赖类型（依赖于模板参数）并且不在当前实例化中，则该基类是一个**依赖类**。否则，称基类为**非依赖类**。
- en: 'These rules may sound a bit harder to comprehend; therefore, let’s try to understand
    them with the help of several examples, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可能听起来有点难以理解；因此，让我们通过几个示例来尝试理解它们，如下所示：
- en: '[PRE190]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: In the primary template `parser`, the names `parser`, `parser<T>`, and `::parser<T>`
    all refer to the current instantiation. However, `parser<T*>` does not. The class
    `token` is a nested class of the primary template `parser`. In the scope of this
    class, `token` and `parser<T>::token` are both denoting the current instantiation.
    The same is not true for `parser<T*>::token`. This snippet also contains a partial
    specialization of the primary template for the pointer type `T*`. In the context
    of this partial specialization, `parser<T*>` is the current instantiation, but
    `parser<T>` is not.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在主模板 `parser` 中，名称 `parser`、`parser<T>` 和 `::parser<T>` 都指向当前实例化。然而，`parser<T*>`
    并不是。类 `token` 是主模板 `parser` 的嵌套类。在这个类的范围内，`token` 和 `parser<T>::token` 都表示当前实例化。对于
    `parser<T*>::token` 并不适用。这个片段还包含了对指针类型 `T*` 的主模板的部分特化。在这个部分特化的上下文中，`parser<T*>`
    是当前实例化，但 `parser<T>` 不是。
- en: Dependent names are an important aspect of template programming. The key takeaway
    from this section is that names are categorized as dependent (those that depend
    on a template parameter) and non-dependent (those that don’t depend on a template
    parameter). Name binding happens at the point of definition for non-dependent
    types and at the point of instantiation for dependent types. In some cases, the
    keywords `typename` and `template` are required to disambiguate the use of names
    and tell the compiler that a name refers to a type or a template. In the context
    of a class template definition, the compiler is, however, able to figure out that
    some dependent names refer to the current instantiation, which enables it to identify
    errors sooner.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖名称是模板编程的一个重要方面。本节的关键要点是，名称被分类为依赖（依赖于模板参数）和非依赖（不依赖于模板参数）。非依赖类型的名称绑定发生在定义点，依赖类型的名称绑定发生在实例化点。在某些情况下，需要关键字
    `typename` 和 `template` 来消除歧义，并告诉编译器一个名称指的是类型或模板。然而，在类模板定义的上下文中，编译器能够确定一些依赖名称指的是当前实例化，这使得它能够更快地识别错误。
- en: In the next section, we move our attention to a topic that we briefly touched
    already, which is template recursion.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将注意力转向一个我们已经简要涉及过的主题，即模板递归。
- en: Exploring template recursion
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模板递归
- en: 'In [*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*,
    we discussed variadic templates and saw that they are implemented with a mechanism
    that looks like recursion. In fact, it is overloaded functions and class template
    specializations respectively. However, it is possible to create recursive templates.
    To demonstrate how this works, we’ll look at implementing a compile-time version
    of the factorial function. This is typically implemented in a recursive manner,
    and a possible implementation is the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18367_03_ePub.xhtml#_idTextAnchor051) *可变模板*中，我们讨论了可变模板，并看到它们是通过类似于递归的机制实现的。实际上，这是重载函数和类模板特化分别实现的。然而，可以创建递归模板。为了展示这是如何工作的，我们将查看实现阶乘函数的编译时版本。这通常以递归方式实现，一个可能的实现如下：
- en: '[PRE211]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'This should be trivial to understand: return the result of multiplying the
    function argument with the value returned by calling the function recursively
    with the decremented argument, or return the value `1` if the argument is `0`
    or `1`. The type of the argument (and the return value) is `unsigned int` to avoid
    calling it for negative integers.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很容易理解：返回函数参数与递归调用递减参数的函数返回值相乘的结果，或者如果参数是`0`或`1`，则返回值`1`。参数的类型（以及返回值）是`unsigned
    int`，以避免对负整数进行调用。
- en: 'To compute the value of the factorial function at compile time, we need to
    define a class template that contains a data member holding the value of the function.
    The implementation looks as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译时计算阶乘函数的值，我们需要定义一个包含持有函数值的成员数据的类模板。其实现如下：
- en: '[PRE215]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The first definition is the primary template. It has a non-type template parameter
    representing the value whose factorial needs to be computed. This class contains
    a static `constexpr` data member called `value`, initialized with the result of
    multiplying the argument `N` and the value of the factorial class template instantiated
    with the decremented argument. The recursion needs an end case and that is provided
    by the explicit specialization for the value `0` (of the non-type template argument),
    in which case the member value is initialized with `1`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个定义是主要模板。它有一个非类型模板参数，表示需要计算阶乘的值。这个类包含一个静态`constexpr`数据成员`value`，其初始化为将参数`N`与使用递减参数实例化的阶乘类模板的值相乘的结果。递归需要一个结束条件，这由非类型模板参数的显式特化提供，即值为`0`时，成员值初始化为`1`。
- en: 'When encountering the instantiation `factorial<4>::value` in the `main` function,
    the compiler generates all the recursive instantiations from `factorial<4>` to
    `factorial<0>`. These look as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`main`函数中遇到实例化`factorial<4>::value`时，编译器会生成从`factorial<4>`到`factorial<0>`的所有递归实例化。这些实例化看起来如下：
- en: '[PRE230]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: From these instantiations, the compiler is able to compute the value of the
    data member `factorial<N>::value`. It should be mentioned again that when optimizations
    are enabled, this code would not even be generated, but the resulting constant
    is used directly in the generated assembly code.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些实例化中，编译器能够计算出数据成员`factorial<N>::value`的值。再次提到，当启用优化时，此代码甚至不会被生成，但结果常量会直接用于生成的汇编代码中。
- en: 'The implementation of the factorial class template is relatively trivial, and
    the class template is basically only a wrapper over the static data member `value`.
    We can actually avoid it altogether by using a variable template instead. This
    can be defined as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘类模板的实现相对简单，类模板基本上只是静态数据成员`value`的包装。实际上，我们可以通过使用变量模板来避免它。这可以定义如下：
- en: '[PRE259]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: There is a striking similarity between the implementation of the `factorial`
    class template and the `factorial` variable template. For the latter, we have
    basically taken out the data member value and called it `factorial`. On the other
    hand, this may also be more convenient to use because it does not require accessing
    the data member value as in `factorial<4>::value`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial`类模板的实现与`factorial`变量模板的实现之间有显著的相似性。对于后者，我们基本上取出了数据成员值并称之为`factorial`。另一方面，这也许更方便使用，因为它不需要像`factorial<4>::value`那样访问数据成员值。'
- en: 'There is a third approach for computing the factorial at compile time: using
    function templates. A possible implementation is shown next:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 计算编译时阶乘的第三种方法是使用函数模板。以下是一个可能的实现：
- en: '[PRE267]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: You can see there is a primary template that calls the `factorial` function
    template recursively, and we have two full specializations for the values `1`
    and `0`, both returning `1`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到有一个主要模板递归调用`factorial`函数模板，并且我们有两个完全特化，针对值`1`和`0`，都返回`1`。
- en: 'Which of these three different approaches is the best is probably arguable.
    Nevertheless, the complexity of the recursive instantiations of the factorial
    templates remained the same. However, this depends on the nature of the template.
    The following snippet shows an example of when complexity increases:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种不同方法中哪一种最好可能是有争议的。然而，阶乘模板的递归实例化的复杂性保持不变。然而，这取决于模板的性质。以下代码片段显示了复杂性增加的例子：
- en: '[PRE280]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'There are two class templates in this example. The first is called `wrapper`
    and has an empty implementation (it doesn’t actually matter what it contains)
    but it represents a wrapper class over some type (or more precisely a value of
    some type). The second template is called `manyfold_wrapper`. This represents
    a wrapper over a wrapper over a type many times over, hence the name `manyfold_wrapper`.
    There is no end case for an upper limit of this number of wrappings, but there
    is a start case for the lower limit. The full specialization for value `0` defines
    a member type called `value_type` for the `unsigned int` type. As a result, `manyfold_wrapper<1>`
    defines a member type called `value_type` for `wrapper<unsigned int>`, `manyfold_wrapper<2>`
    defines a member type called `value_type` for `wrapper<wrapper<unsigned int>>`,
    and so on. Therefore, executing the `main` function will print the following to
    the console:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有两个类模板。第一个被称为`wrapper`，它有一个空实现（实际上它包含的内容并不重要），但它代表了一个类型（或更精确地说，某个类型的值）的包装类。第二个模板被称为`manyfold_wrapper`。这代表了一个类型多次包装的包装器，因此得名`manyfold_wrapper`。这个数字的包装上限没有终点，但有一个下限的起点。值为`0`的全特化定义了一个名为`value_type`的成员类型，用于`unsigned
    int`类型。因此，`manyfold_wrapper<1>`定义了一个名为`value_type`的成员类型，用于`wrapper<unsigned int>`，`manyfold_wrapper<2>`定义了一个名为`value_type`的成员类型，用于`wrapper<wrapper<unsigned
    int>>`，依此类推。因此，执行`main`函数将在控制台打印以下内容：
- en: '[PRE305]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'The C++ standard does not specify a limit for the recursively nested template
    instantiations but does recommend a minimum limit of 1,024\. However, this is
    only a recommendation and not a requirement. Therefore, different compilers have
    implemented different limits. The **VC++ 16.11** compiler has the limit set at
    500, **GCC 12** at 900, and **Clang 13** at 1,024\. A compiler error is generated
    when this limit is exceeded. Some examples are shown here:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准没有指定递归嵌套模板实例化的限制，但建议一个最小限制为1,024。然而，这只是一个建议，而不是要求。因此，不同的编译器实现了不同的限制。**VC++
    16.11**编译器的限制设置为500，**GCC 12**为900，**Clang 13**为1,024。当超过这个限制时，会生成编译器错误。这里展示了几个例子：
- en: 'For VC++:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于VC++：
- en: '[PRE309]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'For GCC:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GCC：
- en: '[PRE310]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'For Clang:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Clang：
- en: '[PRE311]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: For GCC and Clang, the compiler option `-ftemplate-depth=N` can be used to increase
    this maximum value for nested template instantiations. Such an option is not available
    for the Visual C++ compiler.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GCC和Clang，可以使用编译器选项`-ftemplate-depth=N`来增加嵌套模板实例化的最大值。这个选项对于Visual C++编译器不可用。
- en: Recursive templates help us solve some problems in a recursive manner at compile
    time. Whether you use recursive function templates, variable templates, or class
    templates depends on the problem you are trying to solve or perhaps your preference.
    However, you should keep in mind there are limits to the depth template recursion
    works. Nevertheless, use template recursion judiciously.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 递归模板帮助我们以递归方式在编译时解决一些问题。你使用递归函数模板、变量模板还是类模板取决于你试图解决的问题或可能你的偏好。然而，你应该记住模板递归的深度是有限制的。尽管如此，还是要谨慎使用模板递归。
- en: The next advanced topic to address in this chapter is template argument deduction,
    both for functions and classes. We start next with the former.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来要讨论的下一个高级主题是模板参数推断，包括函数和类。我们接下来从前者开始。
- en: Function template argument deduction
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数模板参数推断
- en: Earlier in this book, we have briefly talked about the fact that the compiler
    can sometimes deduce the template arguments from the context of the function call,
    allowing you to avoid explicitly specifying them. The rules for template argument
    deduction are more complex and we will explore this topic in this section.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们简要地讨论了编译器有时可以从函数调用的上下文中推断出模板参数的事实，这允许你避免显式指定它们。模板参数推断的规则更为复杂，我们将在本节中探讨这个主题。
- en: 'Let’s start the discussion by looking at a simple example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个简单的例子开始讨论：
- en: '[PRE312]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: In this snippet, `process` is a function template with a single type template
    parameter. The calls `process(42)` and `process<int>(42)` are identical because,
    in the first case, the compiler is able to deduce the type of the type template
    parameter `T` as `int` from the value of the argument passed to the function.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`process`是一个具有单个类型模板参数的函数模板。调用`process(42)`和`process<int>(42)`是相同的，因为在第一种情况下，编译器能够从传递给函数的参数的值推断出类型模板参数`T`的类型为`int`。
- en: 'When the compiler tries to deduce the template arguments, it performs the matching
    of the types of the template parameters with the types of the arguments used to
    invoke the function. There are some rules that govern this matching. The compiler
    can match the following:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器尝试推断模板参数时，它会将模板参数的类型与调用函数时使用的参数类型进行匹配。有一些规则控制着这种匹配。编译器可以匹配以下类型：
- en: 'Types (both cv-qualified and non-qualified) of the form `T`, `T const`, `T
    volatile`:'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式为 `T`、`T const`、`T volatile` 的类型（既包括cv-限定类型也包括非限定类型）：
- en: '[PRE323]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'Pointers (`T*`), l-value references (`T&`), and r-value references (`T&&`):'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针 (`T*`)、左值引用 (`T&`) 和右值引用 (`T&&`)：
- en: '[PRE324]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'Arrays such as `T[5]`, or `C[5][n]`, where `C` is a class type and `n` is a
    non-type template argument:'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组，如 `T[5]` 或 `C[5][n]`，其中 `C` 是类类型，`n` 是非类型模板参数：
- en: '[PRE325]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'Pointers to functions, with the form `T(*)()`, `C(*)(T)`, and `T(*)(U)`, where
    `C` is a class type and `T` and `U` are type template parameters:'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数指针，形式为 `T(*)()`, `C(*)(T)`, 和 `T(*)(U)`，其中 `C` 是类类型，`T` 和 `U` 是类型模板参数：
- en: '[PRE326]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Pointers to member functions with one of the following forms, `T (C::*)()`,
    `T (C::*)(U)`, `T (U::*)()`, `T (U::*)(V)`, `C (T::*)()`, `C (T::*)(U)`, and `D
    (C::*)(T)`, where `C` and `D` are class types and `T`, `U`, and `V` are type template
    parameters:'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员函数指针，具有以下形式之一，`T (C::*)()`, `T (C::*)(U)`, `T (U::*)()`, `T (U::*)(V)`, `C
    (T::*)()`, `C (T::*)(U)`, 和 `D (C::*)(T)`，其中 `C` 和 `D` 是类类型，`T`、`U` 和 `V` 是类型模板参数：
- en: '[PRE327]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Pointers to data members such as `T C::*`, `C T::*`, and `T U::*`, where `C`
    is a class type and `T` and `U` are type template parameters:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据成员指针，如 `T C::*`、`C T::*` 和 `T U::*`，其中 `C` 是类类型，`T` 和 `U` 是类型模板参数：
- en: '[PRE328]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'A template with an argument list that contains at least one type template parameter;
    the general form is `C<T>`, where `C` is a class type and `T` is a type template
    parameter:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表至少包含一个类型模板参数的模板；一般形式为 `C<T>`，其中 `C` 是类类型，`T` 是类型模板参数：
- en: '[PRE329]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'A template with an argument list that contains at least one non-type template
    argument; the general form is `C<i>`, where `C` is a class type and `i` a non-type
    template argument:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表至少包含一个非类型模板参数的模板；一般形式为 `C<i>`，其中 `C` 是类类型，`i` 是非类型模板参数：
- en: '[PRE330]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'A template template argument with an argument list that contains at least one
    type template parameter; the general form is `TT<T>`, where `TT` is a template
    template parameter and `T` is a type template:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模板参数的参数列表至少包含一个类型模板参数；一般形式为 `TT<T>`，其中 `TT` 是模板模板参数，`T` 是类型模板：
- en: '[PRE331]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'A template template argument with an argument list that contains at least one
    non-type template argument; the general form is `TT<i>`, where `TT` is a template
    template parameter and `i` is a non-type template argument:'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模板参数的参数列表至少包含一个非类型模板参数；一般形式为 `TT<i>`，其中 `TT` 是模板模板参数，`i` 是非类型模板参数：
- en: '[PRE332]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'A template template argument with an argument list that has no template arguments
    dependent on a template parameter; this has the form `TT<C>`, where `TT` is the
    template template parameter and `C` is a class type:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表没有依赖于模板参数的模板参数的模板模板参数；形式为 `TT<C>`，其中 `TT` 是模板模板参数，`C` 是类类型：
- en: '[PRE333]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Although the compiler is able to deduce many types of template parameters,
    as previously seen, there are also limitations to what it can do. These are exemplified
    in the following list:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器能够推断许多模板参数的类型，如前所述，但它所能做的也有局限性。以下列表举例说明了这些限制：
- en: 'The compiler cannot deduce the type of a type template argument, from the type
    of a non-type template argument. In the following example, `process` is a function
    template with two template parameters: a type template called `T`, and a non-type
    template `i` of the type `T`. Calling the function with an array of five doubles
    does not allow the compiler to determine the type of `T`, even though this is
    the type of the value specifying the size of the array:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器不能从非类型模板参数的类型推断类型模板参数的类型。在以下示例中，`process` 是一个有两个模板参数的函数模板：一个名为 `T` 的类型模板和一个类型为
    `T` 的非类型模板 `i`。使用包含五个双精度浮点数的数组调用函数不允许编译器确定 `T` 的类型，尽管这是指定数组大小的值的类型：
- en: '[PRE334]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE334]'
- en: The compiler is not able to determine the type of a template argument from the
    type of a default value. This is exemplified ahead in the code with the function
    template `process`, which has a single type template parameter, but two function
    parameters, both of type `T` and both with default values.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器无法从默认值的类型推导出模板参数的类型。这一点在下面的代码中通过具有单个类型模板参数但有两个函数参数（都是类型`T`且都有默认值）的函数模板`process`进行说明。
- en: 'The `process()` call (without any arguments) fails because the compiler cannot
    deduce the type of the type template parameter `T` from the default values of
    the function parameters. The `process<int>()` call is OK because the template
    argument is explicitly provided. The `process(6)` call is also OK, because the
    type of the first function parameter can be deduced from the supplied argument,
    and, therefore, the type template argument can also be deduced:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的`process()`调用失败，因为编译器无法从函数参数的默认值推导出类型模板参数`T`的类型。`process<int>()`调用是正确的，因为模板参数是显式提供的。`process(6)`调用也是正确的，因为第一个函数参数的类型可以从提供的参数推导出来，因此类型模板参数也可以推导出来：
- en: '[PRE335]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'Although the compiler can deduce function template arguments from pointer to
    functions or pointer to member functions, as we have seen earlier, there are a
    couple of restrictions to this capability: it cannot deduce arguments from pointers
    to function templates, nor from a pointer to a function that has an overloaded
    set with more than one overloaded function matching the required type.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管编译器可以从函数指针或成员函数指针推导出函数模板参数，如我们之前所看到的，但这个能力有一些限制：它不能从函数模板的指针推导出参数，也不能从具有多个重载函数匹配所需类型的函数的指针推导出参数。
- en: 'In the code ahead, the function template `invoke` takes a pointer to a function
    that has two arguments, the first of the type template parameter `T`, and the
    second an `int`, and returns `void`. This function template cannot be passed a
    pointer to `alpha` (see `[1]`) because this is a function template, nor to `beta`
    (see `[2]`), because this has more than one overload that can match the type `T`.
    However, it is possible to call it with a pointer to `gamma` (see `[3]`), and
    it will correctly deduce the type of the second overload:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，函数模板`invoke`接受一个指向具有两个参数的函数的指针，第一个参数是类型模板参数`T`，第二个是`int`，并返回`void`。这个函数模板不能传递指向`alpha`（见`[1]`）的指针，因为这是一个函数模板，也不能传递指向`beta`（见`[2]`）的指针，因为`beta`有多个重载可以匹配类型`T`。然而，可以传递指向`gamma`（见`[3]`）的指针，并且它将正确推导出第二个重载的类型：
- en: '[PRE336]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Another limitation of the compiler is the argument deduction of the primary
    dimension of an array. The reason is this is not part of function parameter types.
    The exceptions to this limitation are the cases when the dimension refers to a
    reference or pointer type. The following code snippet demonstrates these restrictions:'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器的另一个限制是数组主维度的参数推导。原因是这并非函数参数类型的一部分。这个限制的例外情况是维度指向引用或指针类型。以下代码片段展示了这些限制：
- en: The call to `process1()` at `[1]` generates an error because the compiler is
    not able to deduce the value of the non-type template argument `Size`, since this
    refers to the primary dimension of an array.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`[1]`处的`process1()`调用产生错误，因为编译器无法推导出非类型模板参数`Size`的值，因为`Size`指向数组的主体维度。
- en: The call to `process2()` at the point marked with `[2]` is correct because the
    non-type template parameter `Size` refers to the second dimension of an array.
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标记为`[2]`的点处的`process2()`调用是正确的，因为非类型模板参数`Size`指向数组的第二维度。
- en: 'On the other hand, the calls to `process3()` (at `[3]`) and `process4()` (at
    `[4]`) are both successful, since the function argument is either a reference
    or a pointer to a single-dimensional array:'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，对`process3()`（在`[3]`处）和`process4()`（在`[4]`处）的调用都是成功的，因为函数参数要么是单个维度的数组的引用或指针：
- en: '[PRE337]'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE337]'
- en: If a non-type template argument is used in an expression in the function template
    parameter list, then the compiler cannot deduce its value.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在函数模板参数列表中的表达式中使用了非类型模板参数，则编译器无法推导其值。
- en: 'In the following snippet, `ncube` is a class template with a non-type template
    parameter `N` representing a number of dimensions. The function template `process`
    also has a non-type template parameter `N`, but this is used in an expression
    in the template parameter list of the type of its single parameter. As a result,
    the compiler cannot deduce the value of `N` from the type of the function argument
    (as seen at `[1]`) and this must be specified explicitly (as seen at `[2]`):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`ncube`是一个具有非类型模板参数`N`的类模板，`N`代表维度数。函数模板`process`也具有非类型模板参数`N`，但它在模板参数列表中的类型表达式中被用作表达式的一部分。因此，编译器不能从函数参数的类型中推断出`N`的值（如[1]所示），这必须显式指定（如[2]所示）：
- en: '[PRE338]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: All the rules for template argument deduction discussed in this section also
    apply to variadic function templates. However, everything that was discussed was
    in the context of function templates. Template argument deduction works for class
    templates too and we will explore this topic in the next section.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中讨论的所有模板参数推断规则也适用于变长函数模板。然而，所有讨论都是在函数模板的上下文中进行的。模板参数推断也适用于类模板，我们将在下一节中探讨这个主题。
- en: Class template argument deduction
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类模板参数推断
- en: 'Before **C++17**, template argument deduction only worked for functions but
    not classes. This meant that when a class template had to be instantiated, all
    the template arguments had to be supplied. The following snippet shows several
    examples:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在**C++17**之前，模板参数推断仅适用于函数，而不适用于类。这意味着当一个类模板需要实例化时，必须提供所有的模板参数。下面的代码片段展示了几个例子：
- en: '[PRE339]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'By leveraging template argument deduction for function templates, some standard
    types feature helper functions that create an instance of the type without the
    need to explicitly specify template arguments. Such examples are `std::make_pair`
    for `std::pair` and `std::make_unique` for `std::unique_ptr`. These helper function
    templates, used in corroboration with the `auto` keyword, avoid the need for specifying
    template arguments for class templates. Here is an example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用函数模板的模板参数推断，一些标准类型具有创建该类型实例的辅助函数，无需显式指定模板参数。例如，`std::make_pair`用于`std::pair`，`std::make_unique`用于`std::unique_ptr`。这些辅助函数模板与`auto`关键字一起使用，避免了为类模板指定模板参数的需要。以下是一个示例：
- en: '[PRE347]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'Although not all standard class templates have such a helper function for creating
    instances, it’s not hard to write your own. In the following snippet, we can see
    a `make_vector` function template used to create a `std::vector<T>` instance,
    and a `make_wrapper` function template to create a `wrapper<T>` instance:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有标准类模板都有创建实例的辅助函数，但编写自己的并不困难。在下面的代码片段中，我们可以看到一个用于创建`std::vector<T>`实例的`make_vector`函数模板，以及一个用于创建`wrapper<T>`实例的`make_wrapper`函数模板：
- en: '[PRE348]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'The C++17 standard has simplified the use of class templates by providing template
    argument deduction for them. Therefore, as of C++17, the first snippet shown in
    this section can be simplified as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: C++17标准通过为类模板提供模板参数推断来简化了它们的使用。因此，从C++17开始，本节中展示的第一个代码片段可以简化如下：
- en: '[PRE364]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'This is possible because the compiler is able to deduce the template arguments
    from the type of the initializers. In this example, the compiler deduced it from
    the initializing expression of the variables. But the compiler is also able to
    deduce template arguments from `new` expressions and function-style cast expressions.
    These are exemplified next:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器能够从初始化器的类型中推断出模板参数。在这个例子中，编译器是从变量的初始化表达式中推断出来的。但是编译器也能够从`new`表达式和函数式转换表达式中推断出模板参数。下面将举例说明：
- en: '[PRE367]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: The way template argument deduction works for class templates is different than
    for function templates but it relies on the latter. When encountering the name
    of a class template in a variable declaration or function-style cast, the compiler
    proceeds to build a set of so-called **deduction guides**.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板的模板参数推断方式与函数模板不同，但它依赖于后者。当在变量声明或函数式转换中遇到类模板的名称时，编译器会继续构建一组所谓的**推断指南**。
- en: There are fictional function templates representing constructor signatures of
    a *fictional class type*. Users can also provide deduction guides and these are
    added to the list of compiler-generated guides. If overload resolution fails on
    the constructed set of fictional function templates (the return type is not part
    of the matching process since these functions represent constructors), then the
    program is ill-formed and an error is generated. Otherwise, the return type of
    the selected function template specialization becomes the deduced class template
    specialization.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 有代表虚构类类型构造函数签名的虚构函数模板。用户也可以提供推导指南，这些将被添加到编译器生成的指南列表中。如果在虚构函数模板的构造集合上解析重载失败（返回类型不是匹配过程的一部分，因为这些函数代表构造函数），则程序是不良形式，并生成错误。否则，所选函数模板特化的返回类型成为推导出的类模板特化。
- en: 'To understand this better, let’s see how the deduction guides actually look.
    In the following snippet, you can see some of the guides generated by the compiler
    for the `std::pair` class. The actual list is longer and, for brevity, only some
    are presented here:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们看看推导指南实际上看起来是什么样子。在下面的代码片段中，你可以看到编译器为 `std::pair` 类生成的部分指南。实际的列表更长，为了简洁，这里只展示了部分：
- en: '[PRE381]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: This set of implicitly deduced guides is generated from the constructors of
    the class template. This includes the default constructor, the copy constructor,
    the move constructor, and all the conversion constructors, with the arguments
    copied in the exact order. If the constructor is explicit, then so is the deduction
    guide. However, if the class template does not have any user-defined constructor,
    a deduction guide is created for a hypothetical default constructor. A deduction
    guide for a hypothetical copy constructor is always created.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这组隐式推导指南是从类模板的构造函数生成的。这包括默认构造函数、拷贝构造函数、移动构造函数以及所有转换构造函数，参数以精确的顺序复制。如果构造函数是显式的，那么推导指南也是显式的。然而，如果类模板没有用户定义的构造函数，则会为假设的默认构造函数创建一个推导指南。假设的拷贝构造函数的推导指南总是被创建。
- en: 'User-defined deduction guides can be provided in the source code. The syntax
    is similar to that of functions with a trailing return type but without the `auto`
    keyword. Deduction guides can be either functions or function templates. What
    is important to keep in mind is that these must be provided in the same namespace
    as the class template they apply to. Therefore, if we were to add a user-defined
    deduction guide for the `std::pair` class, it must be done in the `std` namespace.
    An example is shown here:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在源代码中提供自定义推导指南。其语法类似于具有尾随返回类型的函数，但没有 `auto` 关键字。推导指南可以是函数或函数模板。重要的是要记住，这些必须在应用于类模板的同一命名空间中提供。因此，如果我们想为
    `std::pair` 类添加一个用户定义的推导指南，它必须在 `std` 命名空间中完成。以下是一个示例：
- en: '[PRE388]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'The deduction guides shown so far were all function templates. But as mentioned
    earlier, they don’t have to be function templates. They can be regular functions
    too. To demonstrate this, let’s consider the following example:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止显示的推导指南都是函数模板。但如前所述，它们不必是函数模板。它们也可以是普通函数。为了演示这一点，让我们考虑以下示例：
- en: '[PRE393]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'With the compiler-degenerated deduction guides for the `std::pair` class, the
    deduced types are `std::pair<int, const char*>` for `p1`, `std::pair<const char*,
    int>` for `p2`, and `std::pair<const char*, const char*>` for `p3`. In other words,
    the type deduced by the compiler where literal strings are used is `const char*`
    (as one should expect). We could tell the compiler to deduce `std::string` instead
    of `const char*` by providing several user-defined deduction guides. These are
    shown in the following listing:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `std::pair` 类的编译器生成的推导指南，推导出的类型分别是 `p1` 的 `std::pair<int, const char*>`、`p2`
    的 `std::pair<const char*, int>` 和 `p3` 的 `std::pair<const char*, const char*>`。换句话说，编译器推导出的类型，在用到字面字符串时是
    `const char*`（正如预期的那样）。我们可以通过提供几个用户定义的推导指南来告诉编译器推导出 `std::string` 而不是 `const char*`。这些将在下面的列表中展示：
- en: '[PRE397]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Notice that the first two are function templates, but the third one is a regular
    function. Having these guides available, the deduced types for `p1`, `p2`, and
    `p3` from the previous example are `std::pair<int, std::string>`, `std::pair<std::string,
    int>` and `std::pair<std::string, std::string>` respectively.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前两个是函数模板，但第三个是一个普通函数。有了这些指南，从上一个例子中推导出的 `p1`、`p2` 和 `p3` 的类型分别是 `std::pair<int,
    std::string>`、`std::pair<std::string, int>` 和 `std::pair<std::string, std::string>`。
- en: 'Let’s look at one more example for user-defined guides, this time for a user-defined
    class. Let’s consider the following class template that models a range:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个用户定义引导的例子，这次是一个用户定义的类。让我们考虑以下表示范围的类模板：
- en: '[PRE406]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: 'There is not much to this implementation but, in fact, it is enough for our
    purpose. Let’s consider you want to construct a range object from an array of
    integers:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现并没有太多内容，但实际上，它已经足够满足我们的需求了。让我们考虑你想要从一个整数数组构造一个范围对象：
- en: '[PRE417]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'Running this code will generate an error. Different compilers would generate
    different error messages. Perhaps Clang provides the error messages that best
    describe the problem:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将生成错误。不同的编译器会生成不同的错误信息。也许Clang提供的错误信息最能描述问题：
- en: '[PRE419]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'Nevertheless, regardless of what the actual error message is, the meaning is
    the same: template argument deduction for `range_t` failed. In order to make deduction
    work, a user-defined deduction guide needs to be provided and it needs to look
    as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论实际的错误信息是什么，意义都是相同的：`range_t`的模板参数推导失败。为了使推导工作，需要提供一个用户定义的推导引导，并且它需要看起来如下：
- en: '[PRE420]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: What this deduction guide is instructing is that when a call to the constructor
    with two iterator arguments is encountered, the value of the template parameter
    `T` should be deduced to be the value type of the iterator traits. Iterator traits
    is a topic that will be addressed in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*. However, with this available, the previous
    snippet runs without problems and the compiler deduces the type of the `r` variable
    to be `range_t<int>`, as intended.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推导引导所指示的是，当遇到带有两个迭代器参数的构造函数调用时，模板参数`T`的值应该被推导为迭代器特质的值类型。迭代器特质是一个将在[*第五章*](B18367_05_ePub.xhtml#_idTextAnchor080)中讨论的主题，即类型特质和条件编译。然而，有了这个，之前的代码片段可以正常运行，并且编译器推导出`r`变量的类型为`range_t<int>`，正如预期的那样。
- en: 'At the beginning of this section, the following example was provided, where
    the type of `w` was said to be deduced as `wrapper<int>`:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始部分，提供了一个示例，其中提到`w`的类型被推导为`wrapper<int>`：
- en: '[PRE424]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'In C++17, this is not actually true without a user-defined deduction guide.
    The reason is that `wrapper<T>` is an aggregate type and class template argument
    deduction does not work from aggregate initialization in C++17\. Therefore, to
    make the preceding line of code work, a deduction guide as follows needs to be
    provided:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，没有用户定义的推导引导，这实际上是不正确的。原因是`wrapper<T>`是一个聚合类型，并且在C++17中，类模板参数推导不能从聚合初始化中工作。因此，为了使前面的代码行工作，需要提供以下推导引导：
- en: '[PRE425]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: Fortunately, the need for such a user-defined deduction guide was removed in
    C++20\. This version of the standard provides support for aggregate types (as
    long as any dependent base class has no virtual functions or virtual base classes
    and the variable is initialized from a non-empty list of initializers).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在C++20中不再需要这样的用户定义的推导引导。这个标准版本提供了对聚合类型的支持（只要任何依赖的基类没有虚拟函数或虚拟基类，并且变量是从一个非空初始化器列表中初始化的）。
- en: 'Class template argument deduction only works *if no template arguments are
    provided*. As a consequence, the following declarations of `p1` and `p2` are both
    valid and class template argument deduction occurs; for `p2`, the deduced type
    is `std::pair<int, std::string>` (assuming the previously user-defined guides
    are available). However, the declarations of `p3` and `p4` produce an error because
    class template argument deduction does not occur, since a template argument list
    is present (`<>` and `<int>`) but does not contain all required arguments:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板参数推导仅在**没有提供模板参数**的情况下才有效。因此，以下对`p1`和`p2`的声明都是有效的，并且发生了类模板参数推导；对于`p2`，推导出的类型是`std::pair<int,
    std::string>`（假设之前定义的引导可用）。然而，`p3`和`p4`的声明会产生错误，因为类模板参数推导没有发生，因为存在一个模板参数列表（`<>`和`<int>`），但它不包含所有必需的参数：
- en: '[PRE427]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'Class template argument deduction may not always produce the expected results.
    Let’s consider the following example:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板参数推导可能不会总是产生预期的结果。让我们考虑以下示例：
- en: '[PRE431]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'The deduced type for `v1` is `std::vector<int>` and the deduced type for `v2`
    is `std::vector<std::vector<int>>`. However, what should the compiler deduce for
    the type of `v3`? There are two options: `std::vector<std::vector<int>>` and `std::vector<int>`.
    If your expectation is the former, you will be disappointed to learn that the
    compiler actually deduces the latter. This is because deduction depends on both
    *the number of arguments and their type*.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1`的推导类型是`std::vector<int>`，而`v2`的推导类型是`std::vector<std::vector<int>>`。然而，编译器应该推导出`v3`的类型是什么？有两种选择：`std::vector<std::vector<int>>`和`std::vector<int>`。如果你的预期是前者，你可能会失望地发现编译器实际上推导出后者。这是因为推导依赖于**参数的数量和类型**。'
- en: 'When the number of arguments is greater than one, it will use the constructor
    that takes an initializer list. For the `v2` variable, that is `std::initializer_list<std::vector<int>>`.
    When the number of arguments is one, then the type of the arguments is considered.
    If the type of the argument is a (specialization of) `std::vector` – considering
    this explicit case – then the copy-constructor is used and the deduced type is
    the declared type of the argument. This is the case of variable `v3`, where the
    deduced type is `std::vector<int>`. Otherwise, the constructor that takes an initializer
    list (with a single element) is used, as in the case of variable `v1`, for which
    the deduced type is `std::vector<int>`. These could be better visualized with
    the help of the cppinsights.io tool, which shows the following generated code
    (for the previous snippet). Notice that the allocator argument has been removed
    for brevity:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数数量大于一个时，它将使用接受初始化列表的构造函数。对于`v2`变量，那就是`std::initializer_list<std::vector<int>>`。当参数数量为一个时，则考虑参数的类型。如果参数的类型是`std::vector`（考虑这个显式情况）的类型，那么将使用复制构造函数，推导出的类型是参数的声明类型。这是变量`v3`的情况，推导出的类型是`std::vector<int>`。否则，将使用接受初始化列表（单个元素）的构造函数，就像变量`v1`的情况一样，其推导出的类型是`std::vector<int>`。这些可以用cppinsights.io工具更好地可视化，该工具显示了以下生成的代码（对于前面的片段）。注意，为了简洁起见，已经移除了分配器参数：
- en: '[PRE434]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: Class template argument deduction is a useful feature of C++17 with improvements
    for aggregate types in C++20\. It helps avoid writing unnecessary explicit template
    arguments when the compiler is able to deduce them, even though, in some cases,
    the compiler may require user-defined deduction guides for the deduction to work.
    It also avoids the need for creating factory functions, such as `std::make_pair`
    or `std::make_tuple`, that were a workaround for benefiting from template argument
    deduction before it was available for class templates.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板参数推导是C++17的一个有用特性，在C++20中对聚合类型进行了改进。它有助于避免在编译器能够推导出它们时编写不必要的显式模板参数，尽管在某些情况下，编译器可能需要用户定义的推导指南才能使推导工作。它还避免了创建工厂函数的需求，例如`std::make_pair`或`std::make_tuple`，这些函数是模板参数推导可用之前从类模板中受益的解决方案。
- en: There is more to template argument deduction than what we have discussed so
    far. There is a special case of function template argument deduction known as
    forwarding references. This will be addressed next.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数推导的内容比我们之前讨论的要多。有一个特殊的情况是函数模板参数推导，称为前向引用。这将在下一部分讨论。
- en: Forwarding references
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向引用
- en: 'One of the most important features that were added to the language in C++11
    is **move semantics**, which helps improve performance by avoiding making unnecessary
    copies. Move semantics are supported by another C++11 feature called **rvalue
    references**. Before discussing these, it is worth mentioning that, in C++, we
    have two kinds of values:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中添加到语言中的最重要的特性之一是**移动语义**，它通过避免不必要的复制来提高性能。移动语义由另一个称为**右值引用**的C++11特性支持。在讨论这些之前，值得提到的是，在C++中，我们有两种类型的值：
- en: '`&` operator. lvalues can appear both on the left and right sides of an assignment
    expression.'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`运算符。左值可以出现在赋值表达式的左侧和右侧。'
- en: '`&` operator. rvalues are literals and temporary objects and can only appear
    on the right side of an assignment expression.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`运算符。右值是字面量和临时对象，并且只能出现在赋值表达式的右侧。'
- en: Note
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In C++11, there are a few other value categories, glvalue, prvalue, and xvalue.
    Discussing them here would not benefit the current topic. However, you can read
    more about them at [https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category).
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 C++11 中，还有一些其他的值类别，如 glvalue、prvalue 和 xvalue。在这里讨论它们不会对当前主题有所帮助。然而，你可以在 [https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category)
    上了解更多关于它们的信息。
- en: 'References are aliases to already existing objects or functions. Just as we
    have two kinds of values, in C++11 we have two kinds of references:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是已存在对象或函数的别名。正如我们有两种类型的值一样，在 C++11 中，我们有两种类型的引用：
- en: '`&`, such as in `&x`, are references to lvalues.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`，例如在 `&x` 中，是左值的引用。'
- en: '`&&`, such as in `&&x`, are references to rvalues.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`，例如在 `&&x` 中，是右值的引用。'
- en: 'Let’s look at some examples to understand these concepts better:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来更好地理解这些概念：
- en: '[PRE444]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'We have three functions here: `f`, which takes an lvalue reference (that is,
    `int&`); `g`, which has two overloads, one for an lvalue reference, and one for
    an rvalue reference (that is, `int&&`); and `h`, which takes an rvalue reference.
    We also have two variables, `x` and `rx`. Here, `x` is an lvalue, whose type is
    `foo`. We can take its address with `&x`. An lvalue is also `rx`, which is an
    lvalue reference, whose type is `foo&`. Now, let’s see how we can call each of
    the `f`, `g`, and `h` functions:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有三个函数：`f`，它接受一个左值引用（即 `int&`）；`g`，它有两个重载，一个用于左值引用，另一个用于右值引用（即 `int&&`）；以及
    `h`，它接受一个右值引用。我们还有两个变量，`x` 和 `rx`。在这里，`x` 是一个左值，其类型是 `foo`。我们可以用 `&x` 来获取它的地址。左值还包括
    `rx`，它是一个左值引用，其类型是 `foo&`。现在，让我们看看我们如何调用每个 `f`、`g` 和 `h` 函数：
- en: '[PRE458]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'Because `x` and `rx` are both lvalues, passing them to `f` is OK since this
    function takes an lvalue reference. However, `foo{42}` is a temporary object,
    as it does not exist outside the context of the call to `f`. That means, it is
    an rvalue, and passing it to `f` will result in a compiler error, because the
    parameter of the function is of the type `foo&` and non-constant references may
    only be bound to lvalues. This would work if the signature of the function `f`
    was changed to `f(int const &v)`. Next, let’s discuss the `g` function:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `x` 和 `rx` 都是左值，所以将它们传递给 `f` 是可以的，因为这个函数接受左值引用。然而，`foo{42}` 是一个临时对象，因为它在
    `f` 的调用上下文之外不存在。这意味着它是一个右值，将 `foo{42}` 传递给 `f` 将导致编译器错误，因为函数的参数类型是 `foo&`，并且非常量引用只能绑定到左值。如果函数
    `f` 的签名改为 `f(int const &v)`，则可以解决这个问题。接下来，让我们讨论一下 `g` 函数：
- en: '[PRE462]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'In the preceding snippet, calling `g` with either `x` or `rx` will resolve
    to the first overload, which takes an lvalue reference. However, calling it with
    `foo{42}`, which is a temporary object, therefore an rvalue, will resolve to the
    second overload, which takes an rvalue reference. Let’s see what happens when
    we want to make the same calls to the `h` function:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用 `x` 或 `rx` 调用 `g` 将解析为第一个重载，它接受左值引用。然而，使用 `foo{42}`（这是一个临时对象，因此是右值）调用它将解析为第二个重载，它接受右值引用。让我们看看当我们想要对
    `h` 函数进行相同的调用时会发生什么：
- en: '[PRE465]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: This function takes an rvalue reference. The attempts to pass either `x` or
    `rx` to it result in compiler errors because lvalues cannot be bound to rvalue
    references. The expression `foo{42}`, being an rvalue, can be passed as an argument.
    We can also pass the lvalue `x` to the function `h` if we change its semantic
    from an lvalue to an rvalue. That is done with the help of `std::move`. This function
    does not really move anything; it only makes a sort of a cast from an lvalue to
    an rvalue.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个右值引用。尝试将 `x` 或 `rx` 传递给它会导致编译器错误，因为左值不能绑定到右值引用。表达式 `foo{42}` 是一个右值，可以作为参数传递。我们还可以通过将
    `h` 函数的语义从左值改为右值，将左值 `x` 传递给该函数。这是通过 `std::move` 实现的。这个函数实际上并没有移动任何东西；它只是进行了一种从左值到右值的类型转换。
- en: 'However, it is important to understand that passing rvalues to a function has
    two purposes: either the object is temporary and does not exist outside the call
    and the function can do anything with it, or the function is supposed to take
    ownership of the object that is received. This is the purpose of the move constructor
    and the move assignment operator and it’s rare that you will see other functions
    taking rvalue references. In our last example, within the function `h`, the parameter
    `v` is an lvalue but it is bound to an rvalue. The variable `x` existed outside
    the call to `h` but passing it to `std::move` transformed it into an rvalue. It
    still exists as an lvalue after the call to `h` returns but you should assume
    the function `h` did something with it and its state can be anything.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要理解将右值传递给函数有两个目的：要么对象是临时的，不存在于调用之外，函数可以对其做任何操作，要么函数应该接收并拥有该对象。这就是移动构造函数和移动赋值运算符的目的，而且你很少会看到其他函数接受右值引用。在我们最后的例子中，在函数
    `h` 内部，参数 `v` 是一个左值，但它绑定到一个右值上。变量 `x` 在调用 `h` 之前存在，但传递给 `std::move` 后将其转换成了右值。在
    `h` 的调用返回后，它仍然作为一个左值存在，但你应该假设函数 `h` 对其做了某些操作，其状态可以是任何东西。
- en: 'One purpose of rvalue references is, therefore, to enable move semantics. But
    it has yet another one and that is to enable `g` and `h`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，右值引用的一个目的是启用移动语义。但它还有一个目的，那就是启用 `g` 和 `h`：
- en: '[PRE469]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'In this snippet, the implementation of `g` is identical to the one seen earlier.
    However, `h` also has two overloads, one that takes an lvalue reference and calls
    `g` and another one that takes an rvalue reference and also calls `g`. In other
    words, the function `h` is just forwarding the argument to `g`. Now, let’s consider
    the following calls:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`g` 的实现与之前看到的相同。然而，`h` 也有两个重载，一个接受左值引用并调用 `g`，另一个接受右值引用并也调用 `g`。换句话说，函数
    `h` 只是将参数转发给 `g`。现在，让我们考虑以下调用：
- en: '[PRE473]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'From this, you would expect that the call `h(x)` will result in a call to the
    `g` overload taking an lvalue reference and the call to `h(foo{42})` will result
    in a call to the `g` overload taking an rvalue reference. However, in fact, both
    of them will call the first overload of `g`, therefore printing `g(foo&)` to the
    console. The explanation is actually simple once you understand how references
    work: in the context `h(foo&& v)`, the parameter `v` is actually an lvalue (it
    has a name and you can take its address) so calling `g` with it invokes the overload
    that takes an lvalue reference. To make it work as intended, we need to change
    the implementation of the `h` functions as follows:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，你可能会预期 `h(x)` 的调用将导致调用接受左值引用的重载 `g`，而 `h(foo{42})` 的调用将导致调用接受右值引用的重载
    `g`。然而，实际上，它们都会调用 `g` 的第一个重载，因此会在控制台上打印 `g(foo&)`。一旦你理解了引用的工作原理，这个解释实际上很简单：在 `h(foo&&
    v)` 的上下文中，参数 `v` 实际上是一个左值（它有一个名称，你可以获取它的地址），因此用 `v` 调用 `g` 将会调用接受左值引用的重载。为了让它按预期工作，我们需要按照以下方式更改
    `h` 函数的实现：
- en: '[PRE476]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: 'The `std::forward` is a function that enables the correct forwarding of values.
    What the function does is as follows:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward` 是一个函数，它能够正确地转发值。该函数的作用如下：'
- en: If the argument is an lvalue reference, then the function behaves just as a
    call to `std::move` (changing the semantics from an lvalue to an rvalue).
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个左值引用，那么函数的行为就像是对 `std::move` 的调用（将语义从左值转换为右值）。
- en: If the argument is an rvalue reference, then it does nothing.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个右值引用，那么它不做任何事情。
- en: Everything that we discussed so far is unrelated to templates, which are the
    subject of this book. However, function templates can also be used to take lvalue
    and rvalue references and it’s important to understand first how these work in
    non-templates scenarios. This is because, in templates, rvalue references work
    slightly differently, and sometimes they are rvalue references, but other times
    they are actually lvalue references.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止讨论的所有内容都与模板无关，模板是本书的主题。然而，函数模板也可以用来接受左值和右值引用，并且首先理解它们在非模板场景中的工作方式是很重要的。这是因为，在模板中，右值引用的工作方式略有不同，有时它们是右值引用，但有时它们实际上是左值引用。
- en: References that exhibit this behavior are called **forwarding references**.
    However, they are often referred to as **universal references**. This was a term
    coined by Scott Meyers shortly after C++11 when there was no term in the standard
    for this type of reference. In order to address this shortcoming, and because
    it didn’t feel the term universal references properly described their semantics,
    the C++ standard committee called these forwarding references in C++14\. Yet,
    both terms are equally present in literature. For the sake of being true to the
    standard terminology, we’ll call them forwarding references in this book.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 表现出这种行为的引用被称为**转发引用**。然而，它们通常被称为**通用引用**。这是 Scott Meyers 在 C++11 之后不久提出的术语，因为在标准中没有这个类型的引用的术语。为了解决这个不足，并且因为它觉得“通用引用”这个术语并不能很好地描述它们的语义，C++标准委员会在
    C++14 中将这些转发引用称为转发引用。然而，这两个术语在文献中都是同样存在的。为了忠实于标准术语，我们将在本书中称它们为转发引用。
- en: 'To begin the discussion on forwarding references, let’s consider the following
    overloaded function templates and class templates:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始讨论转发引用，让我们考虑以下重载的函数模板和类模板：
- en: '[PRE478]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: 'We can make calls to these functions as follows:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样调用这些函数：
- en: '[PRE493]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'From this snippet, we can notice that:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个片段中，我们可以注意到：
- en: Calling `f` with an lvalue or rvalue at `[1]` and `[2]` resolves to the first
    overload, `f(T&&)`.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `[1]` 和 `[2]` 处用左值或右值调用 `f` 会解析为第一个重载，`f(T&&)`。
- en: Calling `f` with a constant lvalue at `[3]` also resolves to the first overload,
    but calling `f` with a constant rvalue at `[4]` resolves to the second overload,
    `f(T const&&)`, because it’s a better match.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `[3]` 处用常量左值调用 `f` 也会解析为第一个重载，但用 `[4]` 处的常量右值调用 `f` 会解析为第二个重载，`f(T const&&)`，因为它是一个更好的匹配。
- en: Calling `f` with an lvalue `std::vector` object at `[5]` resolves to the first
    overload, but calling `f` with an rvalue `std::vector` object at `[6]` resolves
    to the third overload, `f(vector<T>&&)`, because it’s a better match.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `[5]` 处用左值 `std::vector` 对象调用 `f` 会解析为第一个重载，但用 `[6]` 处的右值 `std::vector` 对象调用
    `f` 会解析为第三个重载，`f(vector<T>&&)`，因为它是一个更好的匹配。
- en: Calling `S::f` with an lvalue at `[7]` is an error because lvalues cannot be
    bound to rvalue references, but calling it with an rvalue at `[8]` is correct.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `[7]` 处用左值调用 `S::f` 是一个错误，因为左值不能绑定到右值引用，但用 `[8]` 处的右值调用它是正确的。
- en: All the `f` function overloads in this example take an rvalue reference. However,
    the `&&` in the first overload does not necessarily mean an rvalue reference.
    It means *an rvalue reference if an rvalue was passed or an lvalue reference if
    an lvalue was passed*. Such a reference is called a `T&&` and nothing else. `T
    const&&` or `std::vector<T>&&` are not forwarding references, but normal rvalue
    references. Similarly, the `T&&` in the `f` function member of the class template
    `S` is also an rvalue reference because `f` is not a template but a non-template
    member function of a class template, so this rule for forwarding references does
    not apply.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有的 `f` 函数重载都接受一个右值引用。然而，第一个重载中的 `&&` 并不必然意味着一个右值引用。它意味着 *如果传递了一个右值，则是一个右值引用；如果传递了一个左值，则是一个左值引用*。这样的引用被称为
    `T&&`，没有其他。`T const&&` 或 `std::vector<T>&&` 不是转发引用，而是普通的右值引用。同样，类模板 `S` 的 `f`
    函数成员中的 `T&&` 也是一个右值引用，因为 `f` 不是一个模板，而是类模板的非模板成员函数，因此这个转发引用的规则不适用。
- en: Forwarding references are a special case of function template argument deduction,
    a topic that we previously discussed in this chapter. Their purpose is to enable
    perfect forwarding with templates and they are made possible by a new C++11 feature
    called **reference collapsing**. Let’s look at this first, before showing how
    they solve the perfect forwarding problem.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 转发引用是函数模板参数推导的一个特例，我们之前在本章中讨论过这个话题。它们的目的在于通过模板启用完美转发，并且它们是由 C++11 中的一个新特性**引用折叠**所实现的。让我们先看看这个，然后再展示它们是如何解决完美转发问题的。
- en: 'Prior to C++11, it was not possible to take a reference to a reference. However,
    that is now possible in C++11 for `typedef`s and templates. Here is an example:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前，不可能取一个引用的引用。然而，现在在 C++11 中，对于 `typedef`s 和模板来说这是可能的。以下是一个例子：
- en: '[PRE505]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'The rule is pretty simple: an rvalue reference to an rvalue reference collapses
    to an rvalue reference; all other combinations collapse to an lvalue reference.
    This can be put in a tabular form as follows:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 规则相当简单：一个右值引用的右值引用会折叠为一个右值引用；所有其他组合都会折叠为一个左值引用。这可以用以下表格形式表示：
- en: '![Table 4.2'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.2'
- en: '](img/B18367_04_Table_4.2.jpg)'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18367_04_Table_4.2.jpg)'
- en: Table 4.2
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2
- en: 'Any other combinations, shown in the following table, do not involve reference
    collapsing rules. These only apply when both types are references:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格中显示的任何其他组合都不涉及引用折叠规则。这些规则仅适用于两种类型都是引用的情况：
- en: '![Table 4.3'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.3'
- en: '](img/B18367_04_Table_4.3.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18367_04_Table_4.3.jpg)'
- en: Table 4.3
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3
- en: 'Forwarding references work not only for templates but also with auto deduction
    rules. When `auto&&` is found, it means a forwarding reference. The same does
    not apply for anything else, such as cv-qualified forms like `auto const&&`. Here
    are some examples:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 前向引用不仅适用于模板，也适用于自动推导规则。当发现`auto&&`时，意味着一个前向引用。这同样不适用于其他任何东西，例如`auto const&&`这样的cv-限定形式。以下是一些示例：
- en: '[PRE512]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: In the first two examples, `rx` and `rc` are both forwarding references and
    are bound to an lvalue and an rvalue respectively. However, `rcx` is an rvalue
    reference because `auto const&&` does not denote a forwarding reference. Therefore,
    trying to bind it to an lvalue is an error. Similarly, `rv` is a forwarding reference
    and is bound to an lvalue.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，`rx`和`rc`都是前向引用，分别绑定到一个左值和一个右值。然而，`rcx`是一个右值引用，因为`auto const&&`并不表示一个前向引用。因此，尝试将其绑定到一个左值是一个错误。同样，`rv`是一个前向引用，绑定到一个左值。
- en: 'As previously mentioned, the purpose of forwarding references is to enable
    perfect forwarding. We have seen the concept of perfect forwarding earlier but
    in a non-template context. It works, however, in a similar manner with templates.
    To demonstrate this, let’s redefine the function `h` as a template function. It
    would look as follows:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前向引用的目的是实现完美前向传递。我们之前已经看到了完美前向传递的概念，但是在非模板上下文中。然而，它在模板中也以类似的方式工作。为了演示这一点，让我们将函数`h`重新定义为模板函数。它看起来如下：
- en: '[PRE518]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: The implementation of the `g` overloads is the same, but the `h` overloads are
    now function templates. However, calling `h` with an lvalue and an rvalue actually
    resolves to the same call to `g`, the first overload taking an lvalue. This is
    because in the context of the function `h`, `v` is an lvalue so passing it to
    `g` will call the overload taking an lvalue.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`重载的实现是相同的，但`h`重载现在是函数模板。然而，用左值和右值调用`h`实际上解析为对`g`的相同调用，第一个重载接受一个左值。这是因为函数`h`的上下文中，`v`是一个左值，所以将其传递给`g`将调用接受左值的重载。这是因为函数`h`的上下文中，`v`是一个左值，所以将其传递给`g`将调用接受左值的重载。'
- en: 'The solution to this problem is the same as what we already saw before discussing
    templates. However, there is a difference: we no longer need two overloads, but
    a single one taking a forwarding reference:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法与我们之前在讨论模板时看到的方法相同。然而，有一个区别：我们不再需要两个重载，而是一个接受前向引用的单个重载：
- en: '[PRE525]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'This implementation is using `std::forward` to pass lvalues as lvalues and
    rvalues as rvalues. It works similarly for variadic function templates. The following
    is a conceptual implementation of the `std::make_unique` function that creates
    a `std::unique_ptr` object:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现使用`std::forward`将左值作为左值和右值作为右值传递。它对变长函数模板也以类似的方式工作。以下是对`std::make_unique`函数的概念性实现，该函数创建一个`std::unique_ptr`对象：
- en: '[PRE530]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: 'To summarize this section, remember that forwarding references (also known
    as **universal references**) are basically a special deduction rule for function
    template arguments. They work based on the rules of reference collapsing and their
    purpose is to enable perfect forwarding. That is passing forward to another function
    a reference by preserving its valueness semantics: rvalues should be passed as
    rvalues and lvalues as lvalues.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节内容，请记住，前向引用（也称为**通用引用**）基本上是函数模板参数的一个特殊推导规则。它们基于引用折叠的规则工作，其目的是实现完美前向传递。也就是说，通过保留其值语义将引用传递给另一个函数：右值应该作为右值传递，左值应该作为左值传递。
- en: The next topic that we will address in this chapter is the `decltype` specifier.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来我们将讨论的主题是`decltype`说明符。
- en: The decltype specifier
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`decltype`说明符'
- en: This specifier, introduced in C++11, returns the type of an expression. It is
    usually used in templates together with the `auto` specifier. Together, they can
    be used to declare the return type of a function template that depends on its
    template arguments, or the return type of a function that wraps another function
    and returns the result from executing the wrapped function.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这个说明符是在C++11中引入的，它返回一个表达式的类型。它通常与`auto`说明符一起在模板中使用。一起使用时，它们可以用来声明一个函数模板的返回类型，该模板的返回类型依赖于其模板参数，或者声明一个封装另一个函数并从封装的函数执行返回结果的函数的返回类型。
- en: 'The `decltype` specifier is not restricted for use in template code. It can
    be used with different expressions, and it yields different results based on the
    expression. The rules are as follows:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype` 指示符不限于在模板代码中使用。它可以与不同的表达式一起使用，并根据表达式产生不同的结果。规则如下：'
- en: If the expression is an identifier or a class member access, then the result
    is the type of the entity that is named by the expression. If the entity does
    not exist, or it is a function that has an overload set (more than one function
    with the same name exists), then the compiler will generate an error.
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表达式是一个标识符或类成员访问，则结果是表达式所命名的实体的类型。如果实体不存在，或者是一个具有重载集（存在多个具有相同名称的函数）的函数，则编译器将生成错误。
- en: If the expression is a function call or an overloaded operator function, then
    the result is the return type of the function. If the overloaded operator is wrapped
    in parentheses, these are ignored.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表达式是函数调用或重载运算符函数，则结果是函数的返回类型。如果重载运算符被括号包围，则忽略这些括号。
- en: If the expression is an lvalue, then the result type is an lvalue reference
    to the type of expression.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表达式是左值，则结果类型是表达式类型的左值引用。
- en: If the expression is something else, then the result type is the type of the
    expression.
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表达式是其他内容，则结果类型是表达式的类型。
- en: 'To understand these rules better, we’ll look at a set of examples. For these,
    we will consider the following functions and variables that we will use in `decltype`
    expressions:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些规则，我们将通过一系列示例来探讨。对于这些示例，我们将考虑以下在 `decltype` 表达式中使用的函数和变量：
- en: '[PRE536]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: 'The following listing shows multiple uses of the `decltype` specifier. The
    rule that applies in each case, as well as the deduced type, is specified on each
    line in a comment:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了 `decltype` 指示符的多种用法。每种情况下适用的规则以及推导出的类型，都在每行的注释中指定：
- en: '[PRE553]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: 'We will not elaborate on all these declarations. Most of these are relatively
    easy to follow based on the specified rules. A few notes, however, are worth considering
    for clarifying some of the deduced types:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细解释所有这些声明。大多数这些声明根据指定的规则相对容易理解。然而，以下几点值得考虑，以澄清一些推导出的类型：
- en: '`decltype(f)` only names a function with an overloaded set, so rule 1 applies.
    `decltype(g)` also names a function but it has an overloaded set. Therefore, rule
    1 applies and the compiler generates an error.'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decltype(f)` 只命名了一个具有重载集的函数，因此适用规则1。`decltype(g)` 也命名了一个函数，但它有一个重载集。因此，适用规则1，编译器生成错误。'
- en: '`decltype(f())` and `decltype(g(1))` are both using function calls for the
    expression, so the second rule applies, and even if `g` has an overload set, the
    declaration is correct.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decltype(f())` 和 `decltype(g(1))` 都使用了函数调用作为表达式，因此适用第二条规则，即使 `g` 有重载集，声明也是正确的。'
- en: '`decltype(&f)` uses the address of the function `f`, so the fourth rule applies,
    yielding `int(*)()`.'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decltype(&f)` 使用了函数 `f` 的地址，因此适用第四条规则，得到 `int(*)()`。'
- en: '`decltype(1+2)` and `decltype(a+1)` use the overloaded operator `+` that returns
    an rvalue, so the fourth rule applies. The result is `int`. However, `decltype(a
    = 1)` uses the assignment operator that returns an lvalue, so the third rule applies,
    yielding the lvalue reference `int&`.'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decltype(1+2)` 和 `decltype(a+1)` 使用了返回右值的重载运算符 `+`，因此适用第四条规则。结果是 `int`。然而，`decltype(a
    = 1)` 使用了返回左值的赋值运算符，因此适用第三条规则，得到左值引用 `int&`。'
- en: 'The `decltype` specifier defines an `a=1` is used with the `decltype` specifier
    to declare the variable `e`, but after the declaration, the value of `a` is the
    one with which it was initialized:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `decltype` 指示符的 `a=1` 声明变量 `e`，但在声明之后，`a` 的值是它被初始化时的值：
- en: '[PRE574]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: 'There is an exception to this rule concerning template instantiation. When
    the expression used with the `decltype` specifier contains a template, the template
    is instantiated before the expression is evaluated at compile time:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模板实例化的这个规则有一个例外。当与 `decltype` 指示符一起使用的表达式包含模板时，模板在编译时评估表达式之前被实例化：
- en: '[PRE577]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: The type of `e1` is `double`, and `wrapper<double>` is instantiated for this
    to be deduced. On the other hand, the type of `e2` is `int&` (as the variable
    `a` is an lvalue). However, `wrapper<char>` is instantiated here even if the type
    is only deduced from the variable `a` (due to the use of the comma operator).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`e1` 的类型是 `double`，因此为推导出此类型实例化了 `wrapper<double>`。另一方面，`e2` 的类型是 `int&`（因为变量
    `a` 是左值）。然而，即使类型仅从变量 `a` 推导出来（由于使用了逗号运算符），这里也实例化了 `wrapper<char>`。'
- en: 'The preceding rules mentioned are not the only ones used for determining the
    type. There are several more for data member access. These are as follows:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的规则不是用于确定类型的唯一规则。还有几个用于数据成员访问的规则。这些如下所示：
- en: The `const` or `volatile` specifiers of the object used in the `decltype` expression
    do not contribute to the deduced type.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `decltype` 表达式中使用的对象的 `const` 或 `volatile` 指定符不会对推导出的类型产生影响。
- en: Whether the object or pointer expression is an lvalue or an rvalue does not
    affect the deduced type.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象或指针表达式是左值还是右值不会影响推导出的类型。
- en: If the data member access expression is parenthesized, such as `decltype((expression))`,
    then the previous two rules do not apply. The `const` or `volatile` qualifier
    of the object does affect the deduced type, including the valueness of the object.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据成员访问表达式被括号括起来，例如 `decltype((expression))`，则前两条规则不适用。对象的 `const` 或 `volatile`
    修饰符会影响推导出的类型，包括对象的值的有效性。
- en: 'The first two rules from this list are demonstrated with the following snippet:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的前两条规则可以通过以下片段来证明：
- en: '[PRE585]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'The deduced type for each case is mentioned on the right side in a comment.
    When the expression is parenthesized, these two rules are reversed. Let’s take
    a look at the following snippet:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 每个情况的推导类型在右侧的注释中提到。当表达式被括号括起来时，这两个规则会颠倒。让我们看一下以下片段：
- en: '[PRE606]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: Here, all the expressions used with `decltype` for declaring variables `e1`
    to `e9` are lvalues, so the deduced type is an lvalue reference. On the other
    hand, the expression used to declare the variables `e10`, `e11`, and `e12` is
    an rvalue; therefore, the deduced type is an rvalue reference. Furthermore, `cf`
    is a constant object and `foo::a` has the type `int`. Therefore, the result type
    is `const int&`. Similarly, `foo::b` has the type `volatile int`; therefore, the
    result type is `const volatile int&`. These are just a few examples from this
    snippet, but the others follow the same rules for deduction.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有用于声明变量 `e1` 到 `e9` 的 `decltype` 表达式都是左值，所以推导出的类型是左值引用。另一方面，用于声明变量 `e10`、`e11`
    和 `e12` 的表达式是一个右值；因此，推导出的类型是右值引用。此外，`cf` 是一个常量对象，`foo::a` 的类型是 `int`。因此，结果类型是
    `const int&`。同样，`foo::b` 的类型是 `volatile int`；因此，结果类型是 `const volatile int&`。这只是这个片段中的几个例子，但其他例子遵循相同的推导规则。
- en: 'Because `decltype` is a type specifier, the redundant `const` and `volatile`
    qualifiers and reference specifiers are ignored. This is demonstrated with the
    following example:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `decltype` 是一个类型指定符，所以多余的 `const` 和 `volatile` 修饰符以及引用指定符会被忽略。这可以通过以下示例来证明：
- en: '[PRE624]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'So far in this section, we have learned how the `decltype` specifier works.
    However, its real purpose is to be used in templates, where the return value of
    a function depends on its template arguments and is not known before instantiation.
    To understand this scenario, let’s start with the following example of a function
    template that returns the minimum of two values:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们已经学习了 `decltype` 指定符的工作方式。然而，它的真正目的是在模板中使用，其中函数的返回值取决于其模板参数，并且在实例化之前是未知的。为了理解这种情况，让我们从以下函数模板的示例开始，该模板返回两个值中的较小值：
- en: '[PRE631]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: 'We can use this as follows:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE636]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: 'The first two calls are both correct, as the supplied arguments are of the
    same type. The third call, however, will produce a compiler error, because the
    arguments have different types. For this to work, we need to cast the integer
    value to a `double`. However, there is an alternative: we could write a function
    template that takes two arguments of potentially different types and returns the
    minimum of the two. This can look as follows:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 前两次调用都是正确的，因为提供的参数类型相同。然而，第三次调用将产生编译器错误，因为参数类型不同。为了使其工作，我们需要将整数值转换为 `double`
    类型。然而，有一个替代方案：我们可以编写一个函数模板，它接受两个可能不同类型的参数并返回两个中的较小值。这可以看起来如下所示：
- en: '[PRE640]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: The question is, what is the return type of this function? This can be implemented
    differently, depending on the standard version you are using.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，这个函数的返回类型是什么？这可以有不同的实现方式，具体取决于你使用的标准版本。
- en: 'In C++11, we can use the `auto` specifier with a trailing return type, where
    we use the `decltype` specifier to deduce the return type from an expression.
    This would look as follows:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 中，我们可以使用带尾随返回类型的 `auto` 指定符，其中我们使用 `decltype` 指定符从表达式中推导出返回类型。这看起来如下所示：
- en: '[PRE645]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'This syntax can be simplified if you’re using C++14 or a newer version of the
    standard. The trailing return type is no longer necessary. You can write the same
    function as follows:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 C++14 或更新的标准版本，这种语法可以简化。尾随返回类型不再是必需的。您可以像下面这样编写相同的函数：
- en: '[PRE650]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: 'It is possible to simplify this further and simply use `auto` for the return
    type, shown as follows:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步简化，简单地使用 `auto` 作为返回类型，如下所示：
- en: '[PRE655]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: 'Although `decltype(auto)` and `auto` have the same effect in this example,
    this is not always the case. Let’s consider the following example where we have
    a function returning a reference, and another function that calls it perfectly
    forwarding the argument:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中 `decltype(auto)` 和 `auto` 有相同的效果，但这并不总是如此。让我们考虑以下例子，其中有一个返回引用的函数，另一个函数完美转发参数调用它：
- en: '[PRE660]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: 'The function `func` returns a reference, and `func_caller` is supposed to do
    a perfect forwarding to this function. By using `auto` for the return type, it
    is inferred as `int` in the preceding snippet (see variable `r2`). In order to
    do a perfect forwarding of the return type, we must use `decltype(auto)` for it,
    as shown next:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `func` 返回一个引用，而 `func_caller` 应该完美转发到这个函数。通过使用 `auto` 作为返回类型，它在上面的代码片段中被推断为
    `int`（参见变量 `r2`）。为了完美转发返回类型，我们必须使用 `decltype(auto)`，如下所示：
- en: '[PRE673]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: This time, the result is as intended, and the type of both `r1` and `r2` in
    this snippet is `int const&`.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果正如预期的那样，这个代码片段中 `r1` 和 `r2` 的类型都是 `int const&`。
- en: As we have seen in this section, `decltype` is a type specifier used to deduce
    the type of an expression. It can be used in different contexts, but its purpose
    is for templates to determine the return type of a function and to ensure the
    perfect forwarding of it. Another feature that comes together with `decltype`
    is `std::declval`, which we will look at in the following section.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中看到的，`decltype` 是一个类型指定符，用于推导表达式的类型。它可以在不同的上下文中使用，但其目的是为了模板确定函数的返回类型并确保其完美转发。与
    `decltype` 一起出现的另一个特性是 `std::declval`，我们将在下一节中探讨。
- en: The std::declval type operator
  id: totrans-921
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::declval 类型操作符
- en: 'The `std::declval` is a utility type operation function, available in the `<utility>`
    header. It’s in the same category as functions such as `std::move` and `std::forward`
    that we have already seen. What it does is very simple: it adds an rvalue reference
    to its type template argument. The declaration of this function looks as follows:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::declval` 是一个实用类型操作函数，它包含在 `<utility>` 头文件中。它与我们已经看到的 `std::move` 和 `std::forward`
    等函数属于同一类别。它所做的是非常简单的：它为其类型模板参数添加一个右值引用。这个函数的声明如下所示：'
- en: '[PRE681]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: This function has no definition and therefore it cannot be called directly.
    It can only be used in `decltype`, `sizeof`, `typeid`, and `noexcept`. These are
    compile-time-only contexts that are not evaluated during runtime. The purpose
    of `std::declval` is to aid with dependent type evaluation for types that do not
    have a default constructor or have one but it cannot be accessed because it’s
    private or protected.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数没有定义，因此不能直接调用。它只能用于 `decltype`、`sizeof`、`typeid` 和 `noexcept`。这些是仅在编译时评估的上下文，不在运行时评估。`std::declval`
    的目的是帮助对没有默认构造函数或虽然有但无法访问（因为它私有或受保护）的类型进行依赖类型评估。
- en: 'To understand how this works, let’s consider a class template that does the
    composition of two values of different types, and we want to create a type alias
    for the result of applying the plus operator to two values of these types. How
    could such a type alias be defined? Let’s start with the following form:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，让我们考虑一个类模板，它将不同类型的两个值组合在一起，并且我们想要为将这些类型的两个值相加的结果创建一个类型别名。这样的类型别名应该如何定义？让我们从以下形式开始：
- en: '[PRE683]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: 'We can use the `decltype` specifier but we need to provide an expression. We
    cannot say `decltype(T + U)` because these are types, not values. We could invoke
    the default constructor and, therefore, use the expression `decltype(T{} + U{})`.
    This can work fine for built-in types such as `int` and `double`, as shown in
    the following snippet:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `decltype` 指示符，但我们需要提供一个表达式。我们不能说 `decltype(T + U)`，因为这些是类型，而不是值。我们可以调用默认构造函数，因此可以使用表达式
    `decltype(T{} + U{})`。这对于内置类型如 `int` 和 `double` 来说可以正常工作，如下面的代码片段所示：
- en: '[PRE688]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'It can also work for types that have an (accessible) default constructor. But
    it cannot work for types that don’t have a default constructor. The following
    type wrapper is such an example:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以适用于具有（可访问的）默认构造函数的类型。但它不能适用于没有默认构造函数的类型。以下是一个这样的类型包装器示例：
- en: '[PRE691]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '[PRE707]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: 'The solution here is to use `std::declval()`. The implementation of the class
    template composition would change as follows:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案是使用 `std::declval()`。类模板组合的实现将如下所示更改：
- en: '[PRE708]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: With this change, both the static asserts previously shown compile without any
    error. This function avoids the need to use particular values to determine the
    type of an expression. It produces a value of a type `T` without involving a default
    constructor. The reason it returns an rvalue reference is to enable us to work
    with types that cannot be returned from a function, such as arrays and abstract
    types.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，之前显示的静态断言编译时没有任何错误。这个函数避免了使用特定值来确定表达式类型的需要。它产生一个类型为 `T` 的值，而不涉及默认构造函数。它返回右值引用的原因是使我们能够处理不能从函数返回的类型，例如数组和抽象类型。
- en: The definition of the `wrapper` class earlier contained two friend operators.
    Friendship, when templates are involved, has some particularities. We will discuss
    this in the next section.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `wrapper` 类的定义中包含了两个友元运算符。当涉及到模板时，友元关系有一些特定的特性。我们将在下一节中讨论这个问题。
- en: Understanding friendship in templates
  id: totrans-963
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中理解友元关系
- en: 'When you define a class, you can restrict access to its member data and member
    functions with the `protected` and `private` access specifiers. If a member is
    private, it can only be accessed within the class. If a member is protected, it
    can be accessed from derived classes with public or protected access. However,
    a class can grant access to its private or protected members to other functions
    or classes with the help of the `friend` keyword. These functions or classes,
    to which special access has been granted, are called **friends**. Let’s take a
    look at a simple example:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个类时，你可以使用 `protected` 和 `private` 访问说明符来限制对其成员数据和成员函数的访问。如果一个成员是私有的，它只能在类内部访问。如果一个成员是受保护的，它可以通过派生类使用公共或受保护的访问来访问。然而，一个类可以通过使用
    `friend` 关键字将对其私有或受保护成员的访问权限授予其他函数或类。这些被授予特殊访问权限的函数或类被称为**友元**。让我们看看一个简单的例子：
- en: '[PRE714]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: The `wrapper` class has a private data member called `value`. There is a free
    function called `print` that takes an argument of the type `wrapper` and prints
    the wrapped value to the console. However, in order to be able to access it, the
    function is declared a friend of the `wrapper` class.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper` 类有一个名为 `value` 的私有数据成员。存在一个名为 `print` 的自由函数，它接受一个 `wrapper` 类型的参数，并将包装的值打印到控制台。然而，为了能够访问它，该函数被声明为
    `wrapper` 类的一个友元。'
- en: 'We will not focus on the way friendship works for non-templates. You should
    be familiar with this feature to proceed to discuss it in the context of templates.
    When it comes to templates, things get a bit complicated. We will look into this
    with the help of several examples. Let’s start with the following:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会关注非模板中友元关系的工作方式。你应该熟悉这个特性，以便在模板的上下文中讨论它。当涉及到模板时，事情会变得有些复杂。我们将通过几个示例来探讨这个问题。让我们从以下内容开始：
- en: '[PRE725]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: '[PRE734]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '[PRE740]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '[PRE744]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: 'The `print` function is now a function template. It has a type template parameter,
    but that’s not really used anywhere. That may look a bit odd, but it’s a valid
    code, and we need to invoke it by specifying the template argument. However, it
    helps us make a point: any template instantiation of `print`, regardless of the
    template argument, can access the private members of the `wrapper` class. Notice
    the syntax used to declare it as a friend of the `wrapper` class: it uses the
    template syntax. The same applies to the class template `printer`. It’s declared
    as a friend of the `wrapper` class and any template instantiation, regardless
    of the template argument, can access its private parts.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数现在是一个函数模板。它有一个类型模板参数，但实际上并没有在某个地方使用。这看起来可能有点奇怪，但它是一个有效的代码，我们需要通过指定模板参数来调用它。然而，它有助于我们提出一个观点：无论模板参数如何，任何
    `print` 的模板实例化都可以访问 `wrapper` 类的私有成员。注意声明它为 `wrapper` 类友元时使用的语法：它使用了模板语法。同样适用于类模板
    `printer`。它被声明为 `wrapper` 类和任何模板实例的友元，无论模板参数如何，都可以访问其私有部分。'
- en: 'What if we wanted to restrict access to only some instances of these templates?
    Such as only the specializations for the `int` type? Then, we can declare these
    specializations as friends, as shown here:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想限制对某些模板实例的访问怎么办？比如只对 `int` 类型的特殊化进行限制？那么，我们可以将这些特殊化声明为友元，如下所示：
- en: '[PRE749]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: '[PRE753]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '[PRE754]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: '[PRE760]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[PRE761]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '[PRE762]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: '[PRE763]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: '[PRE764]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: '[PRE765]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: '[PRE766]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: '[PRE767]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '[PRE768]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '[PRE769]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: '[PRE770]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '[PRE771]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: '[PRE772]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '[PRE773]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: '[PRE774]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: '[PRE775]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: '[PRE776]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: '[PRE777]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: '[PRE778]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: '[PRE779]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: '[PRE780]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: '[PRE781]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '[PRE782]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: '[PRE783]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '[PRE784]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: In this snippet, the `wrapper` class is the same as previously. For both the
    `print` function template and the `printer` class template, we have a primary
    template and a full specialization for the `int` type. Only the `int` instantiations
    are declared friends of the `wrapper` class. Attempting to access the private
    parts of the `wrapper` class in the primary templates generates compiler errors.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中，`wrapper`类与之前相同。对于`print`函数模板和`printer`类模板，我们都有一个主模板和针对`int`类型的完全特化。只有`int`实例被声明为`wrapper`类的友元。尝试在主模板中访问`wrapper`类的私有部分将生成编译器错误。
- en: 'In these examples, the class that granted friendship to its private parts was
    a non-template class. But class templates can also declare friends. Let’s see
    how it works in this case. We will start with the case of a class template and
    a non-template function:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，授予其私有部分友元权限的是非模板类。但类模板也可以声明友元。让我们看看在这种情况下它是如何工作的。我们将从类模板和非模板函数的情况开始：
- en: '[PRE785]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: '[PRE786]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: '[PRE787]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: '[PRE788]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: '[PRE789]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: '[PRE790]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '[PRE791]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '[PRE792]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[PRE793]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: '[PRE794]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[PRE795]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: '[PRE796]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: 'In this implementation, the `wrapper` class template declares the overload
    of print that takes a `wrapper<int>` as a parameter as being a friend. Therefore,
    in this overloaded function, we can access the private data member `value`, but
    not in any other overload. A similar case occurs when the friend function or class
    is a template and we want only one specialization to access the private parts.
    Let’s see the following snippet:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，`wrapper`类模板将接受`wrapper<int>`作为参数的打印重载声明为友元。因此，在此重载函数中，我们可以访问私有数据成员`value`，但在任何其他重载中则不行。当友元函数或类是模板且我们只想让一个特化访问私有部分时，也会发生类似的情况。让我们看看以下片段：
- en: '[PRE797]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: '[PRE798]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '[PRE799]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: '[PRE800]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: '[PRE801]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: '[PRE802]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: '[PRE803]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '[PRE804]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '[PRE805]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: '[PRE806]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '[PRE807]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '[PRE808]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: '[PRE809]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '[PRE810]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '[PRE811]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: '[PRE812]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: '[PRE813]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: '[PRE814]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: '[PRE815]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: '[PRE816]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '[PRE817]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '[PRE818]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '[PRE819]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '[PRE820]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '[PRE821]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '[PRE822]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: '[PRE823]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '[PRE824]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: '[PRE825]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: This implementation of the `wrapper` class template grants friendship to the
    `int` specializations of the `print` function template and `printer` class template.
    The attempt to access the private data member `value` in the primary templates
    (or any other specialization) would generate a compiler error.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 此`wrapper`类模板的实现将`print`函数模板和`printer`类模板的`int`特化授予了友元权限。尝试在主模板（或任何其他特化）中访问私有数据成员`value`将生成编译器错误。
- en: 'If the intention is that the `wrapper` class template gives friend access to
    any instantiation of the `print` function template or `printer` class template,
    then the syntax to do so is as follows:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意图是让`wrapper`类模板允许对`print`函数模板或`printer`类模板的任何实例化提供友元访问，那么实现这一点的语法如下：
- en: '[PRE826]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: '[PRE827]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: '[PRE828]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: '[PRE829]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: '[PRE830]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: '[PRE831]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: '[PRE832]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: '[PRE833]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: '[PRE834]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '[PRE835]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: '[PRE836]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: '[PRE837]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: '[PRE838]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '[PRE839]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: '[PRE840]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: '[PRE841]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: '[PRE842]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: '[PRE843]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: '[PRE844]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: '[PRE845]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: '[PRE846]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '[PRE847]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: 'Notice that in declaring the friends, the syntax is `template <typename U>`
    and not `template <typename T>`. The name of the template parameter, `U`, can
    be anything except for `T`. That would shadow the name of the template parameter
    of the `wrapper` class template and that is an error. Keep in mind though that
    with this syntax, any specialization of `print` or `printer` has access to the
    private members of any specialization of the `wrapper` class template. If you
    want that only the specializations of the friends that meet the template argument
    of the wrapper class have access to its private parts, then you must use the following
    syntax:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在声明友元时，语法是`template <typename U>`而不是`template <typename T>`。模板参数的名称`U`可以是任何名称，但不能是`T`。这会遮蔽`wrapper`类模板的模板参数名称，这是错误的。但请记住，使用这种语法，`print`或`printer`的任何特化都可以访问`wrapper`类模板任何特化的私有成员。如果你想只有满足`wrapper`类模板模板参数的友元特化可以访问其私有部分，那么你必须使用以下语法：
- en: '[PRE848]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: '[PRE849]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '[PRE850]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: '[PRE851]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: '[PRE852]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: '[PRE853]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: '[PRE854]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '[PRE855]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: '[PRE856]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: This is similar to what we have seen previously when access was granted only
    to the `int` specializations, except that now it’s for any specialization that
    matches `T`.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的类似，当时只有对`int`特化提供了访问权限，但现在是对任何匹配`T`的特化。
- en: 'Apart from these cases, it’s also possible for a class template to grant friendship
    to a type template parameter. This is demonstrated with the following example:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些情况之外，类模板还可以将友元权限授予类型模板参数。以下示例展示了这一点：
- en: '[PRE857]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: '[PRE858]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: '[PRE859]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '[PRE860]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: '[PRE861]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: '[PRE862]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: '[PRE863]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: '[PRE864]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: '[PRE865]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: '[PRE866]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: '[PRE867]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: '[PRE868]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: '[PRE869]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: '[PRE870]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: '[PRE871]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: '[PRE872]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: '[PRE873]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: '[PRE874]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: The `connection` class template has a private data member called `ConnectionString`.
    The type template parameter `T` is a friend of the class. The `executor` class
    uses the instantiation `connection<executor>`, which means the `executor` type
    is the template argument and benefits from the friendship with the `connection`
    class so that it can access the private data member `ConnectionString`.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection`类模板有一个名为`ConnectionString`的私有数据成员。类型模板参数`T`是类的友元。`executor`类使用`connection<executor>`实例化，这意味着`executor`类型是模板参数，并从与`connection`类的友元关系中受益，因此它可以访问私有数据成员`ConnectionString`。'
- en: 'As can be seen from all these examples, friendship with templates is slightly
    different than friendship among non-template entities. Remember that friends have
    access to all the non-public members of a class. Therefore, friendship should
    be granted with care. On the other hand, if you need to grant access to some private
    members but not all, this is possible with the help of the **client-attorney pattern**.
    This pattern allows you to control the granularity of access to the private parts
    of a class. You can learn more about this pattern at this URL: [https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client).'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 如所有这些示例所示，模板的友谊与非模板实体之间的友谊略有不同。请记住，朋友可以访问类的所有非公开成员。因此，友谊应该谨慎授予。另一方面，如果您需要授予对某些私有成员的访问权限，但不授予所有成员，这可以通过**客户-律师模式**实现。这种模式允许您控制对类私有部分的访问粒度。您可以在以下网址了解更多关于此模式的信息：[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client)。
- en: Summary
  id: totrans-1140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through a series of advanced topics. We started with
    name binding and dependent names and learned how to use the `typename` and the
    `template` keywords to tell the compiler what kind of dependent names we are referring
    to. Then, we learned about recursive templates and how to implement compile-time
    versions, using different approaches, for a recursive function.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一系列高级主题。我们首先从名称绑定和依赖名称开始，学习了如何使用`typename`和`template`关键字来告诉编译器我们正在引用哪种依赖名称。然后，我们学习了递归模板以及如何使用不同的方法实现递归函数的编译时版本。
- en: We also learned about argument deduction for both function templates and class
    templates and how to help the compiler to do the latter with the help of user-defined
    deduction guides. An important topic covered in this chapter was the forwarding
    references and how they help us to implement perfect forwarding. Toward the end
    of the chapter, we learned about the `decltype` type specifier, the `std::declvalue`
    type utility, and, lastly, how friendship works in the context of class templates.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了函数模板和类模板的参数推导，以及如何通过用户定义的推导指南帮助编译器完成后者。本章的一个重要主题是转发引用以及它们如何帮助我们实现完美转发。在章节的末尾，我们学习了`decltype`类型说明符、`std::declvalue`类型实用工具，以及最后，在类模板的上下文中友谊是如何工作的。
- en: In the next chapter, we begin utilizing the knowledge accumulated so far about
    templates to do template metaprogramming, which is, basically, writing code that
    is evaluated at compile-time.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始利用到目前为止积累的关于模板的知识来进行模板元编程，这基本上是在编译时评估的代码。
- en: Questions
  id: totrans-1144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When is name lookup performed?
  id: totrans-1145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称查找何时执行？
- en: What are deduction guides?
  id: totrans-1146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是推导指南？
- en: What are forwarding references?
  id: totrans-1147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转发引用是什么？
- en: What does `decltype` do?
  id: totrans-1148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decltype`做什么？'
- en: What does `std::declval` do?
  id: totrans-1149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::declval`做什么？'
- en: Further readings
  id: totrans-1150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Dependent name lookup for C++ templates* – Eli Bendersky, [https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates](https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates)'
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++模板的依赖名称查找* – Eli Bendersky，[https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates](https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates)'
- en: '*Universal References in C++11* – Scott Meyers, [https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)'
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++11中的通用引用* – Scott Meyers，[https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)'
- en: '*C++ Rvalue References Explained* – Thomas Becker, [http://thbecker.net/articles/rvalue_references/section_01.html](http://thbecker.net/articles/rvalue_references/section_01.html)'
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++右值引用解释* – Thomas Becker，[http://thbecker.net/articles/rvalue_references/section_01.html](http://thbecker.net/articles/rvalue_references/section_01.html)'
- en: '*Universal vs Forwarding References in C++* – Petr Zemek, [https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/](https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/)'
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++中的通用引用与转发引用* – Petr Zemek，[https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/](https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/)'
