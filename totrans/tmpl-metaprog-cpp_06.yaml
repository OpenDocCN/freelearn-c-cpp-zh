- en: '*Chapter 4*: Advanced Template Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we learned the core fundamentals of C++ templates.
    At this point, you should be able to write templates that are perhaps not very
    complex. However, there are many more details concerning templates, and this chapter
    is dedicated to these more advanced topics. These include the following topics
    that we address next:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding name binding and dependent names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring template recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding template argument deduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning forwarding references and perfect forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `decltype` specifier and the `std::declval` type operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding friendship in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On completing this chapter, you will acquire a deeper knowledge of these advanced
    template concepts and be able to understand and write more complex template code.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter by learning about name binding and dependent names.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding name binding and dependent names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term **name binding** refers to the process of finding the declaration
    of each name that is used within a template. There are two kinds of names used
    within a template: **dependent names** and **non-dependent names**. The former
    are names that depend on the type or value of a template parameter that can be
    a type, non-type, or template parameter. Names that don’t depend on template parameters
    are called *non-dependent*. The name lookup is performed differently for dependent
    and non-dependent names:'
  prefs: []
  type: TYPE_NORMAL
- en: For dependent names, it is performed at *the point of template instantiation*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-dependent names, it is performed at *the point of the template definition*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will first look at non-dependent names. As previously mentioned, name lookup
    happens at the point of the template definition. This is located immediately before
    the template definition. To understand how this works, let’s consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are several points of reference that are marked in the comments on the
    right side. At point `[1]`, we have the declaration of a class template called
    `parser`. This is followed at point `[2]` by the definition of a function called
    `handle` that takes a `double` as its argument. The definition of the class template
    follows at point `[3]`. This class contains a single method called `run` that
    invokes a function called `handle` with the value `42` as its argument, at point
    `[4]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name `handle` is a non-dependent name because it does not depend on any
    template parameter. Therefore, name lookup and binding are performed at this point.
    `handle` must be a function known at point `[3]` and the function defined at `[2]`
    is the only match. After the class template definition, at point `[5]` we have
    the definition of an overload for the function `handle`, which takes an integer
    as its argument. This is a better match for `handle(42)`, but it comes after the
    name binding has been performed, and therefore it will be ignored. In the `main`
    function, at point `[6]`, we have an instantiation of the `parser` class template
    for the type `int`. Upon calling the `run` function, the text `processing a double:
    42` will be printed to the console output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is designed to introduce you to the concept of dependent names.
    Let’s look at the code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This example is slightly different from the previous one. The `parser` class
    template is very similar, but the `handle` functions have become members of another
    class template. Let’s analyze it point by point.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the point mark with `[1]` in the comments, we have the definition of a class
    template called `handler`. This contains a single, public method called `handle`
    that takes an argument of the `T` type and prints its value to the console. Next,
    at point `[2]`, we have the definition of the class template called `parser`.
    This is similar to the previous one, except for one key aspect: at point `[3]`,
    it invokes a method called `handle` on its argument. Because the type of the argument
    is the template parameter `T`, it makes `handle` a dependent name. Dependent names
    are looked up at the point of template instantiation, so `handle` is not bound
    at this point. Continuing with the code, at point `[4]`, there is a template specialization
    for the `handler` class template for the type `int`. As a specialization, this
    is a better match for the dependent name. Therefore, when the template instantiation
    happens at point `[6]`, `handler<int>::handle` is the name that is bound to the
    dependent name used at `[3]`. Running this program will print `handler<int>: 42`
    to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how name binding occurs, let’s learn how this relates to
    template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Two-phase name lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key takeaway from the previous section is that name lookup happens differently
    for dependent names (those that depend on a template parameter) and non-dependent
    names (those that do not depend on a template parameter, plus the template name
    and names defined in the current template instantiation). When the compiler passes
    through the definition of a template it needs to figure out whether a name is
    dependent or non-dependent. Further name lookup depends on this categorization
    and happens either at the template definition point (for non-dependent names)
    or the template instantiation point (for dependent names). Therefore, instantiation
    of a template happens in two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The first phase occurs at the point of the definition when the template syntax
    is checked and names are categorized as dependent or non-dependent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second phase occurs at the point of instantiation when the template arguments
    are substituted for the template parameters. Name binding for dependent names
    happens at this point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This process in two steps is called **two-phase name lookup**. To understand
    it better, let’s consider another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we have two class templates: `base_parser`, which contains
    a public method called `init`, and `parser`, which derives from `base_parser`
    and contains a public method called `parse`. The `parse` member function calls
    a function called `init` and the intention is that it’s the base-class method
    `init` that is invoked here. However, the compiler will issue an error, because
    it’s not able to find `init`. The reason this happens is that `init` is a non-dependent
    name (as it does not depend on a template parameter). Therefore, it must be known
    at the point of the definition of the `parser` template. Although a `base_parser<T>::init`
    exists, the compiler cannot assume it’s what we want to call because the primary
    template `base_parser` can be later specialized and `init` can be defined as something
    else (such as a type, or a variable, or another function, or it may be missing
    entirely). Therefore, name lookup does not happen in the base class, only on its
    enclosing scope, and there is no function called `init` in `parser`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem can be fixed by making `init` a dependent name. This can be done
    either by prefixing with `this->` or with `base_parser<T>::`. By turning `init`
    into a dependent name, its name binding is moved from the point of template definition
    to the point of template instantiation. In the following snippet, this problem
    is solved by invoking `init` through the `this` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing this example, let’s consider that a specialization of `base_parser`
    for the `int` type is made available after the definition of the `parser` class
    template. This can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, let’s consider the following use of the `parser` class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this program, the following text will be printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this behavior is that `p1` is an instance of `parser<int>` and
    there is a specialization of its base class, `base_parser<int>` that implements
    the `init` function and prints `specialized init` to the console. On the other
    hand, `p2` is an instance of `parser<double>`. Since a specialization of `base_parser`
    for the `double` type is not available, the `init` function from the primary template
    is being called and this only prints `init` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The next subject of this broader topic is using dependent names that are types.
    Let’s learn how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent type names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples seen so far, the dependent name was a function or a member
    function. However, there are cases when a dependent name is a type. This is demonstrated
    with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `base_parser` is a class template that defines a type alias
    for `T` called `value_type`. The `parser` class template, which derives from `base_parser`,
    needs to use this type within its `parse` method. However, both `value_type` and
    `base_parser<T>::value_type` do not work, and the compiler is issuing an error.
    `value_type` does not work because it’s a non-dependent name and therefore it
    will not be looked up in the base class, only in the enclosing scope. `base_parser<T>::value_type`
    does not work either because the compiler cannot assume this is actually a type.
    A specialization of `base_parser` may follow and `value_type` could be defined
    as something else than a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this problem, we need to tell the compiler the name refers
    to a type. Otherwise, by default, the compiler assumes it’s not a type. This is
    done with the `typename` keyword, at the point of definition, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'There are actually two exceptions to this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: When specifying a base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When initializing class members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example for these two exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The `dictionay_traits` is a class used as the template argument for the `dictionary`
    class template. This class derives from `T::map_type` (see line `[1]`) but the
    use of the `typename` keyword is not required here. The dictionary class defines
    a member called `start_key`, which is an `int` initialized with the value of `T::identity`
    (see line `[2]`). Again, the `typename` keyword is not needed here. However, if
    we want to define yet another member of the type `T::key_type` (see line `[3]`)
    we do need to use `typename`.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for using `typename` have been relaxed in `[3]` previously
    no longer requires prefixing with the `typename` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, `typename` is implicit (can be deduced by the compiler) in the following
    contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: In using declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the declaration of data members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the declaration or definition of function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In trailing return types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In default arguments of type-parameters of a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the type-id of a `static_cast`, `const_cast`, `reinterpret_cast`, or `dynamic_cast`
    statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these contexts are exemplified in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: At all the lines marked with `[1]`, `[2]`, and `[3]` in this snippet, prior
    to C++20, the `typename` keyword was required to indicate a type name (such as
    `T::key_type` or `T::map_type::mapped_type`). When compiled with C++20, this is
    no longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), *Template Fundamentals*,
    we have seen that the keywords `typename` and `class` can be used to introduce
    type template parameters and they are interchangeable. The keyword `typename`
    here, although it has a similar purpose, cannot be substituted with the keyword
    `class`.
  prefs: []
  type: TYPE_NORMAL
- en: Not only types can be dependent names but other templates too. We look at this
    topic in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent template names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are cases when the dependent name is a template, such as a function template
    or a class template. However, the default behavior of the compiler is to interpret
    the dependent name as a non-type, which leads to errors concerning the usage of
    the comparison operator `<`. Let’s demonstrate this with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the previous snippets, but the `init` function in `base_parser`
    is also a template. The attempt to call it using the `base_parser<T>::init<int>()`
    syntax, as seen at point `[1]`, results in a compiler error. Therefore, we must
    use the `template` keyword to tell the compiler the dependent name is a template.
    This is done as shown at point `[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the `template` keyword can only follow the scope resolution
    operator (`::`), member access through pointer (`->`), and the member access (`.`).
    Examples of correct usage are `X::template foo<T>()`, `this->template foo<T>()`,
    and `obj.template foo<T>()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependent name does not have to be a function template. It can also be
    a class template, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The `token` class is an inner class template of the `base_parser` class template.
    It can be either used as in the line marked with `[1]`, where a type alias is
    defined (which is then used to instantiate an object) or as at line `[2]`, where
    it is used directly to declare a variable. Notice that the `typename` keyword
    is not necessary at `[1]`, where the using declaration indicates we are dealing
    with a type, but is required at `[2]` because the compiler would otherwise assume
    it’s a non-type name.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `typename` and `template` keywords is not required in some contexts
    of the current template instantiation being observed. This will be the topic of
    the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Current instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The requirement to use the `typename` and `template` keywords to disambiguate
    dependent names may be avoided in the context of a class template definition where
    the compiler is able to deduce some dependent names (such as the name of a nested
    class) to refer to the current instantiation. This means some errors can be identified
    sooner, at the point of definition instead of the point of instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete list of names that can refer to the current instantiation, according
    to the C++ *Standard, §13.8.2.1 - Dependent Types*, is presented in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_04_Table_4.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the rules for considering a name as part of the current instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: An unqualified name (that does not appear on the right side of the scope resolution
    operator `::`) found in the current instantiation or its non-dependent base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A qualified name (that appears on the right side of the scope resolution operator
    `::`) if its qualifier (the part that appears on the left side of the scope resolution
    operator) names the current instantiation and is found in the current instantiation
    or its non-dependent base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name used in a class member access expression where the object expression
    is the current instantiation and the name is found in the current instantiation
    or its non-dependent base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is said that a base class is a **dependent class** if it is a dependent type
    (depends on a template parameter) and is not in the current instantiation. Otherwise,
    a base class is said to be a **non-dependent class**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These rules may sound a bit harder to comprehend; therefore, let’s try to understand
    them with the help of several examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: In the primary template `parser`, the names `parser`, `parser<T>`, and `::parser<T>`
    all refer to the current instantiation. However, `parser<T*>` does not. The class
    `token` is a nested class of the primary template `parser`. In the scope of this
    class, `token` and `parser<T>::token` are both denoting the current instantiation.
    The same is not true for `parser<T*>::token`. This snippet also contains a partial
    specialization of the primary template for the pointer type `T*`. In the context
    of this partial specialization, `parser<T*>` is the current instantiation, but
    `parser<T>` is not.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent names are an important aspect of template programming. The key takeaway
    from this section is that names are categorized as dependent (those that depend
    on a template parameter) and non-dependent (those that don’t depend on a template
    parameter). Name binding happens at the point of definition for non-dependent
    types and at the point of instantiation for dependent types. In some cases, the
    keywords `typename` and `template` are required to disambiguate the use of names
    and tell the compiler that a name refers to a type or a template. In the context
    of a class template definition, the compiler is, however, able to figure out that
    some dependent names refer to the current instantiation, which enables it to identify
    errors sooner.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we move our attention to a topic that we briefly touched
    already, which is template recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring template recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*,
    we discussed variadic templates and saw that they are implemented with a mechanism
    that looks like recursion. In fact, it is overloaded functions and class template
    specializations respectively. However, it is possible to create recursive templates.
    To demonstrate how this works, we’ll look at implementing a compile-time version
    of the factorial function. This is typically implemented in a recursive manner,
    and a possible implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be trivial to understand: return the result of multiplying the
    function argument with the value returned by calling the function recursively
    with the decremented argument, or return the value `1` if the argument is `0`
    or `1`. The type of the argument (and the return value) is `unsigned int` to avoid
    calling it for negative integers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the value of the factorial function at compile time, we need to
    define a class template that contains a data member holding the value of the function.
    The implementation looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The first definition is the primary template. It has a non-type template parameter
    representing the value whose factorial needs to be computed. This class contains
    a static `constexpr` data member called `value`, initialized with the result of
    multiplying the argument `N` and the value of the factorial class template instantiated
    with the decremented argument. The recursion needs an end case and that is provided
    by the explicit specialization for the value `0` (of the non-type template argument),
    in which case the member value is initialized with `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When encountering the instantiation `factorial<4>::value` in the `main` function,
    the compiler generates all the recursive instantiations from `factorial<4>` to
    `factorial<0>`. These look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: From these instantiations, the compiler is able to compute the value of the
    data member `factorial<N>::value`. It should be mentioned again that when optimizations
    are enabled, this code would not even be generated, but the resulting constant
    is used directly in the generated assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the factorial class template is relatively trivial, and
    the class template is basically only a wrapper over the static data member `value`.
    We can actually avoid it altogether by using a variable template instead. This
    can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: There is a striking similarity between the implementation of the `factorial`
    class template and the `factorial` variable template. For the latter, we have
    basically taken out the data member value and called it `factorial`. On the other
    hand, this may also be more convenient to use because it does not require accessing
    the data member value as in `factorial<4>::value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a third approach for computing the factorial at compile time: using
    function templates. A possible implementation is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: You can see there is a primary template that calls the `factorial` function
    template recursively, and we have two full specializations for the values `1`
    and `0`, both returning `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which of these three different approaches is the best is probably arguable.
    Nevertheless, the complexity of the recursive instantiations of the factorial
    templates remained the same. However, this depends on the nature of the template.
    The following snippet shows an example of when complexity increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two class templates in this example. The first is called `wrapper`
    and has an empty implementation (it doesn’t actually matter what it contains)
    but it represents a wrapper class over some type (or more precisely a value of
    some type). The second template is called `manyfold_wrapper`. This represents
    a wrapper over a wrapper over a type many times over, hence the name `manyfold_wrapper`.
    There is no end case for an upper limit of this number of wrappings, but there
    is a start case for the lower limit. The full specialization for value `0` defines
    a member type called `value_type` for the `unsigned int` type. As a result, `manyfold_wrapper<1>`
    defines a member type called `value_type` for `wrapper<unsigned int>`, `manyfold_wrapper<2>`
    defines a member type called `value_type` for `wrapper<wrapper<unsigned int>>`,
    and so on. Therefore, executing the `main` function will print the following to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ standard does not specify a limit for the recursively nested template
    instantiations but does recommend a minimum limit of 1,024\. However, this is
    only a recommendation and not a requirement. Therefore, different compilers have
    implemented different limits. The **VC++ 16.11** compiler has the limit set at
    500, **GCC 12** at 900, and **Clang 13** at 1,024\. A compiler error is generated
    when this limit is exceeded. Some examples are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For VC++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'For GCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'For Clang:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: For GCC and Clang, the compiler option `-ftemplate-depth=N` can be used to increase
    this maximum value for nested template instantiations. Such an option is not available
    for the Visual C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive templates help us solve some problems in a recursive manner at compile
    time. Whether you use recursive function templates, variable templates, or class
    templates depends on the problem you are trying to solve or perhaps your preference.
    However, you should keep in mind there are limits to the depth template recursion
    works. Nevertheless, use template recursion judiciously.
  prefs: []
  type: TYPE_NORMAL
- en: The next advanced topic to address in this chapter is template argument deduction,
    both for functions and classes. We start next with the former.
  prefs: []
  type: TYPE_NORMAL
- en: Function template argument deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this book, we have briefly talked about the fact that the compiler
    can sometimes deduce the template arguments from the context of the function call,
    allowing you to avoid explicitly specifying them. The rules for template argument
    deduction are more complex and we will explore this topic in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start the discussion by looking at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `process` is a function template with a single type template
    parameter. The calls `process(42)` and `process<int>(42)` are identical because,
    in the first case, the compiler is able to deduce the type of the type template
    parameter `T` as `int` from the value of the argument passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler tries to deduce the template arguments, it performs the matching
    of the types of the template parameters with the types of the arguments used to
    invoke the function. There are some rules that govern this matching. The compiler
    can match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types (both cv-qualified and non-qualified) of the form `T`, `T const`, `T
    volatile`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pointers (`T*`), l-value references (`T&`), and r-value references (`T&&`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arrays such as `T[5]`, or `C[5][n]`, where `C` is a class type and `n` is a
    non-type template argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pointers to functions, with the form `T(*)()`, `C(*)(T)`, and `T(*)(U)`, where
    `C` is a class type and `T` and `U` are type template parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pointers to member functions with one of the following forms, `T (C::*)()`,
    `T (C::*)(U)`, `T (U::*)()`, `T (U::*)(V)`, `C (T::*)()`, `C (T::*)(U)`, and `D
    (C::*)(T)`, where `C` and `D` are class types and `T`, `U`, and `V` are type template
    parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pointers to data members such as `T C::*`, `C T::*`, and `T U::*`, where `C`
    is a class type and `T` and `U` are type template parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A template with an argument list that contains at least one type template parameter;
    the general form is `C<T>`, where `C` is a class type and `T` is a type template
    parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A template with an argument list that contains at least one non-type template
    argument; the general form is `C<i>`, where `C` is a class type and `i` a non-type
    template argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A template template argument with an argument list that contains at least one
    type template parameter; the general form is `TT<T>`, where `TT` is a template
    template parameter and `T` is a type template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A template template argument with an argument list that contains at least one
    non-type template argument; the general form is `TT<i>`, where `TT` is a template
    template parameter and `i` is a non-type template argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A template template argument with an argument list that has no template arguments
    dependent on a template parameter; this has the form `TT<C>`, where `TT` is the
    template template parameter and `C` is a class type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although the compiler is able to deduce many types of template parameters,
    as previously seen, there are also limitations to what it can do. These are exemplified
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler cannot deduce the type of a type template argument, from the type
    of a non-type template argument. In the following example, `process` is a function
    template with two template parameters: a type template called `T`, and a non-type
    template `i` of the type `T`. Calling the function with an array of five doubles
    does not allow the compiler to determine the type of `T`, even though this is
    the type of the value specifying the size of the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The compiler is not able to determine the type of a template argument from the
    type of a default value. This is exemplified ahead in the code with the function
    template `process`, which has a single type template parameter, but two function
    parameters, both of type `T` and both with default values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `process()` call (without any arguments) fails because the compiler cannot
    deduce the type of the type template parameter `T` from the default values of
    the function parameters. The `process<int>()` call is OK because the template
    argument is explicitly provided. The `process(6)` call is also OK, because the
    type of the first function parameter can be deduced from the supplied argument,
    and, therefore, the type template argument can also be deduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the compiler can deduce function template arguments from pointer to
    functions or pointer to member functions, as we have seen earlier, there are a
    couple of restrictions to this capability: it cannot deduce arguments from pointers
    to function templates, nor from a pointer to a function that has an overloaded
    set with more than one overloaded function matching the required type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the code ahead, the function template `invoke` takes a pointer to a function
    that has two arguments, the first of the type template parameter `T`, and the
    second an `int`, and returns `void`. This function template cannot be passed a
    pointer to `alpha` (see `[1]`) because this is a function template, nor to `beta`
    (see `[2]`), because this has more than one overload that can match the type `T`.
    However, it is possible to call it with a pointer to `gamma` (see `[3]`), and
    it will correctly deduce the type of the second overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Another limitation of the compiler is the argument deduction of the primary
    dimension of an array. The reason is this is not part of function parameter types.
    The exceptions to this limitation are the cases when the dimension refers to a
    reference or pointer type. The following code snippet demonstrates these restrictions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `process1()` at `[1]` generates an error because the compiler is
    not able to deduce the value of the non-type template argument `Size`, since this
    refers to the primary dimension of an array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `process2()` at the point marked with `[2]` is correct because the
    non-type template parameter `Size` refers to the second dimension of an array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the calls to `process3()` (at `[3]`) and `process4()` (at
    `[4]`) are both successful, since the function argument is either a reference
    or a pointer to a single-dimensional array:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: If a non-type template argument is used in an expression in the function template
    parameter list, then the compiler cannot deduce its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following snippet, `ncube` is a class template with a non-type template
    parameter `N` representing a number of dimensions. The function template `process`
    also has a non-type template parameter `N`, but this is used in an expression
    in the template parameter list of the type of its single parameter. As a result,
    the compiler cannot deduce the value of `N` from the type of the function argument
    (as seen at `[1]`) and this must be specified explicitly (as seen at `[2]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: All the rules for template argument deduction discussed in this section also
    apply to variadic function templates. However, everything that was discussed was
    in the context of function templates. Template argument deduction works for class
    templates too and we will explore this topic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Class template argument deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before **C++17**, template argument deduction only worked for functions but
    not classes. This meant that when a class template had to be instantiated, all
    the template arguments had to be supplied. The following snippet shows several
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'By leveraging template argument deduction for function templates, some standard
    types feature helper functions that create an instance of the type without the
    need to explicitly specify template arguments. Such examples are `std::make_pair`
    for `std::pair` and `std::make_unique` for `std::unique_ptr`. These helper function
    templates, used in corroboration with the `auto` keyword, avoid the need for specifying
    template arguments for class templates. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'Although not all standard class templates have such a helper function for creating
    instances, it’s not hard to write your own. In the following snippet, we can see
    a `make_vector` function template used to create a `std::vector<T>` instance,
    and a `make_wrapper` function template to create a `wrapper<T>` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++17 standard has simplified the use of class templates by providing template
    argument deduction for them. Therefore, as of C++17, the first snippet shown in
    this section can be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'This is possible because the compiler is able to deduce the template arguments
    from the type of the initializers. In this example, the compiler deduced it from
    the initializing expression of the variables. But the compiler is also able to
    deduce template arguments from `new` expressions and function-style cast expressions.
    These are exemplified next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: The way template argument deduction works for class templates is different than
    for function templates but it relies on the latter. When encountering the name
    of a class template in a variable declaration or function-style cast, the compiler
    proceeds to build a set of so-called **deduction guides**.
  prefs: []
  type: TYPE_NORMAL
- en: There are fictional function templates representing constructor signatures of
    a *fictional class type*. Users can also provide deduction guides and these are
    added to the list of compiler-generated guides. If overload resolution fails on
    the constructed set of fictional function templates (the return type is not part
    of the matching process since these functions represent constructors), then the
    program is ill-formed and an error is generated. Otherwise, the return type of
    the selected function template specialization becomes the deduced class template
    specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let’s see how the deduction guides actually look.
    In the following snippet, you can see some of the guides generated by the compiler
    for the `std::pair` class. The actual list is longer and, for brevity, only some
    are presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: This set of implicitly deduced guides is generated from the constructors of
    the class template. This includes the default constructor, the copy constructor,
    the move constructor, and all the conversion constructors, with the arguments
    copied in the exact order. If the constructor is explicit, then so is the deduction
    guide. However, if the class template does not have any user-defined constructor,
    a deduction guide is created for a hypothetical default constructor. A deduction
    guide for a hypothetical copy constructor is always created.
  prefs: []
  type: TYPE_NORMAL
- en: 'User-defined deduction guides can be provided in the source code. The syntax
    is similar to that of functions with a trailing return type but without the `auto`
    keyword. Deduction guides can be either functions or function templates. What
    is important to keep in mind is that these must be provided in the same namespace
    as the class template they apply to. Therefore, if we were to add a user-defined
    deduction guide for the `std::pair` class, it must be done in the `std` namespace.
    An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'The deduction guides shown so far were all function templates. But as mentioned
    earlier, they don’t have to be function templates. They can be regular functions
    too. To demonstrate this, let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'With the compiler-degenerated deduction guides for the `std::pair` class, the
    deduced types are `std::pair<int, const char*>` for `p1`, `std::pair<const char*,
    int>` for `p2`, and `std::pair<const char*, const char*>` for `p3`. In other words,
    the type deduced by the compiler where literal strings are used is `const char*`
    (as one should expect). We could tell the compiler to deduce `std::string` instead
    of `const char*` by providing several user-defined deduction guides. These are
    shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first two are function templates, but the third one is a regular
    function. Having these guides available, the deduced types for `p1`, `p2`, and
    `p3` from the previous example are `std::pair<int, std::string>`, `std::pair<std::string,
    int>` and `std::pair<std::string, std::string>` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one more example for user-defined guides, this time for a user-defined
    class. Let’s consider the following class template that models a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not much to this implementation but, in fact, it is enough for our
    purpose. Let’s consider you want to construct a range object from an array of
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will generate an error. Different compilers would generate
    different error messages. Perhaps Clang provides the error messages that best
    describe the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, regardless of what the actual error message is, the meaning is
    the same: template argument deduction for `range_t` failed. In order to make deduction
    work, a user-defined deduction guide needs to be provided and it needs to look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: What this deduction guide is instructing is that when a call to the constructor
    with two iterator arguments is encountered, the value of the template parameter
    `T` should be deduced to be the value type of the iterator traits. Iterator traits
    is a topic that will be addressed in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*. However, with this available, the previous
    snippet runs without problems and the compiler deduces the type of the `r` variable
    to be `range_t<int>`, as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, the following example was provided, where
    the type of `w` was said to be deduced as `wrapper<int>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++17, this is not actually true without a user-defined deduction guide.
    The reason is that `wrapper<T>` is an aggregate type and class template argument
    deduction does not work from aggregate initialization in C++17\. Therefore, to
    make the preceding line of code work, a deduction guide as follows needs to be
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, the need for such a user-defined deduction guide was removed in
    C++20\. This version of the standard provides support for aggregate types (as
    long as any dependent base class has no virtual functions or virtual base classes
    and the variable is initialized from a non-empty list of initializers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Class template argument deduction only works *if no template arguments are
    provided*. As a consequence, the following declarations of `p1` and `p2` are both
    valid and class template argument deduction occurs; for `p2`, the deduced type
    is `std::pair<int, std::string>` (assuming the previously user-defined guides
    are available). However, the declarations of `p3` and `p4` produce an error because
    class template argument deduction does not occur, since a template argument list
    is present (`<>` and `<int>`) but does not contain all required arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Class template argument deduction may not always produce the expected results.
    Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'The deduced type for `v1` is `std::vector<int>` and the deduced type for `v2`
    is `std::vector<std::vector<int>>`. However, what should the compiler deduce for
    the type of `v3`? There are two options: `std::vector<std::vector<int>>` and `std::vector<int>`.
    If your expectation is the former, you will be disappointed to learn that the
    compiler actually deduces the latter. This is because deduction depends on both
    *the number of arguments and their type*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the number of arguments is greater than one, it will use the constructor
    that takes an initializer list. For the `v2` variable, that is `std::initializer_list<std::vector<int>>`.
    When the number of arguments is one, then the type of the arguments is considered.
    If the type of the argument is a (specialization of) `std::vector` – considering
    this explicit case – then the copy-constructor is used and the deduced type is
    the declared type of the argument. This is the case of variable `v3`, where the
    deduced type is `std::vector<int>`. Otherwise, the constructor that takes an initializer
    list (with a single element) is used, as in the case of variable `v1`, for which
    the deduced type is `std::vector<int>`. These could be better visualized with
    the help of the cppinsights.io tool, which shows the following generated code
    (for the previous snippet). Notice that the allocator argument has been removed
    for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: Class template argument deduction is a useful feature of C++17 with improvements
    for aggregate types in C++20\. It helps avoid writing unnecessary explicit template
    arguments when the compiler is able to deduce them, even though, in some cases,
    the compiler may require user-defined deduction guides for the deduction to work.
    It also avoids the need for creating factory functions, such as `std::make_pair`
    or `std::make_tuple`, that were a workaround for benefiting from template argument
    deduction before it was available for class templates.
  prefs: []
  type: TYPE_NORMAL
- en: There is more to template argument deduction than what we have discussed so
    far. There is a special case of function template argument deduction known as
    forwarding references. This will be addressed next.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important features that were added to the language in C++11
    is **move semantics**, which helps improve performance by avoiding making unnecessary
    copies. Move semantics are supported by another C++11 feature called **rvalue
    references**. Before discussing these, it is worth mentioning that, in C++, we
    have two kinds of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&` operator. lvalues can appear both on the left and right sides of an assignment
    expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&` operator. rvalues are literals and temporary objects and can only appear
    on the right side of an assignment expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In C++11, there are a few other value categories, glvalue, prvalue, and xvalue.
    Discussing them here would not benefit the current topic. However, you can read
    more about them at [https://en.cppreference.com/w/cpp/language/value_category](https://en.cppreference.com/w/cpp/language/value_category).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References are aliases to already existing objects or functions. Just as we
    have two kinds of values, in C++11 we have two kinds of references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&`, such as in `&x`, are references to lvalues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&&`, such as in `&&x`, are references to rvalues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at some examples to understand these concepts better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three functions here: `f`, which takes an lvalue reference (that is,
    `int&`); `g`, which has two overloads, one for an lvalue reference, and one for
    an rvalue reference (that is, `int&&`); and `h`, which takes an rvalue reference.
    We also have two variables, `x` and `rx`. Here, `x` is an lvalue, whose type is
    `foo`. We can take its address with `&x`. An lvalue is also `rx`, which is an
    lvalue reference, whose type is `foo&`. Now, let’s see how we can call each of
    the `f`, `g`, and `h` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `x` and `rx` are both lvalues, passing them to `f` is OK since this
    function takes an lvalue reference. However, `foo{42}` is a temporary object,
    as it does not exist outside the context of the call to `f`. That means, it is
    an rvalue, and passing it to `f` will result in a compiler error, because the
    parameter of the function is of the type `foo&` and non-constant references may
    only be bound to lvalues. This would work if the signature of the function `f`
    was changed to `f(int const &v)`. Next, let’s discuss the `g` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, calling `g` with either `x` or `rx` will resolve
    to the first overload, which takes an lvalue reference. However, calling it with
    `foo{42}`, which is a temporary object, therefore an rvalue, will resolve to the
    second overload, which takes an rvalue reference. Let’s see what happens when
    we want to make the same calls to the `h` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: This function takes an rvalue reference. The attempts to pass either `x` or
    `rx` to it result in compiler errors because lvalues cannot be bound to rvalue
    references. The expression `foo{42}`, being an rvalue, can be passed as an argument.
    We can also pass the lvalue `x` to the function `h` if we change its semantic
    from an lvalue to an rvalue. That is done with the help of `std::move`. This function
    does not really move anything; it only makes a sort of a cast from an lvalue to
    an rvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is important to understand that passing rvalues to a function has
    two purposes: either the object is temporary and does not exist outside the call
    and the function can do anything with it, or the function is supposed to take
    ownership of the object that is received. This is the purpose of the move constructor
    and the move assignment operator and it’s rare that you will see other functions
    taking rvalue references. In our last example, within the function `h`, the parameter
    `v` is an lvalue but it is bound to an rvalue. The variable `x` existed outside
    the call to `h` but passing it to `std::move` transformed it into an rvalue. It
    still exists as an lvalue after the call to `h` returns but you should assume
    the function `h` did something with it and its state can be anything.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One purpose of rvalue references is, therefore, to enable move semantics. But
    it has yet another one and that is to enable `g` and `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, the implementation of `g` is identical to the one seen earlier.
    However, `h` also has two overloads, one that takes an lvalue reference and calls
    `g` and another one that takes an rvalue reference and also calls `g`. In other
    words, the function `h` is just forwarding the argument to `g`. Now, let’s consider
    the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you would expect that the call `h(x)` will result in a call to the
    `g` overload taking an lvalue reference and the call to `h(foo{42})` will result
    in a call to the `g` overload taking an rvalue reference. However, in fact, both
    of them will call the first overload of `g`, therefore printing `g(foo&)` to the
    console. The explanation is actually simple once you understand how references
    work: in the context `h(foo&& v)`, the parameter `v` is actually an lvalue (it
    has a name and you can take its address) so calling `g` with it invokes the overload
    that takes an lvalue reference. To make it work as intended, we need to change
    the implementation of the `h` functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::forward` is a function that enables the correct forwarding of values.
    What the function does is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is an lvalue reference, then the function behaves just as a
    call to `std::move` (changing the semantics from an lvalue to an rvalue).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the argument is an rvalue reference, then it does nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything that we discussed so far is unrelated to templates, which are the
    subject of this book. However, function templates can also be used to take lvalue
    and rvalue references and it’s important to understand first how these work in
    non-templates scenarios. This is because, in templates, rvalue references work
    slightly differently, and sometimes they are rvalue references, but other times
    they are actually lvalue references.
  prefs: []
  type: TYPE_NORMAL
- en: References that exhibit this behavior are called **forwarding references**.
    However, they are often referred to as **universal references**. This was a term
    coined by Scott Meyers shortly after C++11 when there was no term in the standard
    for this type of reference. In order to address this shortcoming, and because
    it didn’t feel the term universal references properly described their semantics,
    the C++ standard committee called these forwarding references in C++14\. Yet,
    both terms are equally present in literature. For the sake of being true to the
    standard terminology, we’ll call them forwarding references in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the discussion on forwarding references, let’s consider the following
    overloaded function templates and class templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make calls to these functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'From this snippet, we can notice that:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `f` with an lvalue or rvalue at `[1]` and `[2]` resolves to the first
    overload, `f(T&&)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `f` with a constant lvalue at `[3]` also resolves to the first overload,
    but calling `f` with a constant rvalue at `[4]` resolves to the second overload,
    `f(T const&&)`, because it’s a better match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `f` with an lvalue `std::vector` object at `[5]` resolves to the first
    overload, but calling `f` with an rvalue `std::vector` object at `[6]` resolves
    to the third overload, `f(vector<T>&&)`, because it’s a better match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `S::f` with an lvalue at `[7]` is an error because lvalues cannot be
    bound to rvalue references, but calling it with an rvalue at `[8]` is correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the `f` function overloads in this example take an rvalue reference. However,
    the `&&` in the first overload does not necessarily mean an rvalue reference.
    It means *an rvalue reference if an rvalue was passed or an lvalue reference if
    an lvalue was passed*. Such a reference is called a `T&&` and nothing else. `T
    const&&` or `std::vector<T>&&` are not forwarding references, but normal rvalue
    references. Similarly, the `T&&` in the `f` function member of the class template
    `S` is also an rvalue reference because `f` is not a template but a non-template
    member function of a class template, so this rule for forwarding references does
    not apply.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding references are a special case of function template argument deduction,
    a topic that we previously discussed in this chapter. Their purpose is to enable
    perfect forwarding with templates and they are made possible by a new C++11 feature
    called **reference collapsing**. Let’s look at this first, before showing how
    they solve the perfect forwarding problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to C++11, it was not possible to take a reference to a reference. However,
    that is now possible in C++11 for `typedef`s and templates. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule is pretty simple: an rvalue reference to an rvalue reference collapses
    to an rvalue reference; all other combinations collapse to an lvalue reference.
    This can be put in a tabular form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_04_Table_4.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other combinations, shown in the following table, do not involve reference
    collapsing rules. These only apply when both types are references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_04_Table_4.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Forwarding references work not only for templates but also with auto deduction
    rules. When `auto&&` is found, it means a forwarding reference. The same does
    not apply for anything else, such as cv-qualified forms like `auto const&&`. Here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: In the first two examples, `rx` and `rc` are both forwarding references and
    are bound to an lvalue and an rvalue respectively. However, `rcx` is an rvalue
    reference because `auto const&&` does not denote a forwarding reference. Therefore,
    trying to bind it to an lvalue is an error. Similarly, `rv` is a forwarding reference
    and is bound to an lvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, the purpose of forwarding references is to enable
    perfect forwarding. We have seen the concept of perfect forwarding earlier but
    in a non-template context. It works, however, in a similar manner with templates.
    To demonstrate this, let’s redefine the function `h` as a template function. It
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `g` overloads is the same, but the `h` overloads are
    now function templates. However, calling `h` with an lvalue and an rvalue actually
    resolves to the same call to `g`, the first overload taking an lvalue. This is
    because in the context of the function `h`, `v` is an lvalue so passing it to
    `g` will call the overload taking an lvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is the same as what we already saw before discussing
    templates. However, there is a difference: we no longer need two overloads, but
    a single one taking a forwarding reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is using `std::forward` to pass lvalues as lvalues and
    rvalues as rvalues. It works similarly for variadic function templates. The following
    is a conceptual implementation of the `std::make_unique` function that creates
    a `std::unique_ptr` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize this section, remember that forwarding references (also known
    as **universal references**) are basically a special deduction rule for function
    template arguments. They work based on the rules of reference collapsing and their
    purpose is to enable perfect forwarding. That is passing forward to another function
    a reference by preserving its valueness semantics: rvalues should be passed as
    rvalues and lvalues as lvalues.'
  prefs: []
  type: TYPE_NORMAL
- en: The next topic that we will address in this chapter is the `decltype` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The decltype specifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This specifier, introduced in C++11, returns the type of an expression. It is
    usually used in templates together with the `auto` specifier. Together, they can
    be used to declare the return type of a function template that depends on its
    template arguments, or the return type of a function that wraps another function
    and returns the result from executing the wrapped function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `decltype` specifier is not restricted for use in template code. It can
    be used with different expressions, and it yields different results based on the
    expression. The rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the expression is an identifier or a class member access, then the result
    is the type of the entity that is named by the expression. If the entity does
    not exist, or it is a function that has an overload set (more than one function
    with the same name exists), then the compiler will generate an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expression is a function call or an overloaded operator function, then
    the result is the return type of the function. If the overloaded operator is wrapped
    in parentheses, these are ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expression is an lvalue, then the result type is an lvalue reference
    to the type of expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expression is something else, then the result type is the type of the
    expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand these rules better, we’ll look at a set of examples. For these,
    we will consider the following functions and variables that we will use in `decltype`
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'The following listing shows multiple uses of the `decltype` specifier. The
    rule that applies in each case, as well as the deduced type, is specified on each
    line in a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not elaborate on all these declarations. Most of these are relatively
    easy to follow based on the specified rules. A few notes, however, are worth considering
    for clarifying some of the deduced types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`decltype(f)` only names a function with an overloaded set, so rule 1 applies.
    `decltype(g)` also names a function but it has an overloaded set. Therefore, rule
    1 applies and the compiler generates an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decltype(f())` and `decltype(g(1))` are both using function calls for the
    expression, so the second rule applies, and even if `g` has an overload set, the
    declaration is correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decltype(&f)` uses the address of the function `f`, so the fourth rule applies,
    yielding `int(*)()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decltype(1+2)` and `decltype(a+1)` use the overloaded operator `+` that returns
    an rvalue, so the fourth rule applies. The result is `int`. However, `decltype(a
    = 1)` uses the assignment operator that returns an lvalue, so the third rule applies,
    yielding the lvalue reference `int&`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `decltype` specifier defines an `a=1` is used with the `decltype` specifier
    to declare the variable `e`, but after the declaration, the value of `a` is the
    one with which it was initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an exception to this rule concerning template instantiation. When
    the expression used with the `decltype` specifier contains a template, the template
    is instantiated before the expression is evaluated at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: The type of `e1` is `double`, and `wrapper<double>` is instantiated for this
    to be deduced. On the other hand, the type of `e2` is `int&` (as the variable
    `a` is an lvalue). However, `wrapper<char>` is instantiated here even if the type
    is only deduced from the variable `a` (due to the use of the comma operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding rules mentioned are not the only ones used for determining the
    type. There are several more for data member access. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `const` or `volatile` specifiers of the object used in the `decltype` expression
    do not contribute to the deduced type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the object or pointer expression is an lvalue or an rvalue does not
    affect the deduced type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data member access expression is parenthesized, such as `decltype((expression))`,
    then the previous two rules do not apply. The `const` or `volatile` qualifier
    of the object does affect the deduced type, including the valueness of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two rules from this list are demonstrated with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'The deduced type for each case is mentioned on the right side in a comment.
    When the expression is parenthesized, these two rules are reversed. Let’s take
    a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: Here, all the expressions used with `decltype` for declaring variables `e1`
    to `e9` are lvalues, so the deduced type is an lvalue reference. On the other
    hand, the expression used to declare the variables `e10`, `e11`, and `e12` is
    an rvalue; therefore, the deduced type is an rvalue reference. Furthermore, `cf`
    is a constant object and `foo::a` has the type `int`. Therefore, the result type
    is `const int&`. Similarly, `foo::b` has the type `volatile int`; therefore, the
    result type is `const volatile int&`. These are just a few examples from this
    snippet, but the others follow the same rules for deduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `decltype` is a type specifier, the redundant `const` and `volatile`
    qualifiers and reference specifiers are ignored. This is demonstrated with the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: 'So far in this section, we have learned how the `decltype` specifier works.
    However, its real purpose is to be used in templates, where the return value of
    a function depends on its template arguments and is not known before instantiation.
    To understand this scenario, let’s start with the following example of a function
    template that returns the minimum of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two calls are both correct, as the supplied arguments are of the
    same type. The third call, however, will produce a compiler error, because the
    arguments have different types. For this to work, we need to cast the integer
    value to a `double`. However, there is an alternative: we could write a function
    template that takes two arguments of potentially different types and returns the
    minimum of the two. This can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: The question is, what is the return type of this function? This can be implemented
    differently, depending on the standard version you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++11, we can use the `auto` specifier with a trailing return type, where
    we use the `decltype` specifier to deduce the return type from an expression.
    This would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax can be simplified if you’re using C++14 or a newer version of the
    standard. The trailing return type is no longer necessary. You can write the same
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to simplify this further and simply use `auto` for the return
    type, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `decltype(auto)` and `auto` have the same effect in this example,
    this is not always the case. Let’s consider the following example where we have
    a function returning a reference, and another function that calls it perfectly
    forwarding the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `func` returns a reference, and `func_caller` is supposed to do
    a perfect forwarding to this function. By using `auto` for the return type, it
    is inferred as `int` in the preceding snippet (see variable `r2`). In order to
    do a perfect forwarding of the return type, we must use `decltype(auto)` for it,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: This time, the result is as intended, and the type of both `r1` and `r2` in
    this snippet is `int const&`.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this section, `decltype` is a type specifier used to deduce
    the type of an expression. It can be used in different contexts, but its purpose
    is for templates to determine the return type of a function and to ensure the
    perfect forwarding of it. Another feature that comes together with `decltype`
    is `std::declval`, which we will look at in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The std::declval type operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::declval` is a utility type operation function, available in the `<utility>`
    header. It’s in the same category as functions such as `std::move` and `std::forward`
    that we have already seen. What it does is very simple: it adds an rvalue reference
    to its type template argument. The declaration of this function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: This function has no definition and therefore it cannot be called directly.
    It can only be used in `decltype`, `sizeof`, `typeid`, and `noexcept`. These are
    compile-time-only contexts that are not evaluated during runtime. The purpose
    of `std::declval` is to aid with dependent type evaluation for types that do not
    have a default constructor or have one but it cannot be accessed because it’s
    private or protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let’s consider a class template that does the
    composition of two values of different types, and we want to create a type alias
    for the result of applying the plus operator to two values of these types. How
    could such a type alias be defined? Let’s start with the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `decltype` specifier but we need to provide an expression. We
    cannot say `decltype(T + U)` because these are types, not values. We could invoke
    the default constructor and, therefore, use the expression `decltype(T{} + U{})`.
    This can work fine for built-in types such as `int` and `double`, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also work for types that have an (accessible) default constructor. But
    it cannot work for types that don’t have a default constructor. The following
    type wrapper is such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution here is to use `std::declval()`. The implementation of the class
    template composition would change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: With this change, both the static asserts previously shown compile without any
    error. This function avoids the need to use particular values to determine the
    type of an expression. It produces a value of a type `T` without involving a default
    constructor. The reason it returns an rvalue reference is to enable us to work
    with types that cannot be returned from a function, such as arrays and abstract
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `wrapper` class earlier contained two friend operators.
    Friendship, when templates are involved, has some particularities. We will discuss
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding friendship in templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you define a class, you can restrict access to its member data and member
    functions with the `protected` and `private` access specifiers. If a member is
    private, it can only be accessed within the class. If a member is protected, it
    can be accessed from derived classes with public or protected access. However,
    a class can grant access to its private or protected members to other functions
    or classes with the help of the `friend` keyword. These functions or classes,
    to which special access has been granted, are called **friends**. Let’s take a
    look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: The `wrapper` class has a private data member called `value`. There is a free
    function called `print` that takes an argument of the type `wrapper` and prints
    the wrapped value to the console. However, in order to be able to access it, the
    function is declared a friend of the `wrapper` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not focus on the way friendship works for non-templates. You should
    be familiar with this feature to proceed to discuss it in the context of templates.
    When it comes to templates, things get a bit complicated. We will look into this
    with the help of several examples. Let’s start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print` function is now a function template. It has a type template parameter,
    but that’s not really used anywhere. That may look a bit odd, but it’s a valid
    code, and we need to invoke it by specifying the template argument. However, it
    helps us make a point: any template instantiation of `print`, regardless of the
    template argument, can access the private members of the `wrapper` class. Notice
    the syntax used to declare it as a friend of the `wrapper` class: it uses the
    template syntax. The same applies to the class template `printer`. It’s declared
    as a friend of the `wrapper` class and any template instantiation, regardless
    of the template argument, can access its private parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to restrict access to only some instances of these templates?
    Such as only the specializations for the `int` type? Then, we can declare these
    specializations as friends, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, the `wrapper` class is the same as previously. For both the
    `print` function template and the `printer` class template, we have a primary
    template and a full specialization for the `int` type. Only the `int` instantiations
    are declared friends of the `wrapper` class. Attempting to access the private
    parts of the `wrapper` class in the primary templates generates compiler errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these examples, the class that granted friendship to its private parts was
    a non-template class. But class templates can also declare friends. Let’s see
    how it works in this case. We will start with the case of a class template and
    a non-template function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: 'In this implementation, the `wrapper` class template declares the overload
    of print that takes a `wrapper<int>` as a parameter as being a friend. Therefore,
    in this overloaded function, we can access the private data member `value`, but
    not in any other overload. A similar case occurs when the friend function or class
    is a template and we want only one specialization to access the private parts.
    Let’s see the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of the `wrapper` class template grants friendship to the
    `int` specializations of the `print` function template and `printer` class template.
    The attempt to access the private data member `value` in the primary templates
    (or any other specialization) would generate a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the intention is that the `wrapper` class template gives friend access to
    any instantiation of the `print` function template or `printer` class template,
    then the syntax to do so is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in declaring the friends, the syntax is `template <typename U>`
    and not `template <typename T>`. The name of the template parameter, `U`, can
    be anything except for `T`. That would shadow the name of the template parameter
    of the `wrapper` class template and that is an error. Keep in mind though that
    with this syntax, any specialization of `print` or `printer` has access to the
    private members of any specialization of the `wrapper` class template. If you
    want that only the specializations of the friends that meet the template argument
    of the wrapper class have access to its private parts, then you must use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to what we have seen previously when access was granted only
    to the `int` specializations, except that now it’s for any specialization that
    matches `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these cases, it’s also possible for a class template to grant friendship
    to a type template parameter. This is demonstrated with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: The `connection` class template has a private data member called `ConnectionString`.
    The type template parameter `T` is a friend of the class. The `executor` class
    uses the instantiation `connection<executor>`, which means the `executor` type
    is the template argument and benefits from the friendship with the `connection`
    class so that it can access the private data member `ConnectionString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from all these examples, friendship with templates is slightly
    different than friendship among non-template entities. Remember that friends have
    access to all the non-public members of a class. Therefore, friendship should
    be granted with care. On the other hand, if you need to grant access to some private
    members but not all, this is possible with the help of the **client-attorney pattern**.
    This pattern allows you to control the granularity of access to the private parts
    of a class. You can learn more about this pattern at this URL: [https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Friendship_and_the_Attorney-Client).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through a series of advanced topics. We started with
    name binding and dependent names and learned how to use the `typename` and the
    `template` keywords to tell the compiler what kind of dependent names we are referring
    to. Then, we learned about recursive templates and how to implement compile-time
    versions, using different approaches, for a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about argument deduction for both function templates and class
    templates and how to help the compiler to do the latter with the help of user-defined
    deduction guides. An important topic covered in this chapter was the forwarding
    references and how they help us to implement perfect forwarding. Toward the end
    of the chapter, we learned about the `decltype` type specifier, the `std::declvalue`
    type utility, and, lastly, how friendship works in the context of class templates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we begin utilizing the knowledge accumulated so far about
    templates to do template metaprogramming, which is, basically, writing code that
    is evaluated at compile-time.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When is name lookup performed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are deduction guides?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are forwarding references?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `decltype` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `std::declval` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dependent name lookup for C++ templates* – Eli Bendersky, [https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates](https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Universal References in C++11* – Scott Meyers, [https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Rvalue References Explained* – Thomas Becker, [http://thbecker.net/articles/rvalue_references/section_01.html](http://thbecker.net/articles/rvalue_references/section_01.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Universal vs Forwarding References in C++* – Petr Zemek, [https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/](https://blog.petrzemek.net/2016/09/17/universal-vs-forwarding-references-in-cpp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
