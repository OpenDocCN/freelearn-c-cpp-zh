<html><head></head><body>
<div epub:type="chapter" id="_idContainer036">
<h1 class="chapter-number" id="_idParaDest-138"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-139"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.2.1">Atypical Allocation Mechanisms</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We are progressing in our exploration of memory management with C++. </span><span class="koboSpan" id="kobo.3.2">In </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we explored the various syntactic ways in which one can overload </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">operator new()</span></strong><span class="koboSpan" id="kobo.7.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">operator delete()</span></strong><span class="koboSpan" id="kobo.9.1"> (as well as their array counterparts), and in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.11.1">, we wrote an actual, real-life example (a memory leak detector) relying on the capacity to write such overloads. </span><span class="koboSpan" id="kobo.11.2">It’s a nice start, showing concretely that this knowledge has practical uses, but you might (rightfully) wonder what else we can do when controlling memory </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">management facilities.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">This chapter will be slightly different from the others. </span><span class="koboSpan" id="kobo.13.2">What we will do here is present a non-exhaustive set of ways in which one can benefit from taking control of the memory allocation functions of C++. </span><span class="koboSpan" id="kobo.13.3">More precisely, we will show </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">How placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">new</span></strong><span class="koboSpan" id="kobo.17.1"> can let us drive memory-mapped </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">hardware efficiently</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">How one can simplify usage of error management with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">nothrow</span></strong><span class="koboSpan" id="kobo.21.1"> version of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">operator new()</span></strong></span></li>
<li><span class="koboSpan" id="kobo.23.1">How one can install and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.25.1"> to make it easier to react to </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">out-of-memory situations</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">How one can handle “exotic” memories such as shared memory or persistent memory through the mediation of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">standard C++</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">At the end of this chapter, we will have a broader view of what opportunities the basic memory allocation facilities of C++ provide us with. </span><span class="koboSpan" id="kobo.29.2">Later chapters will return to more focused topics such as arena-based allocation (</span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.30.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.31.1">), deferred reclamation (</span><a href="B21071_11.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.33.1">), and, in later chapters, how to control memory allocation with containers </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">and allocators.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.35.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.36.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter9"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.40.1">Placement new and memory-mapped hardware</span></h1>
<p><span class="koboSpan" id="kobo.41.1">There are many uses for placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">new</span></strong><span class="koboSpan" id="kobo.43.1"> (an important</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.44.1"> feature</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.45.1"> discussed in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.47.1">, as you might remember) but one use that is particularly interesting is that it allows us to map software objects to memory-mapped hardware, effectively allowing us to drive hardware as if it </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">was software.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">A working example of this feature would be tricky to write as we would find ourselves in “non-portable code land,” using operating-system-specific features to get the address of a particular device and discussing ways to get read and write privileges to memory locations normally accessed by software drivers. </span><span class="koboSpan" id="kobo.49.2">For that reason, we will craft an artificial yet illustrative example and ask you, esteemed reader, to imagine that the missing parts of this </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">example exist.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">First, suppose that we are developing a driver for a new video card, one that is so wonderful that its codename is </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">super_video_card</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">For the sake of this illustration, we will model this through the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">following class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
#include &lt;cstdint&gt;
class super_video_card {
  // ...
</span><span class="koboSpan" id="kobo.55.2">public:
  // super duper registers
  volatile std::uint32_t r0{}, r1{}, r2{}, r3{};
  static_assert(sizeof(float) == 4); // sanity check
  volatile float f0{}, f1{}, f2{}, f3{};
  // etc.
</span><span class="koboSpan" id="kobo.55.3">  // initialize the video card's state
  super_video_card() = default;
  super_video_card(const super_video_card&amp;) = delete;
  super_video_card&amp;
    operator=(const super_video_card&amp;) = delete;
  // could be used to reset the video card's state
  ~super_video_card() = default;
  // various services (omitted for brevity)
};
// ...</span></pre> <p><span class="koboSpan" id="kobo.56.1">The important aspects of this class for our purpose are </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.58.1">It is an uncopiable type, as it is meant to map to a specific zone of memory. </span><span class="koboSpan" id="kobo.58.2">Copying</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.59.1"> an object </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.60.1">of this type would be counterproductive, to say </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the least.</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">It has been designed in such a way that its state can conceptually be superimposed on its hardware equivalent. </span><span class="koboSpan" id="kobo.62.2">For example, given the preceding class declaration, starting at the beginning of the hardware’s memory layout, we expect four 32-bit integral registers followed by four 32-bit floating point registers. </span><span class="koboSpan" id="kobo.62.3">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">&lt;cstdint&gt;</span></strong><span class="koboSpan" id="kobo.64.1"> to get the aliases for fixed-width integral types on </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">our compiler.</span></span></li>
<li><span class="koboSpan" id="kobo.66.1">As should be the case under such circumstances, we express our expectations through </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">static_assert</span></strong><span class="koboSpan" id="kobo.68.1"> whenever possible. </span><span class="koboSpan" id="kobo.68.2">Also, since the state of the hardware registers can change through other actions than that of our program, we qualified the register-equivalents as </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">volatile</span></strong><span class="koboSpan" id="kobo.70.1"> such that accesses to these member variables will be equivalent to I/O operations for the purpose of C++’s </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">abstract machine.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.72.1">Why do we use volatile variables in this example?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.73.1">If you are not used</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.74.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">volatile</span></strong><span class="koboSpan" id="kobo.76.1"> variables, you might be wondering why we used this qualification on the data members of our memory-mapped hardware-representing class. </span><span class="koboSpan" id="kobo.76.2">The reason why this is important is that we want to avoid our compiler optimizing code based on the (wrong, in this case) assumption that if our code does not touch these variables, then they do not change state or that if our writes to these variables are not followed by reads in our code, then that can be assumed to have no effect. </span><span class="koboSpan" id="kobo.76.3">Through </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">volatile</span></strong><span class="koboSpan" id="kobo.78.1">-qualified variables, we are effectively telling the compiler “</span><em class="italic"><span class="koboSpan" id="kobo.79.1">There are things you do not know happening on these objects, so please do not assume </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.80.1">too much</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">For simplicity, we used a constructor that zeros out the data members and a trivial destructor, but in practice, we could have used constructors (default or otherwise) to initialize the state of the memory-mapped device to match our needs and the destructor to reset the state of that device to some </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">acceptable state.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Normally, for a program to access the memory-mapped hardware, we would probably communicate with the operating system with services that accept as argument the required information to identify the device whose address we seek. </span><span class="koboSpan" id="kobo.84.2">In our case, we will simply make it look like we can access a zone of memory of the right size and alignment to which we can read and write. </span><span class="koboSpan" id="kobo.84.3">The memory address is exposed as raw memory (of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">void*</span></strong><span class="koboSpan" id="kobo.86.1">), which</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.87.1"> is</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.88.1"> what we can realistically expect from an operating system function under </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">similar circumstances:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
// somewhere in memory where we have read / write
// access privileges is a memory-mapped hardware
// that corresponds to the actual device
alignas(super_video_card) char
  mem_mapped_device[sizeof(super_video_card)];
void* get_super_card_address() {
  return mem_mapped_device;
}
// ...</span></pre> <p><span class="koboSpan" id="kobo.91.1">We then arrive at how one can use placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">new</span></strong><span class="koboSpan" id="kobo.93.1"> to map an object to some memory-mapped hardware location. </span><span class="koboSpan" id="kobo.93.2">Note that we need to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">&lt;new&gt;</span></strong><span class="koboSpan" id="kobo.95.1"> header as this is where placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">new</span></strong><span class="koboSpan" id="kobo.97.1"> is defined. </span><span class="koboSpan" id="kobo.97.2">The steps to meet our objective are </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.99.1">First, obtain the address where we want to map our carefully crafted </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">super_video_card</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1"> object.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Then, through placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">new</span></strong><span class="koboSpan" id="kobo.104.1"> at that address, construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">super_video_card</span></strong><span class="koboSpan" id="kobo.106.1"> object such that the data members of that object correspond to the address of the registers </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">they represent.</span></span></li>
<li><span class="koboSpan" id="kobo.108.1">For the duration of that object’s lifetime, use the object through the corresponding pointer (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">the_card</span></strong><span class="koboSpan" id="kobo.110.1"> variable in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">code excerpt).</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">When we are done, the one thing we do not want to do is apply </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">operator delete()</span></strong><span class="koboSpan" id="kobo.114.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">the_card</span></strong><span class="koboSpan" id="kobo.116.1"> as we never allocated the associated memory in the first place. </span><span class="koboSpan" id="kobo.116.2">We do want to finalize the object through </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">~super_video_card()</span></strong><span class="koboSpan" id="kobo.118.1">, however, to make sure the cleanup or reset code (if any) for that object </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">is run.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.120.1">We thus </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.121.1">end </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.122.1">up with </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
// ...
</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">#include &lt;new&gt;</span></strong><span class="koboSpan" id="kobo.126.1">
int main() {
  // map our object to the hardware
</span><strong class="bold"><span class="koboSpan" id="kobo.127.1">  void* p = get_super_card_address();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.128.1">  auto the_card =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.129.1">      new(p) super_video_card{ /* args */ };</span></strong><span class="koboSpan" id="kobo.130.1">
  // through pointer the_card, use the actual memory-
  // mapped hardware
  // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.131.1">  the_card-&gt;~super_video_card();</span></strong><span class="koboSpan" id="kobo.132.1">
}</span></pre> <p><span class="koboSpan" id="kobo.133.1">If the explicit destructor call is a problem, such as in code where exceptions could be thrown along the way, we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.135.1"> object with a custom deleter (see </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.137.1">) to finalize the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">super_video_card</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
// ...
</span><span class="koboSpan" id="kobo.140.2">#include &lt;new&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">#include &lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.142.1">
int main() {
  // map our object to the hardware
  void* p = get_super_card_address();
</span><strong class="bold"><span class="koboSpan" id="kobo.143.1">  std::unique_ptr&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.144.1">      super_video_card,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.145.1">      decltype([](super_video_card *p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.146.1">        p-&gt;~super_video_card(); // do not call delete p!</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.147.1">      })</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.148.1">  &gt; the_card {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.149.1">      new(p) super_video_card{ /* args */ }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.150.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.151.1">};</span></strong><span class="koboSpan" id="kobo.152.1">
  // through pointer the_card, use the actual memory-
  // mapped hardware
   // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.153.1">   // implicit call to the_card-&gt;~super_video_card()</span></strong><span class="koboSpan" id="kobo.154.1">
}</span></pre> <p><span class="koboSpan" id="kobo.155.1">In</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.156.1"> this</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.157.1"> case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.159.1">  object finalizes the pointee (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">super_video_card</span></strong><span class="koboSpan" id="kobo.161.1"> object) but does not free its memory storage, leading to more robust code in the presence of exceptions during the lifetime of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">the_card</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> variable.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.164.1">Simplifying nothrow new usage</span></h1>
<p><span class="koboSpan" id="kobo.165.1">As mentioned in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.166.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.167.1">, the default behavior of </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">operator new()</span></strong><span class="koboSpan" id="kobo.169.1"> when unable to perform an</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.170.1"> allocation request is to throw an exception. </span><span class="koboSpan" id="kobo.170.2">This can result from such situations as running out of memory or otherwise being unable to service the allocation request, in which case, one usually throws </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.172.1">; from an incorrect array length (for example, a negative length of one exceeding implementation-defined limits), usually leading to </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">std::bad_array_new_length</span></strong><span class="koboSpan" id="kobo.174.1"> being thrown; or from failure to complete the subsequent construction of the object following the completion of </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">operator new()</span></strong><span class="koboSpan" id="kobo.176.1">, in which case, the exception that will be thrown will be whatever was thrown from the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">failing constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Exceptions are the “normal” way for a C++ function to signal failure to meet the function’s postconditions. </span><span class="koboSpan" id="kobo.178.2">In some cases, such as a constructor or an overloaded operator, it’s the only real, workable way to do so: a constructor has no return value, and the signature of functions that overload operators generally does not leave room for additional arguments or error-reporting return values, although one could make a case for some types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">std::optional</span></strong><span class="koboSpan" id="kobo.180.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">std::expected</span></strong><span class="koboSpan" id="kobo.182.1"> as allowing an alternative for some overloaded operator </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">Of course, some domains typically do not use exceptions: a significant number of video games are compiled without exception support, for example, and the same goes for a lot of programs written for embedded systems. </span><span class="koboSpan" id="kobo.184.2">Reasons invoked go from the technical (fear of overhead considered undesirable in terms of memory space consumption, execution speed, or both) to the more philosophical (dislike for what is seen as hidden control paths), but no matter what the reasons are, the fact is that C++ code compiled without exception support exists and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">nothrow</span></strong><span class="koboSpan" id="kobo.186.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">operator new()</span></strong><span class="koboSpan" id="kobo.188.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">a reality.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">This does mean, of course, that even seemingly simple code such as the following can lead</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.191.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">undefined </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.193.1">behavior</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.195.1">UB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
#include &lt;new&gt;
#include &lt;iostream&gt;
struct X {
  int n;
  X(int n) : n { n } { }
};
int main() {
  auto p = </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">new (std::nothrow) X{ 3 }</span></strong><span class="koboSpan" id="kobo.199.1">;
</span><strong class="bold"><span class="koboSpan" id="kobo.200.1">  std::cout &lt;&lt; p-&gt;n; // &lt;-- HERE</span></strong><span class="koboSpan" id="kobo.201.1">
  delete p;
}</span></pre> <p><span class="koboSpan" id="kobo.202.1">The reason for this potential UB is that if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">nothrow</span></strong><span class="koboSpan" id="kobo.204.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">operator new()</span></strong><span class="koboSpan" id="kobo.206.1"> fails (unlikely but not impossible, especially in memory-constrained situations), then </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">p</span></strong><span class="koboSpan" id="kobo.208.1"> will be null, and accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">n</span></strong><span class="koboSpan" id="kobo.210.1"> data member through </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">p</span></strong><span class="koboSpan" id="kobo.212.1"> will be… a very </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">bad idea.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Of course, the solution is simple, and being the astute reader that you are, you have probably noticed it </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.215.1">already: just test the pointer before using it! </span><span class="koboSpan" id="kobo.215.2">This works, of course, as </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
#include &lt;new&gt;
#include &lt;iostream&gt;
struct X {
  int n;
  X(int n) : n { n } { }
};
int main() {
  auto p = </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">new (std::nothrow) X{ 3 }</span></strong><span class="koboSpan" id="kobo.219.1">;
</span><strong class="bold"><span class="koboSpan" id="kobo.220.1">  if(p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.221.1">      std::cout &lt;&lt; p-&gt;n; // ...use *p as needed...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.222.1">  }</span></strong><span class="koboSpan" id="kobo.223.1">
  delete p; // fine even in p is null
}</span></pre> <p><span class="koboSpan" id="kobo.224.1">The problem with this approach is that code quickly becomes littered with tests, as there is rarely only one pointer in a program, reminding us that the beauty of code using exceptions is that one does not need to worry about those tests. </span><span class="koboSpan" id="kobo.224.2">With exceptions, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">operator new()</span></strong><span class="koboSpan" id="kobo.226.1"> and the subsequent construction both succeeded and one can use the resulting pointer confidently, or one of these steps failed and code execution did not reach the point where one could get </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">into trouble:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
#include &lt;new&gt;
#include &lt;iostream&gt;
struct X {
  int n;
  X(int n) : n { n } { }
};
int main() {
  auto p = </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">new X{ 3 }</span></strong><span class="koboSpan" id="kobo.230.1">; // throws if operator new() or
                        // X::X(int) fails
</span><strong class="bold"><span class="koboSpan" id="kobo.231.1">  std::cout &lt;&lt; p-&gt;n; // ...use *p as needed...</span></strong><span class="koboSpan" id="kobo.232.1">
  delete p;
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">Of course, one can</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.234.1"> get in trouble even with exceptions, for example, if there is an execution path that lets </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">p</span></strong><span class="koboSpan" id="kobo.236.1"> remain null or uninitialized and others where that cannot happen (you can usually avoid this by initializing your objects on declaration, but that is not always possible); let us leave these code hygiene considerations aside for now as they would deviate from our topic </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">of interest.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">An important consideration when facing a failure-to-allocate situation is what to do when it happens. </span><span class="koboSpan" id="kobo.238.2">Whether our code base uses exceptions or not, we most probably do not want to let the execution of our program continue and therefore incur UB through such things as the improper use of a </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">null pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">A common way to stop execution at the point of failure-to-allocate is to wrap the tentative allocation and construction operation, the subsequent test on the resulting pointer, and the action to take if the pointer is null in some code construct. </span><span class="koboSpan" id="kobo.240.2">The code we want to wrap will be something like the following, supposing we want to allocate-then-construct an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
// ...
</span><span class="koboSpan" id="kobo.243.2">int *p = new int{ 3 };
if(!p) std::abort(); // for example
return p;
// ...</span></pre> <p><span class="koboSpan" id="kobo.244.1">This code used </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">std::abort()</span></strong><span class="koboSpan" id="kobo.246.1"> as a mechanism to end program execution; exceptions would provide us with potentially recoverable errors, but without exceptions, most standard mechanisms at our disposal will lead to program termination, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">std::abort()</span></strong><span class="koboSpan" id="kobo.248.1"> is a</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.249.1"> reasonable choice in </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">this case.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.251.1">Ways to conclude program execution</span></p>
<p class="callout"><span class="koboSpan" id="kobo.252.1">A C++ program can conclude in many different ways: reaching the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">main()</span></strong><span class="koboSpan" id="kobo.254.1"> function is the most obvious one, but other examples exist. </span><span class="koboSpan" id="kobo.254.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">std::exit()</span></strong><span class="koboSpan" id="kobo.256.1"> is used for normal program termination accompanied by cleanup steps; </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">std::quick_exit()</span></strong><span class="koboSpan" id="kobo.258.1"> is used for program termination without cleanup steps. </span><span class="koboSpan" id="kobo.258.2">One can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">std::atexit()</span></strong><span class="koboSpan" id="kobo.260.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">std::at_quick_exit()</span></strong><span class="koboSpan" id="kobo.262.1"> to register some functions to be called before exiting, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">std::abort()</span></strong><span class="koboSpan" id="kobo.264.1"> is used to signal abnormal program termination without cleanup steps. </span><span class="koboSpan" id="kobo.264.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">std::terminate()</span></strong><span class="koboSpan" id="kobo.266.1"> function is used when some unpleasantness in a documented list of situations occurs (this list includes such things as an exception being thrown from the constructor of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">static</span></strong><span class="koboSpan" id="kobo.268.1"> variable or from the body of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">noexcept</span></strong><span class="koboSpan" id="kobo.270.1"> function). </span><span class="koboSpan" id="kobo.270.2">In our case, the only mechanism that really fit </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">was </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">std::abort()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">One possible approach</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.275.1"> to solve this problem is to use a macro and an </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">immediately-invoked function expression</span></strong><span class="koboSpan" id="kobo.277.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.278.1">IIFE</span></strong><span class="koboSpan" id="kobo.279.1">), which is the name given to an expression made from an anonymous lambda that is at once created, executed, and discarded. </span><span class="koboSpan" id="kobo.279.2">To make our solution general, we need to be able to do </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.281.1">Specify the type of object </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">to create</span></span></li>
<li><span class="koboSpan" id="kobo.283.1">Make the macro variadic, as we need to be able to pass any number of arguments of any type to the </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">object’s constructor</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.285.1">A possible implementation of such a macro would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">TRY_NEW</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.287.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
#include &lt;new&gt;
#include &lt;cstdlib&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.289.1">#define TRY_NEW(T,...) [&amp;] { \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.290.1">  auto p = new (std::nothrow) T(__VA_ARGS__); \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.291.1">  if(!p) std::abort(); \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.292.1">  return p; \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.293.1">}()</span></strong><span class="koboSpan" id="kobo.294.1">
struct dies_when_newed {
  void* operator new(std::size_t, std::nothrow_t) {
      return {};
  }
};
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.295.1">  // p0 is int*, points to an int{ 0 }</span></strong><span class="koboSpan" id="kobo.296.1">
  auto p0 = </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">TRY_NEW(int)</span></strong><span class="koboSpan" id="kobo.298.1">;
</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">  // p1 is int*, points to an int{ 3 }</span></strong><span class="koboSpan" id="kobo.300.1">
  auto p1 = </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">TRY_NEW(int, 3)</span></strong><span class="koboSpan" id="kobo.302.1">;
  auto q = </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">TRY_NEW(dies_when_newed)</span></strong><span class="koboSpan" id="kobo.304.1">; </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">// calls abort()</span></strong><span class="koboSpan" id="kobo.306.1">
}</span></pre> <p><span class="koboSpan" id="kobo.307.1">Not everyone is</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.308.1"> familiar with variadic macros, so let’s take it step </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">by step:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.310.1">The “signature” of our macro is </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">TRY_NEW(T,...)</span></strong><span class="koboSpan" id="kobo.312.1">, meaning </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">T</span></strong><span class="koboSpan" id="kobo.314.1"> is mandatory and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">...</span></strong><span class="koboSpan" id="kobo.316.1"> could be any number of tokens (including none at all) separated by commas. </span><span class="koboSpan" id="kobo.316.2">Unsurprisingly, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">T</span></strong><span class="koboSpan" id="kobo.318.1"> for the type to construct and </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">...</span></strong><span class="koboSpan" id="kobo.320.1"> for the arguments to pass to the constructor that will </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">be invoked.</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">Since we wrote the macro on more than one line (for readability), each line but the last terminates with a space followed by a backslash to inform the preprocessor that it should continue parsing on the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">next line.</span></span></li>
<li><span class="koboSpan" id="kobo.324.1">The symbols on </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">...</span></strong><span class="koboSpan" id="kobo.326.1"> are relayed through the special macro named </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">__VA_ARGS__</span></strong><span class="koboSpan" id="kobo.328.1">, which expands to what </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">...</span></strong><span class="koboSpan" id="kobo.330.1"> contained and can be empty if </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">...</span></strong><span class="koboSpan" id="kobo.332.1"> itself is empty. </span><span class="koboSpan" id="kobo.332.2">This works in both C and C++. </span><span class="koboSpan" id="kobo.332.3">Note that we use parentheses, not braces, in the constructor call as we want to avoid unwittingly building an initializer list if all elements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">__VA_ARGS__</span></strong><span class="koboSpan" id="kobo.334.1"> are of the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">same type.</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">We test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">p</span></strong><span class="koboSpan" id="kobo.338.1"> pointer resulting from the call to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">std::nothrow</span></strong><span class="koboSpan" id="kobo.340.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">operator new()</span></strong><span class="koboSpan" id="kobo.342.1"> and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">std::abort()</span></strong><span class="koboSpan" id="kobo.344.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">p</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.346.1">is null.</span></span></li>
<li><span class="koboSpan" id="kobo.347.1">This entire sequence of operations is, as announced, wrapped in an IIFE and the newly allocated pointer is returned. </span><span class="koboSpan" id="kobo.347.2">Note that we could also have returned a </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.349.1"> object from that lambda if we had wanted to do so. </span><span class="koboSpan" id="kobo.349.2">Also, note that this lambda expression uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">[&amp;]</span></strong><span class="koboSpan" id="kobo.351.1"> capture block to ensure the availability </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.352.1">of tokens in </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">__VA_ARGS__</span></strong><span class="koboSpan" id="kobo.354.1"> within the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the lambda.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.356.1">A small but interesting side effect</span></p>
<p class="callout"><span class="koboSpan" id="kobo.357.1">Note that since we used parentheses (the same would hold for braces), an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">__VAR_ARGS__</span></strong><span class="koboSpan" id="kobo.359.1"> will lead this macro to zero-initialize fundamental types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">int</span></strong><span class="koboSpan" id="kobo.361.1"> instead of leaving them uninitialized. </span><span class="koboSpan" id="kobo.361.2">You can compare: as of C++23, </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">new int;</span></strong><span class="koboSpan" id="kobo.363.1"> yields a pointer to an uninitialized </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">int</span></strong><span class="koboSpan" id="kobo.365.1"> object, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">new int();</span></strong><span class="koboSpan" id="kobo.367.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">new int{};</span></strong><span class="koboSpan" id="kobo.369.1"> both initialize the allocated block with a value of zero. </span><span class="koboSpan" id="kobo.369.2">There is an upside to this, as with this macro, we will not end up with a pointer to an uninitialized object, even for trivial types. </span><span class="koboSpan" id="kobo.369.3">However, there is also a downside as we will be paying for an initialization even in cases where it might not have </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">been necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Another approach would be to use a variadic function template, which might lead to a better debugging experience in practice. </span><span class="koboSpan" id="kobo.371.2">It has slightly different-looking client code but is otherwise similar in usage </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">and effect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
#include &lt;new&gt;
#include &lt;cstdlib&gt;
#include &lt;utility&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">template &lt;class T, class ... </span><span class="koboSpan" id="kobo.374.2">Args&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.375.1">  auto try_new(Args &amp;&amp;... </span><span class="koboSpan" id="kobo.375.2">args) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.376.1">      auto p =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.377.1">        new (std::nothrow) T(std::forward&lt;Args&gt;(args)...);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.378.1">      if(!p) std::abort();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.379.1">      return p;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.380.1">  }</span></strong><span class="koboSpan" id="kobo.381.1">
struct dies_when_newed {
  void* operator new(std::size_t, std::nothrow_t) {
      return {};
  }
};
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.382.1">  // p0 is int*, points to an int{ 0 }</span></strong><span class="koboSpan" id="kobo.383.1">
  auto p0 = </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">try_new&lt;int&gt;()</span></strong><span class="koboSpan" id="kobo.385.1">;
</span><strong class="bold"><span class="koboSpan" id="kobo.386.1">  // p1 is int*, points to an int{ 3 }</span></strong><span class="koboSpan" id="kobo.387.1">
  auto p1 = </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">try_new&lt;int&gt;(3)</span></strong><span class="koboSpan" id="kobo.389.1">;
  auto q = </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">try_new&lt;dies_when_newed&gt;()</span></strong><span class="koboSpan" id="kobo.391.1">; </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">// calls abort()</span></strong><span class="koboSpan" id="kobo.393.1">
}</span></pre> <p><span class="koboSpan" id="kobo.394.1">The call syntax for the</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.395.1"> variadic function version looks like a cast, and arguments passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">try_new()</span></strong><span class="koboSpan" id="kobo.397.1"> are perfectly forwarded to the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">T</span></strong><span class="koboSpan" id="kobo.399.1"> to ensure that the expected constructor is called in the end. </span><span class="koboSpan" id="kobo.399.2">As was the case with the macro, we could have chosen to return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.401.1"> object instead of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">T*</span></strong><span class="koboSpan" id="kobo.403.1"> object with </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">this function.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.405.1">Out-of-memory situations and new_handler</span></h1>
<p><span class="koboSpan" id="kobo.406.1">So far in this </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.407.1">book, including this</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.408.1"> chapter, we have stated that </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">operator new()</span></strong><span class="koboSpan" id="kobo.410.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.412.1"> typically throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.414.1"> when failing to allocate memory. </span><span class="koboSpan" id="kobo.414.2">It’s true to a wide extent, but there is a subtlety we have avoided so far and to which we will now give some time </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">and attention.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Imagine a situation where user code has specialized the memory allocation functions to fetch memory blocks from a pre-allocated data structure with interesting performance characteristics. </span><span class="koboSpan" id="kobo.416.2">Suppose that this data structure initially allocates space for a small number of blocks and then goes on to allocate more space once the user code exhausts the blocks from the initial allocation. </span><span class="koboSpan" id="kobo.416.3">Expressed otherwise: in this situation, we have an initial, fast setting (let’s call that the “optimistic” state) and a secondary setting (let’s call that the “second chance” state) that lets user code continue allocating once the “optimistic” state’s resources have </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">been consumed.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">For a scenario such as this to be seamless, with a transparent change of allocation strategy achievable without the explicit intervention of user code, explicitly throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.420.1"> would be insufficient. </span><span class="koboSpan" id="kobo.420.2">Throwing would complete the execution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">operator new()</span></strong><span class="koboSpan" id="kobo.422.1"> and client code could catch the exception and take action, of course, but in this (reasonable) scenario, we would like failure to allocate to lead to some action being taken and </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">operator new()</span></strong><span class="koboSpan" id="kobo.424.1"> to try again with the updated state of things, </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">if any.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">In C++, scenarios such as this are handled through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.428.1">, which is an alias for a function pointer of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">void(*)()</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">What one needs to know is </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.432.1">There is a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.434.1"> in a program, and by default, its value </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">nullptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.438.1">One can set the active </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.440.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">std::set_new_handler()</span></strong><span class="koboSpan" id="kobo.442.1"> function, and one can get the active </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.444.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">std::get_new_handler()</span></strong><span class="koboSpan" id="kobo.446.1"> function. </span><span class="koboSpan" id="kobo.446.2">Note that as a convenience, </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">std::set_new_handler()</span></strong><span class="koboSpan" id="kobo.448.1"> returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.450.1"> that is </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">being replaced.</span></span></li>
<li><span class="koboSpan" id="kobo.452.1">When an allocation function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">operator new()</span></strong><span class="koboSpan" id="kobo.454.1"> fails, what it should do is first get the active </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.456.1">. </span><span class="koboSpan" id="kobo.456.2">If that pointer is null, then the allocation function should throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.458.1"> as we have done so far; otherwise, it should call that </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.460.1"> and try again under the new conditions that this </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">call installed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.462.1">As could be expected, your standard library should already implement this algorithm, but our own overloads of </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">operator new()</span></strong><span class="koboSpan" id="kobo.464.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.466.1"> have not done so, at least so far. </span><span class="koboSpan" id="kobo.466.2">To show how to benefit from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.468.1">, we will now implement an artificial version of the aforementioned </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">two-step scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">This toy implementation will use the member version of the allocation operators for some </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">X</span></strong><span class="koboSpan" id="kobo.472.1"> type and behave as if we initially had enough memory for </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">limit</span></strong><span class="koboSpan" id="kobo.474.1"> objects of that type (normally, we would actually manage that memory, and you can see an example of such management in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.475.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.476.1"> where we will provide a more realistic example). </span><span class="koboSpan" id="kobo.476.2">We will install a </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.478.1"> that, when called, changes </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">limit</span></strong><span class="koboSpan" id="kobo.480.1"> to a higher number, and then resets the active handler to </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">nullptr</span></strong><span class="koboSpan" id="kobo.482.1"> such that subsequent failures to </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.483.1">allocate </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">X</span></strong><span class="koboSpan" id="kobo.485.1"> objects </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.486.1">will lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">throwing </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">std::bad_alloc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
#include &lt;new&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.491.1">struct X {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.492.1">  // toy example, not thread-safe</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.493.1">  static inline int limit = 5;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.494.1">  void* operator new(std::size_t n) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.495.1">      std::cout &lt;&lt; "X::operator new() called with "</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.496.1">                &lt;&lt; limit &lt;&lt; " blocks left\n";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.497.1">      while (limit &lt;= 0) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.498.1">        if (auto hdl = std::get_new_handler(); hdl)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.499.1">            hdl();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.500.1">        else</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.501.1">            throw std::bad_alloc{};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.502.1">      }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.503.1">      --limit;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.504.1">      return ::operator new(n);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.505.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.506.1">  void operator delete(void* p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.507.1">      std::cout &lt;&lt; "X::operator delete()\n";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.508.1">      ::operator delete(p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.509.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.510.1">  // same for the array versions</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.511.1">};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.512.1">int main() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.513.1">  std::set_new_handler([]() noexcept {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.514.1">      std::cout &lt;&lt; "allocation failure, "</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.515.1">                   "fetching more memory\n";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.516.1">      X::limit = 10;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.517.1">      std::set_new_handler(nullptr); // as per default</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.518.1">  });</span></strong><span class="koboSpan" id="kobo.519.1">
  std::vector&lt;X*&gt; v;
  v.reserve(100);
  try {
      for (int i = 0; i != 10; ++i)
         v.emplace_back(new X);
  } catch(...) {
</span><strong class="bold"><span class="koboSpan" id="kobo.520.1">      // this will never be reached with this program</span></strong><span class="koboSpan" id="kobo.521.1">
      std::cerr &lt;&lt; "out of memory\n";
  }
  for (auto p : v) delete p;
}</span></pre> <p><span class="koboSpan" id="kobo.522.1">Note the way that </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">X::operator new()</span></strong><span class="koboSpan" id="kobo.524.1"> handles failure: if it notices that it will not be able to meet its postconditions, it gets the active </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.526.1">, and if it’s non-null, calls it before trying again. </span><span class="koboSpan" id="kobo.526.2">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.528.1">, when called, has to either change the situation in such a way that a subsequent tentative allocation could succeed or change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.530.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">nullptr</span></strong><span class="koboSpan" id="kobo.532.1"> such that failure will lead to an exception being thrown. </span><span class="koboSpan" id="kobo.532.2">Failure to respect these rules could lead to an infinite loop and much sadness </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">would ensue.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">The handler installed in </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">main()</span></strong><span class="koboSpan" id="kobo.536.1"> for this toy example does this: when called, it changes the conditions under which the allocations will be performed (it raises the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">X::limit</span></strong><span class="koboSpan" id="kobo.538.1">). </span><span class="koboSpan" id="kobo.538.2">It then calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">std::set_new_handler()</span></strong><span class="koboSpan" id="kobo.540.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">nullptr</span></strong><span class="koboSpan" id="kobo.542.1"> as we have not planned for another approach after the “optimistic” and “second chance” situations, so if we exhaust </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.543.1">the</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.544.1"> second chance resources, we (as they say) </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">are toast.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.546.1">A lambda as new_handler?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.547.1">You might have</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.548.1"> noticed that we described the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">std::new_handler</span></strong><span class="koboSpan" id="kobo.550.1"> type as being an alias for a function pointer of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">void(*)()</span></strong><span class="koboSpan" id="kobo.552.1"> type, yet in our toy example, we installed a lambda. </span><span class="koboSpan" id="kobo.552.2">Why does that work? </span><span class="koboSpan" id="kobo.552.3">Well, it happens that a stateless lambda—a lambda expression with an empty capture block—is implicitly convertible to a function pointer with the same calling signature. </span><span class="koboSpan" id="kobo.552.4">It’s a useful thing to know under many circumstances, such as when writing C++ code that interfaces with C code or operating </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">system APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">We are now about to enter a strange and quite technical part of this chapter, where we will see how to leverage C++ to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">atypical memory.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.556.1">Standard C++ and exotic memory</span></h1>
<p><span class="koboSpan" id="kobo.557.1">Our last example in </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.558.1">this slightly strange chapter with examples of unusual memory management usage is concerned with the ways in which we can write standard C++ programs that deal with “exotic” memory. </span><span class="koboSpan" id="kobo.558.2">By “exotic,” we mean memory that requires explicit actions to “touch” (allocate, read from, write to, deallocate, and so on) and that differs from a “normal” memory block under the control of our program, such as the one used in the illustrative example of memory-mapped usage with placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">new</span></strong><span class="koboSpan" id="kobo.560.1"> earlier in this chapter. </span><span class="koboSpan" id="kobo.560.2">Examples of such memory include persistent (non-volatile) memory or shared memory, but anything </span><em class="italic"><span class="koboSpan" id="kobo.561.1">out of the ordinary</span></em><span class="koboSpan" id="kobo.562.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">do, really.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">Since we have to pick an example, we will write an example using a (fictional) shared </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">memory block.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.566.1">A little white lie…</span></p>
<p class="callout"><span class="koboSpan" id="kobo.567.1">It’s important to understand that we are describing a mechanism for memory that would normally be shared between </span><em class="italic"><span class="koboSpan" id="kobo.568.1">processes</span></em><span class="koboSpan" id="kobo.569.1">, but inter-process communication is the domain of the operating system. </span><span class="koboSpan" id="kobo.569.2">Standard C++ only describes the rules for sharing data between </span><em class="italic"><span class="koboSpan" id="kobo.570.1">threads</span></em><span class="koboSpan" id="kobo.571.1"> in a process; for that reason, we will tell a little white lie and write a multithreaded system, not a multiple-process one, using that memory to share data. </span><span class="koboSpan" id="kobo.571.2">Our focus is on memory management facilities, not inter-process communication, so that should not pose </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">a problem.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">Following the same approach as we did in previous sections of this chapter, we will craft a portable illustration of how to proceed in code that seeks to manage atypical memory, and let you map the details to the services of your chosen platform. </span><span class="koboSpan" id="kobo.573.2">Our example code will take the </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">following shape:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.575.1">A shared memory block will be allocated. </span><span class="koboSpan" id="kobo.575.2">We will make it look like this memory is special in the sense that one needs special operating system functions to create it, allocate it, or deallocate it, but we will deliberately avoid using actual operating system functions. </span><span class="koboSpan" id="kobo.575.3">This means that if you want to use the code in this section for a real application, you will need to adapt it to your chosen </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">platform’s API.</span></span></li>
<li><span class="koboSpan" id="kobo.577.1">We will craft a “handmade” version of a toy program that uses this fictional API for shared memory in order to illustrate what user code would look like under </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">these circumstances.</span></span></li>
<li><span class="koboSpan" id="kobo.579.1">Then, we will show how understanding the memory management facilities of C++ can help us write more pleasant and “normal looking” user code that does the same thing as the “handmade” one… or </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">even better.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.581.1">Fictional realism?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.582.1">This entire section on C++ and exotic memory, which we cover next, will hopefully be interesting, and the code we will write will strive to be realistic with respect to memory management. </span><span class="koboSpan" id="kobo.582.2">As mentioned previously, since the C++ standard is mostly silent on the idea of multi-process systems, we will try to make multithreaded code look kind of like multi-process code. </span><span class="koboSpan" id="kobo.582.3">I hope you, astute reader, will accept </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">this proposition.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.584.1">Please note that there will be a small amount of low-level synchronization in user code for this section, including some through atomic variables. </span><span class="koboSpan" id="kobo.584.2">I tried to keep it minimal yet reasonably realistic and hope you will be able to accept it even though I will not explain it all in detail, with this book’s focus being on memory management rather than on concurrent computing (another fine topic, of course). </span><span class="koboSpan" id="kobo.584.3">Feel free to use your favorite concurrent programming resource if you want to know more about such things as waiting on atomics or using </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">thread fences.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">Ready? </span><span class="koboSpan" id="kobo.586.2">Let’s</span><a id="_idIndexMarker519"/> <span class="No-Break"><span class="koboSpan" id="kobo.587.1">do this!</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.588.1">A fictional shared memory API</span></h2>
<p><span class="koboSpan" id="kobo.589.1">We will write an</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.590.1"> API that is </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.591.1">fictional but inspired by what one finds in most operating systems, except that we will report errors through exceptions to simplify user code. </span><span class="koboSpan" id="kobo.591.2">Operating systems mostly report errors through error codes expressed from return values, but this leads to user code that is more involved. </span><span class="koboSpan" id="kobo.591.3">I hope this seems like an acceptable compromise to you, </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">dear reader.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">As most operating systems do, we will abstract the actual resource through a form of handle, or key; creating a “shared memory” segment of some size will yield a key (an integral identifier), after which, accessing that memory will require that key, and so will destroying that memory. </span><span class="koboSpan" id="kobo.593.2">As can be expected with a facility meant to be used to share data between processes, destroying the memory will not finalize the objects therein, so user code will need to ensure that objects in the shared memory are destroyed before releasing the shared </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">memory segment.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">The signatures </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.596.1">and types</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.597.1"> for our API will be </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
// ...
</span><span class="koboSpan" id="kobo.599.2">#include &lt;cstddef&gt; // std::size_t
#include &lt;new&gt; // std::bad_alloc
#include &lt;utility&gt; // std::pair
class invalid_shared_mem_key {};
enum shared_mem_id : std::size_t;
shared_mem_id create_shared_mem(std::size_t size);
std::pair&lt;void*, std::size_t&gt;
  get_shared_mem(shared_mem_id);
void destroy_shared_mem(shared_mem_id);
// ...</span></pre> <p><span class="koboSpan" id="kobo.600.1">You might notice that we are using an </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">enum</span></strong><span class="koboSpan" id="kobo.602.1"> type for </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">shared_mem_id</span></strong><span class="koboSpan" id="kobo.604.1">. </span><span class="koboSpan" id="kobo.604.2">The reason for this is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">enum</span></strong><span class="koboSpan" id="kobo.606.1"> types are distinct types in C++, not just aliases as one would get from </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">using</span></strong><span class="koboSpan" id="kobo.608.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">typedef</span></strong><span class="koboSpan" id="kobo.610.1">. </span><span class="koboSpan" id="kobo.610.2">Having distinct types can be useful when overloading functions based on the types of their arguments. </span><span class="koboSpan" id="kobo.610.3">It’s a useful trick to know: if we write two functions with the same name (one that takes an argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">shared_mem_id</span></strong><span class="koboSpan" id="kobo.612.1"> type and another that takes an argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">std::size_t</span></strong><span class="koboSpan" id="kobo.614.1"> type), these will be distinct functions, even though the underlying type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">shared_mem_id</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.616.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">std::size_t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Since we are building an artificial implementation of “shared memory” to show how memory allocation functions can simplify user code, the implementation for the functions of our API will be written to be simple, but let us write client code that behaves as if it were using shared memory. </span><span class="koboSpan" id="kobo.619.2">We will define a shared memory segment as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">shared_mem_block</span></strong><span class="koboSpan" id="kobo.621.1"> modeled by a pair made from an array of bytes and a size in bytes. </span><span class="koboSpan" id="kobo.621.2">We will keep a </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">std::vector</span></strong><span class="koboSpan" id="kobo.623.1"> object of that type, using the indices in that array as </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">shared_mem_id</span></strong><span class="koboSpan" id="kobo.625.1">. </span><span class="koboSpan" id="kobo.625.2">This means that when a </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">shared_mem_block</span></strong><span class="koboSpan" id="kobo.627.1"> object is destroyed, we will not reuse its index in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">std::vector</span></strong><span class="koboSpan" id="kobo.629.1"> (the container will eventually have “holes,” so </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">to speak).</span></span></p>
<p><span class="koboSpan" id="kobo.631.1">Our implementation is as follows. </span><span class="koboSpan" id="kobo.631.2">Note that it is not thread-safe, but that does not impact our </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.632.1">memory </span><a id="_idIndexMarker525"/><span class="No-Break"><span class="koboSpan" id="kobo.633.1">management-related discourse:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
// ...
</span><span class="koboSpan" id="kobo.634.2">#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;
struct shared_mem_block {
  std::unique_ptr&lt;char[]&gt; mem;
  std::size_t size;
};
std::vector&lt;shared_mem_block&gt; shared_mems;
std::pair&lt;void*, std::size_t&gt;
  get_shared_mem(shared_mem_id id) {
  if (id &lt; std::size(shared_mems))
      return { shared_mems[id].mem.get(),
               shared_mems[id].size };
  return { nullptr, 0 };
}
shared_mem_id create_shared_mem(std::size_t size) {
  auto p = std::make_unique&lt;char[]&gt;(size);
  shared_mems.emplace_back(std::move(p), size);
  // note the parentheses
  return shared_mem_id(std::size(shared_mems) - 1);
}
// function for internal purposes only
bool is_valid_shared_mem_key(shared_mem_id id) {
  return id &lt; std::size(shared_mems) &amp;&amp;
         shared_mems[id].mem;
}
void destroy_shared_mem(shared_mem_id id) {
  if (!is_valid_shared_mem_key(id))
      throw invalid_shared_mem_key{};
  shared_mems[id].mem.reset();
}</span></pre> <p><span class="koboSpan" id="kobo.635.1">If you want to experiment, you can replace the implementation of these functions with equivalent implementations that call the functions of your chosen operating system, adjusting the API </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">Equipped with this implementation, we can now compare a “handmade” example of shared memory-using code with one that benefits from the facilities of C++. </span><span class="koboSpan" id="kobo.637.2">We will do this comparison with code where one allocates some chunk of data from a shared memory segment and then launches two threads (a writer and a reader). </span><span class="koboSpan" id="kobo.637.3">The writer will write to that shared data, and then (with minimal synchronization) the reader will read from it. </span><span class="koboSpan" id="kobo.637.4">As </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.638.1">mentioned </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.639.1">previously, our code will use </span><em class="italic"><span class="koboSpan" id="kobo.640.1">intra</span></em><span class="koboSpan" id="kobo.641.1">-process synchronization (C++ atomic variables), but in real code, you should use </span><em class="italic"><span class="koboSpan" id="kobo.642.1">inter</span></em><span class="koboSpan" id="kobo.643.1">-process synchronization mechanisms provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">operating system.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.645.1">A note on lifetime</span></p>
<p class="callout"><span class="koboSpan" id="kobo.646.1">You might remember from </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.647.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.648.1"> that each object has an associated lifetime, and that the compiler keeps track of this fact in your programs. </span><span class="koboSpan" id="kobo.648.2">Our fictional multiple-process example is really a single-process, multithreaded example, so the usual C++ lifetime </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">rules apply.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.650.1">If you want to take the code in this section and write a real multi-process system to run some tests, you might want to consider using </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">std::start_lifetime_as()</span></strong><span class="koboSpan" id="kobo.652.1"> from C++23 in those processes that did not explicitly create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">data</span></strong><span class="koboSpan" id="kobo.654.1"> object, and avoid detrimental optimizations from happening based on the compiler’s reasoning that, in these processes, the objects have never been constructed. </span><span class="koboSpan" id="kobo.654.2">In earlier compilers, one trick that generally works is calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.656.1"> of the not-officially-constructed object onto itself, effectively starting </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">its lifetime.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">In both our “handmade” and our standard-looking implementations, we will be using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">data</span></strong><span class="koboSpan" id="kobo.660.1"> object made of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">int</span></strong><span class="koboSpan" id="kobo.662.1"> value and a Boolean </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">ready</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1"> flag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
struct data {
  bool ready;
  int value;
};</span></pre> <p><span class="koboSpan" id="kobo.666.1">In a single-process </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.667.1">implementation, a </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.668.1">better choice for the completion flag would be an </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">atomic&lt;bool&gt;</span></strong><span class="koboSpan" id="kobo.670.1"> object as we want to make sure the write to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">ready</span></strong><span class="koboSpan" id="kobo.672.1"> flag happens before the write to the value, but since we want this example to look like we are using inter-process shared memory, we will limit ourselves to a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">bool</span></strong><span class="koboSpan" id="kobo.674.1"> and ensure this synchronization through </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">other means.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.676.1">A word on synchronization</span></p>
<p class="callout"><span class="koboSpan" id="kobo.677.1">In a contemporary</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.678.1"> program, optimizing compilers will often reorder operations that seem independent to generate better code, and processors will do the same once the code has been generated in order to maximize usage of the processor’s internal pipeline. </span><span class="koboSpan" id="kobo.678.2">Concurrent code sometimes contains dependencies that are neither visible to the compiler nor to the processor. </span><span class="koboSpan" id="kobo.678.3">In our examples, we will want the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">ready</span></strong><span class="koboSpan" id="kobo.680.1"> completion flag to become </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">true</span></strong><span class="koboSpan" id="kobo.682.1"> only after the write to </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">value</span></strong><span class="koboSpan" id="kobo.684.1"> has been performed; this order is only important because the writes are performed in one thread but </span><em class="italic"><span class="koboSpan" id="kobo.685.1">another</span></em><span class="koboSpan" id="kobo.686.1"> thread will look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">ready</span></strong><span class="koboSpan" id="kobo.688.1"> to know whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">value</span></strong><span class="koboSpan" id="kobo.690.1"> can </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">be read.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.692.1">Not enforcing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">value</span></strong><span class="koboSpan" id="kobo.694.1">-then-</span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">ready</span></strong><span class="koboSpan" id="kobo.696.1"> sequence of writes through some form of synchronization would let either the compiler or the processor reorder these (seemingly independent) writes </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.697.1">and break our assumptions on the meaning </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">ready</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.701.1">A handmade user code example</span></h2>
<p><span class="koboSpan" id="kobo.702.1">We can, of course, write </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.703.1">user code that uses our fictional API without resorting to specialized memory management facilities of C++, simply relying on placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">new</span></strong><span class="koboSpan" id="kobo.705.1"> usage as seen in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.706.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.707.1">. </span><span class="koboSpan" id="kobo.707.2">It might be tempting to think of placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">new</span></strong><span class="koboSpan" id="kobo.709.1"> as a specialized facility since you might have learned of it from this book, but if that is your perspective, you are invited to reconsider: the placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">new</span></strong><span class="koboSpan" id="kobo.711.1"> mechanism is a fundamental memory management tool used in almost every program, whether user code is aware of it </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">As a reminder, our example program will do </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.715.1">Create a shared memory segment of some size (we will allocate much more than we need in </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">this case).</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">data</span></strong><span class="koboSpan" id="kobo.719.1"> object at the beginning of that segment, obviously through </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">placement </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">new</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.723.1">Start a thread that will wait for a signal on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">go</span></strong><span class="koboSpan" id="kobo.725.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">atomic&lt;bool&gt;</span></strong><span class="koboSpan" id="kobo.727.1">, then obtain access to the shared memory segment, write to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">value</span></strong><span class="koboSpan" id="kobo.729.1"> data member and then only signal that the write has occurred through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">ready</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.731.1">data member.</span></span></li>
<li><span class="koboSpan" id="kobo.732.1">Start another thread that will obtain access to the shared memory segment, get a pointer to the shared </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">data</span></strong><span class="koboSpan" id="kobo.734.1"> object therein, and then do some (very inefficient) busy waiting on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">ready</span></strong><span class="koboSpan" id="kobo.736.1"> flag to change state, after which </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">value</span></strong><span class="koboSpan" id="kobo.738.1"> will be read and used. </span><span class="koboSpan" id="kobo.738.2">Once this has been done, completion will be signaled through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">done</span></strong><span class="koboSpan" id="kobo.740.1"> flag of </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">atomic&lt;bool&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.744.1">Our program will then read a key from the keyboard, signal the threads (the writer thread, really) that it’s time to start working, and wait until they are done before freeing the shared memory segment and concluding </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">its work.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.746.1">We thus end up with </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
// ...
</span><span class="koboSpan" id="kobo.748.2">#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;iostream&gt;
int main() {
  // we need a N-bytes shared memory block
  constexpr std::size_t N = 1'000'000;
</span><strong class="bold"><span class="koboSpan" id="kobo.749.1">  auto key = create_shared_mem(N);</span></strong><span class="koboSpan" id="kobo.750.1">
  // map a data object in the shared memory block
</span><strong class="bold"><span class="koboSpan" id="kobo.751.1">  auto [p, sz] = get_shared_mem(key);</span></strong><span class="koboSpan" id="kobo.752.1">
  if (!p) return -1;
  // start the lifetime of a non-ready data object
</span><strong class="bold"><span class="koboSpan" id="kobo.753.1">  auto p_data = new (p) data{ false };</span></strong><span class="koboSpan" id="kobo.754.1">
  std::atomic&lt;bool&gt; go{ false };
  std::atomic&lt;bool&gt; done{ false };
  std::jthread writer{ [key, &amp;go] {
</span><strong class="bold"><span class="koboSpan" id="kobo.755.1">      go.wait(false);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.756.1">      auto [p, sz] = get_shared_mem(key);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.757.1">      if (p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.758.1">        auto p_data = static_cast&lt;data*&gt;(p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.759.1">        p_data-&gt;value = 3;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.760.1">        std::atomic_thread_fence(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.761.1">            std::memory_order_release</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.762.1">        );</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.763.1">        p_data-&gt;ready = true;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.764.1">      }</span></strong><span class="koboSpan" id="kobo.765.1">
  } };
  std::jthread reader{ [key, &amp;done] {
</span><strong class="bold"><span class="koboSpan" id="kobo.766.1">      </span></strong><strong class="bold"><span class="koboSpan" id="kobo.767.1">auto [p, sz] = get_shared_mem(key);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.768.1">      if (p) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.769.1">        auto p_data = static_cast&lt;data*&gt;(p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.770.1">        while (!p_data-&gt;ready)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.771.1">            ; // busy waiting, not cool</span></strong><span class="koboSpan" id="kobo.772.1">
        std::cout &lt;&lt; "read value "
                  &lt;&lt; p_data-&gt;value &lt;&lt; '\n';
      }
</span><strong class="bold"><span class="koboSpan" id="kobo.773.1">      done = true;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.774.1">      done.notify_all();</span></strong><span class="koboSpan" id="kobo.775.1">
  } };
  if (char c; !std::cin.get(c)) exit(-1);
</span><strong class="bold"><span class="koboSpan" id="kobo.776.1">  go = true;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.777.1">  go.notify_all();</span></strong><span class="koboSpan" id="kobo.778.1">
  // writer and reader run to completion, then complete
</span><strong class="bold"><span class="koboSpan" id="kobo.779.1">  done.wait(false);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.780.1">  p_data-&gt;~data();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.781.1">  destroy_shared_mem(key);</span></strong><span class="koboSpan" id="kobo.782.1">
}</span></pre> <p><span class="koboSpan" id="kobo.783.1">We made this </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.784.1">work: we have an infrastructure of sorts to manage shared memory segments, we can use these memory blocks to share data, and we can write code that reads from that shared data as well as writes to it. </span><span class="koboSpan" id="kobo.784.2">Note that we captured the key in each thread in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">key</span></strong><span class="koboSpan" id="kobo.786.1"> variable and then obtained the memory block within each lambda through that key, but it would also be reasonable to simply capture the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">p_data</span></strong><span class="koboSpan" id="kobo.788.1"> pointer and </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">Notice, however, that we did not really manage that block: we created it and used a small chunk of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">sizeof(data)</span></strong><span class="koboSpan" id="kobo.792.1"> at the beginning. </span><span class="koboSpan" id="kobo.792.2">Now, what if we had wanted to create multiple objects in that zone? </span><span class="koboSpan" id="kobo.792.3">And what if we had wanted to write code that both creates and destroys objects, introducing the need to manage what parts of that block are in use at a given time? </span><span class="koboSpan" id="kobo.792.4">With what we just wrote, that would mean doing it all in user code, a</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.793.1"> somewhat </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">burdensome endeavor.</span></span></p>
<p><span class="koboSpan" id="kobo.795.1">Keeping that in mind, we will now solve the same problem but with a </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">different approach.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.797.1">A standard-looking user code equivalent</span></h2>
<p><span class="koboSpan" id="kobo.798.1">So, what</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.799.1"> mechanism does C++ offer us if we want to use “exotic” memory in a more idiomatic manner? </span><span class="koboSpan" id="kobo.799.2">Well, one way to do so is </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.801.1">To write a manager class for the “exotic” memory, encapsulating the non-portable interface to the operating system and exposing services that are closer to what C++ user code </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">would expect</span></span></li>
<li><span class="koboSpan" id="kobo.803.1">To write overloads of the memory allocation operators (</span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">operator new()</span></strong><span class="koboSpan" id="kobo.805.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">operator delete()</span></strong><span class="koboSpan" id="kobo.807.1">, and so on) that take a reference to such a manager object as an </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">additional argument</span></span></li>
<li><span class="koboSpan" id="kobo.809.1">To make these overloaded memory allocation operators bridge the gap between portable and non-portable code through delegation on the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">manager object</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.811.1">This way, user code can be written essentially as “normal looking” code that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">new</span></strong><span class="koboSpan" id="kobo.813.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">delete</span></strong><span class="koboSpan" id="kobo.815.1"> operators, except that these calls will use the same kind of extended notation seen in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.816.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.817.1"> for such things as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">nothrow</span></strong><span class="koboSpan" id="kobo.819.1"> or placement versions of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.824.1"> class will use the fictional operating system API described earlier in this section but, normally, one would write a class that encapsulates whatever operating system services are required to access the atypical memory one aims to use in </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">a program.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">Being an example made for simplicity, mostly to show how the feature works and can be used, the astute reader that you are will hopefully see much room for improvement and optimization… Indeed, this manager is really slow and memory consuming, keeping a </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">std::vector&lt;bool&gt;</span></strong><span class="koboSpan" id="kobo.828.1"> object where each </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">bool</span></strong><span class="koboSpan" id="kobo.830.1"> value indicates whether a byte in the memory block is taken or not and performing a naïve linear search through that container whenever an allocation request is made (also, it’s not thread-safe, which is bad!). </span><span class="koboSpan" id="kobo.830.2">We will examine some quality of implementation considerations in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.831.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.832.1">, but nothing stops you from taking </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.834.1"> and making it significantly better in </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the meantime.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">You will notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.838.1"> has been expressed as an RAII type: its constructor creates a shared memory segment, its destructor frees that memory segment, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.840.1"> type has been made uncopiable as is often the case for RAII types. </span><span class="koboSpan" id="kobo.840.2">The key member functions to look at in the following code excerpt are </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">allocate()</span></strong><span class="koboSpan" id="kobo.842.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">deallocate()</span></strong><span class="koboSpan" id="kobo.844.1">; the former tries to allocate a block from the shared memory</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.845.1"> segment and notes that this has been done, whereas the latter frees the memory associated with an address within </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">the block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.847.1">
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;new&gt;
class shared_mem_mgr {
  shared_mem_id key;
  std::vector&lt;bool&gt; taken;
  void *mem;
  auto find_first_free(std::size_t from = 0) {
      using namespace std;
      auto p = find(begin(taken) + from, end(taken),
                    false);
      return distance(begin(taken), p);
  }
  bool at_least_free_from(std::size_t from, int n) {
      using namespace std;
      return from + n &lt; size(taken) &amp;&amp;
             count(begin(taken) + from,
                   begin(taken) + from + n,
                   false) == n;
  }
  void take(std::size_t from, std::size_t to) {
      using namespace std;
      fill(begin(taken) + from, begin(taken) + to,
          begin(taken) + from, true);
  }
  void free(std::size_t from, std::size_t to) {
      using namespace std;
      fill(begin(taken) + from, begin(taken) + to,
          begin(taken) + from, false);
  }
public:
  // create shared memory block
</span><strong class="bold"><span class="koboSpan" id="kobo.848.1">  shared_mem_mgr(std::size_t size)</span></strong><span class="koboSpan" id="kobo.849.1">
      : key{ </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">create_shared_mem(size)</span></strong><span class="koboSpan" id="kobo.851.1"> }, taken(size) {
</span><strong class="bold"><span class="koboSpan" id="kobo.852.1">      auto [p, sz] = get_shared_mem(key);</span></strong><span class="koboSpan" id="kobo.853.1">
      if (!p) throw invalid_shared_mem_key{};
</span><strong class="bold"><span class="koboSpan" id="kobo.854.1">      </span></strong><strong class="bold"><span class="koboSpan" id="kobo.855.1">mem = p;</span></strong><span class="koboSpan" id="kobo.856.1">
  }
  shared_mem_mgr(const shared_mem_mgr&amp;) = delete;
  shared_mem_mgr&amp;
      operator=(const shared_mem_mgr&amp;) = delete;
</span><strong class="bold"><span class="koboSpan" id="kobo.857.1">  void* allocate(std::size_t n) {</span></strong><span class="koboSpan" id="kobo.858.1">
      using namespace std;
      std::size_t i = find_first_free();
      // insanely inefficient
      while (!at_least_free_from(i, n) &amp;&amp; i != size(taken))
        i = find_first_free(i + 1);
      if (i == size(taken)) throw bad_alloc{};
      take(i, i + n);
      return static_cast&lt;char*&gt;(mem) + i;
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.859.1">  void deallocate(void *p, std::size_t n) {</span></strong><span class="koboSpan" id="kobo.860.1">
      using namespace std;
      auto i = distance(
         static_cast&lt;char*&gt;(mem), static_cast&lt;char*&gt;(p)
      );
      take(i, i + n);
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.861.1">  ~shared_mem_mgr() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.862.1">      destroy_shared_mem(key);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.863.1">  }</span></strong><span class="koboSpan" id="kobo.864.1">
};</span></pre> <p><span class="koboSpan" id="kobo.865.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.867.1"> really is a class that manages a chunk of memory, and there is</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.868.1"> no magic involved. </span><span class="koboSpan" id="kobo.868.2">Should someone want to improve the memory management algorithms, one could do so without touching the interface of this class, benefiting from the low coupling that stems </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">from encapsulation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.870.1">If you want to play…</span></p>
<p class="callout"><span class="koboSpan" id="kobo.871.1">One interesting way to refine </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.873.1"> would be to first make this class responsible for allocating and freeing the shared memory, as it already does, then write a different class to manage the memory within that shared memory block, and finally, make them work together. </span><span class="koboSpan" id="kobo.873.2">This way, one could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.875.1"> with different memory management algorithms and pick management strategies based on the needs of individual programs, or sections thereof. </span><span class="koboSpan" id="kobo.875.2">Something to try if you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">have fun!</span></span></p>
<p><span class="koboSpan" id="kobo.877.1">The next step is to implement the allocation operator overloads that take an argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">shared_mem_mgr&amp;</span></strong><span class="koboSpan" id="kobo.879.1">. </span><span class="koboSpan" id="kobo.879.2">This is essentially trivial since all these overloads need to do is delegate </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.880.1">the work to </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">the manager:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
void* operator new(std::size_t n, shared_mem_mgr&amp; mgr) {
  return mgr.allocate(n);
}
void* operator new[](std::size_t n, shared_mem_mgr&amp; mgr) {
  return mgr.allocate(n);
}
void operator delete(void *p, std::size_t n,
                    shared_mem_mgr&amp; mgr) {
  mgr.deallocate(p, n);
}
void operator delete[](void *p, std::size_t n,
                      shared_mem_mgr&amp; mgr) {
  mgr.deallocate(p, n);
}</span></pre> <p><span class="koboSpan" id="kobo.883.1">Equipped with our manager and these overloads, we can write our test program that performs the same task as the “handmade” one from the previous section. </span><span class="koboSpan" id="kobo.883.2">In this case, however, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">some differences:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.885.1">We do not need to manage the shared memory segment’s creation and destruction. </span><span class="koboSpan" id="kobo.885.2">These tasks are handled by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.887.1"> object as part of its implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">RAII idiom.</span></span></li>
<li><span class="koboSpan" id="kobo.889.1">We do not need to manage the shared memory block at all, as this task is assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">shared_mem_mgr</span></strong><span class="koboSpan" id="kobo.891.1"> object. </span><span class="koboSpan" id="kobo.891.2">Finding a location in the block to put an object, tracking how the block is being used for objects, ensuring that it’s possible to distinguish used areas from unused ones, and so on are all part of that </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">class’s responsibilities.</span></span></li>
<li><span class="koboSpan" id="kobo.893.1">As a corollary, in the “handmade” version, we constructed an object at the beginning of the shared memory block and stated that it would be a burden on user code to construct more objects or manage the shared memory segment to take into account numerous calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">new</span></strong><span class="koboSpan" id="kobo.895.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">delete</span></strong><span class="koboSpan" id="kobo.897.1"> operators, but in this implementation, we can freely call </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">new</span></strong><span class="koboSpan" id="kobo.899.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">delete</span></strong><span class="koboSpan" id="kobo.901.1"> as much as we want since this memory management becomes transparent to </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">client code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.903.1">The construction</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.904.1"> aspect of objects in atypical memory is rather easy: just pass the additional argument in the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">new</span></strong><span class="koboSpan" id="kobo.906.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">new[]</span></strong><span class="koboSpan" id="kobo.908.1">operators. </span><span class="koboSpan" id="kobo.908.2">The finalization part of objects managed through a manager such as this is slightly more complex though: we cannot write the equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">delete p</span></strong><span class="koboSpan" id="kobo.910.1"> on our pointers as this would try to finalize the object </span><em class="italic"><span class="koboSpan" id="kobo.911.1">and</span></em><span class="koboSpan" id="kobo.912.1"> deallocate the memory through “normal” means. </span><span class="koboSpan" id="kobo.912.2">Instead, we need to manually finalize the objects, and then manually call the appropriate version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">operator delete()</span></strong><span class="koboSpan" id="kobo.914.1"> function in order to do the exotic memory cleanup tasks. </span><span class="koboSpan" id="kobo.914.2">Of course, given what we have written in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.915.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.916.1">, you could encapsulate these tasks in a smart pointer of your own to get simpler and safer </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">user code.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">We end up with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">example program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
int main() {
  // we need a N-bytes shared memory block
  constexpr std::size_t N = 1'000'000;
  // HERE
</span><strong class="bold"><span class="koboSpan" id="kobo.921.1">  shared_mem_mgr mgr{ N };</span></strong><span class="koboSpan" id="kobo.922.1">
  // start the lifetime of a non-ready data object
</span><strong class="bold"><span class="koboSpan" id="kobo.923.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.924.1">auto p_data = new (mgr) data{ false };</span></strong><span class="koboSpan" id="kobo.925.1">
  std::atomic&lt;bool&gt; go{ false };
  std::atomic&lt;bool&gt; done{ false };
  std::jthread writer{ [p_data, &amp;go] {
      go.wait(false);
      p_data-&gt;value = 3;
      std::atomic_thread_fence(std::memory_order_release);
      p_data-&gt;ready = true;
  } };
  std::jthread reader{ [p_data, &amp;done] {
      while (!p_data-&gt;ready)
        ; // busy waiting, not cool
      std::cout &lt;&lt; "read value " &lt;&lt; p_data-&gt;value &lt;&lt; '\n';
      done = true;
      done.notify_all();
  } };
  if (char c; !std::cin.get(c)) exit(-1);
  go = true;
  go.notify_all();
  // writer and reader run to completion, then complete
  done.wait(false);
</span><strong class="bold"><span class="koboSpan" id="kobo.926.1">  p_data-&gt;~data();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.927.1">  operator delete(p_data, sizeof(data), mgr);</span></strong><span class="koboSpan" id="kobo.928.1">
}</span></pre> <p><span class="koboSpan" id="kobo.929.1">This is still not a </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.930.1">trivial example, but the memory management aspect is clearly simpler than in the “handmade” version, and the compartmentalization of tasks makes it easier to </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.931.1">optimize the way in which memory </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">is managed.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">And… we’re done. </span><span class="koboSpan" id="kobo.933.2">Whew! </span><span class="koboSpan" id="kobo.933.3">That was quite the ride, </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">once more!</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.935.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.936.1">This chapter explored various ways in which one can use the C++ memory management facilities in unusual ways: mapping objects onto memory-mapped hardware, integrating basic forms of error handling with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">nothrow</span></strong><span class="koboSpan" id="kobo.938.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">operator new()</span></strong><span class="koboSpan" id="kobo.940.1">, reacting to out-of-memory situations with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">std::exception_handler</span></strong><span class="koboSpan" id="kobo.942.1">, and accessing atypical memory with non-portable services through a specialization of the “normal” allocation operator and a manager object. </span><span class="koboSpan" id="kobo.942.2">This gives us a broader overview of memory management facilities in C++ and how one can use them to </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">one’s advantage.</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">One thing we have mentioned but not yet discussed is optimization: how to make memory allocation and memory allocation fast, blazingly fast even, and deterministic in terms of execution speed when some conditions are met. </span><span class="koboSpan" id="kobo.944.2">This is what we will do in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.945.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.946.1"> when explaining how to write arena-based </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">allocation code.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">Oh, and as a bonus, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">kill Orcs.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.950.1">Orcs? </span><span class="koboSpan" id="kobo.950.2">What are you talking about?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.951.1">Orcs are fictional creatures found in numerous works of fictional fantasy, usually mean beasts used as foes and that have an unhealthy relation to Elves, another kind of fictional creature that often has a better reputation. </span><span class="koboSpan" id="kobo.951.2">As your friendly author has worked a lot with game programmers over the last few decades, Orcs tend to appear in his examples and will be central to the code we write in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.952.1">Chapter 10</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.953.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">Sounds good? </span><span class="koboSpan" id="kobo.954.2">Then, on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">next chapter!</span></span></p>
</div>
</body></html>