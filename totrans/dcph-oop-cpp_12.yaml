- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Friends and Operator Overloading
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 友元与操作符重载
- en: This chapter will continue our pursuit of expanding your C++ programming repertoire
    beyond OOP concepts, with the goal of writing more extensible code. We will next
    explore **friend functions**, **friend classes**, and **operator overloading**
    in C++. We will understand how operator overloading can extend operators beyond
    their usage with standard types to behave uniformly with user defined types, and
    why this is a powerful OOP tool. We will learn how friend functions and classes
    can be safely used to achieve this goal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续我们扩展你的C++编程知识库的追求，目标是编写更可扩展的代码。我们将接下来探索C++中的**友元函数**、**友元类**和**操作符重载**。我们将了解操作符重载如何将操作符的使用扩展到标准类型之外，以与用户定义的类型保持一致，以及为什么这是一个强大的面向对象编程工具。我们将学习如何安全地使用友元函数和类来实现这一目标。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding friend functions and friend classes, appropriate reasons to utilize,
    and measures to add safety to their usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解友元函数和友元类，适当的使用理由以及增加其使用安全性的措施
- en: Learning about operator overloading essentials – how and why to overload operators,
    ensuring operators are polymorphic between standard and user defined types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解操作符重载的基本知识——如何以及为什么重载操作符，确保操作符在标准类型和用户定义类型之间是多态的
- en: Implementing operator functions and knowing when friends may be necessary
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现操作符函数以及了解何时可能需要友元
- en: By the end of this chapter, you will unlock the proper usage of friends and
    understand their utility in harnessing C++’s ability to overload operators. Though
    the usage of friend functions and classes can be exploited, you will instead insist
    on their contained usage only within two tightly coupled classes. You will understand
    how the proper usage of friends can enhance operator overloading, allowing operators
    to be extended to support user defined types so they may work associatively with
    their operands.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将解锁友元的正确使用方法，并了解它们在利用C++重载操作符的能力中的用途。尽管友元函数和类的使用可能被滥用，但你将坚持只在两个紧密耦合的类中仅限内部使用。你将了解正确使用友元如何增强操作符重载，使操作符能够扩展以支持用户定义的类型，从而与操作数关联操作。
- en: Let’s increase our understanding of C++ by expanding your programming repertoire
    through exploring friend functions, friend classes, and operator overloading.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索友元函数、友元类和操作符重载来扩展我们对C++的理解。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter12` in a file named `Chp12-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter12`子目录中找到，文件名为`Chp12-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3K0f4tb](https://bit.ly/3K0f4tb).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下网址查看：[https://bit.ly/3K0f4tb](https://bit.ly/3K0f4tb)。
- en: Understanding friend classes and friend functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解友元类和友元函数
- en: Encapsulation is a valuable OOP feature that C++ offers through the proper usage
    of classes and access regions. Encapsulation offers uniformity in the manner in
    which data and behaviors are manipulated. In general, it is unwise to forfeit
    the encapsulated protection that a class offers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是C++通过正确使用类和访问区域提供的有价值的面向对象编程（OOP）特性。封装提供了在处理数据和行为方面的统一性。一般来说，放弃类提供的封装保护是不明智的。
- en: There are, however, selected programming situations in which breaking encapsulation
    slightly is considered more acceptable than the alternative of providing an *overly
    public* interface to a class. That is, when a class needs to provide methods for
    two classes to cooperate, yet, in general, those methods are inappropriate to
    be publicly accessible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些编程场景中，稍微打破封装性被认为比提供一个过于公开的类接口更可接受。也就是说，当一个类需要为两个类提供协作的方法时，尽管通常这些方法不适合公开访问。
- en: 'Let’s consider a scenario that may lead us to consider slightly forfeiting
    (that is, breaking) the sacred OOP concept of encapsulation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个可能导致我们考虑稍微放弃（即，打破）神圣的面向对象编程概念封装性的场景：
- en: Two tightly coupled classes may exist that are not otherwise related to one
    another. One class may have one or more associations with the other class and
    need to manipulate the other class’s members. Yet, a public interface to allow
    access to such members would make these internals *overly public* and subject
    to manipulation well beyond the needs of the pair of tightly coupled classes.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在两个紧密耦合的类，它们之间没有其他关系。一个类可能与其他类有一个或多个关联，并需要操作另一个类的成员。然而，允许访问这些成员的公共接口会使这些内部成员过于公开，并容易受到超出紧密耦合类对需求之外的操纵。
- en: In this situation, it is a better choice to allow one class in the tightly coupled
    pair to have access to the other class’s members versus providing a public interface
    in the other class that allows for more manipulation of these members than is
    generally safe. We will see, momentarily, how to minimize this prospective loss
    of encapsulation.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，允许紧密耦合对中的其中一个类访问另一个类的成员，比在另一个类中提供一个允许比通常更安全地操作这些成员的公共接口更好。我们将很快看到如何最小化这种潜在的封装性损失。
- en: Selected operator overloading situations, which we will soon see, may require
    an instance to have access to its members while in a function that is outside
    of its class scope. Again, a fully accessible public interface may be considered
    dangerous.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将很快看到的某些选定的运算符重载场景可能需要实例在类作用域之外的函数中访问其成员。再次强调，一个完全可访问的公共接口可能被认为是危险的。
- en: '**Friend functions** and **friend classes** allow this selective breaking of
    encapsulation to occur. Breaking encapsulation is serious and should not be done
    to simply override access regions. Instead, friends can be used – with added safety
    measures – when the choices are slightly breaking encapsulation between two tightly
    coupled classes or providing an overly public interface that would yield greater
    and potentially unwanted access to another class’s members from various scopes
    in the application.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**友元函数**和**友元类**允许这种选择性的封装性打破。打破封装性是严重的，不应仅仅为了覆盖访问区域而进行。相反，当选择稍微打破两个紧密耦合类之间的封装性或提供一个过于公开的接口，该接口可能导致从应用程序的各个作用域对另一个类的成员有更大的、可能是不希望有的访问时，可以使用友元（并采取额外的安全措施）。'
- en: Let us take a look at how each may be used, and then we will add the relevant
    safety measures we should insist on employing. Let’s start with friend functions
    and friend classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个如何使用，然后我们将添加我们应该坚持采用的相关安全措施。让我们从友元函数和友元类开始。
- en: Using friend functions and friend classes
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用友元函数和友元类
- en: '**Friend functions** are functions that are individually granted *extended
    scope* to include the class with which they are associated. Let’s examine the
    implications and logistics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**友元函数**是那些被个别授予扩展作用域以包括它们所关联的类的函数。让我们考察其影响和后勤：'
- en: In the scope of friend functions, an instance of the associated type can access
    its own members as if it were in the scope of its own class.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在友元函数的作用域内，关联类型的实例可以访问其自己的成员，就像它们在自己的类作用域内一样。
- en: A friend function needs to be prototyped as a friend in the class definition
    of the class relinquishing access (that is, extending its scope).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个友元函数需要在放弃访问权限（即扩展其作用域）的类的类定义中作为友元进行原型化。
- en: The keyword `friend` is used in front of the prototype that provides access.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`friend`用于提供访问的函数原型之前。
- en: Functions overloading friend functions are not considered friends.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载友元函数不被视为友元。
- en: '**Friend classes** are classes in which every member function of the class
    is a friend function of the associated class. Let’s examine the logistics:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**友元类**是那些其每个成员函数都是关联类的友元函数的类。让我们考察其后勤：'
- en: A friend class should have a forward declaration in the class definition of
    the class that is providing it with access to its members (that is, scope).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 友元类应该在提供访问其成员（即作用域）的类的类定义中有一个前向声明。
- en: The keyword `friend` should precede the forward declaration of the class gaining
    access (that is, whose scope has been extended).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 `friend` 应该位于获得访问权限的类的前向声明之前（即，其作用域已被扩展）。
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Friend classes and friend functions should be utilized sparingly, only when
    breaking encapsulation selectively and slightly is it a better choice than offering
    an *overly public* interface (that is, a public interface that would universally
    offer undesired access to selected members within any scope of the application).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 友元类和友元函数应该谨慎使用，只有在选择性地稍微打破封装时，它才比提供一个过于公开的接口（即，一个在应用程序的任何作用域中都会提供对所选成员的不希望访问的公共接口）更好。
- en: 'Let’s begin by examining the syntax for friend classes and friend function
    declarations. The following classes do not represent complete class definitions;
    however, the complete program can be found in our online in our GitHub repository
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查友元类和友元函数声明的语法开始。以下类不代表完整的类定义；然而，完整的程序可以在我们的 GitHub 仓库中找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code fragment, we first notice a friend class definition within
    the `Id` class. The statement `friend class Student;` indicates that all member
    functions in `Student` are friend functions to `Id`. This all-inclusive statement
    is in lieu of naming every function of the `Student` class as a friend function
    of `Id`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先注意到 `Id` 类中的一个友元类定义。语句 `friend class Student;` 表示 `Student` 中的所有成员函数都是
    `Id` 的友元函数。这个包含性的声明代替了将 `Student` 类的每个函数都命名为 `Id` 的友元函数。
- en: Also, in the `Student` class, notice the declaration of `friend void Id::SetStudent(Student
    *);`. This friend function declaration indicates that only this specific member
    function of `Id` is a friend function of `Student`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `Student` 类中，请注意 `friend void Id::SetStudent(Student *);` 的声明。这个友元函数声明表示，只有
    `Id` 的这个特定成员函数是 `Student` 的友元函数。
- en: The implication of the friend function prototype `friend void Id::SetStudent(Student
    *);` is that if a `Student` finds itself in the scope of the `Id::SetStudent()`
    method, that `Student` may manipulate its own members as though it is in its own
    scope, namely that of `Student`. You may ask, which `Student` may find itself
    in the scope of `Id::SetStudent(Student *)`? That’s easy, it is the one passed
    to the method as an input parameter. The result is that the input parameter of
    type `Student *` in the `Id::SetStudent()` method may access its own private and
    protected members as if the `Student` instance were in its own class scope – it
    is in the scope of a friend function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 友元函数原型 `friend void Id::SetStudent(Student *);` 的含义是，如果一个 `Student` 在 `Id::SetStudent()`
    方法的范围内，那么这个 `Student` 可以像在自己的作用域内一样操作自己的成员，即 `Student` 的作用域。你可能想知道，哪个 `Student`
    会发现自己处于 `Id::SetStudent(Student *)` 的作用域中？这很简单，就是作为输入参数传递给方法的那个。结果是，`Id::SetStudent()`
    方法中的类型为 `Student *` 的输入参数可以像 `Student` 实例在自己的类作用域内一样访问其自己的私有和受保护的成员——它处于友元函数的作用域中。
- en: 'Similarly, the implication of the friend class forward declaration: `friend
    class Student;` found in the `Id` class is that if any `Id` instance finds itself
    in a `Student` method, that `Id` instance can access its own private or protected
    methods as if it were in its own class. The `Id` instance may be in any member
    function of its friend class, `Student`; it is as though those methods have been
    augmented to also have the scope of the `Id` class.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Id` 类中找到的友元类前向声明 `friend class Student;` 的含义是，如果任何 `Id` 实例发现自己处于 `Student`
    方法中，那么这个 `Id` 实例可以像在自己的类中一样访问其自己的私有或受保护方法。`Id` 实例可能在其友元类 `Student` 的任何成员函数中，就像那些方法被扩展到也有
    `Id` 类的作用域一样。
- en: 'Notice that the class giving up access – that is, the class widening scope
    – is the one to announce friendship. That is, the `friend class Student;` statement
    in `Id` says: If any `Id` happens to be in any member function of `Student`, allow
    that `Id` to have full access to its members as if it is in its own scope. Likewise,
    the friend function statement in `Student` indicates that if a `Student` instance
    is found (via the input parameter) in this particular method of `Id`, it may have
    access to its elements fully, as though it were in a member function of its own
    class. Think in terms of friendship as a means of augmenting scope.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意放弃访问权的类——即扩展范围的类——是宣布友情的类。也就是说，`Id`中的`friend class Student;`语句表示：如果任何`Id`恰好位于`Student`的任何成员函数中，允许该`Id`完全访问其成员，就像它在自己的作用域中一样。同样，`Student`中的友元函数语句表示，如果在这个特定的`Id`方法中找到一个`Student`实例（通过输入参数），它可以完全访问其元素，就像它在自己的类成员函数中一样。从增加作用域的角度考虑友情。
- en: Now that we have seen the basic mechanics of friend functions and friend classes,
    let’s employ a simple contract to make it a bit more appealing to selectively
    break encapsulation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了友元函数和友元类的基本机制，让我们使用一个简单的协议来使其更具吸引力，以便选择性地破坏封装。
- en: Making access safer when using friends
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用友元时，使访问更安全
- en: 'We have seen that two tightly coupled classes, such as those related through
    an association, may need to extend their scope somewhat to selectively include
    one another through the use of **friend functions** or **friend classes**. The
    alternative is offering a public interface to select elements of each class. However,
    consider that you may not want the public interface to those elements to be uniformly
    accessible to be used in any scope of the application. You are truly facing a
    tough choice: utilize friends or provide an *overly public* interface.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，两个紧密耦合的类，例如通过关联相关联的类，可能需要稍微扩展它们的范围，以便通过使用**友元函数**或**友元类**来选择性地包含彼此。另一种选择是提供一个公共接口来选择每个类的元素。然而，考虑到你可能不希望这些元素的公共接口在应用程序的任何范围内都可以统一访问，你可以使用。你真正面临的是一个艰难的选择：利用友元还是提供一个**过于公开**的接口。
- en: Though it may make you initially cringe to utilize friends, it may be safer
    than the alternative of providing an undesired public interface to class elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始使用友元可能会让你感到不适，但它可能比提供对类元素的不希望公开的接口更安全。
- en: 'To lessen the panic that you feel towards the selective breaking of encapsulation
    that friends allow, consider adding the following contract to your usage of friends:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻你对友元允许的选择性破坏封装所感到的恐慌，考虑将以下协议添加到你的友元使用中：
- en: When utilizing friends, to lessen the loss of encapsulation, one class can provide
    private access methods to the other class’ data members. Consider making these
    methods inline for efficiency, as they are simple access methods (typically single
    line methods not likely to add software bloat through their expansion).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用友元时，为了减少封装的损失，一个类可以提供对另一个类数据成员的私有访问方法。考虑到这些方法是简单的访问方法（通常是单行方法，不太可能通过扩展增加软件膨胀），可以考虑将这些方法内联以提高效率。
- en: The instance in question should agree to only utilize the private access methods
    created to appropriately access its desired members while in the scope of the
    friend function (even though it could actually unrestrictedly access any data
    or methods of its own type in the scope of the friend function). This informal
    understanding is, of course, a gentleman’s agreement, and not language imposed.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被讨论的实例应同意仅使用在友元函数的作用域内适当访问其所需成员而创建的私有访问方法。这种非正式的理解当然是一种绅士协议，而不是语言强加的。
- en: 'Here is a simple example to illustrate two tightly coupled classes appropriately
    using a `main()` function and several methods are not shown to save space, the
    complete example can be found in our GitHub repository as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，说明如何使用`main()`函数和几个方法来适当地使用两个紧密耦合的类，为了节省空间，没有显示所有方法，完整的示例可以在我们的GitHub仓库中找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp)'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s examine the preceding class definitions for `LinkListElement` and `LinkList`.
    Notice that in the `LinkListElement` class, we have three private member functions:
    `void *GetData();`, `LinkListElement *GetNext();`, and `void SetNext(LinkListElement
    *);`. These three member functions should not be part of the public class interface.
    It is only appropriate for these methods to be used within the scope of `LinkList`,
    a class that is tightly coupled with `LinkListElement`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面定义的`LinkListElement`和`LinkList`类。注意，在`LinkListElement`类中，我们有三个私有成员函数：`void
    *GetData();`、`LinkListElement *GetNext();`和`void SetNext(LinkListElement *);`。这三个成员函数不应成为公共类接口的一部分。只有当这些方法在`LinkList`的范围内使用时才是合适的，`LinkList`是与`LinkListElement`紧密耦合的类。
- en: Next, notice the `friend class LinkList;` forward declaration in the `LinkListElement`
    class. This declaration means that all member functions of `LinkList` are friend
    functions of `LinkListElement`. As a result, any `LinkListElement` instances that
    find themselves in `LinkList` methods may access their own aforementioned private
    `GetData()`, `GetNext()`, and `SetNext()` methods simply because they will be
    in the scope of a friend class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意在`LinkListElement`类中的`friend class LinkList;`前向声明。这个声明意味着`LinkList`的所有成员函数都是`LinkListElement`的友元函数。因此，任何发现自己处于`LinkList`方法中的`LinkListElement`实例可以简单地访问它们之前提到的私有`GetData()`、`GetNext()`和`SetNext()`方法，因为它们将处于友元类的范围内。
- en: Next, let’s take a look at the `LinkList` class in the preceding code. The class
    definition itself does not have any unique declarations with respect to friendship.
    After all, it is the `LinkListElement` class that has widened its scope to include
    methods of the `LinkedList` class, not the other way around.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看前面代码中的`LinkList`类。类定义本身没有关于友元的独特声明。毕竟，是`LinkListElement`类扩大了其作用域以包括`LinkedList`类的方法，而不是相反。
- en: 'Now, let’s take a look at two selected member functions of the `LinkList` class.
    The full complement of these methods may be found online, at the previously mentioned
    URL:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`LinkList`类的两个选定的成员函数。这些方法的完整集合可以在之前提到的URL上找到：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we examine the aforementioned code, we can see that in a sampling of `LinkList`
    methods, a `LinkListElement` can call private methods on itself because it is
    in the scope of a friend function (which is essentially its own scope, widened).
    For example, in `LinkList::InsertAtFront()`, `LinkListElement *temp` sets its
    `next` member to `head` using `temp->SetNext(head)`. Certainly, we could have
    also directly accessed the private data member here using `temp->next = head;`.
    However, we maintained a modicum of encapsulation by `LinkListElement` providing
    private access functions, such as `SetNext()`, and asking `LinkList` methods (friend
    functions) to have `temp` utilize private method `SetNext()`, rather than just
    directly manipulating the data member itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查上述代码时，我们可以看到在`LinkList`方法的样本中，一个`LinkListElement`可以在友元函数（本质上是其自己的作用域的扩展）的作用域内调用其私有的方法。例如，在`LinkList::InsertAtFront()`中，`LinkListElement
    *temp`使用`temp->SetNext(head)`将其`next`成员设置为`head`。当然，我们也可以直接使用`temp->next = head;`来访问私有数据成员。然而，我们通过`LinkListElement`提供私有访问函数（如`SetNext()`），并要求`LinkList`方法（友元函数）让`temp`使用私有方法`SetNext()`，而不是直接操作数据成员本身，从而保持了一定的封装性。
- en: Because `GetData()`, `GetNext()`, and `SetNext()` in `LinkListElement` are inline
    functions, we do not forfeit performance by providing a sense of encapsulated
    access to members `data` and `next`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LinkListElement`中的`GetData()`、`GetNext()`和`SetNext()`是内联函数，我们通过提供封装访问成员`data`和`next`的感觉，并没有失去性能。
- en: We can similarly see that other member functions of `LinkList`, such as `RemoveAtFront()`
    (and `Print()` which appears in the online code) have `LinkListElement` instances
    utilizing its private access methods, rather than allowing the `LinkListElement`
    instances to grab their private `data` and `next` members directly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同样看到`LinkList`的其他成员函数，例如`RemoveAtFront()`（以及出现在在线代码中的`Print()`）使用`LinkListElement`实例利用其私有访问方法，而不是允许`LinkListElement`实例直接获取它们的私有`data`和`next`成员。
- en: '`LinkListElement` and `LinkList` are iconic examples of two tightly coupled
    classes in which it may be better to extend one class to include the other’s scope
    for access, rather than providing an *overly public* interface. After all, we
    wouldn’t want users in `main()` to get their hands on a `LinkListElement` and
    apply `SetNext()`, for example, which could change an entire `LinkedList` without
    the `LinkList` class’ knowledge.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkListElement` 和 `LinkList` 是两个紧密耦合的类的标志性例子，在这种情况下，最好扩展一个类以包含另一个类的访问范围，而不是提供一个**过于公开**的接口。毕竟，我们不想让
    `main()` 中的用户能够接触到 `LinkListElement` 并应用 `SetNext()`，例如，这可能会在没有 `LinkList` 类知识的情况下改变整个
    `LinkedList`。'
- en: Now that we have seen the mechanics as well as suggested usage for friend functions
    and classes, let’s explore another language feature that may need to utilize friends
    – that of operator overloading.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了友元函数和类的机制以及建议的用法，让我们探索另一种可能需要使用友元的语言特性——操作符重载。
- en: Deciphering operator overloading essentials
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密操作符重载的基本原理
- en: C++ has a variety of operators in the language. C++ allows most operators to
    be redefined to include usage with user defined types; this is known as **operator
    overloading**. In this way, user defined types may utilize the same notation as
    standard types to perform these well-understood operations. We can view an overloaded
    operator as polymorphic in that its same form can be used with a variety of types
    – standard and user defined.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言中包含多种操作符。C++ 允许大多数操作符被重新定义，以便包括与用户定义类型的用法；这被称为**操作符重载**。通过这种方式，用户定义的类型可以利用与标准类型相同的表示法来执行这些已知的操作。我们可以将重载的操作符视为多态的，因为它的相同形式可以与各种类型（标准类型和用户定义类型）一起使用。
- en: 'Not all operators may be overloaded in C++. The following operators cannot
    be overloaded: the member access operator (`.`), the ternary conditional operator
    (`?:`), the scope resolution operator (`::`), the pointer-to-member operator (`.*`),
    the `sizeof()` operator, and the `typeid()` operator. All the rest may be overloaded,
    provided at least one operand is a user defined type.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有操作符都可以在 C++ 中重载。以下操作符不能重载：成员访问操作符 (`.`)、三元条件操作符 (`?:`)、作用域解析操作符 (`::`)、成员指针操作符
    (`.*`)、`sizeof()` 操作符和 `typeid()` 操作符。所有其余的操作符都可以重载，前提是至少有一个操作数是用户定义类型。
- en: When overloading an operator, it is important to promote the same meaning that
    the operator has for standard types. For example, the extraction operator (`<<`)
    is defined when used in conjunction with `cout` to print to standard output. This
    operator can be applied to various standard types, such as integers, floating-point
    numbers, character strings, and so on. Should the extraction operator (`<<`) be
    overloaded for a user defined type, such as `Student`, it should also mean to
    print to standard output. In this fashion, operator `<<` is polymorphic when used
    in the context of an output buffer, such as `cout`; that is, it has the same meaning
    but different implementation for all types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在重载操作符时，重要的是要传达操作符对标准类型所具有的相同含义。例如，当与 `cout` 一起使用时，提取操作符 (`<<`) 被定义为打印到标准输出。此操作符可以应用于各种标准类型，例如整数、浮点数、字符字符串等。如果为用户定义的类型（如
    `Student`）重载提取操作符 (`<<`)，它也应该意味着打印到标准输出。以这种方式，操作符 `<<` 在输出缓冲区（如 `cout`）的上下文中是多态的；也就是说，它对所有类型具有相同的意义但不同的实现。
- en: It is important to note that when overloading an operator in C++, we may not
    change the predefined precedence of the operators as they occur in the language.
    This makes sense – we are not rewriting the compiler to parse and interpret expressions
    differently. We are merely extending the meaning of an operator from its usage
    with standard types to include usage with user defined types. Operator precedence
    will remain unchanged.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在 C++ 中重载操作符时，我们可能不能改变操作符在语言中出现的预定义优先级。这很有意义——我们并不是在重写编译器以不同方式解析和解释表达式。我们只是在扩展操作符的含义，从它与标准类型的用法扩展到包括与用户定义类型的用法。操作符优先级将保持不变。
- en: An `operator`, followed by the symbol representing the operator which you wish
    to overload.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**操作符**，后跟表示你想要重载的操作符的符号。
- en: 'Let’s take a look at the simple syntax of an operator function prototype:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看操作符函数原型的简单语法：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we intend to provide a means to add a floating-point number and a `Student`
    instance using the C++ addition operator (`+`). The meaning of this addition might
    be to average the new floating-point number with the student’s existing grade
    point average. Here, the name of the operator function is `operator+()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们旨在提供一种使用C++加法运算符（`+`）将浮点数和`Student`实例相加的方法。这种加法的意义可能是将新的浮点数与学生的现有平均成绩点数平均。在这里，运算符函数的名称是`operator+()`。
- en: In the aforementioned prototype, the operator function is not a member function
    of any class. The left expected operand will be a `float` and the right operand
    will be a `Student`. The return type of the function (`Student &`) allows us to
    cascade the use of `+` with multiple operands or be paired with multiple operators,
    such as `s1 = 3.45 + s2;`. The overall concept is that we can define how to use
    `+` with multiple types, provided at least one operand is a user defined type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，运算符函数不是任何类的成员函数。左操作数预期为`float`类型，右操作数为`Student`类型。函数的返回类型（`Student &`）允许我们使用多个操作数级联使用`+`，或者与多个运算符配对，例如`s1
    = 3.45 + s2;`。整体概念是，只要至少有一个操作数是用户定义类型，我们就可以定义如何使用`+`与多个类型一起使用。
- en: There’s actually a lot more involved than the simple syntax shown in the previous
    prototype. Before we fully examine a detailed example, let’s first take a look
    at more logistics relating to implementing operator functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，涉及的内容远不止前面原型中显示的简单语法。在我们全面检查详细示例之前，让我们首先看看更多与实现运算符函数相关的后勤问题。
- en: Implementing operator functions and knowing when friends might be necessary
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现运算符函数以及知道何时可能需要友元
- en: 'An **operator function**, the mechanism to overload an operator, may be implemented
    as a member function or as a regular, external function. Let’s summarize the mechanics
    of implementing operator functions with the following key points:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符函数**，重载运算符的机制，可以作为一个成员函数或作为一个常规的外部函数实现。让我们以下列关键点总结实现运算符函数的机制：'
- en: Operator functions that are implemented as member functions will receive an
    implicit argument (the `this` pointer), plus, at most, one explicit argument.
    If the left operand in the overloaded operation is a user defined type in which
    modifications to the class can easily be made, implementing the operator function
    as a member function is reasonable and preferred.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为成员函数实现的运算符函数将接收一个隐式参数（`this`指针），最多还有一个显式参数。如果重载操作中的左操作数是用户定义类型，并且可以轻松修改该类，则将运算符函数实现为成员函数是合理且首选的。
- en: Operator functions that are implemented as external functions will receive one
    or two explicit arguments. If the left operand in the overloaded operation is
    a standard type or a class type that is not modifiable, then an external (non-member)
    function must be used to overload this operator. This external function may need
    to be a `friend` of any object type that is used as the right-hand function argument.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为外部函数实现的运算符函数将接收一个或两个显式参数。如果重载操作中的左操作数是标准类型或不可修改的类类型，则必须使用外部（非成员）函数来重载此运算符。这个外部函数可能需要成为任何用作右手函数参数的对象类型的`friend`。
- en: Operator functions should most often be implemented reciprocally. That is, when
    overloading a binary operator, ensure that it has been defined to work no matter
    what order the data types (should they differ) appear in the operator.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符函数通常应该相互实现。也就是说，在重载二元运算符时，确保它已经定义为无论数据类型（如果它们不同）在运算符中出现的顺序如何都能工作。
- en: 'Let’s take a look at a full program example to illustrate the mechanics of
    operator overloading, including member and non-member functions, as well as scenarios
    requiring the usage of friends. Though some well-known portions of the program
    have been excluded to save space, the full program example can be found online
    in our GitHub repository:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个完整的程序示例，以说明运算符重载的机制，包括成员函数和非成员函数，以及需要使用友元的场景。尽管为了节省空间，已经排除了程序的一些知名部分，但完整的程序示例可以在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s begin our code examination by first looking at the preceding class definition
    for `Person`. In addition to the class elements that we are accustomed to seeing,
    we have four operator functions prototyped: `operator=()`, `operator==()`, and
    `operator+()` (which is implemented twice so that the operands to `+` can be reversed).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看`Person`类的先前定义开始，检查我们的代码。除了我们习惯看到的类元素之外，我们还有四个原型化的运算符函数：`operator=()`,
    `operator==()`, 和 `operator+()`（它被实现两次，以便`+`的运算数可以反转）。
- en: Functions for `operator=()`, `operator==()`, and one version of `operator+()`
    will be implemented as member functions of this class, whereas the other `operator+()`,
    with `const char *` and `Person` parameters, will be implemented as a non-member
    function and will additionally necessitate the use of a friend function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator=()`, `operator==()`和`operator+()`的一个版本将被实现为这个类的成员函数，而另一个`operator+()`，具有`const
    char *`和`Person`参数，将被实现为一个非成员函数，并且还需要使用友元函数。'
- en: Overloading the assignment operator
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值运算符重载
- en: 'Let’s move forward to examine the applicable operator function definitions
    for this class, starting by overloading the assignment operator:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，检查这个类的适用运算符函数定义，首先从重载赋值运算符开始：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let us now review the overloaded assignment operator in the preceding code.
    It is designated by the member function `Person &Person::operator=(const Person
    &p);`. Here, we will be assigning memory from a source object, which will be input
    parameter `p`, to a destination object, which will be pointed to by `this`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下前面代码中重载的赋值运算符。它由成员函数`Person &Person::operator=(const Person &p);`指定。在这里，我们将从源对象分配内存，该源对象将是输入参数`p`，到目标对象，该对象将由`this`指向。
- en: Our first order of business will be to ensure that we are not assigning an object
    to itself. Should this be the case, there is no work to be done! We make this
    check by testing `if (this != &p)` to see whether both addresses point to the
    same object. If we’re not assigning an object to itself, we continue.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是确保我们不是将对象赋值给自己。如果是这种情况，就没有工作要做！我们通过测试`if (this != &p)`来检查两个地址是否指向同一个对象。如果不是将对象赋值给自己，我们继续。
- en: Next, within the conditional statement (`if`), we first deallocate the existing
    memory for the dynamically allocated data members pointed to by `this`. After
    all, the object on the left-hand of the assignment pre-exists and undoubtedly
    has allocations for these data members.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在条件语句（`if`）内部，我们首先释放由`this`指向的动态分配的数据成员所使用的现有内存。毕竟，赋值运算符左侧的对象是预先存在的，并且无疑为这些数据成员进行了分配。
- en: Now, we notice that the core piece of code within the conditional statement
    looks very similar to that of the copy constructor. That is, we carefully allocate
    space for pointer data members to match the sizes needed from their corresponding
    data members of input parameter `p`. We then copy the applicable data members
    from input parameter `p` to the data members pointed to by `this`. For the `char`
    data member, `middleInitial`, a memory allocation is not necessary; we merely
    use an assignment. This is also true for the `string` data members, `firstName`
    and `lastName`. In this segment of code, we ensure that we have performed a deep
    assignment for any pointer data members. A shallow (pointer) assignment, where
    the source and destination object would otherwise share memory for the data portions
    of data members that are pointers, would be a disaster waiting to happen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们注意到条件语句中的核心代码看起来与复制构造函数非常相似。也就是说，我们仔细分配空间给指针数据成员，以匹配从输入参数`p`的相应数据成员所需的大小。然后，我们将输入参数`p`的适用数据成员复制到由`this`指向的数据成员。对于`char`数据成员`middleInitial`，不需要内存分配；我们只是使用赋值。对于`string`数据成员`firstName`和`lastName`也是如此。在这段代码中，我们确保我们对任何指针数据成员执行了深度赋值。浅拷贝（指针赋值），其中源对象和目标对象本应共享数据成员指针的数据部分内存，将会是一个即将发生的灾难。
- en: Lastly, at the end of our implementation of `operator=()`, we return `*this`.
    Notice that the return type from this function is a reference to a `Person`. Since
    `this` is a pointer, we merely dereference it so that we may return a referenceable
    object. This is done so that assignments between `Person` instances can be cascaded;
    that is, `p1 = p2 = p3;` where `p1`, `p2`, and `p3` are each an instance of `Person`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的 `operator=()` 实现的末尾，我们返回 `*this`。请注意，此函数的返回类型是 `Person` 的引用。由于 `this`
    是一个指针，我们只需取消引用它，以便返回一个可引用的对象。这样做是为了使 `Person` 实例之间的赋值可以级联；也就是说，`p1 = p2 = p3;`
    其中 `p1`、`p2` 和 `p3` 分别是 `Person` 的实例。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When overloading `operator=`, always check for self-assignment. That is, make
    sure you are not assigning an object to itself. Not only is there no work to be
    done in the case of self-assignment, but proceeding with an unnecessary self-assignment
    can actually create unexpected errors! For example, if we have dynamically allocated
    data members, we will be releasing destination object memory and re-allocating
    those data members based on the details of the source object’s memory (which,
    when being the same object, will have been released). The resulting behavior can
    be unpredictable and error-prone.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当重载 `operator=` 时，始终检查自赋值。也就是说，确保你不会将一个对象赋值给自己。在自赋值的情况下，实际上没有工作要做，但继续进行不必要的自赋值实际上可能会产生意外的错误！例如，如果我们有动态分配的数据成员，我们将释放目标对象的内存，并根据源对象内存的细节重新分配这些数据成员（当它们是同一个对象时，这些内存已经被释放）。这种行为可能是不可预测的，并且容易出错。
- en: 'Should the programmer wish to disallow assignment between two objects, the
    keyword `delete` can be used in the prototype of the overloaded assignment operator
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员希望禁止两个对象之间的赋值，可以在重载赋值运算符的原型中使用 `delete` 关键字，如下所示：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is useful to remember that an overloaded assignment operator shares many
    similarities with the copy constructor; the same care and cautions apply to both
    language features. Keep in mind, however, that the assignment operator will be
    invoked when conducting an assignment between two pre-existing objects, whereas
    the copy constructor is implicitly invoked for initialization following the creation
    of a new instance. With the copy constructor, the new instance uses the existing
    instance as its basis for initialization; similarly, the left-hand object of the
    assignment operator uses the right-hand object as its basis for the assignment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，重载的赋值运算符与拷贝构造函数有很多相似之处；对这两种语言特性都应采取相同的谨慎和注意。然而，请注意，赋值运算符将在进行两个现有对象之间的赋值时被调用，而拷贝构造函数是在创建新实例后隐式调用的初始化。在拷贝构造函数中，新实例使用现有实例作为其初始化的基础；同样，赋值运算符的左侧对象使用右侧对象作为其赋值的基础。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An overloaded assignment operator is not inherited by derived classes; therefore,
    it must be defined by each class in the hierarchy. Neglecting to overload `operator=`
    for a class will force the compiler to provide you with a default, shallow assignment
    operator for that class; this is dangerous for any classes containing data members
    that are pointers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的赋值运算符不会被派生类继承；因此，它必须由层次结构中的每个类定义。忽略为类重载 `operator=` 将迫使编译器为该类提供一个默认的浅拷贝赋值运算符；这对于包含指针数据成员的任何类都是危险的。
- en: Overloading the comparison operator
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值运算符重载
- en: 'Next, let’s take a look at our implementation of the overloaded comparison
    operator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们对重载的赋值运算符的实现：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Continuing with a segment from our previous program, we overload the comparison
    operator. It is designated by the member function `int Person::operator==(const
    Person &p);`. Here, we will be comparing a `Person` object on the right-hand side
    of the operator, which will be referenced by input parameter `p`, to a `Person`
    object on the left-hand side of the operator, which will be pointed to by `this`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们之前的程序段，我们重载比较运算符。它由成员函数 `int Person::operator==(const Person &p);` 指定。在这里，我们将比较运算符右侧的
    `Person` 对象，该对象将通过输入参数 `p` 进行引用，与运算符左侧的 `Person` 对象进行比较，该对象将由 `this` 指向。
- en: Similarly, our first order of business will be to test whether the object on
    the `if (this != &p)` to see whether both addresses point to the same object.
    If both addresses point to the same object, we return the boolean (`bool`) value
    of `true`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的首要任务是测试 `if (this != &p)` 中的对象是否指向同一个对象。如果两个地址都指向同一个对象，我们返回布尔值 (`bool`)
    的 `true`。
- en: Next, we check whether the two `Person` objects contain identical values. They
    may be separate objects in memory, yet if they contain identical values, we can
    likewise choose to return a `bool` value of `true`. If there is no match, we then
    return a `bool` value of `false`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查两个 `Person` 对象是否包含相同的值。它们可能在内存中是分离的对象，但如果它们包含相同的值，我们同样可以选择返回 `bool`
    值为 `true`。如果没有匹配，我们则返回 `bool` 值为 `false`。
- en: Overloading the addition operator as a member function
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将加法操作符作为成员函数重载
- en: 'Now, let’s take a look at how to overload `operator+` for `Person` and a `string`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为 `Person` 和 `string` 重载 `operator+`：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Moving forward with the preceding program, we overload the addition operator
    (`+`) to be used with a `Person` and a `string`. The operator function is designated
    by the member function prototype `Person& Person::operator+(const string &t);`.
    The parameter, `t`, will represent the right operand of `operator+`, which is
    a character string (which will bind to a reference to a string). The left-hand
    operand will be pointed to by `this`. An example use would be `p1 + "Miss"`, where
    we wish to add a `title` to the `Person` `p1` using `operator+`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用前面的程序，我们将加法操作符 (`+`) 重载以与 `Person` 和 `string` 一起使用。操作符函数由成员函数原型 `Person&
    Person::operator+(const string &t);` 指定。参数 `t` 将代表 `operator+` 的右操作数，它是一个字符字符串（它将绑定到一个字符串的引用）。左操作数将由
    `this` 指向。一个可能的用法是 `p1 + "Miss"`，其中我们希望使用 `operator+` 给 `Person` `p1` 添加一个 `title`。
- en: In the body of this member function, we merely use the input parameter `t` as
    an argument to `ModifyTitle()`, that is, `ModifyTitle(t);`. We then return `*this`
    so that we may cascade the use of this operator (notice the return type is a `Person
    &`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个成员函数的主体中，我们仅仅将输入参数 `t` 作为 `ModifyTitle()` 的参数使用，即 `ModifyTitle(t);`。然后我们返回
    `*this` 以便我们可以级联使用这个操作符（注意返回类型是 `Person &`）。
- en: Overloading the addition operator as a non-member function (using friends)
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将加法操作符作为非成员函数重载（使用友元）
- en: 'Now, let’s reverse the order of operands with `operator+` to allow for a `string`
    and a `Person`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `operator+` 反转操作数的顺序，以便使用 `string` 和 `Person`：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Continuing forward with the preceding program, we would ideally like `operator+`
    to work not only with a `Person` and a `string` but also with the operands reversed,
    that is, with a `string` and a `Person`. There is no reason this operator should
    work one way and not the other.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用前面的程序，我们希望 `operator+` 不仅与 `Person` 和 `string` 一起工作，而且与操作数顺序相反，即与 `string`
    和 `Person` 一起工作。没有理由这个操作符应该以一种方式工作，而不是另一种方式。
- en: To implement `operator+` fully, we next overload `operator+()` to be used with
    `const string &` and `Person`. The operator function is designated by the non-member
    function `Person& operator+(const string &t, Person &p);`, which has two explicit
    input parameters. The first parameter, `t`, will represent the left operand of
    `operator+`, which is a character string (binding this parameter to a reference
    to a string as the first formal parameter in the operator function). The second
    parameter, `p`, will be a reference to the right operand used in `operator+`.
    An example use might be `"Miss" + p1`, where we wish to add a title to the `Person
    p1` using `operator+`. Note that `"Miss"` will be constructed as a `string` using
    the `std::string(const char *)` constructor—the string literal is simply the initial
    value for the string object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全实现 `operator+`，我们接下来重载 `operator+()` 以与 `const string &` 和 `Person` 一起使用。操作符函数由非成员函数
    `Person& operator+(const string &t, Person &p);` 指定，它有两个显式输入参数。第一个参数 `t` 将代表 `operator+`
    的左操作数，它是一个字符串（将此参数绑定到操作符函数中的第一个形式参数的字符串引用）。第二个参数 `p` 将是 `operator+` 中使用的右操作数的引用。一个可能的用法是
    `"Miss" + p1`，其中我们希望使用 `operator+` 给 `Person p1` 添加一个头衔。注意，`"Miss"` 将使用 `std::string(const
    char *)` 构造函数构造为一个 `string`——字符串字面量只是字符串对象的初始值。
- en: In the body of this non-member function, we merely take input parameter `p`
    and apply the protected method `ModifyTitle()` using the string of characters
    specified by parameter `t`, that is, `p.ModifyTitle(t)`. However, because `Person::ModifyTitle()`
    is protected, `Person &p` may not invoke this method outside of member functions
    of `Person`. We are in an external function; we are not in the scope of `Person`.
    Therefore, unless this member function is a `friend` of `Person`, `p` may not
    invoke `ModifyTitle()`. Luckily, `Person &operator+(const string &, Person &);`
    has been prototyped as a friend function in the `Person` class, providing the
    necessary scope to `p` to allow it to invoke its protected method. It is as if
    `p` is in the scope of `Person`; it is in the scope of a friend function of `Person`!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非成员函数的函数体内，我们仅仅接受输入参数 `p` 并使用参数 `t` 指定的字符串字符调用受保护的 `ModifyTitle()` 方法，即 `p.ModifyTitle(t)`。然而，因为
    `Person::ModifyTitle()` 是受保护的，`Person &p` 可能不能在 `Person` 的成员函数之外调用此方法。我们处于外部函数中；我们不在
    `Person` 的作用域内。因此，除非这个成员函数是 `Person` 的 `friend`，否则 `p` 不能调用 `ModifyTitle()`。幸运的是，`Person
    &operator+(const string &, Person &);` 已经在 `Person` 类中作为友元函数原型，为 `p` 提供了必要的范围，允许它调用其受保护的方法。这就像
    `p` 在 `Person` 的作用域内；它是在 `Person` 的友元函数的作用域内！
- en: 'Let us now move forward to our `main()` function, tying together our many aforementioned
    code segments, so we may see how to invoke our operator functions utilizing our
    overloaded operators:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进到我们的 `main()` 函数，将我们之前提到的许多代码段结合起来，以便我们可以看到如何使用重载运算符调用我们的运算符函数：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, let us examine our `main()` function for the preceding program. We
    begin by instantiating three instances of `Person`, namely `p1`, `p2`, and `p3`;
    we then print their values using member function `Print()` for each instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查前面程序中的 `main()` 函数。我们首先实例化三个 `Person` 实例，即 `p1`、`p2` 和 `p3`；然后使用每个实例的成员函数
    `Print()` 打印它们的值。
- en: 'Now, we invoke our overloaded assignment operator with the statement `p1 =
    p2;`. Under the hood, this translates to the following operator function invocation:
    `p1.operator=(p2);`. From this, we can clearly see that we are invoking the previously
    defined `operator=()` method of `Person`, which performs a deep copy from source
    object `p2` to destination object `p1`. We apply `p1.Print();` to see our resulting
    copy.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们用语句 `p1 = p2;` 调用我们的重载赋值运算符。在底层，这翻译成以下运算符函数调用：`p1.operator=(p2);`。从这我们可以清楚地看到，我们正在调用之前定义的
    `operator=()` 方法，该方法从源对象 `p2` 深度复制到目标对象 `p1`。我们使用 `p1.Print();` 来查看我们的复制结果。
- en: 'Next, we invoke our overloaded `operator+` with `"Ms." + p2`. This portion
    of this line of code translates to the following operator function call: `operator+("Ms.",
    p2);`. Here, we simply invoke our previously described `operator+()` function,
    which is a non-member function and `friend` of the `Person` class. Because this
    function returns a `Person &`, we can cascade this function call to look more
    like the usual context of addition and additionally write `p2 = "Ms." + p2;`.
    In this full line of code, first, `operator+()` is invoked for `"Ms." + p2`. The
    return value of this invocation is `p2`, which is then used as the right-hand
    operand of the cascaded call to `operator=`. Notice that the left-hand operand
    to `operator=` also happens to be `p2`. Fortunately, the overloaded assignment
    operator checks for self-assignment.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们用 `"Ms." + p2` 调用我们的重载 `operator+`。这一行代码的这一部分翻译成以下运算符函数调用：`operator+("Ms.",
    p2);`。在这里，我们简单地调用之前描述的 `operator+()` 函数，这是一个非成员函数，也是 `Person` 类的 `friend`。因为此函数返回一个
    `Person &`，我们可以级联这个函数调用，使其看起来更像通常的加法上下文，并额外写出 `p2 = "Ms." + p2;`。在这整行代码中，首先调用
    `operator+()` 对 `"Ms." + p2`。这个调用的返回值是 `p2`，然后被用作级联调用 `operator=` 的右操作数。注意，`operator=`
    的左操作数也恰好是 `p2`。幸运的是，重载的赋值运算符检查自赋值。
- en: 'Now, we see a cascaded assignment of `p1 = p2 = p3;`. Here, we are invoking
    the overloaded assignment operator twice. First, we invoke `operator=` with `p2`
    and `p3`. The translated call would be `p2.operator=(p3);`. Then, using the return
    value of the first function call, we would invoke `operator=` a second time. The
    nested, translated call for `p1 = p2 = p3;` would look like this: `p1.operator=(p2.operator=(p3));`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到一个级联赋值 `p1 = p2 = p3;`。在这里，我们两次调用了重载的赋值运算符。首先，我们用 `p2` 和 `p3` 调用 `operator=`。翻译后的调用将是
    `p2.operator=(p3);`。然后，使用第一次函数调用的返回值，我们再次调用 `operator=`。对于 `p1 = p2 = p3;` 的嵌套翻译调用看起来像这样：`p1.operator=(p2.operator=(p3));`。
- en: Lastly in this program, we invoke the overloaded comparison operator twice.
    For example, each comparison of `if (p2 == p2)` or `if (p1 == p3)` merely calls
    the `operator==` member function we have defined previously. Recall that we’ve
    written this function to report `true` either if the objects are the same in memory
    or simply contain the same values, and return `false` otherwise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在这个程序中，我们调用了两次重载的比较操作符。例如，每次比较`if (p2 == p2)`或`if (p1 == p3)`仅仅调用我们之前定义的`operator==`成员函数。回想一下，我们编写这个函数是为了报告对象在内存中相同或简单地包含相同的值时返回`true`，否则返回`false`。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have now seen how to specify and utilize friend classes and friend functions,
    how to overload C++ operators, and have seen cases when these two concepts can
    complement each other. Let us now briefly recap the features we have learned in
    this chapter before moving forward to our next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何指定和利用友元类和友元函数，如何重载C++操作符，以及这些概念可以相互补充的情况。在我们继续前进到下一章之前，让我们简要回顾一下本章我们学到的特性。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have furthered our C++ programming endeavors beyond OOP
    language features to include features that will enable us to write more extensible
    programs. We have learned how to utilize friend functions and friend classes and
    we have learned how to overload operators in C++.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将C++编程努力扩展到了面向对象语言特性之外，包括将使我们能够编写更可扩展程序的功能。我们已经学习了如何利用友元函数和友元类，我们也学习了如何在C++中重载操作符。
- en: We have seen that friend functions and classes should be used sparingly and
    with caution. They are not meant to provide a blatant means to circumvent access
    regions. Instead, they are meant to handle programming situations to allow access
    between two tightly coupled classes without providing the alternative of an *overly
    public* interface in either of those classes, which could be misused on a broader
    scale.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，应该谨慎且少量地使用友元函数和类。它们不是为了提供一种明显的绕过访问区域的方法。相反，它们是为了处理编程情况，允许两个紧密耦合的类之间进行访问，而不在任一类中提供过于公开的接口，这可能在更广泛的范围内被滥用。
- en: We have seen how to overload operators in C++ using operator functions, both
    as member and non-member functions. We have learned that overloading operators
    will allow us to extend the meaning of C++ operators to include user defined types
    in the same way they encompass standard types. We have also seen that, in some
    cases, friend functions or classes may come in handy to help implement operator
    functions so they may behave associatively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用操作符函数在C++中重载操作符，无论是作为成员函数还是非成员函数。我们已经了解到，重载操作符将允许我们扩展C++操作符的意义，使其包括用户定义的类型，就像它们包含标准类型一样。我们还看到，在某些情况下，友元函数或类可能很有用，可以帮助实现操作符函数，以便它们可以关联地行为。
- en: We have added important features to our C++ repertoire through exploring friends
    and operator overloading, the latter of which will help us to ensure code we will
    soon write using templates can be used for nearly any data type, contributing
    to highly extensible and reusable code. We are now ready to move forward to [*Chapter
    13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*, so that we can
    continue expanding our C++ programming skills with essential language features
    that will make us better programmers. Let’s move ahead!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索友元和操作符重载，我们已经为我们的C++工具箱添加了重要功能，后者将帮助我们确保我们很快将使用模板编写的代码可以用于几乎任何数据类型，从而有助于高度可扩展和可重用的代码。我们现在可以继续前进到[*第13章*](B19087_13.xhtml#_idTextAnchor561)，*使用模板*，这样我们就可以继续使用基本语言特性来扩展我们的C++编程技能，这些特性将使我们成为更好的程序员。让我们继续前进吧！
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Overload `operator=` in your `Shape` exercise from [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*, or alternatively, overload `operator=` in your ongoing
    `LifeForm`/`Person`/`Student` classes as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[*第8章*](B19087_08.xhtml#_idTextAnchor399)，*掌握抽象类*的“Shape”练习中重载`operator=`，或者，也可以在你的正在进行的`LifeForm`/`Person`/`Student`类中重载`operator=`，如下所示：
- en: 'Define `operator=` in `Shape` (or `LifeForm`) and override this method in all
    of its derived classes. Hint: the derived implementation of `operator=()` will
    do more work than its ancestor, yet could call its ancestor’s implementation to
    perform the base class part of the work.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Shape`（或`LifeForm`）中定义`operator=`，并在所有其派生类中重写此方法。提示：派生类中`operator=()`的实现将比其祖先做更多的工作，但仍可以调用祖先的实现来执行基类的工作部分。
- en: Overload `operator<<` in your `Shape` class (or `LifeForm` class) to print information
    about each `Shape` (or `LifeForm`). The arguments to this function should be an
    `ostream &` and a `Shape &` (or a `LifeForm &`). Note that `ostream` is from the
    C++ Standard Library (`using namespace std;`).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Shape` 类（或 `LifeForm` 类）中重载 `operator<<` 操作符以打印每个 `Shape`（或 `LifeForm`）的信息。此函数的参数应该是一个
    `ostream &` 和一个 `Shape &`（或一个 `LifeForm &`）。注意，`ostream` 来自 C++ 标准库（`using namespace
    std;`）。
- en: You may either provide one function, `ostream &operator<<(ostream &, Shape &);`,
    and from it call a polymorphic `Print()`, which is defined in `Shape` and redefined
    in each derived class. Or, provide multiple `operator<<` methods to implement
    this functionality (one for each derived class). If using the `Lifeform` hierarchy,
    substitute `LifeForm` for `Shape`, in the aforementioned `operator<<` function
    signature.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提供一个函数，`ostream &operator<<(ostream &, Shape &);`，并从该函数中调用在 `Shape` 中定义并在每个派生类中重新定义的多态
    `Print()`，或者提供多个 `operator<<` 方法来实现此功能（每个派生类一个）。如果使用 `Lifeform` 层次结构，在上述 `operator<<`
    函数签名中将 `LifeForm` 替换为 `Shape`。
- en: 'Create an `ArrayInt` class to provide safe integer arrays with bounds checking.
    Overload `operator[]` to return an element if it exists in the array, or throw
    an exception if it is `OutOfBounds`. Add other methods to `ArrayInt`, such as
    `Resize()`, `RemoveElement()`, and so on. Model the data comprising the array
    using a dynamically allocated array (that is, using `int *contents`) so that you
    can easily handle resizing. The code would begin as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ArrayInt` 类以提供具有边界检查的安全整数数组。重载 `operator[]` 以返回数组中存在的元素，或者在元素不存在时抛出 `OutOfBounds`
    异常。向 `ArrayInt` 添加其他方法，例如 `Resize()`、`RemoveElement()` 等。使用动态分配的数组（即使用 `int *contents`）来表示数组中的数据，这样你可以轻松地处理调整大小。代码可以从以下内容开始：
- en: '[PRE12]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
