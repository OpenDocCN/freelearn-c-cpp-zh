- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Friends and Operator Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit of expanding your C++ programming repertoire
    beyond OOP concepts, with the goal of writing more extensible code. We will next
    explore **friend functions**, **friend classes**, and **operator overloading**
    in C++. We will understand how operator overloading can extend operators beyond
    their usage with standard types to behave uniformly with user defined types, and
    why this is a powerful OOP tool. We will learn how friend functions and classes
    can be safely used to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding friend functions and friend classes, appropriate reasons to utilize,
    and measures to add safety to their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about operator overloading essentials – how and why to overload operators,
    ensuring operators are polymorphic between standard and user defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing operator functions and knowing when friends may be necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will unlock the proper usage of friends and
    understand their utility in harnessing C++’s ability to overload operators. Though
    the usage of friend functions and classes can be exploited, you will instead insist
    on their contained usage only within two tightly coupled classes. You will understand
    how the proper usage of friends can enhance operator overloading, allowing operators
    to be extended to support user defined types so they may work associatively with
    their operands.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our understanding of C++ by expanding your programming repertoire
    through exploring friend functions, friend classes, and operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter12` in a file named `Chp12-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3K0f4tb](https://bit.ly/3K0f4tb).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding friend classes and friend functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is a valuable OOP feature that C++ offers through the proper usage
    of classes and access regions. Encapsulation offers uniformity in the manner in
    which data and behaviors are manipulated. In general, it is unwise to forfeit
    the encapsulated protection that a class offers.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, selected programming situations in which breaking encapsulation
    slightly is considered more acceptable than the alternative of providing an *overly
    public* interface to a class. That is, when a class needs to provide methods for
    two classes to cooperate, yet, in general, those methods are inappropriate to
    be publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a scenario that may lead us to consider slightly forfeiting
    (that is, breaking) the sacred OOP concept of encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: Two tightly coupled classes may exist that are not otherwise related to one
    another. One class may have one or more associations with the other class and
    need to manipulate the other class’s members. Yet, a public interface to allow
    access to such members would make these internals *overly public* and subject
    to manipulation well beyond the needs of the pair of tightly coupled classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this situation, it is a better choice to allow one class in the tightly coupled
    pair to have access to the other class’s members versus providing a public interface
    in the other class that allows for more manipulation of these members than is
    generally safe. We will see, momentarily, how to minimize this prospective loss
    of encapsulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selected operator overloading situations, which we will soon see, may require
    an instance to have access to its members while in a function that is outside
    of its class scope. Again, a fully accessible public interface may be considered
    dangerous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friend functions** and **friend classes** allow this selective breaking of
    encapsulation to occur. Breaking encapsulation is serious and should not be done
    to simply override access regions. Instead, friends can be used – with added safety
    measures – when the choices are slightly breaking encapsulation between two tightly
    coupled classes or providing an overly public interface that would yield greater
    and potentially unwanted access to another class’s members from various scopes
    in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a look at how each may be used, and then we will add the relevant
    safety measures we should insist on employing. Let’s start with friend functions
    and friend classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using friend functions and friend classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Friend functions** are functions that are individually granted *extended
    scope* to include the class with which they are associated. Let’s examine the
    implications and logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: In the scope of friend functions, an instance of the associated type can access
    its own members as if it were in the scope of its own class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A friend function needs to be prototyped as a friend in the class definition
    of the class relinquishing access (that is, extending its scope).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `friend` is used in front of the prototype that provides access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions overloading friend functions are not considered friends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friend classes** are classes in which every member function of the class
    is a friend function of the associated class. Let’s examine the logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: A friend class should have a forward declaration in the class definition of
    the class that is providing it with access to its members (that is, scope).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `friend` should precede the forward declaration of the class gaining
    access (that is, whose scope has been extended).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Friend classes and friend functions should be utilized sparingly, only when
    breaking encapsulation selectively and slightly is it a better choice than offering
    an *overly public* interface (that is, a public interface that would universally
    offer undesired access to selected members within any scope of the application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by examining the syntax for friend classes and friend function
    declarations. The following classes do not represent complete class definitions;
    however, the complete program can be found in our online in our GitHub repository
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code fragment, we first notice a friend class definition within
    the `Id` class. The statement `friend class Student;` indicates that all member
    functions in `Student` are friend functions to `Id`. This all-inclusive statement
    is in lieu of naming every function of the `Student` class as a friend function
    of `Id`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the `Student` class, notice the declaration of `friend void Id::SetStudent(Student
    *);`. This friend function declaration indicates that only this specific member
    function of `Id` is a friend function of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: The implication of the friend function prototype `friend void Id::SetStudent(Student
    *);` is that if a `Student` finds itself in the scope of the `Id::SetStudent()`
    method, that `Student` may manipulate its own members as though it is in its own
    scope, namely that of `Student`. You may ask, which `Student` may find itself
    in the scope of `Id::SetStudent(Student *)`? That’s easy, it is the one passed
    to the method as an input parameter. The result is that the input parameter of
    type `Student *` in the `Id::SetStudent()` method may access its own private and
    protected members as if the `Student` instance were in its own class scope – it
    is in the scope of a friend function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the implication of the friend class forward declaration: `friend
    class Student;` found in the `Id` class is that if any `Id` instance finds itself
    in a `Student` method, that `Id` instance can access its own private or protected
    methods as if it were in its own class. The `Id` instance may be in any member
    function of its friend class, `Student`; it is as though those methods have been
    augmented to also have the scope of the `Id` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the class giving up access – that is, the class widening scope
    – is the one to announce friendship. That is, the `friend class Student;` statement
    in `Id` says: If any `Id` happens to be in any member function of `Student`, allow
    that `Id` to have full access to its members as if it is in its own scope. Likewise,
    the friend function statement in `Student` indicates that if a `Student` instance
    is found (via the input parameter) in this particular method of `Id`, it may have
    access to its elements fully, as though it were in a member function of its own
    class. Think in terms of friendship as a means of augmenting scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the basic mechanics of friend functions and friend classes,
    let’s employ a simple contract to make it a bit more appealing to selectively
    break encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Making access safer when using friends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that two tightly coupled classes, such as those related through
    an association, may need to extend their scope somewhat to selectively include
    one another through the use of **friend functions** or **friend classes**. The
    alternative is offering a public interface to select elements of each class. However,
    consider that you may not want the public interface to those elements to be uniformly
    accessible to be used in any scope of the application. You are truly facing a
    tough choice: utilize friends or provide an *overly public* interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Though it may make you initially cringe to utilize friends, it may be safer
    than the alternative of providing an undesired public interface to class elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To lessen the panic that you feel towards the selective breaking of encapsulation
    that friends allow, consider adding the following contract to your usage of friends:'
  prefs: []
  type: TYPE_NORMAL
- en: When utilizing friends, to lessen the loss of encapsulation, one class can provide
    private access methods to the other class’ data members. Consider making these
    methods inline for efficiency, as they are simple access methods (typically single
    line methods not likely to add software bloat through their expansion).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance in question should agree to only utilize the private access methods
    created to appropriately access its desired members while in the scope of the
    friend function (even though it could actually unrestrictedly access any data
    or methods of its own type in the scope of the friend function). This informal
    understanding is, of course, a gentleman’s agreement, and not language imposed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate two tightly coupled classes appropriately
    using a `main()` function and several methods are not shown to save space, the
    complete example can be found in our GitHub repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the preceding class definitions for `LinkListElement` and `LinkList`.
    Notice that in the `LinkListElement` class, we have three private member functions:
    `void *GetData();`, `LinkListElement *GetNext();`, and `void SetNext(LinkListElement
    *);`. These three member functions should not be part of the public class interface.
    It is only appropriate for these methods to be used within the scope of `LinkList`,
    a class that is tightly coupled with `LinkListElement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice the `friend class LinkList;` forward declaration in the `LinkListElement`
    class. This declaration means that all member functions of `LinkList` are friend
    functions of `LinkListElement`. As a result, any `LinkListElement` instances that
    find themselves in `LinkList` methods may access their own aforementioned private
    `GetData()`, `GetNext()`, and `SetNext()` methods simply because they will be
    in the scope of a friend class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the `LinkList` class in the preceding code. The class
    definition itself does not have any unique declarations with respect to friendship.
    After all, it is the `LinkListElement` class that has widened its scope to include
    methods of the `LinkedList` class, not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at two selected member functions of the `LinkList` class.
    The full complement of these methods may be found online, at the previously mentioned
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we examine the aforementioned code, we can see that in a sampling of `LinkList`
    methods, a `LinkListElement` can call private methods on itself because it is
    in the scope of a friend function (which is essentially its own scope, widened).
    For example, in `LinkList::InsertAtFront()`, `LinkListElement *temp` sets its
    `next` member to `head` using `temp->SetNext(head)`. Certainly, we could have
    also directly accessed the private data member here using `temp->next = head;`.
    However, we maintained a modicum of encapsulation by `LinkListElement` providing
    private access functions, such as `SetNext()`, and asking `LinkList` methods (friend
    functions) to have `temp` utilize private method `SetNext()`, rather than just
    directly manipulating the data member itself.
  prefs: []
  type: TYPE_NORMAL
- en: Because `GetData()`, `GetNext()`, and `SetNext()` in `LinkListElement` are inline
    functions, we do not forfeit performance by providing a sense of encapsulated
    access to members `data` and `next`.
  prefs: []
  type: TYPE_NORMAL
- en: We can similarly see that other member functions of `LinkList`, such as `RemoveAtFront()`
    (and `Print()` which appears in the online code) have `LinkListElement` instances
    utilizing its private access methods, rather than allowing the `LinkListElement`
    instances to grab their private `data` and `next` members directly.
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkListElement` and `LinkList` are iconic examples of two tightly coupled
    classes in which it may be better to extend one class to include the other’s scope
    for access, rather than providing an *overly public* interface. After all, we
    wouldn’t want users in `main()` to get their hands on a `LinkListElement` and
    apply `SetNext()`, for example, which could change an entire `LinkedList` without
    the `LinkList` class’ knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the mechanics as well as suggested usage for friend functions
    and classes, let’s explore another language feature that may need to utilize friends
    – that of operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering operator overloading essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has a variety of operators in the language. C++ allows most operators to
    be redefined to include usage with user defined types; this is known as **operator
    overloading**. In this way, user defined types may utilize the same notation as
    standard types to perform these well-understood operations. We can view an overloaded
    operator as polymorphic in that its same form can be used with a variety of types
    – standard and user defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all operators may be overloaded in C++. The following operators cannot
    be overloaded: the member access operator (`.`), the ternary conditional operator
    (`?:`), the scope resolution operator (`::`), the pointer-to-member operator (`.*`),
    the `sizeof()` operator, and the `typeid()` operator. All the rest may be overloaded,
    provided at least one operand is a user defined type.'
  prefs: []
  type: TYPE_NORMAL
- en: When overloading an operator, it is important to promote the same meaning that
    the operator has for standard types. For example, the extraction operator (`<<`)
    is defined when used in conjunction with `cout` to print to standard output. This
    operator can be applied to various standard types, such as integers, floating-point
    numbers, character strings, and so on. Should the extraction operator (`<<`) be
    overloaded for a user defined type, such as `Student`, it should also mean to
    print to standard output. In this fashion, operator `<<` is polymorphic when used
    in the context of an output buffer, such as `cout`; that is, it has the same meaning
    but different implementation for all types.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that when overloading an operator in C++, we may not
    change the predefined precedence of the operators as they occur in the language.
    This makes sense – we are not rewriting the compiler to parse and interpret expressions
    differently. We are merely extending the meaning of an operator from its usage
    with standard types to include usage with user defined types. Operator precedence
    will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: An `operator`, followed by the symbol representing the operator which you wish
    to overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the simple syntax of an operator function prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we intend to provide a means to add a floating-point number and a `Student`
    instance using the C++ addition operator (`+`). The meaning of this addition might
    be to average the new floating-point number with the student’s existing grade
    point average. Here, the name of the operator function is `operator+()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the aforementioned prototype, the operator function is not a member function
    of any class. The left expected operand will be a `float` and the right operand
    will be a `Student`. The return type of the function (`Student &`) allows us to
    cascade the use of `+` with multiple operands or be paired with multiple operators,
    such as `s1 = 3.45 + s2;`. The overall concept is that we can define how to use
    `+` with multiple types, provided at least one operand is a user defined type.
  prefs: []
  type: TYPE_NORMAL
- en: There’s actually a lot more involved than the simple syntax shown in the previous
    prototype. Before we fully examine a detailed example, let’s first take a look
    at more logistics relating to implementing operator functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing operator functions and knowing when friends might be necessary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **operator function**, the mechanism to overload an operator, may be implemented
    as a member function or as a regular, external function. Let’s summarize the mechanics
    of implementing operator functions with the following key points:'
  prefs: []
  type: TYPE_NORMAL
- en: Operator functions that are implemented as member functions will receive an
    implicit argument (the `this` pointer), plus, at most, one explicit argument.
    If the left operand in the overloaded operation is a user defined type in which
    modifications to the class can easily be made, implementing the operator function
    as a member function is reasonable and preferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator functions that are implemented as external functions will receive one
    or two explicit arguments. If the left operand in the overloaded operation is
    a standard type or a class type that is not modifiable, then an external (non-member)
    function must be used to overload this operator. This external function may need
    to be a `friend` of any object type that is used as the right-hand function argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator functions should most often be implemented reciprocally. That is, when
    overloading a binary operator, ensure that it has been defined to work no matter
    what order the data types (should they differ) appear in the operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at a full program example to illustrate the mechanics of
    operator overloading, including member and non-member functions, as well as scenarios
    requiring the usage of friends. Though some well-known portions of the program
    have been excluded to save space, the full program example can be found online
    in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s begin our code examination by first looking at the preceding class definition
    for `Person`. In addition to the class elements that we are accustomed to seeing,
    we have four operator functions prototyped: `operator=()`, `operator==()`, and
    `operator+()` (which is implemented twice so that the operands to `+` can be reversed).'
  prefs: []
  type: TYPE_NORMAL
- en: Functions for `operator=()`, `operator==()`, and one version of `operator+()`
    will be implemented as member functions of this class, whereas the other `operator+()`,
    with `const char *` and `Person` parameters, will be implemented as a non-member
    function and will additionally necessitate the use of a friend function.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the assignment operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s move forward to examine the applicable operator function definitions
    for this class, starting by overloading the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let us now review the overloaded assignment operator in the preceding code.
    It is designated by the member function `Person &Person::operator=(const Person
    &p);`. Here, we will be assigning memory from a source object, which will be input
    parameter `p`, to a destination object, which will be pointed to by `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Our first order of business will be to ensure that we are not assigning an object
    to itself. Should this be the case, there is no work to be done! We make this
    check by testing `if (this != &p)` to see whether both addresses point to the
    same object. If we’re not assigning an object to itself, we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Next, within the conditional statement (`if`), we first deallocate the existing
    memory for the dynamically allocated data members pointed to by `this`. After
    all, the object on the left-hand of the assignment pre-exists and undoubtedly
    has allocations for these data members.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we notice that the core piece of code within the conditional statement
    looks very similar to that of the copy constructor. That is, we carefully allocate
    space for pointer data members to match the sizes needed from their corresponding
    data members of input parameter `p`. We then copy the applicable data members
    from input parameter `p` to the data members pointed to by `this`. For the `char`
    data member, `middleInitial`, a memory allocation is not necessary; we merely
    use an assignment. This is also true for the `string` data members, `firstName`
    and `lastName`. In this segment of code, we ensure that we have performed a deep
    assignment for any pointer data members. A shallow (pointer) assignment, where
    the source and destination object would otherwise share memory for the data portions
    of data members that are pointers, would be a disaster waiting to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, at the end of our implementation of `operator=()`, we return `*this`.
    Notice that the return type from this function is a reference to a `Person`. Since
    `this` is a pointer, we merely dereference it so that we may return a referenceable
    object. This is done so that assignments between `Person` instances can be cascaded;
    that is, `p1 = p2 = p3;` where `p1`, `p2`, and `p3` are each an instance of `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When overloading `operator=`, always check for self-assignment. That is, make
    sure you are not assigning an object to itself. Not only is there no work to be
    done in the case of self-assignment, but proceeding with an unnecessary self-assignment
    can actually create unexpected errors! For example, if we have dynamically allocated
    data members, we will be releasing destination object memory and re-allocating
    those data members based on the details of the source object’s memory (which,
    when being the same object, will have been released). The resulting behavior can
    be unpredictable and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should the programmer wish to disallow assignment between two objects, the
    keyword `delete` can be used in the prototype of the overloaded assignment operator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is useful to remember that an overloaded assignment operator shares many
    similarities with the copy constructor; the same care and cautions apply to both
    language features. Keep in mind, however, that the assignment operator will be
    invoked when conducting an assignment between two pre-existing objects, whereas
    the copy constructor is implicitly invoked for initialization following the creation
    of a new instance. With the copy constructor, the new instance uses the existing
    instance as its basis for initialization; similarly, the left-hand object of the
    assignment operator uses the right-hand object as its basis for the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: An overloaded assignment operator is not inherited by derived classes; therefore,
    it must be defined by each class in the hierarchy. Neglecting to overload `operator=`
    for a class will force the compiler to provide you with a default, shallow assignment
    operator for that class; this is dangerous for any classes containing data members
    that are pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the comparison operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at our implementation of the overloaded comparison
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with a segment from our previous program, we overload the comparison
    operator. It is designated by the member function `int Person::operator==(const
    Person &p);`. Here, we will be comparing a `Person` object on the right-hand side
    of the operator, which will be referenced by input parameter `p`, to a `Person`
    object on the left-hand side of the operator, which will be pointed to by `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, our first order of business will be to test whether the object on
    the `if (this != &p)` to see whether both addresses point to the same object.
    If both addresses point to the same object, we return the boolean (`bool`) value
    of `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the two `Person` objects contain identical values. They
    may be separate objects in memory, yet if they contain identical values, we can
    likewise choose to return a `bool` value of `true`. If there is no match, we then
    return a `bool` value of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the addition operator as a member function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at how to overload `operator+` for `Person` and a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Moving forward with the preceding program, we overload the addition operator
    (`+`) to be used with a `Person` and a `string`. The operator function is designated
    by the member function prototype `Person& Person::operator+(const string &t);`.
    The parameter, `t`, will represent the right operand of `operator+`, which is
    a character string (which will bind to a reference to a string). The left-hand
    operand will be pointed to by `this`. An example use would be `p1 + "Miss"`, where
    we wish to add a `title` to the `Person` `p1` using `operator+`.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of this member function, we merely use the input parameter `t` as
    an argument to `ModifyTitle()`, that is, `ModifyTitle(t);`. We then return `*this`
    so that we may cascade the use of this operator (notice the return type is a `Person
    &`).
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the addition operator as a non-member function (using friends)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s reverse the order of operands with `operator+` to allow for a `string`
    and a `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Continuing forward with the preceding program, we would ideally like `operator+`
    to work not only with a `Person` and a `string` but also with the operands reversed,
    that is, with a `string` and a `Person`. There is no reason this operator should
    work one way and not the other.
  prefs: []
  type: TYPE_NORMAL
- en: To implement `operator+` fully, we next overload `operator+()` to be used with
    `const string &` and `Person`. The operator function is designated by the non-member
    function `Person& operator+(const string &t, Person &p);`, which has two explicit
    input parameters. The first parameter, `t`, will represent the left operand of
    `operator+`, which is a character string (binding this parameter to a reference
    to a string as the first formal parameter in the operator function). The second
    parameter, `p`, will be a reference to the right operand used in `operator+`.
    An example use might be `"Miss" + p1`, where we wish to add a title to the `Person
    p1` using `operator+`. Note that `"Miss"` will be constructed as a `string` using
    the `std::string(const char *)` constructor—the string literal is simply the initial
    value for the string object.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of this non-member function, we merely take input parameter `p`
    and apply the protected method `ModifyTitle()` using the string of characters
    specified by parameter `t`, that is, `p.ModifyTitle(t)`. However, because `Person::ModifyTitle()`
    is protected, `Person &p` may not invoke this method outside of member functions
    of `Person`. We are in an external function; we are not in the scope of `Person`.
    Therefore, unless this member function is a `friend` of `Person`, `p` may not
    invoke `ModifyTitle()`. Luckily, `Person &operator+(const string &, Person &);`
    has been prototyped as a friend function in the `Person` class, providing the
    necessary scope to `p` to allow it to invoke its protected method. It is as if
    `p` is in the scope of `Person`; it is in the scope of a friend function of `Person`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now move forward to our `main()` function, tying together our many aforementioned
    code segments, so we may see how to invoke our operator functions utilizing our
    overloaded operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let us examine our `main()` function for the preceding program. We
    begin by instantiating three instances of `Person`, namely `p1`, `p2`, and `p3`;
    we then print their values using member function `Print()` for each instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we invoke our overloaded assignment operator with the statement `p1 =
    p2;`. Under the hood, this translates to the following operator function invocation:
    `p1.operator=(p2);`. From this, we can clearly see that we are invoking the previously
    defined `operator=()` method of `Person`, which performs a deep copy from source
    object `p2` to destination object `p1`. We apply `p1.Print();` to see our resulting
    copy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we invoke our overloaded `operator+` with `"Ms." + p2`. This portion
    of this line of code translates to the following operator function call: `operator+("Ms.",
    p2);`. Here, we simply invoke our previously described `operator+()` function,
    which is a non-member function and `friend` of the `Person` class. Because this
    function returns a `Person &`, we can cascade this function call to look more
    like the usual context of addition and additionally write `p2 = "Ms." + p2;`.
    In this full line of code, first, `operator+()` is invoked for `"Ms." + p2`. The
    return value of this invocation is `p2`, which is then used as the right-hand
    operand of the cascaded call to `operator=`. Notice that the left-hand operand
    to `operator=` also happens to be `p2`. Fortunately, the overloaded assignment
    operator checks for self-assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we see a cascaded assignment of `p1 = p2 = p3;`. Here, we are invoking
    the overloaded assignment operator twice. First, we invoke `operator=` with `p2`
    and `p3`. The translated call would be `p2.operator=(p3);`. Then, using the return
    value of the first function call, we would invoke `operator=` a second time. The
    nested, translated call for `p1 = p2 = p3;` would look like this: `p1.operator=(p2.operator=(p3));`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly in this program, we invoke the overloaded comparison operator twice.
    For example, each comparison of `if (p2 == p2)` or `if (p1 == p3)` merely calls
    the `operator==` member function we have defined previously. Recall that we’ve
    written this function to report `true` either if the objects are the same in memory
    or simply contain the same values, and return `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen how to specify and utilize friend classes and friend functions,
    how to overload C++ operators, and have seen cases when these two concepts can
    complement each other. Let us now briefly recap the features we have learned in
    this chapter before moving forward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our C++ programming endeavors beyond OOP
    language features to include features that will enable us to write more extensible
    programs. We have learned how to utilize friend functions and friend classes and
    we have learned how to overload operators in C++.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that friend functions and classes should be used sparingly and
    with caution. They are not meant to provide a blatant means to circumvent access
    regions. Instead, they are meant to handle programming situations to allow access
    between two tightly coupled classes without providing the alternative of an *overly
    public* interface in either of those classes, which could be misused on a broader
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to overload operators in C++ using operator functions, both
    as member and non-member functions. We have learned that overloading operators
    will allow us to extend the meaning of C++ operators to include user defined types
    in the same way they encompass standard types. We have also seen that, in some
    cases, friend functions or classes may come in handy to help implement operator
    functions so they may behave associatively.
  prefs: []
  type: TYPE_NORMAL
- en: We have added important features to our C++ repertoire through exploring friends
    and operator overloading, the latter of which will help us to ensure code we will
    soon write using templates can be used for nearly any data type, contributing
    to highly extensible and reusable code. We are now ready to move forward to [*Chapter
    13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*, so that we can
    continue expanding our C++ programming skills with essential language features
    that will make us better programmers. Let’s move ahead!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overload `operator=` in your `Shape` exercise from [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*, or alternatively, overload `operator=` in your ongoing
    `LifeForm`/`Person`/`Student` classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define `operator=` in `Shape` (or `LifeForm`) and override this method in all
    of its derived classes. Hint: the derived implementation of `operator=()` will
    do more work than its ancestor, yet could call its ancestor’s implementation to
    perform the base class part of the work.'
  prefs: []
  type: TYPE_NORMAL
- en: Overload `operator<<` in your `Shape` class (or `LifeForm` class) to print information
    about each `Shape` (or `LifeForm`). The arguments to this function should be an
    `ostream &` and a `Shape &` (or a `LifeForm &`). Note that `ostream` is from the
    C++ Standard Library (`using namespace std;`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may either provide one function, `ostream &operator<<(ostream &, Shape &);`,
    and from it call a polymorphic `Print()`, which is defined in `Shape` and redefined
    in each derived class. Or, provide multiple `operator<<` methods to implement
    this functionality (one for each derived class). If using the `Lifeform` hierarchy,
    substitute `LifeForm` for `Shape`, in the aforementioned `operator<<` function
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `ArrayInt` class to provide safe integer arrays with bounds checking.
    Overload `operator[]` to return an element if it exists in the array, or throw
    an exception if it is `OutOfBounds`. Add other methods to `ArrayInt`, such as
    `Resize()`, `RemoveElement()`, and so on. Model the data comprising the array
    using a dynamically allocated array (that is, using `int *contents`) so that you
    can easily handle resizing. The code would begin as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
