<html><head></head><body>
<div id="_idContainer021">
<h1 class="chapter-number" id="_idParaDest-261"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-262"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.2.1">Modern Approach to Managing Third Parties</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In modern software development, the reliance on third-party libraries is virtually inescapable. </span><span class="koboSpan" id="kobo.3.2">From foundational components such as OpenSSL for secure communication, and Boost for extensive C++ libraries, to even the standard library that forms the bedrock of C++ programming, external libraries are integral to building functional and efficient applications. </span><span class="koboSpan" id="kobo.3.3">This dependency underscores the importance of understanding how third-party libraries are managed within the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">C++ ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Given the complexity and diversity of these libraries, it’s crucial for developers to grasp the basics of third-party library management. </span><span class="koboSpan" id="kobo.5.2">This knowledge not only aids in the seamless integration of these libraries into projects but also influences deployment strategies. </span><span class="koboSpan" id="kobo.5.3">The compilation method of a library, whether static or dynamic, directly impacts the number of files deployed and the overall footprint of </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Unlike some other programming languages that benefit from a standardized library ecosystem, C++ presents a unique challenge due to the absence of such a unified system. </span><span class="koboSpan" id="kobo.7.2">This chapter delves into the existing solutions for third-party library management in C++, exploring tools such as vcpkg, Conan, and others. </span><span class="koboSpan" id="kobo.7.3">By examining these tools, we aim to provide insights into which solution might best fit your project’s needs, considering factors such as platform compatibility, ease of use, and the scope of the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">library catalog.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">As we navigate through these solutions, our goal is to equip you with the knowledge to make informed decisions about integrating and managing third-party libraries in your C++ projects, thereby enhancing your development workflow and the quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">your software.</span></span></p>
<h1 id="_idParaDest-263"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.11.1">Overview of linking and shared V threads::ThreadsS static libraries</span></h1>
<p><span class="koboSpan" id="kobo.12.1">In the context of C and C++ development, third-party entities are external libraries or frameworks that developers integrate into their projects. </span><span class="koboSpan" id="kobo.12.2">These entities serve to improve functionality or utilize existing solutions. </span><span class="koboSpan" id="kobo.12.3">These third-party components can vary significantly in scope, from minimal utility libraries to comprehensive frameworks offering a broad range </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">of features.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">The </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.15.1">process of integrating third-party libraries into a project involves using header files that outline the interfaces of these libraries. </span><span class="koboSpan" id="kobo.15.2">These header files contain the declarations of classes, functions, and variables provided by the library, allowing the compiler to understand the required signatures and structures for successful compilation. </span><span class="koboSpan" id="kobo.15.3">Including a header file in a C++ source file essentially concatenates the contents of the header file to the point of inclusion, enabling access to the library’s interfaces without embedding the actual implementation within the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">The implementation of these libraries is supplied through compiled object code, typically distributed as either static libraries or shared libraries. </span><span class="koboSpan" id="kobo.17.2">Static libraries are archives of object files that are directly incorporated into the final executable by the linker, resulting in a larger executable size due to the embedding of the library code. </span><span class="koboSpan" id="kobo.17.3">On the other hand, shared libraries, known</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.18.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">Dynamic Link Libraries (DLLs)</span></strong><span class="koboSpan" id="kobo.20.1"> on Windows or </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Shared Objects (SOs)</span></strong><span class="koboSpan" id="kobo.22.1"> on Unix-like systems, are not embedded into the </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.23.1">executable. </span><span class="koboSpan" id="kobo.23.2">Instead, references to these libraries are included, and the operating system loads them into memory at runtime. </span><span class="koboSpan" id="kobo.23.3">This mechanism allows multiple applications to utilize the same library code, </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">conserving memory.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Shared libraries </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.26.1">were designed to facilitate the sharing of common libraries, such as libc or C++ standard libraries, among multiple applications. </span><span class="koboSpan" id="kobo.26.2">This practice is especially advantageous for frequently utilized libraries. </span><span class="koboSpan" id="kobo.26.3">This design also theoretically allows users to update shared libraries without needing to upgrade the entire application. </span><span class="koboSpan" id="kobo.26.4">However, in practice, this is not always seamless and can introduce compatibility issues, making it less advantageous for applications to provide their dependencies as shared libraries. </span><span class="koboSpan" id="kobo.26.5">Furthermore, opting for shared libraries over static ones can reduce linker time, as the linker does not need to embed the library code into the executable, which can speed up the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">build process.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The linker plays a pivotal role in this process, merging various object files and libraries into a single executable or library, and resolving symbol references along the way to ensure the final binary is complete </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">and executable.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">The choice between static and dynamic linking significantly affects application performance, size, and deployment strategies. </span><span class="koboSpan" id="kobo.30.2">Static linking simplifies deployment by creating self-contained executables but at the cost of larger file sizes and the necessity to recompile for library updates. </span><span class="koboSpan" id="kobo.30.3">Dynamic linking, while reducing memory usage by sharing library code among </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.31.1">applications and facilitating easier library updates, introduces complexities in deployment to ensure all dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">are met.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Given the complexities associated with linking external shared objects and the widespread use of templated code in C++, many library developers have started to prefer supplying their libraries as “header-only” libraries. </span><span class="koboSpan" id="kobo.33.2">A </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.34.1">header-only library is a library that is entirely contained within header files, with no separate implementation files or precompiled binaries. </span><span class="koboSpan" id="kobo.34.2">This means that all the code, including function and class definitions, is included in the </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">header files.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">This approach simplifies the integration process significantly. </span><span class="koboSpan" id="kobo.36.2">When a developer includes a header file from a header-only library, they are not just including interface declarations but the entire implementation. </span><span class="koboSpan" id="kobo.36.3">Consequently, there is no need for separate compilation or linking of the library’s implementation; the compiler includes and compiles the library’s code directly into the developer’s source code when the header file is included. </span><span class="koboSpan" id="kobo.36.4">This direct inclusion can lead to more efficient inlining and optimizations by the compiler, potentially resulting in faster executable code due to the elimination of function </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">call overheads.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">However, it’s worth noting that while header-only libraries offer convenience and ease of integration, they also have some downsides. </span><span class="koboSpan" id="kobo.38.2">Since the entire library is included and compiled with each source file that includes it, this can lead to increased compilation times, especially for large libraries or projects that include the library in multiple files. </span><span class="koboSpan" id="kobo.38.3">Furthermore, any change in the header file necessitates recompiling all source files that include it, which can further increase </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">development time.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Despite its drawbacks, the header-only approach in C++ is highly attractive to many developers and users due to its simplicity of distribution and use. </span><span class="koboSpan" id="kobo.40.2">Additionally, it helps avoid linking issues and offers benefits for template-heavy libraries. </span><span class="koboSpan" id="kobo.40.3">This model is especially prevalent in libraries where heavy use of templates is made, such as those providing metaprogramming facilities, because templates must be available in their entirety to the compiler at compile time, making the header-only model a </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">natural fit.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">In essence, the management of third-party dependencies in C++ projects involves a deep understanding of header files, static and shared libraries, and the intricacies of the linking process. </span><span class="koboSpan" id="kobo.42.2">Developers must carefully consider the trade-offs between static and dynamic linking in the context of application requirements and deployment environments, balancing factors such as performance, size, and ease </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">of maintenance.</span></span></p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.44.1">Managing third-party libraries in C++</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Managing </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.46.1">third-party libraries is a critical aspect of C++ development. </span><span class="koboSpan" id="kobo.46.2">While there is no standardized package manager for C++, various methods and tools have been adopted to streamline this process, each with its own set of practices and </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">supported platforms.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.48.1">Installing libraries with OS package managers</span></h2>
<p><span class="koboSpan" id="kobo.49.1">Many </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.50.1">developers rely on the operating system’s package manager to install third-party libraries. </span><span class="koboSpan" id="kobo.50.2">On Ubuntu and other Debian-based systems, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">apt</span></strong><span class="koboSpan" id="kobo.52.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">commonly used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.54.1">
sudo apt install libboost-all-dev</span></pre>
<p><span class="koboSpan" id="kobo.55.1">For Red Hat-based systems, </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">yum</span></strong><span class="koboSpan" id="kobo.57.1"> or its successor </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">dnf</span></strong><span class="koboSpan" id="kobo.59.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">go-to option:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
sudo yum install boost-devel</span></pre>
<p><span class="koboSpan" id="kobo.62.1">On macOS, Homebrew is a popular choice for </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">managing packages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
brew install boost</span></pre>
<p><span class="koboSpan" id="kobo.65.1">Windows users often turn to Chocolatey or </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">vcpkg</span></strong><span class="koboSpan" id="kobo.67.1"> (the latter also functions as a general C++ library manager beyond </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">just Windows):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
choco install boost</span></pre>
<p><span class="koboSpan" id="kobo.70.1">These OS package managers are convenient for common libraries but might not always offer the latest version or specific configurations needed </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">for development.</span></span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.72.1">Using Git as a third-party manager via submodules</span></h2>
<p><span class="koboSpan" id="kobo.73.1">Git submodules</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.74.1"> allow developers to include and manage the source code of third-party libraries directly within their repositories. </span><span class="koboSpan" id="kobo.74.2">This method is advantageous for ensuring all team members and the build system use an exact version of a library. </span><span class="koboSpan" id="kobo.74.3">A typical workflow for adding a submodule and integrating it with CMake might look </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
git submodule add https://github.com/google/googletest.git external/googletest
git submodule update --init</span></pre>
<p><span class="koboSpan" id="kobo.77.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">CMakeLists.txt</span></strong><span class="koboSpan" id="kobo.79.1">, you’d include </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the submodule:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.81.1">
add_subdirectory(external/googletest)
include_directories(${gtest_SOURCE_DIR}/include ${gtest_SOURCE_DIR})</span></pre>
<p><span class="koboSpan" id="kobo.82.1">This </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.83.1">method tightly couples your project with specific versions of the library and facilitates tracking updates </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">through Git.</span></span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.85.1">Using CMake FetchContent to download libraries</span></h2>
<p><span class="koboSpan" id="kobo.86.1">CMake’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">FetchContent</span></strong><span class="koboSpan" id="kobo.88.1"> module</span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.89.1"> provides a more</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.90.1"> flexible alternative to submodules by downloading dependencies at configure time, without the need to include them directly in </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">your repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
include(FetchContent)
FetchContent_Declare(
  json
  GIT_REPOSITORY https://github.com/nlohmann/json.git
  GIT_TAG v3.7.3
)
FetchContent_MakeAvailable(json)</span></pre>
<p><span class="koboSpan" id="kobo.93.1">This approach differs from Git submodules by not requiring the library’s source code to be present in your repository or updating it manually. </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">FetchContent</span></strong><span class="koboSpan" id="kobo.95.1"> dynamically retrieves the specified version, making it easier to manage and </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">update dependencies.</span></span></p>
<h1 id="_idParaDest-268"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.97.1">Conan – advanced dependency management</span></h1>
<p><span class="koboSpan" id="kobo.98.1">Conan is a</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.99.1"> powerful package manager for C and C++ that simplifies the process of integrating third-party libraries and managing dependencies across various platforms and configurations. </span><span class="koboSpan" id="kobo.99.2">It</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.100.1"> stands out for its ability to handle multiple versions of libraries, complex dependency graphs, and different build configurations, making it an essential tool for modern </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">C++ development.</span></span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.102.1">Conan configuration and features</span></h2>
<p><span class="koboSpan" id="kobo.103.1">Conan’s </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.104.1">configuration is stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">conanfile.txt</span></strong><span class="koboSpan" id="kobo.106.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">conanfile.py</span></strong><span class="koboSpan" id="kobo.108.1">, where developers specify the required libraries, versions, settings, and options. </span><span class="koboSpan" id="kobo.108.2">This file serves as the manifest for project dependencies, enabling precise control over the libraries </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.109.1">used in </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">a project.</span></span></p>
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.111.1">Key features</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.113.1">Multi-platform support</span></strong><span class="koboSpan" id="kobo.114.1">: Conan is designed to work on Windows, Linux, macOS, and FreeBSD, offering a consistent experience across different </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">operating systems</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.116.1">Build configuration management</span></strong><span class="koboSpan" id="kobo.117.1">: Developers can specify settings such as compiler version, architecture, and build type (debug, release) to ensure compatibility and optimal builds for </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">their projects</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.119.1">Version handling</span></strong><span class="koboSpan" id="kobo.120.1">: Conan can manage multiple versions of the same library, allowing projects to depend on specific versions </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">as needed</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.122.1">Dependency resolution</span></strong><span class="koboSpan" id="kobo.123.1">: It automatically resolves and downloads transitive dependencies, ensuring that all required libraries are available for the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">build process</span></span></li>
</ul>
<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.125.1">Library locations and Conan Center</span></h2>
<p><span class="koboSpan" id="kobo.126.1">The </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.127.1">primary</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.128.1"> repository for Conan packages is </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">Conan Center</span></strong><span class="koboSpan" id="kobo.130.1">, an extensive collection of open source C and C++ libraries. </span><span class="koboSpan" id="kobo.130.2">Conan Center is the go-to place to find and download packages, but developers can also specify custom or private repositories for </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">their projects.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">In addition to</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.133.1"> Conan Center, companies and development teams can host their own Conan servers or use services such as Artifactory to manage private or proprietary packages, enabling a centralized approach to dependency management within </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">an organization.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.135.1">Configuring static or dynamic linking</span></h2>
<p><span class="koboSpan" id="kobo.136.1">Conan </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.137.1">allows developers to specify whether to use static or dynamic linking for libraries. </span><span class="koboSpan" id="kobo.137.2">This is typically done through options in </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">conanfile.txt</span></strong><span class="koboSpan" id="kobo.139.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">conanfile.py</span></strong><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
[options]
Poco:shared=True  # Use dynamic linking for Poco
Or in </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">conanfile.py</span></strong><span class="koboSpan" id="kobo.145.1">:
class MyProject(ConanFile):
    requires = “poco/1.10.1”
    default_options = {“poco:shared”: True}</span></pre>
<p><span class="koboSpan" id="kobo.146.1">These settings instruct Conan to download and use the dynamic version of the specified libraries. </span><span class="koboSpan" id="kobo.146.2">Similarly, setting the option to </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">False</span></strong><span class="koboSpan" id="kobo.148.1"> would favor static libraries. </span><span class="koboSpan" id="kobo.148.2">It’s essential to note that not all packages will support both linking options, depending on how they were packaged </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">for Conan.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.150.1">Extending Conan with custom packages</span></h2>
<p><span class="koboSpan" id="kobo.151.1">One of the </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.152.1">strengths of Conan is its extensible nature. </span><span class="koboSpan" id="kobo.152.2">If a required library is not available in Conan Center or does not meet specific needs, developers can create and contribute their own packages. </span><span class="koboSpan" id="kobo.152.3">Conan provides a Python-based development kit for creating packages, which includes tools for defining build processes, dependencies, and </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">package metadata.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">To create a Conan package, developers define </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">conanfile.py</span></strong><span class="koboSpan" id="kobo.156.1"> that describes how to source, build, and package the library. </span><span class="koboSpan" id="kobo.156.2">This file includes methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">source()</span></strong><span class="koboSpan" id="kobo.158.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">build()</span></strong><span class="koboSpan" id="kobo.160.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">package()</span></strong><span class="koboSpan" id="kobo.162.1"> that Conan executes during the package </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">creation process.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Once a package is developed, it can be shared through Conan Center by submitting it for inclusion, or it can be distributed through private repositories to maintain control over distribution </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">and usage.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Conan’s flexibility, support </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.167.1">for multiple platforms and configurations, and its comprehensive package repository make it an invaluable tool for C++ developers. </span><span class="koboSpan" id="kobo.167.2">By leveraging Conan, teams can streamline their dependency management process, ensuring consistent, reproducible builds across different environments. </span><span class="koboSpan" id="kobo.167.3">The ability to configure static or dynamic linking, coupled with the option to extend the repository with custom packages, underscores Conan’s adaptability to diverse project requirements. </span><span class="koboSpan" id="kobo.167.4">Whether working with widely-used open source libraries or specialized proprietary code, Conan provides a robust framework for managing C++ dependencies efficiently </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">and effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Conan is a dedicated C++ package manager that excels in managing different versions of libraries and their dependencies. </span><span class="koboSpan" id="kobo.169.2">It operates independently of the operating system’s package manager and provides a high level of control and flexibility. </span><span class="koboSpan" id="kobo.169.3">A typical Conan workflow involves creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">conanfile.txt</span></strong><span class="koboSpan" id="kobo.171.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">conanfile.py</span></strong><span class="koboSpan" id="kobo.173.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">declare dependencies.</span></span></p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.175.1">CMake integration</span></h1>
<p><span class="koboSpan" id="kobo.176.1">CMake is </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.177.1">widely used in C++ projects for its powerful scripting capabilities and cross-platform support. </span><span class="koboSpan" id="kobo.177.2">Integrating Conan with CMake can significantly streamline the process of managing dependencies. </span><span class="koboSpan" id="kobo.177.3">Here’s how</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.178.1"> you can achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">this integration:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.180.1">Conan CMake wrapper</span></strong><span class="koboSpan" id="kobo.181.1">: Conan provides a CMake wrapper script that automates the</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.182.1"> integration. </span><span class="koboSpan" id="kobo.182.2">To use it, include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">conanbuildinfo.cmake</span></strong><span class="koboSpan" id="kobo.184.1"> file generated by Conan in your </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">project’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">CMakeLists.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.188.1">
include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.189.1">
conan_basic_setup(TARGETS)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.190.1">This script sets up the necessary </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">include</span></strong><span class="koboSpan" id="kobo.192.1"> paths and library paths, and defines the dependencies managed by Conan, making them available to your </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">CMake project.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">Using targets</span></strong><span class="koboSpan" id="kobo.195.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">TARGETS</span></strong><span class="koboSpan" id="kobo.197.1"> option in </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">conan_basic_setup()</span></strong><span class="koboSpan" id="kobo.199.1"> generates CMake targets for your Conan dependencies, allowing you to link against them using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">target_link_libraries()</span></strong><span class="koboSpan" id="kobo.201.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">in CMake:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
target_link_libraries(my_project_target CONAN_PKG::poco)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.204.1">This approach</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.205.1"> provides a clean and explicit way to link your project’s targets against the libraries managed </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">by Conan.</span></span></p></li>
</ul>
<h2 id="_idParaDest-274"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.207.1">Other build system integration</span></h2>
<p><span class="koboSpan" id="kobo.208.1">Conan’s flexibility </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.209.1">extends to other build systems as well, making it adaptable to various </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">project requirements:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.211.1">Makefiles</span></strong><span class="koboSpan" id="kobo.212.1">: For </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.213.1">projects using Makefiles, Conan can generate the appropriate variables for </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">include</span></strong><span class="koboSpan" id="kobo.215.1"> paths, library paths, and flags that can be included in </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">a Makefile:</span></span><pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.217.1">include conanbuildinfo.mak</span></strong></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.218.1">MSBuild</span></strong><span class="koboSpan" id="kobo.219.1">: For</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.220.1"> projects using MSBuild (common in Windows environments), Conan can generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">.props</span></strong><span class="koboSpan" id="kobo.222.1"> files that can be imported into Visual Studio projects, providing a seamless integration with the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">MSBuild ecosystem.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.224.1">Bazel, Meson, and others</span></strong><span class="koboSpan" id="kobo.225.1">: While </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.226.1">direct support for some build systems such as Bazel or </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.227.1">Meson might require custom integration scripts or tools, the Conan community often contributes generators and tools to bridge these gaps, extending Conan’s reach to virtually any </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">build system.</span></span></li>
</ul>
<h2 id="_idParaDest-275"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.229.1">Custom integration</span></h2>
<p><span class="koboSpan" id="kobo.230.1">For </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.231.1">build systems without direct support or for projects with unique requirements, Conan offers the ability to customize the generated files or even write custom generators. </span><span class="koboSpan" id="kobo.231.2">This allows developers to tailor the integration to their specific build</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.232.1"> process, making Conan a highly adaptable tool for </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">dependency management.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.234.1">Conclusion</span></h2>
<p><span class="koboSpan" id="kobo.235.1">The integration of Conan with CMake and other build systems underscores its versatility as a package manager for C++ projects. </span><span class="koboSpan" id="kobo.235.2">By providing straightforward mechanisms to incorporate dependencies into various build environments, Conan not only simplifies dependency management but also enhances build reproducibility and consistency across different platforms and configurations. </span><span class="koboSpan" id="kobo.235.3">Whether you’re working with a widely used build system such as CMake or a more specialized setup, Conan’s flexible integration options ensure that you can maintain an efficient and streamlined </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">development workflow.</span></span></p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.237.1">vcpkg</span></h1>
<p><span class="koboSpan" id="kobo.238.1">vcpkg, developed</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.239.1"> by Microsoft, is a cross-platform C++ package manager that simplifies the process of acquiring and building C++ open source libraries. </span><span class="koboSpan" id="kobo.239.2">It is designed to work seamlessly with CMake and other build systems, providing a straightforward and consistent way to manage C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">library dependencies.</span></span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.241.1">Key differences from Conan</span></h2>
<p><span class="koboSpan" id="kobo.242.1">While both </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.243.1">vcpkg and Conan are aimed at simplifying dependency management in C++ projects, there are notable differences in their approach </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">and ecosystem:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.245.1">Origin and backing</span></strong><span class="koboSpan" id="kobo.246.1">: vcpkg was created and is maintained by Microsoft, which ensures tight integration with Visual Studio and the MSBuild system, although it remains fully functional and useful across different platforms and </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">development environments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.248.1">Package sources</span></strong><span class="koboSpan" id="kobo.249.1">: vcpkg focuses on compiling from source, ensuring that libraries are built with the same compiler and settings as the consuming project. </span><span class="koboSpan" id="kobo.249.2">This approach contrasts with Conan, which can manage precompiled binaries, allowing for quicker integration but potentially leading to binary </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">incompatibility issues.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.251.1">Integration</span></strong><span class="koboSpan" id="kobo.252.1">: vcpkg </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.253.1">integrates natively with CMake and Visual Studio, providing manifest files for project-level integration. </span><span class="koboSpan" id="kobo.253.2">This can make it particularly attractive for projects already using these tools, offering a more seamless </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">integration experience.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.255.1">Ecosystem and libraries</span></strong><span class="koboSpan" id="kobo.256.1">: Both package managers boast a large collection of available libraries, but their ecosystems might differ slightly due to the community and backing of </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">each project.</span></span></li>
</ul>
<h2 id="_idParaDest-279"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.258.1">Operating system support</span></h2>
<p><span class="koboSpan" id="kobo.259.1">vcpkg is designed</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.260.1"> to be cross-platform, with support for </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.262.1">Windows</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.263.1">Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.264.1">macOS</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.265.1">This wide range of support makes it a versatile option for developers working in diverse </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">development environments.</span></span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.267.1">Example of configuring a project with vcpkg</span></h2>
<p><span class="koboSpan" id="kobo.268.1">To</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.269.1"> illustrate the use of vcpkg in a project, let’s go through a simple example of integrating a library, such as the JSON for Modern C++ library (</span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">nlohmann-json</span></strong><span class="koboSpan" id="kobo.271.1">), into a C++ project </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">using CMake.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Clone the vcpkg repository and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">bootstrap script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh  # Use bootstrap-vcpkg.bat on Windows
Install </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">nlohmann-json</span></strong><span class="koboSpan" id="kobo.277.1"> using vcpkg:
./vcpkg install nlohmann-json</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">vcpkg</span></strong><span class="koboSpan" id="kobo.279.1"> will download and compile the library, making it available </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">for projects.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">To use vcpkg</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.282.1"> with a CMake project, you can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">CMAKE_TOOLCHAIN_FILE</span></strong><span class="koboSpan" id="kobo.284.1"> variable to the path of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">vcpkg.cmake</span></strong><span class="koboSpan" id="kobo.286.1"> toolchain file when configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">your project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
cmake -B build -S . </span><span class="koboSpan" id="kobo.288.2">-DCMAKE_TOOLCHAIN_FILE=[vcpkg root]/scripts/buildsystems/vcpkg.cmake
Replace [vcpkg root] with the path to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">vcpkg</span></strong><span class="koboSpan" id="kobo.290.1"> installation.
</span><span class="koboSpan" id="kobo.290.2">In your CMakeLists.txt, find and link against the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">nlohmann-json</span></strong><span class="koboSpan" id="kobo.292.1"> package:
cmake_minimum_required(VERSION 3.0)
project(MyVcpkgProject)
find_package(nlohmann_json CONFIG REQUIRED)
add_executable(my_app main.cpp)
target_link_libraries(my_app PRIVATE nlohmann_json::nlohmann_json)
In your main.cpp, you can now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">nlohmann-json</span></strong><span class="koboSpan" id="kobo.294.1"> library:
#include &lt;nlohmann/json.hpp&gt;
int main() {
    nlohmann::json j;
    j[“message”] = “Hello, world!”;
    std::cout &lt;&lt; j &lt;&lt; std::endl;
    return 0;
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">vcpkg</span></strong><span class="koboSpan" id="kobo.296.1">, with its emphasis on source-based distribution and integration with CMake and Visual Studio, offers a robust solution for C++ developers looking to manage library dependencies effectively. </span><span class="koboSpan" id="kobo.296.2">Its</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.297.1"> simplicity, coupled with the backing of Microsoft, makes it a compelling choice for projects that prioritize consistency with the build environment and seamless integration with existing Microsoft tools. </span><span class="koboSpan" id="kobo.297.2">While it shares common goals with Conan in simplifying dependency management, the choice between vcpkg and Conan may come down to specific project requirements, preferred workflow, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">development ecosystem.</span></span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.299.1">Utilizing Docker for C++ builds</span></h2>
<p><span class="koboSpan" id="kobo.300.1">A </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.301.1">notable shortfall within C++ is its absence of an inherent mechanism for managing dependencies. </span><span class="koboSpan" id="kobo.301.2">Consequently, the incorporation of third-party elements is achieved through a heterogeneous array of methodologies: the utilization of package managers provided by Linux distributions (for instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">apt-get</span></strong><span class="koboSpan" id="kobo.303.1">), the direct installation via </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">make install</span></strong><span class="koboSpan" id="kobo.305.1">, the inclusion of third-party libraries as Git submodules and their subsequent compilation within the project’s source tree, or the adoption of package management solutions such as Conan </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">or Vcpkgvcpkg.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Regrettably, each of these methods comes with its own set </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">of drawbacks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.309.1">The installation of dependencies directly on a development machine tends to compromise the cleanliness of the environment, rendering it dissimilar to those of CI/CD pipelines or production environments – a discrepancy that becomes more pronounced with each update of </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">third-party components.</span></span></li>
<li><span class="koboSpan" id="kobo.311.1">It is often a formidable task to ensure uniformity in the versions of compilers, debuggers, and other tools utilized by all developers. </span><span class="koboSpan" id="kobo.311.2">This lack of standardization can culminate in a scenario where a build executes successfully on an individual developer’s machine yet fails within the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">CI/CD environment.</span></span></li>
<li><span class="koboSpan" id="kobo.313.1">The practice of integrating third-party libraries as Git submodules and compiling them within the project’s source directory poses a challenge, particularly when dealing with substantial libraries (such as Boost, Protobuf, Thrift, etc.). </span><span class="koboSpan" id="kobo.313.2">This method can lead to a significant deceleration of the build process, to the extent that developers may hesitate to clear the build directory or to alternate </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">between branches.</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">Package </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.316.1">management solutions such as Conan may not always offer the desired version of a specific dependency, and the inclusion of such a version necessitates the authoring of additional code in Python, which, in my opinion, is </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">unduly burdensome.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.318.1">A single isolated and reproducible build environment</span></h3>
<p><span class="koboSpan" id="kobo.319.1">The </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.320.1">optimal resolution for the aforementioned challenges involves the formulation of a Docker image, embedded with all requisite dependencies and tools, such as compilers and debuggers, to facilitate the project’s compilation within a container derived from </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">this image.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">This particular image serves as the cornerstone for a </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">singular</span></strong><span class="koboSpan" id="kobo.324.1"> build environment that is uniformly employed by developers on their respective workstations as well as on CI/CD servers, effectively eliminating the all-too-common discrepancy of “it works on my machine but fails </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">at CI!”.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Owing to the encapsulated nature of the build process within the container, it remains impervious to any external variables, tools, or configurations peculiar to an individual developer’s local setup, thereby rendering the build </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">environment </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.328.1">isolated</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">In an ideal scenario, Docker images are meticulously labeled with meaningful version identifiers, enabling users to seamlessly transition between different environments by retrieving the appropriate image from the registry. </span><span class="koboSpan" id="kobo.330.2">Furthermore, in the event that an image is no longer available in the registry, it’s worth noting that Docker images are constructed from Dockerfiles, which are typically maintained within Git repositories. </span><span class="koboSpan" id="kobo.330.3">This ensures that, should the need arise, there is always the feasibility to reconstruct the image from a previous version of the Dockerfile. </span><span class="koboSpan" id="kobo.330.4">This attribute of the Dockerized build framework lends it a characteristic of </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">being </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.332.1">reproducible</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.334.1">Creating the build image</span></h3>
<p><span class="koboSpan" id="kobo.335.1">We will embark on developing a straightforward application and compile it within a container. </span><span class="koboSpan" id="kobo.335.2">The</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.336.1"> essence of the application is to display its size utilizing </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">boost::filesystem</span></strong><span class="koboSpan" id="kobo.338.1">. </span><span class="koboSpan" id="kobo.338.2">The selection of Boost for this demonstration is intentional, aiming to illustrate the integration of Docker with a “heavy” </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">third-party library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
#include &lt;boost/filesystem/operations.hpp&gt;
#include &lt;iostream&gt;
int main(int argc, char *argv[]) {
    std::cout &lt;&lt; “The path to the binary is: “
              &lt;&lt; boost::filesystem::absolute(argv[0])
              &lt;&lt; “, the size is:” &lt;&lt; boost::filesystem::file_size(argv[0]) &lt;&lt; ‘\n’;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.341.1">The CMake file is </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">quite simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
cmake_minimum_required(VERSION 3.10.2)
project(a.out)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
# Remove for compiler-specific features
set(CMAKE_CXX_EXTENSIONS OFF)
string(APPEND CMAKE_CXX_FLAGS “ -Wall”)
string(APPEND CMAKE_CXX_FLAGS “ -Wbuiltin-macro-redefined”)
string(APPEND CMAKE_CXX_FLAGS “ -pedantic”)
string(APPEND CMAKE_CXX_FLAGS “ -Werror”)
# clangd completion
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
include_directories(${CMAKE_SOURCE_DIR})
file(GLOB SOURCES “${CMAKE_SOURCE_DIR}/*.cpp”)
add_executable(${PROJECT_NAME} ${SOURCES})
set(Boost_USE_STATIC_LIBS        ON) # only find static libs
set(Boost_USE_MULTITHREADED      ON)
set(Boost_USE_STATIC_RUNTIME    OFF) # do not look for boost libraries linked against static C++ std lib
find_package(Boost REQUIRED COMPONENTS filesystem)
target_link_libraries(${PROJECT_NAME}
    Boost::filesystem
)</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.344.1">Note </span></p>
<p class="callout"><span class="koboSpan" id="kobo.345.1">In this example, Boost is linked statically since it is required if the target machine does not have the right version of Boost pre-installed; this recommendation applies to all dependencies pre-installed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">Docker image.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">The </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.348.1">Dockerfile employed for this task is </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">notably uncomplicated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
FROM ubuntu:18.04
LABEL Description=”Build environment”
ENV HOME /root
SHELL [“/bin/bash”, “-c”]
RUN apt-get update &amp;&amp; apt-get -y --no-install-recommends install \
    build-essential \
    clang \
    cmake \
    gdb \
    wget
# Let us add some heavy dependency
RUN cd ${HOME} &amp;&amp; \
    wget --no-check-certificate --quiet \
        https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.gz &amp;&amp; \
        tar xzf ./boost_1_77_0.tar.gz &amp;&amp; \
        cd ./boost_1_77_0 &amp;&amp; \
        ./bootstrap.sh &amp;&amp; \
        ./b2 install &amp;&amp; \
        cd .. </span><span class="koboSpan" id="kobo.350.2">&amp;&amp; \
</span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">        rm -rf ./boost_1_77_0</span></strong></pre>
<p><span class="koboSpan" id="kobo.352.1">To</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.353.1"> ensure that its name is distinctive and does not overlap with existing Dockerfiles, while also clearly conveying its purpose, I have named </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">DockerfileBuildEnv</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
$ docker build -t example/example_build:0.1 -f DockerfileBuildEnv .
</span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Here is supposed to be a long output of boost build</span></strong></pre>
<p><span class="koboSpan" id="kobo.359.1">*Note that the version is not the “latest” but has a meaningful name (</span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">e.g., 0.1).</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">Once the image has been successfully constructed, we are positioned to proceed with the project’s build process. </span><span class="koboSpan" id="kobo.361.2">The initial step involves initiating a Docker container that is based on our crafted image, followed by the execution of the Bash shell within </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">this container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
$ cd project
$ docker run -it --rm --name=example \
 --mount type=bind,source=${PWD},target=/src \
 example/example_build:0.1 \
</span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1"> bash</span></strong></pre>
<p><span class="koboSpan" id="kobo.365.1">The parameter of particular importance in this context is </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">mount type=bind,source=$</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">
{PWD},target=/src</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">This directive instructs Docker to bind mount the current directory, which houses the source code, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">/src</span></strong><span class="koboSpan" id="kobo.371.1"> directory within the container. </span><span class="koboSpan" id="kobo.371.2">This approach circumvents the need to copy source files into the container. </span><span class="koboSpan" id="kobo.371.3">Moreover, as will be demonstrated subsequently, it enables the storage of output binaries directly on the host’s file system, thereby eliminating the need for redundant copying. </span><span class="koboSpan" id="kobo.371.4">For an understanding of the remaining flags and options, it is advisable to consult the official </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">Docker documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Within the </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.374.1">container, we will proceed to compile </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">the project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
root@3abec58c9774:/# cd src
root@3abec58c9774:/src# mkdir build &amp;&amp; cd build
root@3abec58c9774:/src/build# cmake ..
</span><span class="koboSpan" id="kobo.376.2">-- The C compiler identification is GNU 7.5.0
-- The CXX compiler identification is GNU 7.5.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Boost  found.
</span><span class="koboSpan" id="kobo.376.3">-- Found Boost components:
   filesystem
-- Configuring done
-- Generating done
-- Build files have been written to: /src/build
root@3abec58c9774:/src/build# make
Scanning dependencies of target a.out
[ 50%] Building CXX object CMakeFiles/a.out.dir/main.cpp.o
[100%] Linking CXX executable a.out
</span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">[100%] Built target a.out</span></strong></pre>
<p><span class="koboSpan" id="kobo.378.1">Et voilà, the</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.379.1"> project was </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">built successfully!</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">The resulting binary runs successfully, both in the container and on the host, because Boost is </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">linked </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.383.1">statically</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
$ build/a.out
The size of “/home/dima/dockerized_cpp_build_example/build/a.out” is 177320</span></pre>
<h3><span class="koboSpan" id="kobo.386.1">Making the environment usable</span></h3>
<p><span class="koboSpan" id="kobo.387.1">At this</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.388.1"> juncture, it’s reasonable to feel overwhelmed by the multitude of Docker commands and wonder how one is expected to memorize them all. </span><span class="koboSpan" id="kobo.388.2">It’s important to emphasize that developers are not expected to retain every detail of these commands for project-building purposes. </span><span class="koboSpan" id="kobo.388.3">To streamline this process, I propose encapsulating the Docker commands within a tool that is widely familiar to most developers – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">make</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">To facilitate this, I have established a GitHub repository (</span><a href="https://github.com/f-squirrel/dockerized_cpp"><span class="koboSpan" id="kobo.392.1">https://github.com/f-squirrel/dockerized_cpp</span></a><span class="koboSpan" id="kobo.393.1">) that contains a versatile Makefile. </span><span class="koboSpan" id="kobo.393.2">This Makefile is designed to be easily adaptable and can typically be employed for nearly any project that utilizes CMake without necessitating modifications. </span><span class="koboSpan" id="kobo.393.3">Users have the option to either directly download it from this repository or integrate it into their project as a Git submodule, ensuring access to the most recent updates. </span><span class="koboSpan" id="kobo.393.4">I advocate for the latter approach and will provide further details </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">on this.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">The Makefile is configured to support fundamental commands. </span><span class="koboSpan" id="kobo.395.2">Users can display the available command options by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">make help</span></strong><span class="koboSpan" id="kobo.397.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
$ make help
gen_cmake                      Generate cmake files, used internally
build                          Build source. </span><span class="koboSpan" id="kobo.399.2">In order to build a specific target run: make TARGET=&lt;target name&gt;.
</span><span class="koboSpan" id="kobo.399.3">test                           Run all tests
clean                          Clean build directory
login                          Login to the container. </span><span class="koboSpan" id="kobo.399.4">Note: if the container is already running, login into the existing one
</span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">build-docker-deps-image        Build the deps image.</span></strong></pre>
<p><span class="koboSpan" id="kobo.401.1">To</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.402.1"> integrate the Makefile into our sample project, we’ll begin by adding it as a Git submodule within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">build_tools</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1"> directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
git submodule add  https://github.com/f-squirrel/dockerized_cpp.git build_tools/</span></pre>
<p><span class="koboSpan" id="kobo.406.1">The next step is to create another Makefile in the root of the repository and include the Makefile that we have just </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">checked out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
include build_tools/Makefile</span></pre>
<p><span class="koboSpan" id="kobo.409.1">Before the project compilation, it’s prudent to adjust certain default settings to better suit the specific needs of your project. </span><span class="koboSpan" id="kobo.409.2">This can be efficiently achieved by declaring variables in the top-level Makefile prior to the inclusion of </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">build_tools/Makefile</span></strong><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">Such preemptive declarations allow for the customization of various parameters, ensuring that the build environment and process are optimally configured for your </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">project’s requirements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
PROJECT_NAME=example
DOCKER_DEPS_VERSION=0.1
</span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">include build_tools/Makefile</span></strong><span class="koboSpan" id="kobo.415.1">
By defining the project name, we automatically set the build image name as </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">example/example_build</span></strong><span class="koboSpan" id="kobo.417.1">.</span></pre>
<p><span class="koboSpan" id="kobo.418.1">Make is </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.419.1">now ready to build </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">the image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
$ make build-docker-deps-image
docker build  -t example/example_build:latest \
 -f ./DockerfileBuildEnv .
</span><span class="koboSpan" id="kobo.421.2">Sending build context to Docker daemon  1.049MB
Step 1/6 : FROM ubuntu:18.04
&lt; long output of docker build &gt;
Build finished. </span><span class="koboSpan" id="kobo.421.3">Docker image name: “example/example_build:latest”.
</span><span class="koboSpan" id="kobo.421.4">Before you push it to Docker Hub, please tag it(DOCKER_DEPS_VERSION + 1).
</span><span class="koboSpan" id="kobo.421.5">If you want the image to be the default, please update the following variables:
</span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">/home/dima/dockerized_cpp_build_example/Makefile: DOCKER_DEPS_VERSION</span></strong></pre>
<p><span class="koboSpan" id="kobo.423.1">The Makefile, by default, assigns the latest tag to the Docker image. </span><span class="koboSpan" id="kobo.423.2">For better version control and to align with our project’s current stage, it is advisable to tag the image with a specific version. </span><span class="koboSpan" id="kobo.423.3">In this context, we shall tag the image </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">0.1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">Finally, let us build </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
$ make
docker run -it --init --rm --memory-swap=-1 --ulimit core=-1 --name=”example_build” --workdir=/example --mount type=bind,source=/home/dima/dockerized_cpp_build_example,target=/example  example/example_build:0.1 \
 bash -c \
 “mkdir -p /example/build &amp;&amp; \
 cd build &amp;&amp; \
 CC=clang CXX=clang++ \
 cmake  ..”
</span><span class="koboSpan" id="kobo.429.2">-- The C compiler identification is Clang 6.0.0
-- The CXX compiler identification is Clang 6.0.0
-- Check for working C compiler: /usr/bin/clang
-- Check for working C compiler: /usr/bin/clang -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/clang++
-- Check for working CXX compiler: /usr/bin/clang++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Boost  found.
</span><span class="koboSpan" id="kobo.429.3">-- Found Boost components:
   filesystem
-- Configuring done
-- Generating done
-- Build files have been written to: /example/build
CMake finished.
</span><span class="koboSpan" id="kobo.429.4">docker run -it --init --rm --memory-swap=-1 --ulimit core=-1 --name=”example_build” --workdir=/example --mount type=bind,source=/home/dima/dockerized_cpp_build_example,target=/example  example/example_build:latest \
 bash -c \
 “cd build &amp;&amp; \
 make -j $(nproc) “
Scanning dependencies of target a.out
[ 50%] Building CXX object CMakeFiles/a.out.dir/main.cpp.o
[100%] Linking CXX executable a.out
[100%] Built target a.out
</span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Build finished. </span><span class="koboSpan" id="kobo.430.2">The binaries are in /home/dima/dockerized_cpp_build_example/build</span></strong></pre>
<p><span class="koboSpan" id="kobo.431.1">Upon inspecting the build directory on the host, you’ll observe that the output binary has been seamlessly placed there, facilitating easy access </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">and management.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Both the </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.434.1">Makefile and an example of a project that utilizes it with its default values can be found on GitHub. </span><span class="koboSpan" id="kobo.434.2">This provides a practical demonstration of how the Makefile can be integrated into a project, offering a turnkey solution for developers seeking to implement a Dockerized build environment in their </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">C++ projects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.436.1">Makefile </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">repository: </span></span><a href="https://github.com/f-squirrel/dockerized_cpp"><span class="No-Break"><span class="koboSpan" id="kobo.438.1">https://github.com/f-squirrel/dockerized_cpp</span></span></a></li>
<li><span class="koboSpan" id="kobo.439.1">Example </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">project: </span></span><a href="https://github.com/f-squirrel/dockerized_cpp"><span class="No-Break"><span class="koboSpan" id="kobo.441.1">https://github.com/f-squirrel/dockerized_cpp</span></span></a></li>
</ul>
<h3><span class="koboSpan" id="kobo.442.1">Enhancements for user management within Dockerized builds</span></h3>
<p><span class="koboSpan" id="kobo.443.1">The initial iteration of the Docker-based build system executed operations under the root user’s </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.444.1">privileges. </span><span class="koboSpan" id="kobo.444.2">While this setup typically doesn’t pose immediate problems—developers have the option to modify file permissions using </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">chmod</span></strong><span class="koboSpan" id="kobo.446.1">—executing Docker containers as the root user is generally discouraged from a security standpoint. </span><span class="koboSpan" id="kobo.446.2">More critically, this approach can lead to complications if any of the build targets modify the source code, such as code formatting or applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">clang-tidy</span></strong><span class="koboSpan" id="kobo.448.1"> corrections through </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">make</span></strong><span class="koboSpan" id="kobo.450.1"> commands. </span><span class="koboSpan" id="kobo.450.2">Such modifications could result in source files being owned by the root user, thereby restricting the ability to edit these files directly from </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the host.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">To address this concern, modifications have been made to the Dockerized build’s source code, enabling the container to execute as the host user by specifying the current user’s ID and group ID. </span><span class="koboSpan" id="kobo.452.2">This adjustment is now the standard configuration to enhance security and usability. </span><span class="koboSpan" id="kobo.452.3">Should there be a need to revert to running the container as the root user, the following command can </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">be utilized:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
make DOCKER_USER_ROOT=ON</span></pre>
<p><span class="koboSpan" id="kobo.455.1">It is important to recognize that the Docker image does not replicate the host user’s environment in its entirety—there is no corresponding home directory, nor are the user’s name and group replicated within the container. </span><span class="koboSpan" id="kobo.455.2">This implies that if the build process relies on accessing the home directory, this modified approach may not </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">be suitable.</span></span></p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.457.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.458.1">In this chapter, we explored various strategies and tools for managing third-party dependencies in C++ projects, a critical aspect that significantly impacts the efficiency and reliability of the development process. </span><span class="koboSpan" id="kobo.458.2">We delved into traditional methods, such as utilizing operating system package managers and incorporating dependencies directly via Git submodules, each with its unique advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">and limitations.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">We then transitioned to more specialized C++ package managers, highlighting Conan and vcpkg. </span><span class="koboSpan" id="kobo.460.2">Conan, with its robust ecosystem, extensive library support through Conan Center, and flexible configuration options, offers a comprehensive solution for managing complex dependencies, integrating seamlessly with multiple build systems, and supporting both static and dynamic linking. </span><span class="koboSpan" id="kobo.460.3">Its ability to handle multiple versions of libraries and the ease with which developers can extend the repository with custom packages make it an invaluable tool for modern </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">C++ development.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">vcpkg, developed by Microsoft, presents a slightly different approach, focusing on source-based distribution and ensuring libraries are built with the same compiler and settings as the consuming project. </span><span class="koboSpan" id="kobo.462.2">Its tight integration with CMake and Visual Studio, coupled with the backing of Microsoft, ensures a smooth experience, particularly for projects within the Microsoft ecosystem. </span><span class="koboSpan" id="kobo.462.3">The emphasis on compiling from source addresses potential binary incompatibility issues, making vcpkg a reliable choice for </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">managing dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">Lastly, we discussed the adoption of Dockerized builds as an advanced strategy for creating consistent, reproducible build environments, particularly beneficial in Linux systems. </span><span class="koboSpan" id="kobo.464.2">This approach, while more complex, offers significant advantages in terms of isolation, scalability, and consistency across development, testing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">deployment stages.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Throughout the chapter, we aimed to equip you with the knowledge and tools necessary to navigate the landscape of dependency management in C++ projects. </span><span class="koboSpan" id="kobo.466.2">By understanding the strengths and limitations of each method and tool, developers can make informed decisions tailored to their project’s specific needs, leading to more efficient and reliable software </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">development processes.</span></span></p>
</div>
</body></html>