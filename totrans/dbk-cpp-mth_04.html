<html><head></head><body>
  <div id="_idContainer024">
   <h1 class="chapter-number" id="_idParaDest-51">
    <a id="_idTextAnchor050">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-52">
    <a id="_idTextAnchor051">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     The Main() Function is the Entry Point to Your Application
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      What happens before main stays
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       in main
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     For programmers working with C++ on various operating systems, the entry point of an application is a concept that requires a deep understanding of the underlying architecture.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     In this chapter, we’ll analyze how an application starts, focusing on the initialization code that’s executed before we reach the user-defined
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.6.1">
       main()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.7.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.8.1">
     While exploring this process under Linux, we’ll analyze the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      Executable and Linkable Format
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      ELF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     ), detailing how
    </span>
    <a id="_idIndexMarker118">
    </a>
    <span class="koboSpan" id="kobo.13.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.14.1">
      execve()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.15.1">
     system call loads and executes a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.16.1">
      _start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.17.1">
     function, which prepares the runtime environment before calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.18.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.19.1">
     .
    </span>
    <span class="koboSpan" id="kobo.19.2">
     We’ll also explore some compiler-specific extensions that we can use to manipulate this process.
    </span>
    <span class="koboSpan" id="kobo.19.3">
     Then, we’ll shift our focus to Windows by offering a detailed examination
    </span>
    <a id="_idIndexMarker119">
    </a>
    <span class="koboSpan" id="kobo.20.1">
     of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.21.1">
      Portable Executable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.22.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.23.1">
      PE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     ) file sections
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      on Windows.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     We’ll also use a tool called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.27.1">
      Ghidra
     </span>
    </strong>
    <span class="koboSpan" id="kobo.28.1">
     to
    </span>
    <a id="_idIndexMarker120">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     dissect and analyze the executables under both platforms since this is one of the tools that provides practical insights into the low-level operations that underpin
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      application startup.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     After completing this chapter, you’ll have a deeper understanding of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      following aspects:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.33.1">
      The format of executable files and starting processes under Linux
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       and Windows
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.35.1">
      How to tinker with the startup process
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       of applications
      </span>
     </span>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.37.1">
     What is Ghidra?
    </span>
   </p>
   <p class="callout">
    <strong class="bold">
     <span class="koboSpan" id="kobo.38.1">
      Ghidra
     </span>
    </strong>
    <span class="koboSpan" id="kobo.39.1">
     is an
    </span>
    <a id="_idIndexMarker121">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     open source software reverse engineering suite developed by the NSA for analyzing compiled code across various formats and platforms.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     It offers tools for decompiling, disassembling, and debugging binary files, making it easier for users to understand and analyze
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      machine code.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-53">
    <a id="_idTextAnchor052">
    </a>
    <span class="koboSpan" id="kobo.42.1">
     The main() function
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     When we took up C++ in school, or maybe
    </span>
    <a id="_idIndexMarker122">
    </a>
    <span class="koboSpan" id="kobo.44.1">
     at university, on our first C++ course, we were told by our teacher: “Dear fellows, here’s the main function:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.45.1">
      void main(void)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.46.1">
     .
    </span>
    <span class="koboSpan" id="kobo.46.2">
     That’s where your program will start.”
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      That’s it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Chapter done – turn the pages and see you in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      next one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     However, this statement isn’t true.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     I wrote
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.51.1">
      void main(void)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.52.1">
     just to wake your curiosity and put you in a state of alertness.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     At this point in their career, all C++ programmers should know that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.53.1">
      void main(void)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     is as far as standard C++ as Point Nemo is from the closest piece of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      dry land.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.56.1">
     Oh – you’re still here!
    </span>
    <span class="koboSpan" id="kobo.56.2">
     This means that you must have read the fine print.
    </span>
    <span class="koboSpan" id="kobo.56.3">
     Excellent – we programmers should always pay attention to the finer details, such as how our application is loaded and executed in memory by the underlying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      operating system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     Since we live in a free world, we have the option to choose from several operating systems at our discretion, so we’ve opted to present how this application loading happens under Linux
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.59.1">
      and Windows.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     There’s a significant difference between these two operating systems concerning the way they load and execute the compiled binaries, and while in one of them (it’s not that hard to guess which one) we can track all the code paths of this peculiar process down the deepest layers of the underlying kernel, for the other one, we must rely on existing documentation, books, and various sources of information that are to be gathered by the enthusiast
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      low-level scholar.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Since the way Linux deals with this operation is very similar to how the operating systems from the BSD family (FreeBSD, NetBSD, and so on) approach the same problem, we’ll refrain from actively mentioning these while we debate the problem in the upcoming paragraphs.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     Since we want to keep you entertained while in the pursuit of knowledge, we still want to offer information that’s up to date, so we’ve decided not to offer this information for peculiar operating systems, such as MS-DOS, that are no longer used in active production environments as of 2024 (except if you happen to work at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      Deutsche Bahn
     </span>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span id="footnote-016-backlink">
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-016">
        <span class="koboSpan" id="kobo.64.1">
         1
        </span>
       </a>
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      ).
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-016">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-016-backlink">
      <span class="koboSpan" id="kobo.66.1">
       1
      </span>
     </a>
     <a href="https://www.theregister.com/2024/01/30/windows_311_trundles_on/">
      <span class="koboSpan" id="kobo.67.1">
       https://www.theregister.com/2024/01/30/windows_311_trundles_on/
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     But before we dig deeper, we’ll
    </span>
    <a id="_idIndexMarker123">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     present the test application that we’ll be using in this chapter to exemplify the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      aforementioned functionality:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.71.1">
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
struct A {
   A(const char* p_a):m_a(new char[32]) { strcpy(m_a, p_a);
       printf("A::A : %s\n", p_a);
   }
   ~A() {
       printf("A::~A : %s\n", m_a);
       delete[] m_a;
   }
   volatile const char* get() const {return m_a;}
private:
   char* m_a;
};
const char* my_string= "Hello string";
A my_a(my_string);
const char* my_other_string = "Go away string";
A my_other_a(my_other_string);
int main() {
   printf("Hello, World, %s, %s\n", my_a.get(), my_other_a.get()); }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     When compiled and run on a standard compliant system, the preceding application produces the following output, as expected by a standard
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      compliant programmer:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.74.1">
A::A : Hello string
A::A : Go away string
Hello, World, Hello string, Go away string
A::~A : Go away string
A::~A : Hello string</span></pre>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     Yes, we’ve intentionally used no
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      cout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     and other stream operations as we want to keep this simple.
    </span>
    <span class="koboSpan" id="kobo.77.2">
     We don’t want to pollute the generated code since we plan to dig deep into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      compiled executables.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     Also, please note
    </span>
    <a id="_idIndexMarker124">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     that this is synthetic code that’s been written specifically for this chapter to exemplify the features we want to present.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     The authors are totally aware of the potential memory overflow error induced by strcpy, so the readers are advised to do what the author tells them to do, not what the author does: “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.81.1">
      Don’t
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.82.1">
       use strcpy.
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.83.1">
      ”
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     Going back to our initial goal, let’s present how operating systems load and execute applications.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     In case, dear reader, you feel that the discussion below is of a too low level, please bear in mind:  C++ programs compile to native code while running at the highest possible speed allocated by the underlying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      operating system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.86.1">
     With this in mind, we consider that it’s in the interest of any C++ programmer to know how the operating system is handling their code, and what happens after the compiler has digested their source files and spat out an executable.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     We will try to keep out the lowest level details and present only what is really necessary, in order to fully grasp the seriousness of the situation.
    </span>
   </p>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor053">
    </a>
    <span class="koboSpan" id="kobo.87.1">
     The penguin farm
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     When Linux loads and executes an application (say we want to execute an application, not a shell script or something else), usually a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      fork()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.91.1">
      execve()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.92.1">
     pair of
    </span>
    <a id="_idIndexMarker125">
    </a>
    <span class="koboSpan" id="kobo.93.1">
     system calls are initiated to start the execution of the application.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     These system calls are responsible for duplicating the current process (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.95.1">
      fork()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     ) and replacing the current process image with a new process image (the application to be executed – that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      is,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.98.1">
       execve()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.100.1">
     These API calls are presented in great detail in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.101.1">
      Advanced Linux Programming
     </span>
    </em>
    <span class="koboSpan" id="kobo.102.1">
     , by Mark Mitchell, Jeffrey Oldham, and Alex Samuel, but there are countless online resources dedicated to this subject.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     So, if you’re interested in this subject, you might find good sources of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      information there.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.104.1">
     But let’s continue loading the
    </span>
    <a id="_idIndexMarker126">
    </a>
    <span class="koboSpan" id="kobo.105.1">
     executable.
    </span>
    <span class="koboSpan" id="kobo.105.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      execve()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     system call, after several iterations where it leaves the confines of userspace, will end up in the Linux kernel and create a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.108.1">
       linux_binprm
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      structure
     </span>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span id="footnote-015-backlink">
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-015">
        <span class="koboSpan" id="kobo.110.1">
         2
        </span>
       </a>
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      .
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-015">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-015-backlink">
      <span class="koboSpan" id="kobo.112.1">
       2
      </span>
     </a>
     <a href="https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h">
      <span class="koboSpan" id="kobo.113.1">
       https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.114.1">
     According to the documentation, this structure is used upon loading binaries and contains all the major details that are needed upon loading and executing a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      binary file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     If you have lots of free time, are armed with a large cup of tea, and have deep knowledge of the intricacies of the C language, you can easily read through the lengthy implementation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      do_execveat_common
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     function to learn more about the behind-the-scenes of this function in the current Linux kernel
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      source tree
     </span>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span id="footnote-014-backlink">
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-014">
        <span class="koboSpan" id="kobo.120.1">
         3
        </span>
       </a>
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      .
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-014">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-014-backlink">
      <span class="koboSpan" id="kobo.122.1">
       3
      </span>
     </a>
     <span class="koboSpan" id="kobo.123.1">
      https://github.com/torvalds/linux/blob/master/fs/exec.c
     </span>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.124.1">
     The kernel, in turn, determines the format of the executable file.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     On Linux systems, the most common executable format
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      is ELF.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     All fields are described in the official standard document,
    </span>
    <span class="superscript">
     <span id="footnote-013-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-013">
       <span class="koboSpan" id="kobo.127.1">
        4
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.128.1">
     but a quick summary of the fields that are relevant to our use case are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      as follows:
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-013">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-013-backlink">
      <span class="koboSpan" id="kobo.130.1">
       4
      </span>
     </a>
     <span class="koboSpan" id="kobo.131.1">
      https://refspecs.linuxfoundation.org/elf/elf.pdf
     </span>
    </p>
   </div>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.132.1">
           Field Name
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.133.1">
           Offset
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.134.1">
           Description
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.135.1">
           MAGIC
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.136.1">
          0x00
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.137.1">
         A magic number indicating that the file is an ELF file (“ELF” in ASCII
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.138.1">
          and 0x7F)
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.139.1">
           CLASS
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.140.1">
          0x04
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.141.1">
         Specifies the class (32-bit or 64-bit) of the
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.142.1">
          ELF file
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.143.1">
           e_type
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.144.1">
          0x10
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.145.1">
         Identifies the object file type (for example, executable, shared object, and
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.146.1">
          so on)
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.147.1">
           e_machine
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.148.1">
          0x12
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.149.1">
         Specifies the architecture for which the file
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.150.1">
          was compiled
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.151.1">
           e_entry
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.152.1">
          0x18
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.153.1">
         The virtual address to which the system transfers control first, starting
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.154.1">
          the process
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    <span class="koboSpan" id="kobo.155.1">
     Please remember this table as we’ll be referring to it shortly.
    </span>
    <span class="koboSpan" id="kobo.155.2">
     But for now, let’s continue loading a program.
    </span>
    <span class="koboSpan" id="kobo.155.3">
     It’s time for the kernel to read the ELF header to understand the structure of the executable.
    </span>
    <span class="koboSpan" id="kobo.155.4">
     The following operations happen at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      this stage:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.157.1">
       Memory allocation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.158.1">
      : The
     </span>
     <a id="_idIndexMarker127">
     </a>
     <span class="koboSpan" id="kobo.159.1">
      kernel allocates memory for the new process.
     </span>
     <span class="koboSpan" id="kobo.159.2">
      This includes setting up the process’s address space, which consists of different segments such as text (code), data, the heap, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.160.1">
       the stack.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.161.1">
       Section mapping
      </span>
     </strong>
     <span class="koboSpan" id="kobo.162.1">
      : The
     </span>
     <a id="_idIndexMarker128">
     </a>
     <span class="koboSpan" id="kobo.163.1">
      kernel maps sections of the executable file into the process’s address space.
     </span>
     <span class="koboSpan" id="kobo.163.2">
      For example, the text segment (containing executable code) is mapped as read-only, while the data segment (containing global variables) is mapped
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.164.1">
       as read-write.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.165.1">
       Dynamic linking
      </span>
     </strong>
     <span class="koboSpan" id="kobo.166.1">
      : If the
     </span>
     <a id="_idIndexMarker129">
     </a>
     <span class="koboSpan" id="kobo.167.1">
      executable depends on shared libraries, the dynamic linker/loader (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.168.1">
       ld.so
      </span>
     </strong>
     <span class="koboSpan" id="kobo.169.1">
      ) is invoked to load the necessary shared libraries and resolve symbol references.
     </span>
     <span class="koboSpan" id="kobo.169.2">
      The dynamic linker also maps these libraries into the process’s
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.170.1">
       address space.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     These operations all happen deep inside the Linux kernel, but if you’re interested in this domain, we encourage you to go and read the source – perhaps you can spot something
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      teasing there.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     Once all these interesting and very low-level operations have been performed successfully, the kernel sets up the initial environment stack for the process.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     This stack contains
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.175.1">
       Argument vectors
      </span>
     </strong>
     <span class="koboSpan" id="kobo.176.1">
      (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.177.1">
       argv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.178.1">
      ): An
     </span>
     <a id="_idIndexMarker130">
     </a>
     <span class="koboSpan" id="kobo.179.1">
      array of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.180.1">
       command-line arguments
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.181.1">
       Environment variables
      </span>
     </strong>
     <span class="koboSpan" id="kobo.182.1">
      (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.183.1">
       envp
      </span>
     </strong>
     <span class="koboSpan" id="kobo.184.1">
      ): An
     </span>
     <a id="_idIndexMarker131">
     </a>
     <span class="koboSpan" id="kobo.185.1">
      array of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.186.1">
       environment variables
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.187.1">
       Auxiliary vectors
      </span>
     </strong>
     <span class="koboSpan" id="kobo.188.1">
      (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.189.1">
       auxv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.190.1">
      ): Additional
     </span>
     <a id="_idIndexMarker132">
     </a>
     <span class="koboSpan" id="kobo.191.1">
      information needed by the program, such as system page size, entry point of the program, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.192.1">
       so on
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.193.1">
     All this happens in the same kernel source file mentioned previously (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      binfmt_elf.c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     ), in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      following function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.197.1">
static int create_elf_tables(struct linux_binprm *bprm,
const struct elfhdr *exec, unsigned long interp_load_addr,
unsigned long e_entry,unsigned long phdr_addr) { ... </span><span class="koboSpan" id="kobo.197.2">}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     After creating the runtime environment, the
    </span>
    <a id="_idIndexMarker133">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     kernel sets up the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.200.1">
      instruction pointer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.202.1">
      IP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     ) to point to the entry point of the program (as specified in the ELF header).
    </span>
    <span class="koboSpan" id="kobo.203.2">
     The CPU registers are also initialized as required.
    </span>
    <span class="koboSpan" id="kobo.203.3">
     Finally, the kernel switches the CPU back to user mode and transfers control to the entry point of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.205.1">
     In Linux, transfer of control i occurs primarily in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      start_thread()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     function, which is architecture-specific.
    </span>
    <span class="koboSpan" id="kobo.207.2">
     At the time of writing, for x86, this function is defined in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      arch/x86/include/asm/processor.h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     and is implemented in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      arch/x86/kernel/process_64.c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     .
    </span>
    <span class="koboSpan" id="kobo.211.2">
     The program starts executing from this point.
    </span>
    <span class="koboSpan" id="kobo.211.3">
     Now comes the interesting part – at least from a C++ developer’s point
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      of view.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.213.1">
     First, the program’s initialization code (often part of the C runtime library) is executed – typically the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.214.1">
      _start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.215.1">
     function, not
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     .
    </span>
    <span class="koboSpan" id="kobo.217.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      e_entry
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     field of the ELF header lists the offset in the file where the program starts executing.
    </span>
    <span class="koboSpan" id="kobo.219.2">
     Usually, it’s the offset of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.220.1">
      _start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.221.1">
     method, or at least if the executable was compiled with the standard GNU toolchain.
    </span>
    <span class="koboSpan" id="kobo.221.2">
     This code is responsible for setting up any runtime environment variables and calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     function of the program.
    </span>
    <span class="koboSpan" id="kobo.223.2">
     From this point, the program runs as per the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      instructions written.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     So, let’s examine what exactly is the
    </span>
    <a id="_idIndexMarker134">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     initialization code.
    </span>
    <span class="koboSpan" id="kobo.226.2">
     We’ll use our handy
    </span>
    <a id="_idIndexMarker135">
    </a>
    <span class="koboSpan" id="kobo.227.1">
     tool,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.228.1">
      Ghidra
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     , which allows us to dissect Linux executables and examine their inner workings.
    </span>
    <span class="koboSpan" id="kobo.229.2">
     This tool provides the following summary of our almost
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      empty application:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer010">
     <span class="koboSpan" id="kobo.231.1">
      <img alt="Figure 4.1 – The structure of our synthetic application" src="image/B22235_04_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.232.1">
     Figure 4.1 – The structure of our synthetic application
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.233.1">
     When looking at the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.234.1">
      ELF Source File
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     section, we can see our initial
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.236.1">
      main.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     file; however, there are a few other items that we’re not familiar with yet – for example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      crtstuff.c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     .
    </span>
    <span class="koboSpan" id="kobo.239.2">
     This file is part of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.240.1">
      libgcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.241.1">
     and can be found in
    </span>
    <a id="_idIndexMarker136">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.243.1">
      libgcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     repository
    </span>
    <span class="superscript">
     <span id="footnote-012-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-012">
       <span class="koboSpan" id="kobo.245.1">
        5
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.246.1">
     , with the following comment written at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      the top:
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-012">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-012-backlink">
      <span class="koboSpan" id="kobo.248.1">
       5
      </span>
     </a>
     <a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c">
      <span class="koboSpan" id="kobo.249.1">
       https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c
      </span>
     </a>
    </p>
   </div>
   <pre class="source-code"><span class="koboSpan" id="kobo.250.1">
/* Specialized bits of code needed to support construction and destruction of file-scope objects in C++ code.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     With that, one of the mysteries has been resolved and the comment is self-explanatory.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     However, another remains:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.252.1">
      Scrt1.o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     .
    </span>
    <span class="koboSpan" id="kobo.253.2">
     To understand
    </span>
    <a id="_idIndexMarker137">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     this, we need to know about the difference
    </span>
    <a id="_idIndexMarker138">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     between
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.256.1">
      fixed-address executables
     </span>
    </strong>
    <span class="koboSpan" id="kobo.257.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.258.1">
      position-independent
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.259.1">
       executables
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.261.1">
       PIEs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.263.1">
     Fixed-address executables
    </span>
    <a id="_idIndexMarker139">
    </a>
    <span class="koboSpan" id="kobo.264.1">
     are compiled to be loaded at specific, predetermined memory addresses, making them simpler but less secure and flexible since their addresses are predictable and vulnerable to attacks.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     This is the preferred manner of loading executables on embedded devices and some older platforms (such as MS-DOS, which also had this “feature” of requiring
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      .com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     applications to be loaded at a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      specific offset).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.268.1">
     On the other hand,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.269.1">
      Position Independent Executable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.270.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.271.1">
      PIE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     ) executables
    </span>
    <a id="_idIndexMarker140">
    </a>
    <span class="koboSpan" id="kobo.273.1">
     are compiled and linked to be position-independent, allowing them to be loaded at any address
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      in memory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.275.1">
     When you compile a program, you can use various flags to control how the compiler generates the code.
    </span>
    <span class="koboSpan" id="kobo.275.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.276.1">
      -fPIE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.277.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      -pie
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.280.1">
      -fPIC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     flags are related to how the code is positioned and handled in memory.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     Here’s a quick breakdown of what each
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      flag does:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.283.1">
       -fPIE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.284.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.285.1">
       position-independent executable
      </span>
     </strong>
     <span class="koboSpan" id="kobo.286.1">
      ): The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.287.1">
       -fPIE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.288.1">
      flag tells the compiler to generate
     </span>
     <a id="_idIndexMarker141">
     </a>
     <span class="koboSpan" id="kobo.289.1">
      position-independent code for executables.
     </span>
     <span class="koboSpan" id="kobo.289.2">
      This is useful for creating executables that support
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.290.1">
       Address Space Layout Randomization
      </span>
     </strong>
     <span class="koboSpan" id="kobo.291.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.292.1">
       ASLR
      </span>
     </strong>
     <span class="koboSpan" id="kobo.293.1">
      ), a
     </span>
     <a id="_idIndexMarker142">
     </a>
     <span class="koboSpan" id="kobo.294.1">
      security feature that randomizes the memory address where the executable is loaded to make it harder for attackers to predict the location of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.295.1">
       specific code.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.296.1">
       -pie
      </span>
     </strong>
     <span class="koboSpan" id="kobo.297.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.298.1">
       position-independent executable linker flag
      </span>
     </strong>
     <span class="koboSpan" id="kobo.299.1">
      ): The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.300.1">
       -pie
      </span>
     </strong>
     <span class="koboSpan" id="kobo.301.1">
      flag is used during the linking stage.
     </span>
     <span class="koboSpan" id="kobo.301.2">
      It
     </span>
     <a id="_idIndexMarker143">
     </a>
     <span class="koboSpan" id="kobo.302.1">
      instructs the linker to produce a position-independent executable.
     </span>
     <span class="koboSpan" id="kobo.302.2">
      This means that the final output file (the executable) will be able to be loaded at any address in memory supporting ASLR.
     </span>
     <span class="koboSpan" id="kobo.302.3">
      It complements the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.303.1">
       -fPIE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.304.1">
      flag, which is used during compilation, ensuring that all the code in the executable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.305.1">
       is position-independent.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.306.1">
       -fPIC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.307.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.308.1">
       position-independent code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.309.1">
      ): The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.310.1">
       -fPIC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.311.1">
      flag tells the compiler to generate
     </span>
     <a id="_idIndexMarker144">
     </a>
     <span class="koboSpan" id="kobo.312.1">
      position-independent code for shared libraries.
     </span>
     <span class="koboSpan" id="kobo.312.2">
      Position-independent code for shared libraries means that the library can be loaded at any address in memory.
     </span>
     <span class="koboSpan" id="kobo.312.3">
      This is essential for shared libraries because they may be loaded into different memory locations in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.313.1">
       different programs.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     Now that we know about these important notions, let’s get back to where we left off and cover the one remaining mystery in our
    </span>
    <a id="_idIndexMarker145">
    </a>
    <span class="koboSpan" id="kobo.315.1">
     binary:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.316.1">
      Scrt1.o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     .
    </span>
    <span class="koboSpan" id="kobo.317.2">
     Do you remember the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      _start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     function?
    </span>
    <span class="koboSpan" id="kobo.319.2">
     Since you didn’t write it yourself, it must come from somewhere.
    </span>
    <span class="koboSpan" id="kobo.319.3">
     For us, it comes from this magic
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.320.1">
      Scrt1.o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     .
    </span>
    <span class="koboSpan" id="kobo.321.2">
     There are several variations of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.322.1">
      crtX.o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.323.1">
     , some with a leading S, some without, but for us, the presence of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.324.1">
      Scrt1.o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     tells us that our application is a PIE executable.
    </span>
    <span class="koboSpan" id="kobo.325.2">
     Several other files can be linked to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.326.1">
      our application:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.327.1">
       crt0.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.328.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.329.1">
       crt1.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.330.1">
      , and so on: These
     </span>
     <a id="_idIndexMarker146">
     </a>
     <span class="koboSpan" id="kobo.331.1">
      files contain the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.332.1">
       _start
      </span>
     </strong>
     <span class="koboSpan" id="kobo.333.1">
      symbol, which is crucial for
     </span>
     <a id="_idIndexMarker147">
     </a>
     <span class="koboSpan" id="kobo.334.1">
      bootstrapping program execution.
     </span>
     <span class="koboSpan" id="kobo.334.2">
      Their specific naming conventions may vary between
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.335.1">
        libc
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.336.1">
       implementations.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.337.1">
       crti.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.338.1">
      : This defines
     </span>
     <a id="_idIndexMarker148">
     </a>
     <span class="koboSpan" id="kobo.339.1">
      function prologues for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.340.1">
       .init
      </span>
     </strong>
     <span class="koboSpan" id="kobo.341.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.342.1">
       .fini
      </span>
     </strong>
     <span class="koboSpan" id="kobo.343.1">
      sections, triggering linker-generated dynamic tags (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.344.1">
       DT_INIT and DT_FINI
      </span>
     </strong>
     <span class="koboSpan" id="kobo.345.1">
      ), to support We’ll discuss these notions here, so don’t worry about the unknown
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.346.1">
       terminology yet.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.347.1">
       crtn.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.348.1">
      : This provides
     </span>
     <a id="_idIndexMarker149">
     </a>
     <span class="koboSpan" id="kobo.349.1">
      function epilogues for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.350.1">
       .init
      </span>
     </strong>
     <span class="koboSpan" id="kobo.351.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.352.1">
       .fini
      </span>
     </strong>
     <span class="koboSpan" id="kobo.353.1">
      sections,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.354.1">
       complementing
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.355.1">
        crti.o
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.356.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.357.1">
       Scrt1.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.358.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.359.1">
       gcrt1.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.360.1">
      , and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.361.1">
       Mcrt1.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.362.1">
      : These are
     </span>
     <a id="_idIndexMarker150">
     </a>
     <span class="koboSpan" id="kobo.363.1">
      variants of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.364.1">
       crt1.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.365.1">
      that are used under different
     </span>
     <a id="_idIndexMarker151">
     </a>
     <span class="koboSpan" id="kobo.366.1">
      circumstances, such as generating PIEs or including
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.367.1">
       profiling
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker152">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.368.1">
       information.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.369.1">
       crtbegin.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.370.1">
      ,
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.371.1">
       crtbeginS.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.372.1">
      , and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.373.1">
       crtbeginT.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.374.1">
      : These
     </span>
     <a id="_idIndexMarker153">
     </a>
     <span class="koboSpan" id="kobo.375.1">
      are used by GCC to locate constructors and
     </span>
     <a id="_idIndexMarker154">
     </a>
     <span class="koboSpan" id="kobo.376.1">
      their variations (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.377.1">
       crtbeginS.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      for shared
     </span>
     <a id="_idIndexMarker155">
     </a>
     <span class="koboSpan" id="kobo.379.1">
      objects/PIEs and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.380.1">
       crtbeginT.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.381.1">
      for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.382.1">
       static executables).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.383.1">
       crtend.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.384.1">
      and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.385.1">
       crtendS.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.386.1">
      : Similar
     </span>
     <a id="_idIndexMarker156">
     </a>
     <span class="koboSpan" id="kobo.387.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.388.1">
       crtbegin.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.389.1">
      , these are used by GCC to locate
     </span>
     <a id="_idIndexMarker157">
     </a>
     <span class="koboSpan" id="kobo.390.1">
      destructors (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.391.1">
       crtendS.o
      </span>
     </strong>
     <span class="koboSpan" id="kobo.392.1">
      for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.393.1">
       shared objects/PIEs).
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     Now that we’ve demystified the content of our executable, we need to understand something else: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      .init_array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     section in an ELF file is used to store an array of function pointers that are automatically executed by the operating system’s runtime loader during
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      program startup.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     These functions are typically referred to as “init functions” or “initialization functions.”
    </span>
    <span class="koboSpan" id="kobo.398.2">
     They’re called before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.399.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     and are responsible for initializing global data.
    </span>
    <span class="koboSpan" id="kobo.400.2">
     For our synthetic application, this is how this section looks once it’s been analyzed
    </span>
    <a id="_idIndexMarker158">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.402.1">
       Ghidra
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer011">
     <span class="koboSpan" id="kobo.404.1">
      <img alt="Figure 4.2 – The .init_array section for global variables" src="image/B22235_04_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.405.1">
     Figure 4.2 – The .init_array section for global variables
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     As we can see, there are two functions here – a dummy one and something called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.407.1">
      _GLOBAL__sub_I_my_string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.408.1">
     .
    </span>
    <span class="koboSpan" id="kobo.408.2">
     Interesting choice of name, so let’s use the assembly to C-like code feature of the tool and see what it does:
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer012">
     <span class="koboSpan" id="kobo.409.1">
      <img alt="Figure 4.3 – How global objects are created according to Ghidra" src="image/B22235_04_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.410.1">
     Figure 4.3 – How global objects are created according to Ghidra
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     Intriguing, isn’t it?
    </span>
    <span class="koboSpan" id="kobo.411.2">
     This is
    </span>
    <a id="_idIndexMarker159">
    </a>
    <span class="koboSpan" id="kobo.412.1">
     just what you would expect to happen in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      global namespace.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.414.1">
     Here, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.415.1">
      my_a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.417.1">
      my_other_a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.418.1">
     objects are being created, their constructor is called, and the destructor of class
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.419.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.420.1">
     is being invoked for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      __cxa_atexit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     .
    </span>
    <span class="koboSpan" id="kobo.422.2">
     It is quite an intriguing observation though, how the constructor calls behind the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.423.1">
      scenes work.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     From this queasy disassembly, you may feel that the constructor gets an invisible parameter for the object it’s constructing.
    </span>
    <span class="koboSpan" id="kobo.424.2">
     This is true: this is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.425.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     variable, and it’s implicitly added to all the methods of a class without being explicitly required.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     This is how we gain access to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      object itself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     As its name suggests, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.429.1">
      __cxa_atexit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     function is just like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      atexit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     .
    </span>
    <span class="koboSpan" id="kobo.432.2">
     However, you don’t have to worry about it because it isn’t a function that should be dealt with outside of the library it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      resides in.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.434.1">
     Now that we understand what happens here, it’s time to pick up another thread we mentioned previously: the infamous
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       _start()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     As mentioned previously, this function should do some housekeeping and start our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.438.1">
      main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.439.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.439.2">
     According to
    </span>
    <a id="_idIndexMarker160">
    </a>
    <span class="koboSpan" id="kobo.440.1">
     Ghidra, it can be indeed found in the ELF header.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     According to the ELF specification, it occupies the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      e_entry
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     field in the long list of ELF
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      entries: :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer013">
     <span class="koboSpan" id="kobo.444.1">
      <img alt="Figure 4.4 – The ELF header according to Ghidra" src="image/B22235_04_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.445.1">
     Figure 4.4 – The ELF header according to Ghidra
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     Now, after applying
    </span>
    <a id="_idIndexMarker161">
    </a>
    <span class="koboSpan" id="kobo.447.1">
     some disassembly magic, courtesy of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.448.1">
      Ghidra
     </span>
    </strong>
    <span class="koboSpan" id="kobo.449.1">
     , it looks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      like this:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer014">
     <span class="koboSpan" id="kobo.451.1">
      <img alt="Figure 4.5 – The _start routine function, disassembled and converted into C pseudocode" src="image/B22235_04_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.452.1">
     Figure 4.5 – The _start routine function, disassembled and converted into C pseudocode
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.453.1">
     The scary-looking
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      __libc_start_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.455.1">
     function isn’t as scary as it seems and is responsible for loading our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.456.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.457.1">
     function alongside the parameters provided by the operating system.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     This function is part of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.458.1">
      glibc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.459.1">
     and can
    </span>
    <a id="_idIndexMarker162">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     be obtained free of charge
    </span>
    <span class="superscript">
     <span id="footnote-011-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-011">
       <span class="koboSpan" id="kobo.461.1">
        6
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.462.1">
     , just like every other free piece of software with good behavior, so that we can study
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.463.1">
      its internals.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-011">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-011-backlink">
      <span class="koboSpan" id="kobo.464.1">
       6
      </span>
     </a>
     <span class="koboSpan" id="kobo.465.1">
      git clone git://sourceware.org/git/glibc.git
     </span>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.466.1">
     At this stage, with the outcome of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      __libc_start_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     , we’ve reached the actual main function.
    </span>
    <span class="koboSpan" id="kobo.468.2">
     This is where we would expect our program
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.469.1">
      to reside.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.470.1">
     These details offer deeper insights into program execution, optimization opportunities, and debugging capabilities.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     Mastery of the ELF file format enables you to optimize performance by leveraging specific linker options and understanding dynamic linking intricacies.
    </span>
    <span class="koboSpan" id="kobo.470.3">
     Moreover, it facilitates effective debugging by tracing initialization sequences and identifying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      startup-related issues.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-55">
    <a id="_idTextAnchor054">
    </a>
    <span class="koboSpan" id="kobo.472.1">
     Oh no, there’s more!
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.473.1">
     Now that we’re here, typing on our favorite Linux machine, let’s not waste any more time and dive a bit deeper into the internals of some of the compilers that come with this great operating system.
    </span>
    <span class="koboSpan" id="kobo.473.2">
     For example, let’s dig into the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.474.1">
      .init_array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     section of the ELF file.
    </span>
    <span class="koboSpan" id="kobo.475.2">
     As mentioned previously, it’s responsible
    </span>
    <a id="_idIndexMarker163">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     for starting different functions before the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      main one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     But before we continue our journey through these swampy fields, a warning must be mentioned: what we’re going to discuss isn’t for faint-hearted C++ programmers, to the extent that it isn’t even standard C++.
    </span>
    <span class="koboSpan" id="kobo.478.2">
     Please read
    </span>
    <a href="B22235_02.xhtml#_idTextAnchor026">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.479.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.480.1">
     concerning C++ standardness.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     If you can live with the unholy scripture of compiler extensions, then please
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      read on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     GCC (as well as Clang) has a very
    </span>
    <a id="_idIndexMarker164">
    </a>
    <span class="koboSpan" id="kobo.483.1">
     handy extension for executing functions before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.484.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.485.1">
     .
    </span>
    <span class="koboSpan" id="kobo.485.2">
     These functions are called constructor functions and they need to be spawned with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.486.1">
      specific attribute:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.487.1">
__attribute__((constructor)) void welcome() {
   printf("constructor fun\n");
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     If we add this specific piece of
    </span>
    <a id="_idIndexMarker165">
    </a>
    <span class="koboSpan" id="kobo.489.1">
     code to our synthetic application, we can expect the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.491.1">
constructor fun
A::A : Hello string
A::A : Go away string
Hello, World, Hello string, Go away string
A::~A : Go away string
A::~A : Hello string</span></pre>
   <p>
    <span class="koboSpan" id="kobo.492.1">
     As you can see, the constructor function is being executed before the global initialization code.
    </span>
    <span class="koboSpan" id="kobo.492.2">
     If we dig  into the executable with our favorite nine-headed spades, we’ll see the following content in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.493.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.494.1">
       init_array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.495.1">
      section:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer015">
     <span class="koboSpan" id="kobo.496.1">
      <img alt="Figure 4.6 – The .init_array section with a constructor function" src="image/B22235_04_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.497.1">
     Figure 4.6 – The .init_array section with a constructor function
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.498.1">
     With this knowledge, we now possess two methods of writing code that will be executed before the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.499.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.500.1">
     function in a C++ application: constructor functions and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      global variables.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.502.1">
     At this point, we’re in a
    </span>
    <a id="_idIndexMarker166">
    </a>
    <span class="koboSpan" id="kobo.503.1">
     place where we’ve started scratching the surface of something dangerous: the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.504.1">
      static initialization order fiasco
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     .
    </span>
    <span class="koboSpan" id="kobo.505.2">
     This is a
    </span>
    <a id="_idIndexMarker167">
    </a>
    <span class="koboSpan" id="kobo.506.1">
     subject that’s been debated several times, in various places.
    </span>
    <span class="koboSpan" id="kobo.506.2">
     These debates summarize that this issue arises from the undefined order of initialization of static or global variables across different translation units.
    </span>
    <span class="koboSpan" id="kobo.506.3">
     There are various techniques for resolving these issues, but our recommendation is to just
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.507.1">
       avoid them
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.508.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.509.1">
     The following example illustrates why this can conjure up dangerous situations.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     Here, we’ve created several short files, again with synthetic content, trying to emulate a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      real-life situation:
     </span>
    </span>
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.511.1">
     a.h
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.512.1">
#ifndef A_H
#define A_H
class C;
extern C a_c;
#endif</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.513.1">
     b.h
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.514.1">
#ifndef B_H
#define B_H
class C;
extern C b_c;
#endif</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.515.1">
     C.h
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.516.1">
#ifndef C_H
#define C_H
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
struct C {
   C(const char* p_c) : m_c(nullptr) {
       m_c = new char[32];
       strcpy(m_c, p_c);
       printf("C::C : %s\n", p_c);
   }
   ~C() {
       printf("C::~C : %s\n", m_c);
       delete[] m_c;
   }
private:
   char* m_c;
};
#endif</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.517.1">
     a.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.518.1">
#include "C.h"
C a_c("A");</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.519.1">
     b.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.520.1">
#include "C.h"
C b_c("B");</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.521.1">
     main.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.522.1">
int main()
{
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     This isn’t
    </span>
    <a id="_idIndexMarker168">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     extraordinarily complicated code – it’s just a diagnostic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.525.1">
      C
     </span>
    </strong>
    <span class="koboSpan" id="kobo.526.1">
     class that’s used to print out some debugging information and some separate C++ files creating objects of the aforementioned
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      diagnostic class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.528.1">
     Normally, these files are compiled with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.529.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.530.1">
     , so let’s compile them and execute the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.531.1">
      resulting file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.532.1">
&gt; $ g++ main.cpp a.cpp b.cpp -o test
&gt; $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A</span></pre>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     There’s nothing special here – we compiled and created an executable that performed what it’s supposed to: print out when a specific object was created
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.534.1">
      and destroyed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.535.1">
     But what happens if we specify the files in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.536.1">
      different order?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.537.1">
&gt; $ g++ main.cpp b.cpp a.cpp -o test
&gt; $ ./test
C::C : B
C::C : A
C::~C : A
C::~C : B</span></pre>
   <p>
    <span class="koboSpan" id="kobo.538.1">
     What a
    </span>
    <a id="_idIndexMarker169">
    </a>
    <span class="koboSpan" id="kobo.539.1">
     surprise.
    </span>
    <span class="koboSpan" id="kobo.539.2">
     Now, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      b_c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     object from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      b.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     is created before the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      a_c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     object from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      a.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     .
    </span>
    <span class="koboSpan" id="kobo.547.2">
     Now, imagine the disastrous situation where our program is made up of global objects that depend on the pre-existence of some other global objects to be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      initialized correctly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.549.1">
     Thankfully, the compiler ecosystem under Linux provides us with the necessary tools to achieve a sane state of our applications concerning this matter, with the help of a very handy extension.
    </span>
    <span class="koboSpan" id="kobo.549.2">
     This extension is used to specify the initialization order for global members and it manifests itself using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.550.1">
       __attribute__((init_priority(XXX)))
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      syntax.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.553.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.555.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.556.1">
     provide this way to control the
    </span>
    <a id="_idIndexMarker170">
    </a>
    <span class="koboSpan" id="kobo.557.1">
     initialization order of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      namespacescope
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     objects across translation units using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.560.1">
      init_priority
     </span>
    </strong>
    <span class="koboSpan" id="kobo.561.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     This
    </span>
    <a id="_idIndexMarker171">
    </a>
    <span class="koboSpan" id="kobo.562.1">
     attribute allows users to assign a relative priority to the initialization, with priority values ranging from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.563.1">
      101
     </span>
    </strong>
    <span class="koboSpan" id="kobo.564.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.565.1">
      65535
     </span>
    </strong>
    <span class="koboSpan" id="kobo.566.1">
     inclusive.
    </span>
    <span class="koboSpan" id="kobo.566.2">
     Lower numbers correspond to higher priority, meaning objects with lower i
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.567.1">
      nit_priority
     </span>
    </strong>
    <span class="koboSpan" id="kobo.568.1">
     values will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.569.1">
      initialized earlier.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.570.1">
     Armed with this knowledge, let’s modify our synthetic example files so that they use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      this extension:
     </span>
    </span>
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.572.1">
     a.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.573.1">
#include "C.h"
__attribute__((init_priority(1000))) C a_c("A");</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.574.1">
     b.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.575.1">
#include "C.h"
__attribute__((init_priority(1001))) C b_c("B");</span></pre>
   <p>
    <span class="koboSpan" id="kobo.576.1">
     Now, regardless of the order in which
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.577.1">
      a.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.578.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.579.1">
      b.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.580.1">
     are introduced to the compiler, the result will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.581.1">
      the same:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.582.1">
&gt; $ g++ main.cpp a.cpp b.cpp -o test
&gt; $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A
&gt; $ g++ main.cpp b.cpp a.cpp -o test
&gt; $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A</span></pre>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     Now, let’s return to our first synthetic application – the one that tried to create global objects but in the same translation unit.
    </span>
    <span class="koboSpan" id="kobo.583.2">
     And also introduced the notion of “constructor” functions.
    </span>
    <span class="koboSpan" id="kobo.583.3">
     Let’s see what happens if we specify initialization priority for one of the global objects, and what the
    </span>
    <a id="_idIndexMarker172">
    </a>
    <span class="koboSpan" id="kobo.584.1">
     order will be in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.585.1">
      that case:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.586.1">
__attribute__((init_priority(1000)))
                             A my_other_a(my_other_string);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.587.1">
     Surprisingly, the output will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.589.1">
A::A : Go away string
constructor fun
A::A : Hello string
Hello, World, Hello string, Go away string
A::~A : Hello string
A::~A : Go away string</span></pre>
   <p>
    <span class="koboSpan" id="kobo.590.1">
     In order to grasp a deeper understanding of the mechanics behind the scenes, and to understand why this scenario happened we run our
    </span>
    <a id="_idIndexMarker173">
    </a>
    <span class="koboSpan" id="kobo.591.1">
     beloved tool on the compiled binary.
    </span>
    <span class="koboSpan" id="kobo.591.2">
     The result confirms our finding as per the following screenshot:
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer016">
     <span class="koboSpan" id="kobo.592.1">
      <img alt="Figure 4.7 – The .init_array section according to gcc with the specified init priority" src="image/B22235_04_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.593.1">
     Figure 4.7 – The .init_array section according to gcc with the specified init priority
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.594.1">
     The output happens to be as it is because the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.595.1">
      .init_array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     section has gained a new member that’s to be executed before the constructor and the standard global
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      initialization code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.598.1">
     It isn’t hard to
    </span>
    <a id="_idIndexMarker174">
    </a>
    <span class="koboSpan" id="kobo.599.1">
     guess that the name of the new function contains the initialization priority.
    </span>
    <span class="koboSpan" id="kobo.599.2">
     What however still baffles the author is why
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.600.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.601.1">
     decided to continuously use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.602.1">
      my_string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.603.1">
     as a postfix for the variable names.
    </span>
    <span class="koboSpan" id="kobo.603.2">
     This must be a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     specificity because the same executable compiled with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.606.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.607.1">
     produces the following
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.608.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.609.1">
       init_array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.610.1">
      section:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer017">
     <span class="koboSpan" id="kobo.611.1">
      <img alt="Figure 4.8 – Clang’s different .init_array section for the same init priority" src="image/B22235_04_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.612.1">
     Figure 4.8 – Clang’s different .init_array section for the same init priority
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.613.1">
     The author has found it interesting why
    </span>
    <a id="_idIndexMarker175">
    </a>
    <span class="koboSpan" id="kobo.614.1">
     there’s such a difference between how
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     handle this critical section of the object file.
    </span>
    <span class="koboSpan" id="kobo.618.2">
     However, without analyzing the source files of these compilers further, this will remain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.619.1">
      a mystery.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor055">
    </a>
    <span class="koboSpan" id="kobo.620.1">
     A library is the delivery room for the birth of
    </span>
    <span class="strikethrough">
     <span class="koboSpan" id="kobo.621.1">
      ideas
     </span>
    </span>
    <span class="koboSpan" id="kobo.622.1">
     unexpected behavior
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     So far, we’ve been the happy parents of a single application.
    </span>
    <span class="koboSpan" id="kobo.623.2">
     Now, the time has come for our lovechild to mature and marry a
    </span>
    <a id="_idIndexMarker176">
    </a>
    <span class="koboSpan" id="kobo.624.1">
     … meaning, in order to adhere to some common sense and more advanced programming practices, we want to factor out some very useful functionality of our synthetic code into a synthetic library and
    </span>
    <a id="_idIndexMarker177">
    </a>
    <span class="koboSpan" id="kobo.625.1">
     call it
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.626.1">
      synth
     </span>
    </strong>
    <span class="koboSpan" id="kobo.627.1">
     .
    </span>
    <span class="koboSpan" id="kobo.627.2">
     Pardon – I
    </span>
    <a id="_idIndexMarker178">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.628.1">
      mean
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.629.1">
       libsinth
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.630.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.631.1">
     And since the main focus of this chapter is still the dissection of code execution before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.633.1">
     (
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.634.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.635.1">
     ),  and since we are happily advocating for gcc (and clang) extensions (2), let’s see what happens if we hitch all these together in an unholy matrimony of code and data.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     As a side note, we’ll use our second synthetic example, where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.637.1">
      a.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.638.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.639.1">
      b.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.640.1">
     remained unchanged from their last stage, which includes the required initialization order.
    </span>
    <span class="koboSpan" id="kobo.640.2">
     We’ll create a new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.641.1">
      main.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.642.1">
     file to utilize the library itself, and we’ll also introduce the library’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.643.1">
      source code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.644.1">
     Our library will be constructed from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.645.1">
      following code:
     </span>
    </span>
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.646.1">
     synth.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.647.1">
#include "C.h"
#include &lt;cstdio&gt;
__attribute__((init_priority(2000))) C synth_c("synth");
__attribute__((constructor)) void welcome_library() {
   printf("welcome to the library\n");
}
void print_synth() {
   printf("print_synth: %s\n", synth_c.get());
}</span></pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.648.1">
     synth.h
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.649.1">
#ifndef SYNTH_H
#define SYNTH_H
void print_synth();
#endif</span></pre>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     Besides defining the
    </span>
    <a id="_idIndexMarker179">
    </a>
    <span class="koboSpan" id="kobo.651.1">
     global object
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.652.1">
      synth_c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.653.1">
     of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      C
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     (as defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.656.1">
      C.h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.657.1">
     header) and has an initialization priority of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.658.1">
      2000
     </span>
    </strong>
    <span class="koboSpan" id="kobo.659.1">
     , we also define a function called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.660.1">
      welcome_library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.661.1">
     marked with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.662.1">
      __attribute__((constructor))
     </span>
    </strong>
    <span class="koboSpan" id="kobo.663.1">
     , ensuring it runs before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.664.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.665.1">
     and prints “welcome to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.666.1">
      the library.”
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.667.1">
     Additionally, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.668.1">
      print_synth
     </span>
    </strong>
    <span class="koboSpan" id="kobo.669.1">
     function prints a message that states the value that was obtained from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.670.1">
      synth_c.get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.671.1">
     .
    </span>
    <span class="koboSpan" id="kobo.671.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.672.1">
      C.h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.673.1">
     header is the one from a few pages prior – it defines the class
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.674.1">
      C
     </span>
    </strong>
    <span class="koboSpan" id="kobo.675.1">
     , along with all the required methods and constructors to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      objects properly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.677.1">
     To use this
    </span>
    <a id="_idIndexMarker180">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     library, we’ll need to create the corresponding underlying infrastructure for it.
    </span>
    <span class="koboSpan" id="kobo.678.2">
     This consists of the two aforementioned files and an application that uses the features exposed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.679.1">
      by it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.680.1">
     To keep on track, we’ll need to modify our main file so that it uses the library’s features.
    </span>
    <span class="koboSpan" id="kobo.680.2">
     However, we also want to keep the test source files we created for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.681.1">
      this scenario.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.682.1">
     So, our application will contain the aforementioned
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.683.1">
      a.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.685.1">
      b.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.686.1">
     files, as well as our new
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.687.1">
       main.cpp
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.688.1">
      file:
     </span>
    </span>
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.689.1">
     main.cpp
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.690.1">
#include "synth.h"
#include "C.h"
__attribute__((constructor)) void welcome_main() {
   printf("welcome to the main\n");
}
C main_c("main") ;
int main() {
   print_synth();
   return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.691.1">
     To make everything work properly, we need to link these items and turn them into a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.692.1">
      working application:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.693.1">
&gt; $ g++ -c -o synth.o synth.cpp
&gt; $ ar rcs libsynth.a synth.o
&gt; $ g++ -o main main.cpp a.cpp b.cpp -L. </span><span class="koboSpan" id="kobo.693.2">-lsynth</span></pre>
   <p>
    <span class="koboSpan" id="kobo.694.1">
     As you can see, at this stage, we’ve created
    </span>
    <a id="_idIndexMarker181">
    </a>
    <span class="koboSpan" id="kobo.695.1">
     a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.696.1">
      static
     </span>
    </strong>
    <span class="koboSpan" id="kobo.697.1">
     library,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.698.1">
      libsynth.a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.699.1">
     , and
    </span>
    <a id="_idIndexMarker182">
    </a>
    <span class="koboSpan" id="kobo.700.1">
     linked our main application to it to incorporate all the code in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.701.1">
      library properly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.702.1">
     Please note that there is no
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.703.1">
      c.cpp
     </span>
    </em>
    <span class="koboSpan" id="kobo.704.1">
     file because, to be as compact as possible, we’ve provided all the implementation of the class in the header file.
    </span>
    <span class="koboSpan" id="kobo.704.2">
     For bigger projects, this isn’t best practice because a small change in the implementation of any functions of the class will require all the files that include the header to be recompiled.
    </span>
    <span class="koboSpan" id="kobo.704.3">
     However, for this very peculiar situation, we can live
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.705.1">
      with it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.706.1">
     Since we’re interested in the order of execution of the various constructs we’ve created, after running the resulting application, we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.707.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.708.1">
&gt; $ ./main
C::C : A
C::C : B
C::C : synth
welcome to the main
C::C : main
welcome to the library
print_synth: synth
C::~C : main
C::~C : synth
C::~C : B
C::~C : A</span></pre>
   <p>
    <span class="koboSpan" id="kobo.709.1">
     To dig a bit deeper into the innards of the freshly compiled executable file, we’ll open it with our beloved tool,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.710.1">
      Ghidra
     </span>
    </strong>
    <span class="koboSpan" id="kobo.711.1">
     , and
    </span>
    <a id="_idIndexMarker183">
    </a>
    <span class="koboSpan" id="kobo.712.1">
     locate the section we’re most interested in: the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.713.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.714.1">
       init_array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.715.1">
      section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.716.1">
     After a quick inspection, we can see that the
    </span>
    <a id="_idIndexMarker184">
    </a>
    <span class="koboSpan" id="kobo.717.1">
     order of the printouts corresponds to the order of the functions in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.718.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.719.1">
       init_array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      section:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer018">
     <span class="koboSpan" id="kobo.721.1">
      <img alt="Figure 4.9 – The .init_array section for different init priorities in different files" src="image/B22235_04_09.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.722.1">
     Figure 4.9 – The .init_array section for different init priorities in different files
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.723.1">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.724.1">
      _GLOBAL__sub_I_welcome_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.725.1">
     is the
    </span>
    <a id="_idIndexMarker185">
    </a>
    <span class="koboSpan" id="kobo.726.1">
     function creating the global object in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.727.1">
      main.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.728.1">
     – that is,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      C main_c("main") ;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     .
    </span>
    <span class="koboSpan" id="kobo.730.2">
     Interesting!
    </span>
    <span class="koboSpan" id="kobo.730.3">
     At this point, we’re convinced that the order of initialization for global objects works even after libraries – at least
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.731.1">
      static ones.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.732.1">
     But we’re still not done.
    </span>
    <span class="koboSpan" id="kobo.732.2">
     Let’s see what happens if we create a shared library.
    </span>
    <span class="koboSpan" id="kobo.732.3">
     That isn’t that complicated.
    </span>
    <span class="koboSpan" id="kobo.732.4">
     After removing the generated files – that is,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.733.1">
      synth.o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.734.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.735.1">
      libsynth.a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.736.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.737.1">
      main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.738.1">
     – so that we have a clean plate, we need to run the following command to create a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.739.1">
      shared library:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.740.1">
&gt; $ g++ -fPIC -c -o  synth.o synth.cpp
&gt; $ g++ -shared -o libsynth.so synth.o
&gt; $ g++ -pie -o main main.cpp a.cpp b.cpp -L. </span><span class="koboSpan" id="kobo.740.2">-lsynth</span></pre>
   <p>
    <span class="koboSpan" id="kobo.741.1">
     Now, we can see how easily those magic switches fall into place from the beginning of this chapter, where we created a shared library and application that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.742.1">
      uses it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.743.1">
     With all these pieces in place, we can see an
    </span>
    <a id="_idIndexMarker186">
    </a>
    <span class="koboSpan" id="kobo.744.1">
     interesting change in how Ghidra presents the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.745.1">
      application overview:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer019">
     <span class="koboSpan" id="kobo.746.1">
      <img alt="Figure 4.10 – The synth library as a dependency, as shown in Ghidra" src="image/B22235_04_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.747.1">
     Figure 4.10 – The synth library as a dependency, as shown in Ghidra
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.748.1">
     Here, we can see a dependency on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.749.1">
      libsynth.so
     </span>
    </strong>
    <span class="koboSpan" id="kobo.750.1">
     library
    </span>
    <a id="_idIndexMarker187">
    </a>
    <span class="koboSpan" id="kobo.751.1">
     we just created.
    </span>
    <span class="koboSpan" id="kobo.751.2">
     Now, we can examine the part that interests us most regarding the executable –
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.752.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.753.1">
       init_array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.754.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer020">
     <span class="koboSpan" id="kobo.755.1">
      <img alt="Figure 4.11 – No reference to libsynth in the .init_array section" src="image/B22235_04_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.756.1">
     Figure 4.11 – No reference to libsynth in the .init_array section
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.757.1">
     There’s no reference at all to the objects and functions in our synth library… No wonder – it’s a library.
    </span>
    <span class="koboSpan" id="kobo.757.2">
     But at least we can still see that our application links to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.758.1">
      library properly:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.759.1">
&gt; $ LD_LIBRARY_PATH=. </span><span class="koboSpan" id="kobo.759.2">ldd ./main
   linux-vdso.so.1 (0x00007fff17387000)
   libsynth.so =&gt; ./libsynth.so (0x00007ea84ee45000)
   libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6</span></pre>
   <p>
    <span class="koboSpan" id="kobo.760.1">
     Please observe that we have to specify
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.761.1">
      LD_LIBRARY_PATH=.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.762.1">
     explicitly to find the library (note that we’ve also truncated unnecessary output lines to keep
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.763.1">
      things clear).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.764.1">
     At this point, we’re curious about what happens when we execute
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.765.1">
      the application:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.766.1">
&gt; $ LD_LIBRARY_PATH=. </span><span class="koboSpan" id="kobo.766.2">./main
C::C : synth
welcome to the library
C::C : A
C::C : B
welcome to the main
C::C : main
print_synth: synth
C::~C : main
C::~C : B
C::~C : A
C::~C : synth</span></pre>
   <p>
    <span class="koboSpan" id="kobo.767.1">
     First, according to the expectations set by the single application test, the object(s) with the specified priority(ies) is(are) created in the library.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     Then, the constructor function from the library is called.
    </span>
    <span class="koboSpan" id="kobo.767.3">
     If there were any other non-prioritized global objects in the library, they would have been created after these, before the prioritized objects from the main application were created and the constructor from the main application was called.
    </span>
    <span class="koboSpan" id="kobo.767.4">
     All these operations were performed before the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     function even had the chance to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.770.1">
      say
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.771.1">
       hush
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.772.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.773.1">
     Almost as we expected it to happen.
    </span>
    <span class="koboSpan" id="kobo.773.2">
     There’s just one dark corner of these function constructor extensions that I’ve been unable to find a cure for at the moment – what if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.774.1">
      a.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.775.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.776.1">
      b.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.777.1">
     contain the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.778.1">
      following lines?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.779.1">
__attribute__((constructor)) void welcome_a() {
   printf("welcome to the 'a' file\n"); }
__attribute__((constructor)) void welcome_b() {
   printf("welcome to the 'b' file\n"); }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.780.1">
     This unholy scribbling of spooky code adds two more constructor functions to our executable.
    </span>
    <span class="koboSpan" id="kobo.780.2">
     Now, we have three.
    </span>
    <span class="koboSpan" id="kobo.780.3">
     If you want to have a predictable order of execution for these constructor functions too, you need to specify their priority using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.781.1">
      __attribute__((constructor(205))) void welcome_b()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.782.1">
     .
    </span>
    <span class="koboSpan" id="kobo.782.2">
     This will guarantee that these functions will also be executed in a specific order and that you’re not facing the global constructor invoking
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.783.1">
      order fiasco.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.784.1">
     The behavior in case the library was dynamically loaded (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.785.1">
      dlopen
     </span>
    </strong>
    <span class="koboSpan" id="kobo.786.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.787.1">
      dlclose
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     ) is the one that one would expect, i.e.
    </span>
    <span class="koboSpan" id="kobo.788.2">
     it follows the execution flow of the main application, and at the point where the library is loaded, it will jump and execute the various constructors and object initializations from the library.
    </span>
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor056">
    </a>
    <span class="koboSpan" id="kobo.789.1">
     Famous last words
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.790.1">
     This chapter dealt with code that is executed before the main function.
    </span>
    <span class="koboSpan" id="kobo.790.2">
     However the same attention would require the topic
    </span>
    <a id="_idIndexMarker188">
    </a>
    <span class="koboSpan" id="kobo.791.1">
     covering the code that is executed after the main function, but that debate will go in a different chapter, in a different book.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.792.1">
     But just to spoil you, here’s a small hint: the same way as there are constructor functions, there are also destructor functions.
    </span>
    <span class="koboSpan" id="kobo.792.2">
     They’re not like C++ destructors – more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.793.1">
      like
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.794.1">
       __attribute__((destructor))
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.795.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.796.1">
     Spicing those up with the standard application exit routines, we have twice as much fun as the startup because we have to consider a myriad of other alternatives, such as functions registered for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      std::atexit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.798.1">
     (or even
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.799.1">
      std::quick_exit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.800.1">
     ), or abnormal program termination.
    </span>
    <span class="koboSpan" id="kobo.800.2">
     For example, let’s say an exception is thrown in a destructor or we use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      std::terminate
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.802.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.803.1">
       std::abort
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.805.1">
     The documentation
    </span>
    <a id="_idIndexMarker189">
    </a>
    <span class="koboSpan" id="kobo.806.1">
     on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.807.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.808.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.809.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.810.1">
     offers a
    </span>
    <a id="_idIndexMarker190">
    </a>
    <span class="koboSpan" id="kobo.811.1">
     nice escapade from the standard world, and any good book on C++ will offer a great overview of the standard termination routines, so please head over to them for a good lecture.
    </span>
    <span class="koboSpan" id="kobo.811.2">
     A combination of these two will provide the best overview of how applications start
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.812.1">
      and exit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.813.1">
     For now, we’ll shift our attention toward other platforms before we get a good wigging from the folks at Packt – instead of the agreed-upon 16 pages for this chapter, we’re already at 22 and covered only half of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.814.1">
      promised subject.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor057">
    </a>
    <span class="koboSpan" id="kobo.815.1">
     Let’s open the Windows (unless you’re on ISS)
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.816.1">
     Before we delve deep into the internals of how an application is executed under Windows and the steps we must take to reach our main function, please note that from C++’s point of view, there should be no real difference from Linux or any other operating system.
    </span>
    <span class="koboSpan" id="kobo.816.2">
     The C++-only standard functionality is (should be) identical to the functionality presented in the previous pages, so we won’t repeat the same
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      information here.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.818.1">
     We will, however, present how and why the application starts under Windows the way it does and present some techniques that can directly influence this behavior, just like we did under Linux.
    </span>
    <span class="koboSpan" id="kobo.818.2">
     We’ll also be using a Visual Studio compiler since
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.819.1">
      gcc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.820.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.821.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.822.1">
     for Windows behave identically, so there’s no sense in presenting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.823.1">
      them again.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.824.1">
     Due to its closed nature, to understand process creation under Windows, we need to resort to the few available resources that deal with this kind of information.
    </span>
    <span class="koboSpan" id="kobo.824.2">
     One of these resources is the best book I’ve managed to find in this domain:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.825.1">
      Windows Internals, 7th edition (Part 1)
     </span>
    </em>
    <span class="koboSpan" id="kobo.826.1">
     ,
    </span>
    <span class="superscript">
     <span id="footnote-010-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-010">
       <span class="koboSpan" id="kobo.827.1">
        7
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.828.1">
     by Pavel Yosifovich, Alex Ionescu, Mark E.
    </span>
    <span class="koboSpan" id="kobo.828.2">
     Russinovich, and David
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.829.1">
      A.
     </span>
     <span class="koboSpan" id="kobo.829.2">
      Solomon.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-010">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-010-backlink">
      <span class="koboSpan" id="kobo.830.1">
       7
      </span>
     </a>
     <a href="https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals">
      <span class="koboSpan" id="kobo.831.1">
       https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.832.1">
     The information gathered from that book is complemented by various scraps gathered from the world wide internet, and filtered in order to offer our readers a light introduction to the Windows side of process creation.
    </span>
    <span class="koboSpan" id="kobo.832.2">
     We will reference back however some of the notions encountered in the Linux subsection of this chapter, so reading it would be beneficial.
    </span>
    <span class="koboSpan" id="kobo.832.3">
     Also, a small observation: security, thread handling, and user management are much more fine-tuned in Windows than in Linux, and all this is reflected in the way processes are treated.
    </span>
    <span class="koboSpan" id="kobo.832.4">
     If you’re interested in understanding this domain, there are several resources available, such as the excellent
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.833.1">
      Windows Security Internals: A Deep Dive into Windows Authentication, Authorization, and Auditing
     </span>
    </em>
    <span class="koboSpan" id="kobo.834.1">
     , by James Forshaw.
    </span>
    <span class="koboSpan" id="kobo.834.2">
     We recommend reading through it if you’re interested in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.835.1">
      the domain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.836.1">
     Let’s get back to the processes.
    </span>
    <span class="koboSpan" id="kobo.836.2">
     The process creation mechanism in Windows involves several stages that are executed by different components of the operating system: the Windows client-side library,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.837.1">
      kernel32.dll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.838.1">
     , the
    </span>
    <a id="_idIndexMarker191">
    </a>
    <span class="koboSpan" id="kobo.839.1">
     Windows executive, and the Windows subsystem
    </span>
    <a id="_idIndexMarker192">
    </a>
    <span class="koboSpan" id="kobo.840.1">
     process (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.841.1">
      csrss.exe
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.842.2">
     Due to the simple fact that we don’t have access to the sources of these Windows components, our presentation on this matter will be a very
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.843.1">
      high-level one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.844.1">
     Processes in Windows are created by a function of the CreateProcess family, which comes with several relatives and uncles (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.845.1">
      create process
     </span>
    </strong>
    <span class="koboSpan" id="kobo.846.1">
     as a different user, create process with various security clearances, etc…) but all members of the extended family routines after several iterations end up in the  CreateProcessInternalW function in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.847.1">
      kernel32.dll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.848.1">
     , which first validates and converts some of the parameters and flags to an internal representation (to which sadly we have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.849.1">
      no access).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.850.1">
     The priority class for the new process is determined by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.851.1">
      CreationFlags
     </span>
    </strong>
    <span class="koboSpan" id="kobo.852.1">
     parameter.
    </span>
    <span class="koboSpan" id="kobo.852.2">
     In Windows, there are six priority classes: Idle, Below Normal, Normal, Above Normal, High, and Real-time.
    </span>
    <span class="koboSpan" id="kobo.852.3">
     If no priority class is specified, the priority class defaults to Normal.
    </span>
    <span class="koboSpan" id="kobo.852.4">
     If Real-time is requested but the caller lacks the necessary privileges, the priority is downgraded
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.853.1">
      to High.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.854.1">
     Next,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.855.1">
      kernel32.dll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.856.1">
     initiates a connection to the native debugging interface if the process is to be debugged and sets the default hard error mode if specified.
    </span>
    <span class="koboSpan" id="kobo.856.2">
     The user-specified attribute list is converted into its native format, and any additional internal attributes are added.
    </span>
    <span class="koboSpan" id="kobo.856.3">
     The security attributes for the process and initial thread are also converted into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.857.1">
      internal representations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.858.1">
     The next step is to open the executable image to be run.
    </span>
    <span class="koboSpan" id="kobo.858.2">
     This task is handled within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      NtCreateUserProcess
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     system call.
    </span>
    <span class="koboSpan" id="kobo.860.2">
     First, the function validates the arguments again to ensure they haven’t been tampered with.
    </span>
    <span class="koboSpan" id="kobo.860.3">
     Then, it attempts to find and open the appropriate Windows image and create a section object, which will be mapped into the new process’s address space at a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.861.1">
      later date.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.862.1">
     If the image isn’t a valid Windows executable, the function searches for a support image to run it.
    </span>
    <span class="koboSpan" id="kobo.862.2">
     For instance, if the executable is an MS-DOS or Win16 application, it uses
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.863.1">
      ntvdm.exe
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     (for 32-bit Windows) to
    </span>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.865.1">
     run it.
    </span>
    <span class="koboSpan" id="kobo.865.2">
     This ensures that older DOS or Win16 applications can be executed correctly within the Windows environment.
    </span>
    <span class="koboSpan" id="kobo.865.3">
     However, this feature has been slowly deprecated on modern Windows systems, so you need to enable it so that it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.866.1">
      can function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.867.1">
     Once the executable image has been opened, the next stage is to create the Windows executive process object.
    </span>
    <span class="koboSpan" id="kobo.867.2">
     This involves setting up the process’s virtual address space and other critical structures.
    </span>
    <span class="koboSpan" id="kobo.867.3">
     The executive process object serves as a container for all the resources needed by the process, including memory, handles,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.868.1">
      and threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     With the process object in place, the initial thread is created.
    </span>
    <span class="koboSpan" id="kobo.869.2">
     This step involves setting up the thread’s stack, context, and executive thread object.
    </span>
    <span class="koboSpan" id="kobo.869.3">
     The thread is responsible for executing the program’s entry point and managing the process’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.870.1">
      execution flow.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.871.1">
     After the initial thread is created, Windows performs subsystem-specific initialization tasks.
    </span>
    <span class="koboSpan" id="kobo.871.2">
     These tasks are essential for integrating the new process into the Windows subsystem, which provides the environment and resources necessary for the process to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.872.1">
      run correctly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.873.1">
     The initial thread is then started, unless the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      CREATE_SUSPENDED
     </span>
    </strong>
    <span class="koboSpan" id="kobo.875.1">
     flag is specified, in which case the thread remains suspended until it’s explicitly resumed.
    </span>
    <span class="koboSpan" id="kobo.875.2">
     Starting the thread involves switching to user mode and executing the process’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.876.1">
      entry point.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.877.1">
     Finally, in the context of the new process and thread, the address space is initialized.
    </span>
    <span class="koboSpan" id="kobo.877.2">
     This includes loading any required DLLs and performing any other necessary setup tasks.
    </span>
    <span class="koboSpan" id="kobo.877.3">
     Once these steps are complete, the process begins executing its code, and process creation is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.878.1">
      considered complete.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor058">
    </a>
    <span class="koboSpan" id="kobo.879.1">
     To PE or not to PE
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.880.1">
     Like every other file with a specific meaning, the bytes that conjure up Windows-based executables also have a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.881.1">
      special meaning.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.882.1">
     The Windows
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.883.1">
      Portable Executable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.884.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.885.1">
      PE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.886.1">
     ) format
    </span>
    <a id="_idIndexMarker194">
    </a>
    <span class="koboSpan" id="kobo.887.1">
     is a file format for executables, object code, DLLs, and other system files that are used in Windows operating systems.
    </span>
    <span class="koboSpan" id="kobo.887.2">
     It’s the standard file format for executables in
    </span>
    <a id="_idIndexMarker195">
    </a>
    <span class="koboSpan" id="kobo.888.1">
     DOS (as well as FreeDOS), Windows, and ReactOS and
    </span>
    <a id="_idIndexMarker196">
    </a>
    <span class="koboSpan" id="kobo.889.1">
     encompasses both the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.890.1">
      executable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.892.1">
      EXE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.893.1">
     ) and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.894.1">
      Dynamic Link Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.895.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.896.1">
      DLL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     )
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.898.1">
      file types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.899.1">
     The PE
    </span>
    <a id="_idIndexMarker197">
    </a>
    <span class="koboSpan" id="kobo.900.1">
     format is designed to be extensible and capable of supporting modern operating system features.
    </span>
    <span class="koboSpan" id="kobo.900.2">
     If you’re interested in this domain, there are excellent learning opportunities online, so we encourage you to study this subject since this book can’t encompass all the required information due to lack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.901.1">
      of space.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.902.1">
     Here’s a filtered explanation of its structure and components, mostly the ones relevant to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.903.1">
      this chapter:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.904.1">
       DOS
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.905.1">
        header (IMAGE_DOS_HEADER)
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.906.1">
       :
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.907.1">
       The file begins
      </span>
      <a id="_idIndexMarker198">
      </a>
      <span class="koboSpan" id="kobo.908.1">
       with
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.909.1">
        MZ
       </span>
      </strong>
      <span class="koboSpan" id="kobo.910.1">
       , the initials of Mark Zbikowski, the engineer who created this format while working at Microsoft.
      </span>
      <span class="koboSpan" id="kobo.910.2">
       This is followed by a DOS header, which is a relic from the MS-DOS days.
      </span>
      <span class="koboSpan" id="kobo.910.3">
       This header includes a small DOS stub program that displays a message (“This program can’t be run in DOS mode”) if the executable is run in a DOS environment.
      </span>
      <span class="koboSpan" id="kobo.910.4">
       The last section of the DOS header contains a pointer to the PE
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.911.1">
        header’s location.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.912.1">
       PE
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.913.1">
        header (IMAGE_NT_HEADERS)
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.914.1">
       :
      </span>
     </span>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.915.1">
         Signature
        </span>
       </strong>
       <span class="koboSpan" id="kobo.916.1">
        : This
       </span>
       <a id="_idIndexMarker199">
       </a>
       <span class="koboSpan" id="kobo.917.1">
        identifies the file as a PE file.
       </span>
       <span class="koboSpan" id="kobo.917.2">
        The signature is a 4-byte value – that
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.918.1">
         is,
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.919.1">
          PE\0\0
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.920.1">
         .
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.921.1">
         File header
        </span>
       </strong>
       <span class="koboSpan" id="kobo.922.1">
        (
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.923.1">
         IMAGE_FILE_HEADER
        </span>
       </strong>
       <span class="koboSpan" id="kobo.924.1">
        ): This contains basic information about the file, such as the
       </span>
       <a id="_idIndexMarker200">
       </a>
       <span class="koboSpan" id="kobo.925.1">
        target machine type, the number of sections, the time and date the file was created, and the size of the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.926.1">
         optional header.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.927.1">
         Optional header
        </span>
       </strong>
       <span class="koboSpan" id="kobo.928.1">
        (
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.929.1">
         IMAGE_OPTIONAL_HEADER
        </span>
       </strong>
       <span class="koboSpan" id="kobo.930.1">
        ): This provides essential information for loading and
       </span>
       <a id="_idIndexMarker201">
       </a>
       <span class="koboSpan" id="kobo.931.1">
        running the program.
       </span>
       <span class="koboSpan" id="kobo.931.2">
        Despite its name, this header is required for executable files and includes the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.932.1">
         following aspects:
        </span>
       </span>
       <ul>
        <li>
         <strong class="bold">
          <span class="koboSpan" id="kobo.933.1">
           Magic number
          </span>
         </strong>
         <span class="koboSpan" id="kobo.934.1">
          : Identifies the format (for example, PE32 for 32-bit and PE32+
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.935.1">
           for 64-bit)
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.936.1">
           AddressOfEntryPoint
          </span>
         </strong>
         <span class="koboSpan" id="kobo.937.1">
          : The address where
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.938.1">
           execution starts
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.939.1">
           ImageBase
          </span>
         </strong>
         <span class="koboSpan" id="kobo.940.1">
          : The preferred base address for the executable
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.941.1">
           in memory
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.942.1">
           SectionAlignment
          </span>
         </strong>
         <span class="koboSpan" id="kobo.943.1">
          : Alignment of sections
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.944.1">
           in memory.
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.945.1">
           SizeOfImage
          </span>
         </strong>
         <span class="koboSpan" id="kobo.946.1">
          : The total size of the image
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.947.1">
           in memory
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.948.1">
           Subsystem
          </span>
         </strong>
         <span class="koboSpan" id="kobo.949.1">
          : Identifies
         </span>
         <a id="_idIndexMarker202">
         </a>
         <span class="koboSpan" id="kobo.950.1">
          the required subsystem (Windows GUI
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.951.1">
           or CUI)
          </span>
         </span>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.952.1">
       Section
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.953.1">
        headers (IMAGE_SECTION_HEADER)
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.954.1">
       :
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.955.1">
       Following the PE header, there are one or more section headers, each describing a section of the file.
      </span>
      <span class="koboSpan" id="kobo.955.2">
       These sections contain the actual data and code of the program.
      </span>
      <span class="koboSpan" id="kobo.955.3">
       The following are some
      </span>
      <a id="_idIndexMarker203">
      </a>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.956.1">
        common sections:
       </span>
      </span>
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.957.1">
         .text
        </span>
       </strong>
       <span class="koboSpan" id="kobo.958.1">
        : Contains
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.959.1">
         executable code.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.960.1">
         .data
        </span>
       </strong>
       <span class="koboSpan" id="kobo.961.1">
        : Contains initialized global and
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.962.1">
         static variables.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.963.1">
         .bss
        </span>
       </strong>
       <span class="koboSpan" id="kobo.964.1">
        : Contains
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.965.1">
         uninitialized data.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.966.1">
         .rdata
        </span>
       </strong>
       <span class="koboSpan" id="kobo.967.1">
        : Read-only data (such as string literals
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.968.1">
         and constants).
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.969.1">
         .idata
        </span>
       </strong>
       <span class="koboSpan" id="kobo.970.1">
        :  Import table, listing the functions and DLLs that the executable depends on.
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.971.1">
         .edata
        </span>
       </strong>
       <span class="koboSpan" id="kobo.972.1">
        :  Export table, listing functions and data that the executable exposes to other modules.
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.973.1">
        Data directories
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.974.1">
       :
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.975.1">
       Part of the optional header, these
      </span>
      <a id="_idIndexMarker204">
      </a>
      <span class="koboSpan" id="kobo.976.1">
       directories provide information about the location and size of various tables and data structures within the executable file, including:
      </span>
     </p>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.977.1">
         Import table
        </span>
       </strong>
       <span class="koboSpan" id="kobo.978.1">
        : Lists the DLLs and
       </span>
       <a id="_idIndexMarker205">
       </a>
       <span class="koboSpan" id="kobo.979.1">
        functions imported by
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.980.1">
         the executable.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.981.1">
         Export table
        </span>
       </strong>
       <span class="koboSpan" id="kobo.982.1">
        : Lists the
       </span>
       <a id="_idIndexMarker206">
       </a>
       <span class="koboSpan" id="kobo.983.1">
        functions and data exported by
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.984.1">
         the executable.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.985.1">
         Resource table
        </span>
       </strong>
       <span class="koboSpan" id="kobo.986.1">
        : Contains
       </span>
       <a id="_idIndexMarker207">
       </a>
       <span class="koboSpan" id="kobo.987.1">
        resources that are built into the application, such as icons, menus, and dialogs.
       </span>
       <span class="koboSpan" id="kobo.987.2">
        These resources are stored in a resource tree, depending on their type.
       </span>
       <span class="koboSpan" id="kobo.987.3">
        There’s also support for variations in multiple languages for the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.988.1">
         same resource.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.989.1">
         Exception table
        </span>
       </strong>
       <span class="koboSpan" id="kobo.990.1">
        : Contains
       </span>
       <a id="_idIndexMarker208">
       </a>
       <span class="koboSpan" id="kobo.991.1">
        information for
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.992.1">
         exception handling.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.993.1">
         Relocation table
        </span>
       </strong>
       <span class="koboSpan" id="kobo.994.1">
        : Used
       </span>
       <a id="_idIndexMarker209">
       </a>
       <span class="koboSpan" id="kobo.995.1">
        for
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.996.1">
         address fixups.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.997.1">
        Sections
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.998.1">
       :
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.999.1">
       The actual sections
      </span>
      <a id="_idIndexMarker210">
      </a>
      <span class="koboSpan" id="kobo.1000.1">
       follow the headers and contain the executable code, initialized data, and other components that the program needs
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1001.1">
        to run.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1002.1">
       Each section is aligned based on the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1003.1">
        SectionAlignment
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1004.1">
       value specified in the
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1005.1">
        optional header.
       </span>
      </span>
     </p>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1006.1">
     For us, the most important and interesting part of this list of sections and subsections is the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1007.1">
       AddressOfEntryPoint
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1008.1">
      field.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor059">
    </a>
    <span class="koboSpan" id="kobo.1009.1">
     Getting our hands dirty
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1010.1">
     Our initial approach will be a very clean
    </span>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.1011.1">
     application to work on, a classical “Hello World!”
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello World!\n";
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1013.1">
     This will allow us to understand how a very simple application is loaded and executed under Windows.
    </span>
    <span class="koboSpan" id="kobo.1013.2">
     However, before taking things further, a small remark: under Windows, there are different kinds of applications, as indicated by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1014.1">
      OptionalHeader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1015.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1016.1">
      Subsystem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1017.1">
     field in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1018.1">
      PE header.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1019.1">
     For our purpose, which is to dissect an application to examine how it starts, we’ll create a Console Application.
    </span>
    <span class="koboSpan" id="kobo.1019.2">
     There are other types of applications we could look at, but they’re overly complex.
    </span>
    <span class="koboSpan" id="kobo.1019.3">
     For example, if they have a GUI, then we must implement complicated message loops and dependencies, so we’ll stick with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1020.1">
      something simple.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1021.1">
     Assuming that we’ve successfully
    </span>
    <a id="_idIndexMarker212">
    </a>
    <span class="koboSpan" id="kobo.1022.1">
     compiled our synthetic console application, we can fire up Ghidra and see that a large section of the file resembles the standard PE header
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1023.1">
      shown previously:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer021">
     <span class="koboSpan" id="kobo.1024.1">
      <img alt="Figure 4.12 – The contents of the PE header" src="image/B22235_04_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1025.1">
     Figure 4.12 – The contents of the PE header
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1026.1">
     This is a lot of information to digest, but what’s interesting for us is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1027.1">
      AddressOfEntryPoint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1028.1">
     field.
    </span>
    <span class="koboSpan" id="kobo.1028.2">
     At the moment, it points to a method called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1029.1">
      entry
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1030.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1030.2">
     This is where our application will start executing, so let’s examine this function in a bit more detail.
    </span>
    <span class="koboSpan" id="kobo.1030.3">
     If we dig deeper and
    </span>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.1031.1">
     see what the entry is, we’ll reach the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1032.1">
      following function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1033.1">
ulong __cdecl entry(void *param_1) {
  ulong uVar1;
  uVar1 = __scrt_common_main();
  return uVar1;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1034.1">
     This in itself is an interesting discovery as it seems to be the entry point of console-based Windows applications.
    </span>
    <span class="koboSpan" id="kobo.1034.2">
     Let’s explore this further.
    </span>
    <span class="koboSpan" id="kobo.1034.3">
     The next function that’s run is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1035.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
int __cdecl __scrt_common_main(void) {
  int iVar1;
   __security_init_cookie();
  iVar1 = __scrt_common_main_seh();
  return iVar1;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1037.1">
     Microsoft’s page
    </span>
    <span class="superscript">
     <span id="footnote-009-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-009">
       <span class="koboSpan" id="kobo.1038.1">
        8
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.1039.1">
     contains a detailed description of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1040.1">
      __security_init_cookie()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1041.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1041.2">
     However, the other function is a different kind of beast.
    </span>
    <span class="koboSpan" id="kobo.1041.3">
     It does a large amount of initialization, such as setting up the terminal and handling initialization errors.
    </span>
    <span class="koboSpan" id="kobo.1041.4">
     At some point, the following piece of code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1042.1">
      is executed:
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-009">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-009-backlink">
      <span class="koboSpan" id="kobo.1043.1">
       8
      </span>
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">
      <span class="koboSpan" id="kobo.1044.1">
       https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170
      </span>
     </a>
    </p>
   </div>
   <div>
    <div class="IMG---Figure" id="_idContainer022">
     <span class="koboSpan" id="kobo.1045.1">
      <img alt="Figure 4.13 – The invocation of main()" src="image/B22235_04_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1046.1">
     Figure 4.13 – The invocation of main()
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1047.1">
     As you may
    </span>
    <a id="_idIndexMarker214">
    </a>
    <span class="koboSpan" id="kobo.1048.1">
     have guessed,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1049.1">
      invoke_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1050.1">
     is responsible for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1051.1">
      invoking
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1052.1">
       main()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1053.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1054.1">
int __cdecl invoke_main(void) {
  char **_Argv;
  char **_Env;
  undefined4 *puVar1;
  int *piVar2;
  int iVar3;
  _Env = (char **)__get_initial_narrow_environment();
  puVar1 = (undefined4 *)___p___argv();
  _Argv = (char **)*puVar1;
  piVar2 = (int *)___p___argc();
  iVar3 = main(*piVar2,_Argv,_Env);
  return iVar3;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1055.1">
     At this point, we’ve reached the stage where our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1056.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1057.1">
     function is called.
    </span>
    <span class="koboSpan" id="kobo.1057.2">
     Even for a simple “Hello World!”
    </span>
    <span class="koboSpan" id="kobo.1057.3">
     application, there’s a large amount of boilerplate code that needs to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1058.1">
      be executed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1059.1">
     Now, it’s time to go one step further and take our synthetic application on a ride through Ghidra (for brevity’s sake, we’ll omit that we must create a project, compile it, and link the application; let’s just assume the application summons itself
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1060.1">
      by magic).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1061.1">
     Since we’re mostly interested in determining the order of function calls before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1062.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1063.1">
     , and we know that we initialize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1064.1">
      my_a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1065.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1066.1">
      my_other_a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1067.1">
     variables globally, we need to look through the binary.
    </span>
    <span class="koboSpan" id="kobo.1067.2">
     At some point, we’ll spot the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1068.1">
      interesting data:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer023">
     <span class="koboSpan" id="kobo.1069.1">
      <img alt="Figure 4.14 – The .CRT$XCU section according to Ghidra" src="image/B22235_04_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1070.1">
     Figure 4.14 – The .CRT$XCU section according to Ghidra
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1071.1">
     Well, this looks interesting, especially
    </span>
    <a id="_idIndexMarker215">
    </a>
    <span class="koboSpan" id="kobo.1072.1">
     that cryptic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1073.1">
      .CRT$XCU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1074.1">
     text.
    </span>
    <span class="koboSpan" id="kobo.1074.2">
     This takes us back to a few paragraphs prior, where the sections of a PE file were discussed: sections are distinct areas within the executable file that hold different types of data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1075.1">
      and code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1076.1">
     Each section serves a specific purpose and has attributes that define its behavior and how it should be handled by the operating system.
    </span>
    <span class="koboSpan" id="kobo.1076.2">
     There’s excellent documentation
    </span>
    <span class="superscript">
     <span id="footnote-008-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-008">
       <span class="koboSpan" id="kobo.1077.1">
        9
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.1078.1">
     on Microsoft’s site that discusses the sections responsible for initializing CRT, a quick summary of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1079.1">
      it follows.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-008">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-008-backlink">
      <span class="koboSpan" id="kobo.1080.1">
       9
      </span>
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170">
      <span class="koboSpan" id="kobo.1081.1">
       https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.1082.1">
     According to the documentation, by default, the CRT library is included via the linker, which ensures that the CRT is initialized properly, global initializers are called, and, subsequently, the user-defined
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1083.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1084.1">
     function is executed.
    </span>
    <span class="koboSpan" id="kobo.1084.2">
     When the compiler encounters a global initializer, it creates a dynamic initializer and places it in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1085.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1086.1">
       CRT$XCU
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1087.1">
      section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1088.1">
     The CRT uses specific pointers such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1089.1">
      __xc_a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1090.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1091.1">
      __xc_z
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1092.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1093.1">
      .CRT$XCA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1094.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1095.1">
      .CRT$XCZ
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1096.1">
     initialization sections to define the start and end of the list of initializers, ensuring they’re called in the correct order.
    </span>
    <span class="koboSpan" id="kobo.1096.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1097.1">
      __scrt_common_main_seh()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1098.1">
     function, which we discussed previously, is responsible for setting these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1099.1">
      up correctly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1100.1">
     These names are predefined by the CRT, and the linker arranges these sections alphabetically.
    </span>
    <span class="koboSpan" id="kobo.1100.2">
     This ordering ensures that user-defined initializers in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1101.1">
      .CRT$XCU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1102.1">
     are executed between the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1103.1">
      standard sections.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1104.1">
     To manipulate the initialization order, developers can place their initializers in unused reserved sections such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1105.1">
      .CRT$XCT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1106.1">
     (before compiler-generated initializers) and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1107.1">
      .CRT$XCV
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1108.1">
     (after compiler-generated initializers) using specific pragmas, as detailed in the CRT startup documentation mentioned a few paragraphs prior, but before jumping on that technique, please read below because things are a bit more complicated than they seem.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1109.1">
     According to Microsoft, that subject is so platform and compiler-specific that we don’t wish to explore those fields, especially considering the warning that comes from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1110.1">
      official site:
     </span>
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.1111.1">
     “The names .CRT$XCT and .CRT$XCV aren’t used by either the compiler or the CRT library right now, but there’s no guarantee that they’ll remain unused in the future.
    </span>
    <span class="koboSpan" id="kobo.1111.2">
     And, your variables could still be optimized away by the compiler.
    </span>
    <span class="koboSpan" id="kobo.1111.3">
     Consider the potential engineering, maintenance, and portability issues before adopting this technique.”
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1112.1">
     So, once again, we’ll just
    </span>
    <a id="_idIndexMarker216">
    </a>
    <span class="koboSpan" id="kobo.1113.1">
     repeat what the official warning said: unless you have to do this kind of hackery, please refrain from using these halfheartedly documented “features” of the language and compiler since (again, as mentioned in the official warning) there’s no guarantee that if it works today, it will work tomorrow, or even after the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1114.1">
      system update.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1115.1">
     Instead, let’s turn our attention toward the functions that we “discovered” in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1116.1">
      .CRT$XCU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1117.1">
     section and see what kind of sorcery lies behind this very explicit name, which undoubtedly isn’t standard C (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1118.1">
      nor C++):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1119.1">
void __cdecl `dynamic_initializer_for_'my_a''(void)
{
int iVar1;
uchar *unaff_EDI;
undefined4 *puVar2;
  puVar2 = (undefined4 *)&amp;stack0xfffffffc;
for (iVar1 = 0; iVar1 != 0; iVar1 = iVar1 + -1) {
   *puVar2 = 0xcccccccc;
   puVar2 = puVar2 + 1;
}
__CheckForDebuggerJustMyCode(unaff_EDI);
A::A(&amp;my_a,my_string);
atexit(`dynamic_atexit_destructor_for_'my_a'');
return;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1120.1">
     After performing some maintenance tasks (such as initializing the stack with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1121.1">
      0xcccccccc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1122.1">
     value), we can see the function call to the constructor of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1123.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1124.1">
     , with stylishly the first parameter being the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1125.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1126.1">
     object, and registering an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1127.1">
      atexit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1128.1">
     function for the destructor of the class for the specific object, again.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1129.1">
     This
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1130.1">
      0xcccccccc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1131.1">
     pattern
    </span>
    <a id="_idIndexMarker217">
    </a>
    <span class="koboSpan" id="kobo.1132.1">
     is the
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.1133.1">
     typical way the Visual C++ compiler marks uninitialized stack memory, making it easier to detect the use of uninitialized memory in debugging sessions.
    </span>
    <span class="koboSpan" id="kobo.1133.2">
     Interestingly, the loop doesn’t seem to execute.
    </span>
    <span class="koboSpan" id="kobo.1133.3">
     However, if we were to dig deeper into the debug builds of functions that have larger C-style arrays, we’d see this stack protection scheme in action, together with some nicely set-up
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1134.1">
      stack canaries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1135.1">
     Stack
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.1136.1">
     canaries are a security mechanism designed to detect and prevent stack-based buffer overflow attacks by placing a special value (called the canary) between a function's local variables and its control data on the stack (such as the return address and the saved frame pointer).
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1137.1">
     If a buffer overflow occurs, the canary value is altered, signaling that some mischief has taken place.
    </span>
    <span class="koboSpan" id="kobo.1137.2">
     This allows the program to take corrective actions, such as terminating execution to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1138.1">
      prevent exploitation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1139.1">
     The origin of this term is a bit obscure, and it goes back to the historical use of canaries in coal mines.
    </span>
    <span class="koboSpan" id="kobo.1139.2">
     Miners would bring canaries into the mines to detect toxic gases such as carbon monoxide.
    </span>
    <span class="koboSpan" id="kobo.1139.3">
     Since canaries are more sensitive to these gases than humans, if the bird became ill or died (that is, it stopped singing), it served as an early warning signal for miners to evacuate.
    </span>
    <span class="koboSpan" id="kobo.1139.4">
     This isn’t quite of mythological proportions, but it’s pragmatic – especially if you’re the miner, not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1140.1">
      the canary.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1141.1">
     With these notions set in place, we have an overview of how the application loads under Windows, but only from the console.
    </span>
    <span class="koboSpan" id="kobo.1141.2">
     But let’s not forget that Windows is a GUI environment.
    </span>
    <span class="koboSpan" id="kobo.1141.3">
     It creates windows and dialogs, has a message loop, and deals with a plethora
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1142.1">
      of events.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1143.1">
     However, the startup process of a Windows GUI application isn’t that dissimilar to a console-based application.
    </span>
    <span class="koboSpan" id="kobo.1143.2">
     The main difference is that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1144.1">
      invoke_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1145.1">
     function invokes two different functions before invoking a GUI-specific
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1146.1">
      WinMain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1147.1">
     function, dealing with the show state of the window and the command
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1148.1">
      line options.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1149.1">
     The first function allows us to show the window of the application in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1150.1">
      different ways.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1151.1">
     The second function is the command line of the application, in a wide
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1152.1">
      string format.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1153.1">
     The rest is just
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.1154.1">
     calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1155.1">
      WinMain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1156.1">
     and from there, we are in familiar territory, at least programmers who have experience in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1157.1">
      this domain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1158.1">
     In closing this chapter, there’s nothing else but encourage our readers to experiment while hacking around binaries – that’s the only way to truly understand how a specific functionality will behave on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1159.1">
      your system.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-61">
    <a id="_idTextAnchor060">
    </a>
    <span class="koboSpan" id="kobo.1160.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1161.1">
     In this chapter, the author tried to provide a not-so-comprehensive overview of the application startup processes on both Linux and Windows.
    </span>
    <span class="koboSpan" id="kobo.1161.2">
     The insights that were provided into the initial stages of execution, including the critical steps before reaching the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1162.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1163.1">
     function, weren’t as complete as the platforms themselves require, but then this book would have been called something else since this is a huge and very niche topic that doesn’t attract a broad range
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1164.1">
      of programmers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1165.1">
     By exploring ELF on Linux, understanding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1166.1">
      execve()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1167.1">
     system call, and examining the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1168.1">
      _start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1169.1">
     function, you gained valuable knowledge about the underlying architecture and initialization routines.
    </span>
    <span class="koboSpan" id="kobo.1169.2">
     Similarly, the discussion on Windows highlighted the startup sequence for both console-based and GUI applications, emphasizing the role of the various sections and how they come together to start that pesky program of yours, especially if it’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1170.1">
      not working.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1171.1">
     By leaving a window of opportunity open to further deepen the understanding of this topic, we recommended that you engage in hands-on experimentation by creating and analyzing binaries, modifying startup routines, and observing the effects on different operating systems.
    </span>
    <span class="koboSpan" id="kobo.1171.2">
     You even can manually change various addresses in the headers of executables to see what happens and how
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1172.1">
      they crash.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1173.1">
     This practical approach will not only reinforce the concepts that were covered in this chapter but also provide you with a more profound and practical grasp of application startup processes.
    </span>
    <span class="koboSpan" id="kobo.1173.2">
     By actively exploring and experimenting, you’ll enhance your ability to troubleshoot, optimize, and innovate within the realm of software development while learning useful and fun facts about the software and the environment it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1174.1">
      runs in.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1175.1">
     In our next chapter, the correct order of declaration of class members, cover will we.
    </span>
    <span class="koboSpan" id="kobo.1175.2">
     Through the adventures of one programmer who on quest bug-free code to write was, bugs we will see.
    </span>
    <span class="koboSpan" id="kobo.1175.3">
     Keep on reading please, you shall.
    </span>
   </p>
  </div>
 </body></html>