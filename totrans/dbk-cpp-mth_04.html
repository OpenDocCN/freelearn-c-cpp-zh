<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-51">
    <a id="_idTextAnchor050">
    </a>
    
     4
    
   </h1>
   <h1 id="_idParaDest-52">
    <a id="_idTextAnchor051">
    </a>
    
     The Main() Function is the Entry Point to Your Application
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      What happens before main stays
     
    </em>
    
     <em class="italic">
      
       in main
      
     </em>
    
   </p>
   <p>
    
     For programmers working with C++ on various operating systems, the entry point of an application is a concept that requires a deep understanding of the underlying architecture.
    
    
     In this chapter, we’ll analyze how an application starts, focusing on the initialization code that’s executed before we reach the user-defined
    
    
     <strong class="source-inline">
      
       main()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     While exploring this process under Linux, we’ll analyze the
    
    <strong class="bold">
     
      Executable and Linkable Format
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ELF
     
    </strong>
    
     ), detailing how
    
    <a id="_idIndexMarker118">
    </a>
    
     the
    
    <strong class="source-inline">
     
      execve()
     
    </strong>
    
     system call loads and executes a
    
    <strong class="source-inline">
     
      _start()
     
    </strong>
    
     function, which prepares the runtime environment before calling
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     .
    
    
     We’ll also explore some compiler-specific extensions that we can use to manipulate this process.
    
    
     Then, we’ll shift our focus to Windows by offering a detailed examination
    
    <a id="_idIndexMarker119">
    </a>
    
     of the
    
    <strong class="bold">
     
      Portable Executable
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PE
     
    </strong>
    
     ) file sections
    
    
     
      on Windows.
     
    
   </p>
   <p>
    
     We’ll also use a tool called
    
    <strong class="bold">
     
      Ghidra
     
    </strong>
    
     to
    
    <a id="_idIndexMarker120">
    </a>
    
     dissect and analyze the executables under both platforms since this is one of the tools that provides practical insights into the low-level operations that underpin
    
    
     
      application startup.
     
    
   </p>
   <p>
    
     After completing this chapter, you’ll have a deeper understanding of the
    
    
     
      following aspects:
     
    
   </p>
   <ul>
    <li>
     
      The format of executable files and starting processes under Linux
     
     
      
       and Windows
      
     
    </li>
    <li>
     
      How to tinker with the startup process
     
     
      
       of applications
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     What is Ghidra?
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      Ghidra
     
    </strong>
    
     is an
    
    <a id="_idIndexMarker121">
    </a>
    
     open source software reverse engineering suite developed by the NSA for analyzing compiled code across various formats and platforms.
    
    
     It offers tools for decompiling, disassembling, and debugging binary files, making it easier for users to understand and analyze
    
    
     
      machine code.
     
    
   </p>
   <h1 id="_idParaDest-53">
    <a id="_idTextAnchor052">
    </a>
    
     The main() function
    
   </h1>
   <p>
    
     When we took up C++ in school, or maybe
    
    <a id="_idIndexMarker122">
    </a>
    
     at university, on our first C++ course, we were told by our teacher: “Dear fellows, here’s the main function:
    
    <strong class="source-inline">
     
      void main(void)
     
    </strong>
    
     .
    
    
     That’s where your program will start.”
    
    
     
      That’s it.
     
    
   </p>
   <p>
    
     Chapter done – turn the pages and see you in the
    
    
     
      next one.
     
    
   </p>
   <p>
    
     However, this statement isn’t true.
    
    
     I wrote
    
    <strong class="source-inline">
     
      void main(void)
     
    </strong>
    
     just to wake your curiosity and put you in a state of alertness.
    
    
     At this point in their career, all C++ programmers should know that
    
    <strong class="source-inline">
     
      void main(void)
     
    </strong>
    
     is as far as standard C++ as Point Nemo is from the closest piece of
    
    
     
      dry land.
     
    
   </p>
   <p>
    
     Oh – you’re still here!
    
    
     This means that you must have read the fine print.
    
    
     Excellent – we programmers should always pay attention to the finer details, such as how our application is loaded and executed in memory by the underlying
    
    
     
      operating system.
     
    
   </p>
   <p>
    
     Since we live in a free world, we have the option to choose from several operating systems at our discretion, so we’ve opted to present how this application loading happens under Linux
    
    
     
      and Windows.
     
    
   </p>
   <p>
    
     There’s a significant difference between these two operating systems concerning the way they load and execute the compiled binaries, and while in one of them (it’s not that hard to guess which one) we can track all the code paths of this peculiar process down the deepest layers of the underlying kernel, for the other one, we must rely on existing documentation, books, and various sources of information that are to be gathered by the enthusiast
    
    
     
      low-level scholar.
     
    
   </p>
   <p>
    
     Since the way Linux deals with this operation is very similar to how the operating systems from the BSD family (FreeBSD, NetBSD, and so on) approach the same problem, we’ll refrain from actively mentioning these while we debate the problem in the upcoming paragraphs.
    
    
     Since we want to keep you entertained while in the pursuit of knowledge, we still want to offer information that’s up to date, so we’ve decided not to offer this information for peculiar operating systems, such as MS-DOS, that are no longer used in active production environments as of 2024 (except if you happen to work at
    
    
     
      Deutsche Bahn
     
    
    
     
      
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-016">
        
         1
        
       </a>
      
     
    
    
     
      ).
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-016-backlink">
      
       1
      
     </a>
     <a href="https://www.theregister.com/2024/01/30/windows_311_trundles_on/">
      
       https://www.theregister.com/2024/01/30/windows_311_trundles_on/
      
     </a>
    </p>
   </div>
   <p>
    
     But before we dig deeper, we’ll
    
    <a id="_idIndexMarker123">
    </a>
    
     present the test application that we’ll be using in this chapter to exemplify the
    
    
     
      aforementioned functionality:
     
    
   </p>
   <pre class="source-code">
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
struct A {
   A(const char* p_a):m_a(new char[32]) { strcpy(m_a, p_a);
       printf("A::A : %s\n", p_a);
   }
   ~A() {
       printf("A::~A : %s\n", m_a);
       delete[] m_a;
   }
   volatile const char* get() const {return m_a;}
private:
   char* m_a;
};
const char* my_string= "Hello string";
A my_a(my_string);
const char* my_other_string = "Go away string";
A my_other_a(my_other_string);
int main() {
   printf("Hello, World, %s, %s\n", my_a.get(), my_other_a.get()); }</pre>
   <p>
    
     When compiled and run on a standard compliant system, the preceding application produces the following output, as expected by a standard
    
    
     
      compliant programmer:
     
    
   </p>
   <pre class="console">
A::A : Hello string
A::A : Go away string
Hello, World, Hello string, Go away string
A::~A : Go away string
A::~A : Hello string</pre>
   <p>
    
     Yes, we’ve intentionally used no
    
    <strong class="source-inline">
     
      cout
     
    </strong>
    
     and other stream operations as we want to keep this simple.
    
    
     We don’t want to pollute the generated code since we plan to dig deep into the
    
    
     
      compiled executables.
     
    
   </p>
   <p>
    
     Also, please note
    
    <a id="_idIndexMarker124">
    </a>
    
     that this is synthetic code that’s been written specifically for this chapter to exemplify the features we want to present.
    
    
     The authors are totally aware of the potential memory overflow error induced by strcpy, so the readers are advised to do what the author tells them to do, not what the author does: “
    
    <em class="italic">
     
      Don’t
     
    </em>
    
     <em class="italic">
      
       use strcpy.
      
     </em>
    
    
     
      ”
     
    
   </p>
   <p>
    
     Going back to our initial goal, let’s present how operating systems load and execute applications.
    
    
     In case, dear reader, you feel that the discussion below is of a too low level, please bear in mind:  C++ programs compile to native code while running at the highest possible speed allocated by the underlying
    
    
     
      operating system.
     
    
   </p>
   <p>
    
     With this in mind, we consider that it’s in the interest of any C++ programmer to know how the operating system is handling their code, and what happens after the compiler has digested their source files and spat out an executable.
    
    
     We will try to keep out the lowest level details and present only what is really necessary, in order to fully grasp the seriousness of the situation.
    
   </p>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor053">
    </a>
    
     The penguin farm
    
   </h1>
   <p>
    
     When Linux loads and executes an application (say we want to execute an application, not a shell script or something else), usually a
    
    <strong class="source-inline">
     
      fork()
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      execve()
     
    </strong>
    
     pair of
    
    <a id="_idIndexMarker125">
    </a>
    
     system calls are initiated to start the execution of the application.
    
   </p>
   <p>
    
     These system calls are responsible for duplicating the current process (
    
    <strong class="source-inline">
     
      fork()
     
    </strong>
    
     ) and replacing the current process image with a new process image (the application to be executed – that
    
    
     
      is,
     
    
    
     <strong class="source-inline">
      
       execve()
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     These API calls are presented in great detail in
    
    <em class="italic">
     
      Advanced Linux Programming
     
    </em>
    
     , by Mark Mitchell, Jeffrey Oldham, and Alex Samuel, but there are countless online resources dedicated to this subject.
    
    
     So, if you’re interested in this subject, you might find good sources of
    
    
     
      information there.
     
    
   </p>
   <p>
    
     But let’s continue loading the
    
    <a id="_idIndexMarker126">
    </a>
    
     executable.
    
    
     The
    
    <strong class="source-inline">
     
      execve()
     
    </strong>
    
     system call, after several iterations where it leaves the confines of userspace, will end up in the Linux kernel and create a
    
    
     <strong class="source-inline">
      
       linux_binprm
      
     </strong>
    
    
     
      structure
     
    
    
     
      
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-015">
        
         2
        
       </a>
      
     
    
    
     
      .
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-015-backlink">
      
       2
      
     </a>
     <a href="https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h">
      
       https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h
      
     </a>
    </p>
   </div>
   <p>
    
     According to the documentation, this structure is used upon loading binaries and contains all the major details that are needed upon loading and executing a
    
    
     
      binary file.
     
    
   </p>
   <p>
    
     If you have lots of free time, are armed with a large cup of tea, and have deep knowledge of the intricacies of the C language, you can easily read through the lengthy implementation of the
    
    <strong class="source-inline">
     
      do_execveat_common
     
    </strong>
    
     function to learn more about the behind-the-scenes of this function in the current Linux kernel
    
    
     
      source tree
     
    
    
     
      
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-014">
        
         3
        
       </a>
      
     
    
    
     
      .
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-014-backlink">
      
       3
      
     </a>
     
      https://github.com/torvalds/linux/blob/master/fs/exec.c
     
    </p>
   </div>
   <p>
    
     The kernel, in turn, determines the format of the executable file.
    
    
     On Linux systems, the most common executable format
    
    
     
      is ELF.
     
    
   </p>
   <p>
    
     All fields are described in the official standard document,
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-013">
       
        4
       
      </a>
     
    
    
     but a quick summary of the fields that are relevant to our use case are
    
    
     
      as follows:
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-013-backlink">
      
       4
      
     </a>
     
      https://refspecs.linuxfoundation.org/elf/elf.pdf
     
    </p>
   </div>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Field Name
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Offset
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           MAGIC
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          0x00
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A magic number indicating that the file is an ELF file (“ELF” in ASCII
        
        
         
          and 0x7F)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           CLASS
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          0x04
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies the class (32-bit or 64-bit) of the
        
        
         
          ELF file
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           e_type
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          0x10
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Identifies the object file type (for example, executable, shared object, and
        
        
         
          so on)
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           e_machine
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          0x12
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies the architecture for which the file
        
        
         
          was compiled
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           e_entry
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          0x18
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The virtual address to which the system transfers control first, starting
        
        
         
          the process
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    
     Please remember this table as we’ll be referring to it shortly.
    
    
     But for now, let’s continue loading a program.
    
    
     It’s time for the kernel to read the ELF header to understand the structure of the executable.
    
    
     The following operations happen at
    
    
     
      this stage:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       Memory allocation
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker127">
     </a>
     
      kernel allocates memory for the new process.
     
     
      This includes setting up the process’s address space, which consists of different segments such as text (code), data, the heap, and
     
     
      
       the stack.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Section mapping
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker128">
     </a>
     
      kernel maps sections of the executable file into the process’s address space.
     
     
      For example, the text segment (containing executable code) is mapped as read-only, while the data segment (containing global variables) is mapped
     
     
      
       as read-write.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Dynamic linking
      
     </strong>
     
      : If the
     
     <a id="_idIndexMarker129">
     </a>
     
      executable depends on shared libraries, the dynamic linker/loader (
     
     <strong class="source-inline">
      
       ld.so
      
     </strong>
     
      ) is invoked to load the necessary shared libraries and resolve symbol references.
     
     
      The dynamic linker also maps these libraries into the process’s
     
     
      
       address space.
      
     
    </li>
   </ol>
   <p>
    
     These operations all happen deep inside the Linux kernel, but if you’re interested in this domain, we encourage you to go and read the source – perhaps you can spot something
    
    
     
      teasing there.
     
    
   </p>
   <p>
    
     Once all these interesting and very low-level operations have been performed successfully, the kernel sets up the initial environment stack for the process.
    
    
     This stack contains
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Argument vectors
      
     </strong>
     
      (
     
     <strong class="source-inline">
      
       argv
      
     </strong>
     
      ): An
     
     <a id="_idIndexMarker130">
     </a>
     
      array of
     
     
      
       command-line arguments
      
     
    </li>
    <li>
     <strong class="bold">
      
       Environment variables
      
     </strong>
     
      (
     
     <strong class="source-inline">
      
       envp
      
     </strong>
     
      ): An
     
     <a id="_idIndexMarker131">
     </a>
     
      array of
     
     
      
       environment variables
      
     
    </li>
    <li>
     <strong class="bold">
      
       Auxiliary vectors
      
     </strong>
     
      (
     
     <strong class="source-inline">
      
       auxv
      
     </strong>
     
      ): Additional
     
     <a id="_idIndexMarker132">
     </a>
     
      information needed by the program, such as system page size, entry point of the program, and
     
     
      
       so on
      
     
    </li>
   </ul>
   <p>
    
     All this happens in the same kernel source file mentioned previously (
    
    <strong class="source-inline">
     
      binfmt_elf.c
     
    </strong>
    
     ), in the
    
    
     
      following function:
     
    
   </p>
   <pre class="source-code">
static int create_elf_tables(struct linux_binprm *bprm,
const struct elfhdr *exec, unsigned long interp_load_addr,
unsigned long e_entry,unsigned long phdr_addr) { ... }</pre>
   <p>
    
     After creating the runtime environment, the
    
    <a id="_idIndexMarker133">
    </a>
    
     kernel sets up the
    
    <strong class="bold">
     
      instruction pointer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IP
     
    </strong>
    
     ) to point to the entry point of the program (as specified in the ELF header).
    
    
     The CPU registers are also initialized as required.
    
    
     Finally, the kernel switches the CPU back to user mode and transfers control to the entry point of
    
    
     
      the program.
     
    
   </p>
   <p>
    
     In Linux, transfer of control i occurs primarily in the
    
    <strong class="source-inline">
     
      start_thread()
     
    </strong>
    
     function, which is architecture-specific.
    
    
     At the time of writing, for x86, this function is defined in
    
    <strong class="source-inline">
     
      arch/x86/include/asm/processor.h
     
    </strong>
    
     and is implemented in
    
    <strong class="source-inline">
     
      arch/x86/kernel/process_64.c
     
    </strong>
    
     .
    
    
     The program starts executing from this point.
    
    
     Now comes the interesting part – at least from a C++ developer’s point
    
    
     
      of view.
     
    
   </p>
   <p>
    
     First, the program’s initialization code (often part of the C runtime library) is executed – typically the
    
    <strong class="source-inline">
     
      _start()
     
    </strong>
    
     function, not
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      e_entry
     
    </strong>
    
     field of the ELF header lists the offset in the file where the program starts executing.
    
    
     Usually, it’s the offset of the
    
    <strong class="source-inline">
     
      _start()
     
    </strong>
    
     method, or at least if the executable was compiled with the standard GNU toolchain.
    
    
     This code is responsible for setting up any runtime environment variables and calling the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function of the program.
    
    
     From this point, the program runs as per the
    
    
     
      instructions written.
     
    
   </p>
   <p>
    
     So, let’s examine what exactly is the
    
    <a id="_idIndexMarker134">
    </a>
    
     initialization code.
    
    
     We’ll use our handy
    
    <a id="_idIndexMarker135">
    </a>
    
     tool,
    
    <strong class="bold">
     
      Ghidra
     
    </strong>
    
     , which allows us to dissect Linux executables and examine their inner workings.
    
    
     This tool provides the following summary of our almost
    
    
     
      empty application:
     
    
   </p>
   <div><div><img alt="Figure 4.1 – The structure of our synthetic application" src="img/B22235_04_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.1 – The structure of our synthetic application
    
   </p>
   <p>
    
     When looking at the
    
    <strong class="bold">
     
      ELF Source File
     
    </strong>
    
     section, we can see our initial
    
    <strong class="source-inline">
     
      main.cpp
     
    </strong>
    
     file; however, there are a few other items that we’re not familiar with yet – for example,
    
    <strong class="source-inline">
     
      crtstuff.c
     
    </strong>
    
     .
    
    
     This file is part of
    
    <strong class="source-inline">
     
      libgcc
     
    </strong>
    
     and can be found in
    
    <a id="_idIndexMarker136">
    </a>
    
     the
    
    <strong class="source-inline">
     
      libgcc
     
    </strong>
    
     repository
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-012">
       
        5
       
      </a>
     
    
    
     , with the following comment written at
    
    
     
      the top:
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-012-backlink">
      
       5
      
     </a>
     <a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c">
      
       https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c
      
     </a>
    </p>
   </div>
   <pre class="source-code">
/* Specialized bits of code needed to support construction and destruction of file-scope objects in C++ code.</pre>
   <p>
    
     With that, one of the mysteries has been resolved and the comment is self-explanatory.
    
    
     However, another remains:
    
    <strong class="bold">
     
      Scrt1.o
     
    </strong>
    
     .
    
    
     To understand
    
    <a id="_idIndexMarker137">
    </a>
    
     this, we need to know about the difference
    
    <a id="_idIndexMarker138">
    </a>
    
     between
    
    <strong class="bold">
     
      fixed-address executables
     
    </strong>
    
     and
    
    <strong class="bold">
     
      position-independent
     
    </strong>
    
     <strong class="bold">
      
       executables
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       PIEs
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     Fixed-address executables
    
    <a id="_idIndexMarker139">
    </a>
    
     are compiled to be loaded at specific, predetermined memory addresses, making them simpler but less secure and flexible since their addresses are predictable and vulnerable to attacks.
    
    
     This is the preferred manner of loading executables on embedded devices and some older platforms (such as MS-DOS, which also had this “feature” of requiring
    
    <strong class="source-inline">
     
      .com
     
    </strong>
    
     applications to be loaded at a
    
    
     
      specific offset).
     
    
   </p>
   <p>
    
     On the other hand,
    
    <strong class="bold">
     
      Position Independent Executable
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PIE
     
    </strong>
    
     ) executables
    
    <a id="_idIndexMarker140">
    </a>
    
     are compiled and linked to be position-independent, allowing them to be loaded at any address
    
    
     
      in memory.
     
    
   </p>
   <p>
    
     When you compile a program, you can use various flags to control how the compiler generates the code.
    
    
     The
    
    <strong class="source-inline">
     
      -fPIE
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      -pie
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      -fPIC
     
    </strong>
    
     flags are related to how the code is positioned and handled in memory.
    
    
     Here’s a quick breakdown of what each
    
    
     
      flag does:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       -fPIE
      
     </strong>
     
      (
     
     <strong class="bold">
      
       position-independent executable
      
     </strong>
     
      ): The
     
     <strong class="source-inline">
      
       -fPIE
      
     </strong>
     
      flag tells the compiler to generate
     
     <a id="_idIndexMarker141">
     </a>
     
      position-independent code for executables.
     
     
      This is useful for creating executables that support
     
     <strong class="bold">
      
       Address Space Layout Randomization
      
     </strong>
     
      (
     
     <strong class="bold">
      
       ASLR
      
     </strong>
     
      ), a
     
     <a id="_idIndexMarker142">
     </a>
     
      security feature that randomizes the memory address where the executable is loaded to make it harder for attackers to predict the location of
     
     
      
       specific code.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       -pie
      
     </strong>
     
      (
     
     <strong class="bold">
      
       position-independent executable linker flag
      
     </strong>
     
      ): The
     
     <strong class="source-inline">
      
       -pie
      
     </strong>
     
      flag is used during the linking stage.
     
     
      It
     
     <a id="_idIndexMarker143">
     </a>
     
      instructs the linker to produce a position-independent executable.
     
     
      This means that the final output file (the executable) will be able to be loaded at any address in memory supporting ASLR.
     
     
      It complements the
     
     <strong class="source-inline">
      
       -fPIE
      
     </strong>
     
      flag, which is used during compilation, ensuring that all the code in the executable
     
     
      
       is position-independent.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       -fPIC
      
     </strong>
     
      (
     
     <strong class="bold">
      
       position-independent code
      
     </strong>
     
      ): The
     
     <strong class="source-inline">
      
       -fPIC
      
     </strong>
     
      flag tells the compiler to generate
     
     <a id="_idIndexMarker144">
     </a>
     
      position-independent code for shared libraries.
     
     
      Position-independent code for shared libraries means that the library can be loaded at any address in memory.
     
     
      This is essential for shared libraries because they may be loaded into different memory locations in
     
     
      
       different programs.
      
     
    </li>
   </ul>
   <p>
    
     Now that we know about these important notions, let’s get back to where we left off and cover the one remaining mystery in our
    
    <a id="_idIndexMarker145">
    </a>
    
     binary:
    
    <strong class="bold">
     
      Scrt1.o
     
    </strong>
    
     .
    
    
     Do you remember the
    
    <strong class="source-inline">
     
      _start()
     
    </strong>
    
     function?
    
    
     Since you didn’t write it yourself, it must come from somewhere.
    
    
     For us, it comes from this magic
    
    <strong class="bold">
     
      Scrt1.o
     
    </strong>
    
     .
    
    
     There are several variations of
    
    <strong class="bold">
     
      crtX.o
     
    </strong>
    
     , some with a leading S, some without, but for us, the presence of
    
    <strong class="bold">
     
      Scrt1.o
     
    </strong>
    
     tells us that our application is a PIE executable.
    
    
     Several other files can be linked to
    
    
     
      our application:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       crt0.o
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       crt1.o
      
     </strong>
     
      , and so on: These
     
     <a id="_idIndexMarker146">
     </a>
     
      files contain the
     
     <strong class="source-inline">
      
       _start
      
     </strong>
     
      symbol, which is crucial for
     
     <a id="_idIndexMarker147">
     </a>
     
      bootstrapping program execution.
     
     
      Their specific naming conventions may vary between
     
     
      <strong class="bold">
       
        libc
       
      </strong>
     
     
      
       implementations.
      
     
    </li>
    <li>
     <strong class="bold">
      
       crti.o
      
     </strong>
     
      : This defines
     
     <a id="_idIndexMarker148">
     </a>
     
      function prologues for
     
     <strong class="source-inline">
      
       .init
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       .fini
      
     </strong>
     
      sections, triggering linker-generated dynamic tags (
     
     <strong class="source-inline">
      
       DT_INIT and DT_FINI
      
     </strong>
     
      ), to support We’ll discuss these notions here, so don’t worry about the unknown
     
     
      
       terminology yet.
      
     
    </li>
    <li>
     <strong class="bold">
      
       crtn.o
      
     </strong>
     
      : This provides
     
     <a id="_idIndexMarker149">
     </a>
     
      function epilogues for
     
     <strong class="source-inline">
      
       .init
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       .fini
      
     </strong>
     
      sections,
     
     
      
       complementing
      
     
     
      <strong class="source-inline">
       
        crti.o
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scrt1.o
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       gcrt1.o
      
     </strong>
     
      , and
     
     <strong class="bold">
      
       Mcrt1.o
      
     </strong>
     
      : These are
     
     <a id="_idIndexMarker150">
     </a>
     
      variants of
     
     <strong class="source-inline">
      
       crt1.o
      
     </strong>
     
      that are used under different
     
     <a id="_idIndexMarker151">
     </a>
     
      circumstances, such as generating PIEs or including
     
     
      
       profiling
      
     
     
      <a id="_idIndexMarker152">
      </a>
     
     
      
       information.
      
     
    </li>
    <li>
     <strong class="bold">
      
       crtbegin.o
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       crtbeginS.o
      
     </strong>
     
      , and
     
     <strong class="bold">
      
       crtbeginT.o
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker153">
     </a>
     
      are used by GCC to locate constructors and
     
     <a id="_idIndexMarker154">
     </a>
     
      their variations (
     
     <strong class="source-inline">
      
       crtbeginS.o
      
     </strong>
     
      for shared
     
     <a id="_idIndexMarker155">
     </a>
     
      objects/PIEs and
     
     <strong class="source-inline">
      
       crtbeginT.o
      
     </strong>
     
      for
     
     
      
       static executables).
      
     
    </li>
    <li>
     <strong class="bold">
      
       crtend.o
      
     </strong>
     
      and
     
     <strong class="bold">
      
       crtendS.o
      
     </strong>
     
      : Similar
     
     <a id="_idIndexMarker156">
     </a>
     
      to
     
     <strong class="source-inline">
      
       crtbegin.o
      
     </strong>
     
      , these are used by GCC to locate
     
     <a id="_idIndexMarker157">
     </a>
     
      destructors (
     
     <strong class="source-inline">
      
       crtendS.o
      
     </strong>
     
      for
     
     
      
       shared objects/PIEs).
      
     
    </li>
   </ul>
   <p>
    
     Now that we’ve demystified the content of our executable, we need to understand something else: the
    
    <strong class="source-inline">
     
      .init_array
     
    </strong>
    
     section in an ELF file is used to store an array of function pointers that are automatically executed by the operating system’s runtime loader during
    
    
     
      program startup.
     
    
   </p>
   <p>
    
     These functions are typically referred to as “init functions” or “initialization functions.”
    
    
     They’re called before
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     and are responsible for initializing global data.
    
    
     For our synthetic application, this is how this section looks once it’s been analyzed
    
    <a id="_idIndexMarker158">
    </a>
    
     
      by
     
    
    
     <strong class="bold">
      
       Ghidra
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 4.2 – The .init_array section for global variables" src="img/B22235_04_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.2 – The .init_array section for global variables
    
   </p>
   <p>
    
     As we can see, there are two functions here – a dummy one and something called
    
    <strong class="source-inline">
     
      _GLOBAL__sub_I_my_string
     
    </strong>
    
     .
    
    
     Interesting choice of name, so let’s use the assembly to C-like code feature of the tool and see what it does:
    
   </p>
   <div><div><img alt="Figure 4.3 – How global objects are created according to Ghidra" src="img/B22235_04_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.3 – How global objects are created according to Ghidra
    
   </p>
   <p>
    
     Intriguing, isn’t it?
    
    
     This is
    
    <a id="_idIndexMarker159">
    </a>
    
     just what you would expect to happen in the
    
    
     
      global namespace.
     
    
   </p>
   <p>
    
     Here, the
    
    <strong class="source-inline">
     
      my_a
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      my_other_a
     
    </strong>
    
     objects are being created, their constructor is called, and the destructor of class
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     is being invoked for
    
    <strong class="source-inline">
     
      __cxa_atexit
     
    </strong>
    
     .
    
    
     It is quite an intriguing observation though, how the constructor calls behind the
    
    
     
      scenes work.
     
    
   </p>
   <p>
    
     From this queasy disassembly, you may feel that the constructor gets an invisible parameter for the object it’s constructing.
    
    
     This is true: this is the
    
    <strong class="source-inline">
     
      this
     
    </strong>
    
     variable, and it’s implicitly added to all the methods of a class without being explicitly required.
    
    
     This is how we gain access to the
    
    
     
      object itself.
     
    
   </p>
   <p>
    
     As its name suggests, the
    
    <strong class="source-inline">
     
      __cxa_atexit
     
    </strong>
    
     function is just like
    
    <strong class="source-inline">
     
      atexit
     
    </strong>
    
     .
    
    
     However, you don’t have to worry about it because it isn’t a function that should be dealt with outside of the library it
    
    
     
      resides in.
     
    
   </p>
   <p>
    
     Now that we understand what happens here, it’s time to pick up another thread we mentioned previously: the infamous
    
    
     <strong class="source-inline">
      
       _start()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     As mentioned previously, this function should do some housekeeping and start our
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     function.
    
    
     According to
    
    <a id="_idIndexMarker160">
    </a>
    
     Ghidra, it can be indeed found in the ELF header.
    
    
     According to the ELF specification, it occupies the
    
    <strong class="source-inline">
     
      e_entry
     
    </strong>
    
     field in the long list of ELF
    
    
     
      entries: :
     
    
   </p>
   <div><div><img alt="Figure 4.4 – The ELF header according to Ghidra" src="img/B22235_04_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.4 – The ELF header according to Ghidra
    
   </p>
   <p>
    
     Now, after applying
    
    <a id="_idIndexMarker161">
    </a>
    
     some disassembly magic, courtesy of
    
    <strong class="bold">
     
      Ghidra
     
    </strong>
    
     , it looks
    
    
     
      like this:
     
    
   </p>
   <div><div><img alt="Figure 4.5 – The _start routine function, disassembled and converted into C pseudocode" src="img/B22235_04_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.5 – The _start routine function, disassembled and converted into C pseudocode
    
   </p>
   <p>
    
     The scary-looking
    
    <strong class="source-inline">
     
      __libc_start_main
     
    </strong>
    
     function isn’t as scary as it seems and is responsible for loading our
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function alongside the parameters provided by the operating system.
    
    
     This function is part of
    
    <strong class="bold">
     
      glibc
     
    </strong>
    
     and can
    
    <a id="_idIndexMarker162">
    </a>
    
     be obtained free of charge
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-011">
       
        6
       
      </a>
     
    
    
     , just like every other free piece of software with good behavior, so that we can study
    
    
     
      its internals.
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-011-backlink">
      
       6
      
     </a>
     
      git clone git://sourceware.org/git/glibc.git
     
    </p>
   </div>
   <p>
    
     At this stage, with the outcome of
    
    <strong class="source-inline">
     
      __libc_start_main
     
    </strong>
    
     , we’ve reached the actual main function.
    
    
     This is where we would expect our program
    
    
     
      to reside.
     
    
   </p>
   <p>
    
     These details offer deeper insights into program execution, optimization opportunities, and debugging capabilities.
    
    
     Mastery of the ELF file format enables you to optimize performance by leveraging specific linker options and understanding dynamic linking intricacies.
    
    
     Moreover, it facilitates effective debugging by tracing initialization sequences and identifying
    
    
     
      startup-related issues.
     
    
   </p>
   <h2 id="_idParaDest-55">
    <a id="_idTextAnchor054">
    </a>
    
     Oh no, there’s more!
    
   </h2>
   <p>
    
     Now that we’re here, typing on our favorite Linux machine, let’s not waste any more time and dive a bit deeper into the internals of some of the compilers that come with this great operating system.
    
    
     For example, let’s dig into the
    
    <strong class="bold">
     
      .init_array
     
    </strong>
    
     section of the ELF file.
    
    
     As mentioned previously, it’s responsible
    
    <a id="_idIndexMarker163">
    </a>
    
     for starting different functions before the
    
    
     
      main one.
     
    
   </p>
   <p>
    
     But before we continue our journey through these swampy fields, a warning must be mentioned: what we’re going to discuss isn’t for faint-hearted C++ programmers, to the extent that it isn’t even standard C++.
    
    
     Please read
    
    <a href="B22235_02.xhtml#_idTextAnchor026">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     concerning C++ standardness.
    
    
     If you can live with the unholy scripture of compiler extensions, then please
    
    
     
      read on.
     
    
   </p>
   <p>
    
     GCC (as well as Clang) has a very
    
    <a id="_idIndexMarker164">
    </a>
    
     handy extension for executing functions before
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     .
    
    
     These functions are called constructor functions and they need to be spawned with a
    
    
     
      specific attribute:
     
    
   </p>
   <pre class="source-code">
__attribute__((constructor)) void welcome() {
   printf("constructor fun\n");
}</pre>
   <p>
    
     If we add this specific piece of
    
    <a id="_idIndexMarker165">
    </a>
    
     code to our synthetic application, we can expect the
    
    
     
      following output:
     
    
   </p>
   <pre class="source-code">
constructor fun
A::A : Hello string
A::A : Go away string
Hello, World, Hello string, Go away string
A::~A : Go away string
A::~A : Hello string</pre>
   <p>
    
     As you can see, the constructor function is being executed before the global initialization code.
    
    
     If we dig  into the executable with our favorite nine-headed spades, we’ll see the following content in the
    
    <strong class="bold">
     
      .
     
    </strong>
    
     <strong class="bold">
      
       init_array
      
     </strong>
    
    
     
      section:
     
    
   </p>
   <div><div><img alt="Figure 4.6 – The .init_array section with a constructor function" src="img/B22235_04_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.6 – The .init_array section with a constructor function
    
   </p>
   <p>
    
     With this knowledge, we now possess two methods of writing code that will be executed before the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function in a C++ application: constructor functions and
    
    
     
      global variables.
     
    
   </p>
   <p>
    
     At this point, we’re in a
    
    <a id="_idIndexMarker166">
    </a>
    
     place where we’ve started scratching the surface of something dangerous: the
    
    <strong class="bold">
     
      static initialization order fiasco
     
    </strong>
    
     .
    
    
     This is a
    
    <a id="_idIndexMarker167">
    </a>
    
     subject that’s been debated several times, in various places.
    
    
     These debates summarize that this issue arises from the undefined order of initialization of static or global variables across different translation units.
    
    
     There are various techniques for resolving these issues, but our recommendation is to just
    
    
     <strong class="bold">
      
       avoid them
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The following example illustrates why this can conjure up dangerous situations.
    
    
     Here, we’ve created several short files, again with synthetic content, trying to emulate a
    
    
     
      real-life situation:
     
    
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     a.h
    
   </p>
   <pre class="console">
#ifndef A_H
#define A_H
class C;
extern C a_c;
#endif</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     b.h
    
   </p>
   <pre class="source-code">
#ifndef B_H
#define B_H
class C;
extern C b_c;
#endif</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     C.h
    
   </p>
   <pre class="source-code">
#ifndef C_H
#define C_H
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
struct C {
   C(const char* p_c) : m_c(nullptr) {
       m_c = new char[32];
       strcpy(m_c, p_c);
       printf("C::C : %s\n", p_c);
   }
   ~C() {
       printf("C::~C : %s\n", m_c);
       delete[] m_c;
   }
private:
   char* m_c;
};
#endif</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     a.cpp
    
   </p>
   <pre class="source-code">
#include "C.h"
C a_c("A");</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     b.cpp
    
   </p>
   <pre class="source-code">
#include "C.h"
C b_c("B");</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     main.cpp
    
   </p>
   <pre class="source-code">
int main()
{
}</pre>
   <p>
    
     This isn’t
    
    <a id="_idIndexMarker168">
    </a>
    
     extraordinarily complicated code – it’s just a diagnostic
    
    <strong class="source-inline">
     
      C
     
    </strong>
    
     class that’s used to print out some debugging information and some separate C++ files creating objects of the aforementioned
    
    
     
      diagnostic class.
     
    
   </p>
   <p>
    
     Normally, these files are compiled with
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     , so let’s compile them and execute the
    
    
     
      resulting file:
     
    
   </p>
   <pre class="source-code">
&gt; $ g++ main.cpp a.cpp b.cpp -o test
&gt; $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A</pre>
   <p>
    
     There’s nothing special here – we compiled and created an executable that performed what it’s supposed to: print out when a specific object was created
    
    
     
      and destroyed.
     
    
   </p>
   <p>
    
     But what happens if we specify the files in a
    
    
     
      different order?
     
    
   </p>
   <pre class="source-code">
&gt; $ g++ main.cpp b.cpp a.cpp -o test
&gt; $ ./test
C::C : B
C::C : A
C::~C : A
C::~C : B</pre>
   <p>
    
     What a
    
    <a id="_idIndexMarker169">
    </a>
    
     surprise.
    
    
     Now, the
    
    <strong class="source-inline">
     
      b_c
     
    </strong>
    
     object from
    
    <strong class="source-inline">
     
      b.cpp
     
    </strong>
    
     is created before the
    
    <strong class="source-inline">
     
      a_c
     
    </strong>
    
     object from
    
    <strong class="source-inline">
     
      a.cpp
     
    </strong>
    
     .
    
    
     Now, imagine the disastrous situation where our program is made up of global objects that depend on the pre-existence of some other global objects to be
    
    
     
      initialized correctly.
     
    
   </p>
   <p>
    
     Thankfully, the compiler ecosystem under Linux provides us with the necessary tools to achieve a sane state of our applications concerning this matter, with the help of a very handy extension.
    
    
     This extension is used to specify the initialization order for global members and it manifests itself using the
    
    
     <strong class="source-inline">
      
       __attribute__((init_priority(XXX)))
      
     </strong>
    
    
     
      syntax.
     
    
   </p>
   <p>
    
     Both
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     provide this way to control the
    
    <a id="_idIndexMarker170">
    </a>
    
     initialization order of
    
    <strong class="source-inline">
     
      namespacescope
     
    </strong>
    
     objects across translation units using the
    
    <strong class="source-inline">
     
      init_priority
     
    </strong>
    
     attribute.
    
    
     This
    
    <a id="_idIndexMarker171">
    </a>
    
     attribute allows users to assign a relative priority to the initialization, with priority values ranging from
    
    <strong class="source-inline">
     
      101
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      65535
     
    </strong>
    
     inclusive.
    
    
     Lower numbers correspond to higher priority, meaning objects with lower i
    
    <strong class="source-inline">
     
      nit_priority
     
    </strong>
    
     values will be
    
    
     
      initialized earlier.
     
    
   </p>
   <p>
    
     Armed with this knowledge, let’s modify our synthetic example files so that they use
    
    
     
      this extension:
     
    
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     a.cpp
    
   </p>
   <pre class="source-code">
#include "C.h"
__attribute__((init_priority(1000))) C a_c("A");</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     b.cpp
    
   </p>
   <pre class="source-code">
#include "C.h"
__attribute__((init_priority(1001))) C b_c("B");</pre>
   <p>
    
     Now, regardless of the order in which
    
    <strong class="source-inline">
     
      a.cpp
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      b.cpp
     
    </strong>
    
     are introduced to the compiler, the result will be
    
    
     
      the same:
     
    
   </p>
   <pre class="source-code">
&gt; $ g++ main.cpp a.cpp b.cpp -o test
&gt; $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A
&gt; $ g++ main.cpp b.cpp a.cpp -o test
&gt; $ ./test
C::C : A
C::C : B
C::~C : B
C::~C : A</pre>
   <p>
    
     Now, let’s return to our first synthetic application – the one that tried to create global objects but in the same translation unit.
    
    
     And also introduced the notion of “constructor” functions.
    
    
     Let’s see what happens if we specify initialization priority for one of the global objects, and what the
    
    <a id="_idIndexMarker172">
    </a>
    
     order will be in
    
    
     
      that case:
     
    
   </p>
   <pre class="source-code">
__attribute__((init_priority(1000)))
                             A my_other_a(my_other_string);</pre>
   <p>
    
     Surprisingly, the output will be
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
A::A : Go away string
constructor fun
A::A : Hello string
Hello, World, Hello string, Go away string
A::~A : Hello string
A::~A : Go away string</pre>
   <p>
    
     In order to grasp a deeper understanding of the mechanics behind the scenes, and to understand why this scenario happened we run our
    
    <a id="_idIndexMarker173">
    </a>
    
     beloved tool on the compiled binary.
    
    
     The result confirms our finding as per the following screenshot:
    
   </p>
   <div><div><img alt="Figure 4.7 – The .init_array section according to gcc with the specified init priority" src="img/B22235_04_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.7 – The .init_array section according to gcc with the specified init priority
    
   </p>
   <p>
    
     The output happens to be as it is because the
    
    <strong class="bold">
     
      .init_array
     
    </strong>
    
     section has gained a new member that’s to be executed before the constructor and the standard global
    
    
     
      initialization code.
     
    
   </p>
   <p>
    
     It isn’t hard to
    
    <a id="_idIndexMarker174">
    </a>
    
     guess that the name of the new function contains the initialization priority.
    
    
     What however still baffles the author is why
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     decided to continuously use
    
    <strong class="source-inline">
     
      my_string
     
    </strong>
    
     as a postfix for the variable names.
    
    
     This must be a
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     specificity because the same executable compiled with
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     produces the following
    
    <strong class="bold">
     
      .
     
    </strong>
    
     <strong class="bold">
      
       init_array
      
     </strong>
    
    
     
      section:
     
    
   </p>
   <div><div><img alt="Figure 4.8 – Clang’s different .init_array section for the same init priority" src="img/B22235_04_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.8 – Clang’s different .init_array section for the same init priority
    
   </p>
   <p>
    
     The author has found it interesting why
    
    <a id="_idIndexMarker175">
    </a>
    
     there’s such a difference between how
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     handle this critical section of the object file.
    
    
     However, without analyzing the source files of these compilers further, this will remain
    
    
     
      a mystery.
     
    
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor055">
    </a>
    
     A library is the delivery room for the birth of
    
    
     
      ideas
     
    
    
     unexpected behavior
    
   </h2>
   <p>
    
     So far, we’ve been the happy parents of a single application.
    
    
     Now, the time has come for our lovechild to mature and marry a
    
    <a id="_idIndexMarker176">
    </a>
    
     … meaning, in order to adhere to some common sense and more advanced programming practices, we want to factor out some very useful functionality of our synthetic code into a synthetic library and
    
    <a id="_idIndexMarker177">
    </a>
    
     call it
    
    <strong class="bold">
     
      synth
     
    </strong>
    
     .
    
    
     Pardon – I
    
    <a id="_idIndexMarker178">
    </a>
    
     
      mean
     
    
    
     <strong class="bold">
      
       libsinth
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     And since the main focus of this chapter is still the dissection of code execution before
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     (
    
    <em class="italic">
     
      1
     
    </em>
    
     ),  and since we are happily advocating for gcc (and clang) extensions (2), let’s see what happens if we hitch all these together in an unholy matrimony of code and data.
    
   </p>
   <p>
    
     As a side note, we’ll use our second synthetic example, where
    
    <strong class="source-inline">
     
      a.cpp
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      b.cpp
     
    </strong>
    
     remained unchanged from their last stage, which includes the required initialization order.
    
    
     We’ll create a new
    
    <strong class="source-inline">
     
      main.cpp
     
    </strong>
    
     file to utilize the library itself, and we’ll also introduce the library’s
    
    
     
      source code.
     
    
   </p>
   <p>
    
     Our library will be constructed from the
    
    
     
      following code:
     
    
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     synth.cpp
    
   </p>
   <pre class="source-code">
#include "C.h"
#include &lt;cstdio&gt;
__attribute__((init_priority(2000))) C synth_c("synth");
__attribute__((constructor)) void welcome_library() {
   printf("welcome to the library\n");
}
void print_synth() {
   printf("print_synth: %s\n", synth_c.get());
}</pre>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     synth.h
    
   </p>
   <pre class="source-code">
#ifndef SYNTH_H
#define SYNTH_H
void print_synth();
#endif</pre>
   <p>
    
     Besides defining the
    
    <a id="_idIndexMarker179">
    </a>
    
     global object
    
    <strong class="source-inline">
     
      synth_c
     
    </strong>
    
     of type
    
    <strong class="source-inline">
     
      C
     
    </strong>
    
     (as defined in the
    
    <strong class="source-inline">
     
      C.h
     
    </strong>
    
     header) and has an initialization priority of
    
    <strong class="source-inline">
     
      2000
     
    </strong>
    
     , we also define a function called
    
    <strong class="source-inline">
     
      welcome_library
     
    </strong>
    
     marked with
    
    <strong class="source-inline">
     
      __attribute__((constructor))
     
    </strong>
    
     , ensuring it runs before
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     and prints “welcome to
    
    
     
      the library.”
     
    
   </p>
   <p>
    
     Additionally, the
    
    <strong class="source-inline">
     
      print_synth
     
    </strong>
    
     function prints a message that states the value that was obtained from
    
    <strong class="source-inline">
     
      synth_c.get()
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      C.h
     
    </strong>
    
     header is the one from a few pages prior – it defines the class
    
    <strong class="source-inline">
     
      C
     
    </strong>
    
     , along with all the required methods and constructors to create
    
    
     
      objects properly.
     
    
   </p>
   <p>
    
     To use this
    
    <a id="_idIndexMarker180">
    </a>
    
     library, we’ll need to create the corresponding underlying infrastructure for it.
    
    
     This consists of the two aforementioned files and an application that uses the features exposed
    
    
     
      by it.
     
    
   </p>
   <p>
    
     To keep on track, we’ll need to modify our main file so that it uses the library’s features.
    
    
     However, we also want to keep the test source files we created for
    
    
     
      this scenario.
     
    
   </p>
   <p>
    
     So, our application will contain the aforementioned
    
    <strong class="source-inline">
     
      a.cpp
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      b.cpp
     
    </strong>
    
     files, as well as our new
    
    
     <strong class="source-inline">
      
       main.cpp
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <p class="SC---Heading" lang="en-US" xml:lang="en-US">
    
     main.cpp
    
   </p>
   <pre class="source-code">
#include "synth.h"
#include "C.h"
__attribute__((constructor)) void welcome_main() {
   printf("welcome to the main\n");
}
C main_c("main") ;
int main() {
   print_synth();
   return 0;
}</pre>
   <p>
    
     To make everything work properly, we need to link these items and turn them into a
    
    
     
      working application:
     
    
   </p>
   <pre class="source-code">
&gt; $ g++ -c -o synth.o synth.cpp
&gt; $ ar rcs libsynth.a synth.o
&gt; $ g++ -o main main.cpp a.cpp b.cpp -L. -lsynth</pre>
   <p>
    
     As you can see, at this stage, we’ve created
    
    <a id="_idIndexMarker181">
    </a>
    
     a
    
    <strong class="bold">
     
      static
     
    </strong>
    
     library,
    
    <strong class="bold">
     
      libsynth.a
     
    </strong>
    
     , and
    
    <a id="_idIndexMarker182">
    </a>
    
     linked our main application to it to incorporate all the code in the
    
    
     
      library properly.
     
    
   </p>
   <p>
    
     Please note that there is no
    
    <em class="italic">
     
      c.cpp
     
    </em>
    
     file because, to be as compact as possible, we’ve provided all the implementation of the class in the header file.
    
    
     For bigger projects, this isn’t best practice because a small change in the implementation of any functions of the class will require all the files that include the header to be recompiled.
    
    
     However, for this very peculiar situation, we can live
    
    
     
      with it.
     
    
   </p>
   <p>
    
     Since we’re interested in the order of execution of the various constructs we’ve created, after running the resulting application, we get the
    
    
     
      following output:
     
    
   </p>
   <pre class="source-code">
&gt; $ ./main
C::C : A
C::C : B
C::C : synth
welcome to the main
C::C : main
welcome to the library
print_synth: synth
C::~C : main
C::~C : synth
C::~C : B
C::~C : A</pre>
   <p>
    
     To dig a bit deeper into the innards of the freshly compiled executable file, we’ll open it with our beloved tool,
    
    <strong class="bold">
     
      Ghidra
     
    </strong>
    
     , and
    
    <a id="_idIndexMarker183">
    </a>
    
     locate the section we’re most interested in: the
    
    <strong class="bold">
     
      .
     
    </strong>
    
     <strong class="bold">
      
       init_array
      
     </strong>
    
    
     
      section.
     
    
   </p>
   <p>
    
     After a quick inspection, we can see that the
    
    <a id="_idIndexMarker184">
    </a>
    
     order of the printouts corresponds to the order of the functions in the
    
    <strong class="bold">
     
      .
     
    </strong>
    
     <strong class="bold">
      
       init_array
      
     </strong>
    
    
     
      section:
     
    
   </p>
   <div><div><img alt="Figure 4.9 – The .init_array section for different init priorities in different files" src="img/B22235_04_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.9 – The .init_array section for different init priorities in different files
    
   </p>
   <p>
    
     Here,
    
    <strong class="source-inline">
     
      _GLOBAL__sub_I_welcome_main
     
    </strong>
    
     is the
    
    <a id="_idIndexMarker185">
    </a>
    
     function creating the global object in
    
    <strong class="source-inline">
     
      main.cpp
     
    </strong>
    
     – that is,
    
    <strong class="source-inline">
     
      C main_c("main") ;
     
    </strong>
    
     .
    
    
     Interesting!
    
    
     At this point, we’re convinced that the order of initialization for global objects works even after libraries – at least
    
    
     
      static ones.
     
    
   </p>
   <p>
    
     But we’re still not done.
    
    
     Let’s see what happens if we create a shared library.
    
    
     That isn’t that complicated.
    
    
     After removing the generated files – that is,
    
    <strong class="source-inline">
     
      synth.o
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      libsynth.a
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     – so that we have a clean plate, we need to run the following command to create a
    
    
     
      shared library:
     
    
   </p>
   <pre class="source-code">
&gt; $ g++ -fPIC -c -o  synth.o synth.cpp
&gt; $ g++ -shared -o libsynth.so synth.o
&gt; $ g++ -pie -o main main.cpp a.cpp b.cpp -L. -lsynth</pre>
   <p>
    
     Now, we can see how easily those magic switches fall into place from the beginning of this chapter, where we created a shared library and application that
    
    
     
      uses it.
     
    
   </p>
   <p>
    
     With all these pieces in place, we can see an
    
    <a id="_idIndexMarker186">
    </a>
    
     interesting change in how Ghidra presents the
    
    
     
      application overview:
     
    
   </p>
   <div><div><img alt="Figure 4.10 – The synth library as a dependency, as shown in Ghidra" src="img/B22235_04_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.10 – The synth library as a dependency, as shown in Ghidra
    
   </p>
   <p>
    
     Here, we can see a dependency on the
    
    <strong class="bold">
     
      libsynth.so
     
    </strong>
    
     library
    
    <a id="_idIndexMarker187">
    </a>
    
     we just created.
    
    
     Now, we can examine the part that interests us most regarding the executable –
    
    <strong class="bold">
     
      .
     
    </strong>
    
     <strong class="bold">
      
       init_array
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 4.11 – No reference to libsynth in the .init_array section" src="img/B22235_04_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.11 – No reference to libsynth in the .init_array section
    
   </p>
   <p>
    
     There’s no reference at all to the objects and functions in our synth library… No wonder – it’s a library.
    
    
     But at least we can still see that our application links to the
    
    
     
      library properly:
     
    
   </p>
   <pre class="source-code">
&gt; $ LD_LIBRARY_PATH=. ldd ./main
   linux-vdso.so.1 (0x00007fff17387000)
   libsynth.so =&gt; ./libsynth.so (0x00007ea84ee45000)
   libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6</pre>
   <p>
    
     Please observe that we have to specify
    
    <strong class="source-inline">
     
      LD_LIBRARY_PATH=.
     
    </strong>
    
     explicitly to find the library (note that we’ve also truncated unnecessary output lines to keep
    
    
     
      things clear).
     
    
   </p>
   <p>
    
     At this point, we’re curious about what happens when we execute
    
    
     
      the application:
     
    
   </p>
   <pre class="source-code">
&gt; $ LD_LIBRARY_PATH=. ./main
C::C : synth
welcome to the library
C::C : A
C::C : B
welcome to the main
C::C : main
print_synth: synth
C::~C : main
C::~C : B
C::~C : A
C::~C : synth</pre>
   <p>
    
     First, according to the expectations set by the single application test, the object(s) with the specified priority(ies) is(are) created in the library.
    
    
     Then, the constructor function from the library is called.
    
    
     If there were any other non-prioritized global objects in the library, they would have been created after these, before the prioritized objects from the main application were created and the constructor from the main application was called.
    
    
     All these operations were performed before the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function even had the chance to
    
    
     
      say
     
    
    
     <em class="italic">
      
       hush
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Almost as we expected it to happen.
    
    
     There’s just one dark corner of these function constructor extensions that I’ve been unable to find a cure for at the moment – what if
    
    <strong class="source-inline">
     
      a.cpp
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      b.cpp
     
    </strong>
    
     contain the
    
    
     
      following lines?
     
    
   </p>
   <pre class="source-code">
__attribute__((constructor)) void welcome_a() {
   printf("welcome to the 'a' file\n"); }
__attribute__((constructor)) void welcome_b() {
   printf("welcome to the 'b' file\n"); }</pre>
   <p>
    
     This unholy scribbling of spooky code adds two more constructor functions to our executable.
    
    
     Now, we have three.
    
    
     If you want to have a predictable order of execution for these constructor functions too, you need to specify their priority using
    
    <strong class="source-inline">
     
      __attribute__((constructor(205))) void welcome_b()
     
    </strong>
    
     .
    
    
     This will guarantee that these functions will also be executed in a specific order and that you’re not facing the global constructor invoking
    
    
     
      order fiasco.
     
    
   </p>
   <p>
    
     The behavior in case the library was dynamically loaded (
    
    <strong class="source-inline">
     
      dlopen
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      dlclose
     
    </strong>
    
     ) is the one that one would expect, i.e.
    
    
     it follows the execution flow of the main application, and at the point where the library is loaded, it will jump and execute the various constructors and object initializations from the library.
    
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor056">
    </a>
    
     Famous last words
    
   </h2>
   <p>
    
     This chapter dealt with code that is executed before the main function.
    
    
     However the same attention would require the topic
    
    <a id="_idIndexMarker188">
    </a>
    
     covering the code that is executed after the main function, but that debate will go in a different chapter, in a different book.
    
   </p>
   <p>
    
     But just to spoil you, here’s a small hint: the same way as there are constructor functions, there are also destructor functions.
    
    
     They’re not like C++ destructors – more
    
    
     
      like
     
    
    
     <strong class="source-inline">
      
       __attribute__((destructor))
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Spicing those up with the standard application exit routines, we have twice as much fun as the startup because we have to consider a myriad of other alternatives, such as functions registered for
    
    <strong class="source-inline">
     
      std::atexit
     
    </strong>
    
     (or even
    
    <strong class="source-inline">
     
      std::quick_exit
     
    </strong>
    
     ), or abnormal program termination.
    
    
     For example, let’s say an exception is thrown in a destructor or we use
    
    <strong class="source-inline">
     
      std::terminate
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       std::abort
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The documentation
    
    <a id="_idIndexMarker189">
    </a>
    
     on
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     offers a
    
    <a id="_idIndexMarker190">
    </a>
    
     nice escapade from the standard world, and any good book on C++ will offer a great overview of the standard termination routines, so please head over to them for a good lecture.
    
    
     A combination of these two will provide the best overview of how applications start
    
    
     
      and exit.
     
    
   </p>
   <p>
    
     For now, we’ll shift our attention toward other platforms before we get a good wigging from the folks at Packt – instead of the agreed-upon 16 pages for this chapter, we’re already at 22 and covered only half of the
    
    
     
      promised subject.
     
    
   </p>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor057">
    </a>
    
     Let’s open the Windows (unless you’re on ISS)
    
   </h1>
   <p>
    
     Before we delve deep into the internals of how an application is executed under Windows and the steps we must take to reach our main function, please note that from C++’s point of view, there should be no real difference from Linux or any other operating system.
    
    
     The C++-only standard functionality is (should be) identical to the functionality presented in the previous pages, so we won’t repeat the same
    
    
     
      information here.
     
    
   </p>
   <p>
    
     We will, however, present how and why the application starts under Windows the way it does and present some techniques that can directly influence this behavior, just like we did under Linux.
    
    
     We’ll also be using a Visual Studio compiler since
    
    <strong class="source-inline">
     
      gcc
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      clang
     
    </strong>
    
     for Windows behave identically, so there’s no sense in presenting
    
    
     
      them again.
     
    
   </p>
   <p>
    
     Due to its closed nature, to understand process creation under Windows, we need to resort to the few available resources that deal with this kind of information.
    
    
     One of these resources is the best book I’ve managed to find in this domain:
    
    <em class="italic">
     
      Windows Internals, 7th edition (Part 1)
     
    </em>
    
     ,
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-010">
       
        7
       
      </a>
     
    
    
     by Pavel Yosifovich, Alex Ionescu, Mark E.
    
    
     Russinovich, and David
    
    
     
      A.
     
     
      Solomon.
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-010-backlink">
      
       7
      
     </a>
     <a href="https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals">
      
       https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals
      
     </a>
    </p>
   </div>
   <p>
    
     The information gathered from that book is complemented by various scraps gathered from the world wide internet, and filtered in order to offer our readers a light introduction to the Windows side of process creation.
    
    
     We will reference back however some of the notions encountered in the Linux subsection of this chapter, so reading it would be beneficial.
    
    
     Also, a small observation: security, thread handling, and user management are much more fine-tuned in Windows than in Linux, and all this is reflected in the way processes are treated.
    
    
     If you’re interested in understanding this domain, there are several resources available, such as the excellent
    
    <em class="italic">
     
      Windows Security Internals: A Deep Dive into Windows Authentication, Authorization, and Auditing
     
    </em>
    
     , by James Forshaw.
    
    
     We recommend reading through it if you’re interested in
    
    
     
      the domain.
     
    
   </p>
   <p>
    
     Let’s get back to the processes.
    
    
     The process creation mechanism in Windows involves several stages that are executed by different components of the operating system: the Windows client-side library,
    
    <strong class="bold">
     
      kernel32.dll
     
    </strong>
    
     , the
    
    <a id="_idIndexMarker191">
    </a>
    
     Windows executive, and the Windows subsystem
    
    <a id="_idIndexMarker192">
    </a>
    
     process (
    
    <strong class="bold">
     
      csrss.exe
     
    </strong>
    
     ).
    
    
     Due to the simple fact that we don’t have access to the sources of these Windows components, our presentation on this matter will be a very
    
    
     
      high-level one.
     
    
   </p>
   <p>
    
     Processes in Windows are created by a function of the CreateProcess family, which comes with several relatives and uncles (
    
    <strong class="source-inline">
     
      create process
     
    </strong>
    
     as a different user, create process with various security clearances, etc…) but all members of the extended family routines after several iterations end up in the  CreateProcessInternalW function in
    
    <strong class="bold">
     
      kernel32.dll
     
    </strong>
    
     , which first validates and converts some of the parameters and flags to an internal representation (to which sadly we have
    
    
     
      no access).
     
    
   </p>
   <p>
    
     The priority class for the new process is determined by the
    
    <strong class="source-inline">
     
      CreationFlags
     
    </strong>
    
     parameter.
    
    
     In Windows, there are six priority classes: Idle, Below Normal, Normal, Above Normal, High, and Real-time.
    
    
     If no priority class is specified, the priority class defaults to Normal.
    
    
     If Real-time is requested but the caller lacks the necessary privileges, the priority is downgraded
    
    
     
      to High.
     
    
   </p>
   <p>
    
     Next,
    
    <strong class="bold">
     
      kernel32.dll
     
    </strong>
    
     initiates a connection to the native debugging interface if the process is to be debugged and sets the default hard error mode if specified.
    
    
     The user-specified attribute list is converted into its native format, and any additional internal attributes are added.
    
    
     The security attributes for the process and initial thread are also converted into
    
    
     
      internal representations.
     
    
   </p>
   <p>
    
     The next step is to open the executable image to be run.
    
    
     This task is handled within the
    
    <strong class="source-inline">
     
      NtCreateUserProcess
     
    </strong>
    
     system call.
    
    
     First, the function validates the arguments again to ensure they haven’t been tampered with.
    
    
     Then, it attempts to find and open the appropriate Windows image and create a section object, which will be mapped into the new process’s address space at a
    
    
     
      later date.
     
    
   </p>
   <p>
    
     If the image isn’t a valid Windows executable, the function searches for a support image to run it.
    
    
     For instance, if the executable is an MS-DOS or Win16 application, it uses
    
    <strong class="bold">
     
      ntvdm.exe
     
    </strong>
    
     (for 32-bit Windows) to
    
    <a id="_idIndexMarker193">
    </a>
    
     run it.
    
    
     This ensures that older DOS or Win16 applications can be executed correctly within the Windows environment.
    
    
     However, this feature has been slowly deprecated on modern Windows systems, so you need to enable it so that it
    
    
     
      can function.
     
    
   </p>
   <p>
    
     Once the executable image has been opened, the next stage is to create the Windows executive process object.
    
    
     This involves setting up the process’s virtual address space and other critical structures.
    
    
     The executive process object serves as a container for all the resources needed by the process, including memory, handles,
    
    
     
      and threads.
     
    
   </p>
   <p>
    
     With the process object in place, the initial thread is created.
    
    
     This step involves setting up the thread’s stack, context, and executive thread object.
    
    
     The thread is responsible for executing the program’s entry point and managing the process’s
    
    
     
      execution flow.
     
    
   </p>
   <p>
    
     After the initial thread is created, Windows performs subsystem-specific initialization tasks.
    
    
     These tasks are essential for integrating the new process into the Windows subsystem, which provides the environment and resources necessary for the process to
    
    
     
      run correctly.
     
    
   </p>
   <p>
    
     The initial thread is then started, unless the
    
    <strong class="source-inline">
     
      CREATE_SUSPENDED
     
    </strong>
    
     flag is specified, in which case the thread remains suspended until it’s explicitly resumed.
    
    
     Starting the thread involves switching to user mode and executing the process’s
    
    
     
      entry point.
     
    
   </p>
   <p>
    
     Finally, in the context of the new process and thread, the address space is initialized.
    
    
     This includes loading any required DLLs and performing any other necessary setup tasks.
    
    
     Once these steps are complete, the process begins executing its code, and process creation is
    
    
     
      considered complete.
     
    
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor058">
    </a>
    
     To PE or not to PE
    
   </h2>
   <p>
    
     Like every other file with a specific meaning, the bytes that conjure up Windows-based executables also have a
    
    
     
      special meaning.
     
    
   </p>
   <p>
    
     The Windows
    
    <strong class="bold">
     
      Portable Executable
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PE
     
    </strong>
    
     ) format
    
    <a id="_idIndexMarker194">
    </a>
    
     is a file format for executables, object code, DLLs, and other system files that are used in Windows operating systems.
    
    
     It’s the standard file format for executables in
    
    <a id="_idIndexMarker195">
    </a>
    
     DOS (as well as FreeDOS), Windows, and ReactOS and
    
    <a id="_idIndexMarker196">
    </a>
    
     encompasses both the
    
    <strong class="bold">
     
      executable
     
    </strong>
    
     (
    
    <strong class="bold">
     
      EXE
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      Dynamic Link Library
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DLL
     
    </strong>
    
     )
    
    
     
      file types.
     
    
   </p>
   <p>
    
     The PE
    
    <a id="_idIndexMarker197">
    </a>
    
     format is designed to be extensible and capable of supporting modern operating system features.
    
    
     If you’re interested in this domain, there are excellent learning opportunities online, so we encourage you to study this subject since this book can’t encompass all the required information due to lack
    
    
     
      of space.
     
    
   </p>
   <p>
    
     Here’s a filtered explanation of its structure and components, mostly the ones relevant to
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       DOS
      
     </strong>
     
      <strong class="bold">
       
        header (IMAGE_DOS_HEADER)
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       The file begins
      
      <a id="_idIndexMarker198">
      </a>
      
       with
      
      <strong class="bold">
       
        MZ
       
      </strong>
      
       , the initials of Mark Zbikowski, the engineer who created this format while working at Microsoft.
      
      
       This is followed by a DOS header, which is a relic from the MS-DOS days.
      
      
       This header includes a small DOS stub program that displays a message (“This program can’t be run in DOS mode”) if the executable is run in a DOS environment.
      
      
       The last section of the DOS header contains a pointer to the PE
      
      
       
        header’s location.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       PE
      
     </strong>
     
      <strong class="bold">
       
        header (IMAGE_NT_HEADERS)
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Signature
        
       </strong>
       
        : This
       
       <a id="_idIndexMarker199">
       </a>
       
        identifies the file as a PE file.
       
       
        The signature is a 4-byte value – that
       
       
        
         is,
        
       
       
        <strong class="source-inline">
         
          PE\0\0
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="bold">
        
         File header
        
       </strong>
       
        (
       
       <strong class="source-inline">
        
         IMAGE_FILE_HEADER
        
       </strong>
       
        ): This contains basic information about the file, such as the
       
       <a id="_idIndexMarker200">
       </a>
       
        target machine type, the number of sections, the time and date the file was created, and the size of the
       
       
        
         optional header.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Optional header
        
       </strong>
       
        (
       
       <strong class="source-inline">
        
         IMAGE_OPTIONAL_HEADER
        
       </strong>
       
        ): This provides essential information for loading and
       
       <a id="_idIndexMarker201">
       </a>
       
        running the program.
       
       
        Despite its name, this header is required for executable files and includes the
       
       
        
         following aspects:
        
       
       <ul>
        <li>
         <strong class="bold">
          
           Magic number
          
         </strong>
         
          : Identifies the format (for example, PE32 for 32-bit and PE32+
         
         
          
           for 64-bit)
          
         
        </li>
        <li>
         <strong class="source-inline">
          
           AddressOfEntryPoint
          
         </strong>
         
          : The address where
         
         
          
           execution starts
          
         
        </li>
        <li>
         <strong class="source-inline">
          
           ImageBase
          
         </strong>
         
          : The preferred base address for the executable
         
         
          
           in memory
          
         
        </li>
        <li>
         <strong class="source-inline">
          
           SectionAlignment
          
         </strong>
         
          : Alignment of sections
         
         
          
           in memory.
          
         
        </li>
        <li>
         <strong class="source-inline">
          
           SizeOfImage
          
         </strong>
         
          : The total size of the image
         
         
          
           in memory
          
         
        </li>
        <li>
         <strong class="source-inline">
          
           Subsystem
          
         </strong>
         
          : Identifies
         
         <a id="_idIndexMarker202">
         </a>
         
          the required subsystem (Windows GUI
         
         
          
           or CUI)
          
         
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Section
      
     </strong>
     
      <strong class="bold">
       
        headers (IMAGE_SECTION_HEADER)
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       Following the PE header, there are one or more section headers, each describing a section of the file.
      
      
       These sections contain the actual data and code of the program.
      
      
       The following are some
      
      <a id="_idIndexMarker203">
      </a>
      
       
        common sections:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         .text
        
       </strong>
       
        : Contains
       
       
        
         executable code.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         .data
        
       </strong>
       
        : Contains initialized global and
       
       
        
         static variables.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         .bss
        
       </strong>
       
        : Contains
       
       
        
         uninitialized data.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         .rdata
        
       </strong>
       
        : Read-only data (such as string literals
       
       
        
         and constants).
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         .idata
        
       </strong>
       
        :  Import table, listing the functions and DLLs that the executable depends on.
       
      </li>
      <li>
       <strong class="source-inline">
        
         .edata
        
       </strong>
       
        :  Export table, listing functions and data that the executable exposes to other modules.
       
      </li>
     </ul>
    </li>
    <li>
     
      <strong class="bold">
       
        Data directories
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       Part of the optional header, these
      
      <a id="_idIndexMarker204">
      </a>
      
       directories provide information about the location and size of various tables and data structures within the executable file, including:
      
     </p>
     <ul>
      <li>
       <strong class="bold">
        
         Import table
        
       </strong>
       
        : Lists the DLLs and
       
       <a id="_idIndexMarker205">
       </a>
       
        functions imported by
       
       
        
         the executable.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Export table
        
       </strong>
       
        : Lists the
       
       <a id="_idIndexMarker206">
       </a>
       
        functions and data exported by
       
       
        
         the executable.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Resource table
        
       </strong>
       
        : Contains
       
       <a id="_idIndexMarker207">
       </a>
       
        resources that are built into the application, such as icons, menus, and dialogs.
       
       
        These resources are stored in a resource tree, depending on their type.
       
       
        There’s also support for variations in multiple languages for the
       
       
        
         same resource.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Exception table
        
       </strong>
       
        : Contains
       
       <a id="_idIndexMarker208">
       </a>
       
        information for
       
       
        
         exception handling.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Relocation table
        
       </strong>
       
        : Used
       
       <a id="_idIndexMarker209">
       </a>
       
        for
       
       
        
         address fixups.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      <strong class="bold">
       
        Sections
       
      </strong>
     
     
      
       :
      
     
     <p class="list-inset">
      
       The actual sections
      
      <a id="_idIndexMarker210">
      </a>
      
       follow the headers and contain the executable code, initialized data, and other components that the program needs
      
      
       
        to run.
       
      
     </p>
     <p class="list-inset">
      
       Each section is aligned based on the
      
      <strong class="source-inline">
       
        SectionAlignment
       
      </strong>
      
       value specified in the
      
      
       
        optional header.
       
      
     </p>
    </li>
   </ul>
   <p>
    
     For us, the most important and interesting part of this list of sections and subsections is the
    
    
     <strong class="source-inline">
      
       AddressOfEntryPoint
      
     </strong>
    
    
     
      field.
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor059">
    </a>
    
     Getting our hands dirty
    
   </h2>
   <p>
    
     Our initial approach will be a very clean
    
    <a id="_idIndexMarker211">
    </a>
    
     application to work on, a classical “Hello World!”
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello World!\n";
}</pre>
   <p>
    
     This will allow us to understand how a very simple application is loaded and executed under Windows.
    
    
     However, before taking things further, a small remark: under Windows, there are different kinds of applications, as indicated by the
    
    <strong class="source-inline">
     
      OptionalHeader
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      Subsystem
     
    </strong>
    
     field in the
    
    
     
      PE header.
     
    
   </p>
   <p>
    
     For our purpose, which is to dissect an application to examine how it starts, we’ll create a Console Application.
    
    
     There are other types of applications we could look at, but they’re overly complex.
    
    
     For example, if they have a GUI, then we must implement complicated message loops and dependencies, so we’ll stick with
    
    
     
      something simple.
     
    
   </p>
   <p>
    
     Assuming that we’ve successfully
    
    <a id="_idIndexMarker212">
    </a>
    
     compiled our synthetic console application, we can fire up Ghidra and see that a large section of the file resembles the standard PE header
    
    
     
      shown previously:
     
    
   </p>
   <div><div><img alt="Figure 4.12 – The contents of the PE header" src="img/B22235_04_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.12 – The contents of the PE header
    
   </p>
   <p>
    
     This is a lot of information to digest, but what’s interesting for us is the
    
    <strong class="source-inline">
     
      AddressOfEntryPoint
     
    </strong>
    
     field.
    
    
     At the moment, it points to a method called
    
    <strong class="source-inline">
     
      entry
     
    </strong>
    
     .
    
    
     This is where our application will start executing, so let’s examine this function in a bit more detail.
    
    
     If we dig deeper and
    
    <a id="_idIndexMarker213">
    </a>
    
     see what the entry is, we’ll reach the
    
    
     
      following function:
     
    
   </p>
   <pre class="source-code">
ulong __cdecl entry(void *param_1) {
  ulong uVar1;
  uVar1 = __scrt_common_main();
  return uVar1;
}</pre>
   <p>
    
     This in itself is an interesting discovery as it seems to be the entry point of console-based Windows applications.
    
    
     Let’s explore this further.
    
    
     The next function that’s run is
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
int __cdecl __scrt_common_main(void) {
  int iVar1;
   __security_init_cookie();
  iVar1 = __scrt_common_main_seh();
  return iVar1;
}</pre>
   <p>
    
     Microsoft’s page
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-009">
       
        8
       
      </a>
     
    
    
     contains a detailed description of the
    
    <strong class="source-inline">
     
      __security_init_cookie()
     
    </strong>
    
     function.
    
    
     However, the other function is a different kind of beast.
    
    
     It does a large amount of initialization, such as setting up the terminal and handling initialization errors.
    
    
     At some point, the following piece of code
    
    
     
      is executed:
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-009-backlink">
      
       8
      
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170">
      
       https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170
      
     </a>
    </p>
   </div>
   <div><div><img alt="Figure 4.13 – The invocation of main()" src="img/B22235_04_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.13 – The invocation of main()
    
   </p>
   <p>
    
     As you may
    
    <a id="_idIndexMarker214">
    </a>
    
     have guessed,
    
    <strong class="source-inline">
     
      invoke_main
     
    </strong>
    
     is responsible for
    
    
     
      invoking
     
    
    
     <strong class="source-inline">
      
       main()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
int __cdecl invoke_main(void) {
  char **_Argv;
  char **_Env;
  undefined4 *puVar1;
  int *piVar2;
  int iVar3;
  _Env = (char **)__get_initial_narrow_environment();
  puVar1 = (undefined4 *)___p___argv();
  _Argv = (char **)*puVar1;
  piVar2 = (int *)___p___argc();
  iVar3 = main(*piVar2,_Argv,_Env);
  return iVar3;
}</pre>
   <p>
    
     At this point, we’ve reached the stage where our
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function is called.
    
    
     Even for a simple “Hello World!”
    
    
     application, there’s a large amount of boilerplate code that needs to
    
    
     
      be executed.
     
    
   </p>
   <p>
    
     Now, it’s time to go one step further and take our synthetic application on a ride through Ghidra (for brevity’s sake, we’ll omit that we must create a project, compile it, and link the application; let’s just assume the application summons itself
    
    
     
      by magic).
     
    
   </p>
   <p>
    
     Since we’re mostly interested in determining the order of function calls before
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     , and we know that we initialize the
    
    <strong class="source-inline">
     
      my_a
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      my_other_a
     
    </strong>
    
     variables globally, we need to look through the binary.
    
    
     At some point, we’ll spot the following
    
    
     
      interesting data:
     
    
   </p>
   <div><div><img alt="Figure 4.14 – The .CRT$XCU section according to Ghidra" src="img/B22235_04_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.14 – The .CRT$XCU section according to Ghidra
    
   </p>
   <p>
    
     Well, this looks interesting, especially
    
    <a id="_idIndexMarker215">
    </a>
    
     that cryptic
    
    <strong class="source-inline">
     
      .CRT$XCU
     
    </strong>
    
     text.
    
    
     This takes us back to a few paragraphs prior, where the sections of a PE file were discussed: sections are distinct areas within the executable file that hold different types of data
    
    
     
      and code.
     
    
   </p>
   <p>
    
     Each section serves a specific purpose and has attributes that define its behavior and how it should be handled by the operating system.
    
    
     There’s excellent documentation
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_04.xhtml#footnote-008">
       
        9
       
      </a>
     
    
    
     on Microsoft’s site that discusses the sections responsible for initializing CRT, a quick summary of
    
    
     
      it follows.
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_04.xhtml#footnote-008-backlink">
      
       9
      
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170">
      
       https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170
      
     </a>
    </p>
   </div>
   <p>
    
     According to the documentation, by default, the CRT library is included via the linker, which ensures that the CRT is initialized properly, global initializers are called, and, subsequently, the user-defined
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function is executed.
    
    
     When the compiler encounters a global initializer, it creates a dynamic initializer and places it in the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       CRT$XCU
      
     </strong>
    
    
     
      section.
     
    
   </p>
   <p>
    
     The CRT uses specific pointers such as
    
    <strong class="source-inline">
     
      __xc_a
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      __xc_z
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      .CRT$XCA
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      .CRT$XCZ
     
    </strong>
    
     initialization sections to define the start and end of the list of initializers, ensuring they’re called in the correct order.
    
    
     The
    
    <strong class="source-inline">
     
      __scrt_common_main_seh()
     
    </strong>
    
     function, which we discussed previously, is responsible for setting these
    
    
     
      up correctly.
     
    
   </p>
   <p>
    
     These names are predefined by the CRT, and the linker arranges these sections alphabetically.
    
    
     This ordering ensures that user-defined initializers in
    
    <strong class="source-inline">
     
      .CRT$XCU
     
    </strong>
    
     are executed between the
    
    
     
      standard sections.
     
    
   </p>
   <p>
    
     To manipulate the initialization order, developers can place their initializers in unused reserved sections such as
    
    <strong class="source-inline">
     
      .CRT$XCT
     
    </strong>
    
     (before compiler-generated initializers) and
    
    <strong class="source-inline">
     
      .CRT$XCV
     
    </strong>
    
     (after compiler-generated initializers) using specific pragmas, as detailed in the CRT startup documentation mentioned a few paragraphs prior, but before jumping on that technique, please read below because things are a bit more complicated than they seem.
    
   </p>
   <p>
    
     According to Microsoft, that subject is so platform and compiler-specific that we don’t wish to explore those fields, especially considering the warning that comes from the
    
    
     
      official site:
     
    
   </p>
   <p class="author-quote">
    
     “The names .CRT$XCT and .CRT$XCV aren’t used by either the compiler or the CRT library right now, but there’s no guarantee that they’ll remain unused in the future.
    
    
     And, your variables could still be optimized away by the compiler.
    
    
     Consider the potential engineering, maintenance, and portability issues before adopting this technique.”
    
   </p>
   <p>
    
     So, once again, we’ll just
    
    <a id="_idIndexMarker216">
    </a>
    
     repeat what the official warning said: unless you have to do this kind of hackery, please refrain from using these halfheartedly documented “features” of the language and compiler since (again, as mentioned in the official warning) there’s no guarantee that if it works today, it will work tomorrow, or even after the next
    
    
     
      system update.
     
    
   </p>
   <p>
    
     Instead, let’s turn our attention toward the functions that we “discovered” in the
    
    <strong class="source-inline">
     
      .CRT$XCU
     
    </strong>
    
     section and see what kind of sorcery lies behind this very explicit name, which undoubtedly isn’t standard C (
    
    
     
      nor C++):
     
    
   </p>
   <pre class="source-code">
void __cdecl `dynamic_initializer_for_'my_a''(void)
{
int iVar1;
uchar *unaff_EDI;
undefined4 *puVar2;
  puVar2 = (undefined4 *)&amp;stack0xfffffffc;
for (iVar1 = 0; iVar1 != 0; iVar1 = iVar1 + -1) {
   *puVar2 = 0xcccccccc;
   puVar2 = puVar2 + 1;
}
__CheckForDebuggerJustMyCode(unaff_EDI);
A::A(&amp;my_a,my_string);
atexit(`dynamic_atexit_destructor_for_'my_a'');
return;
}</pre>
   <p>
    
     After performing some maintenance tasks (such as initializing the stack with the
    
    <strong class="source-inline">
     
      0xcccccccc
     
    </strong>
    
     value), we can see the function call to the constructor of
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     , with stylishly the first parameter being the
    
    <strong class="source-inline">
     
      this
     
    </strong>
    
     object, and registering an
    
    <strong class="source-inline">
     
      atexit
     
    </strong>
    
     function for the destructor of the class for the specific object, again.
    
   </p>
   <p>
    
     This
    
    <strong class="source-inline">
     
      0xcccccccc
     
    </strong>
    
     pattern
    
    <a id="_idIndexMarker217">
    </a>
    
     is the
    
    <a id="_idIndexMarker218">
    </a>
    
     typical way the Visual C++ compiler marks uninitialized stack memory, making it easier to detect the use of uninitialized memory in debugging sessions.
    
    
     Interestingly, the loop doesn’t seem to execute.
    
    
     However, if we were to dig deeper into the debug builds of functions that have larger C-style arrays, we’d see this stack protection scheme in action, together with some nicely set-up
    
    
     
      stack canaries.
     
    
   </p>
   <p>
    
     Stack
    
    <a id="_idIndexMarker219">
    </a>
    
     canaries are a security mechanism designed to detect and prevent stack-based buffer overflow attacks by placing a special value (called the canary) between a function's local variables and its control data on the stack (such as the return address and the saved frame pointer).
    
   </p>
   <p>
    
     If a buffer overflow occurs, the canary value is altered, signaling that some mischief has taken place.
    
    
     This allows the program to take corrective actions, such as terminating execution to
    
    
     
      prevent exploitation.
     
    
   </p>
   <p>
    
     The origin of this term is a bit obscure, and it goes back to the historical use of canaries in coal mines.
    
    
     Miners would bring canaries into the mines to detect toxic gases such as carbon monoxide.
    
    
     Since canaries are more sensitive to these gases than humans, if the bird became ill or died (that is, it stopped singing), it served as an early warning signal for miners to evacuate.
    
    
     This isn’t quite of mythological proportions, but it’s pragmatic – especially if you’re the miner, not
    
    
     
      the canary.
     
    
   </p>
   <p>
    
     With these notions set in place, we have an overview of how the application loads under Windows, but only from the console.
    
    
     But let’s not forget that Windows is a GUI environment.
    
    
     It creates windows and dialogs, has a message loop, and deals with a plethora
    
    
     
      of events.
     
    
   </p>
   <p>
    
     However, the startup process of a Windows GUI application isn’t that dissimilar to a console-based application.
    
    
     The main difference is that the
    
    <strong class="source-inline">
     
      invoke_main
     
    </strong>
    
     function invokes two different functions before invoking a GUI-specific
    
    <strong class="source-inline">
     
      WinMain
     
    </strong>
    
     function, dealing with the show state of the window and the command
    
    
     
      line options.
     
    
   </p>
   <p>
    
     The first function allows us to show the window of the application in
    
    
     
      different ways.
     
    
   </p>
   <p>
    
     The second function is the command line of the application, in a wide
    
    
     
      string format.
     
    
   </p>
   <p>
    
     The rest is just
    
    <a id="_idIndexMarker220">
    </a>
    
     calling the
    
    <strong class="source-inline">
     
      WinMain
     
    </strong>
    
     and from there, we are in familiar territory, at least programmers who have experience in
    
    
     
      this domain.
     
    
   </p>
   <p>
    
     In closing this chapter, there’s nothing else but encourage our readers to experiment while hacking around binaries – that’s the only way to truly understand how a specific functionality will behave on
    
    
     
      your system.
     
    
   </p>
   <h1 id="_idParaDest-61">
    <a id="_idTextAnchor060">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, the author tried to provide a not-so-comprehensive overview of the application startup processes on both Linux and Windows.
    
    
     The insights that were provided into the initial stages of execution, including the critical steps before reaching the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, weren’t as complete as the platforms themselves require, but then this book would have been called something else since this is a huge and very niche topic that doesn’t attract a broad range
    
    
     
      of programmers.
     
    
   </p>
   <p>
    
     By exploring ELF on Linux, understanding the
    
    <strong class="source-inline">
     
      execve()
     
    </strong>
    
     system call, and examining the
    
    <strong class="source-inline">
     
      _start()
     
    </strong>
    
     function, you gained valuable knowledge about the underlying architecture and initialization routines.
    
    
     Similarly, the discussion on Windows highlighted the startup sequence for both console-based and GUI applications, emphasizing the role of the various sections and how they come together to start that pesky program of yours, especially if it’s
    
    
     
      not working.
     
    
   </p>
   <p>
    
     By leaving a window of opportunity open to further deepen the understanding of this topic, we recommended that you engage in hands-on experimentation by creating and analyzing binaries, modifying startup routines, and observing the effects on different operating systems.
    
    
     You even can manually change various addresses in the headers of executables to see what happens and how
    
    
     
      they crash.
     
    
   </p>
   <p>
    
     This practical approach will not only reinforce the concepts that were covered in this chapter but also provide you with a more profound and practical grasp of application startup processes.
    
    
     By actively exploring and experimenting, you’ll enhance your ability to troubleshoot, optimize, and innovate within the realm of software development while learning useful and fun facts about the software and the environment it
    
    
     
      runs in.
     
    
   </p>
   <p>
    
     In our next chapter, the correct order of declaration of class members, cover will we.
    
    
     Through the adventures of one programmer who on quest bug-free code to write was, bugs we will see.
    
    
     Keep on reading please, you shall.
    
   </p>
  </div>
 </body></html>