<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor147"/>7</h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Using Remote Procedure Calls (RPCs)</h1>
<p>Now that you have a strong grip on the world of property replication, it’s time to introduce you to the way in which functions can be called across the network. In Unreal, this is achieved through <strong class="bold">Remote Procedure Calls</strong> (<strong class="bold">RPCs</strong>) – one of the most powerful features <a id="_idIndexMarker405"/>of the engine networking system.</p>
<p>In this chapter, you will learn how to execute functions through RPCs and understand how to run them on the server, on a client, or on all clients that have an instance of a particular object.</p>
<p>Additionally, you will learn about the common requirements for properly calling these types of functions – in particular, I will explain the difference between a reliable and an unreliable function.</p>
<p>Finally, you will obviously apply this newfound, precious knowledge to the project you have developed so far.</p>
<p>So, in the next sections, I will present the following topics:</p>
<ul>
<li>Understanding what an RPC is</li>
<li>Executing RPCs over the network</li>
<li>Implementing a door system</li>
</ul>
<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed the previous ones and understood their content.</p>
<p>Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the <code>.zip</code> project files provided in this book’s companion project repository:</p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a></p>
<p>You can download the files that are up to date with the end of the last chapter by clicking the <code>Unreal Shadows – </code><code>Chapter 06</code><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Understanding what an RPC is</h1>
<p>An <strong class="bold">RPC</strong> is a function that can be called locally but is executed on a different machine – for instance, a server <a id="_idIndexMarker406"/>computer may call a function on a client computer that will command it to spawn a visual effect or a sound somewhere in the level. Another useful application of an RPC is the ability to send messages bi-directionally between a server and a client over a network connection.</p>
<p>There are three types of RPCs available in Unreal Engine:</p>
<ul>
<li><strong class="bold">Server</strong>: The function will be called by an object on the client PC but executed only on the server version <a id="_idIndexMarker407"/>of that same object. The client must own the object calling the method (if you need to, please check <a href="B18203_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Actors in a Multiplayer Environment</em>, for a refresher about owning an Actor).</li>
<li><strong class="bold">Client</strong>: The function will be <a id="_idIndexMarker408"/>called on the server by an object but executed only on the client version that owns the object calling it.</li>
<li><strong class="bold">NetMulticast</strong>: The function can <a id="_idIndexMarker409"/>be called on the server by an object and executed on the server and all client versions of the object calling it. It can also be called by a client but, in this case, it will only be executed locally (i.e., on the client calling it).</li>
</ul>
<p>In order for a function to be properly executed as an RPC, it must be called by an Actor and the Actor must be replicated. Additionally, the function needs to be decorated with the <code>UFUNCTION()</code> macro.</p>
<p>A function that will run just on the owning client will be declared in the <code>.h</code> file as in the following piece of code:</p>
<pre class="source-code">
UFUNCTION(Client)
void DoSomething_Client();</pre>
<p>In the corresponding <code>.cpp</code> file of the previous header, you will need to implement this function <a id="_idIndexMarker410"/>with the <code>_Implementation</code> suffix. The autogenerated code for this class – located in the <code>.generated.h</code> file – will automatically include a call to the <code>_Implementation</code> method when necessary. For a refresher on the <code>.generated.h</code> file, please check <a href="B18203_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>, <em class="italic">Setting Up Your First </em><em class="italic">Multiplayer Environment</em>.</p>
<p>Looking at an example, let’s say your <code>.h</code> header file has a method declaration similar to the following piece of code:</p>
<pre class="source-code">
UFUNCTION(Server)
void DoSomething_Server();</pre>
<p>You will need to implement the following function in your <code>.</code><code>cpp</code> file:</p>
<pre class="source-code">
void DoSomething_Server_Implementation()
{ /* Your code here */ }</pre>
<p>A method is not always guaranteed to be received by the recipient due to performance reasons; however, this behavior can be adjusted, as demonstrated in the following subsection.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Reliability of an RPC</h2>
<p>RPCs are unreliable by <a id="_idIndexMarker411"/>default – this means there is no guarantee that the function call will reach its destination. This is usually acceptable if the executed code is not so important, such as a visual effect spawned on a client or a random noise played near the character; if the message is not received, the effect will simply not spawn or the sound won’t be heard, but gameplay will not be affected.</p>
<p>There are, however, some cases where you want to enforce reliability and guarantee that a message will securely arrive at its destination – as an example, in this chapter, you will execute the sprint action from the server side (you don’t really want to lose that very important interaction with the player). To make sure that an RPC call is executed on the remote machine, you can utilize the <code>Reliable</code> keyword.</p>
<p>To illustrate this point, a function that should be executed reliably on a client will be declared with the following code:</p>
<pre class="source-code">
UFUNCTION(Client, Reliable)
void DoSomethingReliably_Client();</pre>
<p>This will guarantee <a id="_idIndexMarker412"/>that the method call will be received by the client and properly executed, without any risk of data loss over the network because of unreliability.</p>
<p class="callout-heading">Note</p>
<p class="callout">Avoid using reliable RPCs during the <code>Tick()</code> event and exercise caution when binding them to player input. This is because players can repeatedly press buttons very quickly, leading to an overflow of the queue for reliable RPCs.</p>
<p>In addition to reliability, you may want a method to be validated in order to be executed – this is something I’m going to show you right now!</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Validating RPCs</h2>
<p>Unreal Engine offers <a id="_idIndexMarker413"/>an additional feature that adds the ability to check that functions will execute without bad data or input – this is what <strong class="bold">validation</strong> is all about.</p>
<p>To declare that a method should be validated for an RPC call, you need to add the <code>WithValidation</code> specifier to the <code>UFUNCTION()</code> declaration statement and implement an additional function that will return a <code>bool</code> type and be named as the validated function, but with the <code>_Validate</code> suffix.</p>
<p>As an example, a method marked with validation will have a declaration in the <code>.h</code> file, similar to the following code:</p>
<pre class="source-code">
UFUNCTION(Server, WithValidation)
void DoSomethingWithValidation();</pre>
<p>Then, in the <code>.cpp</code> file, you will need to implement two methods. The first one will be the regular function, and will look like the following code:</p>
<pre class="source-code">
void DoSomethingWithValidation_Implementation()
{ /* Your code here */ }</pre>
<p>The second one will be the actual validation function, and will look like the following code:</p>
<pre class="source-code">
bool DoSomethingWithValidation_Validate()
{ /* Your code here */ }</pre>
<p>The <code>_Validate</code> function will return <code>true</code> if the code is validated, or <code>false</code> otherwise. If validation succeeds, the corresponding method will be executed; otherwise, it won’t.</p>
<p>In this section, I have introduced RPCs and how Unreal Engine copes with them. Bear with me – if you’re <a id="_idIndexMarker414"/>working in the networked games industry, mastering RPCs is key to keeping your job and growing your career!</p>
<p>Now that you have a solid understanding of how an RPC should be implemented, it’s time to write some code – and we are going to start by hunting down that pesky little bug that is stopping our thief hero from sprinting freely (and correctly!) around the dungeon.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor153"/>Executing RPCs over the network</h1>
<p>In this section, you’ll do some practice with RPCs by fixing the issue we are experiencing with making the <a id="_idIndexMarker415"/>character sprint correctly. As you may remember, when the character is sprinting on the client, you will get “jumpy” behavior – the character seems to start running but it is immediately brought back to a walking speed.</p>
<p>This happens because the sprint action is being executed on the player client, but it is not being executed on the server, which is the one that is in command; hence, the override from the server slows the character to its move speed on every update. This means that you are trying to move your character at a sprint speed but, as soon as the server replicates the movement on the client, it will bring the character back to moving speed.</p>
<p>We don’t even <a id="_idIndexMarker416"/>want the client to control this kind of important interaction – remember that it is the server who is in command – so, get back to the project and start typing some code to fix this problem!</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Calling a function on the server</h2>
<p>To make our <a id="_idIndexMarker417"/>character run, we simply have to execute the movement speed change on the server, instead of on the client. This will guarantee total control over the behavior and correct replication on all clients.</p>
<p>Let’s start by opening the <code>US_Character.h</code> file and do some code declarations. In the <code>protected</code> section, add these two methods:</p>
<pre class="source-code">
UFUNCTION(Server, Reliable)
void SprintStart_Server();
UFUNCTION(Server, Reliable)
void SprintEnd_Server();</pre>
<p>These functions have the <code>Server</code> attribute, which, as explained in the previous section, will execute them on the server. We have also added the <code>Reliable</code> attribute because we don’t want to lose this RPC due to the default unreliability of the system. The <code>_Server</code> suffix is not mandatory and is written just for clarity (some people use a prefix, so it is up to your personal taste!).</p>
<p>Now open the <code>US_Character.cpp</code> file and implement the two functions by adding the following code:</p>
<pre class="source-code">
void AUS_Character::SprintStart_Server_Implementation()
{
 if (GetCharacterStats())
 {
  GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;SprintSpeed;
 }
}
void AUS_Character::SprintEnd_Server_Implementation()
{
 if (GetCharacterStats())
 {
  GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
 }
}</pre>
<p>The code is pretty straightforward as we are just executing the speed change inside these two new functions and, in just a moment, we are going to remove them from their previous positions (i.e., from the client calls).</p>
<p>Here, just notice the <code>_Implementation</code> suffix – this is mandatory as the <code>SprintStart_Server()</code> and <code>SprintEnd_Server()</code> functions will be auto-generated by Unreal in the <code>.generated.h</code> class file and will be responsible for calling the actual implementations.</p>
<p>We now need to change the <code>SprintStart()</code> and <code>SprintEnd()</code> functions, in order to call the <a id="_idIndexMarker418"/>corresponding server fuctions (i.e., <code>SprintStart_Server()</code> and <code>SprintEnd_Server()</code>). Find those two functions and remove all their content (i.e., the changes to <code>MaxWalkSpeed</code>) and then, in the <code>SprintStart()</code> function, add this simple line of code:</p>
<pre class="source-code">
SprintStart_Server();</pre>
<p>In the <code>SprintEnd()</code> function, add this line of code:</p>
<pre class="source-code">
SprintEnd_Server();</pre>
<p>To make the sprint action fully operational, we need to take one final step. At the moment, if the character is running and levels up, the movement will revert to walking speed. This happens because, in the <code>UpdateCharacterStats()</code> function, we set the <code>MaxWalkSpeed</code> property to the new walk speed, even if the character is sprinting.</p>
<p>Let’s fix this by finding the <code>UpdateCharacterStats()</code> method and adding, at its very beginning, the following code:</p>
<pre class="source-code">
auto IsSprinting = false;
if(GetCharacterStats())
{
 IsSprinting = GetCharacterMovement()-&gt;MaxWalkSpeed == GetCharacterStats()-&gt;SprintSpeed;
}</pre>
<p>This block of <a id="_idIndexMarker419"/>code just checks whether the character is sprinting and stores the result in a local variable.</p>
<p>Then, find this line of code:</p>
<pre class="source-code">
GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;</pre>
<p>Add the following command just after it:</p>
<pre class="source-code">
if(IsSprinting)
{
 SprintStart_Server();
}</pre>
<p>As easy as it is, if the character was sprinting, we would just call the corresponding method on the server to update everything properly.</p>
<p>We’re almost done with the movement management, but there are still a few small things we need to work on. Don’t worry though, we’re working hard to get everything done by the end of <a href="B18203_10.xhtml#_idTextAnchor196"><em class="italic">Chapter 10</em></a>, <em class="italic">Enhancing the Player Experience</em>. So sit tight and stay tuned!</p>
<p>In this section, you have started implementing a simple RPC in your Character class. In particular, you <a id="_idIndexMarker420"/>have sent a command from the client that owns the character to the server, in order to properly update the movement speed.</p>
<p>In the next section, you’ll add some more fancy RPCs for your game. Specifically, you’ll develop a nifty door-opening system. Get ready to flex those programming skills!</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Implementing a door system</h1>
<p>In this section, you’ll repeat some of the previously explained topics about RPCs but with a small tweak – you’ll <a id="_idIndexMarker421"/>be developing some Actor-to-Actor communication over the network. What’s more, it will be between a C++ class – your character – and a Blueprint Class, a door that should be opened.</p>
<p>To accomplish this behavior, you will use a feature that you previously created in <a href="B18203_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>, <em class="italic">Setting Up Your First Multiplayer Environment</em> – the interact action. It may have slipped your mind with all the stuff you have developed so far, but fear not – it’s time to dust it off and put it to work once again.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Creating the Interactable interface</h2>
<p>To create communication between your character and the door, you’ll use an <strong class="bold">interface</strong>. As you <a id="_idIndexMarker422"/>may already know, interfaces in C++ are a powerful tool for creating abstractions between different classes. They allow you to define a contract that all implementing classes must adhere to, thereby allowing you to create code that is more maintainable, extensible, and reusable.</p>
<p>In Unreal Engine, interfaces differ from traditional programming interfaces in that it is not mandatory to implement all functions. Instead, it is optional to implement them. What’s more, you can declare an interface in C++ and implement it in a Blueprint – and that’s exactly what you’ll be doing here.</p>
<p>Let’s start by opening your development IDE and creating a file named <code>US_Interactable.h</code>. Then, <a id="_idIndexMarker423"/>add the following code to the file:</p>
<pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "US_Interactable.generated.h"
UINTERFACE(MinimalAPI, Blueprintable)
class UUS_Interactable : public UInterface
{
 GENERATED_BODY()
};
class UNREALSHADOWS_LOTL_API IUS_Interactable
{
 GENERATED_BODY()
public:
 UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Interaction", meta=(DisplayName="Interact"))
 void Interact(class AUS_Character* CharacterInstigator);
 UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Interaction", meta=(DisplayName="Can Interact"))
 bool CanInteract( AUS_Character * CharacterInstigator) const;
};</pre>
<p>You may notice something weird in the code you just added – there are two classes. In order to properly declare an Unreal Engine interface, you need to declare two classes:</p>
<ul>
<li>A class with a <code>U</code> prefix and extending <code>UInterface</code>: This is not the actual interface but an empty class whose sole aim is to make the class visible in the Unreal Engine system</li>
<li>A class with an <code>I</code> prefix: This is the actual interface and will contain all the interface method definitions</li>
</ul>
<p>As you can see, the U-prefixed class is decorated with the <code>UINTERFACE()</code> macro and the <code>Blueprintable</code> attribute will let you implement this interface from a Blueprint. Isn’t it cool?</p>
<p>Finally, we declare <a id="_idIndexMarker424"/>a couple of functions called <code>Interact()</code> and <code>CanInteract()</code>, respectively. The two of them can be called and implemented in a Blueprint (thanks to the <code>BlueprintCallable</code> and <code>BlueprintNativeEvent</code> attributes).</p>
<p>Even though we will not be implementing the second function (i.e., <code>CanInteract()</code>) in our door Blueprint, it is nice to have such a feature – for instance, to check whether the character can open a door with a key that can be found somewhere in the dungeon. As I told you before, interfaces in Unreal Engine do not force implementation for all method declarations.</p>
<p>So, you have created an interface to allow the character to... well, interact with something. It’s time to let the thief character perform this heroic action – something you are going to implement in the next subsection.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Implementing the interact action</h2>
<p>You are now <a id="_idIndexMarker425"/>ready to get back to the <code>US_Character.h</code> header class and add some code logic for the interact action. As we have already done for the character movement, we will need to execute this interaction from the server.</p>
<p>To do so, open the header file and look for this declaration in the <code>protected</code> section:</p>
<pre class="source-code">
void Interact(const FInputActionValue&amp; Value);</pre>
<p>Add the corresponding server call just after it:</p>
<pre class="source-code">
UFUNCTION(Server, Reliable)
void Interact_Server();</pre>
<p>As for the sprint action, this call must be <code>Reliable</code> as we need to make sure that it will be executed properly, and no information will be lost.</p>
<p>As a last step, add the following line of code to the <code>private</code> section:</p>
<pre class="source-code">
UPROPERTY()
AActor* InteractableActor;</pre>
<p>You will be using this property as a reference to the object that should be interacted with.</p>
<p>Now that the header has been properly updated, open <code>US_Character.cpp</code> and add the following includes at the start of the file:</p>
<pre class="source-code">
#include "US_Interactable.h"
#include "Kismet/KismetSystemLibrary.h"</pre>
<p>Then, look for the <code>Interact()</code> method that, up to now, has just been an empty shell. Inside the method, add the following:</p>
<pre class="source-code">
Interact_Server();</pre>
<p>This code performs <a id="_idIndexMarker426"/>a simple RPC to the corresponding server interaction implementation. As you obviously need to implement the server call, add it to your code, just after the <code>Interact()</code> function:</p>
<pre class="source-code">
void AUS_Character::Interact_Server_Implementation()
{
 if(InteractableActor)
 {
  IUS_Interactable::Execute_Interact(InteractableActor, this);
 }
}</pre>
<p>The call is executed only if a reference to the <code>InteractableActor</code> is found.</p>
<p>If you come from an OOP background and are not familiar with the way interfaces work in Unreal, this call may seem pretty weird – we are performing the call to an Actor reference without any type checking! This is the way interfaces work in Unreal Engine; they are just messages that are sent to an object reference. If the object does not implement that interface, the call will simply be lost.</p>
<p>Obviously, we want the call to be executed to something that can be interacted with (i.e., that implements the <code>US_Interactable</code> interface). To achieve this, we are going to continuously check whether the character is pointing at anything that implements the interface and, if <a id="_idIndexMarker427"/>something is found, we will reference it in the <code>InteractableActor</code> property.</p>
<p>Look for the <code>Tick()</code> method in your <code>.cpp</code> class and start adding the following piece of code:</p>
<pre class="source-code">
if(GetLocalRole() != ROLE_Authority) return;
FHitResult HitResult;
FCollisionQueryParams QueryParams;
QueryParams.bTraceComplex = true;
QueryParams.AddIgnoredActor(this);
auto SphereRadius = 50.f;
auto StartLocation = GetActorLocation() + GetActorForwardVector() * 150.f;
auto EndLocation = StartLocation + GetActorForwardVector() * 500.f;
auto IsHit = UKismetSystemLibrary::SphereTraceSingle(
 GetWorld(),
 StartLocation,
 EndLocation,
 SphereRadius,
 UEngineTypes::ConvertToTraceType(ECC_WorldStatic),
 false,
 TArray&lt;AActor*&gt;(),
 EDrawDebugTrace::ForOneFrame,
 HitResult,
 true
);</pre>
<p>The first thing we do here is to check whether the instance that is executing the trace has the authority to do so – this means only the server will perform the traces for all the characters, and it’s obviously done to avoid cheating from the client side.</p>
<p>Then, we perform a regular sphere trace to check whether the character is pointing at something. If you are not familiar with an <a id="_idIndexMarker428"/>Unreal Engine <strong class="bold">trace</strong>, it is a tool used to detect collisions and <a id="_idIndexMarker429"/>overlapping between objects. It is used for things such as line of sight, weapon fire, and even AI pathfinding. Traces can be configured using parameters such as collision channels, object type filtering, shapes, start/end points, and so on, which allows you to specify exactly what kind of collision should be detected and how it should interact with the environment.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about the inner workings of traces in Unreal Engine, you can check the official documentation, which can be found here: <a href="https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/">https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/</a>.</p>
<p>After the trace, the result is stored in the <code>HitResult</code> variable, which we are going to use to check whether we have found an interactable Actor. To do so, add the next code just after the code you have just written:</p>
<pre class="source-code">
if (IsHit &amp;&amp; HitResult.GetActor()-&gt;GetClass()-&gt;ImplementsInterface(UUS_Interactable::StaticClass()))
{
 DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, SphereRadius, 12, FColor::Magenta, false, 1.f);
 InteractableActor = HitResult.GetActor();
}
else
{
 InteractableActor = nullptr;
}</pre>
<p>The previous check is the core of our interaction control – if the object that has been traced implements the <code>US_Interactable</code> interface, we store the reference and draw a magenta-colored debug sphere for testing purposes. If nothing is found, we just clean up the <code>InteractableActor</code> property from any previous reference.</p>
<p>To check that everything works as expected, you can open Unreal Engine Editor and, after compiling, you can play the game. The server should now draw a red sphere trace for each character <a id="_idIndexMarker430"/>and turn green when hitting something. We still don’t have anything to interact with, so you will not see the debug sphere.</p>
<p>In the next subsection, you will implement a door Blueprint that will react to the character interaction.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Creating the door Blueprint</h2>
<p>It’s now time to <a id="_idIndexMarker431"/>create something that can be interacted with, and we will do this by adding some doors to the dungeon. So, let’s open the <code>Blueprints</code> folder and complete the following steps:</p>
<ol>
<li>Create a new Blueprint Class derived from <strong class="bold">Actor</strong>, name it <strong class="bold">BP_WoodenDoor</strong>, and open it.</li>
<li>In the <strong class="bold">Details</strong> panel, check the <strong class="bold">Replicates</strong> attribute to enable replication for this Actor.</li>
<li>Add a <strong class="bold">StaticMesh</strong> component and assign the door mesh to the <strong class="bold">Static </strong><strong class="bold">Mesh</strong> property.</li>
<li>In the <strong class="bold">Components</strong> panel, select the <strong class="bold">StaticMesh</strong> component and, in the <strong class="bold">Details</strong> panel, check <strong class="bold">Component Replicates</strong> to enable replication.</li>
</ol>
<p>The final result <a id="_idIndexMarker432"/>should be similar to the one depicted in <em class="italic">Figure 7</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 7.1 – The wooden door Blueprint" src="img/Figure_07_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The wooden door Blueprint</p>
<p>Now, open the Event Graph and do the following:</p>
<ol>
<li value="5">Create a variable of type <code>DoorOpen</code>. In its <strong class="bold">Details</strong> panel, set the <strong class="bold">Replication</strong> property to <strong class="bold">Replicated</strong>.</li>
<li>Select the <strong class="bold">Class Settings</strong> tab and, in the <strong class="bold">Interfaces</strong> category, add the <strong class="bold">US_Interactable</strong> interface. This will add the <strong class="bold">Interfaces</strong> section into the <strong class="bold">My </strong><strong class="bold">Blueprint</strong> window.</li>
<li>In the <strong class="bold">Interfaces</strong> section of the <strong class="bold">My Blueprint</strong> tab, open the <strong class="bold">Interaction</strong> category, right-click on the <strong class="bold">Interact</strong> method, and select <strong class="bold">Implement Event</strong>. This will add an <strong class="bold">Event Interact </strong>node on the Event Graph.</li>
<li>From the outgoing pin of the event, add a <strong class="bold">Branch</strong> node and, in the <strong class="bold">Condition</strong> pin, add a getter node of the <strong class="bold">DoorOpen</strong> variable from the <strong class="bold">Variables</strong> section.</li>
<li>Connect the <strong class="bold">False</strong> pin of the <strong class="bold">Branch</strong> node to a <strong class="bold">Setter</strong> node for the <strong class="bold">Door Open</strong> variable and check this last node’s incoming value pin to set it to <strong class="bold">True</strong>.</li>
</ol>
<p>The Event Graph <a id="_idIndexMarker433"/>created so far is shown in <em class="italic">Figure 7</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 7.2 – Door check" src="img/Figure_07_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Door check</p>
<p>The graph at the moment is quite simple; it’s just checking whether the door has already been opened and, if it is closed, marks it as open. You are going to complete the Blueprint by making the door mesh rotate in an opening animation.</p>
<ol>
<li value="10">Connect the outgoing pin of the <strong class="bold">Set Door Open</strong> node to a <strong class="bold">Timeline</strong> node. Call this node <strong class="bold">DoorOpening</strong> and double-click on it to open its corresponding graph.</li>
<li>Add a <strong class="bold">Float Track</strong> and call it <strong class="bold">RotationZ</strong>. Add two keys to the track with the values <strong class="bold">(0, 0)</strong> and <strong class="bold">(1, -</strong><strong class="bold">90)</strong> respectively.</li>
</ol>
<p>The timeline <a id="_idIndexMarker434"/>window is shown in <em class="italic">Figure 7</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 7.3 – The door timeline window" src="img/Figure_07_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The door timeline window</p>
<ol>
<li value="12">Return to the main Event Graph and drag a reference of the <strong class="bold">StaticMesh</strong> component from the <strong class="bold">Components</strong> panel into the graph itself.</li>
<li>Connect the outgoing pin of this reference to a <strong class="bold">Set Relative </strong><strong class="bold">Rotation</strong> node.</li>
<li>Right-click on the <strong class="bold">New Rotation</strong> pin and select <strong class="bold">Split Struct Pin</strong> to expose the <strong class="bold">New Rotation </strong><strong class="bold">Z</strong> value.</li>
<li>Connect the <strong class="bold">Update</strong> execution pin of the <strong class="bold">Timeline</strong> node to the incoming execution pin of the <strong class="bold">Set Relative Rotation</strong> node. Connect the <strong class="bold">Rotation Z</strong> pin with the <strong class="bold">New Rotation Z</strong> to complete the graph.</li>
</ol>
<p>This final part of the graph is depicted in <em class="italic">Figure 7</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 7.4 – The second part of the graph" src="img/Figure_07_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The second part of the graph</p>
<p>This part of the graph <a id="_idIndexMarker435"/>will just start a rotation animation on the <em class="italic">z</em> axis of the mesh, making it open when interacted with.</p>
<p>Let’s now give the thief hero a moment to shine and roam the dungeon, eagerly opening doors to seek out prisoners to liberate and treasures to unearth!</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Testing the interact action</h2>
<p>Open your game level and drag an instance or two of the door Blueprint to start testing the game. Whenever the <a id="_idIndexMarker436"/>server-controlled sphere trace hits a door, you should be able to see a magenta-colored sphere, indicating that the object can be interacted with. Hitting the <em class="italic">I</em> key on the client will open the door and show the hidden treasures (or perils!) behind.</p>
<p>The final result of the interaction check, along with the debug sphere, is displayed in <em class="italic">Figure 7</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 7.5 – The interaction check in action" src="img/Figure_07_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The interaction check in action</p>
<p>So, the door system has finally been created and you are now free to put as many doors as you want inside the dungeon. As an additional exercise, you can create a Blueprint child class from <strong class="bold">BP_WoodenDoor</strong> and use the <strong class="bold">door_gate</strong> mesh to add some kind of variation to your level.</p>
<p>In this final section, you have <a id="_idIndexMarker437"/>implemented a Blueprint that allows the character to interact with other Actors in the game. Specifically, you have created a door system that can be opened through player interaction and will be synchronized over the network. This means that every connected player will see the correct updates.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Summary</h1>
<p>In this chapter, you were introduced to one of the most important and useful features of the Unreal Engine multiplayer environment, remote procedure calls, or RPCs. As you have seen, they allow you to execute functions from a server to a client and vice versa.</p>
<p>In this chapter, you called requests from the client to the server, by improving the character sprint system and by adding interaction logic between the character and other Actors in the game (i.e., the dungeon doors). Rest assured that, by the end of the book, you will also have seen other use cases for RPCs as they are quite ubiquitous in multiplayer games.</p>
<p>This chapter ends the second part of this book – starting from the next chapter, you’ll be working on implementing some AI logic over the network. Let’s spice things up by rounding up those pesky Lichlord minions and giving our character a challenge to step up to!</p>
</div>


<div><h1 id="_idParaDest-160" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor161"/>Part 3:Improving Your Game</h1>
<p>In this part of the book, you will discover how to enhance your game’s appeal to players. This process begins with the creation of captivating opponents. Afterward, you will augment the capabilities of the player characters and add some non-player characters to interact with. Additionally, you will learn how to troubleshoot and debug networked systems within Unreal Engine.</p>
<p>This part includes the following chapters:</p>
<ul>
<li><a href="B18203_08.xhtml#_idTextAnchor162"><em class="italic">Chapter 8</em></a>, <em class="italic">Introducing AI into a Multiplayer Environment</em></li>
<li><a href="B18203_09.xhtml#_idTextAnchor174"><em class="italic">Chapter 9</em></a>, <em class="italic">Extending AI Behaviors</em></li>
<li><a href="B18203_10.xhtml#_idTextAnchor196"><em class="italic">Chapter 10</em></a>, <em class="italic">Enhancing the Player Experience</em></li>
<li><a href="B18203_11.xhtml#_idTextAnchor215"><em class="italic">Chapter 11</em></a>, <em class="italic">Debugging a Multiplayer Game</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>