<html><head></head><body>
<div id="_idContainer110">
<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.2.1">Using Remote Procedure Calls (RPCs)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that you have a strong grip on the world of property replication, it’s time to introduce you to the way in which functions can be called across the network. </span><span class="koboSpan" id="kobo.3.2">In Unreal, this is achieved through </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Remote Procedure Calls</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">RPCs</span></strong><span class="koboSpan" id="kobo.7.1">) – one of the most powerful features </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.8.1">of the engine </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">networking system.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, you will learn how to execute functions through RPCs and understand how to run them on the server, on a client, or on all clients that have an instance of a </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">particular object.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Additionally, you will learn about the common requirements for properly calling these types of functions – in particular, I will explain the difference between a reliable and an </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">unreliable function.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Finally, you will obviously apply this newfound, precious knowledge to the project you have developed </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">So, in the next sections, I will present the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Understanding what an </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">RPC is</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Executing RPCs over </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">the network</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Implementing a </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">door system</span></span></li>
</ul>
<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">To follow the topics presented in this chapter, you should have completed the previous ones and understood </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">their content.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">.zip</span></strong><span class="koboSpan" id="kobo.29.1"> project files provided in this book’s companion </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">project repository:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</span></span></a></p>
<p><span class="koboSpan" id="kobo.32.1">You can download the files that are up to date with the end of the last chapter by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">Unreal Shadows – </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">Chapter 06</span></strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">End</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1"> link.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.37.1">Understanding what an RPC is</span></h1>
<p><span class="koboSpan" id="kobo.38.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">RPC</span></strong><span class="koboSpan" id="kobo.40.1"> is a function that can be called locally but is executed on a different machine – for instance, a server </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.41.1">computer may call a function on a client computer that will command it to spawn a visual effect or a sound somewhere in the level. </span><span class="koboSpan" id="kobo.41.2">Another useful application of an RPC is the ability to send messages bi-directionally between a server and a client over a </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">network connection.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">There are three types of RPCs available in </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Unreal Engine:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Server</span></strong><span class="koboSpan" id="kobo.46.1">: The function will be called by an object on the client PC but executed only on the server version </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.47.1">of that same object. </span><span class="koboSpan" id="kobo.47.2">The client must own the object calling the method (if you need to, please check </span><a href="B18203_05.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.49.1">, </span><em class="italic"><span class="koboSpan" id="kobo.50.1">Managing Actors in a Multiplayer Environment</span></em><span class="koboSpan" id="kobo.51.1">, for a refresher about owning </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">an Actor).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Client</span></strong><span class="koboSpan" id="kobo.54.1">: The function will be </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.55.1">called on the server by an object but executed only on the client version that owns the object </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">calling it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">NetMulticast</span></strong><span class="koboSpan" id="kobo.58.1">: The function can </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.59.1">be called on the server by an object and executed on the server and all client versions of the object calling it. </span><span class="koboSpan" id="kobo.59.2">It can also be called by a client but, in this case, it will only be executed locally (i.e., on the client </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">calling it).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.61.1">In order for a function to be properly executed as an RPC, it must be called by an Actor and the Actor must be replicated. </span><span class="koboSpan" id="kobo.61.2">Additionally, the function needs to be decorated with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">UFUNCTION()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1"> macro.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">A function that will run just on the owning client will be declared in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">.h</span></strong><span class="koboSpan" id="kobo.66.1"> file as in the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
UFUNCTION(Client)
void DoSomething_Client();</span></pre>
<p><span class="koboSpan" id="kobo.69.1">In the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">.cpp</span></strong><span class="koboSpan" id="kobo.71.1"> file of the previous header, you will need to implement this function </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.72.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">_Implementation</span></strong><span class="koboSpan" id="kobo.74.1"> suffix. </span><span class="koboSpan" id="kobo.74.2">The autogenerated code for this class – located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">.generated.h</span></strong><span class="koboSpan" id="kobo.76.1"> file – will automatically include a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">_Implementation</span></strong><span class="koboSpan" id="kobo.78.1"> method when necessary. </span><span class="koboSpan" id="kobo.78.2">For a refresher on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">.generated.h</span></strong><span class="koboSpan" id="kobo.80.1"> file, please check </span><a href="B18203_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.82.1">, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Setting Up Your First </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.84.1">Multiplayer Environment</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Looking at an example, let’s say your </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">.h</span></strong><span class="koboSpan" id="kobo.88.1"> header file has a method declaration similar to the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
UFUNCTION(Server)
void DoSomething_Server();</span></pre>
<p><span class="koboSpan" id="kobo.91.1">You will need to implement the following function in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.95.1">
void DoSomething_Server_Implementation()
{ /* Your code here */ }</span></pre>
<p><span class="koboSpan" id="kobo.96.1">A method is not always guaranteed to be received by the recipient due to performance reasons; however, this behavior can be adjusted, as demonstrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">following subsection.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.98.1">Reliability of an RPC</span></h2>
<p><span class="koboSpan" id="kobo.99.1">RPCs are unreliable by </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.100.1">default – this means there is no guarantee that the function call will reach its destination. </span><span class="koboSpan" id="kobo.100.2">This is usually acceptable if the executed code is not so important, such as a visual effect spawned on a client or a random noise played near the character; if the message is not received, the effect will simply not spawn or the sound won’t be heard, but gameplay will not </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">be affected.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">There are, however, some cases where you want to enforce reliability and guarantee that a message will securely arrive at its destination – as an example, in this chapter, you will execute the sprint action from the server side (you don’t really want to lose that very important interaction with the player). </span><span class="koboSpan" id="kobo.102.2">To make sure that an RPC call is executed on the remote machine, you can utilize the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Reliable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.104.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">To illustrate this point, a function that should be executed reliably on a client will be declared with the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
UFUNCTION(Client, Reliable)
void DoSomethingReliably_Client();</span></pre>
<p><span class="koboSpan" id="kobo.108.1">This will guarantee </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.109.1">that the method call will be received by the client and properly executed, without any risk of data loss over the network because </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">of unreliability.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.111.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.112.1">Avoid using reliable RPCs during the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Tick()</span></strong><span class="koboSpan" id="kobo.114.1"> event and exercise caution when binding them to player input. </span><span class="koboSpan" id="kobo.114.2">This is because players can repeatedly press buttons very quickly, leading to an overflow of the queue for </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">reliable RPCs.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">In addition to reliability, you may want a method to be validated in order to be executed – this is something I’m going to show you </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">right now!</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.118.1">Validating RPCs</span></h2>
<p><span class="koboSpan" id="kobo.119.1">Unreal Engine offers </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.120.1">an additional feature that adds the ability to check that functions will execute without bad data or input – this is what </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">validation</span></strong><span class="koboSpan" id="kobo.122.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">all about.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">To declare that a method should be validated for an RPC call, you need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">WithValidation</span></strong><span class="koboSpan" id="kobo.126.1"> specifier to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">UFUNCTION()</span></strong><span class="koboSpan" id="kobo.128.1"> declaration statement and implement an additional function that will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">bool</span></strong><span class="koboSpan" id="kobo.130.1"> type and be named as the validated function, but with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">_Validate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1"> suffix.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">As an example, a method marked with validation will have a declaration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">.h</span></strong><span class="koboSpan" id="kobo.135.1"> file, similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
UFUNCTION(Server, WithValidation)
void DoSomethingWithValidation();</span></pre>
<p><span class="koboSpan" id="kobo.138.1">Then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">.cpp</span></strong><span class="koboSpan" id="kobo.140.1"> file, you will need to implement two methods. </span><span class="koboSpan" id="kobo.140.2">The first one will be the regular function, and will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
void DoSomethingWithValidation_Implementation()
{ /* Your code here */ }</span></pre>
<p><span class="koboSpan" id="kobo.143.1">The second one will be the actual validation function, and will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
bool DoSomethingWithValidation_Validate()
{ /* Your code here */ }</span></pre>
<p><span class="koboSpan" id="kobo.146.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">_Validate</span></strong><span class="koboSpan" id="kobo.148.1"> function will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">true</span></strong><span class="koboSpan" id="kobo.150.1"> if the code is validated, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">false</span></strong><span class="koboSpan" id="kobo.152.1"> otherwise. </span><span class="koboSpan" id="kobo.152.2">If validation succeeds, the corresponding method will be executed; otherwise, </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">it won’t.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">In this section, I have introduced RPCs and how Unreal Engine copes with them. </span><span class="koboSpan" id="kobo.154.2">Bear with me – if you’re </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.155.1">working in the networked games industry, mastering RPCs is key to keeping your job and growing </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">your career!</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Now that you have a solid understanding of how an RPC should be implemented, it’s time to write some code – and we are going to start by hunting down that pesky little bug that is stopping our thief hero from sprinting freely (and correctly!) around </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">the dungeon.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.159.1">Executing RPCs over the network</span></h1>
<p><span class="koboSpan" id="kobo.160.1">In this section, you’ll do some practice with RPCs by fixing the issue we are experiencing with making the </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.161.1">character sprint correctly. </span><span class="koboSpan" id="kobo.161.2">As you may remember, when the character is sprinting on the client, you will get “jumpy” behavior – the character seems to start running but it is immediately brought back to a </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">walking speed.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">This happens because the sprint action is being executed on the player client, but it is not being executed on the server, which is the one that is in command; hence, the override from the server slows the character to its move speed on every update. </span><span class="koboSpan" id="kobo.163.2">This means that you are trying to move your character at a sprint speed but, as soon as the server replicates the movement on the client, it will bring the character back to </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">moving speed.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">We don’t even </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.166.1">want the client to control this kind of important interaction – remember that it is the server who is in command – so, get back to the project and start typing some code to fix </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">this problem!</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.168.1">Calling a function on the server</span></h2>
<p><span class="koboSpan" id="kobo.169.1">To make our </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.170.1">character run, we simply have to execute the movement speed change on the server, instead of on the client. </span><span class="koboSpan" id="kobo.170.2">This will guarantee total control over the behavior and correct replication on </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">all clients.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Let’s start by opening the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.174.1"> file and do some code declarations. </span><span class="koboSpan" id="kobo.174.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">protected</span></strong><span class="koboSpan" id="kobo.176.1"> section, add these </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">two methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
UFUNCTION(Server, Reliable)
void SprintStart_Server();
UFUNCTION(Server, Reliable)
void SprintEnd_Server();</span></pre>
<p><span class="koboSpan" id="kobo.179.1">These functions have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Server</span></strong><span class="koboSpan" id="kobo.181.1"> attribute, which, as explained in the previous section, will execute them on the server. </span><span class="koboSpan" id="kobo.181.2">We have also added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Reliable</span></strong><span class="koboSpan" id="kobo.183.1"> attribute because we don’t want to lose this RPC due to the default unreliability of the system. </span><span class="koboSpan" id="kobo.183.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">_Server</span></strong><span class="koboSpan" id="kobo.185.1"> suffix is not mandatory and is written just for clarity (some people use a prefix, so it is up to your </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">personal taste!).</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Now open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">US_Character.cpp</span></strong><span class="koboSpan" id="kobo.189.1"> file and implement the two functions by adding the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
void AUS_Character::SprintStart_Server_Implementation()
{
 if (GetCharacterStats())
 {
  GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;SprintSpeed;
 }
}
void AUS_Character::SprintEnd_Server_Implementation()
{
 if (GetCharacterStats())
 {
  GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.192.1">The code is pretty straightforward as we are just executing the speed change inside these two new functions and, in just a moment, we are going to remove them from their previous positions (i.e., from the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">client calls).</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Here, just notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">_Implementation</span></strong><span class="koboSpan" id="kobo.196.1"> suffix – this is mandatory as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">SprintStart_Server()</span></strong><span class="koboSpan" id="kobo.198.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">SprintEnd_Server()</span></strong><span class="koboSpan" id="kobo.200.1"> functions will be auto-generated by Unreal in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">.generated.h</span></strong><span class="koboSpan" id="kobo.202.1"> class file and will be responsible for calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">actual implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">We now need to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">SprintStart()</span></strong><span class="koboSpan" id="kobo.206.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">SprintEnd()</span></strong><span class="koboSpan" id="kobo.208.1"> functions, in order to call the </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.209.1">corresponding server fuctions (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">SprintStart_Server()</span></strong><span class="koboSpan" id="kobo.211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">SprintEnd_Server()</span></strong><span class="koboSpan" id="kobo.213.1">). </span><span class="koboSpan" id="kobo.213.2">Find those two functions and remove all their content (i.e., the changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">MaxWalkSpeed</span></strong><span class="koboSpan" id="kobo.215.1">) and then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">SprintStart()</span></strong><span class="koboSpan" id="kobo.217.1"> function, add this simple line </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
SprintStart_Server();</span></pre>
<p><span class="koboSpan" id="kobo.220.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">SprintEnd()</span></strong><span class="koboSpan" id="kobo.222.1"> function, add this line </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
SprintEnd_Server();</span></pre>
<p><span class="koboSpan" id="kobo.225.1">To make the sprint action fully operational, we need to take one final step. </span><span class="koboSpan" id="kobo.225.2">At the moment, if the character is running and levels up, the movement will revert to walking speed. </span><span class="koboSpan" id="kobo.225.3">This happens because, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">UpdateCharacterStats()</span></strong><span class="koboSpan" id="kobo.227.1"> function, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">MaxWalkSpeed</span></strong><span class="koboSpan" id="kobo.229.1"> property to the new walk speed, even if the character </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">is sprinting.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Let’s fix this by finding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">UpdateCharacterStats()</span></strong><span class="koboSpan" id="kobo.233.1"> method and adding, at its very beginning, the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
auto IsSprinting = false;
if(GetCharacterStats())
{
 IsSprinting = GetCharacterMovement()-&gt;MaxWalkSpeed == GetCharacterStats()-&gt;SprintSpeed;
}</span></pre>
<p><span class="koboSpan" id="kobo.236.1">This block of </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.237.1">code just checks whether the character is sprinting and stores the result in a </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">local variable.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Then, find this line </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;</span></pre>
<p><span class="koboSpan" id="kobo.242.1">Add the following command just </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">after it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
if(IsSprinting)
{
 SprintStart_Server();
}</span></pre>
<p><span class="koboSpan" id="kobo.245.1">As easy as it is, if the character was sprinting, we would just call the corresponding method on the server to update </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">everything properly.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">We’re almost done with the movement management, but there are still a few small things we need to work on. </span><span class="koboSpan" id="kobo.247.2">Don’t worry though, we’re working hard to get everything done by the end of </span><a href="B18203_10.xhtml#_idTextAnchor196"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.249.1">, </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Enhancing the Player Experience</span></em><span class="koboSpan" id="kobo.251.1">. </span><span class="koboSpan" id="kobo.251.2">So sit tight and </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">stay tuned!</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">In this section, you have started implementing a simple RPC in your Character class. </span><span class="koboSpan" id="kobo.253.2">In particular, you </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.254.1">have sent a command from the client that owns the character to the server, in order to properly update the </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">movement speed.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">In the next section, you’ll add some more fancy RPCs for your game. </span><span class="koboSpan" id="kobo.256.2">Specifically, you’ll develop a nifty door-opening system. </span><span class="koboSpan" id="kobo.256.3">Get ready to flex those </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">programming skills!</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.258.1">Implementing a door system</span></h1>
<p><span class="koboSpan" id="kobo.259.1">In this section, you’ll repeat some of the previously explained topics about RPCs but with a small tweak – you’ll </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.260.1">be developing some Actor-to-Actor communication over the network. </span><span class="koboSpan" id="kobo.260.2">What’s more, it will be between a C++ class – your character – and a Blueprint Class, a door that should </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">be opened.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">To accomplish this behavior, you will use a feature that you previously created in </span><a href="B18203_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.263.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.264.1">, </span><em class="italic"><span class="koboSpan" id="kobo.265.1">Setting Up Your First Multiplayer Environment</span></em><span class="koboSpan" id="kobo.266.1"> – the interact action. </span><span class="koboSpan" id="kobo.266.2">It may have slipped your mind with all the stuff you have developed so far, but fear not – it’s time to dust it off and put it to work </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">once again.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.268.1">Creating the Interactable interface</span></h2>
<p><span class="koboSpan" id="kobo.269.1">To create communication between your character and the door, you’ll use an </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">interface</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">As you </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.272.1">may already know, interfaces in C++ are a powerful tool for creating abstractions between different classes. </span><span class="koboSpan" id="kobo.272.2">They allow you to define a contract that all implementing classes must adhere to, thereby allowing you to create code that is more maintainable, extensible, </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">and reusable.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">In Unreal Engine, interfaces differ from traditional programming interfaces in that it is not mandatory to implement all functions. </span><span class="koboSpan" id="kobo.274.2">Instead, it is optional to implement them. </span><span class="koboSpan" id="kobo.274.3">What’s more, you can declare an interface in C++ and implement it in a Blueprint – and that’s exactly what you’ll be </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">doing here.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Let’s start by opening your development IDE and creating a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">US_Interactable.h</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">Then, </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.279.1">add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
#pragma once
#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "US_Interactable.generated.h"
UINTERFACE(MinimalAPI, Blueprintable)
class UUS_Interactable : public UInterface
{
 GENERATED_BODY()
};
class UNREALSHADOWS_LOTL_API IUS_Interactable
{
 GENERATED_BODY()
public:
 UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Interaction", meta=(DisplayName="Interact"))
 void Interact(class AUS_Character* CharacterInstigator);
 UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Interaction", meta=(DisplayName="Can Interact"))
 bool CanInteract( AUS_Character * CharacterInstigator) const;
};</span></pre>
<p><span class="koboSpan" id="kobo.282.1">You may notice something weird in the code you just added – there are two classes. </span><span class="koboSpan" id="kobo.282.2">In order to properly declare an Unreal Engine interface, you need to declare </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">two classes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.284.1">A class with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">U</span></strong><span class="koboSpan" id="kobo.286.1"> prefix and extending </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">UInterface</span></strong><span class="koboSpan" id="kobo.288.1">: This is not the actual interface but an empty class whose sole aim is to make the class visible in the Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">Engine system</span></span></li>
<li><span class="koboSpan" id="kobo.290.1">A class with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">I</span></strong><span class="koboSpan" id="kobo.292.1"> prefix: This is the actual interface and will contain all the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">method definitions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.294.1">As you can see, the U-prefixed class is decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">UINTERFACE()</span></strong><span class="koboSpan" id="kobo.296.1"> macro and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Blueprintable</span></strong><span class="koboSpan" id="kobo.298.1"> attribute will let you implement this interface from a Blueprint. </span><span class="koboSpan" id="kobo.298.2">Isn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">it cool?</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Finally, we declare </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.301.1">a couple of functions called </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Interact()</span></strong><span class="koboSpan" id="kobo.303.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">CanInteract()</span></strong><span class="koboSpan" id="kobo.305.1">, respectively. </span><span class="koboSpan" id="kobo.305.2">The two of them can be called and implemented in a Blueprint (thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">BlueprintCallable</span></strong><span class="koboSpan" id="kobo.307.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">BlueprintNativeEvent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> attributes).</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Even though we will not be implementing the second function (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">CanInteract()</span></strong><span class="koboSpan" id="kobo.312.1">) in our door Blueprint, it is nice to have such a feature – for instance, to check whether the character can open a door with a key that can be found somewhere in the dungeon. </span><span class="koboSpan" id="kobo.312.2">As I told you before, interfaces in Unreal Engine do not force implementation for all </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">method declarations.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">So, you have created an interface to allow the character to... </span><span class="koboSpan" id="kobo.314.2">well, interact with something. </span><span class="koboSpan" id="kobo.314.3">It’s time to let the thief character perform this heroic action – something you are going to implement in the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">next subsection.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.316.1">Implementing the interact action</span></h2>
<p><span class="koboSpan" id="kobo.317.1">You are now </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.318.1">ready to get back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.320.1"> header class and add some code logic for the interact action. </span><span class="koboSpan" id="kobo.320.2">As we have already done for the character movement, we will need to execute this interaction from </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">To do so, open the header file and look for this declaration in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">protected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
void Interact(const FInputActionValue&amp; Value);</span></pre>
<p><span class="koboSpan" id="kobo.326.1">Add the corresponding server call just </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">after it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
UFUNCTION(Server, Reliable)
void Interact_Server();</span></pre>
<p><span class="koboSpan" id="kobo.329.1">As for the sprint action, this call must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Reliable</span></strong><span class="koboSpan" id="kobo.331.1"> as we need to make sure that it will be executed properly, and no information will </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">be lost.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">As a last step, add the following line of code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
UPROPERTY()
AActor* InteractableActor;</span></pre>
<p><span class="koboSpan" id="kobo.337.1">You will be using this property as a reference to the object that should be </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">interacted with.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Now that the header has been properly updated, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">US_Character.cpp</span></strong><span class="koboSpan" id="kobo.341.1"> and add the following includes at the start of </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
#include "US_Interactable.h"
#include "Kismet/KismetSystemLibrary.h"</span></pre>
<p><span class="koboSpan" id="kobo.344.1">Then, look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Interact()</span></strong><span class="koboSpan" id="kobo.346.1"> method that, up to now, has just been an empty shell. </span><span class="koboSpan" id="kobo.346.2">Inside the method, add </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
Interact_Server();</span></pre>
<p><span class="koboSpan" id="kobo.349.1">This code performs </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.350.1">a simple RPC to the corresponding server interaction implementation. </span><span class="koboSpan" id="kobo.350.2">As you obviously need to implement the server call, add it to your code, just after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Interact()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
void AUS_Character::Interact_Server_Implementation()
{
 if(InteractableActor)
 {
  IUS_Interactable::Execute_Interact(InteractableActor, this);
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.354.1">The call is executed only if a reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">InteractableActor</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.356.1">is found.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">If you come from an OOP background and are not familiar with the way interfaces work in Unreal, this call may seem pretty weird – we are performing the call to an Actor reference without any type checking! </span><span class="koboSpan" id="kobo.357.2">This is the way interfaces work in Unreal Engine; they are just messages that are sent to an object reference. </span><span class="koboSpan" id="kobo.357.3">If the object does not implement that interface, the call will simply </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">be lost.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Obviously, we want the call to be executed to something that can be interacted with (i.e., that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">US_Interactable</span></strong><span class="koboSpan" id="kobo.361.1"> interface). </span><span class="koboSpan" id="kobo.361.2">To achieve this, we are going to continuously check whether the character is pointing at anything that implements the interface and, if </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.362.1">something is found, we will reference it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">InteractableActor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Tick()</span></strong><span class="koboSpan" id="kobo.367.1"> method in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">.cpp</span></strong><span class="koboSpan" id="kobo.369.1"> class and start adding the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
if(GetLocalRole() != ROLE_Authority) return;
FHitResult HitResult;
FCollisionQueryParams QueryParams;
QueryParams.bTraceComplex = true;
QueryParams.AddIgnoredActor(this);
auto SphereRadius = 50.f;
auto StartLocation = GetActorLocation() + GetActorForwardVector() * 150.f;
auto EndLocation = StartLocation + GetActorForwardVector() * 500.f;
auto IsHit = UKismetSystemLibrary::SphereTraceSingle(
 GetWorld(),
 StartLocation,
 EndLocation,
 SphereRadius,
 UEngineTypes::ConvertToTraceType(ECC_WorldStatic),
 false,
 TArray&lt;AActor*&gt;(),
 EDrawDebugTrace::ForOneFrame,
 HitResult,
 true
);</span></pre>
<p><span class="koboSpan" id="kobo.372.1">The first thing we do here is to check whether the instance that is executing the trace has the authority to do so – this means only the server will perform the traces for all the characters, and it’s obviously done to avoid cheating from the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">client side.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">Then, we perform a regular sphere trace to check whether the character is pointing at something. </span><span class="koboSpan" id="kobo.374.2">If you are not familiar with an </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.375.1">Unreal Engine </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">trace</span></strong><span class="koboSpan" id="kobo.377.1">, it is a tool used to detect collisions and </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.378.1">overlapping between objects. </span><span class="koboSpan" id="kobo.378.2">It is used for things such as line of sight, weapon fire, and even AI pathfinding. </span><span class="koboSpan" id="kobo.378.3">Traces can be configured using parameters such as collision channels, object type filtering, shapes, start/end points, and so on, which allows you to specify exactly what kind of collision should be detected and how it should interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the environment.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.380.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.381.1">For more information about the inner workings of traces in Unreal Engine, you can check the official documentation, which can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">here: </span></span><a href="https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/"><span class="No-Break"><span class="koboSpan" id="kobo.383.1">https://docs.unrealengine.com/5.1/en-US/traces-with-raycasts-in-unreal-engine/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.384.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">After the trace, the result is stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">HitResult</span></strong><span class="koboSpan" id="kobo.387.1"> variable, which we are going to use to check whether we have found an interactable Actor. </span><span class="koboSpan" id="kobo.387.2">To do so, add the next code just after the code you have </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">just written:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
if (IsHit &amp;&amp; HitResult.GetActor()-&gt;GetClass()-&gt;ImplementsInterface(UUS_Interactable::StaticClass()))
{
 DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, SphereRadius, 12, FColor::Magenta, false, 1.f);
 InteractableActor = HitResult.GetActor();
}
else
{
 InteractableActor = nullptr;
}</span></pre>
<p><span class="koboSpan" id="kobo.390.1">The previous check is the core of our interaction control – if the object that has been traced implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">US_Interactable</span></strong><span class="koboSpan" id="kobo.392.1"> interface, we store the reference and draw a magenta-colored debug sphere for testing purposes. </span><span class="koboSpan" id="kobo.392.2">If nothing is found, we just clean up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">InteractableActor</span></strong><span class="koboSpan" id="kobo.394.1"> property from any </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">previous reference.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">To check that everything works as expected, you can open Unreal Engine Editor and, after compiling, you can play the game. </span><span class="koboSpan" id="kobo.396.2">The server should now draw a red sphere trace for each character </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.397.1">and turn green when hitting something. </span><span class="koboSpan" id="kobo.397.2">We still don’t have anything to interact with, so you will not see the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">debug sphere.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">In the next subsection, you will implement a door Blueprint that will react to the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">character interaction.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.401.1">Creating the door Blueprint</span></h2>
<p><span class="koboSpan" id="kobo.402.1">It’s now time to </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.403.1">create something that can be interacted with, and we will do this by adding some doors to the dungeon. </span><span class="koboSpan" id="kobo.403.2">So, let’s open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Blueprints</span></strong><span class="koboSpan" id="kobo.405.1"> folder and complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.407.1">Create a new Blueprint Class derived from </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">Actor</span></strong><span class="koboSpan" id="kobo.409.1">, name it </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">BP_WoodenDoor</span></strong><span class="koboSpan" id="kobo.411.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">open it.</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">Details</span></strong><span class="koboSpan" id="kobo.415.1"> panel, check the </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">Replicates</span></strong><span class="koboSpan" id="kobo.417.1"> attribute to enable replication for </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">this Actor.</span></span></li>
<li><span class="koboSpan" id="kobo.419.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">StaticMesh</span></strong><span class="koboSpan" id="kobo.421.1"> component and assign the door mesh to the </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">Static </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.423.1">Mesh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1"> property.</span></span></li>
<li><span class="koboSpan" id="kobo.425.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.426.1">Components</span></strong><span class="koboSpan" id="kobo.427.1"> panel, select the </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">StaticMesh</span></strong><span class="koboSpan" id="kobo.429.1"> component and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">Details</span></strong><span class="koboSpan" id="kobo.431.1"> panel, check </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">Component Replicates</span></strong><span class="koboSpan" id="kobo.433.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">enable replication.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.435.1">The final result </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.436.1">should be similar to the one depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.437.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.438.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.440.1"><img alt="Figure 7.1 – The wooden door Blueprint" src="image/Figure_07_01_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.441.1">Figure 7.1 – The wooden door Blueprint</span></p>
<p><span class="koboSpan" id="kobo.442.1">Now, open the Event Graph and do </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the following:</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.444.1">Create a variable of type </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">Boolean</span></strong><span class="koboSpan" id="kobo.446.1"> and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">DoorOpen</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">In its </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Details</span></strong><span class="koboSpan" id="kobo.450.1"> panel, set the </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Replication</span></strong><span class="koboSpan" id="kobo.452.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">Replicated</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.456.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">Class Settings</span></strong><span class="koboSpan" id="kobo.458.1"> tab and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.459.1">Interfaces</span></strong><span class="koboSpan" id="kobo.460.1"> category, add the </span><strong class="bold"><span class="koboSpan" id="kobo.461.1">US_Interactable</span></strong><span class="koboSpan" id="kobo.462.1"> interface. </span><span class="koboSpan" id="kobo.462.2">This will add the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Interfaces</span></strong><span class="koboSpan" id="kobo.464.1"> section into the </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">My </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.466.1">Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1"> window.</span></span></li>
<li><span class="koboSpan" id="kobo.468.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">Interfaces</span></strong><span class="koboSpan" id="kobo.470.1"> section of the </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.472.1"> tab, open the </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">Interaction</span></strong><span class="koboSpan" id="kobo.474.1"> category, right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Interact</span></strong><span class="koboSpan" id="kobo.476.1"> method, and select </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">Implement Event</span></strong><span class="koboSpan" id="kobo.478.1">. </span><span class="koboSpan" id="kobo.478.2">This will add an </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">Event Interact </span></strong><span class="koboSpan" id="kobo.480.1">node on the </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">Event Graph.</span></span></li>
<li><span class="koboSpan" id="kobo.482.1">From the outgoing pin of the event, add a </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">Branch</span></strong><span class="koboSpan" id="kobo.484.1"> node and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">Condition</span></strong><span class="koboSpan" id="kobo.486.1"> pin, add a getter node of the </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">DoorOpen</span></strong><span class="koboSpan" id="kobo.488.1"> variable from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.489.1">Variables</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.491.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.492.1">False</span></strong><span class="koboSpan" id="kobo.493.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">Branch</span></strong><span class="koboSpan" id="kobo.495.1"> node to a </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">Setter</span></strong><span class="koboSpan" id="kobo.497.1"> node for the </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">Door Open</span></strong><span class="koboSpan" id="kobo.499.1"> variable and check this last node’s incoming value pin to set it </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.501.1">True</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.503.1">The Event Graph </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.504.1">created so far is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.505.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.506.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.508.1"><img alt="Figure 7.2 – Door check" src="image/Figure_07_02_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.509.1">Figure 7.2 – Door check</span></p>
<p><span class="koboSpan" id="kobo.510.1">The graph at the moment is quite simple; it’s just checking whether the door has already been opened and, if it is closed, marks it as open. </span><span class="koboSpan" id="kobo.510.2">You are going to complete the Blueprint by making the door mesh rotate in an </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">opening animation.</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.512.1">Connect the outgoing pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">Set Door Open</span></strong><span class="koboSpan" id="kobo.514.1"> node to a </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">Timeline</span></strong><span class="koboSpan" id="kobo.516.1"> node. </span><span class="koboSpan" id="kobo.516.2">Call this node </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">DoorOpening</span></strong><span class="koboSpan" id="kobo.518.1"> and double-click on it to open its </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">corresponding graph.</span></span></li>
<li><span class="koboSpan" id="kobo.520.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.521.1">Float Track</span></strong><span class="koboSpan" id="kobo.522.1"> and call it </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">RotationZ</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">Add two keys to the track with the values </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">(0, 0)</span></strong><span class="koboSpan" id="kobo.526.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">(1, -</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.528.1">90)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1"> respectively.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.530.1">The timeline </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.531.1">window is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.532.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.533.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.535.1"><img alt="Figure 7.3 – The door timeline window" src="image/Figure_07_03_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.536.1">Figure 7.3 – The door timeline window</span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.537.1">Return to the main Event Graph and drag a reference of the </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">StaticMesh</span></strong><span class="koboSpan" id="kobo.539.1"> component from the </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">Components</span></strong><span class="koboSpan" id="kobo.541.1"> panel into the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">graph itself.</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">Connect the outgoing pin of this reference to a </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">Set Relative </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.545.1">Rotation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.547.1">Right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">New Rotation</span></strong><span class="koboSpan" id="kobo.549.1"> pin and select </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">Split Struct Pin</span></strong><span class="koboSpan" id="kobo.551.1"> to expose the </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">New Rotation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.553.1">Z</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1"> value.</span></span></li>
<li><span class="koboSpan" id="kobo.555.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.556.1">Update</span></strong><span class="koboSpan" id="kobo.557.1"> execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.558.1">Timeline</span></strong><span class="koboSpan" id="kobo.559.1"> node to the incoming execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">Set Relative Rotation</span></strong><span class="koboSpan" id="kobo.561.1"> node. </span><span class="koboSpan" id="kobo.561.2">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">Rotation Z</span></strong><span class="koboSpan" id="kobo.563.1"> pin with the </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">New Rotation Z</span></strong><span class="koboSpan" id="kobo.565.1"> to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the graph.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.567.1">This final part of the graph is depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.568.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.569.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.571.1"><img alt="Figure 7.4 – The second part of the graph" src="image/Figure_07_04_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.572.1">Figure 7.4 – The second part of the graph</span></p>
<p><span class="koboSpan" id="kobo.573.1">This part of the graph </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.574.1">will just start a rotation animation on the </span><em class="italic"><span class="koboSpan" id="kobo.575.1">z</span></em><span class="koboSpan" id="kobo.576.1"> axis of the mesh, making it open when </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">interacted with.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">Let’s now give the thief hero a moment to shine and roam the dungeon, eagerly opening doors to seek out prisoners to liberate and treasures </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">to unearth!</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.580.1">Testing the interact action</span></h2>
<p><span class="koboSpan" id="kobo.581.1">Open your game level and drag an instance or two of the door Blueprint to start testing the game. </span><span class="koboSpan" id="kobo.581.2">Whenever the </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.582.1">server-controlled sphere trace hits a door, you should be able to see a magenta-colored sphere, indicating that the object can be interacted with. </span><span class="koboSpan" id="kobo.582.2">Hitting the </span><em class="italic"><span class="koboSpan" id="kobo.583.1">I</span></em><span class="koboSpan" id="kobo.584.1"> key on the client will open the door and show the hidden treasures (or </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">perils!) behind.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">The final result of the interaction check, along with the debug sphere, is displayed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.587.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.588.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.590.1"><img alt="Figure 7.5 – The interaction check in action" src="image/Figure_07_05_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.591.1">Figure 7.5 – The interaction check in action</span></p>
<p><span class="koboSpan" id="kobo.592.1">So, the door system has finally been created and you are now free to put as many doors as you want inside the dungeon. </span><span class="koboSpan" id="kobo.592.2">As an additional exercise, you can create a Blueprint child class from </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">BP_WoodenDoor</span></strong><span class="koboSpan" id="kobo.594.1"> and use the </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">door_gate</span></strong><span class="koboSpan" id="kobo.596.1"> mesh to add some kind of variation to </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">your level.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">In this final section, you have </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.599.1">implemented a Blueprint that allows the character to interact with other Actors in the game. </span><span class="koboSpan" id="kobo.599.2">Specifically, you have created a door system that can be opened through player interaction and will be synchronized over the network. </span><span class="koboSpan" id="kobo.599.3">This means that every connected player will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">correct updates.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.601.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.602.1">In this chapter, you were introduced to one of the most important and useful features of the Unreal Engine multiplayer environment, remote procedure calls, or RPCs. </span><span class="koboSpan" id="kobo.602.2">As you have seen, they allow you to execute functions from a server to a client and </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">In this chapter, you called requests from the client to the server, by improving the character sprint system and by adding interaction logic between the character and other Actors in the game (i.e., the dungeon doors). </span><span class="koboSpan" id="kobo.604.2">Rest assured that, by the end of the book, you will also have seen other use cases for RPCs as they are quite ubiquitous in </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">multiplayer games.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">This chapter ends the second part of this book – starting from the next chapter, you’ll be working on implementing some AI logic over the network. </span><span class="koboSpan" id="kobo.606.2">Let’s spice things up by rounding up those pesky Lichlord minions and giving our character a challenge to step </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">up to!</span></span></p>
</div>


<div class="Content" id="_idContainer111">
<h1 id="_idParaDest-160" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1.1">Part 3:Improving Your Game</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part of the book, you will discover how to enhance your game’s appeal to players. </span><span class="koboSpan" id="kobo.2.2">This process begins with the creation of captivating opponents. </span><span class="koboSpan" id="kobo.2.3">Afterward, you will augment the capabilities of the player characters and add some non-player characters to interact with. </span><span class="koboSpan" id="kobo.2.4">Additionally, you will learn how to troubleshoot and debug networked systems within </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Unreal Engine.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B18203_08.xhtml#_idTextAnchor162"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Introducing AI into a Multiplayer Environment</span></em></li>
<li><a href="B18203_09.xhtml#_idTextAnchor174"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Extending AI Behaviors</span></em></li>
<li><a href="B18203_10.xhtml#_idTextAnchor196"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Enhancing the Player Experience</span></em></li>
<li><a href="B18203_11.xhtml#_idTextAnchor215"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Debugging a Multiplayer Game</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer112">
</div>
</div>
<div>
<div id="_idContainer113">
</div>
</div>
<div>
<div id="_idContainer114">
</div>
</div>
<div>
<div id="_idContainer115">
</div>
</div>
<div>
<div id="_idContainer116">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer117">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer118">
</div>
</div>
<div>
<div id="_idContainer119">
</div>
</div>
<div>
<div id="_idContainer120">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer121">
</div>
</div>
</body></html>