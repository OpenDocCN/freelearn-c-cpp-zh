<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Data Structures and Algorithms</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will learn about advanced data structures and algorithms. We will learn how to use structures such as stacks, circular linked lists, doubly linked lists, and binary trees and their traversal.</p>
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Implementing a stack using a singly linked list</li>
<li>Implementing a doubly or two-way linked list</li>
<li>Implementing a circular linked list</li>
<li>Making a binary search tree and doing inorder traversal recursively</li>
<li>Performing postorder traversal of a binary tree non-recursively</li>
</ul>
<p>Before we get into the recipes, it will be helpful for us to understand some of the structures and related terminologies we will be using in this chapter as well as in the other recipes in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stack</h1>
                
            
            
                
<p>A stack is a data structure where all insertions and deletions are performed at one end. The end at which insertions and deletions are performed is called the <strong>top of the stack</strong> (<strong>tos</strong>). The stack is also known as a <strong>pushdown list</strong> or <strong>Last In First Out</strong> (<strong>LIFO</strong>); that is, the last item that is added to the stack is added at the top of all earlier items and will be the first item to be taken out of the stack.</p>
<p>The operations that can be performed on the stack are as follows:</p>
<ul>
<li><strong>Push</strong>: This pushes the value onto the stack. Before pushing the value onto the stack, the value at the top is incremented to point at the new position where the new value can be pushed.</li>
<li><strong>Pop</strong>: This pops or fetches the value from the stack. The value at the top or the value pointed at by the top is taken out of the stack.</li>
<li><strong>Peep</strong>: This shows the value that is at the top of the stack, that is, the value that is pointed at by the stack, without taking that value out of the stack.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Doubly linked lists (two-way linked lists)</h1>
                
            
            
                
<p>In doubly or two-way linked lists, two pointers are used in the structure, where one pointer points in the forward direction and the other points in the backward direction. These two pointers allow us to traverse a linked list in both ways, that is, in <strong>First in First Out</strong> (<strong>FIFO</strong>) order as well as LIFO order. In a singly linked list, traversal is only possible in one direction. The node of a doubly linked list looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1c8fbda8-34ef-4484-9747-6dac9b13303c.png" style="width:13.00em;height:5.75em;"/></p>
<p>As we can see in the preceding diagram, there are two pointers, <kbd>next</kbd> and <kbd>prev</kbd> (you can give any name you like to these pointers). The <kbd>next</kbd> pointer is pointing at the next node, while the <kbd>prev</kbd> pointer is pointing at its previous node. To traverse the doubly linked list in both directions, we will make use of two other pointers called <kbd>startList</kbd> and <kbd>endList</kbd>. The <kbd>startList</kbd> pointer is set to point at the first node, while the <kbd>endList</kbd> pointer is set to point at the last node to allow for the traversal of the doubly linked list in both directions.</p>
<p>To traverse in FIFO order, we begin traversing from the node being pointed at by <kbd>startList</kbd>, moving further with the help of the <kbd>next</kbd> pointer. To traverse in LIFO order, we begin traversing the linked list from the node that's being pointed at by the <kbd>endList</kbd> pointer, then move backward with help of the <kbd>prev</kbd> pointer.</p>
<p>A doubly linked list that consists of certain nodes may look as follows:<br/></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/30635fc0-c588-4f92-9e20-49a4f63fa3ae.png" style="width:38.75em;height:6.92em;"/></p>
<p>Note that the <kbd>prev</kbd> pointer of the first node and the <kbd>next</kbd> pointer of the last node is set to <kbd>NULL</kbd>. These <kbd>NULL</kbd> values help to terminate the traversing procedure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Circular linked lists</h1>
                
            
            
                
<p>In a linear linked list, the nodes are connected one after the other, and each node except the first has a unique predecessor and successor. The last node is set to point at <kbd>NULL</kbd> to indicate the termination of the linked list. But in the case of a circular linked list, the next pointer of the last node points back to the first node instead of pointing at <kbd>NULL</kbd>. In other words, a circular linked list has no <kbd>NULL</kbd> pointer, as can be seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4658723f-6b9c-44b0-973c-f6c8a8e82480.png" style="width:32.75em;height:7.83em;"/></p>
<p>The advantage of a circular linked list over a linear linked list is that a circular linked list allows the pointer to move in reverse direction too. In real-world applications, the circular linked list is used in several places. For example, it can be used in an operating system while scheduling a CPU in a round-robin fashion, it can be used in a playlist of songs, and it can be used to track users in games.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Binary tree</h1>
                
            
            
                
<p>A tree in which all of the nodes can have two children or siblings (at most) is called a binary tree. A binary tree has the following characteristics:</p>
<ul>
<li>A tree contains, at most, 2<sup>l</sup> nodes at level <em>l</em>.</li>
<li>If a binary tree contains <em>m</em> nodes at level <em>l</em>, it contains at most <em>2m</em> nodes at level <em>l+1</em>.</li>
<li>A tree contains <em>2d</em> leaves and therefore <em>2d-1</em> non-leaf nodes, where <em>d</em> is its depth.</li>
<li>A binary tree with <em>n</em> internal nodes has (<em>n+1</em>) external nodes.</li>
<li>A binary tree with <em>n</em> nodes has exactly <em>n+1</em> <kbd>NULL</kbd> links (see the following screenshot):</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/04bee979-2cad-4fd6-b42c-7fa8c26840de.png" style="width:25.58em;height:15.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binary search trees</h1>
                
            
            
                
<p>A binary search tree is a tree in which the time to search an element is <kbd>O(log2n)</kbd> (which is faster than searching an element in a binary tree, where <kbd>O(n)</kbd>). But to support <kbd>O(log2n)</kbd> searching, we need to add a special property to the binary tree: we put all the nodes with values smaller than the value in the root into its left subtree and all of the nodes with values larger than the value in the root into its right subtree.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Traversing trees</h1>
                
            
            
                
<p>Traversing means visiting the nodes of a tree. There are three ways of traversing a binary tree: preorder, inorder, and postorder. Since traversing a binary tree requires visiting the root and then its left and right child, these three ways of traversal only differ in the order in which visiting is performed. The tree traversal methods that are defined with the recursion method are as follows:</p>
<p>For preorder traversal, these are the steps:</p>
<ol>
<li>Visit the root</li>
<li>Traverse the left subtree in preorder</li>
<li>Traverse the right subtree in preorder</li>
</ol>
<p>In preorder traversal, the root node of the binary tree is visited first.</p>
<p>For inorder traversal, these are the steps:</p>
<ol>
<li>Traverse the left subtree in inorder</li>
<li>Visit the root</li>
<li>Traverse the right subtree in inorder</li>
</ol>
<p>For postorder traversal, these are the steps:</p>
<ol>
<li>Traverse the left subtree in postorder</li>
<li>Traverse the right subtree in postorder</li>
</ol>
<p>Now that we've had a thorough introduction to the structures we will be looking at in this chapter, we can begin our journey.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a stack using a singly linked list</h1>
                
            
            
                
<p>In this recipe, we will learn how to implement a stack that has a LIFO structure. LIFO means that whatever element was added to the stack last will be the first to be removed. The stack is a very important component of any compiler and operating system. The stack is used in branching operations, recursion, and many other system-level tasks. The stack can be implemented using arrays as well as through linked lists. In this recipe, we will learn how to implement a stack using a single linked list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to implement a stack using a linked list:</p>
<ol>
<li>A structure is defined called <kbd>node</kbd>. In this structure, besides a data member for storing content for the stack, a pointer is also defined that points to the next node.</li>
<li>The <kbd>top</kbd> pointer is initialized to <kbd>NULL</kbd> to indicate that the stack is currently empty.</li>
<li>A menu is displayed and the user is asked whether they want to push or pop from the stack. The user can enter 1 to indicate that they want to push a value to the stack or enter 2 to indicate that they want to pop a value from the stack. If the user enters <kbd>1</kbd>, go to <em>step 4</em>. If they enter <kbd>2</kbd>, go to <em>step 9</em>. If they enter <kbd>3</kbd>, it means they want to quit the program, so go to <em>step 13</em>.</li>
<li>Allocate memory for the new node.</li>
<li>Ask the user for the value to be pushed and assign that value to the data member of the node.</li>
<li>Invoke the push function where the next pointer of the new node is set to point at <kbd>top</kbd>.</li>
<li>The <kbd>top</kbd> pointer is set to point at the new node.</li>
<li>Go to <em>step 3</em> to display the menu.</li>
<li>Check whether the <kbd>top</kbd> pointer is <kbd>NULL</kbd>. If yes, then display the message <kbd>Stack is empty</kbd> and go to <em>step 3</em> to display the menu. If <kbd>top</kbd> is not <kbd>NULL</kbd>, go to the next step.</li>
<li>A temporary pointer, <kbd>temp</kbd>, is set to point at the node where <kbd>top</kbd> is pointing.</li>
<li>The <kbd>top</kbd> pointer is set to point to where its <kbd>next</kbd> pointer is pointing.</li>
</ol>
<ol start="12">
<li>Return the node that's being pointed at by <kbd>temp</kbd> as the popped node and display the data member of the popped node.</li>
<li>Exit the program.</li>
</ol>
<p>The program for implementing a stack using a linked list is as follows:</p>
<pre>//<strong>stacklinkedlist.c</strong><br/><br/>#include&lt;stdio.h&gt;<br/><br/>#include &lt;stdlib.h&gt;<br/><br/>struct node {<br/>  int data;<br/>  struct node * next;<br/>};<br/><br/>void push(struct node * NewNode, struct node ** Top);<br/>struct node * pop(struct node ** Top);<br/><br/>int main() {<br/>  struct node * newNode, * top, * recNode;<br/>  int n = 0;<br/>  top = NULL;<br/>  while (n != 3) {<br/>    printf("\n1. Pushing an element into the stack\n");<br/>    printf("2. Popping out an element from the stack\n");<br/>    printf("3. Quit\n");<br/>    printf("Enter your choice 1/2/3:");<br/>    scanf("%d", &amp; n);<br/>    switch (n) {<br/>    case 1:<br/>      newNode = (struct node * ) malloc(sizeof(struct node));<br/>      printf("Enter the value to push: ");<br/>      scanf("%d", &amp; newNode - &gt; data);<br/>      push(newNode, &amp; top);<br/>      printf("Value %d is pushed to stack\n", newNode - &gt; data);<br/>      break;<br/>    case 2:<br/>      recNode = pop( &amp; top);<br/>      if (recNode == NULL) printf("Stack is empty\n");<br/>      else<br/>        printf("The value popped is %d\n", recNode - &gt; data);<br/>      break;<br/>    }<br/>  }<br/>  return 0;<br/>}<br/>void push(struct node * NewNode, struct node ** Top) {<br/>  NewNode - &gt; next = * Top;<br/>  * Top = NewNode;<br/>}<br/><br/>struct node * pop(struct node ** Top) {<br/>  struct node * temp;<br/>  if ( * Top == NULL) return (NULL);<br/>  else {<br/>    temp = * Top;<br/>    ( * Top) = ( * Top) - &gt; next;<br/>    return (temp);<br/>  }<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes so that we can understand the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, a structure is defined, called a node, that consists of two members: one is the data and the other is a pointer called <kbd>next</kbd>. Because we want our stack to only store integer values, the data member of the structure is defined as an integer for storing integers and the next pointer is used to connect other nodes. Initially, the <kbd>top</kbd> pointer is set to <kbd>NULL</kbd>.</p>
<p>A <kbd>while</kbd> loop is set to execute, within which a menu is displayed. The menu is set to display three options: 1, to push into the stack; 2, to pop from the stack; and 3, to quit. Until the user enters 3 in the menu, the <kbd>while</kbd> loop will continue executing and keep displaying the menu, prompting the user to enter the desired option. If the user enters 1 to push a value to the stack, a new node is created by <kbd>newNode</kbd>. The user is prompted to enter the value to be pushed to the stack. Suppose the data that's being entered by the user is 10. Here, that value will be assigned to the data member of <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ad051f01-8b3b-437b-9031-ba1b14bcefba.png" style="width:7.92em;height:6.17em;"/></p>
<p>Thereafter, the <kbd>push</kbd> function is invoked and <kbd>newNode</kbd> and the <kbd>top</kbd> pointer are passed to it. In the <kbd>push</kbd> function, the next pointer of <kbd>newNode</kbd> is set to point at the <kbd>top</kbd> pointer, which is <kbd>NULL</kbd>, and then the top pointer is set to point at X, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/277d1b4c-441a-448f-aef3-5659f893dfd7.png" style="width:10.25em;height:4.92em;"/></p>
<p>The <kbd>top</kbd> pointer must always point to the last inserted node. Due to this, it is set to point at <kbd>newNode</kbd>. After completing the <kbd>push</kbd> function, control goes back to the <kbd>main</kbd> function, where the menu will be displayed once more.</p>
<p>Let's assume that the user enters 1 to push another value to the stack. Again, a new node is created by <kbd>newNode</kbd>. The user is asked to enter the value to push. Assuming that the user enters 20, the value 20 will be assigned to the data member of <kbd>newNode</kbd>. The <kbd>push</kbd> function is invoked and <kbd>newNode</kbd> and the <kbd>top</kbd> pointer are passed to it. Here, the <kbd>top</kbd> pointer is pointing at the node that was pushed earlier, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/64e52460-2831-421b-a0da-33b7d732b1b9.png" style="width:23.33em;height:5.00em;"/></p>
<p>In the <kbd>push</kbd> function, the next pointer of <kbd>newNode</kbd> is set to point at the node where the <kbd>top</kbd> pointer is pointing to, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bbcdabfb-5091-4fec-9d07-63c99c6289aa.png" style="width:15.75em;height:4.83em;"/></p>
<p>Then, the <kbd>top</kbd> pointer is set to point at <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/178f2a74-ced5-4ebf-86e6-363a748dc792.png" style="width:18.50em;height:5.25em;"/></p>
<p>After executing the <kbd>push</kbd> function, the menu will be displayed again. Let's assume that the user wants to <em>pop</em> a value from the stack. To do this, they will enter 2 in the menu. The <kbd>pop</kbd> function will be invoked and the top pointer will be passed to it. In the <kbd>pop</kbd> function, it's ensured that the <kbd>top</kbd> pointer is not <kbd>NULL</kbd> because if it is, this means the stack is already empty; a value can't be popped out from an empty stack. To get the value from the stack, we will use a temporary pointer called <kbd>temp</kbd>. The <kbd>temp</kbd> pointer is set to point at the node that's being pointed to by the <kbd>top</kbd> pointer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb78cf8e-23a8-4f5a-b201-f19fe992329b.png" style="width:19.83em;height:4.83em;"/></p>
<p>Thereafter, the <kbd>top</kbd> pointer is set to move to the next node, that is, the node where its next pointer is pointing to. The node that's being pointed at by the <kbd>temp</kbd> pointer is returned to the <kbd>main</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/79728034-2bf2-47f8-ac1b-146e0f874ff2.png" style="width:20.67em;height:5.00em;"/></p>
<p>In the <kbd>main</kbd> function, the node that's returned by the <kbd>pop</kbd> function is assigned to <kbd>recNode</kbd>. First, it's confirmed that <kbd>recNode</kbd> is not <kbd>NULL</kbd>. Then, the value in its data member is displayed on the screen. So, 20 will be displayed on the screen.</p>
<p>After executing the <kbd>pop</kbd> function, the menu will be displayed once more, asking the user to enter the desired option. Let's assume that the user presses 2 to pop another value from the stack. Again, the <kbd>pop</kbd> function will be invoked. In the <kbd>pop</kbd> function, we check that the <kbd>top</kbd> pointer is not <kbd>NULL</kbd> and that it's pointing to a node. Because the <kbd>top</kbd> pointer is pointing at a node and is not <kbd>NULL</kbd>, a temporary pointer, <kbd>temp</kbd>, is set to point at the node that's being pointed to by the <kbd>top</kbd> pointer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1f27a42c-d088-43d1-badc-3b5b10b39470.png" style="width:9.42em;height:4.67em;"/></p>
<p>Thereafter, the <kbd>top</kbd> pointer is set to point to where its next pointer is pointing. The next pointer of <kbd>top</kbd> is pointing at <kbd>NULL</kbd>, so the <kbd>top</kbd> pointer will be set to <kbd>NULL</kbd> and the node that is being pointed to by the <kbd>temp</kbd> pointer is returned to the <kbd>main</kbd> function.</p>
<p>In the <kbd>main</kbd> function, the returned node from the <kbd>pop</kbd> function is assigned to the <kbd>recNode</kbd> pointer. After confirming that <kbd>recNode</kbd> is not pointing at <kbd>NULL</kbd>, the value in the data member of <kbd>recNode</kbd> is displayed on the screen. So, the value 10 will appear on the screen. After executing the <kbd>pop</kbd> function, the menu will be displayed again on the screen.</p>
<p>Let's assume that the user wants to pop the stack once more. But at this point, we know that the stack is empty. When the user presses <kbd>2</kbd> on the menu, the <kbd>pop</kbd> function will be invoked. However, since the value of the <kbd>top</kbd> pointer is <kbd>NULL</kbd>, the pop function will return a <kbd>NULL</kbd> value to the <kbd>main</kbd> function. In the <kbd>main</kbd> function, the <kbd>NULL</kbd> value that was returned by the <kbd>pop</kbd> function is assigned to the <kbd>recNode</kbd> pointer. Because the <kbd>recNode</kbd> pointer is assigned <kbd>NULL</kbd>, a message stating <kbd>stack is empty</kbd> will be displayed on the screen. Again, the menu will be displayed, prompting the user to enter a choice. Upon entering 3, the program will terminate.</p>
<p class="mce-root"/>
<p>The program is compiled using GCC. Because no error appears on compilation, this means the <kbd>stacklinkedlist.c</kbd> program has successfully compiled into the <kbd>stacklinkedlist.exe</kbd> file. On executing the file, we get a menu, prompting us to push or pop from the stack, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/11df2b8a-038e-4966-8c43-8642b2ff7ce8.png" style="width:28.75em;height:49.58em;"/></p>
<p>While popping from the stack, you must have noticed that the stack is a LIFO structure where the value that was pushed last was the first to be popped out.</p>
<p>Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a doubly or two-way linked list</h1>
                
            
            
                
<p>In this recipe, we will learn how to create a doubly linked list and how to traverse its elements in FIFO and LIFO order. As we explained in the introduction to this chapter, the node of a doubly linked list consists of two pointers: one points forward, while the other points backward. The pointer pointing forward is usually called <kbd>next</kbd> and is used to point at the next node. The other, which is pointing backward, is usually called <kbd>prev</kbd> and is used to point at the previous node.</p>
<p>Traversal in FIFO order means the elements of the doubly linked list are displayed in the order in which they were added to the list. Traversal is done by making use of the <kbd>next</kbd> pointer of the node.</p>
<p>Traversal in LIFO order means the elements are displayed in reverse or backward direction, and this traversal is done with the help of the <kbd>prev</kbd> pointer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In this doubly linked list, I will be making use of two pointers, <kbd>startList</kbd> and <kbd>endList</kbd>, where <kbd>startList</kbd> will point at the first node and <kbd>endList</kbd> will point at the last node. The <kbd>startList</kbd> pointer will help to traverse the list in FIFO order, while the <kbd>endList</kbd> pointer will help to traverse it in LIFO order. Follow these steps to create a doubly linked list and traverse it in either direction:</p>
<ol>
<li>Define a structure called <kbd>node</kbd>. To store content for the doubly linked list, define a data member in the node structure. Define two pointers called <kbd>next</kbd> and <kbd>prev</kbd>.</li>
<li>A menu is displayed that shows four options: <kbd>1</kbd>, to create a doubly linked list; <kbd>2</kbd>, to display the elements of the list in LIFO order; <kbd>3</kbd>, for displaying the elements in FIFO order; and <kbd>4</kbd>, to quit. If the user enters 1, go to <em>step 3</em>. If the user enters 2, go to <em>step 10</em>. If the user enters 3, go to <em>step 15</em>. Finally, if the user enters 4, then it means they want to quit the program, so go to <em>step 19</em>.</li>
</ol>
<ol start="3">
<li>Initialize the <kbd>startList</kbd> pointer to <kbd>NULL</kbd>.</li>
<li>Allocate memory for the new node.</li>
<li>Ask the user for the value to be added to the doubly linked list. The value that's entered by the user is assigned to the data member of the node.</li>
<li>Set the <kbd>next</kbd> and <kbd>prev</kbd> pointers of the node to <kbd>NULL</kbd>.</li>
<li>If this node is the first node of the doubly linked list, set the <kbd>startList</kbd> pointer to point at the new node. If this node is not the first node, don't disturb the <kbd>startList</kbd> pointer and let it point at the node that it is currently pointing to.</li>
<li>If this is the first node of the doubly linked list, set the <kbd>endList</kbd> pointer to at new node. If this is not the first node, perform the following steps:
<ol>
<li>Set the <kbd>next</kbd> pointer of the new node to <kbd>NULL</kbd>.</li>
<li>Set the <kbd>prev</kbd> pointer of the new node so that it points at the node pointed at by <kbd>endList</kbd>.</li>
<li>Set the <kbd>next</kbd> pointer of <kbd>endList</kbd> so that it points at the new node.</li>
<li>Set <kbd>endList</kbd> so that it points at the new node.</li>
</ol>
</li>
</ol>
<ol start="9">
<li>Ask the user whether more elements have to be added to the doubly linked list. If the user wants to enter more, go to <em>step 4</em>; otherwise, display the menu by going to <em>step 2</em>.</li>
<li>To display the linked list in LIFO order, let the <kbd>temp</kbd> pointer point at the node being pointed at by <kbd>endList</kbd>.</li>
<li>Let <em>step 12</em> and <em>step 13</em> run until the <kbd>temp</kbd> pointer reaches <kbd>NULL</kbd>.</li>
<li>Display the data member of the node being pointed at by <kbd>temp</kbd>.</li>
<li>Set the <kbd>temp</kbd> pointer so that it points to where its <kbd>prev</kbd> pointer is pointing.</li>
<li>The doubly linked list's content is displayed in LIFO order. Now, go to <em>step 2</em> to display the menu again.</li>
<li>Make the <kbd>temp</kbd> pointer point at the node being pointed at by the <kbd>startList</kbd> pointer.</li>
<li>If the <kbd>temp</kbd> pointer is not <kbd>NULL</kbd>, display the data member of the node being pointed at by <kbd>temp</kbd>.</li>
<li>Let the <kbd>temp</kbd> point at the node that its next pointer is pointing to.</li>
</ol>
<ol start="18">
<li>If <kbd>temp</kbd> has reached <kbd>NULL</kbd>, this means all of the nodes of the doubly linked list have been traversed. Now, you can display the menu by jumping to <em>step 2</em>. If <kbd>temp</kbd> has not reached <kbd>NULL</kbd>, then go to <em>step 16</em> to display the rest of the elements of the doubly linked list.</li>
<li>Exit the program.</li>
</ol>
<p>The program for implementing a doubly or two-way linked list is as follows:</p>
<pre>//<strong>doublylinkedlist.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#include &lt;stdlib.h&gt;<br/><br/>#include &lt;string.h&gt;<br/><br/>struct node {<br/>  int data;<br/>  struct node * next, * prev;<br/>};<br/><br/>struct node * startList, * endList;<br/>void createdoubly();<br/>void list_lifo();<br/>void list_fifo();<br/><br/>int main() {<br/>  int n = 0;<br/>  while (n != 4) {<br/>    printf("\n1. Creating a doubly linked list\n");<br/>    printf("2. Displaying elements in L.I.F.O. order\n");<br/>    printf("3. Displaying elements in F.I.F.O. order\n");<br/>    printf("4. Quit\n");<br/>    printf("Enter your choice 1/2/3/4: ");<br/>    scanf("%d", &amp; n);<br/>    switch (n) {<br/>    case 1:<br/>      createdoubly();<br/>      break;<br/>    case 2:<br/>      list_lifo();<br/>      break;<br/>    case 3:<br/>      list_fifo();<br/>      break;<br/>    }<br/>  }<br/>  return 0;<br/>}<br/><br/>void createdoubly() {<br/>  char k[10];<br/>  struct node * newNode;<br/>  startList = NULL;<br/>  strcpy(k, "yes");<br/>  while (strcmp(k, "yes") == 0 || strcmp(k, "Yes") == 0) {<br/>    if (startList == NULL) {<br/>      newNode = (struct node * ) malloc(sizeof(struct node));<br/>      printf("Enter the value to add: ");<br/>      scanf("%d", &amp; newNode - &gt; data);<br/>      newNode - &gt; next = NULL;<br/>      newNode - &gt; prev = NULL;<br/>      startList = newNode;<br/>      endList = startList;<br/>    } else {<br/>      newNode = (struct node * ) malloc(sizeof(struct node));<br/>      printf("Enter the value to add: ");<br/>      scanf("%d", &amp; newNode - &gt; data);<br/>      newNode - &gt; next = NULL;<br/>      newNode - &gt; prev = endList;<br/>      endList - &gt; next = newNode;<br/>      endList = newNode;<br/>    }<br/>    printf("Want to add more yes/no? ");<br/>    scanf("%s", k);<br/>  }<br/>  printf("Doubly linked list is created\n");<br/>}<br/>void list_lifo() {<br/>  struct node * temp;<br/>  temp = endList;<br/>  if (temp != NULL) {<br/>    printf("The elements of the doubly linked list in L.I.F.O. order :\n");<br/>    while (temp != NULL) {<br/>      printf("%d\n", temp - &gt; data);<br/>      temp = temp - &gt; prev;<br/>    }<br/>  } else<br/>    printf("The doubly linked list is empty\n");<br/>}<br/><br/>void list_fifo() {<br/>  struct node * temp;<br/>  temp = startList;<br/>  printf("The elements of the doubly linked list in F.I.F.O. order: \n");<br/>  while (temp != NULL) {<br/>    printf("%d\n", temp - &gt; data);<br/>    temp = temp - &gt; next;<br/>  }<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes so that we can understand the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When implementing a doubly linked list, a structure is defined, called a node, that consists of an integer called <kbd>data</kbd> and two pointers, <kbd>next</kbd> and <kbd>prev</kbd>. Because a doubly linked list can be traversed from either end—that is, forward or backward—the two pointers are required. The <kbd>next</kbd> pointer will point at the node after it, whereas the <kbd>prev</kbd> pointer will point at the node just before it.</p>
<p>A menu is displayed on the screen showing four options: <kbd>1</kbd>, for creating the doubly linked list; <kbd>2</kbd>, for displaying the elements of the doubly linked list in LIFO order; <kbd>3</kbd>, for displaying elements in FIFO order; and <kbd>4</kbd>, to quit the program.</p>
<p>Let's assume that the user enters 1. The <kbd>createdoubly</kbd> function will be invoked. In this function, the <kbd>startList</kbd> pointer is set to <kbd>NULL</kbd> and a string variable, <kbd>k</kbd>, is assigned the <kbd>yes</kbd> string. A <kbd>while</kbd> loop is set to execute while <kbd>k</kbd> has <kbd>yes</kbd> assigned to it. Here, the user can keep adding more elements to the doubly linked list by entering <kbd>yes</kbd> whenever they are prompted to continue. The <kbd>startList</kbd> pointer will be set to point at the first node of the doubly linked list, while the <kbd>endList</kbd> pointer will be set to point at the last node.</p>
<p>The procedure for adding the first node is different from adding the rest of the nodes. Due to this, <kbd>if else</kbd> blocks are made in the code. When <kbd>startList</kbd> is <kbd>NULL</kbd> while creating the first node, an <kbd>if</kbd> block will be executed; otherwise, an <kbd>else</kbd> block will be executed. In the <kbd>if</kbd> block, a new node is created called <kbd>newNode</kbd>. The user is asked to enter a value for the doubly linked list. Suppose the user enters the value 10; this will be assigned to the data member of <kbd>newNode</kbd>, and the <kbd>next</kbd> and <kbd>prev</kbd> pointers of <kbd>newNode</kbd> will be set to <kbd>NULL</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/08445db2-9147-4fce-83e4-0841e2e820c6.png" style="width:12.67em;height:4.92em;"/></p>
<p>The <kbd>startList</kbd> pointer is set to point at <kbd>newNode</kbd>, and the <kbd>endList</kbd> pointer is also set to point at <kbd>newNode</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/39d11d91-2d0b-4f2b-a76d-b1f28b66996d.png" style="width:15.75em;height:6.00em;"/></p>
<p><kbd>endList</kbd> will not stay on this first node; instead, it will keep moving forward and will point at the last node of this doubly linked list. After executing the <kbd>if</kbd> block, the user is asked whether more nodes have to be added. If the user enters yes, the <kbd>while</kbd> loop will execute again. Now, <kbd>startList</kbd> isn't <kbd>NULL</kbd> and is pointing at <kbd>newNode</kbd>; so, instead of the <kbd>if</kbd> block, the <kbd>else</kbd> block will execute. In the <kbd>else</kbd> block, a new node is created called <kbd>newNode</kbd>. The user is prompted to enter a value to be added to the doubly linked list. Assuming the user enters a value of 20, the value will be assigned to the data member of <kbd>newNode</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/abb133f0-d943-4b09-a8d1-6a2213614f7a.png" style="width:29.92em;height:5.92em;"/></p>
<p>The <kbd>prev</kbd> pointer of <kbd>newNode</kbd> is set to point at <kbd>endList</kbd>, while the <kbd>next</kbd> pointer of <kbd>newNode</kbd> is set to <kbd>NULL</kbd>. The <kbd>next</kbd> pointer of <kbd>endList</kbd> is set to point at <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5a6c0aae-f263-4212-8702-08f1dba14544.png" style="width:25.75em;height:6.58em;"/></p>
<p>Thereafter, the <kbd>endList</kbd> pointer is set to point at <kbd>newNode</kbd>, but the <kbd>startList</kbd> pointer will be kept pointing at the first node, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e5baf9cf-76ab-4f5f-8ae9-691220202160.png" style="width:25.42em;height:6.50em;"/></p>
<p class="mce-root"/>
<p>Once again, the user is asked whether they want to add more elements to the doubly linked list. Suppose the user doesn't want to add more elements to the list, so the text they enter is <kbd>no</kbd>. The text <kbd>no</kbd> will be assigned to <kbd>k</kbd> and, consequently, the <kbd>while</kbd> loop will terminate. The <kbd>createdoubly</kbd> function ends and control will be returned to the <kbd>main</kbd> function. In the <kbd>main</kbd> function, the menu will be displayed with the aforementioned four options.</p>
<p>Let's assume that the user enters 2 to display the elements of the doubly linked list in LIFO order. Here, the <kbd>list_lifo</kbd> function will be invoked. In the <kbd>list_lifo</kbd> function, a temporary pointer called <kbd>temp</kbd> is used and is set to point at the last node that was pointed at by the <kbd>endList</kbd> pointer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/74d46d9f-471f-478a-962f-3be90d46728a.png" style="width:27.25em;height:6.92em;"/></p>
<p>A <kbd>while</kbd> loop is set to execute until the <kbd>temp</kbd> pointer reaches <kbd>NULL</kbd>. The value in the data member of the node being pointed at by the <kbd>temp</kbd> pointer is displayed on the screen. Here, a value of 20 will appear on the screen. After that, the <kbd>temp</kbd> pointer is set to point to the node being pointed to by its <kbd>prev</kbd> pointer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d8d19e78-3cdc-4377-bc86-c47a9fb324d1.png" style="width:28.25em;height:7.17em;"/></p>
<p>Again, the value of the <kbd>temp</kbd> pointer is checked. Because the <kbd>temp</kbd> pointer isn't <kbd>NULL</kbd>, the <kbd>while</kbd> loop will execute again. Within the <kbd>while</kbd> loop, the value in the data member of the node being pointed at by the <kbd>temp</kbd> pointer is displayed on the screen. Here, a value of 10 will appear on the screen. Thereafter, the <kbd>temp</kbd> pointer is set to point at the node that its <kbd>prev</kbd> pointer is pointing to. The <kbd>prev</kbd> pointer of <kbd>temp</kbd> is pointing at <kbd>NULL</kbd>, so the <kbd>temp</kbd> pointer is set to point at <kbd>NULL</kbd>. Now, because <kbd>temp</kbd> is pointing at <kbd>NULL</kbd>, the <kbd>while</kbd> loop will terminate, the <kbd>list_lifo</kbd> function ends, and control goes back to the <kbd>main</kbd> function.</p>
<p class="mce-root"/>
<p>In the <kbd>main</kbd> function, the menu will be displayed again asking the user to enter the desired option. Now, let's assume that the user enters 3 to display the elements of the doubly linked list in FIFO order. On entering 3, the <kbd>list_fifo</kbd> function will be invoked. In the <kbd>list_fifo</kbd> function, the <kbd>temp</kbd> pointer is set to point at the node being pointed at by the <kbd>startList</kbd> pointer, as shown previously. The <kbd>while</kbd> loop is set to execute until the <kbd>temp</kbd> pointer points at <kbd>NULL</kbd>. Because <kbd>temp</kbd> is not <kbd>NULL</kbd>, the value in the data member of the node being pointed at by the <kbd>temp</kbd> pointer is displayed on the screen. Here, a value of 10 will appear on the screen. Thereafter, the <kbd>temp</kbd> pointer is set to point at the node that is being pointed to by its <kbd>next</kbd> pointer, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cae73af2-783d-4354-8e19-1b62499c1a27.png" style="width:27.25em;height:6.92em;"/></p>
<p>Because the <kbd>temp</kbd> pointer is still not pointing at <kbd>NULL</kbd>, the <kbd>while</kbd> loop will execute once more. Within the <kbd>while</kbd> loop, the value in the data member of the node being pointed at by the <kbd>temp</kbd> pointer is displayed on the screen; a value of 20 will appear. Again, the <kbd>temp</kbd> pointer is set to point at the node that its next pointer is pointing to. The next pointer of <kbd>temp</kbd> is pointing at the <kbd>NULL</kbd> pointer, so <kbd>temp</kbd> will point at <kbd>NULL</kbd>. Because the <kbd>temp</kbd> pointer is pointing at <kbd>NULL</kbd>, the <kbd>while</kbd> loop will terminate; hence, the <kbd>list_fifo</kbd> function ends and control goes back to the <kbd>main</kbd> function. Here, the menu is displayed once more, asking the user to enter the desired option. Let's assume the user enters 4 to quit the program. Upon entering 4, the program will terminate.</p>
<p>The program is compiled using GCC. Because no error appears upon compilation, this means the <kbd>doublylinkedlist.c</kbd> program has successfully compiled into the <kbd>doublylinkedlist.exe</kbd> file. On executing the file, we get a menu asking for options for creating a doubly linked list and for traversing the doubling linked list in LIFO as well as in FIFO order. By doing this, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3bb270ba-890b-467a-8426-c07ad0332809.png" style="width:33.17em;height:48.50em;"/></p>
<p>The preceding screenshot shows the benefit of using a doubly linked list that is traversing its elements in FIFO, as well as in LIFO, order.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a circular linked list</h1>
                
            
            
                
<p>In this recipe, we will learn how to implement a circular linked list. The difference between a linear linked list and a circular linked list is that where the last node of the linear linked list points at <kbd>NULL</kbd>, the pointer of the last node in a circular linked list points back to the first node, hence allowing the pointer to traverse in a backward direction too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to implement a circular linked list:</p>
<ol>
<li>Define a structure called <kbd>node</kbd>. To store data in a circular linked list, define a data member in the node structure. Besides a data member, define a pointer that will point at the next node.</li>
<li>A pointer called <kbd>startList</kbd> is initialized to <kbd>NULL</kbd>. The <kbd>startList</kbd> pointer will designate the start of the circular linked list.</li>
<li>A menu is displayed and the user is asked to press <kbd>1</kbd> to add elements to the circular linked list, <kbd>2</kbd> to display elements of the circular linked list, and <kbd>3</kbd> to quit the program. If the user enters 1, go to <em>step 4</em>. If they enter 2, go to <em>step 16</em>. If they enter 3, it means they want to quit the program, so go to <em>step 23</em>.</li>
<li>The user is prompted to specify how many numbers they want to add to the circular linked list. A loop is set to execute for the specified number of times; that is, <em>steps 5</em> to <em>14</em> are repeated for the specified number of times.</li>
<li>Allocate memory for the new node.</li>
<li>Ask the user for the value to be added to the circular linked list. The value that's entered by the user is assigned to the data member of the node.</li>
<li>If <kbd>startList</kbd> is <kbd>NULL</kbd>—that is, if it is the first node of the circular linked list—then make the <kbd>startList</kbd> pointer point at a new node.</li>
<li>To make a linked list appear as circular, make the next pointer of <kbd>startList</kbd> point at <kbd>startList</kbd>.</li>
<li>If <kbd>startList</kbd> is not <kbd>NULL</kbd>—that is, if it is not the first node of the circular linked list—follow <em>steps 10</em> to <em>14</em>.</li>
<li>Make the <kbd>temp</kbd> pointer point at <kbd>startList</kbd>.</li>
<li>Until the <kbd>next</kbd> pointer of <kbd>temp</kbd> is equal to <kbd>startList</kbd>, make the <kbd>temp</kbd> pointer point to where its next pointer is pointing; that is, set the <kbd>temp</kbd> pointer so that it points at the last node of the circular linked list.</li>
</ol>
<ol start="12">
<li>Once the <kbd>temp</kbd> pointer reaches the last node of the circular linked list, the next pointer of <kbd>temp</kbd> is set to point at the new node.</li>
<li>Then, the <kbd>temp</kbd> pointer is set to point at the new node.</li>
<li>The next pointer of <kbd>temp</kbd> is set to point at <kbd>startLIst</kbd>.</li>
<li>Go to <em>step 3</em> to display the menu.</li>
<li>The previous step ensures <kbd>startList</kbd> is not <kbd>NULL</kbd>. If <kbd>startList</kbd> is <kbd>NULL</kbd>, it means the circular linked list is empty. In that case, a message is displayed, informing the user that the circular linked list is empty. Then, control jumps to <em>step 3</em> to display the menu.</li>
<li>If <kbd>startList</kbd> is not <kbd>NULL</kbd>, the data member of the node being pointed at by the <kbd>startList</kbd> pointer is displayed on the screen.</li>
<li>A temporary pointer, <kbd>temp</kbd>, is set to point to where the next pointer of <kbd>startList</kbd> is pointing to.</li>
<li>Repeat <em>steps 20</em> and <em>21</em> until the <kbd>temp</kbd> pointer reaches the node being pointed at by the <kbd>startList</kbd> pointer.</li>
<li>Display the contents of the node being pointed at by the data member of <kbd>temp</kbd>.</li>
<li>The <kbd>temp</kbd> pointer is set to point to where its next pointer is pointing.</li>
<li>Jump to <em>step 3</em> to display the menu.</li>
<li>Terminate the program.</li>
</ol>
<p>The program for implementing a circular linked list is as follows:</p>
<pre>//<strong>circularlinkedlist.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#include &lt;stdlib.h&gt;<br/><br/>struct node {<br/>  int data;<br/>  struct node * next;<br/>};<br/><br/>struct node * startList = NULL;<br/><br/>void addlist(struct node ** h);<br/>void disp();<br/><br/>int main() {<br/>  struct node * newNode;<br/>  int n = 0, i, k;<br/>  while (n != 3) {<br/>    printf("\n1. Adding elements to the circular linked list\n");<br/>    printf("2. Displaying elements of the circular linked list\n");<br/>    printf("3. Quit\n");<br/>    printf("Enter your choice 1/2/3: ");<br/>    scanf("%d", &amp; n);<br/>    switch (n) {<br/>    case 1:<br/>      printf("How many values are there ");<br/>      scanf("%d", &amp; k);<br/>      printf("Enter %d values\n", k);<br/>      for (i = 1; i &lt;= k; i++) {<br/>        newNode = (struct node * ) malloc(sizeof(struct node));<br/>        scanf("%d", &amp; newNode - &gt; data);<br/>        addlist( &amp; newNode);<br/>      }<br/>      printf("Values added in Circular Linked List \n");<br/>      break;<br/>    case 2:<br/>      disp();<br/>      break;<br/>    }<br/>  }<br/>  return 0;<br/>}<br/><br/>void addlist(struct node ** NewNode) {<br/>  struct node * temp;<br/>  if (startList == NULL) {<br/>    startList = * NewNode;<br/>    startList - &gt; next = startList;<br/>  } else {<br/>    temp = startList;<br/>    while (temp - &gt; next != startList)<br/>      temp = temp - &gt; next;<br/>    temp - &gt; next = * NewNode;<br/>    temp = * NewNode;<br/>    temp - &gt; next = startList;<br/>  }<br/>}<br/><br/>void disp() {<br/>  struct node * temp;<br/>  if (startList == NULL)<br/>    printf("The circular linked list is empty\n");<br/>  else {<br/>    printf("Following are the elements in circular linked list:\n");<br/>    printf("%d\n", startList - &gt; data);<br/>    temp = startList - &gt; next;<br/>    while (temp != startList) {<br/>      printf("%d\n", temp - &gt; data);<br/>      temp = temp - &gt; next;<br/>    }<br/>  }<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes so that we can understand the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A structure is defined, called a node, that consists of two members: an integer and a pointer called <kbd>next</kbd>. I am creating a circular linked list comprised of integer numbers, which is why I have taken an integer member. However, you can use any number of members you want, as well as any data type.</p>
<p>We define a pointer called <kbd>startList</kbd> and initialize it to <kbd>NULL</kbd>. The <kbd>startList</kbd> pointer will be used to point at the first node of the circular linked list.</p>
<p>A menu is displayed on the screen that shows three options: <kbd>1</kbd>, to add elements to the circular linked list; <kbd>2</kbd>, to display elements of the circular linked list; and <kbd>3</kbd>, to quit. Obviously, the first step is to add elements to the circular linked list. Let's assume that the user enters 1. On entering 1, the user will be asked to specify how many values they want to enter in the list. The limit that's entered by the user will be assigned to a variable called <kbd>k</kbd>. Assuming that the user wants to enter five elements in the list, a <kbd>for</kbd> loop is set to run five times. Within the <kbd>for</kbd> loop, a new node is created called <kbd>newNode</kbd>. The value that's entered by the user is assigned to the data member of <kbd>newNode</kbd>. Assuming the value that's entered by the user is 10, it will be assigned to the data member of <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bd7d0b89-849c-4743-a722-80cb251ac5db.png" style="width:7.83em;height:6.17em;"/></p>
<p>The <kbd>addlist</kbd> function will be invoked and <kbd>newNode</kbd> will be passed to it as an argument. In the <kbd>addlist</kbd> function, it is confirmed whether it is the first node of the circular linked list or not; that is, if <kbd>startList</kbd> is <kbd>NULL</kbd>, it is set to point at <kbd>newNode</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ddbf4966-3251-45db-b97c-bbf95fe499a7.png" style="width:10.08em;height:6.83em;"/></p>
<p>To make it a circular linked list, the next pointer of <kbd>startList</kbd> is set to point at <kbd>startList</kbd> itself:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/18d831f7-c2ff-49b8-84d6-3695f73c5055.png" style="width:10.83em;height:7.50em;"/></p>
<p>The <kbd>addlist</kbd> function ends. Control goes back to the main function and resumes the <kbd>for</kbd> loop's execution. Within the <kbd>for</kbd> loop, a <kbd>newNode</kbd> node is created. The value that's entered by the user is assigned to the data member of <kbd>newNode</kbd>. Assuming that the user has entered a value of 20, it will be assigned to the data member of <kbd>newNode</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f76a5552-d4af-462a-a06d-15492e2bfefe.png" style="width:17.58em;height:6.83em;"/></p>
<p>Again, the <kbd>addlist</kbd> function is invoked and <kbd>newNode</kbd> is passed to it. In the <kbd>addlist</kbd> function, because the <kbd>startList</kbd> pointer is no longer <kbd>NULL</kbd>, the <kbd>else</kbd> block will be executed. In the <kbd>else</kbd> block, a temporary pointer called <kbd>temp</kbd> is set to point at <kbd>startList</kbd>. A <kbd>while</kbd> loop is set to execute until the next pointer of <kbd>temp</kbd> points at <kbd>startList</kbd>; that is, until the <kbd>temp</kbd> pointer reaches the last node of the circular linked list, the <kbd>temp</kbd> pointer will keep moving further so that it points at its next node. Because there is only a single node in the circular linked list, the <kbd>temp</kbd> pointer is already pointing at the last node of the list:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6a7ddca6-64af-4ac2-9c1c-8326829b46e4.png" style="width:16.17em;height:6.33em;"/></p>
<p>Once the <kbd>temp</kbd> pointer reaches the last node of the circular linked list, the next pointer of <kbd>temp</kbd> is set to point at <kbd>newNode</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a0dd88ba-a9ba-47ba-82cb-555a0dd9e642.png" style="width:14.00em;height:6.42em;"/></p>
<p>Thereafter, the <kbd>temp</kbd> pointer is set to point at <kbd>newNode</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c25e914c-b753-46b5-a583-755ddb88c8dc.png" style="width:13.08em;height:6.25em;"/></p>
<p>Finally, to make the linked list appear circular, the next pointer of <kbd>temp</kbd> is set to point at <kbd>startList</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/dc084ee7-5ca2-4916-9cf4-4fbe1e804156.png" style="width:14.33em;height:6.17em;"/></p>
<p>This procedure is repeated for the other three elements of the circular linked list. Assuming the other the three elements that are entered are 30, 40, and 50, the circular linked list will appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/238ecd8f-3881-40b7-9040-d79acdb41f4a.png" style="width:31.92em;height:6.08em;"/></p>
<p class="mce-root"/>
<p>After creating the circular linked list, the user will see the display menu again. Assuming the user wants to display the elements of the circular linked list, they will enter a value as per the menu choices. Upon entering the value, the <kbd>disp</kbd> function will be invoked. In the <kbd>disp</kbd> function, it's ensured that the <kbd>startList</kbd> pointer is <kbd>NULL</kbd>. If the <kbd>startList</kbd> pointer is <kbd>NULL</kbd>, it means the circular linked list is empty. In that case, the <kbd>disp</kbd> function will terminate after displaying the message that the circular linked list is empty. If the <kbd>startList</kbd> pointer is not empty, the value in the data member of the node being pointed at by the <kbd>startList</kbd> pointer is displayed on the screen; that is, a value of 10 will appear on the screen. A temporary pointer, <kbd>temp</kbd>, is set to point at the node being pointed at by the next pointer of <kbd>startList</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c05a6088-bde0-4a6b-b7a3-93c75c315db2.png" style="width:32.83em;height:6.25em;"/></p>
<p>A <kbd>while</kbd> loop is set to execute until the <kbd>temp</kbd> pointer reaches the node being pointed at by the <kbd>startList</kbd> pointer. Within the <kbd>while</kbd> loop, the data member of the node being pointed at by the <kbd>temp</kbd> pointer is displayed on the screen; that is, a value of 20 will appear on the screen. Thereafter, the <kbd>temp</kbd> pointer is set to point at the node that its next pointer is pointing to. This way, the <kbd>while</kbd> loop will execute and display all of the elements of the circular linked list. When the <kbd>while</kbd> loop ends, the <kbd>disp</kbd> function also ends. Control goes back to the <kbd>main</kbd> function, where the menu will be displayed once more. To exit the program, the user has to enter 3. On entering 3, the program will terminate.</p>
<p>The program is compiled using GCC. Because no error appears on compilation, this means the <kbd>circularlinkedlist.c</kbd> program has successfully compiled into the <kbd>circularlinkedlist.exe</kbd> file. On executing the file, we get a menu that will not only add elements to the circular linked list but will display them too. By doing this, we get the output shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d1593da0-7c2b-4c29-80f1-d46b8594694f.png" style="width:36.83em;height:46.00em;"/></p>
<p>Voilà! We have successfully implemented a circular linked list. Now, let's move on to the next recipe!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a binary search tree and performing an inorder traversal on it recursively</h1>
                
            
            
                
<p>In this recipe, we will ask the user to enter a few numbers and build a binary tree from those numbers. Once the binary tree has been created, its inorder traversal is performed. These steps will be divided into two parts: creating the binary tree and traversing the binary tree in inorder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it... – binary tree</h1>
                
            
            
                
<p>Follow these steps to create the binary tree:</p>
<ol>
<li>Create a node with the following structure: <kbd>data</kbd> for storing tree elements, a <kbd>right</kbd> pointer to point at the right child of the tree, and a <kbd>left</kbd> pointer to point at the left child of the tree.</li>
<li>Create the <kbd>root</kbd> node of the tree. To do this, allocate memory space for a new node and set the <kbd>root</kbd> pointer to point at it.</li>
<li>Prompt the user to enter the tree elements. The value that's entered by the user is assigned to the data member of the <kbd>root</kbd> node.</li>
<li>The <kbd>left</kbd> and <kbd>right</kbd> pointers of the <kbd>root</kbd> node are set to <kbd>NULL</kbd>.</li>
<li>The root node is created. Next, prompt the user to specify the number of elements in the tree.</li>
<li>Repeat <em>steps 7</em> to <em>22</em> for the number of elements specified by the user.</li>
<li>Allocate memory space for a new node and set the <kbd>new</kbd> pointer so that it points at it.</li>
<li>Prompt the user to enter the tree element. The tree element that's entered by the user is assigned to the data member of the new node.</li>
<li>The <kbd>left</kbd> and <kbd>right</kbd> pointers of the new node are set to <kbd>NULL</kbd>.</li>
<li>To connect the root node to the new node, we need to find a location where it can be connected. To do so, set the <kbd>temp</kbd> pointer so that it points at the root node. Compare the values in the data members of the new node and <kbd>temp</kbd> node.</li>
<li>If <kbd>new -&gt;data &gt; temp-&gt;data</kbd>, go to <em>step 12</em>; otherwise, go to <em>step 16</em>.</li>
</ol>
<ol start="12">
<li>If the right link of <kbd>temp</kbd> is <kbd>NULL</kbd>—that is, if there is no child on the right of the <kbd>temp</kbd> node—then, the new node is added to the right link of the <kbd>temp</kbd> node.</li>
<li>The new node is added as the right child of the <kbd>temp</kbd> node. Jump to <em>step 7</em> to add more tree elements.</li>
<li>If the right link of the root is not <kbd>NULL</kbd>, the <kbd>temp</kbd> pointer is set to point where the <kbd>right</kbd> pointer of <kbd>temp</kbd> is pointing to.</li>
<li>Go to <em>step 11</em> for more comparisons.</li>
<li>If <kbd>new-&gt;data &lt; root-&gt;data</kbd>, go to <em>step 17</em>; otherwise, go to <em>step 21</em>.</li>
<li>If the left link of the node is <kbd>NULL</kbd>—that is, there is no child on the left of the temp node—then the new node is added to the left link.</li>
<li>The new node is added as the left child of the <kbd>temp</kbd> node. Jump to <em>step 7</em> to add more tree elements.</li>
<li>If the left link of the root is not <kbd>NULL</kbd>, the <kbd>temp</kbd> pointer is set to point to where its <kbd>left</kbd> pointer is pointing.</li>
<li>Go to <em>step 11</em> for more comparisons.</li>
<li>If <kbd>new-&gt;data = temp-&gt;data</kbd>, this means the value in the new node is a duplicate and cannot be added to the tree.</li>
<li>Go to <em>step 7</em> to add more tree elements.</li>
<li>For inorder traversal, we will follow the algorithm that's provided in the next section. The <kbd>inorder</kbd> function is called recursively and the root node of the binary tree is passed to this function.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it... – inorder traversal of the tree</h1>
                
            
            
                
<p>Because it's a recursive form, the function will be called recursively. The function is as follows:</p>
<pre>inorder(node)</pre>
<p>Here, <kbd>inorder</kbd> is the function that will be recursively called and <kbd>node</kbd> is the node of the binary tree that's being passed to it. Initially, the node will be the root of the binary tree, whose inorder traversal is required. Follow these steps:</p>
<ol>
<li>If node is <kbd>NULL</kbd>, go to <em>step 2</em>; otherwise, return to the caller function.</li>
</ol>
<ol start="2">
<li>Call the same function (the <kbd>inorder</kbd> function) with the node's left child set as an argument:</li>
</ol>
<pre style="padding-left: 60px">call inorder(node-&gt;leftchild)</pre>
<ol start="3">
<li>Display the content in the node:</li>
</ol>
<pre style="padding-left: 60px">display node-&gt;info</pre>
<ol start="4">
<li>Call the same function itself (the <kbd>inorder</kbd> function) with the node's right child set as an argument:</li>
</ol>
<pre>   call inorder(node-&gt;rightchild)</pre>
<p>The program for creating a binary search tree and traversing it in inorder is as follows:</p>
<pre>//<strong>binarysearchtree.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#include &lt;stdlib.h&gt;<br/><br/>#define max 20<br/>struct tree {<br/>  int data;<br/>  struct tree * right;<br/>  struct tree * left;<br/>};<br/>void build(int Arr[], int Len);<br/>struct tree * makeroot(int val);<br/>void rightchild(struct tree * rootNode, int val);<br/>void leftchild(struct tree * rootNode, int val);<br/>void travino(struct tree * node);<br/>int main() {<br/>  int arr[max], i, len;<br/>  printf("How many elements are there for making the binary search tree? ");<br/>  scanf("%d", &amp; len);<br/>  printf("Enter %d elements in array \n", len);<br/>  for (i = 0; i &lt; len; i++)<br/>    scanf("%d", &amp; arr[i]);<br/>  build(arr, len);<br/>  return 0;<br/>}<br/><br/>void build(int Arr[], int Len) {<br/>  struct tree * temp, * rootNode;<br/>  int j;<br/>  rootNode = makeroot(Arr[0]);<br/>  for (j = 1; j &lt; Len; j++) {<br/>    temp = rootNode;<br/>    while (1) {<br/>      if (Arr[j] &lt; temp - &gt; data) {<br/>        if (temp - &gt; left != NULL) {<br/>          temp = temp - &gt; left;<br/>          continue;<br/>        }<br/>        leftchild(temp, Arr[j]);<br/>      }<br/>      if (Arr[j] &gt; temp - &gt; data) {<br/>        if (temp - &gt; right != NULL) {<br/>          temp = temp - &gt; right;<br/>          continue;<br/>        }<br/>        rightchild(temp, Arr[j]);<br/>      }<br/>      break;<br/>    }<br/>  }<br/>  printf("Binary Search Tree is created\n");<br/>  printf("The inorder traversal of the tree is as follows:\n");<br/>  travino(rootNode);<br/>}<br/><br/>struct tree * makeroot(int val) {<br/>  struct tree * rootNode;<br/>  rootNode = (struct tree * ) malloc(sizeof(struct tree));<br/>  rootNode - &gt; data = val;<br/>  rootNode - &gt; right = NULL;<br/>  rootNode - &gt; left = NULL;<br/>  return rootNode;<br/>}<br/><br/>void leftchild(struct tree * rootNode, int val) {<br/>  struct tree * newNode;<br/>  newNode = (struct tree * ) malloc(sizeof(struct tree));<br/>  newNode - &gt; data = val;<br/>  newNode - &gt; left = NULL;<br/>  newNode - &gt; right = NULL;<br/>  rootNode - &gt; left = newNode;<br/>}<br/><br/>void rightchild(struct tree * rootNode, int val) {<br/>  struct tree * newNode;<br/>  newNode = (struct tree * ) malloc(sizeof(struct tree));<br/>  newNode - &gt; data = val;<br/>  newNode - &gt; left = NULL;<br/>  newNode - &gt; right = NULL;<br/>  rootNode - &gt; right = newNode;<br/>}<br/><br/>void travino(struct tree * node) {<br/>  if (node != NULL) {<br/>    travino(node - &gt; left);<br/>    printf("%d\t", node - &gt; data);<br/>    travino(node - &gt; right);<br/>  }<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes so that we can understand the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works... – binary tree</h1>
                
            
            
                
<p>We created a structure called <kbd>tree</kbd> consisting of the following members:</p>
<ul>
<li><kbd>data</kbd>: An integer member for storing integer data. Here, we're assuming that our tree only consists of integer elements.</li>
<li><kbd>right</kbd> and <kbd>left</kbd> pointers: These are used to point at the left and right child, respectively.</li>
</ul>
<p>Internally, the tree will be maintained through an array; an integer array is defined of the size 20. For our purposes, let's assume that the user doesn't enter more than 20 elements for the tree. However, you can always increase the size of the macro to any larger number you desired.</p>
<p>The user is prompted to specify the number of elements they want to enter for the tree. Let's say the user wants to enter seven elements for the tree; here, the value 7 will be assigned to the <kbd>len</kbd> variable. The user is prompted to enter the seven integers and the values entered by them will be assigned to the <kbd>arr</kbd> array, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6ea4ab83-40b9-4a24-ada1-7ea9807a844b.png" style="width:23.08em;height:4.67em;"/></p>
<p>The <kbd>build</kbd> function is invoked and the array, <kbd>arr</kbd>, containing the tree elements and the length of the array, <kbd>len</kbd>, are passed to it. In the <kbd>build</kbd> function, we need to create a root node of the tree. To create a root node of the tree, the <kbd>makeroot</kbd> function is invoked and the first element of the array, <kbd>arr</kbd>, is passed to it as an argument. In the <kbd>makeroot</kbd> function, a node called <kbd>rootNode</kbd> is created and the value of the first array element is assigned to its data member. Because the root node of the tree is not pointing at any other node at the moment, the right and left child of the root node are set to <kbd>NULL</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0edf7982-a38b-4793-91a4-e2cc4f4251d4.png" style="width:7.58em;height:8.58em;"/></p>
<p>The <kbd>makeroot</kbd> function ends and <kbd>rootNode</kbd> is returned to the <kbd>build</kbd> function. In the <kbd>build</kbd> function, a <kbd>temp</kbd> pointer is set to point at <kbd>rootNode</kbd>. All of the array elements from index 1 and above are compared with the data members of the <kbd>temp</kbd> node, that is, the root node. If the array element is smaller than the data member of the <kbd>temp</kbd> node, the array element will be added as the left child of the root node. Also, if the array element is larger than the data member of the <kbd>temp</kbd> node, it will be added as the right child of the root node, for example, if the second array element is 20 and the root node is 40. Because 20 is smaller than 40, it is checked whether the <kbd>left</kbd> pointer of the <kbd>temp</kbd> node is <kbd>NULL</kbd>. Because the <kbd>left</kbd> pointer of <kbd>temp</kbd> is <kbd>NULL</kbd>, the <kbd>leftchild</kbd> function is invoked and 20 is passed to it. In the <kbd>leftchild</kbd> function, a new node is created called <kbd>newNode</kbd>. Here, the second array element (20) is assigned to the data member of <kbd>newNode</kbd>. The <kbd>left</kbd> and <kbd>right</kbd> pointers of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. The <kbd>left</kbd> pointer of <kbd>temp</kbd> is set to point at <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/175d0f87-4e87-4ee8-aee5-ea4349f47147.png" style="width:11.25em;height:12.75em;"/></p>
<p>Control goes back to the <kbd>build</kbd> function, where the <kbd>for</kbd> loop will pick up the next array element for building the tree. Let's say the next array element is 60. Again, a <kbd>temp</kbd> pointer is set to point at the root node. The value 60 is compared with the root node, which is 40. Because the value of the array element, 60, is greater than the root node, 40, the right child of the root node is checked. Because the right child of the root node is <kbd>NULL</kbd>, the <kbd>rightchild</kbd> function is invoked and the <kbd>temp</kbd> pointer and the array element, 60, are passed to it. In the <kbd>rightchild</kbd> function, a new node is created called <kbd>newNode</kbd> and the value 60 is passed to it, which is assigned to its data member. The <kbd>left</kbd> and <kbd>right</kbd> pointers of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. The <kbd>right</kbd> pointer of <kbd>rootNode</kbd> is set to point at <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0c051ac3-4b13-48eb-b3b3-d516019dee9d.png" style="width:13.67em;height:12.42em;"/></p>
<p>After completing the <kbd>rightchild</kbd> function, control goes back to the <kbd>build</kbd> function, where the <kbd>for</kbd> loop picks up the next array element for building the tree. The next array element is 80. A temporary pointer, <kbd>temp</kbd>, is set to point at the root node. The root node, 40 is compared with the new element to be added, 80. Because 80 &gt; 40, the right child of the <kbd>temp</kbd> node is checked. The <kbd>right</kbd> pointer of the <kbd>temp</kbd> node is not <kbd>NULL</kbd>, so the <kbd>temp</kbd> pointer is set to point at its right node, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/62a3ecf0-7352-4881-9a00-31dd843a41f4.png" style="width:14.50em;height:13.08em;"/></p>
<p>Now, the <kbd>right</kbd> pointer of <kbd>temp</kbd> is checked again. This procedure is repeated until the <kbd>right</kbd> pointer of <kbd>temp</kbd> is found to be <kbd>NULL</kbd>. The <kbd>right</kbd> pointer of 60 is <kbd>NULL</kbd>, so the <kbd>rightchild</kbd> function is invoked and <kbd>temp</kbd>, 60, and the new element, 80, are passed to it. In the <kbd>rightchild</kbd> function, a new node is created called <kbd>newNode</kbd> and the value 80 is assigned to it. The right and left pointers of <kbd>newNode</kbd> are set to <kbd>NULL</kbd>. The <kbd>right</kbd> pointer of <kbd>temp</kbd> is set to point at <kbd>newNode</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/db86352f-0d49-4f40-b250-fb8f3694e29d.png" style="width:15.83em;height:16.50em;"/></p>
<p>After completing the <kbd>rightchild</kbd> function, control jumps back to the <kbd>build</kbd> function, where the <kbd>for</kbd> loop picks up the next array element for building the tree. After all of the array elements have been used, the binary search tree will look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e653e801-ba03-49a4-86f8-5442d383bbac.png" style="width:16.83em;height:17.08em;"/></p>
<p>Once the binary search tree has been created, the <kbd>travino</kbd> function is invoked for inorder traversal of the binary tree and the root node is passed to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works... – inorder traversal of the tree</h1>
                
            
            
                
<p>The <kbd>travino</kbd> function is a recursive function. First, it ensures the supplied node is not <kbd>NULL</kbd>. If the node is not <kbd>NULL</kbd>, a recursive call to the <kbd>travino</kbd> function is made with the node's left child. The node is checked to ensure it's not <kbd>NULL</kbd>. If it isn't, again, a recursive call to the <kbd>travino</kbd> function is made with its left child. If the node is <kbd>NULL</kbd>, the value in the data member of the node is displayed on the screen and a recursive call to the <kbd>travino</kbd> function is made with the node's right child. This procedure is repeated until all of the nodes that are displayed on the screen have been visited.</p>
<p>The inorder traversal is described as <em>L</em>,<em>V</em>,<em>R</em>, as follows:</p>
<ul>
<li>L means visiting the left child</li>
<li>V means visiting the node that is displaying its content</li>
<li>R means visiting the right child</li>
</ul>
<p>On each node of the binary tree, LVR operations are applied, beginning from the root node. Our binary tree has already been created and looks as follows. At node 40, three operations—L,V, and R—are applied. L means visiting its left child, so we move to the left child of node 40, but two of its operations, V and R, still need to be completed on the node left. So, node 40 is pushed onto the stack with V and R attached to it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fe0d2554-9261-4645-9d19-fd47caa653fe.png" style="width:8.42em;height:10.83em;"/></p>
<p>The left child of node 40 is node 20. Again, at node 20, three operations—L,V, and R—are applied. First, L (the left child) is visited. Only two operations, V and R, are left. So, again, node 20 is pushed onto the stack with V and R attached to it. The left child of node 20 is node 10. Again, at this node L, V, and R are applied. Since its left child is <kbd>NULL</kbd>, the second operation, V, is applied; that is, the node is displayed or we can say it is traversed. After that, we go to its right child. The right child of node 10 is <kbd>NULL</kbd> and since all three operations (L,V, and R) have been applied on this node, it is not pushed to the stack:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b621ce57-32ab-44b2-bb83-17f6eb4d0ca5.png" style="width:14.92em;height:7.92em;"/></p>
<p>Now, node 20 is popped from the stack. Its two operations, V and R, are pending. First, it is visited (displayed) and then we go to its right child:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/52060a7d-41df-4c5d-8c1d-ed5974915369.png" style="width:13.67em;height:7.25em;"/></p>
<p>The right child of node 20 is 30. Again, at node 30, three operations—L,V, and R—are applied. First L (the left child) is visited. Since it has no left child, the second operation, V, is applied; that is, node 30 is visited (displayed), and then we go to its right child. It has no right child either and since all three operations (L,V, and R) have been applied on this node, 30 is not pushed to the stack:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1166c2b0-4537-4afc-b92e-8cb0008651b7.png" style="width:13.92em;height:6.92em;"/></p>
<p>Now, node 40 is popped from the stack. Its two operations, V and R, are pending. First, it is visited (displayed) and then we go to its right child. The right child of node 40 is node 60. At node 60, the three operations—L,V, and R—are applied. First, L (the left child) is visited. V and R are left. Here, node 60 is pushed to the stack with V and R attached to it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/52dbf9ff-a522-4981-a405-8c1d91826656.png" style="width:14.83em;height:7.58em;"/></p>
<p class="mce-root"/>
<p>The left child of node 60 is node 50. Again at this node, L, V, and R are applied. Since its left child is <kbd>NULL</kbd>, the second operation, V, is applied; that is, node 50 is displayed or we can say it is traversed. After that, we go to its right child. The right child of node 50 is <kbd>NULL</kbd> and since all three operations (L,V, and R) have been applied to this node, it is not pushed to the stack:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7ea51249-d309-46d1-8f81-4847b36790d6.png" style="width:18.50em;height:7.83em;"/></p>
<p>Now, node 60 is popped from the stack. Its two operations, V and R, are pending. First, it is visited (displayed) and then we go to its right child. So, the visited nodes will be 10, 20, 30, 40, 50, and 60.</p>
<p>The right child of node 60 is 80. Again, at node 80, three operations—L,V, and R—are applied. First, L (its left child) is visited. Since it has no left child, the second operation, V, is applied; that is, node 80 is visited (displayed), and then we go to its right child. It has no right child either and since all three operations (L,V, and R) have been applied to this node, 80 is not pushed to the stack.</p>
<p>So, the final inorder traversal of the tree is 10, 20, 30, 40, 50, 60, and 80.</p>
<p>The program is compiled using the GCC compiler using the following statement:</p>
<pre><strong>D:\CAdvBook&gt;GCC binarysearchtree.c - binarysearchtree</strong></pre>
<p>As shown in the following screenshot, no error appears when we compile. This means the <kbd>binarysearchtree.c</kbd> program has successfully compiled into a <kbd>.exe</kbd> file called <kbd>binarysearchtree.exe</kbd>. Let's run the executable file and enter some elements to create a binary tree and see its inorder traversal. By doing this, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2fac6eb0-302a-4251-8697-856e33eae1c1.png" style="width:37.42em;height:16.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing postorder traversal of a binary tree non-recursively</h1>
                
            
            
                
<p>In this recipe, we will perform postorder traversal of a binary tree without recursion. This will be done through non-recursive calls to the function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>To create a binary tree, refer to the <em>Creating a binary search tree and performing an inorder traversal on it recursively</em> recipe. We will be performing postorder traversal on the same binary tree we created in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>For postorder traversal of a binary tree, we need to apply three tasks—L, R, and V—on each of the tree nodes. These tasks are as follows:</p>
<ul>
<li>L means visit the left link</li>
<li>R means visit the right link</li>
<li>V means visit the node</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To find out which tasks between L, R, and V are pending and which have already been performed, we will use two stacks: one for storing the node and another for storing an integer value of 0 or 1. Let's go over what 0 and 1 indicate:</p>
<ul>
<li>The value 0 indicates that the L task is done, while the R and V tasks are pending on the node.</li>
<li>The value 1 means that the L and R tasks have been performed on the node and that only V is pending.</li>
</ul>
<p>Follow these steps to perform postorder tree traversal:</p>
<ol>
<li>A temporary node called <kbd>temp</kbd> is set to point at the root node of the tree.</li>
<li>Push the node that's being pointed at by <kbd>temp</kbd> to <kbd>nodeArray</kbd> and the value 0 to <kbd>valueArray</kbd>. The integer 0 in <kbd>valueArray</kbd> indicates that the R and V tasks are pending on the node.</li>
<li>Make the <kbd>temp</kbd> node point at the node where its <kbd>left</kbd> pointer is pointing.</li>
<li>If the <kbd>temp</kbd> is not pointing at <kbd>NULL</kbd>, go to <em>step 2</em>.</li>
<li>If <kbd>temp</kbd> reaches <kbd>NULL</kbd>, go to <em>step 6</em>.</li>
<li>Pop the node from <kbd>nodeArray</kbd>.</li>
<li>Pop the integer from <kbd>valueArray</kbd>.</li>
<li>If the popped integer value is 1, visit the node that is displaying the data member of the node. Then, go to <em>step 6</em>.</li>
<li>If the popped integer value is 0, go to <em>step 10</em>.</li>
<li>Push the node to <kbd>nodeArray</kbd>.</li>
<li>Push the integer 1 to <kbd>valueArray</kbd> to indicate that the L and R operations have been performed and that only V is pending.</li>
<li>Make the <kbd>temp</kbd> pointer point to where its <kbd>right</kbd> pointer is pointing.</li>
<li>If the <kbd>temp</kbd> pointer does not reach <kbd>NULL</kbd>, go to <em>step 2</em>.</li>
<li>If the <kbd>temp</kbd> pointer reaches <kbd>NULL</kbd>, go to <em>step 6</em>.</li>
</ol>
<p class="mce-root"/>
<p>The program for creating a binary search tree and traversing it in postorder non-recursively is as follows:</p>
<pre>//<strong>postordernonrec.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#include &lt;stdlib.h&gt;<br/><br/>struct tree {<br/>  int data;<br/>  struct tree * right;<br/>  struct tree * left;<br/>};<br/><br/>struct stackstruc {<br/>  int valueArray[15];<br/>  struct tree * nodeArray[15];<br/>};<br/><br/>struct stackstruc stack;<br/>int top = -1;<br/><br/>struct tree * makeroot(int val);<br/>void rightchild(struct tree * rootNode, int val);<br/>void leftchild(struct tree * rootNode, int val);<br/>void nontravpost(struct tree * node);<br/>void pushNode(struct tree * node, int val);<br/>struct tree * popNode();<br/>int popVal();<br/><br/>int main() {<br/>  struct tree * temp, * rootNode;<br/>  int val;<br/>  printf("Enter elements of tree and 0 to quit\n");<br/>  scanf("%d", &amp; val);<br/>  rootNode = makeroot(val);<br/>  scanf("%d", &amp; val);<br/>  while (val != 0) {<br/>    temp = rootNode;<br/>    while (1) {<br/>      if (val &lt; temp - &gt; data) {<br/>        if (temp - &gt; left != NULL) {<br/>          temp = temp - &gt; left;<br/>          continue;<br/>        }<br/>        leftchild(temp, val);<br/>      }<br/>      if (val &gt; temp - &gt; data) {<br/>        if (temp - &gt; right != NULL) {<br/>          temp = temp - &gt; right;<br/>          continue;<br/>        }<br/>        rightchild(temp, val);<br/>      }<br/>      break;<br/>    }<br/>    scanf("%d", &amp; val);<br/>  }<br/>  printf("\nTraversal of tree in Postorder without using recursion: \n");<br/>  nontravpost(rootNode);<br/>}<br/><br/>struct tree * makeroot(int val) {<br/>  struct tree * rootNode;<br/>  rootNode = (struct tree * ) malloc(sizeof(struct tree));<br/>  rootNode - &gt; data = val;<br/>  rootNode - &gt; right = NULL;<br/>  rootNode - &gt; left = NULL;<br/>  return rootNode;<br/>}<br/><br/>void leftchild(struct tree * rootNode, int val) {<br/>  struct tree * newNode;<br/>  newNode = (struct tree * ) malloc(sizeof(struct tree));<br/>  newNode - &gt; data = val;<br/>  newNode - &gt; left = NULL;<br/>  newNode - &gt; right = NULL;<br/>  rootNode - &gt; left = newNode;<br/>}<br/><br/>void rightchild(struct tree * rootNode, int val) {<br/>  struct tree * newNode;<br/>  newNode = (struct tree * ) malloc(sizeof(struct tree));<br/>  newNode - &gt; data = val;<br/>  newNode - &gt; left = NULL;<br/>  newNode - &gt; right = NULL;<br/>  rootNode - &gt; right = newNode;<br/>}<br/><br/>void nontravpost(struct tree * node) {<br/>  struct tree * temp;<br/>  int val;<br/>  temp = node;<br/>  while (1) {<br/>    while (temp != NULL) {<br/>      pushNode(temp, 0);<br/>      temp = temp - &gt; left;<br/>    }<br/>    while (top &gt;= 0) {<br/>      temp = popNode();<br/>      val = popVal();<br/>      if (val == 0) {<br/>        if (temp - &gt; right != NULL) {<br/>          pushNode(temp, 1);<br/>          temp = temp - &gt; right;<br/>          break;<br/>        }<br/>      }<br/>      printf("%d\n", temp - &gt; data);<br/>      continue;<br/>    }<br/>    if ((temp == NULL) || (top &lt; 0)) break;<br/>    else continue;<br/>  }<br/>}<br/><br/>void pushNode(struct tree * node, int val) {<br/>  top++;<br/>  stack.nodeArray[top] = node;<br/>  stack.valueArray[top] = val;<br/>}<br/><br/>struct tree * popNode() {<br/>  return (stack.nodeArray[top]);<br/>}<br/><br/>int popVal() {<br/>  return (stack.valueArray[top--]);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes so that we can understand the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Postorder traversal requires the L, R, and V tasks to be applied to each node of the binary tree. Here, L means visiting the left child, R means visiting the right child, and V means visiting the node that is displaying its content.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The question is, how will we know which tasks have already been performed on a node and which tasks are left to be performed? To do so, we will use two arrays, <kbd>nodeArray</kbd> and <kbd>valueArray</kbd>. <kbd>nodeArray</kbd> contains the node that the tasks are to be performed one, while <kbd>valueArray</kbd> is used to indicate what task has been left on the corresponding node. <kbd>valueArray</kbd> can have one of the following two values:</p>
<ul>
<li><strong>Value 0</strong>: This indicates that the left link of the node has been traversed and that two tasks are pending: traversing the node being pointed to by its <kbd>right</kbd> pointer and visiting the node.</li>
<li><strong>Value 1</strong>: This indicates that the node being pointed to by its <kbd>right</kbd> pointer has been traversed. Only the task of visiting the node is pending.</li>
</ul>
<p>Once the binary search tree has been created, the <kbd>nontravpost</kbd> function is invoked for postorder traversal of the binary tree and the root node is passed to the function as an argument. The <kbd>nontravpost</kbd> function is a non-recursive function.</p>
<p>A temporary pointer, <kbd>temp</kbd>, is set to point at the root node. A <kbd>while</kbd> loop is set to execute until <kbd>temp</kbd> is not <kbd>NULL</kbd>. Within the <kbd>while</kbd> loop, the <kbd>pushNode</kbd> function is called and the node being pointed to by <kbd>temp</kbd> is passed to it, along with a value of 0.</p>
<p class="mce-root">In the <kbd>pushNode</kbd> function, the value of top that was initialized to -1 is incremented to 0 and the node, 40, and the value 0 are pushed into the <kbd>nodeArray</kbd> and <kbd>valueArray</kbd> arrays at index location being pointed to by <kbd>top</kbd> (the index location, 0):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a2cae85b-f46b-4551-a21f-aeb46c8eb57a.png" style="width:32.58em;height:11.25em;"/></p>
<p>The <kbd>pushNode</kbd> function ends and control jumps back to the <kbd>nontravpost</kbd> function, where the <kbd>temp</kbd> pointer is set to point at its left node. The <kbd>left</kbd> pointer of temp is pointing at node 20, so <kbd>temp</kbd> will now point at node 20. The <kbd>while</kbd> loop will keep executing until the <kbd>temp</kbd> pointer reaches the <kbd>NULL</kbd> pointer. Again, within the <kbd>while</kbd> loop, the <kbd>pushNode</kbd> function is called and node 20 and value 0 are passed to it. In the <kbd>pushNode</kbd> function, the value of the <kbd>top</kbd> pointer is incremented to 1 and node 20 and the value 0 are pushed to the <kbd>nodeArray[1]</kbd> and <kbd>valueArray[1]</kbd> array index locations, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a60b6d60-79e2-49ba-8277-250bc30a0843.png" style="width:33.08em;height:11.33em;"/></p>
<p>This process is repeated for the next node that's on the left of the <kbd>temp</kbd> node. On the left of node 20 is node 10. Upon pushing node 10, the <kbd>nodeArray</kbd> and <kbd>valueArray</kbd> arrays will look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5067f030-aaf3-48d4-bcf4-5502af649446.png" style="width:34.50em;height:11.83em;"/></p>
<p>Because temp has reached the <kbd>NULL</kbd> pointer, the first <kbd>while</kbd> loop will terminate and the next <kbd>while</kbd> loop will execute while the value of <kbd>top</kbd> is greater than or equal to 0. The <kbd>popNode</kbd> function is invoked, which returns the node in the <kbd>nodeArray</kbd> array that's being pointed at by the <kbd>top</kbd> index. The value of the <kbd>top</kbd> index is currently 2, so the node at the index location of <kbd>nodeArray[2]</kbd>, that is, 10, is accessed and returned to the <kbd>nontravpost</kbd> function. In the <kbd>nontravpost</kbd> function, node 10 will be assigned to the <kbd>temp</kbd> pointer. Next, the <kbd>popVal</kbd> function is invoked, which returns the value in the <kbd>valueArray</kbd> array that's being pointed to by the <kbd>top</kbd> index. This happens at the <kbd>valueArray[2]</kbd> index location. That is, the value 0 at the <kbd>valueArray[2]</kbd> index location is returned by the <kbd>popVal</kbd> function and is assigned to the <kbd>val</kbd> variable. The value of <kbd>top</kbd> is now decremented to 1. Because the value in the <kbd>val</kbd> variable is 0, an <kbd>if</kbd> block is executed in the <kbd>nontravpost</kbd> function. The <kbd>if</kbd> block checks whether the right child of the node being pointed at by the <kbd>temp</kbd> pointer isn't <kbd>NULL</kbd>; if so, the <kbd>pushNode</kbd> function is called and the node being pointed to by <kbd>temp</kbd>, that is, 10 and integer value 1, is passed to it as an argument.</p>
<p>In the <kbd>pushNode</kbd> function, the value of <kbd>top</kbd> is incremented to 2 and node 10 and the value 1 are pushed to the <kbd>nodeArray[2]</kbd> and <kbd>valueArray[2]</kbd> index locations, respectively:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/165fead0-b3a1-4ab1-a88b-e5dd8fc18503.png" style="width:31.58em;height:10.83em;"/></p>
<p>After executing the <kbd>pushNode</kbd> function, control jumps back to the <kbd>nontravpost</kbd> function, where the <kbd>temp</kbd> pointer is set to point to where its <kbd>right</kbd> pointer is pointing. But because the <kbd>right</kbd> pointer of <kbd>temp</kbd> is <kbd>NULL</kbd>, the <kbd>while</kbd> loop will break and the data member of the node being pointed to by <kbd>temp</kbd> (that is, 10) is displayed on the screen.</p>
<p>Again, the <kbd>while</kbd> loop will execute and the <kbd>popNode</kbd> and <kbd>popVal</kbd> functions will execute to pop node 20 and value 0, respectively. Node 20 will be pointed to by the <kbd>temp</kbd> pointer. Because the value that's being popped is 0, the right pointer of the node being pointed to by <kbd>temp</kbd> is searched. If the <kbd>right</kbd> pointer of node 20 is pointing at node 30, the <kbd>pushNode</kbd> function is invoked and node 20 is pushed, along with the value 1:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/56ae7b01-996a-44a8-83b4-8b051cf325f0.png" style="width:33.25em;height:11.42em;"/></p>
<p>Next, the <kbd>temp</kbd> pointer is set to point to where its <kbd>right</kbd> pointer is pointing, that is, node 30. The <kbd>pushNode</kbd> function is invoked and node 30 and an integer value of 0 are pushed to the <kbd>nodeArray</kbd> and <kbd>valueArray</kbd> arrays, respectively:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/83d145b5-6a46-444e-ac61-987a88be7791.png" style="width:28.92em;height:9.92em;"/></p>
<p>This procedure is repeated until the stacks are empty.</p>
<p>The program is compiled with GCC using the following statement:</p>
<pre><strong>D:\CAdvBook&gt;GCC postordernonrec.c - postordernonrec</strong></pre>
<p>If no error appears upon compilation, then the <kbd>postordernonrec.c</kbd> program has successfully compiled into the <kbd>postordernonrec.exe</kbd> file. Let's run this file and enter some new elements that will build a binary tree and get its postorder traversal using a non-recursive approach. By doing this, we will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b53423cb-9e80-40ed-a30b-a155df9939bf.png" style="width:30.42em;height:25.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>To learn how to implement queues and circular queues using arrays and dequeues using circular queues, visit <em>Appendix B</em> found on this link: <a href="https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf">https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf</a>.</p>


            

            
        
    </body></html>