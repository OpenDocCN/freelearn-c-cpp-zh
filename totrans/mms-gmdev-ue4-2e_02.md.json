["```cpp\npublic:\n        AMasteringWeapon();\n\n        /** Gun muzzle's offset from the characters location */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\n        FVector GunOffset = FVector(100.0f, 0.0f, 10.0f);\n\n        /** Projectile class to spawn */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Projectile)\n        TSubclassOf<class AMasteringProjectile> ProjectileClass;\n\n        /** Sound to play each time we fire */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\n        class USoundBase* FireSound;\n\n        /** AnimMontage to play each time we fire */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\n        class UAnimMontage* FireAnimation;\n```", "```cpp\n/** Muzzle offset */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Projectile)\nclass USceneComponent* MuzzleLocation;\n```", "```cpp\nFVector GunOffset = FVector(100.0f, 0.0f, 10.0f);\n```", "```cpp\n#include \"MasteringProjectile.h\"\n```", "```cpp\n#include \"Runtime/Engine/Classes/Components/SkeletalMeshComponent.h\"\n#include \"Runtime/Engine/Classes/Animation/AnimInstance.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAMasteringWeapon::AMasteringWeapon()\n{\n        // Create a gun mesh component\n        WeaponMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"WeaponMesh\"));\n        WeaponMesh->SetOnlyOwnerSee(true); // only the owning player will see this mesh\n        WeaponMesh->bCastDynamicShadow = false;\n        WeaponMesh->CastShadow = false;\n        WeaponMesh->SetupAttachment(RootComponent);\n\n        // Our muzzle offset object\n        MuzzleLocation = CreateDefaultSubobject<USceneComponent>(TEXT(\"MuzzleLocation\"));\n        MuzzleLocation->SetupAttachment(WeaponMesh);\n}\n```", "```cpp\npublic:  \n        // Called every frame\n        virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n```", "```cpp\nprotected:\n        // Called when the game starts\n        virtual void BeginPlay() override;\n\npublic:\n        UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        TSubclassOf<class AMasteringWeapon> DefaultWeapon;\n\n        /** Choose the best weapon we can of those available */\n        void SelectBestWeapon(class AMasteringCharacter *Player);\n\n        /** Select a weapon from inventory */\n        void SelectWeapon(class AMasteringCharacter *Player, TSubclassOf<class AMasteringWeapon> Weapon);\n\n        /** Add a weapon to the inventory list */\n        void AddWeapon(TSubclassOf<class AMasteringWeapon> Weapon);\n\n        /** Add any default weapon we may have been set with */\n        void AddDefaultWeapon();\n\n        /** Get the currently selected weapon */\n        FORCEINLINE TSubclassOf<class AMasteringWeapon> GetCurrentWeapon() const { return CurrentWeapon; }\n\nprotected:\n        TArray<TSubclassOf<class AMasteringWeapon> > WeaponsArray;\n        TSubclassOf<class AMasteringWeapon> CurrentWeapon;\n```", "```cpp\n#include \"MasteringCharacter.h\"\n\n// Sets default values for this component's properties\nUMasteringInventory::UMasteringInventory()\n{\n        PrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UMasteringInventory::BeginPlay()\n{\n        Super::BeginPlay();\n\n        if (DefaultWeapon != nullptr)\n        {\n                AddWeapon(DefaultWeapon);\n        }\n}\n\nvoid UMasteringInventory::SelectBestWeapon(class AMasteringCharacter *Player)\n{\n        for (auto WeaponIt = WeaponsArray.CreateIterator(); WeaponIt; ++WeaponIt)\n        {\n                //TODO: add criteria for selecting a weapon\n                {\n                        SelectWeapon(Player, *WeaponIt);\n                        break;\n                }\n        }\n}\n\nvoid UMasteringInventory::SelectWeapon(class AMasteringCharacter *Player, TSubclassOf<class AMasteringWeapon> Weapon)\n{\n        Player->EquipWeapon(Weapon);\n}\n\nvoid UMasteringInventory::AddWeapon(TSubclassOf<class AMasteringWeapon> Weapon)\n{\n        WeaponsArray.AddUnique(Weapon);\n}\n```", "```cpp\nuint32 bUsingMotionControllers : 1;\n\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\nclass UMasteringInventory *Inventory;\n\nclass AMasteringWeapon* EquippedWeaponActor;\n\nFORCEINLINE class UCameraComponent* GetFirstPersonCameraComponent() const { return FirstPersonCameraComponent; }\nFORCEINLINE class UCameraComponent* GetFirstPersonCameraComponent() const { return FirstPersonCameraComponent; }\n\n/** Equip a weapon */\nvoid EquipWeapon(TSubclassOf<class AMasteringWeapon> Weapon);\n\n/** Get the currently equipped weapon */\nFORCEINLINE class AMasteringWeapon* GetEquippedWeapon() const { return EquippedWeaponActor; };\n```", "```cpp\n#include \"XRMotionControllerBase.h\" // for FXRMotionControllerBase::RightHandSourceId\n#include \"MasteringInventory.h\"\n#include \"MasteringWeapon.h\"\n```", "```cpp\nInventory = CreateDefaultSubobject<UMasteringInventory>(TEXT(\"Inventory\"));\n```", "```cpp\nvoid AMasteringCharacter::BeginPlay()\n{\n        // Call the base class  \n        Super::BeginPlay();\n\n        // Equip our best weapon on startup\n        if (Inventory != nullptr)\n        {\n                Inventory->SelectBestWeapon(this);\n        }\n}\n```", "```cpp\nvoid AMasteringCharacter::OnFire()\n{\n        // try and fire a projectile\n        if (GetEquippedWeapon() != nullptr)\n        {\n                UAnimInstance* AnimInstance = Mesh1P->GetAnimInstance();\n                GetEquippedWeapon()->Fire(GetControlRotation(), AnimInstance);\n        }\n}\n```", "```cpp\nvoid AMasteringCharacter::EquipWeapon(TSubclassOf<class AMasteringWeapon> Weapon)\n{\n        UWorld *World = GetWorld();\n        if (World == nullptr)\n                return;\n\n        if (EquippedWeaponActor != nullptr)\n        {\n                World->DestroyActor(EquippedWeaponActor);\n        }\n\n        const FRotator SpawnRotation = GetActorRotation();\n        const FVector SpawnLocation = GetActorLocation();\n        FActorSpawnParameters ActorSpawnParams;\n        ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n        ActorSpawnParams.Owner = this;\n\n        EquippedWeaponActor = Cast<AMasteringWeapon>(World->SpawnActor(Weapon, &SpawnLocation, &SpawnRotation, ActorSpawnParams));\n        if (EquippedWeaponActor != nullptr)\n        {\n                //Attach gun mesh component to skeleton\n                EquippedWeaponActor->AttachToComponent(Mesh1P, FAttachmentTransformRules(EAttachmentRule::SnapToTarget, true), TEXT(\"GripPoint\"));\n        }\n}\n```", "```cpp\npublic:\n        /** Fire the weapon */\n        void Fire(FRotator ControlRotation, class UAnimInstance* AnimInst);\n```", "```cpp\nvoid AMasteringWeapon::Fire(FRotator ControlRotation, class UAnimInstance* AnimInst)\n{\n        // try and fire a projectile\n        if (ProjectileClass != nullptr)\n        {\n                UWorld* const World = GetWorld();\n                if (World != nullptr)\n                {\n                        // MuzzleOffset is in camera space, so transform it to world space before offsetting from the character location to find the final muzzle position\n                        const FVector SpawnLocation = ((MuzzleLocation != nullptr) ? MuzzleLocation->GetComponentLocation() : GetActorLocation()) + ControlRotation.RotateVector(GunOffset);\n\n                        //Set Spawn Collision Handling Override\n                        FActorSpawnParameters ActorSpawnParams;\n                        ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;\n\n                        // spawn the projectile at the muzzle\n                        World->SpawnActor<AMasteringProjectile>(ProjectileClass, SpawnLocation, ControlRotation, ActorSpawnParams);\n                }\n        }\n\n        // try and play the sound if specified\n        if (FireSound != nullptr)\n        {\n                UGameplayStatics::PlaySoundAtLocation(this, FireSound, GetActorLocation());\n        }\n\n        // try and play a firing animation if specified\n        if (FireAnimation != nullptr)\n        {\n                // Get the animation object for the arms mesh\n                if (AnimInst != nullptr)\n                {\n                        AnimInst->Montage_Play(FireAnimation, 1.f);\n                }\n        }\n}\n```", "```cpp\npublic:  \n        // Sets default values for this actor's properties\n        AMasteringWeaponPickup();\n\nprotected:\n        // Called when the game starts or when spawned\n        virtual void BeginPlay() override;\n\n        virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;\n\npublic:       \n        // Called every frame\n        virtual void Tick(float DeltaTime) override;\n\n        UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        TSubclassOf<class AMasteringWeapon> WeaponClass;\n\n        /** How fast the pickup spins while on the ground, degress/second */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\n        float RotationSpeed = 30.0f;\n\n        /** How much ammunition is provided for this weapon on pick-up */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\n        uint8 Ammunition = 10;\n\n        /** This weapon's relative weapon power to compare it to others */\n        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)\n        uint8 WeaponPower = 1;\n```", "```cpp\n#include \"MasteringCharacter.h\"\n#include \"MasteringInventory.h\"\n\n// Sets default values\nAMasteringWeaponPickup::AMasteringWeaponPickup()\n{\n   // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n        PrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMasteringWeaponPickup::BeginPlay()\n{\n        Super::BeginPlay();\n\n}\n\nvoid AMasteringWeaponPickup::NotifyActorBeginOverlap(AActor* OtherActor)\n{\n        AMasteringCharacter *player = Cast<AMasteringCharacter>(OtherActor);\n\n        if (player == nullptr)\n        {\n                return;\n        }\n\n        UMasteringInventory *Inventory = player->GetInventory();\n\n        Inventory->AddWeapon(WeaponClass, Ammunition, WeaponPower);\n\n        // here we automatically select the best weapon which may have changed after adding the above,\n        // NOTE: this should probably be an option the player can turn on and off via UI\n        Inventory->SelectBestWeapon();\n\n        // and now that we've done our job, destroy ourselves\n        Destroy();\n}\n\n// Called every frame\nvoid AMasteringWeaponPickup::Tick(float DeltaTime)\n{\n        Super::Tick(DeltaTime);\n\n        FRotator rotationAmount(0.0f, DeltaTime * RotationSpeed, 0.0f);\n\n        AddActorLocalRotation(rotationAmount);\n}\n```", "```cpp\nUSTRUCT()\nstruct FWeaponProperties\n{\n        GENERATED_USTRUCT_BODY()\n\npublic:\n\n        UPROPERTY()\n        TSubclassOf<class AMasteringWeapon> WeaponClass;\n\n        UPROPERTY()\n        int WeaponPower;\n\n        UPROPERTY()\n        int Ammo;\n};\n```", "```cpp\n   /** Choose the best weapon we can of those available */\n        void SelectBestWeapon();\n\n        /** Select a weapon from inventory */\n        void SelectWeapon(TSubclassOf<class AMasteringWeapon> Weapon);\n\n        /** Add a weapon to the inventory list */\n        void AddWeapon(TSubclassOf<class AMasteringWeapon> Weapon, int AmmoCount, uint8 WeaponPower);\n\n        /** Get the currently selected weapon */\n        FORCEINLINE TSubclassOf<class AMasteringWeapon> GetCurrentWeapon() const { return CurrentWeapon; }\n\n        /** Change a weapon's ammo count, can't go below 0 or over 999 */\n        void ChangeAmmo(TSubclassOf<class AMasteringWeapon> Weapon, const int ChangeAmount);\n\nprotected:\n        TArray<FWeaponProperties> WeaponsArray;\n        TSubclassOf<class AMasteringWeapon> CurrentWeapon;\n        int CurrentWeaponPower = -1;\n        class AMasteringCharacter* MyOwner;\n```", "```cpp\n#define UNLIMITED_AMMO -1\n\n// Sets default values for this component's properties\nUMasteringInventory::UMasteringInventory()\n{\n        PrimaryComponentTick.bCanEverTick = true;\n\n        MyOwner = Cast<AMasteringCharacter>(GetOwner());\n        check(GetOwner() == nullptr || MyOwner != nullptr);\n}\n\n// Called when the game starts\nvoid UMasteringInventory::BeginPlay()\n{\n        Super::BeginPlay();\n\n        if (DefaultWeapon != nullptr)\n        {\n                // NOTE: since we don't use a pick-up for the default weapon, we always give it a power of 0\n                AddWeapon(DefaultWeapon, UNLIMITED_AMMO, 0);\n        }\n}\n```", "```cpp\nvoid UMasteringInventory::SelectWeapon(TSubclassOf<class AMasteringWeapon> Weapon)\n{\n        MyOwner->EquipWeapon(Weapon);\n}\n\nvoid UMasteringInventory::AddWeapon(TSubclassOf<class AMasteringWeapon> Weapon, int AmmoCount, uint8 WeaponPower)\n{\n        for (auto WeaponIt = WeaponsArray.CreateIterator(); WeaponIt; ++WeaponIt)\n        {\n                FWeaponProperties &currentProps = *WeaponIt;\n                if (currentProps.WeaponClass == Weapon)\n                {\n                        checkSlow(AmmoCount >= 0);\n                        currentProps.Ammo += AmmoCount;\n                        return; // our work is done if we found the gun already in inventory, just update ammo\n                }\n        }\n\n        FWeaponProperties weaponProps;\n        weaponProps.WeaponClass = Weapon;\n        weaponProps.WeaponPower = WeaponPower;\n        weaponProps.Ammo = AmmoCount;\n\n        WeaponsArray.Add(weaponProps);\n}\n\nvoid UMasteringInventory::ChangeAmmo(TSubclassOf<class AMasteringWeapon> Weapon, const int ChangeAmount)\n{\n        for (auto WeaponIt = WeaponsArray.CreateIterator(); WeaponIt; ++WeaponIt)\n        {\n                FWeaponProperties &currentProps = *WeaponIt;\n                if (currentProps.WeaponClass == Weapon)\n                {\n                        if (currentProps.Ammo == UNLIMITED_AMMO) // unlimited ammo gun, we're done\n                                return;\n\n                        currentProps.Ammo = FMath::Clamp(currentProps.Ammo + ChangeAmount, 0, 999);\n                        if (currentProps.Ammo == 0) // gun is now empty!\n                        {\n                                CurrentWeaponPower = -1; // force us to select any better weapon that does have ammo\n                                SelectBestWeapon();\n                        }\n                        return; // our work is done if we found the gun already in inventory, just update ammo\n                }\n        }\n}\n```", "```cpp\nvoid Fire(FRotator ControlRotation, class UAnimInstance* AnimInst, class UMasteringInventory* Inventory);\n```", "```cpp\n// reduce ammo by one\nInventory->ChangeAmmo(GetClass(), -1);\n```", "```cpp\nint UMasteringInventory::FindCurrentWeaponIndex() const\n{\n        int currentIndex = 0;\n        for (auto WeaponIt = WeaponsArray.CreateConstIterator(); WeaponIt; ++WeaponIt, ++currentIndex)\n        {\n                const FWeaponProperties &currentProps = *WeaponIt;\n                if (currentProps.WeaponClass == CurrentWeapon)\n                        break;\n        }\n\n        checkSlow(currentIndex < WeaponsArray.Num());\n\n        return currentIndex;\n}\n\nvoid UMasteringInventory::SelectNextWeapon()\n{\n        int currentIndex = FindCurrentWeaponIndex();\n\n        if (currentIndex == WeaponsArray.Num() - 1) // we're at the end\n        {\n                SelectWeapon(WeaponsArray[0].WeaponClass);\n        }\n        else\n        {\n                SelectWeapon(WeaponsArray[currentIndex + 1].WeaponClass);\n        }\n}\n\nvoid UMasteringInventory::SelectPreviousWeapon()\n{\n        int currentIndex = FindCurrentWeaponIndex();\n\n        if (currentIndex > 0) // we're not at the start\n        {\n                SelectWeapon(WeaponsArray[currentIndex - 1].WeaponClass);\n        }\n        else\n        {\n                SelectWeapon(WeaponsArray[WeaponsArray.Num() - 1].WeaponClass); // select the last\n        }\n}\n```", "```cpp\n// Cycling inventory\nPlayerInputComponent->BindAction(\"InventoryUp\", IE_Pressed, this, &AMasteringCharacter::SelectNextWeapon);\nPlayerInputComponent->BindAction(\"InventoryDown\", IE_Pressed, this, &AMasteringCharacter::SelectPreviousWeapon);\n```", "```cpp\nvoid AMasteringCharacter::SelectNextWeapon()\n{\n        Inventory->SelectNextWeapon();\n}\n\nvoid AMasteringCharacter::SelectPreviousWeapon()\n{\n        Inventory->SelectPreviousWeapon();\n}\n```", "```cpp\nvoid UMasteringInventory::SelectWeapon(TSubclassOf<class AMasteringWeapon> Weapon)\n{\n        MyOwner->EquipWeapon(Weapon);\n        CurrentWeapon = Weapon;\n}\n```"]