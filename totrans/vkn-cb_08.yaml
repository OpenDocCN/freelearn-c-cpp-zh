- en: Graphics and Compute Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形和计算管道
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a shader module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建着色器模块
- en: Specifying pipeline shader stages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道着色器阶段
- en: Specifying a pipeline vertex binding description, attribute description, and
    input state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道顶点绑定描述、属性描述和输入状态
- en: Specifying a pipeline input assembly state
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道输入装配状态
- en: Specifying a pipeline tessellation state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道细分状态
- en: Specifying a pipeline viewport and scissor test state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道视口和剪裁测试状态
- en: Specifying a pipeline rasterization state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道光栅化状态
- en: Specifying a pipeline multisample state
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道多重采样状态
- en: Specifying a pipeline depth and stencil state
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道深度和模板状态
- en: Specifying a pipeline blend state
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道混合状态
- en: Specifying pipeline dynamic states
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定管道动态状态
- en: Creating a pipeline layout
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建管道布局
- en: Specifying graphics pipeline creation parameters
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定图形管道创建参数
- en: Creating a pipeline cache object
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建管道缓存对象
- en: Retrieving data from a pipeline cache
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从管道缓存中检索数据
- en: Merging multiple pipeline cache objects
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并多个管道缓存对象
- en: Creating a graphics pipeline
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图形管道
- en: Creating a compute pipeline
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计算管道
- en: Binding a pipeline object
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定管道对象
- en: Creating a pipeline layout with a combined image sampler, a buffer, and push
    constant ranges
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含组合图像采样器、缓冲区和推送常量范围的管道布局
- en: Creating a graphics pipeline with vertex and fragment shaders, depth test enabled,
    and with dynamic viewport and scissor tests
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有顶点和片段着色器、启用深度测试以及具有动态视口和剪裁测试的图形管道
- en: Creating multiple graphics pipelines on multiple threads
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个线程上创建多个图形管道
- en: Destroying a pipeline
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁管道
- en: Destroying a pipeline cache
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁管道缓存
- en: Destroying a pipeline layout
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁管道布局
- en: Destroying a shader module
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁着色器模块
- en: Introduction
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Operations recorded in command buffers and submitted to queues are processed
    by the hardware. Processing is performed in a series of steps that form a pipeline.
    When we want to perform mathematical calculations, we use a compute pipeline.
    If we want to draw anything, we need a graphics pipeline.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在命令缓冲区中并提交到队列中的操作由硬件处理。处理是通过一系列步骤进行的，这些步骤形成一个管道。当我们想要执行数学计算时，我们使用计算管道。如果我们想要绘制任何东西，我们需要一个图形管道。
- en: Pipeline objects control the way in which geometry is drawn or computations
    are performed. They manage the behavior of the hardware on which our application
    is executed. And they are one of the biggest and most apparent differences between
    Vulkan and OpenGL. OpenGL used a state machine. It allowed us to change many rendering
    or computing parameters whenever we wanted. We could set up the state, activate
    a shader program, draw a geometry, then activate another shader program and draw
    another geometry. In Vulkan it is not possible because the whole rendering or
    computing state is stored in a single, monolithical object. When we want to use
    a different set of shaders, we need to prepare and use a separate pipeline. We
    can't just switch shaders.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 管道对象控制几何图形的绘制方式或计算执行。它们管理应用程序执行的硬件的行为。它们是 Vulkan 和 OpenGL 之间最大的、最明显的差异之一。OpenGL
    使用状态机。它允许我们在任何时候更改许多渲染或计算参数。我们可以设置状态，激活着色器程序，绘制几何图形，然后激活另一个着色器程序并绘制另一个几何图形。在 Vulkan
    中，这是不可能的，因为整个渲染或计算状态都存储在单个、统一的对象中。当我们想要使用不同的着色器集时，我们需要准备并使用一个单独的管道。我们无法简单地切换着色器。
- en: This may be intimidating at first because many shader variations (not including
    the rest of the pipeline state) cause us to create multiple pipeline objects.
    But it serves two important goals. The first is the performance. Drivers that
    know the whole state in advance may optimize execution of the following operations.
    The second goal is the stability of the performance. Changing the state whenever
    we want may cause the driver to perform additional operations, such as shader
    recompilation, in unexpected and unpredictable moments. In Vulkan, all the required
    preparations, including shader compilation, are done only during the pipeline
    creation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始会让人感到害怕，因为许多着色器变体（不包括管道状态的其他部分）导致我们创建多个管道对象。但这服务于两个重要的目标。第一个是性能。知道整个状态的驱动程序可能会优化后续操作的执行。第二个目标是性能的稳定性。随时更改状态可能会导致驱动程序在意外和不可预测的时刻执行额外的操作，例如着色器重新编译。在
    Vulkan 中，所有必要的准备，包括着色器编译，都是在管道创建期间完成的。
- en: In this chapter, we will see how to set up all of the graphics or compute pipelines
    parameters to successfully create them. We will see how to prepare shader modules
    and define which shader stages are active, how to set up depth or stencil tests
    and how to enable blending. We will also specify what vertex attributes are used
    and how they are provided during drawing operations. Finally, we will see how
    to create multiple pipelines and how to improve the speed of their creation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何设置所有图形或计算管道参数以成功创建它们。我们将了解如何准备着色器模块并定义哪些着色器阶段是活动的，如何设置深度或模板测试以及如何启用混合。我们还将指定在绘制操作期间使用的顶点属性以及它们是如何提供的。最后，我们将了解如何创建多个管道以及如何提高它们创建的速度。
- en: Creating a shader module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建着色器模块
- en: The first step in creating a pipeline object is to prepare shader modules. They
    represent shaders and contain their code written in a SPIR-V assembly. A single
    module may contain code for multiple shader stages. When we write shader programs
    and convert them into SPIR-V form, we need to create a shader module (or multiple
    modules) before we can use shaders in our application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建管道对象的第一步是准备着色器模块。它们代表着色器并包含用SPIR-V汇编编写的代码。单个模块可能包含多个着色器阶段的代码。当我们编写着色器程序并将它们转换为SPIR-V形式时，在我们可以在我们应用程序中使用着色器之前，我们需要创建一个着色器模块（或多个模块）。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a logical device stored in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取名为`logical_device`的`VkDevice`类型变量的逻辑设备的句柄。
- en: Load a binary SPIR-V assembly of a selected shader and store it in a variable
    of type `std::vector<unsigned char>` named `source_code`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载一个选定的着色器的二进制SPIR-V汇编并将其存储在一个名为`source_code`的类型为`std::vector<unsigned char>`的变量中。
- en: 'Create a variable of type `VkShaderModuleCreateInfo` named `shader_module_create_info`.
    Use the following values to initialize its members:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`shader_module_create_info`的`VkShaderModuleCreateInfo`类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO` value for `sType`.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO`值用于`sType`。'
- en: '`nullptr` value for `pNext`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值'
- en: '`0` value for `flags`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的`0`值'
- en: The number of elements in the `source_code` vector (size in bytes) for `codeSize`
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source_code`向量中元素的数量（以字节为单位）用于`codeSize`'
- en: A pointer to the first element of the `source_code` variable for `pCode`
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向`source_code`变量第一个元素的指针用于`pCode`
- en: Create a variable of type `VkShaderModule` named `shader_module` in which the
    handle of a created shader module will be stored.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`shader_module`的`VkShaderModule`类型的变量，其中将存储创建的着色器模块的句柄。
- en: Make the `vkCreateShaderModule( logical_device, &shader_module_create_info,
    nullptr, &shader_module )` function call for which provide the `logical_device`
    variable, a pointer to the `shader_module_create_info`, a `nullptr` value, and
    a pointer to the `shader_module` variable.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行`vkCreateShaderModule(logical_device, &shader_module_create_info, nullptr,
    &shader_module)`函数调用，其中提供`logical_device`变量、指向`shader_module_create_info`的指针、`nullptr`值和指向`shader_module`变量的指针。
- en: Make sure the `vkCreateShaderModule()` function call returned a `VK_SUCCESS`
    value which indicates that the shader module was properly created.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用`vkCreateShaderModule()`函数返回了`VK_SUCCESS`值，这表示着色器模块已正确创建。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Shader modules contain source code--a single SPIR-V assembly--of selected shader
    programs. It may represent multiple shader stages but a separate entry point must
    be associated with each stage. This entry point is then provided as one of the
    parameters when we create a pipeline object (refer to the *Specifying pipeline
    shader stages* recipe).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器模块包含选定的着色器程序的源代码——一个单独的SPIR-V汇编。它可能代表多个着色器阶段，但每个阶段必须关联一个单独的入口点。这个入口点随后作为创建管道对象时的一个参数提供（参考*指定管道着色器阶段*配方）。
- en: 'When we want to create a shader module, we need to load a file with the binary
    SPIR-V code or acquire it in any other way. Then we provide it to a variable of
    type `VkShaderModuleCreateInfo` like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建一个着色器模块时，我们需要加载一个包含二进制SPIR-V代码的文件或以任何其他方式获取它。然后我们像这样将其提供给一个类型为`VkShaderModuleCreateInfo`的变量：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, the pointer to such a variable is provided to the `vkCreateShaderModule()`
    function, which creates a module:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将此类变量的指针提供给`vkCreateShaderModule()`函数，该函数创建一个模块：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We just need to remember that shaders are not compiled when we create a shader
    module; this is done when we create a pipeline object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需记住，当我们创建着色器模块时，着色器不会被编译；这是在创建管道对象时完成的。
- en: Shader compilation and linkage is performed during the pipeline object creation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器编译和链接是在创建管道对象期间执行的。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying pipeline shader stages*'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线着色阶段*'
- en: '*Creating a graphics pipeline*'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: '*Destroying a shader module*'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁着色器模块*'
- en: Specifying pipeline shader stages
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线着色阶段
- en: In compute pipelines, we can use only compute shaders. But graphics pipelines
    may contain multiple shader stages--vertex (which is obligatory), geometry, tessellation
    control and evaluation, and fragment. So for the pipeline to be properly created,
    we need to specify what programmable shader stages will be active when a given
    pipeline is bound to a command buffer. And we also need to provide a source code
    for all the enabled shaders.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算管线中，我们只能使用计算着色器。但图形管线可能包含多个着色阶段--顶点（这是必需的）、几何、细分控制与评估以及片段。因此，为了正确创建管线，我们需要指定在给定的管线绑定到命令缓冲区时将激活哪些可编程着色阶段。我们还需要提供所有启用着色器的源代码。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To simplify the recipe and lower the number of parameters needed to prepare
    descriptions of all enabled shader stages, a custom `ShaderStageParameters` type
    is introduced. It has the following definition:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化配方并减少准备所有启用着色阶段描述所需的参数数量，引入了一个自定义的 `ShaderStageParameters` 类型。它具有以下定义：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding structure, `ShaderStage` defines a single pipeline stage for
    which the rest of the parameters are specified. `ShaderModule` is a module from
    which a SPIR-V source code for the given stage can be taken, associated with a
    function whose name is provided in the `EntryPointName` member. The `SpecializationInfo`
    parameter is a pointer to a variable of type `VkSpecializationInfo`. It allows
    values of the constant variables defined in the shader source code to be modified
    at runtime, during pipeline creation. But if we don't want to specify constant
    values, we can provide a `nullptr` value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，`ShaderStage` 定义了一个单独的管线阶段，其余参数在此指定。`ShaderModule` 是一个模块，可以从其中获取给定阶段的
    SPIR-V 源代码，与在 `EntryPointName` 成员中提供的名称关联的函数相关。`SpecializationInfo` 参数是指向类型为 `VkSpecializationInfo`
    的变量的指针。它允许在管线创建期间运行时修改在着色器源代码中定义的常量变量的值。但如果我们不想指定常量值，我们可以提供一个 `nullptr` 值。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a shader module or modules containing source code for each shader stage
    that will be active in a given pipeline (refer to the *Creating a shader module*
    recipe).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个或多个着色器模块，其中包含将在给定管线中激活的每个着色阶段的源代码（参考 *创建着色器模块* 配方）。
- en: Create a `std::vector` variable named `shader_stage_create_infos` with elements
    of type `VkPipelineShaderStageCreateInfo`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `shader_stage_create_infos` 的 `std::vector` 变量，其元素类型为 `VkPipelineShaderStageCreateInfo`。
- en: 'For each shader stage that should be enabled in a given pipeline, add an element
    to the `shader_stage_create_infos` vector and use the following values to initialize
    its members:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在给定管线中应启用的每个着色阶段，向 `shader_stage_create_infos` 向量中添加一个元素，并使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO` value for `sType`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO` 的 `sType` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: '`0` value for `flags`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值'
- en: The selected shader stage for `stage`
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `stage` 选定的着色阶段
- en: The shader module with a source code of a given shader stage for `module`
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `module`，包含给定着色阶段源代码的着色器模块
- en: The name of the function that implements the given shader in the shader module
    (usually `main`) for `pName`
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在着色器模块中实现给定着色器的函数名称（通常是 `main`）对于 `pName`
- en: A pointer to a variable of type `VkSpecializationInfo` with a constant value
    specialization or a `nullptr` value if no specialization is required for `pSpecializationInfo`
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向类型为 `VkSpecializationInfo` 的变量的指针，具有常量值特殊化或如果不需要 `pSpecializationInfo` 的特殊化，则为
    `nullptr` 值
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Defining a set of shader stages that will be active in a given pipeline requires
    us to prepare an array (or a vector) variable with elements of type `VkPipelineShaderStageCreateInfo`.
    Each shader stage requires a separate entry in which we need to specify a shader
    module and the name of the entry point that implements the behavior of a given
    shader in the provided module. We can also provide a pointer to the specialization
    info which allows us to modify values of shader constant variables during the
    pipeline creation (at runtime). This allows us to use the same shader code multiple
    times with slight variations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在给定管线中激活的一组着色器阶段需要我们准备一个包含类型为`VkPipelineShaderStageCreateInfo`的元素数组（或向量）。每个着色器阶段需要一个单独的条目，在其中我们需要指定一个着色器模块和实现给定模块中着色器行为的入口点的名称。我们还可以提供一个指向特殊化信息的指针，这允许我们在管线创建期间（在运行时）修改着色器常量变量的值。这允许我们多次使用相同的着色器代码，并略有变化。
- en: Specifying pipeline shader stages info is obligatory for both graphics and compute
    pipelines.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 指定管线着色器阶段信息对于图形和计算管线都是强制性的。
- en: 'Let''s imagine we want to use only vertex and fragment shaders. We can prepare
    a vector with elements of a custom `ShaderStageParameters` type like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们只想使用顶点和片段着色器。我们可以准备一个包含自定义`ShaderStageParameters`类型元素的向量，如下所示：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The implementation of the preceding recipe, which uses the data from the aforementioned
    vector, may look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述食谱的实现，它使用上述向量中的数据，可能看起来像这样：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each shader stage provided in the array must be unique.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中提供的每个着色器阶段必须是唯一的。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a shader module*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a graphics pipeline*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: Specifying a pipeline vertex binding description, attribute description, and
    input state
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线顶点绑定描述、属性描述和输入状态
- en: When we want to draw a geometry, we prepare vertices along with their additional
    attributes like normal vectors, colors, or texture coordinates. Such vertex data
    is chosen arbitrarily by us, so for the hardware to properly use them, we need
    to specify how many attributes there are, how are they laid out in memory, or
    where are they taken from. This information is provided through the vertex binding
    description and attribute description required to create a graphics pipeline.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要绘制几何图形时，我们准备顶点以及它们额外的属性，如法向量、颜色或纹理坐标。这样的顶点数据是我们任意选择的，因此为了硬件能够正确使用它们，我们需要指定有多少属性，它们在内存中的布局方式，或者它们从哪里获取。这些信息通过创建图形管线所需的顶点绑定描述和属性描述提供。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a `std::vector` variable named `binding_descriptions` with elements of
    type `VkVertexInputBindingDescription`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`binding_descriptions`的`std::vector`变量，其元素类型为`VkVertexInputBindingDescription`。
- en: 'Add a separate entry to the `binding_descriptions` vector for each vertex binding
    (part of a buffer bound to a command buffer as a vertex buffer) used in a given
    pipeline. Use the following values to initialize its members:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的管线中使用每个顶点绑定（作为顶点缓冲区绑定到命令缓冲区的缓冲区的一部分）为`binding_descriptions`向量添加一个单独的条目。使用以下值来初始化其成员：
- en: The index of a binding (number which it represents) for `binding`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于`binding`的绑定索引（它所代表的数字）
- en: The number of bytes between two consecutive elements in a buffer for `stride`
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区中连续元素之间的字节数用于`stride`
- en: Parameters indicating whether values of attributes read from a given binding
    should advance per vertex (`VK_VERTEX_INPUT_RATE_VERTEX`) or per instance (`VK_VERTEX_INPUT_RATE_INSTANCE`)
    for `inputRate`
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示从给定绑定读取的属性值是否应按顶点（`VK_VERTEX_INPUT_RATE_VERTEX`）或按实例（`VK_VERTEX_INPUT_RATE_INSTANCE`）递增的参数用于`inputRate`
- en: Create a `std::vector` variable named `attribute_descriptions` with elements
    of type `VkVertexInputAttributeDescription`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`attribute_descriptions`的`std::vector`变量，其元素类型为`VkVertexInputAttributeDescription`。
- en: 'Add a separate entry to the `attribute_descriptions` vector variable for each
    attribute provided to a vertex shader in a given graphics pipeline. Use the following
    values to initialize its members:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的图形管线中，为每个提供给顶点着色器的属性在`attribute_descriptions`向量变量中添加一个单独的条目。使用以下值来初始化其成员：
- en: The shader location through which a given attribute is read in a vertex shader
    for `location`
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在顶点着色器中读取给定属性的着色器位置用于`location`
- en: The index of a binding to which a vertex buffer with the source of this attribute's
    data will be bound for `binding`
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将包含此属性数据源的顶点缓冲区绑定到绑定索引的绑定用于`binding`
- en: The format of an attribute's data for `format`
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 中属性数据的格式'
- en: The memory offset from the beginning of a given element in the binding for `offset`
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从绑定开始到给定元素的内存偏移量用于 `offset`
- en: 'Create a variable of type `VkPipelineVertexInputStateCreateInfo` named `vertex_input_state_create_info`.
    Use the following values to initialize its members:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vertex_input_state_create_info` 的 `VkPipelineVertexInputStateCreateInfo`
    类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO` value for `sType`'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType` 的 `VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: '`0` value for `flags`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值'
- en: The number of elements in the `binding_descriptions` vector for `vertexBindingDescriptionCount`
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding_descriptions` 向量的元素数量用于 `vertexBindingDescriptionCount`'
- en: A pointer to the first element of the `binding_descriptions` vector for `pVertexBindingDescriptions`
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding_descriptions` 向量第一个元素的指针用于 `pVertexBindingDescriptions`'
- en: The number of elements in the `attribute_descriptions` vector for `vertexAttributeDescriptionCount`
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexAttributeDescriptionCount` 中 `attribute_descriptions` 向量的元素数量'
- en: A pointer to the first element of the `attribute_descriptions` vector for `pVertexAttributeDescriptions`
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_descriptions` 向量第一个元素的指针用于 `pVertexAttributeDescriptions`'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Vertex binding defines a collection of data taken from a vertex buffer bound
    to a selected index. This binding is used as a numbered source of data for vertex
    attributes. We can use at least 16 separate bindings to which we can bind separate
    vertex buffers or different parts of memory of the same buffer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点绑定定义了一个从绑定到选定索引的顶点缓冲区中取出的数据集合。此绑定用作顶点属性的编号数据源。我们可以使用至少 16 个独立的绑定，将单独的顶点缓冲区或同一缓冲区的不同部分绑定到这些绑定上。
- en: The vertex input state is obligatory for a graphics pipeline creation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点输入状态对于创建图形管线是必需的。
- en: Through a binding description, we specify where the data is taken from (from
    which binding), how it is laid out (what is the stride between consecutive elements
    in the buffer), and how this data is read (whether it should be fetched per vertex
    or per instance).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绑定描述，我们指定数据是从哪里取出的（从哪个绑定），如何布局（缓冲区中连续元素之间的步长是什么），以及如何读取这些数据（是否应该按顶点或按实例读取）。
- en: 'As an example, when we want to use three attributes--three element vertex positions,
    two element texture coordinates, and three element color values, which are read
    per vertex from the `0`^(th) binding--we can use the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们想要使用三个属性——三个元素的顶点位置、两个元素的纹理坐标和三个元素的颜色值，这些值从 `0`^(th) 绑定中按顶点读取时，我们可以使用以下代码：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Through a vertex input description we define the attributes taken from a given
    binding. For each attribute we need to provide a shader location (the same as
    in the shader source code defined through a `layout( location = <number> )` qualifier),
    a format of the data used for a given attribute, and a memory offset at which
    the given attribute starts (relative to the beginning of the data for the given
    element). The number of input description entries specifies the total number of
    attributes used during rendering.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过顶点输入描述，我们定义从给定绑定中取出的属性。对于每个属性，我们需要提供一个着色器位置（与通过 `layout( location = <number>
    )` 限定符定义的着色器源代码中的位置相同），用于给定属性的数据格式，以及给定属性开始的内存偏移量（相对于给定元素的开始数据）。输入描述条目数指定了渲染过程中使用的属性总数。
- en: '![](img/image_08_001.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_001.png)'
- en: 'In the previous situation--with three component vertex positions, two component
    texture coordinates, and three component colors--we can use the following code
    to specify the vertex input description:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下——具有三个分量的顶点位置、两个分量的纹理坐标和三个分量的颜色——我们可以使用以下代码来指定顶点输入描述：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All three attributes are taken from the `0`^(th) binding. Positions are provided
    to a vertex shader at the `0`^(th) location, texcoords through the first location,
    and color values through the second location. The position and color are three
    component vectors, and texcoords have two components. They all use floating-point
    signed values. The position is first, so it has no offset. The texture coordinate
    goes next, so it has an offset of three floating-point values. The color starts
    after the texture coordinate, so its offset is equal to five floating-point values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个属性都来自`0`^(th)绑定。位置在`0`^(th)位置提供给顶点着色器，通过第一个位置提供texcoords，通过第二个位置提供颜色值。位置和颜色是三维向量，texcoords有两个组件。它们都使用有符号的浮点值。位置是第一个，因此没有偏移。纹理坐标接下来，因此它有三个浮点值的偏移。颜色在纹理坐标之后开始，因此它的偏移等于五个浮点值。
- en: 'The implementation of this recipe is provided in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的实现如下所示：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the recipe:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Writing vertex shaders*'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写顶点着色器*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中，查看以下配方：
- en: '*Binding vertex buffers*'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: The recipe *Creating a graphics **pipeline* in this chapter
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中创建图形**管道**的配方
- en: Specifying a pipeline input assembly state
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管道输入装配状态
- en: Drawing geometry (3D models) involves specifying the type of primitives that
    are formed from provided vertices. This is done through an input assembly state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制几何图形（3D模型）涉及指定从提供的顶点形成的原语类型。这是通过输入装配状态完成的。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a variable of type `VkPipelineInputAssemblyStateCreateInfo` named `input_assembly_state_create_info`.
    Use the following values to initialize its members:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`input_assembly_state_create_info`的`VkPipelineInputAssemblyStateCreateInfo`类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO` value for `sType`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO`的值为`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`的值为`pNext`'
- en: '`0` value for `flags`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的值为`0`'
- en: The selected type of primitives to be formed from vertices (point list, line
    list, line strip, triangle list, triangle strip, triangle fan, line list with
    adjacency, line strip with adjacency, triangle list with adjacency, triangle strip
    with adjacency, or patch list) for `topology`
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`topology`选择从顶点形成的原语类型（点列表、线列表、线带、三角形列表、三角形带、三角形扇、带相邻关系的线列表、带相邻关系的线带、带相邻关系的三角形列表、带相邻关系的三角形带或补丁列表）
- en: For the `primitiveRestartEnable` member, in cases of drawing commands that use
    vertex indices, specify whether a special index value should restart a primitive
    (`VK_TRUE`, can't be used for list primitives) or if a primitive restart should
    be disabled (`VK_FALSE`)
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`primitiveRestartEnable`成员，在绘制使用顶点索引的命令的情况下，指定是否应该使用特殊索引值来重启原语（`VK_TRUE`，不能用于列表原语）或者是否应该禁用原语重启（`VK_FALSE`）
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Through an input assembly state, we define what types of polygons are formed
    from the drawn vertices. The most commonly used primitives are triangle strips
    or lists, but the used topology depends on the results we want to achieve.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入装配状态，我们定义从绘制的顶点形成的多边形类型。最常用的原语是三角形带或列表，但使用的拓扑结构取决于我们想要达到的结果。
- en: An input assembly state is required for the graphics pipeline creation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图形管道需要输入装配状态。
- en: '![](img/image_08_002.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_002.png)'
- en: 'When selecting how vertices are assembled, we just need to bear in mind some
    requirements:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择如何装配顶点时，我们只需牢记一些要求：
- en: We can't use list primitives with a primitive restart option.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能使用具有原语重启选项的列表原语。
- en: Primitives with adjacency can only be used with geometry shaders. For this to
    work correctly, a `geometryShader` feature must be enabled during the logical
    device creation.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有与相邻关系相关的原语才能与几何着色器一起使用。为了正确工作，必须在创建逻辑设备时启用`geometryShader`功能。
- en: When we want to use tessellation shaders, we can only use patch primitives.
    In addition, we also need to remember that a `tessellationShader` feature must
    be enabled during the logical device creation.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要使用细分着色器时，我们只能使用补丁原语。此外，我们还需要记住，在创建逻辑设备时必须启用`tessellationShader`功能。
- en: 'Here is an example of a source code that initializes a variable of type `VkPipelineInputAssemblyStateCreateInfo`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个初始化类型为 `VkPipelineInputAssemblyStateCreateInfo` 的变量的源代码示例：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying pipeline rasterization state*'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Specifying a pipeline tessellation state
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线细分状态
- en: Tessellation shaders are one of the optional, additional programmable shader
    stages that can be enabled in a graphics pipeline. But when we want to activate
    them, we also need to prepare a pipeline tessellation state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 细分着色器是可选的附加可编程着色器阶段之一，可以在图形管线中启用。但当我们想要激活它们时，我们还需要准备一个管线细分状态。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a variable of type `VkPipelineTessellationStateCreateInfo` named `tessellation_state_create_info`.
    Use the following to initialize its members:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `tessellation_state_create_info` 的类型为 `VkPipelineTessellationStateCreateInfo`
    的变量。使用以下内容初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO` value for `sType`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO` 的 `sType` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: '`0` value for `flags`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值'
- en: The number of control points (vertices) which form a patch for `patchControlPoints`
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形成 `patchControlPoints` 补丁的控制点（顶点）数
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To use tessellation shaders in our application, we need to enable a `tessellationShader`
    feature during a logical device creation, we need to write a source code for both
    tessellation control and evaluation shaders, we need to create a shader module
    (or two) for them, and we also need to prepare a pipeline tessellation state represented
    by a variable of type `VkPipelineTessellationStateCreateInfo`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用细分着色器，我们需要在创建逻辑设备期间启用 `tessellationShader` 功能，我们需要为细分控制和评估着色器编写源代码，我们需要为它们创建着色器模块（或两个），并且我们还需要准备一个由类型为
    `VkPipelineTessellationStateCreateInfo` 的变量表示的管线细分状态。
- en: The tessellation state is optional--we need to specify it only when we want
    to use tessellation shaders in a graphics pipeline.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 细分状态是可选的——我们只需要在想要在图形管线中使用细分着色器时指定它。
- en: In the tessellation state we only provide information about the number of control
    points (vertices) from which a patch is formed. The specification states that
    patches may have up to at least 32 vertices.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在细分状态中，我们只提供有关形成补丁的控制点（顶点）数量的信息。规范指出，补丁可以有至少32个顶点。
- en: The maximal supported number of control points (vertices) in a patch must be
    at least 32.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在补丁中支持的最大控制点（顶点）数至少为32。
- en: A patch is just a collection of points (vertices) that are used by the tessellation
    stages to generate typical points, lines, or polygons like triangles. It can be
    exactly the same as usual polygons. As an example, we can take vertices that form
    a triangle and draw them as patches. Results of such an operation are correct.
    But for the patch, we can use any other unusual order and number of vertices.
    This gives us much more flexibility in controlling the way new vertices are created
    by the tessellation engine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁只是一个由点（顶点）组成的集合，这些点被细分阶段用来生成典型的点、线或多边形，如三角形。它可以与通常的多边形完全相同。例如，我们可以取形成三角形的顶点并将它们作为补丁绘制。这种操作的成果是正确的。但对于补丁，我们可以使用任何其他不寻常的顺序和顶点数量。这使我们能够以更多的方式控制细分引擎创建新顶点的方式。
- en: 'To fill a variable of type `VkPipelineTessellationStateCreateInfo,` we can
    prepare the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要填充类型为 `VkPipelineTessellationStateCreateInfo` 的变量，我们可以准备以下代码：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml) *着色器* 中，查看以下食谱：
- en: '*Writing tessellation control shaders*'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分控制着色器*'
- en: '*Writing tessellation evaluation shaders*'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分评估着色器*'
- en: The recipe *Creating a graphics pipeline *in this chapter
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的食谱 *创建图形管线*
- en: Specifying a pipeline viewport and scissor test state
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线视口和剪裁测试状态
- en: Drawing an object on screen requires us to specify the screen parameters. Creating
    a swapchain is not enough--we don't always need to draw to the entire available
    image area. There are situations in which we just want to draw a smaller picture
    in the whole image, such as the reflection in the back mirror of a car or half
    of the image in split-screen multiplayer games. We define the area of the image
    to which we want to draw through a pipeline viewport and scissor test states.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制对象需要我们指定屏幕参数。创建一个交换链是不够的——我们并不总是需要绘制到整个可用图像区域。有些情况下，我们只想在整幅图像中绘制一个较小的图像，例如汽车后视镜中的反射或分屏多人游戏中的图像的一半。我们通过管道视口和裁剪测试状态定义我们想要绘制的图像区域。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Specifying parameters for a viewport and scissor states requires us to provide
    a separate set of parameters for both the viewport and scissor test, but the number
    of elements in both sets must be equal. To keep parameters for both states together,
    a custom `ViewportInfo` type is introduced in this recipe. It has the following
    definition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 指定视口和裁剪状态的参数需要我们为视口和裁剪测试提供一组单独的参数，但两组中的元素数量必须相等。为了将这两个状态的参数放在一起，本菜谱中引入了一个自定义的
    `ViewportInfo` 类型。它具有以下定义：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first member, as the name suggests, contains parameters for a set of viewports.
    The second is used to define the parameters for scissor tests corresponding to
    each viewport.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一成员，正如其名所示，包含一组视口的参数。第二个用于定义与每个视口对应的裁剪测试的参数。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: If rendering is to be performed to more than one viewport, create a logical
    device with the `multiViewport` feature enabled.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要向多个视口进行渲染，请创建一个启用了 `multiViewport` 功能的逻辑设备。
- en: 'Create a variable of type `std::vector<VkViewport>` named `viewports`. Add
    a new element to the `viewports` vector for each viewport into which rendering
    will be done. Use the following values to initialize its members:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `viewports` 的 `std::vector<VkViewport>` 类型的变量。对于每个将要进行渲染的视口，向 `viewports`
    向量中添加一个新元素。使用以下值初始化其成员：
- en: The position (in pixels) of the left side of the rendering area for `x`
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染区域左侧的位置（以像素为单位）对于 `x`
- en: The position (in pixels) of the top side of the rendering area for `y`
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染区域顶部的位置（以像素为单位）对于 `y`
- en: The width of the rendering area (in pixels) for `width`
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染区域宽度（以像素为单位）对于 `width`
- en: The height of the rendering area (in pixels) for `height`
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height` 的渲染区域高度（以像素为单位）'
- en: The value between `0.0` and `1.0` for the minimal depth of the viewport for
    `minDepth`
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视口的最小深度值，介于 `0.0` 和 `1.0` 之间对于 `minDepth`
- en: The value between `0.0` and `1.0` for the maximal depth of the viewport for
    `maxDepth`
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视口的最大深度值，介于 `0.0` 和 `1.0` 之间对于 `maxDepth`
- en: 'Create a variable of type `std::vector<VkRect2D>` named `scissors`. Add a new
    element to the `scissors` vector variable for each viewport into which rendering
    will be done (the `scissors` vector must have the same number of elements as the
    `viewports` vector). Use the following values to initialize its members:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `scissors` 的 `std::vector<VkRect2D>` 类型的变量。对于每个将要进行渲染的视口，向 `scissors`
    向量变量中添加一个新元素（`scissors` 向量必须与 `viewports` 向量具有相同数量的元素）。使用以下值初始化其成员：
- en: The position of the top left corner of the scissor rectangle for the `x` and
    `y` members of the `offset`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪矩形左上角的位置对于 `offset` 的 `x` 和 `y` 成员
- en: The width and height of the scissor rectangle for the `width` and `height` members
    of the `extent`
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪矩形的宽度和高度对于 `extent` 的 `width` 和 `height` 成员
- en: 'Create a variable of type `VkPipelineViewportStateCreateInfo` named `viewport_state_create_info`.
    Use the following values to initialize its members:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `viewport_state_create_info` 的 `VkPipelineViewportStateCreateInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO` value for `sType`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO` 的值对于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值对于 `pNext`'
- en: '`0` value for `flags`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 值对于 `flags`'
- en: The number of elements in the `viewports` vector for `viewportCount`
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewports` 向量中的元素数量对于 `viewportCount`'
- en: A pointer to the first element of the `viewports` vector for `pViewports`
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewports` 向量第一个元素的指针对于 `pViewports`'
- en: The number of elements in the `scissors` vector for `scissorCount`
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scissors` 向量中的元素数量对于 `scissorCount`'
- en: A pointer to the first element of the `scissors` vector for `pScissors`
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scissors` 向量第一个元素的指针对于 `pScissors`'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Vertex positions are transformed (usually inside a vertex shader) from the local
    space into a clip space. The hardware then performs a perspective division which
    generates normalized device coordinates. Next, polygons are assembled and rasterized--this
    process generates fragments. Each fragment has its own position defined in a framebuffer's
    coordinates. Also, for this position to be correctly calculated, a viewport transformation
    is required. Parameters of this transformation are specified in a viewport state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点位置（通常在顶点着色器内部）从局部空间转换到裁剪空间。然后硬件执行透视除法，生成归一化设备坐标。接下来，多边形被组装并光栅化——这个过程生成片段。每个片段在其自己的帧缓冲区坐标中定义了位置。此外，为了正确计算此位置，还需要视口变换。该变换的参数在视口状态中指定。
- en: The viewport and scissor test state is optional, though commonly used--we don't
    need to provide it when rasterization is disabled.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 视口和剪裁测试状态是可选的，尽管常用——当光栅化被禁用时，我们不需要提供它。
- en: Through a viewport state, we define the top-left corner and the width and height
    of the rendering area in a framebuffer's coordinates (pixels on screen). We also
    define the minimal and maximal viewport depth value (floating-point values between
    `0.0` and `1.0`, inclusive). It is valid to specify the value of the maximal depth
    to be smaller than the value of the minimal depth.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视口状态，我们定义在帧缓冲区坐标中渲染区域的左上角、宽度和高度（屏幕上的像素）。我们还定义了视口的最小和最大深度值（介于 `0.0` 和 `1.0`
    之间的浮点值，包括）。指定最大深度值小于最小深度值是有效的。
- en: A scissor test allows us to additionally clip the generated fragments to a rectangle
    specified in the scissor parameters. When we don't want to clip fragments, we
    need to specify an area equal to a viewport size.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 剪裁测试允许我们进一步将生成的片段裁剪到剪裁参数中指定的矩形。当我们不想裁剪片段时，我们需要指定一个与视口大小相等的区域。
- en: In Vulkan, the scissor test is always enabled.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，剪裁测试始终启用。
- en: 'The number of set of parameters for a viewport and scissor test must be equal.
    That''s why it may be good to define a custom type with which we can keep the
    number of elements of both properties equal. The following is a sample code that
    specifies parameters for one viewport and one scissor test through a variable
    of a custom `ViewportInfo` type:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 视口和剪裁测试的参数集数量必须相等。因此，定义一个自定义类型来保持这两个属性元素数量相等可能是个好主意。以下是一个示例代码，它通过自定义 `ViewportInfo`
    类型的变量指定一个视口和一个剪裁测试的参数：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding variable can be used to create a viewport and scissor test as
    defined in this recipe. The implementation of the recipe may look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的变量可以用来创建本食谱中定义的视口和剪裁测试。该食谱的实现可能如下所示：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we want to change some of the viewport or scissor test parameters, we need
    to recreate a pipeline. But during the pipeline creation, we can specify that
    the viewport and scissor test parameters are dynamic. This way, we don't need
    to recreate a pipeline to change these parameters--we specify them during command
    buffer recording. But we need to remember that the number of viewports (and scissor
    tests) is always specified during the pipeline creation. We can't change it later.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要更改视口或剪裁测试的一些参数，我们需要重新创建一个管线。但在管线创建过程中，我们可以指定视口和剪裁测试参数是动态的。这样，我们就不需要重新创建管线来更改这些参数——我们可以在命令缓冲区记录期间指定它们。但我们需要记住，视口（和剪裁测试）的数量始终在管线创建期间指定。我们无法在之后更改它。
- en: It is possible to define a viewport and scissor test as dynamic states and specify
    their parameters during command buffer recording. The number of viewports (and
    scissor tests) is always specified during the graphics pipeline creation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将视口和剪裁测试定义为动态状态，并在命令缓冲区记录期间指定它们的参数。视口（和剪裁测试）的数量始终在图形管线创建期间指定。
- en: We also can't provide more than one viewport and scissor test, unless a `multiViewport`
    feature is enabled for a logical device. An index of a viewport transformation
    that will be used for rasterization can be changed only inside geometry shaders.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能提供超过一个视口和剪裁测试，除非为逻辑设备启用了 `multiViewport` 功能。用于光栅化的视口变换的索引只能在几何着色器内部更改。
- en: Changing the index of a viewport transformation used for rasterization requires
    us to use geometry shaders.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 更改用于光栅化的视口变换索引需要我们使用几何着色器。
- en: See also
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instances and
    Devices*, see the following recipes:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml) *实例与设备* 中，查看以下食谱：
- en: '*Getting features and properties of a physical device*'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取物理设备的特性和属性*'
- en: '*Creating a logical device*'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the recipe:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Writing geometry shaders*'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写几何着色器*'
- en: The recipe *Creating a graphics pipeline*, in this chapter
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的配方*创建图形管道*，
- en: Specifying a pipeline rasterization state
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管道光栅化状态
- en: The rasterization process generates fragments (pixels) from the assembled polygons.
    The viewport state is used to specify where, in the framebuffer coordinates, fragments
    will be generated. To specify how (if at all) fragments are generated, we need
    to prepare a rasterization state.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化过程从组装的多边形生成片段（像素）。视口状态用于指定片段将在帧缓冲区坐标中的何处生成。为了指定（如果有的话）如何生成片段，我们需要准备一个光栅化状态。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a variable of type `VkPipelineRasterizationStateCreateInfo` named `rasterization_state_create_info`.
    Use the following values to initialize its members:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`rasterization_state_create_info`的`VkPipelineRasterizationStateCreateInfo`类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO` value for `sType`.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO`的值用于`sType`。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的值为`nullptr`。'
- en: '`0` value for `flags`.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的值为`0`。'
- en: For `depthClampEnable` use a `true` value if a depth value for fragments whose
    depth is outside of the min/max range specified in a viewport state should be
    clamped within this range, or use a `false` value if fragments with depth outside
    of the this range should be clipped (discarded); when the `depthClampEnable` feature
    is not enabled only a `false` value can be specified.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`depthClampEnable`，如果需要将深度值超出视口状态中指定的最小/最大范围的片段的深度值限制在此范围内，请使用`true`值；如果需要将超出此范围的片段裁剪（丢弃），请使用`false`值；当`depthClampEnable`功能未启用时，只能指定`false`值。
- en: For `rasterizerDiscardEnable` use a `false` value if fragments should be normally
    generated or `true` to disable rasterization.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`rasterizerDiscardEnable`，如果应该正常生成片段，请使用`false`值；如果要禁用光栅化，请使用`true`。
- en: For `polygonMode` specify how assembled polygons should be rendered--fully filled
    or if lines or points should be rendered (lines and points modes can only be used
    if a `fillModeNonSolid` feature is enabled).
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`polygonMode`，指定组装的多边形应该如何渲染——完全填充或是否渲染线条或点（线条和点模式只能在启用`fillModeNonSolid`功能时使用）。
- en: The sides of the polygon--front, back, both or none--that should be culled for
    `cullMode`.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形的侧面——前侧、后侧、两侧或无——在`cullMode`中应该被剔除。
- en: The side of the polygon--drawn on screen in clockwise or counterclockwise vertex
    order--that should be considered as a front side for `frontFace`.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形的侧面——在屏幕上按顺时针或逆时针顶点顺序绘制——应被视为`frontFace`的前侧面。
- en: For `depthBiasEnable` specify a `true` value if depth values calculated for
    fragments should be additionally offset or a `false` value if no such modification
    should be performed.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`depthBiasEnable`，如果需要为片段计算深度值添加额外的偏移，请指定`true`值；如果不需要进行此类修改，请指定`false`值。
- en: The constant value that should be added to a fragment's calculated depth value
    when depth bias is enabled for `depthBiasConstantFactor`.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当为`depthBiasConstantFactor`启用深度偏移时，应添加到片段计算深度值中的常数值。
- en: The maximum (or minimum) value of a depth bias which can be added to a fragment's
    depth when depth bias is enabled for `depthBiasClamp`.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当为`depthBiasClamp`启用深度偏移时，可以添加到片段深度中的最大（或最小）深度偏移值。
- en: The value added to fragment's slope in depth bias calculations when depth bias
    is enabled for `depthBiasSlopeFactor`.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当为`depthBiasSlopeFactor`启用深度偏移时，添加到片段斜率中的值。
- en: The value specifying the width of rendered lines for `lineWidth`; if a `wideLines`
    feature is not enabled, only a `1.0` value can be specified; otherwise, values
    greater than `1.0` can also be provided.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定渲染线条宽度的值用于`lineWidth`；如果未启用`wideLines`功能，则只能指定`1.0`值；否则，也可以提供大于`1.0`的值。
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The rasterization state controls the parameters of a rasterization. First and
    foremost it defines if the rasterization is enabled or disabled. Through it we
    can specify which side of the polygon is the front--if it is the one in which
    vertices appear in a clockwise order on screen or if in a counterclockwise order.
    Next, we need to control if culling should be enabled for the front, back, both
    faces, or if it should be disabled. In OpenGL, by default, counterclockwise faces
    were considered front and culling was disabled. In Vulkan, there is no default
    state so how we define these parameters is up to us.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化状态控制光栅化的参数。首先，它定义了光栅化是否启用或禁用。通过它，我们可以指定多边形的哪一侧是前面——如果它是屏幕上顶点按顺时针顺序出现的那一侧，或者是否是按逆时针顺序。接下来，我们需要控制是否为前面、后面、两侧启用剔除，或者是否禁用剔除。在OpenGL中，默认情况下，逆时针面的被认为是前面，并且剔除是禁用的。在Vulkan中，没有默认状态，因此如何定义这些参数取决于我们。
- en: A rasterization state is always required during the graphics pipeline creation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图形管线时始终需要设置光栅化状态。
- en: The rasterization state also controls the way polygons are drawn. Usually we
    want them to be fully rendered (filled). But we can specify if only their edges
    (lines) or points (vertices) should be drawn. Lines or points modes can only be
    used if the `fillModeNonSolid` feature is enabled during the logical device creation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化状态还控制多边形的绘制方式。通常我们希望它们被完全渲染（填充）。但我们可以指定是否只绘制它们的边缘（线条）或点（顶点）。线条或点模式只能在创建逻辑设备时启用
    `fillModeNonSolid` 功能时使用。
- en: For the rasterization state, we also need to define how the depth value of generated
    fragments is calculated. We can enable depth bias--a process which offsets a generated
    depth value by a constant value and an additional slope factor. We also specify
    the maximal (or minimal) offset value that can be applied to the depth value when
    depth bias is enabled.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于光栅化状态，我们还需要定义如何计算生成的片段的深度值。我们可以启用深度偏移——这是一个通过一个常数值和一个额外的斜率因子偏移生成深度值的过程。我们还可以指定在启用深度偏移时可以应用于深度值的最大（或最小）偏移值。
- en: After that, we also need to define what to do with fragments whose depth value
    is outside the range specified in a viewport state. When the depth clamp is enabled,
    the depth value of such fragments is clamped to the defined range and the fragments
    are processed further. If the depth clamp is disabled, such fragments are discarded.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还需要定义对于深度值超出视口状态中指定范围的片段应该做什么。当启用深度钳位时，此类片段的深度值被钳位到定义的范围内，并且片段会被进一步处理。如果禁用深度钳位，此类片段将被丢弃。
- en: One last thing is to define the width of the rendered lines. Normally we can
    specify only a value of `1.0`. But if we enable the `wideLines` feature, we can
    provide values greater than `1.0`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是要定义渲染线条的宽度。通常我们只能指定 `1.0` 的值。但如果我们启用 `wideLines` 功能，我们可以提供大于 `1.0` 的值。
- en: 'The rasterization state is defined through a variable of type `VkPipelineRasterizationStateCreateInfo`.
    A sample source code that fills such variable with values provided through other
    variables, is presented in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化状态是通过一个 `VkPipelineRasterizationStateCreateInfo` 类型的变量定义的。以下是一个示例代码，展示了如何通过其他变量提供的值填充此类变量：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying pipeline viewport and scissor test state*'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线视口和裁剪测试状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Specifying a pipeline multisample state
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线多采样状态
- en: Multisampling is a process that eliminates jagged edges of drawn primitives.
    In other words, it allows us to anti-alias polygons, lines and points. We define
    how multisampling is performed (and if at all) through a multisample state.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 多采样是一种消除绘制原语锯齿边缘的过程。换句话说，它允许我们对多边形、线条和点进行抗锯齿处理。我们通过多采样状态定义如何进行多采样（以及是否进行）。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a variable of type `VkPipelineMultisampleStateCreateInfo` named `multisample_state_create_info`.
    Use the following values to initialize its members:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `multisample_state_create_info` 的 `VkPipelineMultisampleStateCreateInfo`
    类型的变量。使用以下值来初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO` value for `sType`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType` 的值为 `VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO`'
- en: '`nullptr` value for `pNext`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: '`0` value for `flags`'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的值为 `0`'
- en: The number of samples generated per pixel for `rasterizationSamples`
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每像素生成的样本数用于 `rasterizationSamples`
- en: A `true` value if per sample shading should be enabled (only if `sampleRateShading`
    feature is enabled) or `false` otherwise for `sampleShadingEnable`
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应该启用每个样本着色（仅当启用`sampleRateShading`功能时）或否则为`false`，则对于`sampleShadingEnable`的`true`值
- en: A minimum fraction of uniquely shaded samples, when sample shading is enabled,
    for `minSampleShading`
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启用样本着色时，`minSampleShading`所需的最小独特着色样本分数
- en: A pointer to an array of bitmasks that controls a fragment's static coverage
    or a `nullptr` value to indicate that no coverage is removed from the fragments
    (all bits are enabled in the mask) for `pSampleMask`
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向一个位掩码数组的指针，该数组控制片段的静态覆盖，或一个`nullptr`值以指示从片段中不删除覆盖（掩码中的所有位都启用）对于`pSampleMask`
- en: A `true` value if a fragment's coverage should be generated based on the fragment's
    alpha value or `false` otherwise for `alphaToCoverageEnable`
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果片段的覆盖应该基于片段的alpha值生成或否则为`false`，对于`alphaToCoverageEnable`的`true`值
- en: A `true` value if an alpha component of the fragment's color should be replaced
    with a `1.0` value for floating-point formats or with a maximum available value
    of a given format for fixed-point formats (only when the `alphaToOne` feature
    is enabled) or `false` otherwise value for `alphaToOneEnable`
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果片段的颜色应该用`1.0`值替换片段的alpha分量，对于浮点格式，或者用给定格式的最大可用值替换固定点格式（仅当启用`alphaToOne`功能时）或否则的值，对于`alphaToOneEnable`
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The multisample state allows us to enable anti-aliasing of drawn primitives.
    Through it we can define the number of samples generated per fragment, enable
    per sample shading and specify the minimal number of uniquely shaded samples,
    and define a fragment's coverage parameters --the sample coverage mask, whether
    the coverage should be generated from an alpha component of the fragment's color.
    We can also specify if an alpha component should be replaced with a `1.0` value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 多样本状态允许我们启用绘制的原语的抗锯齿。通过它，我们可以定义每个片段生成的样本数，启用每个样本着色，指定唯一着色样本的最小数量，并定义片段的覆盖参数——样本覆盖掩码，是否应该从片段颜色的alpha分量生成覆盖。我们还可以指定是否应该用`1.0`值替换alpha分量。
- en: A multisample state is required only when rasterization is enabled.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当启用光栅化时，才需要多样本状态。
- en: 'To prepare a multisample state, we need to create a variable of a `VkPipelineMultisampleStateCreateInfo`
    type like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备一个多样本状态，我们需要创建一个`VkPipelineMultisampleStateCreateInfo`类型的变量，如下所示：
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the function's parameters are used to initialize members
    of a `multisample_state_create_info` variable.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，函数的参数用于初始化`multisample_state_create_info`变量的成员。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying pipeline rasterization state*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Specifying a pipeline depth and stencil state
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线深度和模板状态
- en: Usually, when we render a geometry, we want to mimic the way we see the world--objects
    further away are smaller, objects closer to us are larger and they cover the objects
    behind them (obscure our view). In modern 3D graphics, this last effect (objects
    further away being obscured by objects being nearer) is achieved through a depth
    test. The way in which a depth test is performed, is specified through a depth
    and stencil state of a graphics pipeline.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们渲染几何体时，我们想要模仿我们看到世界的方式——远离我们的物体更小，靠近我们的物体更大，并且它们覆盖了后面的物体（遮挡我们的视线）。在现代3D图形中，这种最后的效果（远离的物体被靠近的物体遮挡）是通过深度测试实现的。深度测试的执行方式是通过图形管线的深度和模板状态来指定的。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a variable of type `VkPipelineDepthStencilStateCreateInfo` named `depth_and_stencil_state_create_info`.
    Use the following values to initialize its members:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`depth_and_stencil_state_create_info`的`VkPipelineDepthStencilStateCreateInfo`类型的变量。使用以下值来初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO` value for `sType`'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO`的`sType`值'
- en: '`nullptr` value for `pNext`'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值'
- en: '`0` value for `flags`'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的`0`值'
- en: A `true` value if we want to enable a depth test or otherwise `false` for `depthTestEnable`
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要启用深度测试或否则为`false`，对于`depthTestEnable`的`true`值
- en: A `true` value if we want to store the depth value in a depth buffer and otherwise `false` for
    `depthWriteEnable`
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要将深度值存储在深度缓冲区中，否则对于`depthWriteEnable`为`false`的`true`值
- en: A chosen compare operator (`never`, `less`, `less and equal`, `equal`, `greater
    and equal`, `greater`, `not equal`, `always`) controlling how the depth test is
    performed for `depthCompareOp`
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个比较运算符（`never`，`less`，`less and equal`，`equal`，`greater and equal`，`greater`，`not
    equal`，`always`），用于控制`depthCompareOp`的深度测试执行方式。
- en: A `true` value if we want to enable additional depth bounds tests (only if `depthBounds`
    feature is enabled) or otherwise `false` for `depthBoundsTestEnable`
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想启用额外的深度边界测试（只有当`depthBounds`功能启用时）或否则为`false`，则`depthBoundsTestEnable`的值为`true`。
- en: A `true` value if we want to use a stencil test or `false` if we want to disable
    it for `stencilTestEnable`
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想使用模板测试，则`stencilTestEnable`的值为`true`，如果我们要禁用它，则值为`false`。
- en: 'Use the following values to initialize members of a `front` field through which
    we set up stencil test parameters performed for front-facing polygons:'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下值通过`front`字段初始化成员，通过该字段我们设置用于正面多边形的模板测试参数：
- en: Function performed when samples fail the stencil test for `failOp`.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当样本未通过模板测试时执行的功能，对应于`failOp`。
- en: Action performed when samples pass the stencil test for `passOp`.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当样本通过模板测试时执行的操作，对应于`passOp`。
- en: Action taken when samples pass the stencil test but fail the depth test for
    `depthFailOp`.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当样本通过模板测试但未通过深度测试时采取的操作，对应于`depthFailOp`。
- en: Operator (`never`, `less`, `less and equal`, `equal`, `greater and equal`, `greater`,
    `not equal`, `always`) used to perform the stencil test for `compareOp`.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于执行模板测试的运算符（`never`，`less`，`less and equal`，`equal`，`greater and equal`，`greater`，`not
    equal`，`always`），对应于`compareOp`。
- en: Mask selecting the bits of stencil values that take part in the stencil test
    for `compareMask`.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择参与模板测试的模板值的位的掩码，对应于`compareMask`。
- en: Mask selecting which bits of a stencil value should be updated in a framebuffer
    for `writeMask.`
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择掩码，用于选择在帧缓冲区中应更新的模板值的哪些位，对应于`writeMask`。
- en: Reference value used for stencil test comparison for `reference`.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于模板测试比较的参考值。
- en: For `back` member setup stencil test parameters as described previously for
    front-facing polygons but, this time, for back-facing polygons.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`back`成员，设置模板测试参数，如之前所述用于正面多边形，但这次是针对背面多边形。
- en: The value between `0.0` and `1.0` (inclusive) describing the minimal value of
    a depth bounds test for `minDepthBounds`.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述`minDepthBounds`的深度边界测试的最小值的`0.0`到`1.0`（包含）之间的值。
- en: The value from `0.0` to `1.0` (inclusive) describing the maximal value of a
    depth bounds test for `maxDepthBounds`.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述`maxDepthBounds`的深度边界测试的最大值的`0.0`到`1.0`（包含）之间的值。
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The depth and stencil state specifies whether a depth and/or stencil test should
    be performed. If any of them are enabled, we also define parameters for each of
    these tests.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 深度和模板状态指定是否应执行深度和/或模板测试。如果其中任何一个被启用，我们还为每个这些测试定义参数。
- en: A depth and stencil state is not required when rasterization is disabled or
    if a given subpass in a render pass does not use any depth/stencil attachments.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当光栅化禁用或渲染通道中的给定子通道未使用任何深度/模板附加时，不需要深度和模板状态。
- en: We need to specify how the depth test is performed (how depth values are compared)
    and if the depth value of a processed fragment should be written to a depth attachment
    when the fragment passes the test.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定如何执行深度测试（如何比较深度值）以及当片段通过测试时，处理片段的深度值是否应写入深度附加。
- en: When the `depthBounds` feature is enabled, we can also activate an additional
    depth bounds test. This test checks whether the depth value of a processed fragment
    is inside a specified `minDepthBounds` - `maxDepthBounds` range. If it is not,
    the processed fragment is discarded as if it failed the depth test.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当`depthBounds`功能启用时，我们还可以激活一个额外的深度边界测试。此测试检查处理片段的深度值是否在指定的`minDepthBounds` -
    `maxDepthBounds`范围内。如果不是，则处理片段被丢弃，就像它未通过深度测试一样。
- en: The stencil test allows us to perform additional tests on integer values associated
    with each fragment. It can be used for various purposes. As an example, we can
    define an exact part of the screen which can be updated during drawing, but, contrary
    to the scissor test, this area may have any shape, even if it is very complicated.
    Such an approach is used in deferred shading/lighting algorithms to restrict image
    areas that can be lit by a given light source. Another example of a stencil test
    is using it to show silhouettes of objects that are hidden behind other objects
    or highlighting objects selected by a mouse pointer.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 模板测试允许我们对与每个片段关联的整数值执行附加测试。它可以用于各种目的。例如，我们可以定义在绘制过程中可以更新的屏幕的精确部分，但与剪裁测试不同，这个区域可以是任何形状，即使它非常复杂。这种方法在延迟着色/光照算法中用于限制给定光源可以照亮的图像区域。模板测试的另一个例子是使用它来显示被其他对象隐藏的对象的轮廓或突出显示鼠标指针选择的对象。
- en: In the case of an enabled stencil test, we need to define its parameters separately
    for front- and back-facing polygons. These parameters include actions performed
    when a given fragment fails the stencil test, passes it but fails the depth test,
    and passes both the stencil and depth test. For each situation, we define that
    current value in a stencil attachment should be kept intact, reset to `0`, replaced
    with a reference value, incremented or decremented with clamping (saturation)
    or with wrapping, or if the current value should be inverted bitwise. We also
    specify how the test is performed by setting the comparison operator (similar
    to the operator defined in the depth test), comparison and write masks which select
    the stencil value's bits that should take part in the test or which should be
    updated in a stencil attachment, and a reference value.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用模板测试的情况下，我们需要分别为前向和后向多边形定义其参数。这些参数包括当给定片段失败模板测试、通过模板测试但失败深度测试，以及通过模板和深度测试时执行的操作。对于每种情况，我们定义当前值在模板附加中的值应保持不变，重置为
    `0`，替换为参考值，通过钳位（饱和）或通过环绕进行增加或减少，或者如果当前值应通过位运算取反。我们还通过设置比较运算符（类似于深度测试中定义的运算符）、比较和写入掩码来指定测试的执行方式，这些掩码选择应参与测试或应在模板附加中更新的模板值的位，以及一个参考值。
- en: 'The sample source code that prepares a variable of a `VkPipelineDepthStencilStateCreateInfo`
    type, through which the depth and stencil test is defined, is presented in the
    following code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个类型为 `VkPipelineDepthStencilStateCreateInfo` 的变量的示例源代码，通过该变量定义深度和模板测试，如下代码所示：
- en: '[PRE15]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml) *渲染通道和帧缓冲区* 中，查看以下食谱：
- en: '*Specifying subpass descriptions*'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a framebuffer*'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: 'The following recipes in this chapter:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying pipeline rasterization state*'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Specifying a pipeline blend state
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线混合状态
- en: Transparent objects are very common in the environment we see every day around
    us. Such objects are also common in 3D applications. To simulate transparent materials
    and simplify operations that the hardware needs to perform to render transparent
    objects, blending was introduced. It mixes the color of a processed fragment with
    a color that is already stored in a framebuffer. Parameters for this operation
    are prepared through a graphics pipeline's blend state.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 透明物体在我们每天看到的周围环境中非常常见。这类物体在3D应用程序中也同样常见。为了模拟透明材料并简化硬件需要执行以渲染透明物体的操作，引入了混合。它将处理片段的颜色与已存储在帧缓冲区中的颜色混合。为此操作准备参数是通过图形管线中的混合状态完成的。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a variable of type `VkPipelineColorBlendAttachmentState` named `attachment_blend_states`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `attachment_blend_states` 的类型为 `VkPipelineColorBlendAttachmentState`
    的变量。
- en: 'For each color attachment used in a subpass in which a given graphics pipeline
    is bound, add a new element to the `attachment_blend_states` vector. If the `independentBlend`
    feature is not enabled, all elements added to the `attachment_blend_states` vector
    must be exactly the same. If this feature is enabled, elements may be different.
    Either way, use the following values to initialize members of each added element:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在绑定给定图形管线的子通道中使用的每个颜色附件，向 `attachment_blend_states` 向量添加一个新元素。如果 `independentBlend`
    功能未启用，添加到 `attachment_blend_states` 向量中的所有元素必须完全相同。如果此功能已启用，元素可能不同。无论如何，使用以下值初始化每个添加的元素的成员：
- en: A `true` value whether blending should be enabled and otherwise `false` for
    `blendEnable`
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否启用混合的 `true` 值，否则 `blendEnable` 为 `false`
- en: The selected blend factor for the color of the processed (source) fragment for
    `srcColorBlendFactor`
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `srcColorBlendFactor` 选择处理（源）片段的颜色混合因子
- en: The selected blend factor for the color already stored in an (destination) attachment
    for `dstColorBlendFactor`
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `dstColorBlendFactor` 选择已存储在（目标）附件中的颜色的混合因子
- en: The operator used to perform the blending operation on color components for
    `colorBlendOp`
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在颜色分量上执行混合操作的运算符 `colorBlendOp`
- en: The selected blend factor for the alpha value of an incoming (source) fragment
    for `srcAlphaBlendFactor`
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `srcAlphaBlendFactor` 选择用于传入（源）片段的alpha值的混合因子
- en: The selected blend factor for the alpha value already stored in a destination
    attachment for `dstAlphaBlendFactor`
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `dstAlphaBlendFactor` 选择已存储在目标附件中的alpha值的混合因子
- en: The function used to perform the blending operation on alpha components for
    `alphaBlendOp`
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在alpha分量上执行混合操作的函数 `alphaBlendOp`
- en: The color mask used to select which components should be written to in an attachment
    (no matter if blending is enabled or disabled) for `colorWriteMask`
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于选择在附件中写入哪些分量的颜色遮罩 `colorWriteMask`
- en: 'Create a variable of type `VkPipelineColorBlendStateCreateInfo` named `blend_state_create_info`.
    Use these values to initialize its members:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `blend_state_create_info` 的 `VkPipelineColorBlendStateCreateInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO` value for `sType`'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO` 的 `sType` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pNext`'
- en: '`0` value for `flags`'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 值用于 `flags`'
- en: A `true` value if a logical operation should be performed between a fragment's
    color and a color already stored in an attachment (which disables blending) or `false` otherwise
    for `logicOpEnable`.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应在片段的颜色和已存储在附件中的颜色之间执行逻辑运算（这将禁用混合）或否则为 `false`，则 `logicOpEnable` 为 `true`
- en: The type of the logical operation to be performed (if logical operation is enabled)
    for `logicOp`
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行的逻辑运算的类型（如果启用了逻辑运算） `logicOp`
- en: A number of elements in the `attachment_blend_states` vector for `attachmentCount`
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachment_blend_states` 向量中的元素数量 `attachmentCount`'
- en: A pointer to the first element of the `attachment_blend_states` vector for `pAttachments`
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `attachment_blend_states` 向量第一个元素的指针 `pAttachments`
- en: Four floating-point values defining red, green, blue, and alpha components of
    a blend constant used for some of the blending factors for `blendConstants[4]`
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个浮点值定义了用于某些混合因子的混合常数的红色、绿色、蓝色和alpha分量 `blendConstants[4]`
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The blending state is optional and is not required if rasterization is disabled
    or when there are no color attachments in a subpass, in which a given graphics
    pipeline is used.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 混合状态是可选的，如果禁用光栅化或子通道中没有颜色附件，则不需要混合状态，在这种情况下，使用给定的图形管线。
- en: The blending state is used mainly to define the parameters of a blending operation.
    But it also serves other purposes. In it we specify a color mask which selects
    which color components are updated (written to) during rendering. It also controls
    the state of a logical operation. When enabled, one of the specified logical operations
    is performed between a fragment's color and a color already written in a framebuffer.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 混合状态主要用于定义混合操作的参数。但它也服务于其他目的。在其中，我们指定一个颜色遮罩，该遮罩选择在渲染过程中哪些颜色分量被更新（写入）。它还控制逻辑运算的状态。当启用时，在片段的颜色和已经写入帧缓冲区的颜色之间执行一个指定的逻辑运算。
- en: A logical operation is performed only for attachments with integer and normalized
    integer formats.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对具有整数和归一化整数格式的附件执行逻辑运算。
- en: 'Supported logical operations include:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的逻辑运算包括：
- en: '`CLEAR`: Setting the color to zero'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLEAR`：将颜色设置为零'
- en: '`AND`: Bitwise `AND` operation between the source (fragment''s) color and a
    destination color (already stored in an attachment)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND`: 源颜色（片段颜色）和目标颜色（已存储在附件中）之间的位运算“与”'
- en: '`AND_REVERSE`: Bitwise `AND` operation between source and inverted destination
    colors'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND_REVERSE`: 源颜色和反转目标颜色之间的位运算“与”'
- en: '`COPY`: Copying the source (fragment''s) color without any modifications'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`: 无修改地复制源颜色'
- en: '`AND_INVERTED`: Bitwise `AND` operation between destination and inverted source
    colors'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND_INVERTED`: 目标颜色和反转源颜色之间的位运算“与”'
- en: '`NO_OP`: Leaving the already stored color intact'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_OP`: 保持已存储的颜色不变'
- en: '`XOR`: Bitwise excluded `OR` between source and destination colors'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XOR`: 源颜色和目标颜色之间的位运算“异或”'
- en: '`OR`: Bitwise `OR` operation between the source and destination colors'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OR`: 源颜色和目标颜色之间的位运算“或”'
- en: '`NOR`: Inverted bitwise `OR`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOR`: 反转位运算“或”'
- en: '`EQUIVALENT`: Inverted `XOR`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EQUIVALENT`: 反转的`XOR`'
- en: '`INVERT`: Inverted destination color'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVERT`: 反转目标颜色'
- en: '`OR_REVERSE`: Bitwise `OR` between the source color and inverted destination
    color'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OR_REVERSE`: 源颜色和反转目标颜色之间的位运算“或”'
- en: '`COPY_INVERTED`: Copying bitwise inverted source color'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY_INVERTED`: 复制位运算反转的源颜色'
- en: '`OR_INVERTED`: Bitwise `OR` operation between destination and inverted source
    color'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OR_INVERTED`: 目标颜色和反转源颜色之间的位运算“或”'
- en: '`NAND`: Inverted bitwise `AND` operation'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAND`: 反转位运算“与”'
- en: '`SET`: Setting all color bits to ones'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET`: 将所有颜色位设置为1'
- en: Blending is controlled separately for each color attachment used during rendering
    in a subpass in which a given graphics pipeline is bound. This means that we need
    to specify blending parameters for each color attachment used in rendering. But
    we need to remember that if the `independentBlend` feature is not enabled, blending
    parameters for each attachment must be exactly the same.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染过程中，每个颜色附件的混合操作都是独立控制的，这发生在绑定特定图形管道的子通道中。这意味着我们需要为渲染中使用的每个颜色附件指定混合参数。但我们需要记住，如果未启用`independentBlend`功能，每个附件的混合参数必须完全相同。
- en: 'For blending, we specify the source and destination factors separately for
    color components and an alpha component. Supported blend factors include:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混合，我们分别指定颜色组件和alpha组件的源和目标因子。支持的混合因子包括：
- en: '`ZERO`: `0`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZERO`: `0`'
- en: '`ONE`: `1`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE`: `1`'
- en: '`SRC_COLOR`: `<source component>`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC_COLOR`: `<source component>`'
- en: '`ONE_MINUS_SRC_COLOR`: 1 - `<source component>`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_SRC_COLOR`: 1 - `<source component>`'
- en: '`DST_COLOR`: `<destination component>`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DST_COLOR`: `<destination component>`'
- en: '`ONE_MINUS_DST_COLOR`: 1 - `<destination component>`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_DST_COLOR`: 1 - `<destination component>`'
- en: '`SRC_ALPHA`: `<source alpha>`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC_ALPHA`: `<source alpha>`'
- en: '`ONE_MINUS_SRC_ALPHA`: 1 - `<source alpha>`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_SRC_ALPHA`: 1 - `<source alpha>`'
- en: '`DST_ALPHA`: `<destination alpha>`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DST_ALPHA`: `<destination alpha>`'
- en: '`ONE_MINUS_DST_ALPHA`: 1 - `<destination alpha>`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_DST_ALPHA`: 1 - `<destination alpha>`'
- en: '`CONSTANT_COLOR`: `<constant color component>`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTANT_COLOR`: `<constant color component>`'
- en: '`ONE_MINUS_CONSTANT_COLOR`: 1 - `<constant color component>`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_CONSTANT_COLOR`: 1 - `<constant color component>`'
- en: '`CONSTANT_ALPHA`: `<alpha value of a constant color>`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTANT_ALPHA`: `<alpha value of a constant color>`'
- en: '`ONE_MINUS_CONSTANT_ALPHA`: 1 - `<alpha value of a constant color>`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_CONSTANT_ALPHA`: 1 - `<alpha value of a constant color>`'
- en: '`SRC_ALPHA_SATURATE`: `min( <source alpha>, 1 - <destination alpha> )`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC_ALPHA_SATURATE`: `min( <source alpha>, 1 - <destination alpha> )`'
- en: '`SRC1_COLOR`: `<component of a source''s second color>` (used in dual source
    blending)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC1_COLOR`: `<component of a second color>` (used in dual source blending)'
- en: '`ONE_MINUS_SRC1_COLOR`: 1 - `<component of a source''s second color>` (from
    dual source blending)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_SRC1_COLOR`: 1 - `<component of a second color>` (from dual source
    blending)'
- en: '`SRC1_ALPHA`: `<alpha component of a source''s second color>` (in dual source
    blending)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC1_ALPHA`: `<alpha component of a second color>` (in dual source blending)'
- en: '`ONE_MINUS_SRC1_ALPHA`: 1 - `<alpha component of a source''s second color>`
    (from dual source blending)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_SRC1_ALPHA`: 1 - `<source alpha component of a second color>` (from
    dual source blending)'
- en: Some of the blending factors use constant color instead of a fragment's (source)
    color or color already stored in an attachment (destination). This constant color
    may be specified statically during the pipeline creation or dynamically (as one
    of the dynamic pipeline states) by the `vkCmdSetBlendConstants()` function call
    during command buffer recording.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一些混合因子使用常量颜色而不是片段（源）颜色或已存储在附件中的颜色（目标）。此常量颜色可以在管道创建期间静态指定，也可以在命令缓冲区记录期间通过`vkCmdSetBlendConstants()`函数调用动态指定（作为动态管道状态之一）。
- en: Blending factors that use the source's second color (SRC1) may be used only
    when the `dualSrcBlend` feature is enabled.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源的第二颜色（SRC1）的混合因子只能在启用`dualSrcBlend`功能时使用。
- en: 'The blending function that controls how blending is performed is also specified
    separately for color and alpha components. Blending operators include:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 控制混合如何执行的反混函数也分别针对颜色和alpha分量单独指定。混合运算符包括：
- en: '`ADD`: `<src component> * <src factor> + <dst component> * <dst factor>`'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`: `<src component> * <src factor> + <dst component> * <dst factor>`'
- en: '`SUBTRACT`: `<src component> * <src factor> - <dst component> * <dst factor>`'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBTRACT`: `<src component> * <src factor> - <dst component> * <dst factor>`'
- en: '`REVERSE_SUBTRACT`: `<dst component> * <dst factor> - <src component> * <src
    factor>`'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REVERSE_SUBTRACT`: `<dst component> * <dst factor> - <src component> * <src
    factor>`'
- en: '`MIN`: `min( <src component>, <dst component> )`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIN`: `min( <src component>, <dst component> )`'
- en: '`MAX`: `max( <src component>, <dst component> )`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX`: `max( <src component>, <dst component> )`'
- en: Enabling a logical operation disables blending.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 启用逻辑操作将禁用混合。
- en: 'The following is an example of setting up a blend state with both disabled
    logical operation and blending:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个设置带有禁用逻辑操作和混合的反混状态的示例：
- en: '[PRE16]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The implementation of this recipe that fills a variable of the `VkPipelineColorBlendStateCreateInfo`
    type may look like this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此配方的代码，填充`VkPipelineColorBlendStateCreateInfo`类型的变量可能如下所示：
- en: '[PRE17]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)的*渲染通道和帧缓冲区*中，查看以下配方：
- en: '*Specifying subpass descriptions*'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a framebuffer*'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建帧缓冲区*'
- en: In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)的*命令记录和绘制*中，查看以下配方
- en: '*Setting blend constants states dynamically *'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置混合常数状态*'
- en: 'The following recipes in this chapter:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying pipeline rasterization state*'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Specifying pipeline dynamic states
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定管线动态状态
- en: Creating a graphics pipeline requires us to provide lots of parameters. What's
    more, once set, these parameters can't be changed. Such an approach was taken
    to improve the performance of our application and present a stable and predictable
    environment to the driver. But, unfortunately, it is also uncomfortable for developers
    as they may need to create many pipeline objects with almost identical states
    that differ only in small details.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图形管线需要我们提供大量的参数。更重要的是，一旦设置，这些参数就不能更改。这种做法是为了提高我们应用程序的性能，并为驱动程序提供一个稳定且可预测的环境。但是，不幸的是，这对开发者来说也很不方便，因为他们可能需要创建许多几乎完全相同但只有细微差别的管线对象。
- en: To circumvent this problem, dynamic states were introduced. They allow us to
    control some of the pipeline's parameters dynamically by recording specific functions
    in command buffers. And in order to do that, we need to specify which parts of
    the pipeline are dynamic. This is done by specifying pipeline dynamic states.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，引入了动态状态。它们允许我们通过在命令缓冲区中记录特定函数来动态地控制管线的一些参数。为了做到这一点，我们需要指定管线中哪些部分是动态的。这是通过指定管线动态状态来完成的。
- en: How to do it...
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a variable of type `std::vector<VkDynamicState>` named `dynamic_states`.
    For each (unique) pipeline state that should be set dynamically, add a new element
    to the `dynamic_states` vector. The following values can be used:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dynamic_states`的`std::vector<VkDynamicState>`类型的变量。对于每个应该动态设置的（唯一）管线状态，向`dynamic_states`向量中添加一个新元素。以下值可以使用：
- en: '`VK_DYNAMIC_STATE_VIEWPORT`'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_VIEWPORT`'
- en: '`VK_DYNAMIC_STATE_SCISSOR`'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_SCISSOR`'
- en: '`VK_DYNAMIC_STATE_LINE_WIDTH`'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_LINE_WIDTH`'
- en: '`VK_DYNAMIC_STATE_DEPTH_BIAS`'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_DEPTH_BIAS`'
- en: '`VK_DYNAMIC_STATE_BLEND_CONSTANTS`'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_BLEND_CONSTANTS`'
- en: '`VK_DYNAMIC_STATE_DEPTH_BOUNDS`'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_DEPTH_BOUNDS`'
- en: '`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK`'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK`'
- en: '`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK`'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK`'
- en: '`VK_DYNAMIC_STATE_STENCIL_REFERENCE`'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DYNAMIC_STATE_STENCIL_REFERENCE`'
- en: 'Create a variable of type `VkPipelineDynamicStateCreateInfo` named `dynamic_state_creat_info`.
    Use the following values to initialize its members:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dynamic_state_creat_info`的`VkPipelineDynamicStateCreateInfo`类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO` value for `sType`'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO`值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`值用于`pNext`'
- en: '`0` value for `flags`'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的`0`值'
- en: The number of elements in the `dynamic_states` vector for `dynamicStateCount`
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamicStateCount`的`dynamic_states`向量中的元素数量'
- en: A pointer to the first element of the `dynamic_states` vector for `pDynamicStates`
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic_states`向量的第一个元素的指针用于`pDynamicStates`'
- en: How it works...
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Dynamic pipeline states were introduced to allow for some flexibility in setting
    the state of pipeline objects. There may not be too many different parts of the
    pipeline that can be set during command buffer recording, but the selection is
    a compromise between the performance, the simplicity of a driver, the capabilities
    of modern hardware, and the API's ease of use.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 动态管道状态被引入，以允许在设置管道对象的状态时具有一定的灵活性。在命令缓冲区记录期间可能没有太多不同的管道部分可以设置，但选择是在性能、驱动程序的简单性、现代硬件的能力和API易用性之间的一种折衷。
- en: A dynamic state is optional. If we don't want to set any part of the pipeline
    dynamically, we don't need to do it.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 动态状态是可选的。如果我们不想动态设置管道的任何部分，我们不需要这样做。
- en: 'The following parts of the graphics pipeline can be set dynamically:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图形管道的部分可以动态设置：
- en: '**Viewport**: Parameters for all viewports are set through the `vkCmdSetViewport()`
    function call, but the number of viewports is still defined during the pipeline
    creation (refer to the *Specifying pipeline viewport and scissor test state* recipe)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视口**：所有视口的参数通过`vkCmdSetViewport()`函数调用设置，但视口数量仍在管道创建期间定义（参考*指定管道视口和剪裁测试状态*配方）'
- en: '**Scissor**: Parameters controlling the scissor test are set through the `vkCmdSetScissor()`
    function call, though the number of rectangles used for the scissor test are defined
    statically during the pipeline creation and must be the same as the number of
    viewports (refer to the *Specifying pipeline viewport and scissor test state*
    recipe)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剪裁**：控制剪裁测试的参数通过`vkCmdSetScissor()`函数调用设置，尽管用于剪裁测试的矩形数量在管道创建期间静态定义，并且必须与视口数量相同（参考*指定管道视口和剪裁测试状态*配方）'
- en: '**Line width**: The width of drawn lines is specified not in a graphics pipeline''s
    state but through the `vkCmdSetLineWidth()` function (refer to the *Specifying
    pipeline rasterization state* recipe)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线宽**：绘制线的宽度不是在图形管道的状态中指定，而是通过`vkCmdSetLineWidth()`函数（参考*指定管道光栅化状态*配方）'
- en: '**Depth bias**: When enabled, the depth bias constant factor, slope factor,
    and maximum (or minimum) bias applied to a fragment''s calculated depth value
    are defined through recording the `vkCmdSetDepthBias()` function (refer to the
    *Specifying pipeline depth and stencil state* recipe)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度偏差**：当启用时，片段计算深度值所应用的深度偏差常数因子、斜率因子和最大（或最小）偏差通过记录`vkCmdSetDepthBias()`函数定义（参考*指定管道深度和模板状态*配方）'
- en: '**Depth bounds**: When the depth bounds test is enabled, minimum and maximum
    values used during the test are specified with the `vkCmdSetDepthBounds()` function
    (refer to the *Specifying pipeline depth and stencil state* recipe)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度范围**：当启用深度范围测试时，测试期间使用的最小和最大值通过`vkCmdSetDepthBounds()`函数指定（参考*指定管道深度和模板状态*配方）'
- en: '**Stencil compare mask**: Specific bits of stencil values used during the stencil
    test are defined with the `vkCmdSetStencilCompareMask()` function call (refer
    to the *Specifying pipeline depth and stencil state* recipe)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板比较掩码**：在模板测试期间使用的模板值的特定位通过`vkCmdSetStencilCompareMask()`函数调用定义（参考*指定管道深度和模板状态*配方）'
- en: '**Stencil write mask**: Specifying which bits may be updated in a stencil attachment
    is done through the `vkCmdSetStencilWriteMask()` function (refer to the *Specifying
    pipeline depth and stencil state* recipe)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板写入掩码**：通过`vkCmdSetStencilWriteMask()`函数指定在模板附加中可以更新的位（参考*指定管道深度和模板状态*配方）'
- en: '**Stencil reference value**: Setting the reference value used during the stencil
    test is performed with the `vkCmdSetStencilReference()` function call (refer to
    the *Specifying pipeline depth and stencil state* recipe)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板参考值**：通过`vkCmdSetStencilReference()`函数调用执行在模板测试期间使用的参考值的设置（参考*指定管道深度和模板状态*配方）'
- en: '**Blend constants**: Four floating-point values for red, green, blue, and alpha
    components of a blend constant are specified by recording a `vkCmdSetBlendConstants()` function
    (refer to the *Specifying pipeline blend state* recipe)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合常数**：通过记录`vkCmdSetBlendConstants()`函数指定混合常数的红色、绿色、蓝色和alpha分量的四个浮点值（参考*指定管道混合状态*配方）'
- en: 'Specifying that a given state is set dynamically is done by creating an array
    (or a vector) of `VkDynamicState` enums with values corresponding to the chosen
    states and providing the array (named `dynamic_states` in the following code)
    to the variable of a `VkPipelineDynamicStateCreateInfo` type like this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个`VkDynamicState`枚举值的数组（或向量），其中包含对应于所选状态的值，并将该数组（在以下代码中命名为`dynamic_states`）提供给`VkPipelineDynamicStateCreateInfo`类型的变量来指定给定状态是动态设置的：
- en: '[PRE18]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying pipeline viewport and scissor test state*'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线视口和剪裁测试状态*'
- en: '*Specifying pipeline rasterization state*'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Specifying pipeline depth and stencil state*'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线深度和模板状态*'
- en: '*Specifying pipeline blend state*'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线混合状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，“命令录制与绘制”中，查看以下食谱：
- en: '*Setting viewport state dynamically*'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置视口状态*'
- en: '*Setting scissors state dynamically*'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置剪裁状态*'
- en: '*Setting depth bias state dynamically*'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置深度偏移状态*'
- en: '*Setting blend constants state dynamically*'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态设置混合常数状态*'
- en: Creating a pipeline layout
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管道布局
- en: Pipeline layouts are similar to descriptor set layouts. Descriptor set layouts
    are used to define what types of resources form a given descriptor set. Pipeline
    layouts define what types of resources can be accessed by a given pipeline. They
    are created from descriptor set layouts and, additionally, push constant ranges.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 管道布局类似于描述符集布局。描述符集布局用于定义构成给定描述符集的资源类型。管道布局定义了给定管道可以访问的资源类型。它们从描述符集布局创建，并且还包含推送常量范围。
- en: Pipeline layouts are needed for the pipeline creation as they specify the interface
    between shader stages and shader resources through a set, binding, array element
    address. The same address needs to be used in shaders (through a layout qualifier)
    so they can successfully access a given resource. But even if a given pipeline
    doesn't use any descriptor resources, we need to create a pipeline layout to inform
    the driver that no such interface is needed.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 管道布局在管道创建时是必需的，因为它们通过一组、绑定、数组元素地址指定了着色器阶段和着色器资源之间的接口。相同的地址需要在着色器中（通过布局限定符）使用，以便它们可以成功访问给定的资源。即使给定的管道不使用任何描述符资源，我们也需要创建一个管道布局来通知驱动程序不需要此类接口。
- en: How to do it...
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device stored in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为`logical_device`的`VkDevice`类型变量中的逻辑设备的句柄。
- en: Create a `std::vector` variable named `descriptor_set_layouts` with elements
    of type `VkDescriptorSetLayout`. For each descriptor set, through which resources
    will be accessed from shaders in a given pipeline, add a descriptor set layout
    to the `descriptor_set_layouts` vector.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`descriptor_set_layouts`的`std::vector`变量，其元素类型为`VkDescriptorSetLayout`。对于每个描述符集，通过它将从给定管道中的着色器访问资源，将描述符集布局添加到`descriptor_set_layouts`向量中。
- en: 'Create a `std::vector<VkPushConstantRange>` variable named `push_constant_ranges`.
    Add new elements to this vector for each separate range (a unique set of push
    constants used by different shader stages) and use the following values to initialize
    its members:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`push_constant_ranges`的`std::vector<VkPushConstantRange>`变量。为每个单独的范围（不同着色器阶段使用的唯一推送常量集）添加新元素到这个向量，并使用以下值来初始化其成员：
- en: A logical `OR` of all shader stages that access a given push constant for `stageFlags`
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有访问给定`stageFlags`的推送常量的着色器阶段的逻辑`OR`
- en: The value that is a multiple of 4 for the offset at which a given push constant
    starts in memory for `offset`
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`offset`，给定推送常量在内存中开始的偏移量是4的倍数的值
- en: The value that is a multiple of 4 for the size of a memory for a given push
    constant for `size`
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`size`，给定推送常量在内存中大小的4的倍数的值
- en: 'Create a variable of type `VkPipelineLayoutCreateInfo` named `pipeline_layout_create_info`.
    Use the following values to initialize its members:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pipeline_layout_create_info`的`VkPipelineLayoutCreateInfo`类型的变量。使用以下值来初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO` value for `sType`'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO`值用于`sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext`的`nullptr`值'
- en: '`0` value for `flags`'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`的`0`值'
- en: The number of elements in the `descriptor_set_layouts` vector for `setLayoutCount`
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptor_set_layouts`向量中`setLayoutCount`的元素数量'
- en: A pointer to the first element of the `descriptor_set_layouts` vector for `pSetLayouts`
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pSetLayouts` 的 `descriptor_set_layouts` 向量首个元素的指针'
- en: The number of elements in the `push_constant_ranges` vector for `pushConstantRangeCount`
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_constant_ranges` 向量中 `pushConstantRangeCount` 的元素数量'
- en: A pointer to the first element of the `push_constant_ranges` for `pPushConstantRanges`
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pPushConstantRanges` 的 `push_constant_ranges` 首个元素的指针'
- en: Create a variable of type `VkPipelineLayout` named `pipeline_layout`, in which
    the handle of the created pipeline layout will be stored.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pipeline_layout` 的 `VkPipelineLayout` 类型的变量，其中将存储创建的管道布局的句柄。
- en: 'Make the following call: `vkCreatePipelineLayout( logical_device, &pipeline_layout_create_info,
    nullptr, &pipeline_layout )` for which provide the `logical_device` variable,
    a pointer to the `pipeline_layout_create_info` variable, a `nullptr` value, and
    a pointer to the `pipeline_layout` variable.'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下调用：`vkCreatePipelineLayout( logical_device, &pipeline_layout_create_info,
    nullptr, &pipeline_layout )`，其中提供 `logical_device` 变量，`pipeline_layout_create_info`
    变量的指针，一个 `nullptr` 值，以及 `pipeline_layout` 变量的指针。
- en: Make sure the call was successful by checking if it returned the `VK_SUCCESS`
    value.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查它是否返回了 `VK_SUCCESS` 值来确保调用成功。
- en: How it works...
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A pipeline layout defines the set of resources that can be accessed from shaders
    of a given pipeline. When we record command buffers, we bind descriptor sets to
    selected indices (refer to the *Binding descriptor sets* recipe). This index corresponds
    to a descriptor set layout at the same index in the array used during the pipeline
    layout creation (the `descriptor_set_layouts` vector from this recipe). The same
    index needs to be specified inside shaders through a `layout( set = <index>, binding
    = <number> )` qualifier for the given resource to be properly accessed.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 管道布局定义了可以从给定管道的着色器访问的资源集合。当我们记录命令缓冲区时，我们将描述符集绑定到选定的索引（参考 *绑定描述符集* 菜谱）。此索引对应于在管道布局创建期间使用的数组中相同索引的描述符集布局（本菜谱中的
    `descriptor_set_layouts` 向量）。相同的索引需要在着色器内部通过 `layout( set = <index>, binding =
    <number> )` 限定符指定，以便正确访问给定的资源。
- en: '![](img/B05542-08-03-1.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05542-08-03-1.png)'
- en: Usually, multiple pipelines will access different resources. During command
    buffer recording, we bind a given pipeline and descriptor sets. Only after that
    can we issue drawing commands. When we switch from one pipeline to another, we
    need to bind new descriptor sets according to the pipeline's needs. But frequently
    binding different descriptor sets may impact the performance of our application.
    That's why it is good to create pipelines with similar (or compatible) layouts
    and bind descriptor sets that do not change too often (that are common for many
    pipelines) to indices near the 0 (or near the start of a layout). This way, when
    we switch pipelines, descriptor sets near the start of the pipeline layout (from
    index 0 to some index N) can still be used and don't need to be updated. It is
    only necessary to bind the different descriptor sets--those that are placed at
    greater indices (after the given index N). But one additional condition must be
    met-- to be similar (or compatible), the pipeline layouts must use the same push
    constant ranges.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，多个管道会访问不同的资源。在命令缓冲区记录期间，我们绑定一个给定的管道和描述符集。只有在此之后，我们才能发出绘图命令。当我们从一个管道切换到另一个管道时，我们需要根据管道的需求绑定新的描述符集。但频繁地绑定不同的描述符集可能会影响我们应用程序的性能。这就是为什么创建具有相似（或兼容）布局的管道，并将不经常更改（对许多管道来说是共有的）的描述符集绑定到接近
    0（或布局的起始部分）的索引是很好的。这样，当我们切换管道时，管道布局起始部分的描述符集（从索引 0 到某个索引 N）仍然可以使用，并且不需要更新。只需要绑定不同的描述符集——那些放置在更高索引（在给定索引
    N 之后）的描述符集。但必须满足一个额外条件——为了相似（或兼容），管道布局必须使用相同的推送常量范围。
- en: We should bind descriptor sets that are common for many pipelines near the start
    of a pipeline layout (near the `0`^(th) index).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在管道布局的起始部分（接近 `0`^(th) 索引）绑定许多管道共有的描述符集。
- en: Pipeline layouts also define the ranges of push constants. They allow us to
    provide a small set of constant values to shaders. They are much faster than updating
    descriptor sets, but memory that can be consumed by push constants is also much
    smaller--it is at least 128 bytes for all ranges defined in a pipeline layout.
    Different hardware may offer more memory for push constants, but we can't rely
    on it if we target hardware from various vendors.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 管线布局还定义了推送常量的范围。它们允许我们向着色器提供一组小的常量值。它们比更新描述符集要快得多，但可以被推送常量消耗的内存也小得多——对于管线布局中定义的所有范围，至少是128字节。不同的硬件可能为推送常量提供更多的内存，但我们不能依赖于它，如果我们针对来自不同供应商的硬件。
- en: As an example, when we want to define a different range for each stage in a
    graphics pipeline, we have more or less 128 / 5 = 26 bytes per stage for a push
    constant. Of course, we can define ranges that are common for multiple shader
    stages. But each shader stage may have access to only one push constant range.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们想要为图形管线中的每个阶段定义不同的范围时，每个阶段大约有128 / 5 = 26字节的推送常量。当然，我们可以定义适用于多个着色器阶段的公共范围。但每个着色器阶段可能只能访问一个推送常量范围。
- en: The preceding example is the worst case. Usually not all stages will use different
    push constant ranges. Quite commonly, stages won't require access to a push constant
    range at all. So there should be enough memory for several 4-component vectors
    or a matrix or two.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是最坏的情况。通常，不是所有阶段都会使用不同的推送常量范围。相当常见的是，阶段可能根本不需要访问推送常量范围。因此，应该有足够的内存来存储几个4分量向量或一个矩阵或两个。
- en: Each pipeline stage can access only one push constant range.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管线阶段只能访问一个推送常量范围。
- en: We also need to remember that the size and an offset of a push constant range
    must be a multiple of 4.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住，推送常量范围的尺寸和偏移量必须是4的倍数。
- en: 'In the following code, we can see a source code that implements this recipe.
    Descriptor set layouts and ranges of push constants are provided through `descriptor_set_layouts`
    and `push_constant_ranges` variables, respectively:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们可以看到一个实现此食谱的源代码。描述符集布局和推送常量范围分别通过`descriptor_set_layouts`和`push_constant_ranges`变量提供：
- en: '[PRE19]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，查看以下食谱：
- en: '*Binding descriptor sets*'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*，查看以下食谱：
- en: '*Writing a vertex shader that multiplies vertex position by a projection matrix*'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个乘以投影矩阵的顶点着色器*'
- en: '*Using push constants in shaders*'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'The following recipes in this chapter:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a graphics pipeline*'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: '*Creating a pipeline layout with push constants, sampled image, and a buffer*'
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用推送常量、采样图像和缓冲区创建管线布局*'
- en: '*Destroying a pipeline layout*'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管线布局*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*，查看以下食谱：
- en: '*Providing data to shaders through push constants*'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: Specifying graphics pipeline creation parameters
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定图形管线创建参数
- en: Creating a graphics pipeline requires us to prepare many parameters controlling
    its many different aspects. All these parameters are grouped into a variable of
    type `VkGraphicsPipelineCreateInfo` which needs to be properly initialized before
    we can use it to create a pipeline.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图形管线需要我们准备许多控制其许多不同方面的参数。所有这些参数都被组合到一个类型为`VkGraphicsPipelineCreateInfo`的变量中，在我们可以使用它来创建管线之前，需要正确初始化它。
- en: How to do it...
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a variable of a bitfield type `VkPipelineCreateFlags` named `additional_options`
    through which provide additional pipeline creation options:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名为`additional_options`的`VkPipelineCreateFlags`位字段类型变量创建一个变量，通过它提供额外的管线创建选项：
- en: '**Disable optimization**: specifies that the created pipeline won''t be optimized,
    but the creation process may be faster'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用优化**：指定创建的管线不会被优化，但创建过程可能会更快'
- en: '**Allow derivatives**: specifies that other pipelines may be created from it'
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许派生**：指定其他管线可以从它创建'
- en: '**Derivative**: specifies that this pipeline will be created based on another,
    already created pipeline'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导数**：指定此管线将基于另一个已创建的管线创建'
- en: Create a variable of type `std::vector<VkPipelineShaderStageCreateInfo>` named
    `shader_stage_create_infos`. For each shader stage enabled in a given pipeline,
    add a new element to the `shader_stage_create_infos` vector, specifying the stage's
    parameters. At least the vertex shader stage must be present in the `shader_stage_create_infos`
    vector (refer to the *Specifying pipeline shader stages* recipe).
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `shader_stage_create_infos` 的 `std::vector<VkPipelineShaderStageCreateInfo>`
    类型的变量。对于在给定的管线中启用的每个着色器阶段，向 `shader_stage_create_infos` 向量中添加一个新元素，指定该阶段的参数。至少顶点着色器阶段必须在
    `shader_stage_create_infos` 向量中（参考 *指定管线着色器阶段* 菜谱）。
- en: Create a variable of type `VkPipelineVertexInputStateCreateInfo` named `vertex_input_state_create_info`
    through which vertex bindings, attributes, and input state are specified (refer
    to the *Specifying pipeline vertex binding description, attribute description,
    and input state* recipe).
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `vertex_input_state_create_info` 的 `VkPipelineVertexInputStateCreateInfo`
    类型的变量来指定顶点绑定、属性和输入状态（参考 *指定管线顶点绑定描述、属性描述和输入状态* 菜谱）。
- en: Create a variable of type `VkPipelineInputAssemblyStateCreateInfo` named `input_assembly_state_create_info`.
    Use it to define how drawn vertices are assembled into polygons (refer to the
    *Specifying pipeline input assembly state* recipe).
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `input_assembly_state_create_info` 的 `VkPipelineInputAssemblyStateCreateInfo`
    类型的变量。使用它来定义如何将绘制的顶点组装成多边形（参考 *指定管线输入组装状态* 菜谱）。
- en: If a tessellation should be enabled in a given pipeline, create a variable of
    type `VkPipelineTessellationStateCreateInfo` named `tessellation_state_create_info`
    in which the number of control points forming a patch is defined (refer to the
    *Specifying pipeline tessellation state* recipe).
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在给定的管线中应该启用细分，则创建一个名为 `tessellation_state_create_info` 的 `VkPipelineTessellationStateCreateInfo`
    类型的变量，在其中定义构成补丁的控制点的数量（参考 *指定管线细分状态* 菜谱）。
- en: If a rasterization process won't be disabled in a given pipeline, create a variable
    of type `VkPipelineViewportStateCreateInfo` named `viewport_state_create_info`.
    In the variable, specify viewport and scissor test parameters (refer to the *Specifying
    pipeline viewport and scissor test state* recipe).
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在给定的管线中不会禁用光栅化过程，则创建一个名为 `viewport_state_create_info` 的 `VkPipelineViewportStateCreateInfo`
    类型的变量。在该变量中，指定视口和裁剪测试参数（参考 *指定管线视口和裁剪测试状态* 菜谱）。
- en: Create a variable of type `VkPipelineRasterizationStateCreateInfo` named `rasterization_state_create_info`
    that defines the properties of a rasterization (refer to the *Specifying pipeline
    rasterization state* recipe).
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `rasterization_state_create_info` 的 `VkPipelineRasterizationStateCreateInfo`
    类型的变量，该变量定义了光栅化的属性（参考 *指定管线光栅化状态* 菜谱）。
- en: If rasterization is enabled in a given pipeline, create a variable of type `VkPipelineMultisampleStateCreateInfo`
    named `multisample_state_create_info` that defines multisampling (anti-aliasing)
    parameters (refer to the *Specifying pipeline multisample state* recipe).
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在给定的管线中启用了光栅化，则创建一个名为 `multisample_state_create_info` 的 `VkPipelineMultisampleStateCreateInfo`
    类型的变量，该变量定义了多采样（抗锯齿）参数（参考 *指定管线多采样状态* 菜谱）。
- en: If rasterization is active and depth and/or stencil attachments are used during
    drawing with a given pipeline bound, create a variable of type `VkPipelineDepthStencilStateCreateInfo`
    named `depth_and_stencil_state_create_info`. Use it to define parameters of depth
    and stencil tests (refer to the *Specifying pipeline depth and stencil state*
    recipe).
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在给定的管线中绘制时启用了光栅化并且使用了深度和/或模板附件，则创建一个名为 `depth_and_stencil_state_create_info`
    的 `VkPipelineDepthStencilStateCreateInfo` 类型的变量。使用它来定义深度和模板测试的参数（参考 *指定管线深度和模板状态*
    菜谱）。
- en: If rasterization is not disabled, create a variable of type `VkPipelineColorBlendStateCreateInfo`
    named `blend_state_create_info` through which to specify parameters of operations
    performed on fragments (refer to the *Specifying pipeline blend state* recipe).
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有禁用光栅化，则创建一个名为 `blend_state_create_info` 的 `VkPipelineColorBlendStateCreateInfo`
    类型的变量，通过它来指定对片段执行操作时的参数（参考 *指定管线混合状态* 菜谱）。
- en: If there are parts of the pipeline which should be set dynamically, create a
    variable of type `VkPipelineDynamicStateCreateInfo` named `dynamic_state_creat_info`
    that defines those dynamically set parts (refer to the *Specifying pipeline dynamic
    states* recipe).
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果管线中有一部分应该动态设置，则创建一个名为 `dynamic_state_creat_info` 的 `VkPipelineDynamicStateCreateInfo`
    类型的变量，该变量定义了那些动态设置的部件（参考 *指定管线动态状态* 菜谱）。
- en: Create a pipeline layout and store its handle in a variable of type `VkPipelineLayout`
    named `pipeline_layout`.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管线布局并将它的句柄存储在一个名为 `pipeline_layout` 的 `VkPipelineLayout` 类型的变量中。
- en: Take the handle of a render pass in which drawing with a given pipeline bound
    will be performed. Use the render pass handle to initialize a variable of type
    `VkRenderPass` named `render_pass` (refer to the *Creating a render pass* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*).
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个渲染通道中获取句柄，该通道将使用给定的管线绑定进行绘制。使用渲染通道句柄初始化一个名为 `render_pass` 的 `VkRenderPass`
    类型的变量（参考第 6 章 *创建渲染通道* 的配方，*渲染通道和帧缓冲区*）。
- en: Create a variable of type `uint32_t` named `subpass`. Store the index of the
    render pass's subpass in which a given pipeline will be used during drawing operations
    (refer to the *Specifying subpass descriptions* recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `subpass` 的 `uint32_t` 类型的变量。存储在绘制操作期间将使用给定管线的渲染通道的子通道索引（参考第 6 章 *指定子通道描述*
    的配方，*渲染通道和帧缓冲区*）。
- en: 'Create a variable of type `VkGraphicsPipelineCreateInfo` named `graphics_pipeline_create_info`.
    Use the following values to initialize its members:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `graphics_pipeline_create_info` 的 `VkGraphicsPipelineCreateInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO` value for `sType`'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `sType`，提供一个 `VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO` 值。
- en: '`nullptr` value for `pNext`'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `pNext`，提供一个 `nullptr` 值。
- en: '`additional_options` variable for `flags`'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `flags`，提供一个 `additional_options` 变量。
- en: The number of elements in the `shader_stage_create_infos` vector for `stageCount`
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `stageCount`，提供 `shader_stage_create_infos` 向量中元素的数量。
- en: A pointer to the first element of the `shader_stage_create_infos` vector for
    `pStages`
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `pStages`，提供一个指向 `shader_stage_create_infos` 向量第一个元素的指针。
- en: A pointer to the `vertex_input_state_create_info` variable for `pVertexInputState`
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `pVertexInputState`，提供一个指向 `vertex_input_state_create_info` 变量的指针。
- en: A pointer to the `input_assembly_state_create_info` variable for `pInputAssemblyState`
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `pInputAssemblyState`，提供一个指向 `input_assembly_state_create_info` 变量的指针。
- en: A pointer to the `tessellation_state_create_info` variable if tessellation should
    be active or a `nullptr` value if tessellation should be disabled for `pTessellationState`
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要激活细分，则提供一个指向 `tessellation_state_create_info` 变量的指针，否则如果需要禁用细分，则对于 `pTessellationState`
    提供一个 `nullptr` 值。
- en: A pointer to the `viewport_state_create_info` variable if rasterization is active
    or a `nullptr` value if rasterization is disabled for `pViewportState`
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果光栅化是激活的，则提供一个指向 `viewport_state_create_info` 变量的指针，或者如果光栅化被禁用，则对于 `pViewportState`
    提供一个 `nullptr` 值。
- en: A pointer to the `rasterization_state_create_info` variable for `pRasterizationState`
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `pRasterizationState`，提供一个指向 `rasterization_state_create_info` 变量的指针。
- en: A pointer to the `multisample_state_create_info` variable if rasterization is
    enabled and a `nullptr` value otherwise for `pMultisampleState`
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果光栅化被启用，则提供一个指向 `multisample_state_create_info` 变量的指针，否则对于 `pMultisampleState`
    提供一个 `nullptr` 值。
- en: A pointer to the `depth_and_stencil_state_create_info` variable if rasterization
    is enabled and there is a depth and/or stencil attachment used in the `subpass`
    or a `nullptr` value otherwise for `pDepthStencilState`
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果光栅化被启用并且 `subpass` 中使用了深度和/或模板附件，则提供一个指向 `depth_and_stencil_state_create_info`
    变量的指针，否则对于 `pDepthStencilState` 提供一个 `nullptr` 值。
- en: A pointer to the `blend_state_create_info` variable if rasterization is enabled
    and there is a color attachment used in the `subpass` or a `nullptr` value otherwise
    for `pColorBlendState`
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果光栅化被启用并且 `subpass` 中使用了颜色附件，则提供一个指向 `blend_state_create_info` 变量的指针，否则对于 `pColorBlendState`
    提供一个 `nullptr` 值。
- en: A pointer to the `dynamic_state_creat_info` variable if there are parts of the
    pipeline that should be setup dynamically, or a `nullptr` value if the whole pipeline
    is prepared statically for `pDynamicState`
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管线中有一部分需要动态设置，则提供一个指向 `dynamic_state_creat_info` 变量的指针，或者对于 `pDynamicState`，如果整个管线都是静态准备的，则提供一个
    `nullptr` 值。
- en: The `pipeline_layout` variable for `layout`
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `layout`，提供一个 `pipeline_layout` 变量。
- en: The `render_pass` variable for `renderPass`
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `renderPass`，提供一个 `render_pass` 变量。
- en: The `subpass` variable for `subpass`
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `subpass`，提供一个 `subpass` 变量。
- en: If the pipeline should derive from another, already created pipeline, provide
    the handle of the parent pipeline, otherwise provide a `VK_NULL_HANDLE` for `basePipelineHandle`
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管线应该从另一个已创建的管线派生，则提供父管线的句柄，否则对于 `basePipelineHandle` 提供一个 `VK_NULL_HANDLE`。
- en: If a pipeline should derive from another pipeline that is created within the
    same batch of pipelines, provide the index of a parent pipeline, otherwise provide
    a `-1` value for `basePipelineIndex`
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管线应该从同一批管线中创建的另一个管线派生，则提供父管线的索引，否则对于 `basePipelineIndex` 提供一个 `-1` 值。
- en: How it works...
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Preparing data for a graphics pipeline creation is performed in multiple steps
    and each step specifies different parts of a graphics pipeline. All of these parameters
    are gathered in a variable of type `VkGraphicsPipelineCreateInfo`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为创建图形管道准备数据是分多个步骤进行的，每个步骤指定图形管道的不同部分。所有这些参数都汇总在一个类型为 `VkGraphicsPipelineCreateInfo`
    的变量中。
- en: During the pipeline creation, we can provide many parameters of type `VkGraphicsPipelineCreateInfo`,
    each one specifying attributes of a single pipeline that will be created.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道创建过程中，我们可以提供许多类型为 `VkGraphicsPipelineCreateInfo` 的参数，每个参数指定将要创建的单个管道的属性。
- en: When a graphics pipeline is created, we can use it for drawing by binding it
    to the command buffer before recording a drawing command. Graphics pipelines can
    be bound to command buffers only inside render passes (after the beginning of
    a render pass is recorded). During the pipeline creation, we specify inside which
    render pass a given pipeline will be used. However, we are not limited only to
    the provided render pass. We can also use the same pipeline with other render
    passes if they are compatible with the specified one (refer to the Creating a
    render pass recipe from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建图形管道时，我们可以在记录绘图命令之前将其绑定到命令缓冲区来用于绘图。图形管道只能在渲染通道内（在记录渲染通道的开始之后）绑定到命令缓冲区。在管道创建过程中，我们指定给定管道将在哪个渲染通道中使用。然而，我们不仅限于提供的渲染通道。如果它们与指定的渲染通道兼容，我们还可以使用相同的管道。请参阅第
    6 章（2de4339d-8912-440a-89a6-fd1f84961448.xhtml）中的“创建渲染通道”菜谱，*渲染通道和帧缓冲区*。
- en: It is a rare situation when each created pipeline doesn't have any common state
    with other pipelines. That's why, to speed up the pipeline creation, it is possible
    to specify that a pipeline can be a parent of other pipelines (allow derivatives)
    or that the pipeline will be a child of (derived from) another pipeline. To use
    this feature and shorten the time needed to create a pipeline, we can use `basePipelineHandle`
    or `basePipelineIndex` members of variables of type `VkGraphicsPipelineCreateInfo`
    (the `graphics_pipeline_create_info` variable in this recipe).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 每个创建的管道与其他管道没有任何共同状态的情况是很少见的。这就是为什么，为了加快管道创建速度，可以指定一个管道可以作为其他管道的父级（允许派生）或者该管道将成为另一个管道的子级（从另一个管道派生）。为了使用此功能并缩短创建管道所需的时间，我们可以使用
    `VkGraphicsPipelineCreateInfo` 变量的 `basePipelineHandle` 或 `basePipelineIndex`
    成员（在这个菜谱中的 `graphics_pipeline_create_info` 变量）。
- en: The `basePipelineHandle` member allows us to specify a handle of an already
    created pipeline, which should be a parent of the newly created one.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`basePipelineHandle` 成员允许我们指定一个已创建管道的句柄，该句柄应该是新创建管道的父级。'
- en: The `basePipelineIndex` member is used when we create multiple pipelines at
    once. Through it we specify an index into the array with elements of type `VkGraphicsPipelineCreateInfo`
    provided to the `vkCreateGraphicsPipelines()` function. This index points to a
    parent pipeline that will be created along with the child pipeline in the same,
    single function call. As they are created together, we can't provide a handle,
    that's why there is a separate field for an index. One requirement is that the
    index of a parent pipeline must be smaller than the index of a child pipeline
    (it must appear earlier in the list of `VkGraphicsPipelineCreateInfo` elements,
    before the element that describes the derived pipeline).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`basePipelineIndex` 成员在同时创建多个管道时使用。通过它，我们指定 `vkCreateGraphicsPipelines()` 函数提供的
    `VkGraphicsPipelineCreateInfo` 类型元素数组的索引。此索引指向将在同一函数调用中与子管道一起创建的父级管道。由于它们是同时创建的，我们不能提供句柄，这就是为什么有一个单独的索引字段。一个要求是父级管道的索引必须小于子级管道的索引（它必须在
    `VkGraphicsPipelineCreateInfo` 元素列表中先出现，在描述派生管道的元素之前）。'
- en: We can't use both `basePipelineHandle` and `basePipelineIndex` members; we can
    provide value only for one of them. If we want to specify a handle, we must provide
    a `-1` value for the `basePipelineIndex` field. If we want to specify an index,
    we need to provide a `VK_NULL_HANDLE` value for the `basePipelineHandle` member.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能同时使用 `basePipelineHandle` 和 `basePipelineIndex` 成员；我们只能提供一个值。如果我们想指定句柄，我们必须为
    `basePipelineIndex` 字段提供一个 `-1` 值。如果我们想指定索引，我们需要为 `basePipelineHandle` 成员提供一个
    `VK_NULL_HANDLE` 值。
- en: 'The rest of the parameters are described in earlier recipes of this chapter.
    The following is an example of how to use them to initialize the members of the
    variable of type `VkGraphicsPipelineCreateInfo`:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面的食谱中描述了其余的参数。以下是如何使用它们来初始化 `VkGraphicsPipelineCreateInfo` 类型变量的成员的示例：
- en: '[PRE20]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying pipeline shader stages*'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线着色器阶段*'
- en: '*Specifying pipeline vertex binding description, attribute description, and
    input state*'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线顶点绑定描述、属性描述和输入状态*'
- en: '*Specifying pipeline input assembly state*'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线输入装配状态*'
- en: '*Specifying pipeline tessellation state*'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线细分状态*'
- en: '*Specifying pipeline viewport and scissor test state*'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线视口和剪裁测试状态*'
- en: '*Specifying pipeline rasterization state*'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Specifying pipeline multisample state*'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线多采样状态*'
- en: '*Specifying pipeline depth and stencil state*'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线深度和模板状态*'
- en: '*Specifying pipeline blend state*'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线混合状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线动态状态*'
- en: '*Creating a pipeline layout*'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*'
- en: Creating a pipeline cache object
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管线缓存对象
- en: Creating a pipeline object is a complicated and time-consuming process from
    the driver's perspective. A pipeline object is not a simple wrapper for parameters
    set during the creation. It involves preparing the states of all programmable
    and fixed pipeline stages, setting an interface between shaders and descriptor
    resources, compiling and linking shader programs, and performing error checking
    (that is, checking if shaders are linked properly). Results of these operations
    may be stored in a cache. This cache can then be reused to speed up the creation
    of pipeline objects with similar properties. To be able to use a pipeline cache
    object, we first need to create it.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 从驱动程序的角度来看，创建管线对象是一个复杂且耗时的过程。管线对象不是创建期间设置的参数的简单包装器。它涉及到准备所有可编程和固定管线阶段的态，设置着色器和描述符资源之间的接口，编译和链接着色器程序，以及执行错误检查（即检查着色器是否正确链接）。这些操作的结果可以存储在缓存中。然后，可以使用此缓存来加速具有相似属性的管线对象的创建。要使用管线缓存对象，我们首先需要创建它。
- en: How to do it...
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: If available (that is, retrieved from other caches), prepare data to initialize
    a newly created cache object. Store the data in a variable of type `std::vector<unsigned
    char>` named `cache_data`.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可用（即从其他缓存中检索），准备数据以初始化一个新创建的缓存对象。将数据存储在名为 `cache_data` 的 `std::vector<unsigned
    char>` 类型的变量中。
- en: 'Create a variable of type `VkPipelineCacheCreateInfo` named `pipeline_cache_create_info`.
    Use the following values to initialize its members:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pipeline_cache_create_info` 的 `VkPipelineCacheCreateInfo` 类型的变量。使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO` value for `sType`.'
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO` 值为 `sType`。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值。'
- en: '`0` value for `flags`.'
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值。'
- en: The number of elements in the `cache_data` vector (size of the initialization
    data in bytes) for `initialDataSize`.
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_data` 向量中的元素数量（初始化数据的字节大小）为 `initialDataSize`。'
- en: A pointer to the first element of the `cache_data` vector for `pInitialData`.
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_data` 向量第一个元素的指针为 `pInitialData`。'
- en: Create a variable of type `VkPipelineCache` named `pipeline_cache` in which
    the handle of the created cache object will be stored.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pipeline_cache` 的 `VkPipelineCache` 类型的变量，其中将存储创建的缓存对象的句柄。
- en: 'Make the following function call: `vkCreatePipelineCache( logical_device, &pipeline_cache_create_info,
    nullptr, &pipeline_cache )`. For the call, provide the `logical_device` variable,
    a pointer to the `pipeline_cache_create_info` variable, a `nullptr` value, and
    a pointer to the `pipeline_cache` variable.'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下函数调用：`vkCreatePipelineCache(logical_device, &pipeline_cache_create_info,
    nullptr, &pipeline_cache)`。对于调用，提供 `logical_device` 变量、`pipeline_cache_create_info`
    变量的指针、`nullptr` 值和 `pipeline_cache` 变量的指针。
- en: Make sure the call was successful by checking if it returned a `VK_SUCCESS`
    value.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查它是否返回了 `VK_SUCCESS` 值来确保调用成功。
- en: How it works...
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A pipeline cache, as the name suggests, stores the results of a pipeline preparation
    process. It is optional and can be omitted, but when used, can significantly speed
    up the creation of pipeline objects.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，管线缓存存储了管线准备过程的结果。它是可选的，可以省略，但使用时可以显著加快管线对象的创建。
- en: To use a cache during the pipeline creation, we just need to create a cache
    object and provide it to the pipeline creating function. The driver automatically
    caches the results in the provided object. Also, if the cache contains any data,
    the driver automatically tries to use it for the pipeline creation.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道创建期间使用缓存，我们只需创建一个缓存对象并将其提供给管道创建函数。驱动程序会自动在提供的对象中缓存结果。此外，如果缓存包含任何数据，驱动程序会自动尝试将其用于管道创建。
- en: The most common scenario of using a pipeline cache object, is to store its contents
    in a file and reuse them between separate executions of the same application.
    The first time we run our application, we create an empty cache and all the pipelines
    we need. Next, we retrieve the cache data and save it to a file. Next time the
    application is executed, we also create the cache, but this time we initialize
    it with the contents read from a previously created file. From now on, each time
    we run our application, the process of creating pipelines should be much shorter.
    Of course, when we create only small number of pipelines, we probably won't notice
    any improvement. But modern 3D applications, especially games, may have tens,
    hundreds, or sometimes even thousands of different pipelines (due to shader variations).
    In such situations, the cache can significantly boost the process of creating
    all of them.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道缓存对象最常见的场景是将其内容存储在文件中，以便在相同应用程序的不同执行之间重用。第一次运行我们的应用程序时，我们创建一个空缓存和所有需要的管道。接下来，我们检索缓存数据并将其保存到文件中。下次应用程序执行时，我们也会创建缓存，但这次我们使用从先前创建的文件中读取的内容来初始化它。从现在开始，每次我们运行应用程序时，创建管道的过程应该会短得多。当然，当我们只创建少量管道时，我们可能不会注意到任何改进。但现代3D应用程序，尤其是游戏，可能有数十、数百，有时甚至数千种不同的管道（由于着色器变化）。在这种情况下，缓存可以显著提高创建所有这些管道的过程。
- en: 'Let''s assume the cache data is stored in a vector variable named `cache_data`.
    It may be empty or initialized with contents retrieved from previous pipeline
    creations. The process of creating a pipeline cache that uses this data is presented
    in the following code:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 假设缓存数据存储在一个名为`cache_data`的向量变量中。它可能是空的，或者初始化为从先前管道创建中检索的内容。使用此数据的管道缓存创建过程在以下代码中展示：
- en: '[PRE21]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See also
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Retrieving data from a pipeline cache*'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从管道缓存检索数据*'
- en: '*Merging multiple pipeline cache objects*'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并多个管道缓存对象*'
- en: '*Creating a graphics pipeline*'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管道*'
- en: '*Creating a compute pipeline*'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管道*'
- en: '*Creating multiple graphics pipelines on multiple threads*'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在多个线程上创建多个图形管道*'
- en: '*Destroying a pipeline cache*'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管道缓存*'
- en: Retrieving data from a pipeline cache
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从管道缓存检索数据
- en: A cache allows us to improve the performance of creating multiple pipeline objects.
    But for us to be able to use the cache each time we execute our application, we
    need a way to store the contents of the cache and reuse it any time we want. To
    do that, we can retrieve the data gathered in a cache.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存使我们能够提高创建多个管道对象的速度。但为了每次执行我们的应用程序时都能使用缓存，我们需要一种方法来存储缓存的全部内容，并在我们想要的时候重用它。为此，我们可以检索缓存中收集的数据。
- en: How to do it...
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄，并使用它来初始化一个名为`logical_device`的`VkDevice`类型的变量。
- en: Store the handle of a pipeline cache, from which data should be retrieved, in
    a variable of type `VkPipelineCache` named `pipeline_cache`.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从其中检索数据的管道缓存句柄存储在一个名为`pipeline_cache`的`VkPipelineCache`类型的变量中。
- en: Prepare a variable of type `size_t` named `data_size`.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`data_size`的`size_t`类型的变量。
- en: Call `vkGetPipelineCacheData( logical_device, pipeline_cache, &data_size, nullptr
    )` providing the `logical_device` and `pipeline_cache` variables, a pointer to
    the `data_size` variable, and a `nullptr` value.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPipelineCacheData(logical_device, pipeline_cache, &data_size, nullptr)`，提供`logical_device`和`pipeline_cache`变量，`data_size`变量的指针和一个`nullptr`值。
- en: If a function call was successful (a `VK_SUCCESS` value was returned), the size
    of memory that can hold the cache contents is stored in the `data_size` variable.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功（返回了`VK_SUCCESS`值），可以存储缓存内容的内存大小将存储在`data_size`变量中。
- en: Prepare a storage space for the cache contents. Create a variable of type `std::vector<unsigned
    char>` named `pipeline_cache_data`.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备缓存内容的存储空间。创建一个名为`pipeline_cache_data`的`std::vector<unsigned char>`类型的变量。
- en: Resize the `pipeline_cache_data` vector to be able to hold at least `data_size`
    number of elements.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`pipeline_cache_data`向量的大小调整为至少可以容纳`data_size`个元素。
- en: Call `vkGetPipelineCacheData( logical_device, pipeline_cache, &data_size, pipeline_cache_data.data()
    )` but this time, apart from the previously used parameters, additionally provide
    a pointer to the first element of the `pipeline_cache_data` vector as the last
    parameter.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPipelineCacheData( logical_device, pipeline_cache, &data_size, pipeline_cache_data.data()
    )`，但这次除了之前使用的参数外，还提供一个指向`pipeline_cache_data`向量第一个元素的指针作为最后一个参数。
- en: If the function returns successfully, cache contents are stored in the `pipeline_cache_data`
    vector.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数成功返回，缓存内容将存储在`pipeline_cache_data`向量中。
- en: How it works...
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Retrieving pipeline cache contents is performed in a typical Vulkan double-call
    of a single function. The first call of the `vkGetPipelineCacheData()` function,
    stores the total number of bytes required to hold the entire data retrieved from
    the pipeline cache. This allows us to prepare enough storage for the data:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道缓存中检索内容是在典型的Vulkan双调用中执行单个函数。`vkGetPipelineCacheData()`函数的第一个调用，存储了存储从管道缓存中检索到的整个数据所需的字节数。这使我们能够为数据准备足够的存储空间：
- en: '[PRE22]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when we are ready to acquire the cache contents, we can call the `vkGetPipelineCacheData()`
    function once more. This time the last parameter must point to the beginning of
    the prepared storage. A successful call writes the provided number of bytes to
    the indicated memory:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们准备好获取缓存内容时，我们可以再次调用`vkGetPipelineCacheData()`函数。这次最后一个参数必须指向已准备的存储的开始。成功的调用将提供的字节数写入指定的内存：
- en: '[PRE23]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Data retrieved in this way can be used directly to initialize the contents of
    any other newly created cache object.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式检索的数据可以直接用于初始化任何其他新创建的缓存对象的内容。
- en: See also
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a pipeline cache object*'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管道缓存对象*'
- en: '*Merging multiple pipeline cache objects*'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并多个管道缓存对象*'
- en: '*Creating a graphics pipeline*'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管道*'
- en: '*Creating a compute pipeline*'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管道*'
- en: '*Destroying a pipeline cache*'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管道缓存*'
- en: Merging multiple pipeline cache objects
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并多个管道缓存对象
- en: It may be a common scenario that we will have to create multiple pipelines in
    our application. To shorten the time needed to create them all, it may be a good
    idea to split the creation into multiple threads executed simultaneously. Each
    such thread should use a separate pipeline cache. After all the threads are finished,
    we would like to reuse the cache next time our application is executed. For this
    purpose, it is best to merge multiple cache objects into one.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是一个常见的场景，我们将在我们的应用程序中创建多个管道。为了缩短创建所有这些管道所需的时间，将创建过程分成多个同时执行的线程可能是一个好主意。每个这样的线程应使用单独的管道缓存。所有线程完成后，我们希望在下一次应用程序执行时重用缓存。为此，最好将多个缓存对象合并成一个。
- en: How to do it...
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Store the handle of a logical device in a variable of type `VkDevice` named
    `logical_device`.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑设备的句柄存储在一个名为`logical_device`的类型为`VkDevice`的变量中。
- en: Take the cache object into which other caches will be merged. Using its handle,
    initialize a variable of type `VkPipelineCache` named `target_pipeline_cache`.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他缓存将合并到的缓存对象取出来。使用其句柄，初始化一个名为`target_pipeline_cache`的类型为`VkPipelineCache`的变量。
- en: Create a variable of type `std::vector<VkPipelineCache>` named `source_pipeline_caches`.
    Store the handles of all pipelines caches that should be merged in the `source_pipeline_caches`
    vector (make sure none of the cache objects is the same as the `target_pipeline_cache`
    cache).
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`source_pipeline_caches`的类型为`std::vector<VkPipelineCache>`的变量。将所有应合并到`source_pipeline_caches`向量中的管道缓存句柄存储在该变量中（确保没有缓存对象与`target_pipeline_cache`缓存相同）。
- en: 'Make the following call: `vkMergePipelineCaches( logical_device, target_pipeline_cache,
    static_cast<uint32_t>(source_pipeline_caches.size()), source_pipeline_caches.data()
    )`. For the call, provide the `logical_device` and `target_pipeline_cache` variables,
    the number of elements in the `source_pipeline_caches` vector, and a pointer to
    the first element of the `source_pipeline_caches` vector.'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下调用：`vkMergePipelineCaches( logical_device, target_pipeline_cache, static_cast<uint32_t>(source_pipeline_caches.size()),
    source_pipeline_caches.data() )`。对于调用，提供`logical_device`和`target_pipeline_cache`变量，`source_pipeline_caches`向量中的元素数量，以及指向`source_pipeline_caches`向量第一个元素的指针。
- en: Make sure the call was successful and that it returned a `VK_SUCCESS` value.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用成功，并返回了`VK_SUCCESS`值。
- en: How it works...
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Merging pipeline caches allows us to combine separate cache objects into one.
    This way it is possible to perform multiple pipeline creations that use separate
    caches in multiple threads and then merge the results into one, common cache object.
    Separate threads may also use the same pipeline cache object, but access to the
    cache may be guarded by a mutex in the driver, thus making splitting the job into
    multiple threads quite useless. Saving one cache data in a file is simpler than
    managing multiple ones. And, during the merging operation, duplicate entries should
    be removed by the driver, thus saving us some additional space and memory.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 合并管线缓存允许我们将单独的缓存对象合并成一个。这样，就可以在多个线程中使用多个单独的缓存进行多个管线创建，然后将结果合并成一个公共的缓存对象。单独的线程也可以使用相同的管线缓存对象，但缓存访问可能由驱动程序中的互斥锁保护，因此将任务分割成多个线程相当无用。将一个缓存数据保存到文件中比管理多个缓存简单。而且，在合并操作期间，驱动程序应删除重复条目，从而为我们节省一些额外的空间和内存。
- en: 'Merging multiple pipeline cache objects is performed like this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 合并多个管线缓存对象的操作如下：
- en: '[PRE24]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We need to remember that a cache, into which we merge other cache objects, cannot
    appear in the list of (source) caches to be merged.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，我们合并其他缓存对象的缓存不能出现在要合并的（源）缓存列表中。
- en: See also
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a pipeline cache object*'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线缓存对象*'
- en: '*Retrieving data from a pipeline cache*'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从管线缓存中检索数据*'
- en: '*Creating a graphics pipeline*'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: '*Creating multiple graphics pipelines on multiple threads*'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在多个线程上创建多个图形管线*'
- en: '*Destroying a pipeline cache*'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管线缓存*'
- en: Creating a graphics pipeline
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形管线
- en: A graphics pipeline is the object that allows us to draw anything on screen.
    It controls how the graphics hardware performs all the drawing-related operations,
    which transform vertices provided by the application into fragments appearing
    on screen. Through it we specify shader programs used during drawing, the state
    and parameters of tests such as depth and stencil, or how the final color is calculated
    and written to any of the subpass attachments. It is one of the most important
    objects used by our application. Before we can draw anything, we need to create
    a graphics pipeline. If we want, we can create multiple pipelines at once.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线是允许我们在屏幕上绘制任何内容的对象。它控制图形硬件执行所有与绘图相关的操作，将应用程序提供的顶点转换为屏幕上出现的片段。通过它，我们指定绘图期间使用的着色器程序，深度和模板等测试的状态和参数，或者最终颜色是如何计算并写入任何子通道附件的。它是我们应用程序中使用的重要对象之一。在我们能够绘制任何内容之前，我们需要创建一个图形管线。如果我们愿意，我们可以一次创建多个管线。
- en: How to do it...
  id: totrans-633
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为 `logical_device` 的 `VkDevice` 类型的变量中。
- en: Create a variable of type `std::vector<VkGraphicsPipelineCreateInfo>` named
    `graphics_pipeline_create_infos`. For each pipeline that should be created, add
    an element to the `graphics_pipeline_create_infos` vector describing the pipeline's
    parameters (refer to the *Specifying graphics pipeline creation parameters* recipe).
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `graphics_pipeline_create_infos` 的 `std::vector<VkGraphicsPipelineCreateInfo>`
    类型的变量。对于应该创建的每个管线，向 `graphics_pipeline_create_infos` 向量中添加一个元素，描述该管线的参数（参考 *指定图形管线创建参数*
    食谱）。
- en: If a pipeline cache should be used during the creation process, store its handle
    in a variable of type `VkPipelineCache` named `pipeline_cache`.
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在创建过程中应使用管线缓存，将其句柄存储在名为 `pipeline_cache` 的 `VkPipelineCache` 类型的变量中。
- en: Create a variable of type `std::vector<VkPipeline>` named `graphics_pipelines`,
    in which handles of the created `pipeline` will be stored. Resize the vector to
    hold the same number of elements as the `graphics_pipeline_create_infos` vector.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `graphics_pipelines` 的 `std::vector<VkPipeline>` 类型的变量，其中将存储创建的 `pipeline`
    的句柄。将向量的大小调整为与 `graphics_pipeline_create_infos` 向量中的元素数量相同。
- en: Call `vkCreateGraphicsPipelines( logical_device, pipeline_cache, static_cast<uint32_t>(graphics_pipeline_create_infos.size()),
    graphics_pipeline_create_infos.data(), nullptr, graphics_pipelines.data() )` and
    provide the `logical_device` variable, the `pipeline_cache` variable or a `nullptr`
    value if no cache is used during the pipeline creation, the number of elements
    in the `graphics_pipeline_create_infos` vector, a pointer to the first element
    of the `graphics_pipeline_create_info` vector, a `nullptr` value, and a pointer
    to the first element of the `graphics_pipeline` vector.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateGraphicsPipelines(logical_device, pipeline_cache, static_cast<uint32_t>(graphics_pipeline_create_infos.size()),
    graphics_pipeline_create_infos.data(), nullptr, graphics_pipelines.data())` 并提供
    `logical_device` 变量、`pipeline_cache` 变量或 `nullptr` 值（如果管线创建期间没有使用缓存），`graphics_pipeline_create_infos`
    向量中的元素数量，指向 `graphics_pipeline_create_info` 向量第一个元素的指针，一个 `nullptr` 值，以及指向 `graphics_pipeline`
    向量第一个元素的指针。
- en: Make sure all the pipelines were successfully created by checking whether the
    call returned a `VK_SUCCESS` value. If any of the pipelines weren't created successfully,
    other values will be returned.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有管线都成功创建，通过检查调用是否返回了 `VK_SUCCESS` 值。如果任何管线没有成功创建，将返回其他值。
- en: How it works...
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A graphics pipeline allows us to draw anything on screen. It controls the parameters
    of all programmable and fixed stages of the pipeline realized by the graphics
    hardware. A simplified diagram of a graphics pipeline is presented in the following
    image. White blocks represent programmable stages, gray ones are the fixed parts
    of the pipeline:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线允许我们在屏幕上绘制任何东西。它控制由图形硬件实现的管线所有可编程和固定阶段的参数。以下图像展示了图形管线的一个简化图。白色块代表可编程阶段，灰色块是管线的固定部分：
- en: '![](img/image_08_004.png)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_004.png)'
- en: Programmable stages consist of vertex, tessellation control and evaluation,
    and geometry and fragment shaders, of which only the vertex stage is obligatory.
    The rest are optional and enabling them depends on the parameters specified during
    the pipeline creation. As an example, if rasterization is disabled, there is no
    fragment shader stage. If we enable the tessellation stage, we need to provide
    both tessellation control and evaluation shaders.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程阶段包括顶点、曲面控制与评估、几何和片段着色器，其中只有顶点阶段是必需的。其余的都是可选的，是否启用取决于在管线创建期间指定的参数。例如，如果禁用了光栅化，则没有片段着色器阶段。如果我们启用了曲面阶段，我们需要提供曲面控制和评估着色器。
- en: A graphics pipeline is created with a `vkCreateGraphicsPipelines()` function.
    It allows us to create multiple pipelines at once. We need to provide an array
    of variables of type `VkGraphicsPipelineCreateInfo`, a number of elements in this
    array, and a pointer to an array with elements of type `VkPipeline`. This array
    must be large enough to hold the same number of elements as the input array with
    elements of type `VkGraphicsPipelineCreateInfo` (the `graphics_pipeline_create_infos`
    vector). When we prepare elements to the `graphics_pipeline_create_infos` vector
    and want to use its `basePipelineIndex` member to specify a parent pipeline created
    within the same function call, we provide an index into the `graphics_pipeline_create_infos`
    vector.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vkCreateGraphicsPipelines()` 函数创建一个图形管线。它允许我们一次性创建多个管线。我们需要提供一个类型为 `VkGraphicsPipelineCreateInfo`
    的变量数组，数组中的元素数量，以及一个指向类型为 `VkPipeline` 的数组元素的指针。此数组必须足够大，可以容纳与类型为 `VkGraphicsPipelineCreateInfo`
    的输入数组相同数量的元素（即 `graphics_pipeline_create_infos` 向量）。当我们准备 `graphics_pipeline_create_infos`
    向量中的元素并想要使用其 `basePipelineIndex` 成员来指定在同一个函数调用内创建的父管线时，我们提供 `graphics_pipeline_create_infos`
    向量中的索引。
- en: 'The implementation of this recipe is presented in the following code:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方实现如下代码所示：
- en: '[PRE25]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipe in this chapter:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying graphics pipeline creation parameters*'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定图形管线创建参数*'
- en: '*Creating a pipeline cache object*'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线缓存对象*'
- en: '*Binding a pipeline object*'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管线对象*'
- en: '*Creating a graphics pipeline with vertex and fragment shaders, depth test
    enabled, and with dynamic viewport and scissor tests*'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点和片段着色器创建图形管线，启用深度测试，并具有动态视口和裁剪测试*'
- en: '*Creating multiple graphics pipelines on multiple threads*'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在多个线程上创建多个图形管线*'
- en: '*Destroying a pipeline*'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管线*'
- en: Creating a compute pipeline
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建计算管线
- en: A compute pipeline is the second type of pipeline available in the Vulkan API.
    It is used for dispatching compute shaders, which can perform any mathematical
    operations. And as the compute pipeline is much simpler than the graphics pipeline,
    we create it by providing far fewer parameters.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 计算管道是 Vulkan API 中可用的第二种管道类型。它用于调度计算着色器，可以执行任何数学运算。由于计算管道比图形管道简单得多，我们通过提供更少的参数来创建它。
- en: How to do it...
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a logical device and initialize a variable of type `VkDevice`
    named `logical_device` with it.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到逻辑设备的句柄，并用它初始化一个名为 `logical_device` 的 `VkDevice` 类型的变量。
- en: 'Create a variable of a bitfield type `VkPipelineCreateFlags` named `additional_options`.
    Initialize it with any combination of these additional pipeline creation options:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `additional_options` 的 `VkPipelineCreateFlags` 类型的变量。用以下这些额外的管道创建选项的任意组合来初始化它：
- en: '**Disable optimization**: specifies that the created pipeline won''t be optimized,
    but the creation process may be faster'
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用优化**：指定创建的管道不会被优化，但创建过程可能会更快'
- en: '**Allow derivatives**: specifies that other pipelines may be created from it'
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许派生**：指定可以从它创建其他管道'
- en: '**Derivative**: specifies that this pipeline will be created based on another,
    already created pipeline'
  id: totrans-662
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**派生**：指定此管道将基于另一个已创建的管道创建'
- en: Create a variable of type `VkPipelineShaderStageCreateInfo` named `compute_shader_stage`
    through which specify a single compute shader stage (refer to the *Specifying
    pipeline shader stages* recipe).
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `compute_shader_stage` 变量创建一个名为 `VkPipelineShaderStageCreateInfo` 的变量，通过它指定单个计算着色器阶段（参考
    *指定管道着色器阶段* 菜谱）。
- en: Create a pipeline layout and store its handle in a variable of type `VkPipelineLayout`
    named `pipeline_layout`.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管道布局并将它的句柄存储在名为 `pipeline_layout` 的 `VkPipelineLayout` 类型的变量中。
- en: If a pipeline cache should be used during the pipeline creation, store the handle
    of a created cache object in a variable of type `VkPipelineCache` named `pipeline_cache`.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在管道创建期间应使用管道缓存，将创建的缓存对象的句柄存储在名为 `pipeline_cache` 的 `VkPipelineCache` 类型的变量中。
- en: 'Create a variable of type `VkComputePipelineCreateInfo` named `compute_pipeline_create_info`.
    Use the following values to initialize its members:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `compute_pipeline_create_info` 的 `VkComputePipelineCreateInfo` 类型的变量。使用以下值来初始化其成员：
- en: '`VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO` value for `sType`'
  id: totrans-667
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO` 值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: '`additional_options` variable for `flags`'
  id: totrans-669
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`additional_options` 变量用于 `flags`'
- en: '`compute_shader_stage` variable for `stage`'
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compute_shader_stage` 变量用于 `stage`'
- en: '`pipeline_layout` variable for `layout`'
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipeline_layout` 变量用于 `layout`'
- en: If the pipeline should be a child of another pipeline, provide the handle of
    a parent pipeline or otherwise a `VK_NULL_HANDLE` value for `basePipelineHandle`
  id: totrans-672
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管道应该是另一个管道的子管道，提供父管道的句柄或为 `basePipelineHandle` 提供一个 `VK_NULL_HANDLE` 值。
- en: '`-1` value for `basePipelineIndex`'
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basePipelineIndex` 的值为 `-1`'
- en: Create a variable of type `VkPipeline` named `compute_pipeline` in which a handle
    of the created compute pipeline will be stored.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `compute_pipeline` 的 `VkPipeline` 类型的变量，用于存储创建的计算管道的句柄。
- en: Call `vkCreateComputePipelines( logical_device, pipeline_cache, 1, &compute_pipeline_create_info,
    nullptr, &compute_pipeline )` and provide the `logical_device` variable, the `pipeline_cache`
    variable if caching should be enabled or a `VK_NULL_HANDLE` value otherwise, `1`
    value, a pointer to the `compute_pipeline_create_info` variable, a `nullptr` value,
    and a pointer to the `compute_pipeline` variable.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateComputePipelines(logical_device, pipeline_cache, 1, &compute_pipeline_create_info,
    nullptr, &compute_pipeline)` 并提供 `logical_device` 变量，如果需要启用缓存则提供 `pipeline_cache`
    变量或 `VK_NULL_HANDLE` 值，`1` 值，指向 `compute_pipeline_create_info` 变量的指针，`nullptr`
    值，以及指向 `compute_pipeline` 变量的指针。
- en: Make sure the call was successful by checking if it returned a `VK_SUCCESS`
    value.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查它是否返回了 `VK_SUCCESS` 值来确保调用成功。
- en: How it works...
  id: totrans-677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We use compute pipelines when we want to dispatch compute shaders. A compute
    pipeline consists of only a single compute shader stage (though the hardware may
    implement additional stages if needed).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要调度计算着色器时，我们使用计算管道。计算管道仅由单个计算着色器阶段组成（尽管如果需要，硬件可能实现额外的阶段）。
- en: Compute pipelines cannot be used inside render passes.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 计算管道不能在渲染通道内使用。
- en: Compute shaders don't have any input or output variables, apart from some built-in
    values. For the input and output data, only uniform variables (buffers or images)
    can be used (refer to the *Writing compute shaders* recipe from [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml),
    *Shaders*). That's why, though the compute pipeline is simpler, compute shaders
    are more universal and can be used to perform mathematical operations or operations
    that operate on images.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器除了某些内置值外没有任何输入或输出变量。对于输入和输出数据，只能使用统一变量（缓冲区或图像）（参考第7章的*编写计算着色器*配方，*着色器*）。这就是尽管计算管道更简单，但计算着色器更通用，可以用于执行数学运算或对图像进行操作的运算。
- en: Compute pipelines, similar to graphics pipelines, can be created in bulks and
    multiple variables of type `VkComputePipelineCreateInfo` just need to be provided
    to the compute pipeline creating function. Also, compute pipelines can be parents
    of other compute pipelines and can derive from other parent pipelines. All this
    speeds up the creation process. To use this ability, we need to provide appropriate
    values for `basePipelineHandle` or `basePipelineIndex` members of variables of
    type `VkComputePipelineCreateInfo` (refer to the *Creating a graphics pipeline*
    recipe).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 计算管道，类似于图形管道，可以批量创建，只需要向计算管道创建函数提供多个 `VkComputePipelineCreateInfo` 类型的变量。此外，计算管道可以是其他计算管道的父级，并且可以从其他父级管道继承。所有这些都加快了创建过程。要使用此功能，我们需要为
    `VkComputePipelineCreateInfo` 变量的 `basePipelineHandle` 或 `basePipelineIndex` 成员提供适当的值（参考*创建图形管道*配方）。
- en: 'The simplified process of creating a single compute pipeline is presented in
    the following code:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了创建单个计算管道的简化过程：
- en: '[PRE26]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-684
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipe:'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Writing compute shaders*'
  id: totrans-686
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写计算着色器*'
- en: 'The following recipes in this chapter:'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying pipeline shader stages*'
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道着色器阶段*'
- en: '*Creating a pipeline layout*'
  id: totrans-689
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管道布局*'
- en: '*Creating a pipeline cache object*'
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管道缓存对象*'
- en: '*Destroying a pipeline*'
  id: totrans-691
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管道*'
- en: Binding a pipeline object
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定管道对象
- en: Before we can issue drawing commands or dispatch computational work, we need
    to set up all the required states for the command to be successfully performed.
    One of the required states is binding a pipeline object to the command buffer--a
    graphics pipeline if we want to draw objects on screen or a compute pipeline if
    we want to perform computational work.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以发出绘制命令或调度计算工作之前，我们需要设置所有必要的命令以成功执行的状态。其中之一是绑定管道对象到命令缓冲区--如果我们想在屏幕上绘制对象，则为图形管道；如果我们想执行计算工作，则为计算管道。
- en: How to do it...
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a command buffer and store it in a variable of type `VkCommandBuffer`
    named `command_buffer`. Make sure the command buffer is in the recording state.
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区的句柄并将其存储在名为 `command_buffer` 的 `VkCommandBuffer` 类型变量中。确保命令缓冲区处于录制状态。
- en: If a graphics pipeline needs to be bound, make sure the beginning of a render pass
    has already been recorded in the `command_buffer`. If a compute pipeline should
    be bound, make sure no render pass is started or any render passes are finished
    in the `command_buffer`.
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要绑定图形管道，请确保渲染通道的开始已经在 `command_buffer` 中被记录。如果需要绑定计算管道，请确保没有开始渲染通道或在 `command_buffer`
    中完成任何渲染通道。
- en: Take the handle of a pipeline object. Use it to initialize a variable of type
    `VkPipeline` named `pipeline`.
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取管道对象的句柄。使用它来初始化一个名为 `pipeline` 的 `VkPipeline` 类型的变量。
- en: Call `vkCmdBindPipeline( command_buffer, pipeline_type, pipeline )`. Provide
    the `command_buffer` variable, the type of the pipeline (graphics or compute)
    that is being bound to the command buffer, and the `pipeline` variable.
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCmdBindPipeline(command_buffer, pipeline_type, pipeline)`。提供 `command_buffer`
    变量、被绑定到命令缓冲区的管道类型（图形或计算）以及 `pipeline` 变量。
- en: How it works...
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A pipeline needs to be bound before we can draw or dispatch computational work
    in a command buffer. Graphics pipelines can be bound only inside render passes--the
    one specified during pipeline creation or a compatible one. Compute pipelines
    cannot be used inside render passes. If we want to use them, any started render
    pass needs to be finished.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在命令缓冲区中绘制或调度计算工作之前，需要绑定管道。图形管道只能在渲染通道内绑定--在管道创建期间指定的或兼容的通道。计算管道不能在渲染通道内使用。如果我们想使用它们，任何已经开始的渲染通道都需要完成。
- en: 'Binding a pipeline object is achieved with a single function call like this:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个函数调用，如以下示例，绑定管道对象：
- en: '[PRE27]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the recipe:'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*，查看以下配方：
- en: '*Beginning a command buffer recording operation*'
  id: totrans-705
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始命令缓冲区记录操作*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*，查看以下配方：
- en: '*Beginning a render pass*'
  id: totrans-707
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染通道*'
- en: '*Ending a render pass*'
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束渲染通道*'
- en: 'The following recipes in this chapter:'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a graphics pipeline*'
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管道*'
- en: '*Creating a compute pipeline*'
  id: totrans-711
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管道*'
- en: Creating a pipeline layout with a combined image sampler, a buffer, and push
    constant ranges
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有组合图像采样器、缓冲区和推送常量范围的管道布局
- en: We know how to create descriptor set layouts and use them to create a pipeline
    layout. Here, in this sample recipe, we will have a look at how to create a specific
    pipeline layout--one which allows a pipeline to access a combined image sampler,
    a uniform buffer, and a selected number of push constant ranges.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何创建描述符集布局并使用它们来创建管道布局。在这里，在这个示例配方中，我们将查看如何创建特定的管道布局——允许管道访问组合图像采样器、统一缓冲区和选定的推送常量范围。
- en: How to do it...
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在类型为 `VkDevice` 的变量 `logical_device` 中。
- en: Create a variable of type `std::vector<VkDescriptorSetLayoutBinding>` named
    `descriptor_set_layout_bindings`.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `std::vector<VkDescriptorSetLayoutBinding>` 的变量，命名为 `descriptor_set_layout_bindings`.
- en: 'Add a new element to the `descriptor_set_layout_bindings` vector and use the
    following values to initialize its members:'
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `descriptor_set_layout_bindings` 向量添加新元素，并使用以下值初始化其成员：
- en: '`0` value for `binding`.'
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 的值用于 `binding`.'
- en: '`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` value for `descriptorType`.'
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` 的值用于 `descriptorType`.'
- en: '`1` value for `descriptorCount`.'
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 的值用于 `descriptorCount`.'
- en: '`VK_SHADER_STAGE_FRAGMENT_BIT` value for `stageFlags`.'
  id: totrans-721
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SHADER_STAGE_FRAGMENT_BIT` 的值用于 `stageFlags`.'
- en: '`nullptr` value for `pImmutableSamplers`.'
  id: totrans-722
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 的值用于 `pImmutableSamplers`.'
- en: 'Add a second member to the `descriptor_set_layout_bindings` vector and use
    the following values to initialize its members:'
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `descriptor_set_layout_bindings` 向量添加第二个成员，并使用以下值初始化其成员：
- en: '`1` value for `binding`.'
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 的值用于 `binding`.'
- en: '`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` value for `descriptorType`.'
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` 的值用于 `descriptorType`.'
- en: '`1` value for `descriptorCount`.'
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 的值用于 `descriptorCount`.'
- en: '`VK_SHADER_STAGE_VERTEX_BIT` value for `stageFlags`.'
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SHADER_STAGE_VERTEX_BIT` 的值用于 `stageFlags`.'
- en: '`nullptr` value for `pImmutableSamplers`.'
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 值用于 `pImmutableSamplers`.'
- en: Create a descriptor set layout using the `logical_device` and `descriptor_set_layout_bindings`
    variables and store it in a variable of type `VkDescriptorSetLayout` named `descriptor_set_layout`
    (refer to the *Creating a descriptor set layout* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device` 和 `descriptor_set_layout_bindings` 变量创建描述符集布局，并将其存储在类型为
    `VkDescriptorSetLayout` 的变量 `descriptor_set_layout` 中（参考 [第 5 章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*
    中的 *创建描述符集布局* 配方）。
- en: Create a variable of type `std::vector<VkPushConstantRange>` named `push_constant_ranges`
    and initialize it with the desired number of push constant ranges, each with desired
    values (refer to the *Creating a pipeline layout* recipe).
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `std::vector<VkPushConstantRange>` 的变量，命名为 `push_constant_ranges`，并用所需的推送常量范围数量初始化它，每个范围具有所需的值（参考
    *创建管道布局* 配方）。
- en: Create a variable of type `VkPipelineLayout` named `pipeline_layout` in which
    the handle of the created pipeline layout will be stored.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `VkPipelineLayout` 的变量，命名为 `pipeline_layout`，其中将存储创建的渲染通道句柄。
- en: Create the pipeline layout using the `logical_device`, `descriptor_set_layout`
    and `push_constant_ranges` variables. Store the created handle in the `pipeline_layout`
    variable (refer to the *Creating a pipeline layout* recipe).
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device`、`descriptor_set_layout` 和 `push_constant_ranges` 变量创建管道布局。将创建的句柄存储在
    `pipeline_layout` 变量中（参考 *创建管道布局* 配方）。
- en: How it works...
  id: totrans-733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we assume that we want to create a graphics pipeline that needs
    access to a uniform buffer and a combined image sampler. This is a common situation--we
    use the uniform buffer in a vertex shader to transform vertices from the local
    space to the clip space. A fragment shader is used for texturing so it needs access
    to a combined image sampler descriptor.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们假设我们想要创建一个需要访问统一缓冲区和合成图像采样器的图形管线。这是一个常见的情况--我们在顶点着色器中使用统一缓冲区将顶点从局部空间转换到裁剪空间。片段着色器用于纹理，因此它需要访问合成图像采样器描述符。
- en: 'We need to create a descriptor set that contains these two types of resources.
    For this purpose, we create a layout for it, which defines a uniform buffer used
    in a vertex shader and a combined image sampler accessed in a fragment shader:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个包含这两种类型资源的描述符集。为此，我们为它创建一个布局，该布局定义了一个在顶点着色器中使用的统一缓冲区和在片段着色器中访问的合成图像采样器：
- en: '[PRE28]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using such a descriptor set layout, we can create a pipeline layout using an
    additional vector with information for ranges of push constants:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的描述符集布局，我们可以使用一个包含推送常量范围的额外向量的信息来创建一个管线布局：
- en: '[PRE29]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, when we create a pipeline with such a layout, we can bind one descriptor set
    to index `0`. This descriptor set must have two descriptor resources--a combined
    image sampler at binding `0` and a uniform buffer at binding `1`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用这种布局创建管线时，我们可以将一个描述符集绑定到索引 `0`。这个描述符集必须有两个描述符资源--绑定 `0` 的合成图像采样器和绑定
    `1` 的统一缓冲区。
- en: See also
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the recipe:'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 5 章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集* 中，查看以下菜谱：
- en: '*Creating a descriptor set layout*'
  id: totrans-742
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Creating a pipeline layout*, in this chapter.'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*，在本章中。'
- en: Creating a graphics pipeline with vertex and fragment shaders, depth test enabled,
    and with dynamic viewport and scissor tests
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有顶点和片段着色器、启用深度测试以及具有动态视口和裁剪测试的图形管线
- en: In this recipe, we will see how to create a commonly used graphics pipeline,
    in which vertex and fragment shaders are active and a depth test is enabled. We
    will also specify that viewport and scissor tests are set up dynamically.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何创建一个常用的图形管线，其中顶点和片段着色器是活动的，并且启用了深度测试。我们还将指定视口和裁剪测试是动态设置的。
- en: How to do it...
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a logical device. Use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个逻辑设备的把手。使用它来初始化一个名为 `logical_device` 的 `VkDevice` 类型的变量。
- en: Take the SPIR-V assembly of a vertex shader and use it, along with the `logical_device`
    variable, to create a shader module. Store it in a variable of type `VkShaderModule`
    named `vertex_shader_module` (refer to the *Creating a shader module* recipe).
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个顶点着色器的 SPIR-V 汇编，并使用它以及 `logical_device` 变量来创建一个着色器模块。将其存储在一个名为 `vertex_shader_module`
    的 `VkShaderModule` 类型的变量中（参考 *创建着色器模块* 菜谱）。
- en: Take the SPIR-V assembly of a fragment shader and using it, along with the `logical_device`
    variable, create a second shader module. Store its handle in a variable of type
    `VkShaderModule` named `fragment_shader_module` (refer to the *Creating a shader
    module* recipe).
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个片段着色器的 SPIR-V 汇编，并使用它以及 `logical_device` 变量创建第二个着色器模块。将其句柄存储在一个名为 `fragment_shader_module`
    的 `VkShaderModule` 类型的变量中（参考 *创建着色器模块* 菜谱）。
- en: Create a variable of type `std::vector` named `shader_stage_params` with elements
    of a custom `ShaderStageParameters` type (refer to the *Specifying pipeline shader
    stages* recipe).
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `shader_stage_params` 的 `std::vector` 类型的变量，其元素为自定义的 `ShaderStageParameters`
    类型（参考 *指定管线着色器阶段* 菜谱）。
- en: 'Add an element to the `shader_stage_params` vector and use the following values
    to initialize its members:'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `shader_stage_params` 向量中添加一个元素，并使用以下值来初始化其成员：
- en: '`VK_SHADER_STAGE_VERTEX_BIT` value for `ShaderStage.`'
  id: totrans-752
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SHADER_STAGE_VERTEX_BIT` 值用于 `ShaderStage`。'
- en: '`vertex_shader_module` variable for `ShaderModule.`'
  id: totrans-753
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShaderModule` 的 `vertex_shader_module` 变量。'
- en: '`main` string for `EntryPointName.`'
  id: totrans-754
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntryPointName` 的 `main` 字符串。'
- en: '`nullptr` value for `SpecializationInfo.`'
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpecializationInfo` 的 `nullptr` 值。'
- en: 'Add a second element to the `shader_stage_params` vector and use the following
    values to initialize its members:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `shader_stage_params` 向量中添加第二个元素，并使用以下值来初始化其成员：
- en: '`VK_SHADER_STAGE_FRAGMENT_BIT` value for `ShaderStage.`'
  id: totrans-757
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_SHADER_STAGE_FRAGMENT_BIT` 值用于 `ShaderStage`。'
- en: '`fragment_shader_module` variable for `ShaderModule.`'
  id: totrans-758
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShaderModule` 的 `fragment_shader_module` 变量。'
- en: '`main` string for `EntryPointName.`'
  id: totrans-759
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntryPointName` 的 `main` 字符串。'
- en: '`nullptr` value for `SpecializationInfo.`'
  id: totrans-760
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpecializationInfo` 的 `nullptr` 值。'
- en: Create a variable of type `std::vector<VkPipelineShaderStageCreateInfo>` named
    `shader_stage_create_infos` and initialize it using the members of the `shader_stage_params`
    vector (refer to the *Specifying pipeline shader stages* recipe).
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `shader_stage_create_infos` 的类型为 `std::vector<VkPipelineShaderStageCreateInfo>`
    的变量，并使用 `shader_stage_params` 向量的成员对其进行初始化（参考 *指定管道着色器阶段* 菜谱）。
- en: Create a variable of type `VkPipelineVertexInputStateCreateInfo` named `vertex_input_state_create_info`.
    Initialize it with the desired parameters of vertex input bindings and vertex
    attributes (refer to the *Specifying pipeline vertex binding description, attribute
    description, and input state* recipe).
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vertex_input_state_create_info` 的类型为 `VkPipelineVertexInputStateCreateInfo`
    的变量。使用所需的顶点输入绑定和顶点属性参数对其进行初始化（参考 *指定管道顶点绑定描述、属性描述和输入状态* 菜谱）。
- en: Create a variable of type `VkPipelineInputAssemblyStateCreateInfo` named `input_assembly_state_create_info`
    and initialize it using the desired primitive topology (triangle list or triangle
    strip, or line list, and so on) and decide whether the primitive restart should
    be enabled or disabled (refer to the *Specifying pipeline input assembly state*
    recipe).
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `input_assembly_state_create_info` 的类型为 `VkPipelineInputAssemblyStateCreateInfo`
    的变量，并使用所需的原始拓扑（三角形列表或三角形带，或线列表等）对其进行初始化，并决定是否启用原始重启（参考 *指定管道输入装配状态* 菜谱）。
- en: Create a variable of type `VkPipelineViewportStateCreateInfo` named `viewport_state_create_info`.
    Initialize it using a variable of the `ViewportInfo` type with one-element vectors
    for both viewport and scissor test vectors. Values stored in these vectors don't
    matter as viewport and stencil parameters will be defined dynamically during command buffer
    recording. But as the number of viewports (and scissor test states) are defined
    statically, both vectors need to have one element (refer to the *Specifying pipeline
    viewport and scissor test state* recipe).
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `viewport_state_create_info` 的类型为 `VkPipelineViewportStateCreateInfo`
    的变量。使用 `ViewportInfo` 类型的变量对其进行初始化，其中视口和剪裁测试向量的元素均为一个。存储在这些向量中的值无关紧要，因为视口和模板参数将在命令缓冲区记录期间动态定义。但是，由于视口（和剪裁测试状态）的数量是静态定义的，因此这两个向量都需要有一个元素（参考
    *指定管道视口和剪裁测试状态* 菜谱）。
- en: Create a variable of type `VkPipelineRasterizationStateCreateInfo` named `rasterization_state_create_info`
    and initialize it with selected values. Remember to provide a false value for
    the `rasterizerDiscardEnable` member (refer to the *Specifying pipeline rasterization
    state* recipe).
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `rasterization_state_create_info` 的类型为 `VkPipelineRasterizationStateCreateInfo`
    的变量，并使用所选值对其进行初始化。记得为 `rasterizerDiscardEnable` 成员提供一个假值（参考 *指定管道光栅化状态* 菜谱）。
- en: Create a variable of type `VkPipelineMultisampleStateCreateInfo` named `multisample_state_create_info`.
    Specify the desired parameters of a multisampling (refer to the *Specifying pipeline
    multisample state* recipe).
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `multisample_state_create_info` 的类型为 `VkPipelineMultisampleStateCreateInfo`
    的变量。指定多采样所需的参数（参考 *指定管道多采样状态* 菜谱）。
- en: Create a variable of type `VkPipelineDepthStencilStateCreateInfo` named `depth_and_stencil_state_create_info`.
    Remember to enable depth writes and a depth test and to specify a `VK_COMPARE_OP_LESS_OR_EQUAL`
    operator for a depth test. Define the rest of the depth and stencil parameters
    as required (refer to the *Specifying pipeline depth and stencil state* recipe).
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `depth_and_stencil_state_create_info` 的类型为 `VkPipelineDepthStencilStateCreateInfo`
    的变量。记得启用深度写入和深度测试，并为深度测试指定一个 `VK_COMPARE_OP_LESS_OR_EQUAL` 操作符。根据需要定义其余的深度和模板参数（参考
    *指定管道深度和模板状态* 菜谱）。
- en: Create a variable of type `VkPipelineColorBlendStateCreateInfo` named `blend_state_create_info`
    and initialize it with the desired set of values (refer to the *Specifying pipeline
    blend state* recipe).
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `blend_state_create_info` 的类型为 `VkPipelineColorBlendStateCreateInfo`
    的变量，并使用所需的值集对其进行初始化（参考 *指定管道混合状态* 菜谱）。
- en: Create a variable of type `std::vector<VkDynamicState>` named `dynamic_states`.
    Add two elements to the vector, one with a `VK_DYNAMIC_STATE_VIEWPORT` value,
    and a second with a `VK_DYNAMIC_STATE_SCISSOR` value.
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `dynamic_states` 的类型为 `std::vector<VkDynamicState>` 的变量。向该向量添加两个元素，一个具有
    `VK_DYNAMIC_STATE_VIEWPORT` 值，另一个具有 `VK_DYNAMIC_STATE_SCISSOR` 值。
- en: Create a variable of type `VkPipelineDynamicStateCreateInfo` named `dynamic_state_create_info`.
    Prepare its contents using the `dynamic_states` vector (refer to the *Specifying
    pipeline dynamic states* recipe).
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `dynamic_state_create_info` 的类型为 `VkPipelineDynamicStateCreateInfo` 的变量。使用
    `dynamic_states` 向量准备其内容（参考 *指定管道动态状态* 菜谱）。
- en: Create a variable of type `VkGraphicsPipelineCreateInfo` named `graphics_pipeline_create_info`.
    Initialize it using the `shader_stage_create_infos`, `vertex_input_state_create_info`,
    `input_assembly_state_create_info`, `viewport_state_create_info`, `rasterization_state_create_info`,
    `multisample_state_create_info`, `depth_and_stencil_state_create_info`, `blend_state_create_info`
    and `dynamic_state_create_info` variables. Provide the created pipeline layout,
    the selected render pass, and its subpass. Use the handle or index of a parent
    pipeline. Provide a `nullptr` value for the tessellation state info.
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`graphics_pipeline_create_info`的`VkGraphicsPipelineCreateInfo`类型的变量。使用`shader_stage_create_infos`、`vertex_input_state_create_info`、`input_assembly_state_create_info`、`viewport_state_create_info`、`rasterization_state_create_info`、`multisample_state_create_info`、`depth_and_stencil_state_create_info`、`blend_state_create_info`和`dynamic_state_create_info`变量初始化它。提供创建的管道布局、选定的渲染通道及其子通道。使用父管道的句柄或索引。为细分状态信息提供`nullptr`值。
- en: Create a graphics pipeline using the `logical_device` and `graphics_pipeline_create_info`
    variables. Provide the handle of a pipeline cache, if needed. Store the handle
    of the created pipeline in the one element vector variable of type `std::vector<VkPipeline>`
    named `graphics_pipeline`.
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`logical_device`和`graphics_pipeline_create_info`变量创建图形管道。如果需要，提供管道缓存句柄。将创建的管道句柄存储在名为`graphics_pipeline`的`std::vector<VkPipeline>`类型的一个元素向量变量中。
- en: How it works...
  id: totrans-773
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'One of the most commonly used pipelines is a pipeline with only vertex and
    fragment shaders. To prepare parameters of vertex and fragment shader stages we
    can use the following code:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的管道之一是只有顶点和片段着色器的管道。为了准备顶点和片段着色器阶段的参数，我们可以使用以下代码：
- en: '[PRE30]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we load source codes of vertex and fragment shaders,
    create shader modules for them, and specify parameters of the shader stages.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们加载了顶点和片段着色器的源代码，为它们创建了着色器模块，并指定了着色器阶段的参数。
- en: 'Next we need to select whatever parameters we would like for vertex bindings
    and vertex attributes:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要选择我们想要的顶点绑定和顶点属性参数：
- en: '[PRE31]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Viewport and scissor test parameters are important. But as we want to define
    them dynamically, only the number of viewports matters during the pipeline creation.
    That''s why here we can specify whatever values we want:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 视口和剪裁测试参数很重要。但因为我们想动态定义它们，所以在管道创建期间只关心视口的数量。这就是为什么在这里我们可以指定我们想要的任何值：
- en: '[PRE32]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next we need to prepare parameters for rasterization and multisample states
    (rasterization must be enabled if we want to use a fragment shader):'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要为光栅化和多采样状态准备参数（如果我们要使用片段着色器，则必须启用光栅化）：
- en: '[PRE33]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We also want to enable a depth test (and depth writes). Usually we want to
    simulate how people or cameras observe the world, where objects near the viewer
    block the view, and obscure objects that are further away. That''s why for the
    depth test, we specify a `VK_COMPARE_OP_LESS_OR_EQUAL` operator which defines
    that samples with lower or equal depth values pass and those with greater depth
    values fail the depth test. Other depth-related parameters and parameters for
    the stencil test can be set as we want, but here we assume the stencil test is
    disabled (so the values of the stencil test parameters don''t matter here):'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望启用深度测试（以及深度写入）。通常我们想要模拟人们或相机观察世界的方式，其中靠近观察者的对象阻挡了视线，并遮挡了更远处的对象。这就是为什么对于深度测试，我们指定一个`VK_COMPARE_OP_LESS_OR_EQUAL`运算符，它定义了具有较低或等于深度值的样本通过，而具有较高深度值的样本则深度测试失败。其他与深度相关的参数和模板测试的参数可以按我们的意愿设置，但在这里我们假设模板测试是禁用的（因此模板测试参数的值在这里不重要）：
- en: '[PRE34]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Blending parameters can be set as we want:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 混合参数可以设置为我们想要的：
- en: '[PRE35]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One last thing is to prepare a list of dynamic states:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是准备动态状态列表：
- en: '[PRE36]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can create a pipeline:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个管道：
- en: '[PRE37]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See also
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Specifying pipeline shader stages*'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道着色器阶段*'
- en: '*Specifying pipeline vertex binding description, attribute description, and
    input state*'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道顶点绑定描述、属性描述和输入状态*'
- en: '*Specifying pipeline input assembly state*'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道输入装配状态*'
- en: '*Specifying pipeline viewport and scissor test state*'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道视口和剪裁测试状态*'
- en: '*Specifying pipeline rasterization state*'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道光栅化状态*'
- en: '*Specifying pipeline multisample state*'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道多采样状态*'
- en: '*Specifying pipeline depth and stencil state*'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道深度和模板状态*'
- en: '*Specifying pipeline blend state*'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道混合状态*'
- en: '*Specifying pipeline dynamic states*'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道动态状态*'
- en: '*Creating a pipeline layout*'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管道布局*'
- en: '*Specifying graphics pipeline creation parameters*'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定图形管道创建参数*'
- en: '*Creating a pipeline cache object*'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管道缓存对象*'
- en: '*Creating a graphics pipeline*'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管道*'
- en: Creating multiple graphics pipelines on multiple threads
  id: totrans-806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个线程上创建多个图形管道
- en: The process of creating a graphics pipeline may take a (relatively) long time.
    Shader compilation takes place during the pipeline creation, the driver checks
    if compiled shaders can be properly linked together and if a state is properly
    specified for the shaders to work correctly. That's why, especially when we have
    lots of pipelines to create, it is good to split this process into multiple threads.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图形管道的过程可能需要（相对）较长时间。着色器编译发生在管道创建过程中，驱动程序检查编译的着色器是否可以正确链接，以及是否为着色器指定了正确状态以便它们可以正确工作。这就是为什么，特别是当我们有很多管道需要创建时，将此过程拆分为多个线程是很好的。
- en: But when we have lots of pipelines to create, we should use a cache to speed
    up the creation even further. Here we will see how to use a cache for multiple
    concurrent pipeline creations and how to merge the cache afterwards.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们有很多管道需要创建时，我们应该使用缓存来进一步加快创建速度。在这里，我们将看到如何为多个并发管道创建使用缓存，以及如何在之后合并缓存。
- en: Getting ready
  id: totrans-809
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we use a custom template wrapper class of a `VkDestroyer<>` class.
    It is used to automatically destroy unused resources.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用一个自定义模板包装类，它是`VkDestroyer<>`类的包装。它用于自动销毁未使用的资源。
- en: How to do it...
  id: totrans-811
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Store the name of the file from which cache contents should be read, and into
    which cache contents should be written, in a variable of type `std::string` named
    `pipeline_cache_filename`.
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从其中读取缓存内容的文件名和写入缓存内容的文件名存储在一个名为`pipeline_cache_filename`的`std::string`类型变量中。
- en: Create a variable of type `std::vector<unsigned char>` named `cache_data`. If
    the file named `pipeline_cache_filename` exists, load its contents into the `cache_data`
    vector.
  id: totrans-813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`cache_data`的`std::vector<unsigned char>`类型的变量。如果名为`pipeline_cache_filename`的文件存在，则将其内容加载到`cache_data`向量中。
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在一个名为`logical_device`的`VkDevice`类型的变量中。
- en: Create a variable of type `std::vector<VkPipelineCache>` named `pipeline_caches`.
    For each separate thread, create a pipeline cache object and store its handle
    in the `pipeline_caches` vector (refer to the *Creating a pipeline cache object*
    recipe).
  id: totrans-815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pipeline_caches`的`std::vector<VkPipelineCache>`类型的变量。对于每个单独的线程，创建一个管道缓存对象并将其句柄存储在`pipeline_caches`向量中（参考*创建管道缓存对象*配方）。
- en: Create a variable of type `std::vector<std::thread>` named `threads`. Resize
    it to store the desired number of threads.
  id: totrans-816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`threads`的`std::vector<std::thread>`类型的变量。调整其大小以存储所需数量的线程。
- en: Create a variable of type `std::vector<std::vector<VkGraphicsPipelineCreateInfo>>`
    named `graphics_pipelines_create_infos`. For each thread, add new vector to the
    `graphics_pipelines_create_infos` variable containing variables of type `VkGraphicsPipelineCreateInfo`,
    where the number of these variables should be equal to the number of pipelines
    that should be created on a given thread.
  id: totrans-817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`graphics_pipelines_create_infos`的`std::vector<std::vector<VkGraphicsPipelineCreateInfo>>`类型的变量。对于每个线程，向`graphics_pipelines_create_infos`变量中添加新的向量，包含类型为`VkGraphicsPipelineCreateInfo`的变量，其中这些变量的数量应等于在给定线程上应创建的管道数量。
- en: Create a variable of type `std::vector<std::vector<VkPipeline>>` named `graphics_pipelines`.
    Resize each member vector that corresponds to each thread to hold the same number
    of pipelines created on a given thread.
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`graphics_pipelines`的`std::vector<std::vector<VkPipeline>>`类型的变量。调整每个成员向量的大小，以存储在给定线程上创建的相同数量的管道。
- en: Create the desired number of threads where each thread creates the selected
    number of pipelines using the `logical_device` variable, a cache corresponding
    to this thread (`pipeline_caches[<thread number>]`), and a corresponding vector
    with elements of type `VkGraphicsPipelineCreateInfo` (`graphics_pipelines_create_infos[<thread
    number>]` vector variable).
  id: totrans-819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需数量的线程，其中每个线程使用`logical_device`变量、对应于此线程的缓存（`pipeline_caches[<线程编号>]`）以及相应类型为`VkGraphicsPipelineCreateInfo`的元素向量（`graphics_pipelines_create_infos[<线程编号>]`向量变量）创建选定的数量管道。
- en: Wait for all threads to finish.
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有线程完成。
- en: Create new cache in a variable of type `VkPipelineCache` named `target_cache`.
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`target_cache`的`VkPipelineCache`类型的变量中创建新的缓存。
- en: Merge pipeline caches stored in the `pipeline_caches` vector into the `target_cache`
    variable (refer to the *Merging multiple pipeline cache objects* recipe).
  id: totrans-822
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储在`pipeline_caches`向量中的管道缓存合并到`target_cache`变量中（参考*合并多个管道缓存对象*食谱）。
- en: Retrieve the cache contents of the `target_cache` variable and store it in the
    `cache_data` vector.
  id: totrans-823
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`target_cache`变量中检索缓存内容并将其存储在`cache_data`向量中。
- en: Save the contents of the `cache_data` vector into the file named `pipeline_cache_filename`
    (replace the file's contents with the new data).
  id: totrans-824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`cache_data`向量的内容保存到名为`pipeline_cache_filename`的文件中（用新数据替换文件的内容）。
- en: How it works...
  id: totrans-825
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating multiple graphics pipelines requires us to provide lots of parameters
    for many different pipelines. But using separate threads, where each thread creates
    multiple pipelines, should reduce the time needed to create all the pipelines.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个图形管道需要我们为许多不同的管道提供大量参数。但是，使用单独的线程，其中每个线程创建多个管道，应该可以减少创建所有管道所需的时间。
- en: 'To speed things even more, it is good to use a pipeline cache. First we need
    to read the previously stored cache contents from the file, if it was created.
    Next we need to create the cache for each separate thread. Each cache should be
    initialized with the cache contents loaded from the file (if it was found):'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快地完成任务，使用管道缓存是个好主意。首先，我们需要从文件中读取之前存储的缓存内容，如果它已经被创建的话。接下来，我们需要为每个单独的线程创建缓存。每个缓存都应该用从文件中加载的缓存内容（如果找到了）来初始化：
- en: '[PRE38]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is to prepare storage space in which handles of pipelines created
    on each thread will be stored. We also start all the threads that create multiple
    pipelines using the corresponding cache object:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为每个线程上创建的管道句柄准备存储空间。我们还使用相应的缓存对象启动创建多个管道的所有线程：
- en: '[PRE39]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we need to wait until all the threads are finished. After that we can merge
    different cache objects (from each thread) into one, from which we retrieve the
    contents. These new contents we can store in the same file from which we loaded
    the contents at the beginning (we should replace the contents):'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要等待直到所有线程都完成。之后，我们可以将不同缓存对象（来自每个线程）合并成一个，从中检索内容。这些新内容我们可以存储在最初加载内容的同一文件中（我们应该替换内容）：
- en: '[PRE40]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See also
  id: totrans-833
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Specifying graphics pipeline creation parameters*'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定图形管道创建参数*'
- en: '*Creating a pipeline cache object*'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管道缓存对象*'
- en: '*Retrieving data from a pipeline cache*'
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从管道缓存中检索数据*'
- en: '*Merging multiple pipeline cache objects*'
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并多个管道缓存对象*'
- en: '*Creating a graphics pipeline*'
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管道*'
- en: '*Destroying a pipeline cache*'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁管道缓存*'
- en: Destroying a pipeline
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁管道
- en: When a pipeline object is no longer needed and we are sure that it is not being
    used by the hardware in any of the submitted command buffers, we can safely destroy
    it.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道对象不再需要，并且我们确信它没有被任何提交的命令缓冲区中的硬件使用时，我们可以安全地销毁它。
- en: How to do it...
  id: totrans-843
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a logical device. Use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄。使用它来初始化一个名为`logical_device`的`VkDevice`类型变量。
- en: Take the handle of a pipeline object that should be destroyed. Store it in a
    variable of type `VkPipeline` named `pipeline`. Make sure it is not being referenced
    by any commands submitted to any of the available queues.
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应该被销毁的管道对象的句柄。将其存储在名为`pipeline`的`VkPipeline`类型变量中。确保它没有被任何提交到任何可用队列的命令引用。
- en: Call `vkDestroyPipeline( logical_device, pipeline, nullptr )` for which provide
    the `logical_device` and `pipeline` variables and a `nullptr` value.
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkDestroyPipeline(logical_device, pipeline, nullptr)`，其中提供`logical_device`和`pipeline`变量以及一个`nullptr`值。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `pipeline` variable.
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将`VK_NULL_HANDLE`值分配给`pipeline`变量。
- en: How it works...
  id: totrans-848
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When a pipeline is no longer needed, we can destroy it by calling the `vkDestroyPipeline()`
    function like this:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道不再需要时，我们可以通过调用`vkDestroyPipeline()`函数来销毁它，如下所示：
- en: '[PRE41]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Pipeline objects are used during rendering. So before we can destroy them, we
    must make sure all the rendering commands that used them are already finished.
    This is best done by associating a fence object with a submission of a given command buffer.
    After that we need to wait for the fence before we destroy pipeline objects referenced
    in that command buffer (refer to the *Waiting for fences* recipe). However, other
    synchronization methods are also valid.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 管线对象在渲染过程中被使用。因此，在我们能够销毁它们之前，我们必须确保所有使用它们的渲染命令都已经完成。这最好通过将栅栏对象与给定命令缓冲区的提交关联起来来完成。之后，我们需要等待栅栏，然后才能销毁在命令缓冲区中引用的管线对象（参考
    *等待栅栏* 食谱）。然而，其他同步方法也是有效的。
- en: See also
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步* 中，查看以下食谱：
- en: '*Waiting for fences*'
  id: totrans-854
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Waiting for all submitted commands to be finished*'
  id: totrans-855
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待所有提交的命令完成*'
- en: 'The following recipes in this chapter:'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a graphics pipeline*'
  id: totrans-857
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-858
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: Destroying a pipeline cache
  id: totrans-859
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁管线缓存
- en: A pipeline cache is not used in any commands recorded in a command buffer. That's
    why, when we have created all the pipelines we wanted, merged cache data, or retrieved
    its contents, we can destroy the cache.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 管线缓存不在任何记录在命令缓冲区中的命令中使用。这就是为什么，当我们创建了所有想要的管线、合并了缓存数据或检索了其内容后，我们可以销毁缓存。
- en: How to do it...
  id: totrans-861
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Store the handle of a logical device in a variable of type `VkDevice` named
    `logical_device`.
  id: totrans-862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑设备的句柄存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Take the handle of a pipeline cache object that should be destroyed. Use the
    handle to initialize a variable of type `VkPipelineCache` named `pipeline_cache`.
  id: totrans-863
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到应该被销毁的管线缓存对象句柄。使用句柄来初始化一个名为 `pipeline_cache` 的 `VkPipelineCache` 类型变量。
- en: Call `vkDestroyPipelineCache( logical_device, pipeline_cache, nullptr )` and
    provide the `logical_device` and `pipeline_cache` variables, and a `nullptr` value.
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyPipelineCache( logical_device, pipeline_cache, nullptr )` 并提供 `logical_device`
    和 `pipeline_cache` 变量，以及一个 `nullptr` 值。
- en: For safety reasons, store the `VK_NULL_HANDLE` value in the `pipeline_cache`
    variable.
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值存储在 `pipeline_cache` 变量中。
- en: How it works...
  id: totrans-866
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Pipeline cache objects can be used only during the creation of pipelines, for
    retrieving data from it, and for merging multiple caches into one. None of these
    operations are recorded in the command buffers, so as soon as any function performing
    one the mentioned operations has finished, we can destroy the cache like this:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 管线缓存对象只能在创建管线、从其中检索数据以及将多个缓存合并为一个时使用。这些操作都不会记录在命令缓冲区中，因此，一旦执行上述任何操作的函数完成，我们就可以像这样销毁缓存：
- en: '[PRE42]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-869
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a pipeline cache object*'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线缓存对象*'
- en: '*Retrieving data from a pipeline cache*'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从管线缓存中检索数据*'
- en: '*Merging multiple pipeline cache objects*'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并多个管线缓存对象*'
- en: '*Creating a graphics pipeline*'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: Destroying a pipeline layout
  id: totrans-876
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁管线布局
- en: When we don't need a pipeline layout anymore, and we don't intend to create
    more pipelines with it, bind descriptor sets or update push constants that used
    the given layout, and all operations using the pipeline layout are already finished,
    we can destroy the layout.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要管线布局，并且不打算用它创建更多管线，绑定使用该布局的描述符集或更新推送常量，并且所有使用管线布局的操作都已经完成时，我们可以销毁布局。
- en: How to do it...
  id: totrans-878
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a logical device. Use it to initialize a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-879
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到逻辑设备的句柄。使用它来初始化一个名为 `logical_device` 的 `VkDevice` 类型的变量。
- en: Take the handle of a pipeline layout stored in a variable of type `VkPipelineLayout`
    named `pipeline_layout`.
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个存储在名为 `pipeline_layout` 的 `VkPipelineLayout` 类型变量中的管线布局句柄。
- en: Call `vkDestroyPipelineLayout( logical_device, pipeline_layout, nullptr )`.
    For the call, provide the `logical_device` and `pipeline_layout` variables and
    a `nullptr` value.
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyPipelineLayout( logical_device, pipeline_layout, nullptr )`。对于这个调用，提供
    `logical_device` 和 `pipeline_layout` 变量以及一个 `nullptr` 值。
- en: For safety reasons, assign a `VK_NULL_HANDLE` to the `pipeline_layout` variable.
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 赋值给 `pipeline_layout` 变量。
- en: How it works...
  id: totrans-883
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Pipeline layouts are used only in three situations--creating pipelines, binding
    descriptor sets, and updating push constants. When a given pipeline layout was
    used only to create a pipeline, it may be destroyed immediately after the pipeline
    is created. If we are using it to bind descriptor sets or update push constants,
    we need to wait until the hardware stops processing command buffers, in which
    these operations were recorded. Then, we can safely destroy the pipeline layout
    using the following code:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 管线布局仅在三种情况下使用--创建管线、绑定描述符集和更新推送常量。当给定的管线布局仅用于创建管线时，它可以在管线创建后立即销毁。如果我们使用它来绑定描述符集或更新推送常量，我们需要等待硬件停止处理记录了这些操作的命令缓冲区。然后，我们可以安全地使用以下代码销毁管线布局：
- en: '[PRE43]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also
  id: totrans-886
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*, see the following recipes:'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)的*命令缓冲区和同步*部分，见以下食谱：
- en: '*Waiting for fences*'
  id: totrans-888
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待栅栏*'
- en: '*Waiting for all submitted commands to be finished*'
  id: totrans-889
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待所有提交的命令完成*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)的*描述符集*部分，见以下食谱：
- en: '*Binding descriptor sets*'
  id: totrans-891
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'The following recipes in this chapter:'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a pipeline layout*'
  id: totrans-893
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*'
- en: '*Creating a graphics pipeline*'
  id: totrans-894
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-895
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: '*Providing data to shaders through push constants*'
  id: totrans-896
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: Destroying a shader module
  id: totrans-897
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁着色器模块
- en: Shader modules are used only for creating pipeline objects. After they are created,
    we can immediately destroy them, if we don't intend to use them anymore.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器模块仅用于创建管线对象。在创建后，如果我们不再打算使用它们，我们可以立即销毁它们。
- en: How to do it...
  id: totrans-899
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the handle of a logical device to initialize a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-900
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用逻辑设备的句柄初始化一个名为`logical_device`的`VkDevice`类型变量。
- en: Take the shader module's handle stored in a variable of type `VkShaderModule`
    named `shader_module`.
  id: totrans-901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出存储在名为`shader_module`的`VkShaderModule`类型变量中的着色器模块句柄。
- en: Call `vkDestroyShaderModule( logical_device, shader_module, nullptr )` providing
    the `logical_device` variable, the `shader_module` variable, and a `nullptr` value.
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkDestroyShaderModule( logical_device, shader_module, nullptr )`，提供`logical_device`变量、`shader_module`变量和一个`nullptr`值。
- en: Assign a `VK_NULL_HANDLE` value to the `shader_module` variable for safety reasons.
  id: totrans-903
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将`shader_module`变量的值设置为`VK_NULL_HANDLE`。
- en: How it works...
  id: totrans-904
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Shader modules are used only during the pipeline creation. They are provided
    as part of a shader stages state. When pipelines that use given modules are already
    created, we can destroy the modules (immediately after the pipeline creating functions
    have finished), as they are not needed for the pipeline objects to be correctly
    used by the driver.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器模块仅在管线创建期间使用。它们作为着色器阶段状态的一部分提供。当使用给定模块的管线已经创建时，我们可以在管线创建函数完成后立即销毁这些模块（因为它们对于驱动程序正确使用管线对象不再需要）。
- en: Created pipelines don't need shader modules anymore to be successfully used.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的管线不再需要着色器模块即可成功使用。
- en: 'To destroy a shader module, use the following code:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁着色器模块，请使用以下代码：
- en: '[PRE44]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-909
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a shader module*'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying pipeline shader stages*'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线着色器阶段*'
- en: '*Creating a graphics pipeline*'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Creating a compute pipeline*'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
