- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numeric and Range -Based Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will uncover the potential of the powerful numeric and
    sorting operations of the C++ **Standard Template Library** (**STL**). These functions
    breathe life into sequences, making tasks such as accumulation, transformation,
    and querying using sorted ranges a breeze. Readers will gain insights into elementary
    and advanced numeric operations and discover the utility of working with sorted
    collections. When paired with best practices, this chapter ensures developers
    have a robust toolset to optimize, parallelize, and handle numeric data with finesse.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic numeric operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced numeric operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations on sorted ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Basic numeric operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unearthing the power of the C++ STL’s numeric functions is a refreshing experience.
    In this section, we’ll dive deep into the foundational numeric operations. By
    mastering these, you’ll unlock the capability to generate sequences, compute comprehensive
    summaries, and efficiently execute sophisticated operations on contiguous elements.
    So, buckle up, and let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Generating sequences with std::iota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first treasure we’re going to unearth is `std::iota`. It’s a simple yet
    powerful tool in the numeric operations chest. `std::iota` fills a range with
    a sequence of consecutive values. Starting from an initial value, it assigns increasing
    values to subsequent elements in the range. Here, you can see that `std::itoa`
    fills a vector with five consecutive integers, starting with 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is a boon when you want a container to hold many contiguous sequences
    of numbers without manually inputting each one. Consider a scenario where you
    want a `std::vector` to hold timesteps for a constructive simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `std::iota` is used to generate a sequence of time steps, which
    can be used to model the behavior of a system over time. While this is a simplified
    example, in real-world applications, you can use `std::iota` as a foundation for
    more complex simulations and modeling scenarios, such as physics simulations,
    financial modeling, or scientific research.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::iota` helps create a time series or discrete event timeline, which can
    be a fundamental component in various computational simulations and modeling tasks.
    Its value becomes more apparent when integrated into larger, more complex systems
    where time sequencing or indexing is crucial.'
  prefs: []
  type: TYPE_NORMAL
- en: Summing elements with std::accumulate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say you have a sequence of numbers and wish to find their sum (or maybe a product).
    Enter `std::accumulate`. This algorithm is primarily used to compute the sum over
    a range of elements. Let’s look at the following simple example in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is primarily used to compute the sum of a range of elements, but its power
    doesn’t stop there. With its flexible design, `std::accumulate` can also be employed
    for other operations, such as finding products or concatenating strings. By providing
    a custom binary operation, its applications are broadened significantly. Here
    is a simple example of how `std::accumulate` can be used with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With some creativity, `std::accumulate` can become a versatile tool in your
    algorithmic toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacent elements and their interactions with std::adjacent_difference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we’re interested in individual elements and pairs of adjacent elements.
    The STL has got your back here with `std::adjacent_difference`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::adjacent_difference` calculates the difference between an element and
    its predecessor and stores it in another sequence. This operation is beneficial
    in tasks such as computing discrete derivatives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the usage of `std::adjacent_difference`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Not just for differences, you can pass custom binary operations to `std::adjacent_difference`
    to achieve varied results, such as ratios. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Inner products with std::inner_product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function is a marvel for those who’ve dabbled in linear algebra. `std::inner_product`
    calculates the dot product of two ranges. As you might recall, the dot product
    is the sum of the products of corresponding pairs from two sequences. Let’s look
    at how to compute the dot product of two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`std::inner_product` isn’t just limited to integers or plain multiplication.
    Custom binary operations can be tailored to work on different types and operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some real-world examples to demonstrate that `std::inner_product`
    can work with custom binary operations tailored to different types and operations
    beyond just integers and plain multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::inner_product` to calculate the weighted average of elements in two containers,
    where one container holds values, and the other container holds the corresponding
    weights. The custom binary operation would perform the element-wise multiplication
    of the values and weights and then sum them up to find the weighted average.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::inner_product` with a custom binary operation to calculate the portfolio’s
    total value by multiplying the asset prices by their respective quantities and
    summing them up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::inner_product` can be used with a custom binary operation for this purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::inner_product` can be adapted with a custom binary operation to perform
    matrix multiplication efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::inner_product` to perform complex number operations, such as calculating
    the inner product of two complex vectors or finding the sum of the squares of
    complex numbers. The custom binary operation would be tailored to complex number
    arithmetic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::inner_product` with a custom binary operation that concatenates strings.
    This allows you to join a collection of strings efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::inner_product` can be adapted with a custom binary operation to perform
    color blending based on the desired algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples illustrate that `std::inner_product` is a versatile algorithm
    that can be customized for various types and operations. This makes it useful
    in many real-world applications beyond simple integer multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen that the basic numeric operations provided by
    the C++ STL pave the way for the efficient computation, generation, and manipulation
    of sequences. They transform how developers approach problems, allowing for swift
    and effective solutions. As we’ve seen, these algorithms are versatile and, with
    a pinch of creativity, can be adapted to a myriad of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: With these tools in your utility belt, you’re now equipped to generate sequences,
    compute quick summaries, and perform intricate operations on consecutive elements.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced numeric operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to take our journey with the numeric operations of the C++ STL a step
    further, let’s look at the advanced numerical procedures that elevate data handling
    and make parallelism and concurrency allies in the pursuit of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our discussion about generating sequences and computing summaries?
    Well, imagine supercharging these operations to process enormous volumes of data
    efficiently by harnessing the power of multiple processors. This is precisely
    where advanced numeric operations shine. Parallel algorithms, introduced in C++17,
    provide the means to achieve this, ensuring our computations are both swift and
    efficient, even in concurrent environments.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with vast datasets, sequential processing often doesn’t cut it.
    Take the example of summing up a large vector of numbers. Doing it in a straight
    line gets the job done but might not be the quickest. However, the operation can
    be sped up significantly by splitting the data and working on chunks concurrently.
    This is the essence of parallel algorithms, and functions such as `std::reduce`
    exemplify this. Instead of sequentially accumulating values, `std::reduce` can
    accumulate subtotals in parallel and then combine them, offering a significant
    boost in performance for large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let’s calculate the sum of all numbers in a large vector
    in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Diving into parallel operations requires a nuanced approach. While the promise
    of speed is tempting, one must be cautious. Parallelism introduces challenges
    such as ensuring thread safety and managing data races. Thankfully, the STL offers
    a remedy through execution policies. By specifying an execution policy, such as
    `std::execution::par`, when invoking an algorithm, we can direct it to run in
    parallel. Additionally, there’s `std::execution::par_unseq` for parallel and vectorized
    execution, ensuring even greater throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of transformation, let’s look into `std::transform_reduce`. This is
    a fusion of `std::transform` and `std::reduce`. It applies a transformation function
    to each range element and reduces the results into a single value, which can be
    parallelized. For instance, if we had a vector of numbers and wanted to square
    each element and then sum up the squared values, `std::transform_reduce` would
    be our go-to, especially when dealing with a substantial amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can use `std::transform_reduce` to square each element of
    a vector and then sum up the squared values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another feather in the cap of advanced operations is the `std::inclusive_scan`
    and `std::exclusive_scan` duo. These are powerful tools for generating prefix
    sums. `std::inclusive_scan` includes the ith input element in the ith sum, whereas
    `std::exclusive_scan` doesn’t. Like their fellow advanced numeric operations,
    they, too, can be supercharged with parallel execution for heightened performance.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A `i` in the input sequence, the corresponding element in the output sequence
    contains the sum of all elements from index `0` to `i` in the input sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel operations can be resource-intensive. It’s essential to ensure that
    the hardware can handle the parallelism and that the amount of data is large enough
    to justify the overhead of concurrent execution. Additionally, always be vigilant
    about potential pitfalls such as data races or deadlocks. The key is constantly
    weighing the pros and cons, analyzing the specific requirements, and choosing
    the most suitable approach.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on sorted ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The allure of sorting isn’t just about placing elements for the sake of neatness.
    Instead, it is about the power it grants us in subsequent operations—streamlined
    navigation, efficient querying, and enhanced manipulation capabilities. For C++
    developers, understanding operations on sorted ranges is like acquiring a new
    set of superpowers. Armed with the C++ STL’s tools for these sorted sequences,
    the world of efficient algorithmic operations becomes an open field, ready for
    exploration.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s the big deal about having sorted ranges? Consider the difference
    between looking for a book in a disordered pile versus finding it on a neatly
    organized shelf. When the data are sorted, algorithms can take shortcuts, such
    as dividing and conquering, leading to logarithmic rather than linear-time complexities.
  prefs: []
  type: TYPE_NORMAL
- en: A primary technique leveraged for sorted ranges is `std::lower_bound` and `std::upper_bound`
    are your go-to functions for this purpose. The former finds the first position
    where a value should be inserted to maintain the order, while the latter identifies
    the last suitable spot. Together, they can determine the range of entries equivalent
    to a given value. If you’ve ever marveled at the rapidity with which some applications
    return search results, binary search techniques such as these are often to thank.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on the topic of queries, `std::equal_range` steps in as a combination
    of the aforementioned functions, returning both the lower and upper bounds of
    a value in a sorted range; if you just need a straightforward check, `std::binary_search`
    tells you if an element exists in the sorted range. These tools simplify querying,
    making it both swift and precise.
  prefs: []
  type: TYPE_NORMAL
- en: However, operations on sorted ranges aren’t confined to searches. Set operations,
    reminiscent of our elementary math lessons, come alive with sorted data. If you’ve
    two sorted sequences and wish to determine their common elements, `std::set_intersection`
    is the tool for the job. For those elements that belong to one sequence but not
    to the other, turn to `std::set_difference`. If you’re in the mood to combine
    the elements of two sequences while maintaining the sort order, `std::set_union`
    stands ready. Last but not least, for finding elements unique to each sequence,
    `std::set_symmetric_difference` serves the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the power that these operations grant. Comparing two large datasets
    to find commonalities or differences is a frequent requirement in many applications,
    from databases to data analytics. By working on sorted ranges, these operations
    become feasible and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted operations presume, quite reasonably, that the data is sorted. If this
    invariant isn’t maintained, the results can be unpredictable. So, ensuring the
    sort order is paramount before diving into these operations. Thankfully, with
    functions such as `std::is_sorted`, one can verify the sorted nature of a range
    before venturing further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pull all of these concepts together into a quick example of how they
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is evident from these examples that operations on sorted ranges unlock a
    realm of possibilities. They exemplify the blend of mathematical theory and practical
    coding, creating a robust framework for developers to navigate, query, and manipulate
    data with unparalleled efficiency. As we move forward, we’ll explore the best
    practices associated with numeric and range-based operations, ensuring that as
    we harness their power, we do so with precision, efficiency, and finesse. The
    journey of discovery and mastery continues!
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following best practices are associated with numeric and range-based operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::stable_sort` may prove more efficient than other sorting methods for
    a nearly sorted dataset. Thus, understanding your dataset’s characteristics is
    pivotal when deciding appropriate operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_sorted` before proceeding with sorted operations is recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using parallel algorithms judiciously**: With the growing emphasis on concurrency,
    parallel algorithms present an attractive option to boost performance. The C++
    STL provides parallel versions of many standard algorithms. While these algorithms
    capitalize on multiple CPU cores to deliver faster results, they can also introduce
    challenges, especially regarding thread safety. A primary concern in concurrent
    programming is a shared mutable state. Issues arise when multiple threads attempt
    to simultaneously modify the same data. To use parallel algorithms safely, it’s
    critical that threads either work on distinct data sections or employ synchronization
    tools, such as mutexes, to manage simultaneous data modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, parallelism isn’t always the answer. The overhead from managing
    multiple threads can sometimes negate the benefits of parallel execution, especially
    for small datasets or straightforward tasks. To determine the effectiveness of
    parallelism in a given scenario, it’s beneficial to profile your code in both
    sequential and parallel configurations. This assessment aids in choosing the most
    efficient method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we’ve explored how to choose the right algorithms in the C++
    STL based on data properties, emphasizing the importance of dataset characteristics
    such as size and distribution. Selecting an appropriate algorithm, such as `std::stable_sort`,
    for nearly sorted data is crucial for optimal performance. We also highlighted
    the necessity of maintaining data order for sorted operations, using tools such
    as `std::is_sorted` to ensure data integrity. Parallel algorithms were discussed,
    focusing on their benefits and complexities, such as thread safety. The key takeaway
    is that parallelism, while powerful, requires careful consideration, especially
    regarding dataset size and task complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have immersed ourselves in the versatile world of algorithms
    provided by the C++ STL that handle numeric sequences and operate on sorted ranges.
    We started with basic numeric operations, such as generating sequences with `std::iota`,
    summing elements with accumulate, and exploring the interactions of adjacent elements
    with `std::adjacent_difference`. The chapter explored more complex tasks, such
    as computing inner products with `std::inner_product`.
  prefs: []
  type: TYPE_NORMAL
- en: These operations are essential in data handling and analysis within STL containers,
    facilitating tasks from simple accumulations to complex transformations. The information
    presented is crucial for developers, as it enhances efficiency and efficacy when
    performing numerical computations and prepares them for high-performance scenarios,
    especially when dealing with large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also covered advanced numeric operations, which are particularly
    beneficial in parallel computing environments. We learned how to employ parallel
    algorithms for data transformation and summarization, ensuring high performance
    in concurrent environments. Operations on sorted ranges were explored, illustrating
    the efficiency of binary search techniques and the functionality of set operations,
    which are significantly optimized by the data’s sorted nature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will venture into ranges, representing a more contemporary
    approach to sequences in C++. We will explore why there has been a shift toward
    range-based operations, understand the essence and power of these modern STL components,
    and explore their composability for sorting and searching algorithms. This upcoming
    chapter will empower readers with the knowledge to embrace the full potential
    of the modern STL, making informed decisions on when and how to apply these new
    tools in their C++ programming endeavors.
  prefs: []
  type: TYPE_NORMAL
