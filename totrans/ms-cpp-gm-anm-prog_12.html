<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer114" class="Basic-Text-Frame">
    <h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-253" class="chapterTitle">Adding Behavior and Interaction</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 9</em></a>! In the previous chapter, we took a deeper look into collision detection. After a discussion about the complexity of finding colliding instances in the virtual world, we explored ways to speed up the collision search by adding world partitioning and model simplifications. Then, we implemented a quadtree to split up the world into smaller areas, and we added bounding boxes and bounding spheres for the instances. Finally, we used both the quadtree and the instance boundaries to detect a collision between instances.</p>
    <p class="normal">In this chapter, we will add some sort of “real-life” behavior to the instances, giving them the ability to walk around the virtual world by themselves and react to events like the collisions we added in the previous chapter. First, we will take a brief look at behavior trees and state machines and how both works. Then, we will add a visual editor to visually represent the state machines of the instances themselves. At the end of the chapter, we will extend the code to execute the behavior changes from the created node trees, and we will add interaction as an additional form of behavior.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Structures to control instance behavior</li>
      <li class="bulletList">Adding a visual node editor</li>
      <li class="bulletList">Extending the code to support behavior changes</li>
      <li class="bulletList">Adding interaction between instances</li>
    </ul>
    <h1 id="_idParaDest-254" class="heading-1">Technical requirements</h1>
    <p class="normal">The example code can be found in the folder <code class="inlineCode">chapter09</code>, in the subfolder <code class="inlineCode">01_opengl_behavior</code> for OpenGL and <code class="inlineCode">02_vulkan_behavior</code> for Vulkan.</p>
    <h1 id="_idParaDest-255" class="heading-1">Structures to control instance behavior</h1>
    <p class="normal">In the early days of <a id="_idIndexMarker418"/>computer games, the behavior of enemies and other <strong class="keyWord">non-player characters</strong> (<strong class="keyWord">NPCs</strong>) was rather <a id="_idIndexMarker419"/>simple. Based on only the game state or a few properties, like <em class="italic">The player has eaten a large dot, I must stay away from them!</em> (Pac-Man) or <em class="italic">I saw the player, so I will attack them!</em> (many first-person shooters), the computer counterparts were acting only with a small set of rules.</p>
    <p class="normal">Later, control structures like “plain” state machines, hierarchical state machines, and behavior trees changed<a id="_idIndexMarker420"/> the <strong class="keyWord">artificial intelligence</strong> (<strong class="keyWord">AI</strong>) in games a lot, since it became easy to model complex tasks for enemies and NPCs. Now, it is possible to not only create more alternatives for behavior choices but also let computer-controlled world inhabitants act more like intelligent beings. Spotting the player may lead to a handful of different outcomes from NPCs, based on world factors, their own properties, and a bit of randomness.</p>
    <p class="normal">A behavior tree <a id="_idIndexMarker421"/>simplifies creating behaviors for NPCs and helps reasoning about the states the NPC will be in at any given time. Still, a behavior tree is only an enhanced finite state machine with nodes and links between nodes. The current state of the tree is memorized by the behavior subsystem, and based on configured factors in the nodes, state changes to subsequent nodes in the tree are executed. Without huge complexity, behavior trees are easy to implement but still powerful in games.</p>
    <p class="normal">A common way to create a behavior tree is by using specialized nodes, for instance:</p>
    <ul>
      <li class="bulletList">Selectors, choosing one among a set of options</li>
      <li class="bulletList">Sequences, running tasks in a specific order</li>
      <li class="bulletList">Conditions, using the outcome of previous nodes to choose the next node</li>
      <li class="bulletList">Loops, which repeat a part of the tree several times until a condition is met</li>
      <li class="bulletList">Actions, which affect the character state or perform an action, like attacking</li>
      <li class="bulletList">World perception, changing behavior based on events or world properties</li>
    </ul>
    <p class="normal">Using special nodes helps a lot in building a flexible behavior tree. The enemy or NPC can gather information about the world and other objects in it and choose a different path on the next tree execution if the world around it changes, leading to a more reactive, believable, and less robotic behavior by not doing the same moves and actions repeatedly.</p>
    <p class="normal"><em class="italic">Figure 9.1</em> shows a simple idea for an NPC behavior:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_01.png" alt="" width="1650" height="667"/></figure>
    <p class="packt_figref">Figure 9.1: A simple behavior plan</p>
    <p class="normal">Even though the plan looks straightforward, it encapsulates sophisticated behavior. Considering the enemy’s distance and health status while scanning the plan for the desired behavior should result in fairly impressive NPC actions. By switching, with random variations, between taking cover and a range attack, directly attacking approaching enemies, or just trying to hide or run away as the last option, watching a group of these NPCs fighting incoming enemies would be entertaining.</p>
    <p class="normal">We will add a simple state machine to control the behavior of the instances in this chapter. Also, to simplify creating and controlling the behavior with the state machine, we will add a tool to create nodes and links. So, let’s go on a short detour and add a visual node editor to the application.</p>
    <h1 id="_idParaDest-256" class="heading-1">Adding a visual node editor</h1>
    <p class="normal">Like in the previous chapters, we<a id="_idIndexMarker422"/> will use an open-source tool to build our visual node editor instead of building our own solutions by hand. There are several ImGui-based node editors available. You can find a curated list in the <em class="italic">Additional resources</em> section.</p>
    <p class="normal">In this chapter, we will use the extension <a id="_idIndexMarker423"/>called <strong class="keyWord">imnodes</strong> by Johann “Nelarius” Muszynski. The source code for<a id="_idIndexMarker424"/> imnodes is available on GitHub:</p>
    <p class="normal"><a href="https://github.com/Nelarius/imnodes"><span class="url">https://github.com/Nelarius/imnodes</span></a></p>
    <p class="normal">Like in the previous chapters, we will use CMake to fetch imnodes for us.</p>
    <h2 id="_idParaDest-257" class="heading-2">Integrating imnodes by using CMake</h2>
    <p class="normal">To let CMake <a id="_idIndexMarker425"/>manage imnodes as a dependency, add a new <code class="inlineCode">FetchContent</code> block to <a id="_idIndexMarker426"/>the file <code class="inlineCode">CMakeLists.txt</code> in the project root between the <code class="inlineCode">FetchContent</code> block for <code class="inlineCode">stbi</code> and the <code class="inlineCode">WIN32</code>-only area:</p>
    <pre class="programlisting code"><code class="hljs-code">FetchContent_Declare(
  imnodes
  GIT_REPOSITORY https://github.com/Nelarius/imnodes
  GIT_TAG v0.<span class="hljs-number">5</span>
)
</code></pre>
    <p class="normal">We will use the Git tag <code class="inlineCode">v0.5</code> here to avoid problems introduced by new commits to the <code class="inlineCode">master</code> branch, resulting in not finding the ImGui source code.</p>
    <p class="normal">Next, we make the imnodes code available and let CMake populate the variable for the source folder:</p>
    <pre class="programlisting code"><code class="hljs-code">FetchContent_MakeAvailable(imnodes)
FetchContent_GetProperties(imnodes)
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> imnodes_POPULATED)
  FetchContent_Populate(imnodes)
  <span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-variable">${imnodes_SOURCE_DIR}</span> EXCLUDE_FROM_ALL)
<span class="hljs-keyword">endif</span>()
</code></pre>
    <p class="normal">Then, we append the source directory variable for imnodes to the list of already existing external source files and include directories:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">file</span>(GLOB SOURCES
  ...
  <span class="code-highlight"><strong class="hljs-variable-slc">${imnodes_SOURCE_DIR}</strong><strong class="hljs-slc">/imnodes.cpp</strong></span>
)
...
<span class="code-highlight"><strong class="hljs-keyword-slc">target_include_directories</strong><strong class="hljs-slc">(... </strong><strong class="hljs-variable-slc">${imnodes_SOURCE_DIR}</strong><strong class="hljs-slc">)</strong></span>
</code></pre>
    <p class="normal">As a last step, we add a compiler definition to the existing <code class="inlineCode">add_definitions</code> line:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">add_definitions</span>(... -DIMGUI_DEFINE_MATH_OPERATORS)
</code></pre>
    <p class="normal">By <a id="_idIndexMarker427"/>setting <code class="inlineCode">IMGUI_DEFINE_MATH_OPERATORS</code>, ImGui exposes some of the<a id="_idIndexMarker428"/> internal mathematical operations to external modules like imnodes.</p>
    <p class="normal">After running CMake, which most IDEs will perform automatically after saving the <code class="inlineCode">CMakeLists.txt</code> file, imnodes is available and can be included in the user interface. Now, let us learn how to work with imnodes.</p>
    <h2 id="_idParaDest-258" class="heading-2">Using imnodes to create UI elements</h2>
    <p class="normal">Since<a id="_idIndexMarker429"/> imnodes is based on ImGui, imnodes function calls are like ImGui <a id="_idIndexMarker430"/>calls, with imnodes acting as a container to enclose the UI elements in a graphical node representation. A graphical node, like the wait node shown in <em class="italic">Figure 9.2</em>, can be added and removed dynamically to a node editor window, and links between input and output pins can be created.</p>
    <figure class="mediaobject"><img src="../Images/figure_09_02.png" alt="" width="1214" height="517"/></figure>
    <p class="packt_figref">Figure 9.2: The elements of a simple imnodes wait node</p>
    <p class="normal">Elements of a node are the title bar and an arbitrary number of input pins, output pins, and static elements. In the title bar, a descriptive name to identify the node type is shown, like the word <strong class="screenText">Wait</strong> in <em class="italic">Figure 9.2</em>. The input pin of the wait node is used to connect parent node(s) to this specific node, and on the output pin, one or more child nodes can be connected. All user controls are built using static elements, such as the slider for the time to wait, or the <a id="_idIndexMarker431"/>text field showing the time running toward 0 if the <a id="_idIndexMarker432"/>wait node was activated.</p>
    <p class="normal">But imnodes only maintains the nodes and links. We must implement the logic behind the node editor according to our needs. To get a better impression of how much – or how little – effort is needed to create such a node editor, we will walk through the steps needed to draw a node like in <em class="italic">Figure 9.2</em> to the screen.</p>
    <h3 id="_idParaDest-259" class="heading-3">Creating the imnodes context</h3>
    <p class="normal">Like ImGui, imnodes <a id="_idIndexMarker433"/>needs a basic set of data about the current session, that is, the context. The imnodes context must be created after ImGui’s context, as imnodes relies on data from ImGui. So, the <code class="inlineCode">init()</code> method of the <code class="inlineCode">UserInterface</code> class will be extended by the <code class="inlineCode">CreateContext()</code> call of imnodes:</p>
    <pre class="programlisting code"><code class="hljs-code">  ImGui::<span class="hljs-built_in">CreateContext</span>();
  <span class="code-highlight"><strong class="hljs-slc">ImNodes::</strong><strong class="hljs-built_in-slc">CreateContext</strong><strong class="hljs-slc">();</strong></span>
</code></pre>
    <p class="normal">imnodes’ context needs to be destroyed before ImGui’s context. To do that, we call <code class="inlineCode">DestroyContext()</code> of imnodes before ImGui’s <code class="inlineCode">DestroyContext()</code> in the <code class="inlineCode">cleanup()</code> method of the <code class="inlineCode">UserInterface</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="code-highlight"><strong class="hljs-slc">ImNodes::</strong><strong class="hljs-built_in-slc">DestroyContext</strong><strong class="hljs-slc">();</strong></span>
  ImGui::<span class="hljs-built_in">DestroyContext</span>();
</code></pre>
    <p class="normal">With the context ready, we can start to use the function calls to imnodes. Similar to the <code class="inlineCode">ImGui</code> namespace, the <code class="inlineCode">ImNodes</code> namespace will be used as a prefix.</p>
    <h3 id="_idParaDest-260" class="heading-3">Setting default values for imnodes</h3>
    <p class="normal">Choosing a global color style<a id="_idIndexMarker434"/> can be done exactly like in ImGui. For instance, to set the “light” color style for ImGui and imnodes, use the following lines in the <code class="inlineCode">init()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  ImGui::<span class="hljs-built_in">StyleColorsLight</span>();
  ImNodes::<span class="hljs-built_in">StyleColorsLight</span>();
</code></pre>
    <p class="normal">Another call in the <code class="inlineCode">init()</code> method of the <code class="inlineCode">UserInterface</code> class can be made to set the modifier key used to detach links from a node. By default, imnodes uses the <code class="inlineCode">Alt</code> key to detach a link. With the following two lines, we can set the key binding to use the <code class="inlineCode">Control</code> key instead:</p>
    <pre class="programlisting code"><code class="hljs-code">  ImNodesIO&amp; io = ImNodes::<span class="hljs-built_in">GetIO</span>();
  io.LinkDetachWithModifierClick.Modifier =
    &amp;ImGui::<span class="hljs-built_in">GetIO</span>().KeyCtrl;
</code></pre>
    <p class="normal">After we change the defaults (or not), the node editor window itself will be created.</p>
    <h3 id="_idParaDest-261" class="heading-3">Creating the node editor</h3>
    <p class="normal">Like any other ImGui element, the <a id="_idIndexMarker435"/>node editor must be created inside an ImGui window. We call <code class="inlineCode">BeginNodeEditor()</code> right after the start of a new ImGui window:</p>
    <pre class="programlisting code"><code class="hljs-code">ImGui::<span class="hljs-built_in">Begin</span>(<span class="hljs-string">"Node editor"</span>);
ImNodes::<span class="hljs-built_in">BeginNodeEditor</span>();
</code></pre>
    <p class="normal">Now you should see a window with a visible grid – the node editor. All imnodes and ImGui calls are available in this context, although it is not possible to draw ImGui elements directly onto the node editor as they will overlay the node editor elements.</p>
    <p class="normal">To end the node editor and the ImGui window, we call <code class="inlineCode">EndNodeEditor()</code> just before ending the ImGui window. If we want to have a transparent mini map of the entire node editor window shown on the top left of the window, we can call <code class="inlineCode">MiniMap()</code> before ending the editor:</p>
    <pre class="programlisting code"><code class="hljs-code">ImNodes::<span class="hljs-built_in">MiniMap</span>();
ImNodes::<span class="hljs-built_in">EndNodeEditor</span>();
ImGui::<span class="hljs-built_in">End</span>();
</code></pre>
    <p class="normal">At this point, the node editor window will look like <em class="italic">Figure 9.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_03.png" alt="" width="1342" height="1018"/></figure>
    <p class="packt_figref">Figure 9.3: A fresh node editor window</p>
    <p class="normal">Inside the node <a id="_idIndexMarker436"/>editor window, new nodes can be created. For a small example, we will hardcode all properties into the node. In the section <em class="italic">Extending the node editor</em>, a context menu will be added, allowing us to create and delete nodes at runtime.</p>
    <h3 id="_idParaDest-262" class="heading-3">Adding a simple node</h3>
    <p class="normal">A new node can be started by <a id="_idIndexMarker437"/>calling <code class="inlineCode">BeginNode()</code>, using an <code class="inlineCode">int</code> value as the unique identification for the node:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">const</span> <span class="hljs-type">int</span> nodeId = <span class="hljs-number">1</span>;
ImNodes::<span class="hljs-built_in">BeginNode</span>(nodeId);
ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">"Sample Node"</span>);
ImNodes::<span class="hljs-built_in">EndNode</span>();
</code></pre>
    <p class="normal">Like in ImGui itself, all imnodes UI elements must have a unique ID set to be distinguishable by ImGui. Internally, imnodes uses the <code class="inlineCode">ImGui::PushID()</code> call to set the ID for the group containing the node data. We only need to take care that all elements in the node editor have unique identifications set.</p>
    <p class="normal">Inside the node, we can use all ImGui elements to create control elements. Some ImGui elements may behave unexpectedly. For instance, an <code class="inlineCode">ImGui::Separator()</code> call draws a line up to the right end of the node editor. But the usual elements, like text, buttons, or sliders, are working as expected. Calling <code class="inlineCode">BeginDisable()</code> and <code class="inlineCode">EndDisable()</code> also works normally, allowing us to make parts of the node unavailable.</p>
    <div class="note">
      <p class="normal">Be careful when disabling ImGui elements in a node</p>
      <p class="normal">While it may seem tempting to completely remove unneeded ImGui elements from the node by enclosing them in <code class="inlineCode">if</code> statements, be aware that imnodes calculates the position of input and output pins from the IDs given to the attributes. If you want to remove attributes or ImGui elements, make sure to keep the same IDs for the attributes and elements remaining visible, or else the links will be attached at the wrong places.</p>
    </div>
    <p class="normal"><em class="italic">Figure 9.4</em> shows the result of the previously found lines of code:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_04.png" alt="" width="518" height="246"/></figure>
    <p class="packt_figref">Figure 9.4: The sample node</p>
    <p class="normal">Besides being movable by <a id="_idIndexMarker438"/>holding the left mouse button, our new node is not useful. So, let us add some elements to the node, called “attributes” in imnodes.</p>
    <h3 id="_idParaDest-263" class="heading-3">Creating imnodes attributes and ImGui elements in a node</h3>
    <p class="normal">All attributes for a node <a id="_idIndexMarker439"/>must be defined between <code class="inlineCode">BeginNode()</code> and <code class="inlineCode">EndNode()</code>. Make<a id="_idIndexMarker440"/> sure to skip the <code class="inlineCode">ImGui::Text()</code> line from the section <em class="italic">Adding a simple node</em> as it will destroy the layout of the node.</p>
    <p class="normal">The first imnodes attribute we add is a node title, by using <code class="inlineCode">BeginNodeTitleBar()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">ImNodes::<span class="hljs-built_in">BeginNodeTitleBar</span>();
ImGui::<span class="hljs-built_in">TextUnformatted</span>(<span class="hljs-string">"A cool node title"</span>);
ImNodes::<span class="hljs-built_in">EndNodeTitleBar</span>();
</code></pre>
    <p class="normal">The title is shown in a separate area at the top of the node and shows if it is unselected, hovered over, or selected.</p>
    <p class="normal">Next, we create an input pin by calling <code class="inlineCode">BeginInputAttribute()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inputId = <span class="hljs-number">2</span>;
ImNodes::<span class="hljs-built_in">BeginInputAttribute</span>(inputId);
ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">"in"</span>);
ImNodes::<span class="hljs-built_in">EndInputAttribute</span>();
</code></pre>
    <p class="normal">An input node definition creates a “magnetic” dot on the left side of the node, allowing us later to connect links. A node can have from zero to virtually unlimited input pins, but most probably, only a few pins will be used.</p>
    <p class="normal">After the input pin, we use <code class="inlineCode">BeginStaticAttribute()</code> to create a static attribute:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">const</span> <span class="hljs-type">int</span> staticId = <span class="hljs-number">3</span>;
<span class="hljs-type">static</span> <span class="hljs-type">bool</span> checkboxState = <span class="hljs-literal">false</span>;
ImNodes::<span class="hljs-built_in">BeginStaticAttribute</span>(staticId);
ImGui::<span class="hljs-built_in">Checkbox</span>(<span class="hljs-string">"A fancy checkbox"</span>, &amp;checkboxState);
ImNodes::<span class="hljs-built_in">EndStaticAttribute</span>();
</code></pre>
    <p class="normal">Static attributes have no input or output connectors on the sides of the node. You can use a static attribute just like every other control element in an ImGui window.</p>
    <p class="normal">Finally, we add an output pin with <code class="inlineCode">BeginOutputAttribute()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">const</span> <span class="hljs-type">int</span> outId = <span class="hljs-number">4</span>;
ImNodes::<span class="hljs-built_in">BeginOutputAttribute</span>(outId);
ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">"                 out"</span>);
ImNodes::<span class="hljs-built_in">EndOutputAttribute</span>();
</code></pre>
    <p class="normal">Like input pins, output pins create a connector to dock links. But for output pins, this connector is on the right side of the node.</p>
    <p class="normal">In <em class="italic">Figure 9.5</em>, the resulting node created by the code lines in this section is shown:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_05.png" alt="" width="660" height="328"/></figure>
    <p class="packt_figref">Figure 9.5: The updated example node</p>
    <p class="normal">The <a id="_idIndexMarker441"/>updated node already looks great. We have a title, input and output <a id="_idIndexMarker442"/>pins, and a checkbox controlled by a stateful variable – all in just about twenty lines of code.</p>
    <p class="normal">Connecting nodes with links is also simple, as we will see now.</p>
    <h3 id="_idParaDest-264" class="heading-3">Maintaining links between nodes</h3>
    <p class="normal">Links in imnodes<a id="_idIndexMarker443"/> have three properties: a unique link ID, a start pin ID, and an end pin ID. The unique link ID is needed to identify and draw the link itself, and the pin IDs are taken from the output pin of the parent (or source) node respective to the input pin of the child (or destination) node.</p>
    <p class="normal">By combining these three IDs, links in imnodes are best managed as pairs of pin IDs in a map of link IDs:</p>
    <pre class="programlisting code"><code class="hljs-code">std::map&lt;<span class="hljs-type">int</span>, std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; links;
</code></pre>
    <p class="normal">The inner <code class="inlineCode">std::pair</code> stores the IDs of the start pin (output) and the end pin (input) of a link, in that order. With the outer <code class="inlineCode">std::map</code>, we create a connection between the link ID and the pair of pin IDs.</p>
    <div class="note">
      <p class="normal">Output first, input second</p>
      <p class="normal">It is noteworthy to say that imnodes strictly follows this order. The first reported pin is always the output pin of the parent node, and the second pin is the input pin of the child node. Following this rule makes it easy to use nodes and links to create a finite state machine, maintaining the state of the node tree with a bunch of simple rules.</p>
    </div>
    <p class="normal">Drawing the existing nodes can be done by calling <code class="inlineCode">Link()</code> with exactly the three link properties mentioned earlier in the section:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; link : links) {
    ImNodes::<span class="hljs-built_in">Link</span>(link.first,
      link.second.first, link.second.second);
  }
</code></pre>
    <p class="normal">All links in the map are now drawn as lines with curves at both ends, connecting the output pin of the parent node (first element of the pair) and the input pin of the child node (second element of the pair).</p>
    <p class="normal">New nodes are signaled from imnodes <em class="italic">after</em> the editor has been ended by calling <code class="inlineCode">EndNodeEditor()</code>. Then, two imnodes calls can be used to create or delete links.</p>
    <p class="normal">Whether or not a new link was created in the editor in the current frame can be requested by calling <code class="inlineCode">IsLinkCreated()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">int</span> startId, endId;
  <span class="hljs-keyword">if</span> (ImNodes::<span class="hljs-built_in">IsLinkCreated</span>(&amp;startId, &amp;endId)) {
    linkId = <span class="hljs-built_in">findNextFreeLinkId</span>();
    links[linkId] = (std::<span class="hljs-built_in">make_pair</span>(startId, endId));
  }
</code></pre>
    <p class="normal">If <code class="inlineCode">IsLinkCreated()</code> returns<a id="_idIndexMarker444"/> true, the user made a new link between two nodes, and we can save the new link to the map. How <code class="inlineCode">findNextFreeLinkId()</code> searches for a new link ID depends on the needs of the application. You can check out the example code, a simple implementation that reuses IDs from deleted links.</p>
    <p class="normal">If an existing link was disconnected and then dropped, <code class="inlineCode">IsLinkDestroyed()</code> returns true, giving back the ID of the dropped link as an output parameter:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">int</span> linkId;
  <span class="hljs-keyword">if</span> (ImNodes::<span class="hljs-built_in">IsLinkDestroyed</span>(&amp;linkId)) {
    links.<span class="hljs-built_in">erase</span>(linkId);
}
</code></pre>
    <p class="normal">imnodes has some other functions enabling custom link management, but for our node editor, <code class="inlineCode">IsLinkCreated()</code> and <code class="inlineCode">IsLinkDestroyed()</code> will be sufficient.</p>
    <p class="normal">Duplicating the code for our example node (remember to use unique IDs for every attribute) and adding a link between the output pin ID of the first node and the input ID of the second node will result in something similar to <em class="italic">Figure 9.6</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_06.png" alt="" width="1022" height="576"/></figure>
    <p class="packt_figref">Figure 9.6: Two example nodes connected by a link</p>
    <p class="normal">You will have to move the nodes apart since all new nodes are created in the same spot by default. Next to setting the initial position when creating a node, imnodes allows us to store the positions of all nodes in the current editor session by using <code class="inlineCode">SaveCurrentEditorStateToIniString()</code>. Restoring the positions can be achieved later by calling <code class="inlineCode">LoadCurrentEditorStateFromIniString()</code>.</p>
    <p class="normal">Having the nodes in<a id="_idIndexMarker445"/> the same place when reopening the editor helps to create a great user experience.</p>
    <p class="normal">Now that we have explored how to manage the graphical part of the node editor using imnodes, we need to create a class to store state information and the imnodes draw calls. These new classes are the building blocks for the finite state machine driving the instance behavior.</p>
    <h2 id="_idParaDest-265" class="heading-2">Creating graph node classes</h2>
    <p class="normal">The basic element of node tree classes <a id="_idIndexMarker446"/>is an abstract class called <code class="inlineCode">GraphNodeBase</code>, located in the new folder <code class="inlineCode">graphnodes</code>. All other node classes will inherit from the base class, adding attributes and logic for specific tasks that the node has to take care of.</p>
    <p class="normal">In contrast to a <em class="italic">full-featured</em> behavior tree, our simplified version will store the state of nodes in the nodes itself. Maintaining the node state in a separate part of the code would make the implementation more complex and harder to understand. The only drawback of using an integrated state is to make a copy of the entire node tree for every instance, as the node tree itself is used as the finite state machine. But node objects are small; adding a few nodes per instance creates a negligible overhead in memory space and compute time.</p>
    <p class="normal">Before we dive into more details, here<a id="_idIndexMarker447"/> is a list of all the node types created in the example code for this chapter:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Root Node</strong></li>
    </ul>
    <p class="normal-one">The root node<a id="_idIndexMarker448"/> is the starting point of every node tree, created by default. It is not possible to remove the root node as it’s the starting point of the entire tree. At the start of the execution of the finite state machine, the root node is activated first. Also, when no other nodes are active, the root node is triggered again to start over. Since there is no need to trigger the root node by some other node, the root node has only an output pin but no input pin.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Test Node</strong></li>
    </ul>
    <p class="normal-one">The test node<a id="_idIndexMarker449"/> helps develop and debug node trees. Like the root node, only an output pin is available, plus a button to activate the output pin.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">DebugLog Node</strong></li>
    </ul>
    <p class="normal-one">This is another node to help <a id="_idIndexMarker450"/>build a node tree. Currently, node trees attached to an instance cannot be loaded into the editor for a live-debugging session. A task for implementing the ability to load an existing node tree into the editor window is available in the <em class="italic">Practical sessions</em> section. To watch specific actions, a debug log node can be added, printing a line to the system console when activated.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Wait Node</strong></li>
    </ul>
    <p class="normal-one">The wait node<a id="_idIndexMarker451"/> was already shown as an example in <em class="italic">Figure 9.2</em>. The node will delay the execution between two other nodes by a configurable time.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">RandomWait Node</strong></li>
    </ul>
    <p class="normal-one">This is like the wait node, but<a id="_idIndexMarker452"/> an upper and lower limit can be set to the delay time, enabling a bit more random behavior.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Selector Node</strong></li>
    </ul>
    <p class="normal-one">The selector node<a id="_idIndexMarker453"/> also has a fixed delay, and after the delay time is up, a random output pin is activated.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Sequence Node</strong></li>
    </ul>
    <p class="normal-one">A sequence node<a id="_idIndexMarker454"/> activates the output pins one after the other, starting with pin number one. As an extra feature, the sequence node will wait for the child node on the active output to finish. Waiting for a child is currently only implemented for the two wait node types; more types or a cascade with grandchild nodes can be added. See the section <em class="italic">Practical sessions</em> for ideas.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Action Node</strong></li>
    </ul>
    <p class="normal-one">We added actions in <a href="Chapter_7.xhtml"><em class="italic">Chapter 7</em></a>. An action node<a id="_idIndexMarker455"/> allows us to trigger actions just like we did in <a href="Chapter_7.xhtml"><em class="italic">Chapter 7</em></a> while controlling the instance with a keyboard and mouse, enabling the instances to not just walk <a id="_idIndexMarker456"/>around but jump, roll, punch, or wave, based on the state of the node tree.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Event Node</strong></li>
    </ul>
    <p class="normal-one">An event node<a id="_idIndexMarker457"/> is triggered by an external event sent to the instance, for instance, when a collision happens. The event node also has a cooldown timer to ignore the same event for a small amount of time, avoiding erratic behavior by doing the same action on every update of the tree again if the event keeps being sent to the instance.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Instance Movement Node</strong></li>
    </ul>
    <p class="normal-one">The instance node<a id="_idIndexMarker458"/> allows us to control movement state and movement direction, instance speed, and instance rotation within the node tree. Using an instance node is required to change between the main movement states, like idle, walking, and running. In addition, both speed and rotation can be randomized within the upper <a id="_idIndexMarker459"/>and lower limits to enable a more nondeterministic behavior.</p>
    <p class="normal">In <em class="italic">Figure 9.7</em>, all these nodes are shown:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_07.png" alt="" width="1362" height="908"/></figure>
    <p class="packt_figref">Figure 9.7: An overview of all nodes created for the example code</p>
    <p class="normal">The number next to the <a id="_idIndexMarker460"/>node type is the numerical node ID. In case of errors, or when using a DebugLog node, having the node ID at hand may be beneficial.</p>
    <p class="normal">Now let’s check the most important parts of the <code class="inlineCode">GraphNodeBase</code> class.</p>
    <h3 id="_idParaDest-266" class="heading-3">Exploring the base class for graph nodes</h3>
    <p class="normal">To ensure derived node<a id="_idIndexMarker461"/> classes are implementing a minimum set of functionalities, the <code class="inlineCode">GraphNodeBase</code> class has several pure virtual methods declared in the header file <code class="inlineCode">GraphNodeBase.h</code> in the folder <code class="inlineCode">graphnodes</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">update</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> deltaTime)</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">draw</span><span class="hljs-params">(ModelInstanceCamData modInstCamData)</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">activate</span><span class="hljs-params">()</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">deactivate</span><span class="hljs-params">(</span><span class="hljs-type">bool</span><span class="hljs-params"> informParentNodes = </span><span class="hljs-literal">true</span><span class="hljs-params">)</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">bool</span><span class="hljs-function"> </span><span class="hljs-title">isActive</span><span class="hljs-params">()</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span><span class="hljs-function"> std::shared_ptr&lt;GraphNodeBase&gt; </span><span class="hljs-title">clone</span><span class="hljs-params">()</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span> std::optional&lt;std::map&lt;std::string, std::string&gt;&gt;
  <span class="hljs-built_in">exportData</span>() = <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">importData</span><span class="hljs-params">(</span>
<span class="hljs-params">  std::map&lt;std::string, std::string&gt; data)</span><span class="hljs-function"> </span>= <span class="hljs-number">0</span>;
</code></pre>
    <p class="normal">The first method, <code class="inlineCode">update()</code>, is used to alter the internal state of the node depending on the time difference between two frames. For instance, all nodes with a delay will decrease the internal counter, triggering the output pin once the time reaches 0.</p>
    <p class="normal">Inside the <code class="inlineCode">draw()</code> method, the appearance of the node is set. We created an example node starting with the section <em class="italic">Adding a simple node</em>. The <code class="inlineCode">draw()</code> call contains all commands tailored to the visuals of the specific node type.</p>
    <p class="normal">When the internal timer of the timing nodes reaches 0, or when a node connected to an input pin of the current node has finished its execution, <code class="inlineCode">activate()</code> will be triggered. Here, the main logic of the node’s functionality is set.</p>
    <p class="normal">When a node tree controlling the behavior of an instance should be removed from that instance, we can make sure to stop all nodes by calling <code class="inlineCode">deactivate()</code>. Not stopping the finite state machine for the current instance could lead to interesting side effects and unwanted behavior if a node sets values for properties like speed or movement state. The parameter <code class="inlineCode">informParentNodes</code> is used to distinguish between an ordered shutdown of a node, i.e., notifying a parent node of type Sequence that the child node has finished execution, and a <em class="italic">full stop</em>, when all further actions should be avoided.</p>
    <p class="normal">By using <code class="inlineCode">isActive()</code>, the controlling code of the finite state machine can check if at least one node is still actively doing something, like waiting for a timer to reach 0. As soon as no active node is left, the root node will be triggered.</p>
    <p class="normal">The <code class="inlineCode">clone()</code> method is needed to create a copy of the current instance of a node, containing all settings. Since we are using inheritance, using a copy constructor to achieve the same result would be hard due to missing access to <code class="inlineCode">private</code> members. A virtual cloning method makes our lives much easier, resulting in a 1:1 copy.</p>
    <p class="normal">Finally, <code class="inlineCode">exportData()</code> and <code class="inlineCode">importData()</code> are used to get and set the current state of any node instance with any values <a id="_idIndexMarker462"/>set that are worth saving and restoring. Internally, the values of a node type are stored in a <code class="inlineCode">std::string</code> map, avoiding more than one data type in the map. Also, using simple strings inside the YAML parser removes any conversion when interacting with the raw text data on disk. The graph node types know how to encode and decode the data, moving the node-specific save and load logic away from the YAML parser.</p>
    <p class="normal">In addition to the pure virtual methods, a small number of non-pure virtual functions are declared and defined in the <code class="inlineCode">GraphNodeBase.h</code> header. These methods are only useful for a small subset of node types. So, forcing all node types to implement the functionality makes no sense.</p>
    <p class="normal">The first three methods, <code class="inlineCode">addOutputPin</code>, <code class="inlineCode">delOutputPin</code>, and <code class="inlineCode">getNumOutputPins</code>, are used to handle the dynamic number of output pins on the Sequence and Selector nodes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">addOutputPin</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{};
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">int</span><span class="hljs-function"> </span><span class="hljs-title">delOutputPin</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; };
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">int</span><span class="hljs-function"> </span><span class="hljs-title">getNumOutputPins</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; };
</code></pre>
    <p class="normal">All three method names speak for themselves. Only the return value of <code class="inlineCode">delOutputPin()</code> may need an explanation: when removing an output pin from a node, we must check if any links were connected to that pin. By returning the pin ID of the just-deleted output pin, all connected links can be removed by searching the map of links for the specific output node and deleting all affected links from the link map.</p>
    <p class="normal">The other three virtual methods, <code class="inlineCode">childFinishedExecution</code>, <code class="inlineCode">listensToEvent</code>, and <code class="inlineCode">handleEvent</code>, are even more special:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">childFinishedExecution</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{};
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">bool</span><span class="hljs-function"> </span><span class="hljs-title">listensToEvent</span><span class="hljs-params">(nodeEvent event)</span>
<span class="hljs-function">  </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; };
<span class="hljs-keyword">virtual</span><span class="hljs-function"> </span><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">handleEvent</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{ };
</code></pre>
    <p class="normal">The Sequence node type waits for the child node(s) connected to its output pins to report that they have finished execution. Both the <code class="inlineCode">Wait</code> and <code class="inlineCode">RandomWait</code> nodes will inform their parent node about a status change by calling <code class="inlineCode">childFinishedExecution()</code>.</p>
    <p class="normal">Only the event node implements the last two methods, <code class="inlineCode">listensToEvent()</code> and <code class="inlineCode">handleEvent()</code>. Both method names should be self-explanatory. The split into two separate methods can be useful if some preparations need to be done between checking if a node would handle an event and<a id="_idIndexMarker463"/> the real event execution.</p>
    <p class="normal">As an example for a derived class, we will check some implementation details of the wait node.</p>
    <h3 id="_idParaDest-267" class="heading-3">Creating the wait node</h3>
    <p class="normal">When constructing a new <a id="_idIndexMarker464"/>wait node, some defaults are set:</p>
    <pre class="programlisting code"><code class="hljs-code">WaitNode::<span class="hljs-built_in">WaitNode</span>(<span class="hljs-type">int</span> nodeId, <span class="hljs-type">float</span> waitTime) :
    <span class="hljs-built_in">GraphNodeBase</span>(nodeId) {
  <span class="hljs-type">int</span> id = nodeId * <span class="hljs-number">1000</span>;
  mInId = id;
  mStaticIdStart = id + <span class="hljs-number">100</span>;
  mOutId = id + <span class="hljs-number">200</span>;
  mWaitTime = waitTime;
  mCurrentTime = mWaitTime;
}
</code></pre>
    <p class="normal">We are using a predefined range of attribute IDs here to simplify further coding and help debug issues. By multiplying the node ID by <code class="inlineCode">1000</code>, each node creates space for up to 1000 IDs per node, usable for input and output pins, or static elements like sliders and buttons. The number of nodes per tree is only limited by the storage capacity of an <code class="inlineCode">int</code>, and we also recycle deleted node IDs – that’s more than enough for nodes and pins, even for very large node trees. In addition, by simply doing an integer division of any pin ID by 1000, we get the node ID containing that specific pin. This is the perfect solution to identify the node when sending signals to the pins.</p>
    <p class="normal">Cloning the wait node requires only a single line of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-function">std::shared_ptr&lt;GraphNodeBase&gt; </span><span class="hljs-title">WaitNode::clone</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;WaitNode&gt;(*<span class="hljs-keyword">this</span>);
}
</code></pre>
    <p class="normal">This kind of virtual cloning is widely used and enables us to make an exact copy of that wait node, including all node-specific settings.</p>
    <p class="normal">The <code class="inlineCode">draw()</code> method code can be skipped since we just use a slider as the control element instead of the checkbox. Most of the <code class="inlineCode">draw()</code> code is identical to the code in the sections <em class="italic">Adding a simple node</em> and <em class="italic">Creating imnodes attributes and ImGui elements in a node</em>, so we can skip the details here.</p>
    <p class="normal">A call to <code class="inlineCode">activate()</code> starts the wait timer. The <code class="inlineCode">private</code> Boolean member variable <code class="inlineCode">mActive</code> is set to true, and another <code class="inlineCode">private</code> Boolean called <code class="inlineCode">mFired</code> is set to false:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">WaitNode::activate</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">if</span> (mActive) {
    <span class="hljs-keyword">return</span>;
  }
  mActive = <span class="hljs-literal">true</span>;
  mFired = <span class="hljs-literal">false</span>;
}
</code></pre>
    <p class="normal">We use <code class="inlineCode">mFired</code> only to<a id="_idIndexMarker465"/> change the color of the output pin from white to green, signaling in the editor window that the wait node has notified any node connected to the output pin.</p>
    <p class="normal">Once <code class="inlineCode">mAcive</code> is set to true, the <code class="inlineCode">update()</code> method starts decrementing the wait time in <code class="inlineCode">mCurrentTime</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">WaitNode::update</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> deltaTime)</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">if</span> (!mActive) {
    <span class="hljs-keyword">return</span>;
  }
  mCurrentTime -= deltaTime;
</code></pre>
    <p class="normal">After the wait time is below 0, trigger signals for both the input and the output pin are sent out, the wait time is reset, the node is deactivated, and the color of the output pin changes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (mCurrentTime &lt;= <span class="hljs-number">0.0f</span>)
    <span class="hljs-built_in">fireNodeOutputTriggerCallback</span>(mOutId);
    <span class="hljs-built_in">fireNodeOutputTriggerCallback</span>(mInId);
    mCurrentTime = mWaitTime;
    mActive = <span class="hljs-literal">false</span>;
    mFired = <span class="hljs-literal">true</span>;
  }
}
</code></pre>
    <p class="normal">The reason for triggering the input pin was discussed in the section <em class="italic">Creating graph node classes</em>: if the wait node is a child of a sequence node, the parent sequence node needs to know that the wait node is no longer active.</p>
    <p class="normal">Finally, exporting and importing data is done by the two methods, <code class="inlineCode">exportData()</code> and <code class="inlineCode">importData()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">std::optional&lt;std::map&lt;std::string, std::string&gt;&gt;
    WaitNode::<span class="hljs-built_in">exportData</span>() {
  std::map&lt;std::string, std::string&gt; data{};
  data[<span class="hljs-string">"wait-time"</span>] = std::<span class="hljs-built_in">to_string</span>(mWaitTime);
  <span class="hljs-keyword">return</span> data;
}
<span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">WaitNode::importData</span><span class="hljs-params">(</span>
<span class="hljs-params">    std::map&lt;std::string, std::string&gt; data)</span><span class="hljs-function"> </span>{
  mWaitTime = std::<span class="hljs-built_in">stof</span>(data[<span class="hljs-string">"wait-time"</span>]);
  mCurrentTime = mWaitTime;
}
</code></pre>
    <p class="normal">Both methods are<a id="_idIndexMarker466"/> straightforward. We just store the <code class="inlineCode">float</code> in a <code class="inlineCode">std::string</code> on exporting and read back the <code class="inlineCode">float</code> value on importing.</p>
    <p class="normal">All other specialized nodes are created in a similar way, implementing the required methods and enhancing the other virtual methods if needed.</p>
    <p class="normal">Another well-known coding style from the application is using callbacks to call methods in other classes. <code class="inlineCode">GraphNodeBase</code> uses two callbacks to handle events.</p>
    <h3 id="_idParaDest-268" class="heading-3">Using callbacks to propagate changes</h3>
    <p class="normal">By activating the first callback, a node<a id="_idIndexMarker467"/> informs the finite state machine that it has finished its execution, and the control should be given to the nodes connected to the output pin(s):</p>
    <pre class="programlisting code"><code class="hljs-code">    fireNodeOutputCallback mNodeCallbackFunction;
</code></pre>
    <p class="normal">The method that handles this callback is the main part of the state management when advancing the status of the nodes.</p>
    <p class="normal">Real behavior changes happen in the method executed by the second callback:</p>
    <pre class="programlisting code"><code class="hljs-code">    nodeActionCallback mNodeActionCallbackFunction;
</code></pre>
    <p class="normal">This callback is used by the instance and action node types, informing, after quite a long callback cascade, the renderer class to manipulate a single property of the instance owning the node tree that started the callback.</p>
    <p class="normal">Here is where all the magic happens, letting the instance mode change the movement state to walk or run, or start <a id="_idIndexMarker468"/>an action like jumping or waving the hand.</p>
    <p class="normal">We will now take a closer look at more code that will make use of both callbacks.</p>
    <h3 id="_idParaDest-269" class="heading-3">Creating a behavior struct and a storage class for the instances</h3>
    <p class="normal">To store<a id="_idIndexMarker469"/> nodes, links, and the action callback, the new <code class="inlineCode">struct</code> <code class="inlineCode">BehaviorData</code> will <a id="_idIndexMarker470"/>be used, residing in the file <code class="inlineCode">BehaviorData.h</code> in the <code class="inlineCode">model</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">BehaviorData</span> {
  std::vector&lt;std::shared_ptr&lt;GraphNodeBase&gt;&gt;
    bdGraphNodes{};
  std::unordered_map&lt;<span class="hljs-type">int</span>, std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;
    bdGraphLinks{};
  std::string bdEditorSettings;
  nodeActionCallback bdNodeActionCallbackFunction{};
};
</code></pre>
    <p class="normal">Nodes and links are stored in basic STL containers, and we also store the editor setting string in the <code class="inlineCode">struct</code>, enabling us to save and restore the node positions in the node editor window. The <code class="inlineCode">nodeActionCallback</code> callback is only needed in an intermediate fashion to create a link chain between the callbacks in the nodes and the class storing the behavior data <code class="inlineCode">struct</code> itself.</p>
    <p class="normal">The new class <code class="inlineCode">SingleInstanceBehavior</code> is used to collect all data and methods for the behavior control of a single instance. Here, we create the chain for the <code class="inlineCode">nodeActionCallback</code> callback by setting the callback function of the <code class="inlineCode">BehaviorData</code> <code class="inlineCode">struct</code> to the local method <code class="inlineCode">nodeActionCallback()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">mBehaviorData-&gt;bdNodeActionCallbackFunction = [<span class="hljs-keyword">this</span>]
    (graphNodeType nodeType, instanceUpdateType updateType,
    nodeCallbackVariant data, <span class="hljs-type">bool</span> extraSetting) {
  <span class="hljs-built_in">nodeActionCallback</span>(nodeType, updateType, data,
    extraSetting);
  };
</code></pre>
    <p class="normal">Whenever nodes of types are created that need to change instance data, the <code class="inlineCode">nodeActionCallback</code> of the <code class="inlineCode">BehaviorData</code> <code class="inlineCode">struct</code> is set in the new node:</p>
    <pre class="programlisting code"><code class="hljs-code">newNode-&gt;<span class="hljs-built_in">setNodeActionCallback</span>(
  newBehavior.bdNodeActionCallbackFunction);
</code></pre>
    <p class="normal">Finally, in the <code class="inlineCode">nodeActionCallback()</code> method, the incoming data is transformed to include the instance ID, and another callback function is executed:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-built_in">mInstanceNodeActionCallback</span>(mInstanceId, nodeType,
    updateType, data, extraSetting);
</code></pre>
    <p class="normal">The callback chain decouples the internal instance and animation state from the state machine controlling it. By decoupling the states, it is possible for a node of the instance movement or action type to request a property change for the instance where this node resides in one of the behaviors without any knowledge of which instance the node is.</p>
    <p class="normal">The remaining parts of the node actions will be implemented in the section <em class="italic">Extending the code to support behavior changes</em>, completing the chain from a single node in a node tree all the way up to the renderer.</p>
    <p class="normal">For the second callback function, a lambda in the <code class="inlineCode">SingleInstanceBehavior</code> class is used to connect the state update request to a local method:</p>
    <pre class="programlisting code"><code class="hljs-code"> mFireNodeOutputCallback = [<span class="hljs-keyword">this</span>](<span class="hljs-type">int</span> pinId)
  { <span class="hljs-built_in">updateNodeStatus</span>(pinId); };
</code></pre>
    <p class="normal">Inside <code class="inlineCode">updateNodeStatus()</code>, some simple logic changes the active state of the nodes by using the <code class="inlineCode">pinId</code> given as a parameter. Following the rule “output first, input second” for the link IDs of imnodes and the integer division of the pin ID, we could detect if the signal came from an input or output pin and even find the node that called <code class="inlineCode">updateNodeStatus()</code>.</p>
    <p class="normal">If <code class="inlineCode">updateNodeStatus()</code> receives a call with an output pin ID as a parameter, all connected child nodes will be activated. If no connected child node is found on the output pin, we inform the parent node about a finished execution. This special handling is only relevant for a sequence node right now, enabling us to skip output pins without a connection.</p>
    <p class="normal">For an input pin as<a id="_idIndexMarker471"/> a parameter, the corresponding node<a id="_idIndexMarker472"/> connected to that input pin will be informed. This is only needed at the end of the execution of a child node of a sequence node right now, but the functionality can be extended for new node types.</p>
    <p class="normal">Without logging calls and comments, the entire <code class="inlineCode">updateNodeStatus()</code> method is just about forty lines short, but it still does the main job of the entire behavior tree implementation.</p>
    <p class="normal">To simplify the creation of new nodes, we will use the factory pattern. A node factory encloses all the logic needed to create a new node of a specified type in one place. Plus, we will enhance the editor with a context menu and the ability to switch between different node trees.</p>
    <h3 id="_idParaDest-270" class="heading-3">Adding a node factory</h3>
    <p class="normal">The factory pattern is a nice solution <a id="_idIndexMarker473"/>to create objects of classes derived from a single base class, keeping all parts of the creation logic in a single place.</p>
    <p class="normal">The factory class <code class="inlineCode">GraphNodeFactory</code> in the <code class="inlineCode">graphnodes</code> folder is small and simple, similar to other factory classes. At the creation time of a factory object, the appropriate <code class="inlineCode">fireNodeOutputCallback</code> is injected into the constructor, helping us to add the right callback destination to all new nodes. The constructor also adds a mapping between all node types and the names in the title area of the nodes. This name mapping frees us from adding the node name at node creation time; we only need the node type and a unique node ID to build a new node.</p>
    <p class="normal">The <code class="inlineCode">makeNode()</code> method does all the work by creating a new derived class according to the given node type, adding the callback, the mapped node name, and the node type of the chosen derived class. Like in all factories, the returned smart pointer is of the base class type, allowing us to store all new nodes in STL containers of the base class.</p>
    <h3 id="_idParaDest-271" class="heading-3">Extending the node editor</h3>
    <p class="normal">For better node handling, we create a<a id="_idIndexMarker474"/> context menu in the editor. The context menu can be opened by pressing the right mouse button in the node editor window:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">const</span> <span class="hljs-type">bool</span> openPopup = ImGui::<span class="hljs-built_in">IsWindowFocused</span>(
    ImGuiFocusedFlags_RootAndChildWindows) &amp;&amp;
    ImNodes::<span class="hljs-built_in">IsEditorHovered</span>() &amp;&amp;
    ImGui::<span class="hljs-built_in">IsMouseClicked</span>(ImGuiMouseButton_Right);
</code></pre>
    <p class="normal">In fact, we create two different context menus. Which menu is shown depends on if we are hovering over a node or not:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (openPopup) {
    <span class="hljs-keyword">if</span> (ImNodes::<span class="hljs-built_in">IsNodeHovered</span>(&amp;mHoveredNodeId)) {
      ImGui::<span class="hljs-built_in">OpenPopup</span>(<span class="hljs-string">"change node"</span>);
    } <span class="hljs-keyword">else</span> {
      ImGui::<span class="hljs-built_in">OpenPopup</span>(<span class="hljs-string">"add node"</span>)
    }
  }
</code></pre>
    <p class="normal">If no existing node is hovered over when pressing the right mouse button, an ImGui pop-up window to add a new node will be created, listing all available node types (all but the root node, which only exists once). If a node is hovered over, a different ImGui pop-up window is shown, containing actions that could be executed on the hovered-over node.</p>
    <p class="normal"><em class="italic">Figure 9.8</em> shows both context menus next to each other:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_08.png" alt="" width="736" height="518"/></figure>
    <p class="packt_figref">Figure 9.8: The two context menus of the editor</p>
    <p class="normal">Which options in the <strong class="screenText">Change Node</strong> menu are shown depends on the node type. For sequence and selector nodes, the number of output pins can be changed dynamically, so these two options appear, while for all other nodes, only <strong class="screenText">Deactivate</strong> and <strong class="screenText">Delete</strong> are shown. The availability to deactivate and delete a node is based on the active state of the node. For instance, you cannot delete an active wait node until the wait time has expired.</p>
    <p class="normal">To edit an existing node <a id="_idIndexMarker475"/>tree into the existing editor window, a new method called <code class="inlineCode">loadData()</code> is added:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">loadData</span><span class="hljs-params">(std::shared_ptr&lt;BehaviorData&gt; data)</span>;
</code></pre>
    <p class="normal">Inside <code class="inlineCode">loadData()</code>, both a new <code class="inlineCode">SingleInstanceBehavior</code> and a new <code class="inlineCode">GraphNodeFactory</code> object are created to allow editing the node tree the same way as a fresh node tree.</p>
    <p class="normal">The editor also has an <code class="inlineCode">update()</code> method to behave like a running node tree, updating the properties of all nodes depending on their state:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">updateGraphNodes</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> deltaTime)</span>;
</code></pre>
    <p class="normal">Finally, we add a flag called <code class="inlineCode">mShowEditor</code> to control the visibility of the editor. When a new node tree is created, or an existing tree is edited, the window appears on screen. By clicking on the close button of the editor, or when the currently edited node tree is deleted, we hide the editor window.</p>
    <p class="normal">The last step to complete the implementation of the imnodes-based visual node editor is adding all required data to the <code class="inlineCode">YamlParser</code> class. We do not want to start over with an empty editor every time the application is started.</p>
    <h2 id="_idParaDest-272" class="heading-2">Saving and loading a node tree</h2>
    <p class="normal">Creating the required templates and<a id="_idIndexMarker476"/> overloads for the new behavior data is not much different <a id="_idIndexMarker477"/>from what we did in the previous chapters.</p>
    <p class="normal">To add behavior data to the YAML file, an overload of the output stream operator in the file <code class="inlineCode">YamlParser.cpp</code> is needed. The file can be found in the <code class="inlineCode">tools</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">YAML::Emitter&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(YAML::Emitter&amp; out,
 <span class="hljs-type">const</span> BehaviorData&amp; behavior) {
</code></pre>
    <p class="normal">Most of the code can be copied from the previously defined overloads. Having a map of strings created by <code class="inlineCode">exportData()</code> makes it easy to save the state of the nodes:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">exportData</span>().<span class="hljs-built_in">has_value</span>()) {
        std::map&lt;std::string, std::string&gt; exportData =
          node-&gt;<span class="hljs-built_in">exportData</span>().<span class="hljs-built_in">value</span>();
        ...
      }
</code></pre>
    <p class="normal">By using <code class="inlineCode">std::optional</code> in the return value for <code class="inlineCode">exportData()</code>, we can easily skip the entire section in the YAML file if the node has no state to save. Without the <code class="inlineCode">optional</code> keyword, we would need an additional check to determine if the node state needs to be saved or not.</p>
    <p class="normal">For the loading part of the new behavior data, we must add a new <code class="inlineCode">convert</code> template in the file <code class="inlineCode">YamlParserTypes.h</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">template</span>&lt;&gt;
  <span class="hljs-keyword">struct</span> <span class="hljs-title">convert</span>&lt;ExtendedBehaviorData&gt; {
    <span class="hljs-type">static</span><span class="hljs-function"> Node </span><span class="hljs-title">encode</span><span class="hljs-params">(</span><span class="hljs-type">const</span><span class="hljs-params"> ExtendedBehaviorData&amp; rhs)</span><span class="hljs-function"> </span>{
      ...
    }
    <span class="hljs-type">static</span><span class="hljs-function"> </span><span class="hljs-type">bool</span><span class="hljs-function"> </span><span class="hljs-title">decode</span><span class="hljs-params">(</span><span class="hljs-type">const</span><span class="hljs-params"> Node&amp; node,</span>
<span class="hljs-params">       ExtendedBehaviorData&amp; rhs)</span><span class="hljs-function"> </span>{
      ... 
    }
  }
</code></pre>
    <p class="normal">We are using the extended version of the <code class="inlineCode">BehaviorData</code> <code class="inlineCode">struct</code> since we only store the type of a node, and the YAML parser is the wrong place to create new nodes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">PerNodeImportData</span> {
  <span class="hljs-type">int</span> nodeId;
  graphNodeType nodeType;
  std::map&lt;std::string, std::string&gt; nodeProperties{};
};
<span class="hljs-keyword">struct</span> <span class="hljs-title">ExtendedBehaviorData</span> : BehaviorData {
  std::vector&lt;PerNodeImportData&gt; nodeImportData;
};
</code></pre>
    <p class="normal">Node recreation will happen in the renderer class when loading a saved file, like the creation of models, instances, and cameras.</p>
    <p class="normal">Most of the <code class="inlineCode">convert</code> code can be taken from previously implemented templates. But there is one caveat to the <code class="inlineCode">decode()</code> method. Instead of the data type of the node data, a <code class="inlineCode">std::map</code> of strings, the <code class="inlineCode">yaml-cpp</code> library requires us to use a vector of maps, containing a single entry for every line in<a id="_idIndexMarker478"/> the node data. The following code shows how the parsing is <a id="_idIndexMarker479"/>done:</p>
    <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::map&lt;std::string, std::string&gt;&gt; entry =
  nodeDataNode.as&lt;std::vector&lt;std::map&lt;std::string,
    std::string&gt;&gt;&gt;();
</code></pre>
    <p class="normal">All vector entries will be added to the <code class="inlineCode">nodeProperties</code> variable of the intermediate <code class="inlineCode">PerNodeImportData</code> <code class="inlineCode">struct</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (entry.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; mapEntry : entry) {
      nodeData.nodeProperties.<span class="hljs-built_in">insert</span>(mapEntry.<span class="hljs-built_in">begin</span>(),
        mapEntry.<span class="hljs-built_in">end</span>());
    }
  }
</code></pre>
    <p class="normal">In the renderer, we restore the behavior node tree by creating a new <code class="inlineCode">SingleInstanceBehavior</code> instance, a new <code class="inlineCode">BehaviorData</code> <code class="inlineCode">struct</code>, and new nodes of the saved type and ID, as well as loading back the saved properties. After the links are recreated and links and editor settings are imported to the new <code class="inlineCode">BehaviorData</code>, the node tree is in the same state as when it was saved.</p>
    <div class="note">
      <p class="normal">Restore order: Behavior before instances</p>
      <p class="normal">We must restore the behavior node tree data before restoring the instances, since the behavior data will be copied to an instance if we had set a behavior before saving the configuration data.</p>
    </div>
    <p class="normal">Once the node editor itself is ready, we need to connect the node trees and instances. So, let’s add the missing pieces to have the instances come alive.</p>
    <h1 id="_idParaDest-273" class="heading-1">Extending the code to support behavior changes</h1>
    <p class="normal">A few steps are left to fully support computer-controlled behavior in the instances. First, we need a copy of a node tree in every instance.</p>
    <h2 id="_idParaDest-274" class="heading-2">Creating a node tree copy for every instance</h2>
    <p class="normal">We cannot just copy the nodes<a id="_idIndexMarker480"/> since the original and copy would access the same node behind the shared pointer. Reusing the same nodes for multiple instances would lead to chaos, since collision events from all instances would be triggered, resulting in <a id="_idIndexMarker481"/>the same steps executed for all instances sharing the nodes.</p>
    <p class="normal">To create a copy of the node tree for one of the instances, a custom copy constructor for the <code class="inlineCode">SingleInstanceBehavior</code> class has been created. The copy constructor sets the required callbacks, copies the links, and loops through the vector of existing nodes to create a clone of every node. For nodes that change instance behavior, the additional node action callback will be set.</p>
    <p class="normal">Next, the callback chain to the renderer must be completed. Right now, only the <code class="inlineCode">SingleInstanceBehavior</code> class objects are informed that a node wants to send a property change request to an instance.</p>
    <h2 id="_idParaDest-275" class="heading-2">Connecting SingleInstanceBehavior and the renderer</h2>
    <p class="normal">Managing the copies of the instance <a id="_idIndexMarker482"/>behaviors will be done by the new <code class="inlineCode">BehaviorManager</code> class, located in the <code class="inlineCode">model</code> folder. The <code class="inlineCode">BehaviorManager</code> class<a id="_idIndexMarker483"/> maintains a mapping between the instance IDs and the copy of the node tree the specific instance uses. Also, we have a new callback to keep the renderer in the loop to update instance properties of a node of the node tree:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::map&lt;<span class="hljs-type">int</span>, SingleInstanceBehavior&gt;
    mInstanceToBehaviorMap{};
  instanceNodeActionCallback mInstanceNodeActionCallback;
</code></pre>
    <p class="normal">To update the state of all node trees for the instances, an <code class="inlineCode">update()</code> method exists in the <code class="inlineCode">BehaviorManager</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">BehaviorManager::update</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> deltaTime)</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; instance : mInstanceToBehaviorMap) {
    instance.second.<span class="hljs-built_in">update</span>(deltaTime);
  }
}
</code></pre>
    <p class="normal">We just loop over all instances and call the <code class="inlineCode">update()</code> method of the <code class="inlineCode">SingleInstanceBehavior</code> object, which updates all nodes of the node tree.</p>
    <p class="normal">In the renderer, a <code class="inlineCode">private</code> member named <code class="inlineCode">mBehaviorManager</code> is added and initialized during the <code class="inlineCode">init()</code> method of the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  mBehaviorManager = std::<span class="hljs-built_in">make_shared</span>&lt;BehaviorManager&gt;();
  mInstanceNodeActionCallback = [<span class="hljs-keyword">this</span>](<span class="hljs-type">int</span> instanceId,
      graphNodeType nodeType, instanceUpdateType updateType,
      nodeCallbackVariant data, <span class="hljs-type">bool</span> extraSetting) {
   <span class="hljs-built_in">updateInstanceSettings</span>(instanceId, nodeType, updateType,
     data, extraSetting);
  };
  mBehaviorManager-&gt;<span class="hljs-built_in">setNodeActionCallback</span>(
    mInstanceNodeActionCallback);
</code></pre>
    <p class="normal">A model instance can be added by handing over the instance ID and the node tree to the <code class="inlineCode">addInstance()</code> method of the <code class="inlineCode">BehaviorManager</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">addInstance</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> instanceId,</span>
<span class="hljs-params">    std::shared_ptr&lt;SingleInstanceBehavior&gt; behavior)</span>;
</code></pre>
    <p class="normal">In the <code class="inlineCode">addInstance()</code> method, we copy all nodes in the tree, set the callback to the renderer, and add the instance ID to the <code class="inlineCode">SingleInstanceBehavior</code> object.</p>
    <p class="normal">Now, any instance or action node inside the node tree of that instance can call the function bound to its <code class="inlineCode">nodeActionCallback</code> member. The request goes up the callback chain and ends in the <code class="inlineCode">updateInstanceSettings()</code> method of the renderer, containing all information for the renderer to change the instance property.</p>
    <p class="normal">Finally, we must <a id="_idIndexMarker484"/>define all events we want to send to instances, plus <a id="_idIndexMarker485"/>where to place the code firing these events.</p>
    <h2 id="_idParaDest-276" class="heading-2">Adding events</h2>
    <p class="normal">To support<a id="_idIndexMarker486"/> events, a new <code class="inlineCode">enum</code> <code class="inlineCode">class</code> called <code class="inlineCode">nodeEvent</code> is created in the file <code class="inlineCode">Enums.h</code> located in the <code class="inlineCode">opengl</code> folder (or the <code class="inlineCode">vulkan</code> folder for Vulkan):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum class</span> <span class="hljs-title">nodeEvent</span> : <span class="hljs-type">uint8_t</span> {
  none = <span class="hljs-number">0</span>,
  instanceToInstanceCollision,
  instanceToEdgeCollision,
  NUM
};
</code></pre>
    <p class="normal">To start, we define two values called <code class="inlineCode">instanceToInstanceCollision</code> and <code class="inlineCode">instanceToEdgeCollision</code>, used to inform an instance that a collision with another instance or a collision to the world boundaries has occurred. The first value, <code class="inlineCode">none</code>, is used to ignore events in an event node, and the <code class="inlineCode">NUM</code> value is needed to loop over all values in a <code class="inlineCode">for</code> loop.</p>
    <p class="normal">In the <code class="inlineCode">ModelInstanceCamData</code> <code class="inlineCode">struct</code>, a mapping called <code class="inlineCode">micNodeUpdateMap</code> is added to translate a <code class="inlineCode">nodeEvent</code> value to a readable string for the events:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::unordered_map&lt;nodeEvent, std::string&gt;
    micNodeUpdateMap{};
</code></pre>
    <p class="normal">The renderer not only adds the strings during the <code class="inlineCode">init()</code> method but also, all calls firing an event are sent from the renderer to the node trees:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstCamData.<span class="hljs-built_in">micNodeEventCallbackFunction</span>(
    instSettings.isInstanceIndexPosition,
    nodeEvent::instanceToEdgeCollision);
</code></pre>
    <p class="normal">This new <code class="inlineCode">micNodeEventCallbackFunction</code> callback is bound to the <code class="inlineCode">addBehaviorEvent()</code> method of the renderer, and after chaining the request to existing objects, the call ends in the <code class="inlineCode">SingleInstanceBehavior</code> class. There, all requested events are added to a vector:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::vector&lt;nodeEvent&gt; mPendingNodeEvents;
</code></pre>
    <p class="normal">Events are <a id="_idIndexMarker487"/>handled in the <code class="inlineCode">update()</code> call of the <code class="inlineCode">SingleInstanceBehavior</code> class, calling the <code class="inlineCode">handleEvent()</code> method of the node. The <code class="inlineCode">handleEvent()</code> method was introduced in the section <em class="italic">Exploring the base class for graph nodes</em>. It simply activates all event nodes in the graph of the specified instance that are listening to this event type.</p>
    <p class="normal">An example node tree containing events is shown here:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_09.png" alt="" width="1651" height="1981"/></figure>
    <p class="packt_figref">Figure 9.9: An overview of the node tree for the woman’s model</p>
    <p class="normal">We have split this image of <a id="_idIndexMarker488"/>the node tree into two parts, in <em class="italic">Figures 9.10 and 9.11</em>, for better understanding.</p>
    <p class="normal"><em class="italic">Figure 9.10</em> shows the default path in the node tree, beginning with the root node.</p>
    <figure class="mediaobject"><img src="../Images/figure_09_10.png" alt="" width="1652" height="873"/></figure>
    <p class="packt_figref">Figure 9.10: Default path in the node tree for the woman’s model</p>
    <p class="normal"><em class="italic">Figure 9.11</em> shows the<a id="_idIndexMarker489"/> event nodes plus the reaction to events.</p>
    <figure class="mediaobject"><img src="../Images/figure_09_11.png" alt="" width="1536" height="1053"/></figure>
    <p class="packt_figref">Figure 9.11: Events in the node tree for the woman’s model</p>
    <p class="normal">In <em class="italic">Figure 9.12</em>, the resulting behavior of the tree in <em class="italic">Figure 9.9</em> for the woman’s model and a similar tree for the man’s model is shown:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_12.png" alt="" width="1280" height="912"/></figure>
    <p class="packt_figref">Figure 9.12: Instances living their virtual life</p>
    <p class="normal">By default, the <a id="_idIndexMarker490"/>models are walking around, reacting to collisions with other instances by rotating a bit. After a collision with the world boundaries, the instances turn around. After a random time, the instances stop moving, and a random animation clip is played. At this point, the normal execution ends, and the root node is triggered again.</p>
    <p class="normal">Although the node editor looks really cool, and we can add nodes of different types, create links, and save and load the state, some limits of the current implementation should be noted.</p>
    <h2 id="_idParaDest-277" class="heading-2">Limitations of the current implementation</h2>
    <p class="normal">Our basic implementation lacks some<a id="_idIndexMarker491"/> features of other behavior trees.</p>
    <p class="normal">First, states are stored directly in the nodes. For the use case of the application we are creating, storing state data in the nodes is sufficient. But for larger trees, separate state storage becomes handy, mostly because we no longer need to copy the node data to the instances.</p>
    <p class="normal">Also, changes to the node tree in the editor session are not automatically copied to the instances. You need to select an instance or model and apply the current state after every change.</p>
    <p class="normal">Since only the original node tree data of the editor session is saved to the YAML file and not the tree data of the individual instances, restarting the application or reloading the configuration applies the editor state to all instances that use the specific node tree.</p>
    <p class="normal">Finally, the nodes cannot access data from their instance or other data of the virtual world. Reacting to properties like position or rotation, or seeing if you are the primary or secondary candidate of a collision to adjust the rotation angle, is not possible.</p>
    <p class="normal">Many of these limits <a id="_idIndexMarker492"/>can be removed with some effort and additional coding. See the <em class="italic">Practical sessions</em> section for ideas.</p>
    <p class="normal">In the last section of this chapter, we will use the code we have added up until now to create a new feature: interaction between instances.</p>
    <h1 id="_idParaDest-278" class="heading-1">Adding interaction between instances</h1>
    <p class="normal">We already have an action called <strong class="screenText">Interaction</strong>, starting the interaction animation clip for the man’s model (and doing nothing visible <a id="_idIndexMarker493"/>for the woman’s model, as the model does not have an animation clip to show some kind of interaction).</p>
    <p class="normal">This <em class="italic">interaction</em> action will be extended to send an event to a nearby instance, stating that we want to interact with the instance. A possible reaction to the interaction request could be the replay of the waving animation clip for the man’s model on the nearby instance, visually confirming that the event has been processed.</p>
    <h2 id="_idParaDest-279" class="heading-2">Creating interaction control properties</h2>
    <p class="normal">The renderer needs <a id="_idIndexMarker494"/>some variables and a bit of code to support interaction. We add these new variables in the <code class="inlineCode">OGLRenderData</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">OGLRenderData.h</code> in the <code class="inlineCode">opengl</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">bool</span> rdInteraction = <span class="hljs-literal">false</span>;
  <span class="hljs-type">float</span> rdInteractionMaxRange = <span class="hljs-number">10.0f</span>;
  <span class="hljs-type">float</span> rdInteractionMinRange = <span class="hljs-number">1.5f</span>;
  <span class="hljs-type">float</span> rdInteractionFOV = <span class="hljs-number">45.0f</span>;
  std::set&lt;<span class="hljs-type">int</span>&gt; rdInteractionCandidates{};
  <span class="hljs-type">int</span> rdInteractWithInstanceId = <span class="hljs-number">0</span>;
</code></pre>
    <p class="normal">As always, for Vulkan, the variables have to be added to the <code class="inlineCode">VkRenderData</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">VkRenderData.h</code> file.</p>
    <p class="normal">With these new variables, we can switch interaction on and off, as well as set a minimum and maximum scan range for other instances and a field-of-view angle that the peer instances need to be in. The field of view allows us to select only instances we are looking at, and instances that are looking toward us.</p>
    <p class="normal">In the <code class="inlineCode">std::set</code> of <code class="inlineCode">int</code> values, we store all instances in the configured range and with the correct view angle. Finally, we store the instance we have chosen to interact with.</p>
    <p class="normal">The interaction candidate selection is handled in <code class="inlineCode">findInteractionInstances()</code> in the renderer. Like collision detection, we drill down from all instances to a single instance by narrowing down the selection properties.</p>
    <p class="normal">A simple algorithm is used to find the instance suitable for interaction:</p>
    <ol>
      <li class="numberedList" value="1">A <code class="inlineCode">BoundingBox2D</code> object with the max size is used, and the <code class="inlineCode">query()</code> method of the quadtree is called. Now we have all instances in that area.</li>
      <li class="numberedList">All instances within the minimum range are sorted out, including ourselves.</li>
      <li class="numberedList">By using the dot product between our own rotation angle and the distance vector between us and the remaining instances from step 2, all instances with the incorrect facing are removed.</li>
      <li class="numberedList">The distances between us and all instances left in step 3 are sorted in ascending order, and<a id="_idIndexMarker495"/> the nearest instance is set to be the interaction instance.</li>
    </ol>
    <p class="normal">If any step returns no valid candidates, the interaction request will be ignored.</p>
    <h2 id="_idParaDest-280" class="heading-2">Extending the handling code</h2>
    <p class="normal">Thanks to all our preparations, adding <a id="_idIndexMarker496"/>a new event is now extremely simple. First, we extend the <code class="inlineCode">nodeEvent</code> <code class="inlineCode">enum</code> by the new interaction value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum class</span> <span class="hljs-title">nodeEvent</span> : <span class="hljs-type">uint8_t</span> {
  ...
<span class="code-highlight"><strong class="hljs-slc">  interaction,</strong></span>
  NUM
};
</code></pre>
    <p class="normal">Then, we send the interaction event to the central behavior class when the interaction key is pressed, and our model plays the interaction animation clip:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(mRenderData.rdWindow, GLFW_KEY_U) ==
      GLFW_PRESS) {
    <span class="hljs-keyword">if</span> (mRenderData.rdInteractWithInstanceId &gt; <span class="hljs-number">0</span>) {
      mBehaviorManager-&gt;<span class="hljs-built_in">addEvent</span>(
        mRenderData.rdInteractWithInstanceId,
        nodeEvent::interaction);
    }
  }
</code></pre>
    <p class="normal">Finally, we create a new event node in the node tree for the man’s model, setting the wave action. The new wave action is surrounded by two other actions setting the idle state for the instance to have a smooth animation blending, and two wait nodes allowing us to finish the animations (we have no feedback yet from the instance to the node tree).</p>
    <p class="normal">The resulting part of the node tree can be seen in <em class="italic">Figure 9.13</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_13.png" alt="" width="1650" height="954"/></figure>
    <p class="packt_figref">Figure 9.13: Reacting to an interaction event by playing the waving animation</p>
    <p class="normal">That’s all! Switching to view <a id="_idIndexMarker497"/>mode and pressing the <em class="italic">U</em> key near another man’s instance will instruct that instance to stop and wave its hand back to us. After the wave animation, the portion of the node tree will end, resuming the normal behavior.</p>
    <h2 id="_idParaDest-281" class="heading-2">Drawing debug information</h2>
    <p class="normal">As with all previous additions, getting a <a id="_idIndexMarker498"/>new feature to work without proper debug information could be exhausting. For the interaction, we can utilize the AABB drawing code to draw a bounding box around the instance candidates, and we can use the line mesh to draw a square on the ground, showing the dimensions of the minimum and maximum search area.</p>
    <p class="normal"><em class="italic">Figure 9.14</em> shows an example of the debug lines, captured with a first-person camera:</p>
    <figure class="mediaobject"><img src="../Images/figure_09_14.png" alt="" width="1280" height="751"/></figure>
    <p class="packt_figref">Figure 9.14: Interaction between the user and another instance</p>
    <p class="normal">With behavior and interaction in place, the virtual world looks and feels more alive than ever. The instances are walking around alone, reacting to collisions, and doing various actions at random times. And <a id="_idIndexMarker499"/>we can even greet some of the instances – and they greet us back. It is a lot of fun to just fly around in the virtual world, watching the instances.</p>
    <h1 id="_idParaDest-282" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we created a simple form of NPCs in our virtual world. We started by exploring the basic nature of behavior trees and state machines, and to have a tool for creating the state machine controlling the behavior available, we added an ImGui-based visual node editor. Then, we added classes for different node types and integrated these new classes into the existing code, including a node factory and node editor extensions. Finally, we added interactions with other instances in the virtual world.</p>
    <p class="normal">In the next chapter, we will go back to the animation side of things: we will add additive blending in the form of morph animations to create facial animations. First, we will discuss what morph animations are, and which constraints we must take care of. Then, we will import existing morph animations in the glTF models and offload the animation work to the GPU, similar to the other animations. As the last step, we will combine facial animations and interactions, creating instances that can show if they agree or disagree with us.</p>
    <h1 id="_idParaDest-283" class="heading-1">Practical sessions</h1>
    <p class="normal">Here are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Extend the undo/redo functionality to the node trees.</li>
      <li class="bulletList">In addition to the existing undo/redo operations, add code to support reverting and re-reverting any operations in node trees. It would be helpful to be able to undo accidental changes, like deleting a connection or node.</li>
      <li class="bulletList">Create an <strong class="screenText">Apply changes</strong> button for updating the instances.</li>
    </ul>
    <p class="normal-one">Implement a simpler way to update the copies of a changed node tree for all instances that are using this tree.</p>
    <ul>
      <li class="bulletList">Load node trees from a running instance into the editor.</li>
    </ul>
    <p class="normal-one">This is a good idea for debugging purposes, but probably also fun to watch what happens in real time in the node tree of an instance.</p>
    <ul>
      <li class="bulletList">Add a real-time debug visualization of the loaded node tree.</li>
    </ul>
    <p class="normal-one">Visual debugging could help a lot with understanding what happens in a node tree. You could start by highlighting the currently active node in the graph of the selected instance (see the previous task) and later also highlight the currently active output pin plus the outgoing connections to other nodes.</p>
    <ul>
      <li class="bulletList">React to the creation of new links in imnodes.</li>
    </ul>
    <p class="normal-one">Instead of having to create a new node and then place a link, add the context menu to create a node when a new link is created but not attached. Connect the dangling link directly to the input or output pin of the new node.</p>
    <ul>
      <li class="bulletList">Let the sequence node also wait for grandchildren.</li>
    </ul>
    <p class="normal-one">You could add a cascade of notifications about entire sub-sequences having finished execution, not just wait and RandomWait nodes – maybe with an extra checkbox to control which child node in the chain is the last one to wait for.</p>
    <ul>
      <li class="bulletList">Add condition and loop nodes.</li>
    </ul>
    <p class="normal-one">Enable more control. The condition node needs access to data it should react on, either from the instance, the world, or from other nodes. The loop node must also wait for the child nodes to finish.</p>
    <ul>
      <li class="bulletList">Allow renaming and copy/paste for entire node trees, or between editor windows.</li>
    </ul>
    <p class="normal-one">Extend the current implementation by adding the ability to rename existing node trees. Creating a copy of an entire node tree may become handy to duplicate and adjust existing behavior, and a copy/paste operation of nodes or entire selections between two editor sessions would be a blast.</p>
    <ul>
      <li class="bulletList">Show more than one tree node in the editor window.</li>
    </ul>
    <p class="normal-one">Either by using dockable ImGui windows or just opening more editor windows, let the user work on multiple node trees at the same time.</p>
    <p class="normal-one">Caveat: If more than one window is shown, the internal ImGui IDs must be unique among all UI elements in the windows.</p>
    <ul>
      <li class="bulletList">Enhanced difficulty: Integrate a full C++ behavior tree library.</li>
    </ul>
    <p class="normal-one">Instead of this small and hand-crafted node tree version, add a full-featured behavior tree from a third-party library and add imnodes support for the tree management.</p>
    <h1 id="_idParaDest-284" class="heading-1">Additional resources</h1>
    <ul>
      <li class="bulletList">Introduction to behavior trees: <a href="https://robohub.org/introduction-to-behavior-trees/"><span class="url">https://robohub.org/introduction-to-behavior-trees/</span></a></li>
      <li class="bulletList">Behavior Trees: Breaking the Cycle of Misuse: <a href="https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf"><span class="url">https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf</span></a></li>
      <li class="bulletList">A simple C++ behavior tree example: <a href="https://lisyarus.github.io/blog/posts/behavior-trees.html"><span class="url">https://lisyarus.github.io/blog/posts/behavior-trees.html</span></a></li>
      <li class="bulletList">Node Graph Editors with ImGui: <a href="https://github.com/ocornut/imgui/issues/306"><span class="url">https://github.com/ocornut/imgui/issues/306</span></a></li>
      <li class="bulletList">imnodes extension for ImGui: <a href="https://github.com/Nelarius/imnodes"><span class="url">https://github.com/Nelarius/imnodes</span></a></li>
    </ul>
    <h1 id="_idParaDest-285" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/cppgameanimation"><span class="url">https://packt.link/cppgameanimation</span></a></p>
    <p class="normal"><img src="../Images/QR_code_Discord.png" alt="A qr code with black squares  AI-generated content may be incorrect." width="150" height="150"/></p>
  </div>
</div></div></body></html>