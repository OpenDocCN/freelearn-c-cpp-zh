- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing Databases with SQL Driver and Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structured Query Language** (**SQL**) is a special programming language used
    to manage data held in a relational database management system. A SQL server is
    a database system designed to use one of the many types of SQL programming languages
    to manage its data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing basic SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a login screen with Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information from a database in model view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and
    Qt Creator 12.0.2\. All the code used in this chapter can be downloaded from the
    following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt supports several different types of SQL drivers in the form of plugins/add-ons,
    such as **SQLite**, **ODBC**, **PostgreSQL**, **MySQL**, and so on. However, it’s
    very easy to integrate these drivers into your Qt project. We will learn how to
    do this in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will learn how to use Qt with **SQLite**. Let’s set up
    our SQLite editor before we dive into Qt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download **SQLiteStudio** from [https://sqlitestudio.pl](https://sqlitestudio.pl)
    and install it to administrate your SQLite databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Install SQLiteStudio onto your computer](img/B20976_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Install SQLiteStudio onto your computer
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **SQLiteStudio** and you should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – SQLiteStudio is a handy program for managing SQLite databases](img/B20976_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – SQLiteStudio is a handy program for managing SQLite databases
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new database before we start; go to **Database** | **Add
    a database**. Select the **SQLite 3** option for your database type, followed
    by selecting your file name and setting your database name. Then, click the **Test
    connection** button. You should see a green tick appearing beside the button.
    After that, click on the **OK** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Creating a new SQLite 3 database](img/B20976_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Creating a new SQLite 3 database
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the database has been created, you should see the database appear in the
    **Databases** window. Then, right-click on **Tables** and select **Create a table**
    option from the menu that pops up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Select the Create a table option from the menu](img/B20976_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Select the Create a table option from the menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the table name as `employee`. Then, click on the **Add column (lns)** button
    located above the table name input field. The **Column** window will now pop up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Create a new column called emp_id](img/B20976_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Create a new column called emp_id
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the column name as `emp_id`, set the data type as **INTEGER**, and check
    the **Primary key** checkbox. Then, click on the **Configure** button at the right
    of the **Primary key** checkbox. The **Edit constraint** window will now pop up.
    Check on the **Autoincrement** checkbox and click **Apply**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Enable the Autoincrement checkbox](img/B20976_12_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Enable the Autoincrement checkbox
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, press the `emp_id`. Let’s repeat the steps above (without enabling
    the primary key) to create other columns. You may follow the same settings as
    seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Create all five columns](img/B20976_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Create all five columns
  prefs: []
  type: TYPE_NORMAL
- en: 'The columns are not actually created at this point. Click on the button with
    a green tick icon located above the table name. A window will pop up to confirm
    the creation of the columns. Press **OK** to proceed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Click the OK button to confirm](img/B20976_12_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Click the OK button to confirm
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have created the `employee` table. Let’s move on from the `employee`
    table, which is currently empty. Let’s insert dummy data into the `employee` table
    by clicking on the **Insert row (Ins)** button, which is the one with a green
    plus icon. Then, simply insert some dummy data like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Insert dummy data into the employee table](img/B20976_12_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Insert dummy data into the employee table
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up the SQL driver for our Qt project. Just go to your Qt installation
    folder and look for the `sqldrivers` folder. For example, mine is located at `C:\Qt\6.4.2\mingw_64\plugins\sqldrivers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the entire `sqldrivers` folder to your project’s build directory. You can
    remove the DLL files that are not relevant to the SQL server you’re running. In
    our case, since we’re using `qsqlite.dll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The DLL files mentioned in the previous step are the drivers that enable Qt
    to communicate with different types of SQL architecture. You may also need the
    DLL file of the SQL client library in order for the driver to work. In our case,
    we need `sqlite3.dll` to be located in the same directory as our program’s executable.
    You can either get it from the installation directory of **SQLiteStudio** or from
    the official website of **SQLite**: [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt provides us with SQL drivers so that we can easily connect to different types
    of SQL servers without implementing them ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Qt officially supports SQLite, ODBC, and PostgreSQL. If you need
    to connect directly to MySQL, you need to recompile Qt drivers by yourself, which
    is out of the scope of this book. For security reasons, it’s not recommended that
    you connect to MySQL directly from your application. Instead, your application
    should interact with your MySQL database (or any other SQL servers that are not
    officially supported by Qt) indirectly by sending an HTTP request using `QNetworkAccessManager`
    to your backend script (such as PHP, ASP, and JSP), which can then communicate
    with the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you only need a simple file-based database and don’t plan to use a server-based
    database, **SQLite** is a good choice for you, which is what we have chosen for
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Connecting to a database* recipe, we will learn how to connect to our
    SQL database using Qt’s SQL module.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to connect our Qt 6 application to the SQL
    server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connecting to SQL Server in Qt is really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Qt Creator and create a new **Qt Widgets** **Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your project file (`.pro`), add the `sql` module to your project, and
    run `qmake` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.10 –  Setting the text properties](img/B20976_12_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Setting the text properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `mainwindow.h` and add the following headers below the `QMainWindow` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MainWindow::MainWindow(QWidget *parent) :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QMainWindow(parent), ui(new Ui::MainWindow) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui->setupUi(this);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: db.setDatabaseName("database.db3");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the SQL query once the database connection has been opened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out any error texts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run your project now, you should get something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – The data from our database is now showing on the Qt program](img/B20976_12_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – The data from our database is now showing on the Qt program
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example shows you how to connect to your SQL database using the
    `QSqlDatabase` class derived from the SQL module. You won’t be able to access
    any of the classes related to SQL without adding the module to your Qt project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must tell Qt which SQL architecture we are running by mentioning it when
    calling the `addDatabase()` function. The options supported by Qt are `QSqlDatabase:
    QMYSQL driver not loaded`, you should check whether the DLL files are placed in
    the correct directory.'
  prefs: []
  type: TYPE_NORMAL
- en: We can send our SQL statements to the database through the `QSqlQuery` class
    and wait for it to return the results, which are usually either the data you requested
    or error messages due to invalid statements. If there are any data coming from
    the database server, they will all be stored in the `QSqlQuery` class. All you
    need to retrieve these data is to perform a “while” loop on the `QSqlQuery` class
    to check for all existing records and retrieve them by calling the `value()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Since we used SQLite in the preceding example, we don’t need to set the server
    host, username, and password when connecting to the database. SQLite is a file-based
    SQL database; therefore, we only need to set the file name when calling `QSqlDatabase::setDatabaseName()`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Qt 6 no longer officially supports QMYSQL or QMYSQL3\. You can add MySQL support
    by re-compiling Qt from the source yourself. However, this method is not recommended
    for beginners. For more information, check out [https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver](https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver).
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic SQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we wrote our very first SQL query, which involves the
    `SELECT` statement. This time, we will learn how to use some other SQL statements,
    such as `INSERT`, `UPDATE`, and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a simple program that demonstrates basic SQL query commands by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our previous project files, but there are a couple of things we
    need to change. Open `mainwindow.ui` and replace the labels for `UPDATE`, `INSERT`,
    and `DELETE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Modify the UI to this](img/B20976_12_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Modify the UI to this
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `mainwindow.h` and add the following variables under the private inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MainWindow::MainWindow(QWidget *parent) :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QMainWindow(parent), ui(new Ui::MainWindow) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui->setupUi(this);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: db = QSqlDatabase::addDatabase("QSQLITE");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: db.setDatabaseName("database.db3");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: connected = db.open();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s make a query after we have connected to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out any error messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to `mainwindow.ui` and right-click on one of the buttons we added to the
    canvas in step 1\. Select `mainwindow.h` and `mainwindow.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `mainwindow.cpp` and we will declare what the program will do when we
    click on the **Update** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make an `UPDATE` query like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the last error message, if any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare what will happen when the **INSERT** button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make an `INSERT` query like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare what will happen when the **Delete** button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `QSqlDatabase::close()` at the class destructor to properly terminate
    the SQL connection before exiting the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the program now, you should be able to select the default
    data from the database. Then, you can choose to update it or delete it from the
    database. You can also insert new data into the database by clicking the Insert
    button. You can use **SQLiteStudio** to check whether the data are being altered
    correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Data successfully modified in SQLite](img/B20976_12_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Data successfully modified in SQLite
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s very important to check whether the database is connected before we proceed
    to send an SQL query to the database. Therefore, we keep that status in a variable
    and use it to check before sending out any queries. This, however, is not recommended
    for complex programs that are kept open for long periods of time, as the database
    might get disconnected during those periods, and a fixed variable may not be accurate.
    In that case, it’s better to check the actual status by calling `QSqlDatabase::isOpen()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `currentID` variable is used to save the ID of the current data you obtained
    from the database. When you want to update the data or delete them from the database,
    this variable is crucial for letting the database know what data you’re trying
    to update or delete. If you set your database table correctly, SQLite will treat
    each item of data as a unique entry, so you can be sure that no repeated ID will
    be produced in the database when new data are being saved.
  prefs: []
  type: TYPE_NORMAL
- en: After inserting new data into the database, we call `QSqlQuery::lastInsertId()`
    to obtain the ID of the new data and save it as a `currentID` variable so that
    it becomes the current data that we can update or delete from the database. It
    is a good habit to test your SQL queries on `SQLiteStudio` before using them in
    Qt. You can instantly find out whether your SQL statements are correct or incorrect
    instead of waiting for your project to be built, trying it out, and then rebuilding
    it. As programmers, we must work in the most efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Work hard and work smart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a login screen with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how put our knowledge to use and create a functional
    login screen using Qt and SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create your first functional login screen by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a web browser and go to `user`, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Create a new user table](img/B20976_12_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Create a new user table
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s insert our first item of data into the newly created table and set `user_employeeID`
    to the ID of an existing employee. In this way, the user account we create will
    be linked to the data of one of the employees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.15 – The user_employeeID column is linked to the employee’s emp_id
    column](img/B20976_12_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – The user_employeeID column is linked to the employee’s emp_id
    column
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `mainwindow.ui`. Place a stacked widget on the canvas and make sure it
    contains two pages. Then, set up the two pages in the stacked widget as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Create a two-page UI inside a stacked widget](img/B20976_12_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Create a two-page UI inside a stacked widget
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first page of the stacked widget, click the **Edit Tab Order** icon
    on top of the widget so that you can adjust the order of the widgets in your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Change the order of the widgets by pressing this button](img/B20976_12_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Change the order of the widgets by pressing this button
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click the **Edit Tab Order** icon, you will see some numbers appear
    on top of each widget in the canvas. Make sure the numbers look the same as they
    do in the screenshot that follows. Otherwise, click on the numbers to change their
    order. We only do this for the first page of the stacked widget; it’s okay to
    keep the second page as it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.18 – The order of each widget is shown](img/B20976_12_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 – The order of each widget is shown
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `clicked()` option is selected and press **OK**. Qt will
    then create a slot function for you in your project source files. Repeat this
    step for the **Log Out** button as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `mainwindow.h` and add the following headers after the `#include <``QMainWindow>`
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'private:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ui::MainWindow *ui;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: QSqlDatabase db;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `mainwindow.cpp` and put this code in the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define what will happen if the `Login` button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a SQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We continue with the preceding code, and we set the gender and married texts
    before switching the stacked widget to its second page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print an error message if the login fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define what will happen if the **Log Out** button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the database when the main window is closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the program, and you should be able to log in with the dummy
    account. After you have logged in, you should be able to see the dummy employee
    information linked to the user account. You can also log out by clicking on the
    **Log** **Out** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.19 – A simple, working login screen](img/B20976_12_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – A simple, working login screen
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we select data from the user table that matches the username
    and password that we inserted into the text fields. If nothing is found, it means
    we have provided an invalid username or password. Otherwise, obtain the `user_employeeID`
    data from the user account and do another SQL query to look for information from
    the `employee` table that matches the `user_employeeID` variable. Then, display
    the data according to the UI of your program.
  prefs: []
  type: TYPE_NORMAL
- en: We must set the widget order in the **Edit Tab Order** mode so that when the
    program has started, the first widget that gets focused on is the username line-edit
    widget. If the user presses the *Tab* key on the keyboard, the focus should switch
    to the second widget, which is the password line edit. An incorrect widget order
    will ruin the user experience and drive away any potential users. Make sure that
    the **echoMode** option of the password line edit is set to **Password**. That
    setting will hide the actual password inserted into the line edit and replace
    it with dot symbols for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Since SQLite does not support returning the query size, we cannot use the `QSqlQuery::size()`
    function to determine how many results are being returned; the result will always
    be -`1`. Therefore, we declared a `resultSize` variable to count the result within
    the while loop operation.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying information from a database in model view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to display information from a database on a model view widget:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to display multiple sets of data obtained
    from our SQL database in a model view in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the database table called `employee`, which we used in the
    previous example in *Creating a login screen with Qt*. This time, we need a lot
    more data in the employee table. Open up your **SQLiteStudio** control panel.
    Add data for a few more employees so that we can display it later in our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Add more dummy data to the employee table](img/B20976_12_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – Add more dummy data to the employee table
  prefs: []
  type: TYPE_NORMAL
- en: Open Qt Creator, create a new **Qt Widgets Application** project, and then add
    the **SQL** module to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `mainwindow.ui` and add a table widget (not a table view) from **Item
    Widget** (item-based) under the **Widget** box pane. Select the main window on
    the canvas and click on either the **Lay Out Vertically** or **Lay Out Horizontally**
    button to make the table widget stick to the size of the main window even when
    it’s resized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Click on the Lay Out Vertically button](img/B20976_12_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – Click on the Lay Out Vertically button
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the table widget and a window will appear. Under the **Columns**
    tab, add five items by clicking on the **+** button in the top-left corner. Name
    the items **ID**, **Name**, **Age**, **Gender**, and **Married**. Click **OK**
    when you’re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.22 – We also set the text alignment to center](img/B20976_12_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – We also set the text alignment to center
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the table widget and select `itemChanged(QTableWidgetItem*)`
    option in the pop-up window, and press **OK**. A slot function will be created
    in both of your source files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `mainwindow.h` and add these private variables to the `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#include <QtSql>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QSqlDatabase>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QSqlQuery>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QMessageBox>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QDebug>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QTableWidgetItem>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `mainwindow.cpp`; we’re going to write tons of code there. We need to
    declare what will happen when the program is started. Add the following code to
    the constructor of the `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The SQL query code looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create several `QTableWidgetItem` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move those objects to the table widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare what will happen when an item of the table widget has been edited.
    Add the following code to the `on_tableWidget_itemChanged()` slot function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the database at the class destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the example now, you should get something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.23 – We have created our own SQL editor](img/B20976_12_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.23 – We have created our own SQL editor
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table widget is similar to the one you see in spreadsheet applications such
    as **Microsoft Excel** and **OpenOffice Calc**. In contrast to other types of
    model viewers, such as list view or tree view, table view (or table widget) is
    a two-dimensional model viewer, which displays data in the form of rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a table view and a table widget in Qt is that a
    table widget is built on top of a table view class, which means a table widget
    is easier to use and more suitable for beginners. However, a table widget is less
    flexible and tends to be less scalable than a table view, which is not the best
    choice if you want to customize your table. After retrieving data from SQLite,
    we created a `QTableWidgetItem` item for each of the data items and set which
    column and row should be added to the table widget. Before adding an item to the
    table widget, we must increase the row count of the table by calling `QTableWidget::setRowCount()`.
    We can also get the current row count of the table widget by simply calling `QTableWidget::rowCount()`.
  prefs: []
  type: TYPE_NORMAL
- en: The first column from the left is hidden from view because we only use it to
    save the ID of the data so that we can use it to update the database when one
    of the data items in its row has changed. The `on_tableWidget_itemChanged()` slot
    function will be called when the data in one of the cells has changed. It will
    not only get called when you edit the data in the cell but also when the data
    are first added to the table after being retrieved from the database. To ensure
    that this function is only triggered when we edit the data, we use a Boolean variable
    called `hasInit` to check whether we have done the initialization process (adding
    the first batch of data to the table). If `hasInit` is false, ignore the function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent users from entering a totally irrelevant type of data, such as inserting
    letters into a numerical-only data cell, we manually check whether the data are
    anything close to what we’d expected when they were being edited. Revert it to
    a default value if it doesn’t come close to anything considered valid. This is,
    of course, a simple hack, which does the job but is not the most professional
    method. Alternatively, you can try to create a new class that inherits the `QItemDelegate`
    class and defines how your model view should behave. Then, call `QTableWidget::setItemDelegate()`
    to apply the class to your table widget.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced SQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By following this recipe, you will learn how to use advanced SQL statements
    such as `INNER` `JOIN`, `COUNT`, `LIKE`, and `DISTINCT`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can do a lot more than just perform simple queries on the SQL database.
    Let’s follow these steps to learn how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a few tables to our database before we can dive into the programming
    part. Open your **SQLiteStudio**. We need several tables for this example to work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Additional tables that we need to create for this example](img/B20976_12_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.24 – Additional tables that we need to create for this example
  prefs: []
  type: TYPE_NORMAL
- en: 'I will show you the structure of each of the tables required for this project
    and the dummy data inserted into the tables for testing. The first table is called
    `branch`, which is used to store the IDs and names of different branches of the
    dummy company:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.25 – The branch table](img/B20976_12_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.25 – The branch table
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we have the `department` table, which stores the IDs and names of
    different departments of the dummy company, which is also linked to the `branch`
    data by the branch IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.26 – The department table, which links to the branch table](img/B20976_12_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.26 – The department table, which links to the branch table
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have an `employee` table, which stores information on all the employees
    in the dummy company. This table is similar to the one we used in the previous
    examples, except it has two extra columns, `emp_birthday` and `emp_departmentID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.27 – The employee table, which links to the department table](img/B20976_12_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.27 – The employee table, which links to the department table
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a table called `log`, which contains dummy records of the login
    time for each employee. `log_loginTime` will be set as a date-time variable type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.28 – The log table, which links to the user table](img/B20976_12_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.28 – The log table, which links to the user table
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `user` table that we also used in the previous examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.29 – The user table](img/B20976_12_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.29 – The user table
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Qt Creator. This time, instead of choosing **Qt Widgets Application**,
    we select **Qt** **Console Application**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.30 – Create a Qt Console Application project](img/B20976_12_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.30 – Create a Qt Console Application project
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your project file (.pro) and add the `sql` module to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#include <QSqlDatabase>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QSqlQuery>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QSqlError>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QDate>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QDebug>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function to display employees who are more than 30 years
    old:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function to display the `department` and `branch` information
    of each employee:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, which displays employees who are working in the
    New York branch and are under 40 years old:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, which counts the total number of female employees
    in the dummy company:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, which filters the employee list and only displays
    those names that start with `Ja`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, which displays employees who have birthdays in
    August:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, which checks who logged into the dummy system on
    27 April 2024 and displays their names on the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, connect the program to the SQLite database and call
    all the functions that we defined in the previous steps. Close the database connection,
    and we’re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the project now, you should see a terminal window that
    displays the filtered results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.31 – Printing the results on the Application Output window](img/B20976_12_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.31 – Printing the results on the Application Output window
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A console application does not have a GUI and only shows you a text display
    in a terminal window. This is usually used in a backend system, as it uses fewer
    resources compared to a widget application. We used it in this example because
    it’s faster to display the result without the need to place any widgets in the
    program, which we don’t need in this case.
  prefs: []
  type: TYPE_NORMAL
- en: We separated the SQL queries into different functions so that it’s easier to
    maintain the code and it doesn’t become too messy. Do note that in C++, the functions
    have to be located before the `main()` function; otherwise, they will not be able
    to be called by `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `INNER JOIN` statement used in the preceding example joins two tables together
    and selects all rows from both tables, as long as there is a match between the
    columns in both tables. There are many other types of `JOIN` statements that you
    can use in SQLite (and some other types of SQL architecture), such as `LEFT JOIN`,
    `RIGHT JOIN`, and `FULL` `OUTER JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the different types of `JOIN` statements and their
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.32 – Different types of JOIN statements](img/B20976_12_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.32 – Different types of JOIN statements
  prefs: []
  type: TYPE_NORMAL
- en: 'The following bullet points explain the `LIKE` and `DISTINCT` statements, which
    we used in our example code in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: The `LIKE` statement is normally used to search for a string variable in the
    database without the full word. Notice that there are two % symbols located before
    and after the search keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DISTINCT` statement used in the previous example filters out results that
    have the exact same variable. For example, without the `DISTINCT` statement, you
    will see two versions of Larry King appear in the terminal because there are two
    records of him logging into the system on the same day. By adding the `DISTINCT`
    statement, SQLite will eliminate one of the results and ensure every result is
    unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be wondering what `d-MMMM-yyyy` stands for and why we used it in the
    preceding example. That is actually an expression supplied to the `QDateTime`
    class in Qt to display the date-time result using a given format. In this case,
    it will change the date-time data that we get from SQLite, 2024-08-06, to the
    format that we specified, resulting in 6-August-2024.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, check out Qt’s documentation at [http://doc.qt.io/qt-6/qdatetime.html#toString](http://doc.qt.io/qt-6/qdatetime.html#toString),
    which has the full list of expressions that can be used to determine the format
    of the date and time string.
  prefs: []
  type: TYPE_NORMAL
- en: SQL provides an easy and efficient way to save and load user data without reinventing
    the wheel. Qt provides you with an out-of-the-box solution for connecting your
    application with a SQL database; in this chapter, we have learned how to do this
    by using a step-by-step approach, and we were able to load and save our user’s
    data into the SQL database.
  prefs: []
  type: TYPE_NORMAL
