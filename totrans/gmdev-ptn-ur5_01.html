<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.2.1">Understanding Unreal Engine 5 and its Layers</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Design patterns are a series of tools and practices by which we can learn to write faster and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">easier-to-work-with code.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Applying design patterns to projects developed in </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Unreal Engine 5</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">UE5</span></strong><span class="koboSpan" id="kobo.9.1">) will allow you to make your projects more performant, easier to read, and build upon, as well as develop an improved understanding of how the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">engine works.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">We’re going to begin by developing an understanding of the history of Unreal Engine and ensuring that we are all set up to work with the engine, covering some basic ideas of how C++ and Unreal Engine’s visual scripting language, </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Blueprint</span></strong><span class="koboSpan" id="kobo.13.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">are linked.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Introducing Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Engine 5</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Installing Unreal Engine 5 and preparing your </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">development environment</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">The “Fuzzy” layer – bridging the gap from C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">to Blueprint</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Translating back from Blueprint </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">to C++</span></span></li>
</ul>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">Before embarking on this journey of discovery, know that this book will assume some working knowledge of C++ syntax and the Unreal Engine Editor. </span><span class="koboSpan" id="kobo.26.2">Familiarity with pointers and how to follow code in your chosen </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">integrated development environment</span></strong><span class="koboSpan" id="kobo.28.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.29.1">IDE</span></strong><span class="koboSpan" id="kobo.30.1">) will be key to understanding the Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">core API.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">You will require the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">following software:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">Unreal Engine 5 (this book has been written with </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">version 5.0.3).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.36.1">Visual Studio</span></strong><span class="koboSpan" id="kobo.37.1"> is a decent free IDE (basic support for the engine is present, meaning projects may show errors and </span><em class="italic"><span class="koboSpan" id="kobo.38.1">IntelliSense</span></em><span class="koboSpan" id="kobo.39.1"> may not auto-complete some keywords, but the project will compile </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">and run).</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">If you have access, JetBrains Rider version 2022 or later has built-in support for Unreal Engine, which will make the development process a lot easier. </span><span class="koboSpan" id="kobo.41.2">Rider is an alternative IDE to Visual Studio that is often preferred among programmers working with Unreal. </span><span class="koboSpan" id="kobo.41.3">It offers improved support for working with C++ in Unreal Engine, including auto-complete. </span><span class="koboSpan" id="kobo.41.4">You can learn more about it by </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">visiting </span></span><a href="https://www.jetbrains.com/lp/rider-unreal/"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://www.jetbrains.com/lp/rider-unreal/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.44.1">.</span></span></li>
</ul>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.45.1">Introducing Unreal Engine 5</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Unreal Engine 5, or Unreal for </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.47.1">short, is a game engine developed by </span><em class="italic"><span class="koboSpan" id="kobo.48.1">Epic Games</span></em><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">Unreal, as with any other game engine at its core, simply processes data from files and instructions into data that you can see on the screen. </span><span class="koboSpan" id="kobo.49.3">The suite of tools provided are designed to assist you in creative and predictable tasks. </span><span class="koboSpan" id="kobo.49.4">Having been created for you by elite programmers and designers, it is like outsourcing your development to the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">big leagues.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">However, like a high-performance racing car driven by a learner, even the best tools can perform badly. </span><span class="koboSpan" id="kobo.51.2">The experts at Epic didn’t know how you would use their tools. </span><span class="koboSpan" id="kobo.51.3">So, when we design our code architecture, we need to keep this break in communications in mind. </span><span class="koboSpan" id="kobo.51.4">This is where this book comes in, teaching the expected best practices when writing games in Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">Engine 5.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Unreal Engine has powered an impressive list of gaming titles covering a vast array of genres, shipping on a multitude </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">of platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Unreal Engine 3 powered some of the biggest hits from the seventh generation of game consoles, ranging from third-person shooter games </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.56.1">such as the </span><em class="italic"><span class="koboSpan" id="kobo.57.1">Gears of War</span></em><span class="koboSpan" id="kobo.58.1"> series developed by </span><em class="italic"><span class="koboSpan" id="kobo.59.1">Epic Games</span></em><span class="koboSpan" id="kobo.60.1"> themselves to fighting games such as </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Injustice: Gods Among Us</span></em><span class="koboSpan" id="kobo.62.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Mortal Kombat</span></em><span class="koboSpan" id="kobo.64.1"> from </span><em class="italic"><span class="koboSpan" id="kobo.65.1">NetherRealm</span></em><span class="koboSpan" id="kobo.66.1">, as well as strategy games including the </span><em class="italic"><span class="koboSpan" id="kobo.67.1">XCOM</span></em><span class="koboSpan" id="kobo.68.1"> series developed by </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.69.1">Firaxis Games</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">The eighth generation of consoles saw Unreal Engine 4 expand its portfolio to include racing titles such as the </span><em class="italic"><span class="koboSpan" id="kobo.72.1">MotoGP</span></em><span class="koboSpan" id="kobo.73.1"> games from </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Milestone</span></em><span class="koboSpan" id="kobo.75.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Assetto Corsa Competizione</span></em><span class="koboSpan" id="kobo.77.1"> from </span><em class="italic"><span class="koboSpan" id="kobo.78.1">Kunos Simulazioni</span></em><span class="koboSpan" id="kobo.79.1">, as well as facilitating the hugely popular introduction of the Battle Royale genre with </span><em class="italic"><span class="koboSpan" id="kobo.80.1">PlayerUnknowns’ Battlegrounds</span></em><span class="koboSpan" id="kobo.81.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.82.1">PUBG Studios</span></em><span class="koboSpan" id="kobo.83.1">), which is listed as the fifth highest-selling video game on </span><em class="italic"><span class="koboSpan" id="kobo.84.1">Wikipedia</span></em><span class="koboSpan" id="kobo.85.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Epic Games</span></em><span class="koboSpan" id="kobo.87.1">’ </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Fortnite</span></em><span class="koboSpan" id="kobo.89.1">, which transitioned to Unreal Engine 5 in December 2021 as detailed in </span><a href="B18297_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.91.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Unreal Engine 5 features a series of new, key technologies, including </span><em class="italic"><span class="koboSpan" id="kobo.93.1">Nanite</span></em><span class="koboSpan" id="kobo.94.1">, a sub-mesh level of detail system allowing massive polycount models to render with even screen-space hull size at any distance, and </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Lumen</span></em><span class="koboSpan" id="kobo.96.1">, a real-time lighting solution that mixes mesh distance fields and atlassed local surface data progressively over time to create a realistic lighting effect at low cost. </span><span class="koboSpan" id="kobo.96.2">These new technologies drove the transition from 4.26/4.27 to 5.0 as part of a complete rework of Unreal’s rendering technology. </span><span class="koboSpan" id="kobo.96.3">The engine had an impactful debut with the release of </span><em class="italic"><span class="koboSpan" id="kobo.97.1">The Matrix Awakens: An Unreal Engine Experience</span></em><span class="koboSpan" id="kobo.98.1">, a</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.99.1"> demo featuring photorealistic likenesses of Carrie-Anne Moss and Keanu Reeves, and an open-world city featuring impressive examples of crowd and </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">traffic simulations.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Increasingly, games studios are opting to replace proprietary in-house developed game engines with Unreal Engine 5; studios such as </span><em class="italic"><span class="koboSpan" id="kobo.102.1">CD Projekt Red</span></em><span class="koboSpan" id="kobo.103.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.104.1">The Witcher</span></em><span class="koboSpan" id="kobo.105.1">) and </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Crystal Dynamics</span></em><span class="koboSpan" id="kobo.107.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.108.1">Tomb Raider</span></em><span class="koboSpan" id="kobo.109.1">) have announced the decision to use Unreal Engine 5 in the latest installments of their </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">game series.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Now that we’ve covered a little about Unreal Engine’s past, pedigree, and influence on gaming history, we will get things set up next so that you are ready to use Unreal Engine 5 </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">with C++.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.113.1">Installing Unreal Engine 5 and preparing your development environment</span></h1>
<p><span class="koboSpan" id="kobo.114.1">Unreal Engine can be downloaded either via the Epic </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.115.1">Games Launcher (available from https://unrealengine.com, which will install the engine for you) or as</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.116.1"> source code from GitHub (www.github.com/EpicGames), allowing users to compile the engine and modify it to fit </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">their projects.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">To engage with the activities in this book, you won’t need to compile the engine from source unless you really want to. </span><span class="koboSpan" id="kobo.118.2">The benefits of compiling from source will likely come much later into your journey of working with Unreal Engine and C++. </span><span class="koboSpan" id="kobo.118.3">You will, however, need to install version 5.0.3 (or above) of the engine and have an IDE installed. </span><span class="koboSpan" id="kobo.118.4">This section covers the download, installation, and setup of the engine from scratch using the Unreal Launcher and installation of Visual Studio 2022 Community. </span><span class="koboSpan" id="kobo.118.5">If you already have the engine and Visual Studio installed, you can skip over </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Firstly, you will need to download </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.121.1">the Launcher from </span><a href="https://unrealengine.com"><span class="koboSpan" id="kobo.122.1">https://unrealengine.com</span></a><span class="koboSpan" id="kobo.123.1"> by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Download</span></strong><span class="koboSpan" id="kobo.125.1"> button in the top-right corner of the page and clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Download Launcher</span></strong><span class="koboSpan" id="kobo.127.1"> button on the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">following page.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Once downloaded, you will need to install the Launcher from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">msi</span></strong></span><span class="No-Break"><em class="italic"> </em></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">installer.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">The Launcher is home to the Epic Games Store, your library of purchased and downloaded games as well as versions of Unreal Engine (4 and above). </span><span class="koboSpan" id="kobo.133.2">You will need to navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">Unreal Engine</span></strong><span class="koboSpan" id="kobo.135.1"> and then </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">Library</span></strong><span class="koboSpan" id="kobo.137.1">, then click the </span><em class="italic"><span class="koboSpan" id="kobo.138.1">yellow plus icon</span></em><span class="koboSpan" id="kobo.139.1"> and select your engine version from the resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">engine slot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.141.1"><img alt="Figure 1.1 – The default Epic Games Launcher with no versions of the engine installed" src="image/B18297_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 1.1 – The default Epic Games Launcher with no versions of the engine installed</span></p>
<p><span class="koboSpan" id="kobo.143.1">Alternatively, if you don’t have any versions of the engine installed, you can click the </span><em class="italic"><span class="koboSpan" id="kobo.144.1">yellow drop-down button</span></em><span class="koboSpan" id="kobo.145.1"> in the top right of the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">Launcher application.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Both approaches will present you with the option of where you would like to install the engine. </span><span class="koboSpan" id="kobo.147.2">It is advisable to install the </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.148.1">engine on an SSD if possible as the engine will load significantly quicker than from </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">an HDD:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.150.1"><img alt="Figure 1.2 – Install location options" src="image/B18297_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">Figure 1.2 – Install location options</span></p>
<p><span class="koboSpan" id="kobo.152.1">Clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Options</span></strong><span class="koboSpan" id="kobo.154.1"> button will present you with a series of optional elements for installing </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the engine:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.156.1"><img alt="Figure 1.3 – Installation options for Unreal Engine 5.0.3" src="image/B18297_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.157.1">Figure 1.3 – Installation options for Unreal Engine 5.0.3</span></p>
<p><span class="koboSpan" id="kobo.158.1">We advise installing </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">Starter Content</span></strong><span class="koboSpan" id="kobo.160.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">Templates and Feature Packs</span></strong><span class="koboSpan" id="kobo.162.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.163.1">Engine Source</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.165.1">Engine Source</span></strong><span class="koboSpan" id="kobo.166.1"> will make browsing and debugging code easier but does not allow you to rebuild the engine; for that functionality, you will need to download the source from GitHub, as </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">mentioned earlier.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.168.1">Editor symbols for debugging</span></strong><span class="koboSpan" id="kobo.169.1"> allows the debugging of C++ in the Editor. </span><span class="koboSpan" id="kobo.169.2">This is not required but will prove useful to facilitate jumping from the Editor to engine code and allow you to explore the code behind </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">Blueprint nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">If you decide you want to add/remove </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.172.1">elements later, you can modify these choices by clicking the </span><em class="italic"><span class="koboSpan" id="kobo.173.1">down arrow</span></em><span class="koboSpan" id="kobo.174.1"> next to </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Launch</span></strong><span class="koboSpan" id="kobo.176.1"> on the engine slot and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">selecting </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.178.1">Options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.180.1"><img alt="Figure 1.4 – Location of the Options menu on an engine slot" src="image/B18297_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">Figure 1.4 – Location of the Options menu on an engine slot</span></p>
<p><span class="koboSpan" id="kobo.182.1">Enable the checkbox next to </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">Editor symbols for debugging</span></strong><span class="koboSpan" id="kobo.184.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.186.1">Apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Once you have the engine installed, you can move on to installing </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Visual Studio.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">You will need to download the Visual Studio installer </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">from </span></span><a href="https://visualstudio.microsoft.com/downloads/"><span class="No-Break"><span class="koboSpan" id="kobo.192.1">https://visualstudio.microsoft.com/downloads/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.193.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">When you run the installer, select the </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">Game Development with C++</span></strong><span class="koboSpan" id="kobo.196.1"> preset in the </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">Workloads</span></strong><span class="koboSpan" id="kobo.198.1"> tab and select optional components, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.199.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.200.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.202.1"><img alt="Figure 1.5 – Suggested installation options for Visual Studio Community 2022" src="image/B18297_01_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">Figure 1.5 – Suggested installation options for Visual Studio Community 2022</span></p>
<p><span class="koboSpan" id="kobo.204.1">Once you have Visual</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.205.1"> Studio installed, you should be ready to go. </span><span class="koboSpan" id="kobo.205.2">If you </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.206.1">want to further improve your experience of working in Visual Studio with Unreal Engine 5.0.X, you can find some additional guidance from </span><em class="italic"><span class="koboSpan" id="kobo.207.1">Epic</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.208.1">at </span></span><a href="https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/"><span class="No-Break"><span class="koboSpan" id="kobo.209.1">https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engin</span><span id="_idTextAnchor021"/><span class="koboSpan" id="kobo.210.1">e/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.211.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Now that we’ve installed the engine and set up our IDE, we can start exploring the link between C++ code </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">and Blueprint.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.214.1">The “Fuzzy” layer – bridging the gap from C++ to Blueprint</span></h1>
<p><span class="koboSpan" id="kobo.215.1">Most engines work on the concept of layers. </span><span class="koboSpan" id="kobo.215.2">Each layer has a specific job to do, and when stacked in the correct order, they simplify the development and maintenance of an engine. </span><span class="koboSpan" id="kobo.215.3">For example, if a new graphics language emerges that it would be wise to support, only the layer with the graphics pipeline needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">be changed.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">There is no hard and fast rule for the number or breakdown of layers in an engine, but what you will generally find is a </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.218.1">separation that resembles </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.219.1">Table 1.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.221.1">Tool</span></strong></span></p>
<p><span class="koboSpan" id="kobo.222.1">Full of Editor functions that speed up standard tasks. </span><span class="koboSpan" id="kobo.222.2">This suite is generally what an engine is </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">marketed on.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">Gameplay</span></strong></span></p>
<p><span class="koboSpan" id="kobo.225.1">All of the custom systems created to facilitate interaction mechanics that will be bespoke in the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">built game.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.227.1">Function</span></strong></span></p>
<p><span class="koboSpan" id="kobo.228.1">Where all automatic internal systems are handled like input capture and physics </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">processing, etc.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.230.1">Resource</span></strong></span></p>
<p><span class="koboSpan" id="kobo.231.1">Memory management and asset streaming are </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">handled here.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.233.1">Platform</span></strong></span></p>
<p><span class="koboSpan" id="kobo.234.1">Essentially, the graphics pipeline definition and build platform native integrations if the engine </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">supports it.</span></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">Base</span></strong></span></p>
<p><span class="koboSpan" id="kobo.237.1">Full of core dependency libraries such as UI frameworks for the Editor and </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">math libraries.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">Table 1.1 – Common engine layers and their uses</span></p>
<p><span class="koboSpan" id="kobo.240.1">Although Unreal may not explicitly label its layers in this way, we can see them in action in the relationship between how Unreal processes C++ and Blueprint gameplay. </span><span class="koboSpan" id="kobo.240.2">Functions created with certain specifiers in C++ can be accessed in Blueprint, but the reverse is not true. </span><span class="koboSpan" id="kobo.240.3">This shows there is an order to our actions where signals can only be passed one way. </span><span class="koboSpan" id="kobo.240.4">We’ll refer to this internal separation between gameplay layers as the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.241.1">Fuzzy layer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">The fact that the Fuzzy layer exists</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.244.1"> places a limitation on how we design our systems, but in turn, we gain a separation that enables gameplay programmers to work alongside designers with little friction. </span><span class="koboSpan" id="kobo.244.2">Systems can be developed for simple creative use within accessible Blueprints with the more efficient C++ code hidden out of sight. </span><span class="koboSpan" id="kobo.244.3">To facilitate this construction, Unreal gives us </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">Property Specifiers</span></strong><span class="koboSpan" id="kobo.246.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">Function Specifiers</span></strong><span class="koboSpan" id="kobo.248.1"> to define how signals will </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">punch through.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.250.1">Property Specifiers</span></h2>
<p><span class="koboSpan" id="kobo.251.1">Property Specifiers define characteristics of C++-defined variables when viewed and accessed in the Blueprint layer. </span><span class="koboSpan" id="kobo.251.2">The </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.252.1">Unreal docs provide a handy table explaining the different levels of security afforded by each, along with some more specific ones designed for</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.253.1"> events, collections, and replication over networks (</span><a href="https://docs.unrealengine.com/5.0/en-US/unreal-engine-uproperties/"><span class="koboSpan" id="kobo.254.1">https://docs.unrealengine.com/5.0/en-US/unreal-engine-uproperties/</span></a><span class="koboSpan" id="kobo.255.1">). </span><span class="koboSpan" id="kobo.255.2">The six Display Property Specifiers most commonly used are </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.258.1"> – The value will be changeable in all class defaults and instance detail panels. </span><span class="koboSpan" id="kobo.258.2">This specifier is generally used while prototyping as it displays the variable in most places, with the most options for changing its value. </span><span class="koboSpan" id="kobo.258.3">However, security is the price paid for this flexibility, allowing any designer to change the default and instance values, and so access should be restricted down to what you actually need once a system is tested </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">as working.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">EditDefaultsOnly</span></strong><span class="koboSpan" id="kobo.261.1"> – The value will only be changeable in class defaults. </span><span class="koboSpan" id="kobo.261.2">Useful when a variable needs to be changed for balancing and all instances are spawned at runtime, where you wouldn’t have access to instance detail panels anyway. </span><span class="koboSpan" id="kobo.261.3">Can also be used to ensure no spawned instance has a rogue different value if necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">for execution.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">EditInstanceOnly</span></strong><span class="koboSpan" id="kobo.264.1"> – The value will only be changeable in instance detail panels. </span><span class="koboSpan" id="kobo.264.2">Useful for allowing designers different values on bespoke placed actors in a scene but restricting the</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.265.1"> default value to something that is tested </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">as working.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">VisibleAnywhere</span></strong><span class="koboSpan" id="kobo.268.1"> – The value will be visible in all class defaults and instance detail panels, with no option for changing it from the Editor. </span><span class="koboSpan" id="kobo.268.2">This is useful for debugging how the initialization process affects a value when it is unknown if the code is generally wrong or </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.269.1">wrong at an edge case. </span><span class="koboSpan" id="kobo.269.2">The latter will show incorrect values at the instance level, whereas the former will be wrong at </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">both levels.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">VisibleInstanceOnly</span></strong><span class="koboSpan" id="kobo.272.1"> – The value will only be visible in instance detail panels. </span><span class="koboSpan" id="kobo.272.2">Useful for surface-level debugging of values in each instance without cluttering the screen with debug messages when you have a large number of </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">instances spawned.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">VisibleDefaultsOnly</span></strong><span class="koboSpan" id="kobo.275.1"> – The value will only be visible in class defaults. </span><span class="koboSpan" id="kobo.275.2">Useful for designers to reference what a functional value is and create a parity in the visual elements of an actor. </span><span class="koboSpan" id="kobo.275.3">This is the highest security level as each actor will display the starting value in </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">one place.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.277.1">There are two access specifiers we need to pay attention to for now: </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">BlueprintReadOnly</span></strong><span class="koboSpan" id="kobo.279.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">BlueprintReadWrite</span></strong><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">They give child Blueprint-based classes access to either just the getter or both getter and setter in </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">their graphs.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.283.1">Function Specifiers</span></h2>
<p><span class="koboSpan" id="kobo.284.1">Function Specifiers work similarly to Property </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.285.1">Specifiers, defining how functions should be </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.286.1">seen and accessed by the Blueprint layer, with some subtleties to their usage. </span><span class="koboSpan" id="kobo.286.2">You can find a full list of Function Specifiers in the Unreal docs (</span><a href="https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/"><span class="koboSpan" id="kobo.287.1">https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/</span></a><span class="koboSpan" id="kobo.288.1">), but the three we are interested in are </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">detailed next:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">BlueprintCallable</span></strong><span class="koboSpan" id="kobo.291.1"> – As the name suggests, Blueprint classes can call this function if it is in a parent class and it has the correct encapsulation type (public </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">or protected).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">BlueprintImplementableEvent</span></strong><span class="koboSpan" id="kobo.294.1"> – The stub for this function signature is defined in C++ without any implementation. </span><span class="koboSpan" id="kobo.294.2">This allows C++ systems to call it and Blueprint systems to fill out its actual body. </span><span class="koboSpan" id="kobo.294.3">You might use this for triggering visual effects like a laser beam on a gun when it </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">is fired.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">BlueprintNativeEvent</span></strong><span class="koboSpan" id="kobo.297.1"> – This allows C++ to define a function that is filled out in Blueprint, but in this </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.298.1">case, there can also be a </span><em class="italic"><span class="koboSpan" id="kobo.299.1">default</span></em><span class="koboSpan" id="kobo.300.1"> implementation, which will also be run. </span><span class="koboSpan" id="kobo.300.2">Unreal achieves this by generating two more function definitions for you: </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">*_Implementation()</span></strong><span class="koboSpan" id="kobo.302.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Execute_*()</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">The</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.305.1"> former is used for the C++ side that must be run, and the latter is the function that must be called in C++ to fire </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">both implementations.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.307.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.308.1">As with layering, the C++ side of </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">BlueprintNativeEvents</span></strong><span class="koboSpan" id="kobo.310.1"> will execute before the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">Blueprint side.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">Using Property and Function Specifiers, we can make systems that cross the Fuzzy layer, but almost as important as routing function signals is designing inheritance hierarchies that smooth </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">this process.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.314.1">Useful inheritance</span></h2>
<p><span class="koboSpan" id="kobo.315.1">As standard practice, it is best to make sure that anything instanced in your world is a Blueprint class. </span><span class="koboSpan" id="kobo.315.2">This helps with debugging</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.316.1"> and linking classes with references as you have all the visual tools built into the Editor for tracing executions, and if classes are renamed or if they move directories, then links are live instead of text-based, </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">preventing crashes.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">To make this inheritance strategy work, it is recommended you think about your system from an abstract gameplay point of view. </span><span class="koboSpan" id="kobo.318.2">Which classes affect the mechanics? </span><span class="koboSpan" id="kobo.318.3">These classes need to have a C++ representation for efficiency, and so a hierarchy can be designed. </span><span class="koboSpan" id="kobo.318.4">From there, we inherit Blueprint classes from the end of each branch. </span><span class="koboSpan" id="kobo.318.5">This gives us the Blueprint classes to link, create instances of, and add visual </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">components to:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.320.1"><img alt="Figure 1.6 – Example hierarchy for a weapon mechanic that includes both Projectile and HitScan mechanic types" src="image/B18297_01_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">Figure 1.6 – Example hierarchy for a weapon mechanic that includes both Projectile and HitScan mechanic types</span></p>
<p><span class="koboSpan" id="kobo.322.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.323.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.324.1">.6</span></em><span class="koboSpan" id="kobo.325.1">, the C++ classes would contain all the logic for ammo, damaging actors, interaction handling, and so on. </span><span class="koboSpan" id="kobo.325.2">Then, in the</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.326.1"> Blueprint classes, components to display the mesh, run the kickback animations, and display the muzzle flash would be added. </span><span class="koboSpan" id="kobo.326.2">There would most likely be a function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Weapon</span></strong><span class="koboSpan" id="kobo.328.1"> parent class called from somewhere in the firing logic that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
UFUNCTION(BlueprintImplementableEvent)
void Fire_Visuals();</span></pre> <p><span class="koboSpan" id="kobo.331.1">This could then be implemented in the Blueprint classes to trigger visual effects. </span><span class="koboSpan" id="kobo.331.2">Using some of the patterns we will cover later, namely the type object pattern, you can create a vast array of weapons from these few classes with some simple asset and variable changes. </span><span class="koboSpan" id="kobo.331.3">This shows how the artist, designer, and programmer can all work together on one system without getting in each other’s way while still benefitting from the efficiency gain </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">in C++.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">In theory, this process is perfect, but theory rarely translates to the real world. </span><span class="koboSpan" id="kobo.333.2">A lot of dev time is usually spent working</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.334.1"> out how to do something based on forum posts, documentation, and videos. </span><span class="koboSpan" id="kobo.334.2">It’s great that these resources exist; almost every problem you come across has likely been solved by someone else, but there is no guarantee they have been developed with the same practice. </span><span class="koboSpan" id="kobo.334.3">You will come across a situation where the fix you need is in a Blueprint tutorial/example and your system needs it to be in C++, so let’s have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">translation process.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.336.1">Translating back from Blueprint to C++</span></h1>
<p><span class="koboSpan" id="kobo.337.1">Equipping yourself with tools to translate back from Blueprint to C++ is the smart thing to do, not only for the everyday fixes as mentioned previously, but also for the triple-A setting in a large company. </span><span class="koboSpan" id="kobo.337.2">A typical</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.338.1"> Unreal mechanics development</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.339.1"> pipeline at a large studio might follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">following process:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.341.1">A designer has an idea for a mechanic and is given time to prototype it in Blueprint </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.342.1">as a </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">proof </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.344.1">of concept</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.346.1">This mechanic is tested to see if it should be </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">developed further.</span></span></li>
<li><span class="koboSpan" id="kobo.348.1">If it receives a green light, it will be a programmer’s job to convert the prototype into a more robust </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">C++ system.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.350.1">We’ve covered the tools for designing C++ systems to work with Blueprint effectively, but when faced with the aforementioned situation, how do you take another person’s vision and translate it into something that works efficiently yet doesn’t lose what made it good? </span><span class="koboSpan" id="kobo.350.2">Well, the obvious answer is to directly translate it. </span><span class="koboSpan" id="kobo.350.3">Node for node. </span><span class="koboSpan" id="kobo.350.4">That process is easy, as nodes in Blueprint are quite literally just C++ functions that you have to find in the engine source. </span><span class="koboSpan" id="kobo.350.5">Let’s take a </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">closer look:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.352.1">The first step is to hover the mouse over the node. </span><span class="koboSpan" id="kobo.352.2">Every node has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Target</span></strong><span class="koboSpan" id="kobo.354.1"> class, and mousing over will tell you what </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">that is.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">Next, we go to the Unreal Engine docs (</span><a href="https://www.unrealengine.com/en-US/bing-search?"><span class="koboSpan" id="kobo.357.1">https://www.unrealengine.com/en-US/bing-search?</span></a><span class="koboSpan" id="kobo.358.1">) and search for </span><em class="italic"><span class="koboSpan" id="kobo.359.1">U&lt; Target class name&gt;::&lt;Node name with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">no spaces&gt;</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">The Unreal docs page for the </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.363.1">function is likely to be bare, but it will give you the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">#include</span></strong><span class="koboSpan" id="kobo.365.1"> directory</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.366.1"> for the file header containing that function. </span><span class="koboSpan" id="kobo.366.2">Once a class has been included, it can be used and explored via autocompleting a </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">dot accessor.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.368.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.369.1">If the target is </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Actor</span></strong><span class="koboSpan" id="kobo.371.1">, then it will have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">A</span></strong><span class="koboSpan" id="kobo.373.1"> instead of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">U</span></strong><span class="koboSpan" id="kobo.375.1"> at the beginning, as shown in the example in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.376.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.377.1">.7</span></em><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">This is one of the oddities of UE5; each time there is one, it will be mentioned in a box </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">like this.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.380.1"><img alt="Figure 1.7 – Showing the process from node to Unreal C++ documentation" src="image/B18297_01_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.381.1">Figure 1.7 – Showing the process from node to Unreal C++ documentation</span></p>
<p><span class="koboSpan" id="kobo.382.1">This process may seem tedious but after </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.383.1">a while of searching different things, you will start to see patterns and </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.384.1">be able to work out where functions are likely to be. </span><span class="koboSpan" id="kobo.384.2">Each node with an execution pin (the white arrow) then becomes one line of code with input pins forming the function arguments, and output pins are generally the return type (multiple of which would form </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">a struct).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.386.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.387.1">Reading through the following headers will be useful for mastering the translation process as they are the most frequently used: </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">AActor.h</span></strong><span class="koboSpan" id="kobo.389.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">UGameplayStatics.h</span></strong><span class="koboSpan" id="kobo.391.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">UkismetSystemLibrary.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">The next question is, how do you know where to leave the line between C++ and Blueprints? </span><span class="koboSpan" id="kobo.395.2">Theoretically, you could</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.396.1"> make everything in C++, but as we’ve already shown, that is not a </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.397.1">good idea for teamworking reasons. </span><span class="koboSpan" id="kobo.397.2">The answer has already been hinted at, but generally, you want everything visual or not to do with the gameplay mechanics  to be Blueprint-based. </span><span class="koboSpan" id="kobo.397.3">Where that line exactly sits is up to interpretation and not worth </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">agonizing over.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.399.1">Worked example</span></h2>
<p><span class="koboSpan" id="kobo.400.1">To cement this theory, let’s work through an example. </span><span class="koboSpan" id="kobo.400.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.401.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.402.1">.8</span></em><span class="koboSpan" id="kobo.403.1">, you can see an example Blueprint system</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.404.1"> designed to increment an integer when it is overlapped by a projectile; then, once it reaches 10 overlaps, it will play a sound and unhide a </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">particle effect:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.406.1"><img alt="Figure 1.8 – A series of Blueprint nodes in a basic function; this piece of Blueprint has been arranged using a reroute node for readability but would normally be laid out more linearly" src="image/B18297_01_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.407.1">Figure 1.8 – A series of Blueprint nodes in a basic function; this piece of Blueprint has been arranged using a reroute node for readability but would normally be laid out more linearly</span></p>
<p><span class="koboSpan" id="kobo.408.1">First, we need a C++ class for this to inherit from, and seeing as it is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">BP_Target</span></strong><span class="koboSpan" id="kobo.410.1">, we can name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Target</span></strong><span class="koboSpan" id="kobo.412.1">. </span><span class="koboSpan" id="kobo.412.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Target</span></strong><span class="koboSpan" id="kobo.414.1"> class will need some variables; we can tell from the event that there is some kind of collision component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">TargetCollision</span></strong><span class="koboSpan" id="kobo.416.1">, which has its overlap event bound to this function. </span><span class="koboSpan" id="kobo.416.2">As a component, it needs to be stored in a pointer; otherwise, we would be referencing the class, not an instance. </span><span class="koboSpan" id="kobo.416.3">We also need an integer named </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">TimesHit</span></strong><span class="koboSpan" id="kobo.418.1">. </span><span class="koboSpan" id="kobo.418.2">As discussed prior, mechanics are made by a team of programmers, designers, and artists. </span><span class="koboSpan" id="kobo.418.3">Linking the right particle system for user feedback is a designer’s job, so we’ll leave that as Blueprint for now, but we do need a way to fire the Blueprint side, so a </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">BlueprintImplementableEvent</span></strong><span class="koboSpan" id="kobo.420.1"> will be needed. </span><span class="koboSpan" id="kobo.420.2">With that in mind, the</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.421.1"> header for our new class will look something </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.423.1">Target.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
#pragma once
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Target.generated.h"
class USphereComponent;
UCLASS(Abstract)
class EXAMPLE_API ATarget : public AActor
{
    GENERATED_BODY()
    UPROPERTY(EditDefaultsOnly)
    USphereComponent* _TargetCollision;
    int _TimesHit;
public:
    ATarget();
    UFUNCTION()
    void OnTargetCollisionBeginOverlap(AActor* OtherActor,
        int32 OtherBodyIndex, bool bFromSweep, const
        FHitResult&amp; SweepResult);
    UFUNCTION(BlueprintImplementableEvent)
    Void TenHitVisuals();
};</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.425.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.426.1">Notice how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">UCLASS()</span></strong><span class="koboSpan" id="kobo.428.1"> call includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Abstract</span></strong><span class="koboSpan" id="kobo.430.1"> tag. </span><span class="koboSpan" id="kobo.430.2">This will stop designers from accidentally creating instances of your C++ classes that have not had any visuals </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">set up.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">The next step is to populate</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.433.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">function bodies:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.435.1">Target.cpp</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
#include "Target.h"
#include "Components/SphereComponent.h"
#include "ExampleProjectile.h"
ATarget::ATarget()
{
    _TargetCollision =CreateDefaultSubobject &lt;USphereComponent&gt;
        (TEXT("TargetCollision"));
    _TargetCollision-&gt;SetupAttachment(RootComponent);
    _TargetCollision-&gt;
        OnComponentBeginOverlap.AddDynamic( this,
        &amp;ATarget::OnTargetCollisionBeginOverlap);
    _TimesHit = 0;
}
void ATarget::OnTargetCollisionBeginOverlap
    (UPrimitiveComponent* OverlappedComponent, AActor*
        OtherActor, UPrimitiveComponent* OtherComp, int32
        OtherBodyIndex, bool bFromSweep, const FHitResult&amp;
        SweepResult)
{
    ExampleProjectile* otherProj =
        Cast&lt;AExampleProjectile&gt;(OtherActor);
    if (otherProj != nullptr)
    {
        _TimesHit++;
        if (_TimesHit == 10)
        {
            TenHitVisuals();
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.437.1">The constructor is going to be standard, creating the default sub-object for the collision component and binding the overlap function to that component’s overlap event (</span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">OnTargetCollisionBeginOverlap</span></strong><span class="koboSpan" id="kobo.439.1">). </span><span class="koboSpan" id="kobo.439.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">overlap</span></strong><span class="koboSpan" id="kobo.441.1"> function, the cast node becomes a cast to a temporary “cache” variable with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">if</span></strong><span class="koboSpan" id="kobo.443.1"> statement to check its value against </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">nullptr</span></strong><span class="koboSpan" id="kobo.445.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">_TimesHit</span></strong><span class="koboSpan" id="kobo.447.1"> can then </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.448.1">post increment, and the branch converts to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">if</span></strong><span class="koboSpan" id="kobo.450.1"> statement which, if passed, will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">BlueprintImplementableEvent</span></strong><span class="koboSpan" id="kobo.452.1"> to pass the signal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Blueprint</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.454.1">child class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.455.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.456.1">You are not required to build this example; it is here for </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">reference only.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">There will be plenty more examples of Blueprint to C++ conversion throughout the rest of this book, but if you would like to see some first-party examples, the template projects created by Epic can be loaded in both C++ and </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">Blueprint versions.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.460.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.461.1">In this chapter, we have discussed what Unreal Engine 5 is and how to get it set up with a useful development environment. </span><span class="koboSpan" id="kobo.461.2">We also defined some of the key terms and tools we will be using in later chapters and shared a best practice strategy for </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">building mechanics.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Lastly, we showed the process of translating from other practices to our new </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">best practice.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">This forms the foundation for designing well-structured systems. </span><span class="koboSpan" id="kobo.465.2">At this point, you should be able to at least plan mechanics for your game and implement something that utilizes both C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">and Blueprint.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">In the next chapter, we will cover the process of optimizing a bad project by implementing some of the patterns we will see later in the book. </span><span class="koboSpan" id="kobo.467.2">This should give you an understanding of why design patterns are useful before we jump into a deep dive of </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">each one.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Let’s end the chapter by answering a few questions to test our knowledge and cement some of these practices covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">the chapter.</span></span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.471.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.472.1">Which one of these describes the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">BlueprintNativeEvent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">?</span></span><ol><li class="Alphabets"><span class="koboSpan" id="kobo.476.1">A function that can be described </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">in Blueprint.</span></span></li><li class="Alphabets"><span class="koboSpan" id="kobo.478.1">A function defined in C++ with both C++ and </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">Blueprint implementations.</span></span></li><li class="Alphabets"><span class="koboSpan" id="kobo.480.1">An event declared in C++ but used in Blueprint with an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Execute</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.482.1"> function.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.483.1">How does </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">Nanite work?</span></span><ol><li class="Alphabets"><span class="No-Break"><span class="koboSpan" id="kobo.485.1">Magic</span></span></li><li class="Alphabets"><span class="koboSpan" id="kobo.486.1">Mesh </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">distance formulas</span></span></li><li class="Alphabets"><span class="koboSpan" id="kobo.488.1">Sub-mesh </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.489.1">LOD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1"> groups</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.491.1">Which one of these is not a </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">Property Specifier?</span></span><ol><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">BlueprintWriteOnly</span></strong></span></li><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">EditInstanceOnly</span></strong></span></li><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">VisibleAnywhere</span></strong></span></li></ol></li>
<li><span class="koboSpan" id="kobo.496.1">Which base class adds an </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">A</span></strong><span class="koboSpan" id="kobo.498.1"> to the start of each of its children </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">in C++?</span></span><ol><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">GameplayStatics</span></strong></span></li><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Actor</span></strong></span></li><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">ActorComponents</span></strong></span></li></ol></li>
<li><span class="koboSpan" id="kobo.503.1">All C++ functions should be marked as which of </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">the following?</span></span><ol><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">BuildOnly</span></strong></span></li><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Pure</span></strong></span></li><li class="Alphabets"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Abstract</span></strong></span></li></ol></li>
</ol>
<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.508.1">Answers</span></h2>
<ol>
<li value="1"><span class="koboSpan" id="kobo.509.1">B</span></li>
<li><span class="koboSpan" id="kobo.510.1">C</span></li>
<li><span class="koboSpan" id="kobo.511.1">A</span></li>
<li><span class="koboSpan" id="kobo.512.1">B</span></li>
<li><span class="koboSpan" id="kobo.513.1">C</span></li>
</ol>
</div>
</body></html>