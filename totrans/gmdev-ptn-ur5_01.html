<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-17"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Understanding Unreal Engine 5 and its Layers</h1>
<p>Design patterns are a series of tools and practices by which we can learn to write faster and easier-to-work-with code.</p>
<p>Applying design patterns to projects developed in <strong class="bold">Unreal Engine 5</strong> (<strong class="bold">UE5</strong>) will allow you to make your projects more performant, easier to read, and build upon, as well as develop an improved understanding of how the engine works.</p>
<p>We’re going to begin by developing an understanding of the history of Unreal Engine and ensuring that we are all set up to work with the engine, covering some basic ideas of how C++ and Unreal Engine’s visual scripting language, <strong class="bold">Blueprint</strong>, are linked.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Introducing Unreal Engine 5</li>
<li>Installing Unreal Engine 5 and preparing your development environment</li>
<li>The “Fuzzy” layer – bridging the gap from C++ to Blueprint</li>
<li>Translating back from Blueprint to C++</li>
</ul>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>Before embarking on this journey of discovery, know that this book will assume some working knowledge of C++ syntax and the Unreal Engine Editor. Familiarity with pointers and how to follow code in your chosen <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) will be key to understanding the Unreal core API.</p>
<p>You will require the following software:</p>
<ul>
<li>Unreal Engine 5 (this book has been written with version 5.0.3).</li>
<li><strong class="bold">Visual Studio</strong> is a decent free IDE (basic support for the engine is present, meaning projects may show errors and <em class="italic">IntelliSense</em> may not auto-complete some keywords, but the project will compile and run).</li>
<li>If you have access, JetBrains Rider version 2022 or later has built-in support for Unreal Engine, which will make the development process a lot easier. Rider is an alternative IDE to Visual Studio that is often preferred among programmers working with Unreal. It offers improved support for working with C++ in Unreal Engine, including auto-complete. You can learn more about it by visiting <a href="https://www.jetbrains.com/lp/rider-unreal/">https://www.jetbrains.com/lp/rider-unreal/</a>.</li>
</ul>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Introducing Unreal Engine 5</h1>
<p>Unreal Engine 5, or Unreal for <a id="_idIndexMarker000"/>short, is a game engine developed by <em class="italic">Epic Games</em>. Unreal, as with any other game engine at its core, simply processes data from files and instructions into data that you can see on the screen. The suite of tools provided are designed to assist you in creative and predictable tasks. Having been created for you by elite programmers and designers, it is like outsourcing your development to the big leagues.</p>
<p>However, like a high-performance racing car driven by a learner, even the best tools can perform badly. The experts at Epic didn’t know how you would use their tools. So, when we design our code architecture, we need to keep this break in communications in mind. This is where this book comes in, teaching the expected best practices when writing games in Unreal Engine 5.</p>
<p>Unreal Engine has powered an impressive list of gaming titles covering a vast array of genres, shipping on a multitude of platforms.</p>
<p>Unreal Engine 3 powered some of the biggest hits from the seventh generation of game consoles, ranging from third-person shooter games <a id="_idIndexMarker001"/>such as the <em class="italic">Gears of War</em> series developed by <em class="italic">Epic Games</em> themselves to fighting games such as <em class="italic">Injustice: Gods Among Us</em> and <em class="italic">Mortal Kombat</em> from <em class="italic">NetherRealm</em>, as well as strategy games including the <em class="italic">XCOM</em> series developed by <em class="italic">Firaxis Games</em>.</p>
<p>The eighth generation of consoles saw Unreal Engine 4 expand its portfolio to include racing titles such as the <em class="italic">MotoGP</em> games from <em class="italic">Milestone</em> and <em class="italic">Assetto Corsa Competizione</em> from <em class="italic">Kunos Simulazioni</em>, as well as facilitating the hugely popular introduction of the Battle Royale genre with <em class="italic">PlayerUnknowns’ Battlegrounds</em> (<em class="italic">PUBG Studios</em>), which is listed as the fifth highest-selling video game on <em class="italic">Wikipedia</em>, and <em class="italic">Epic Games</em>’ <em class="italic">Fortnite</em>, which transitioned to Unreal Engine 5 in December 2021 as detailed in <a href="B18297_03.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>.</p>
<p>Unreal Engine 5 features a series of new, key technologies, including <em class="italic">Nanite</em>, a sub-mesh level of detail system allowing massive polycount models to render with even screen-space hull size at any distance, and <em class="italic">Lumen</em>, a real-time lighting solution that mixes mesh distance fields and atlassed local surface data progressively over time to create a realistic lighting effect at low cost. These new technologies drove the transition from 4.26/4.27 to 5.0 as part of a complete rework of Unreal’s rendering technology. The engine had an impactful debut with the release of <em class="italic">The Matrix Awakens: An Unreal Engine Experience</em>, a<a id="_idIndexMarker002"/> demo featuring photorealistic likenesses of Carrie-Anne Moss and Keanu Reeves, and an open-world city featuring impressive examples of crowd and traffic simulations.</p>
<p>Increasingly, games studios are opting to replace proprietary in-house developed game engines with Unreal Engine 5; studios such as <em class="italic">CD Projekt Red</em> (<em class="italic">The Witcher</em>) and <em class="italic">Crystal Dynamics</em> (<em class="italic">Tomb Raider</em>) have announced the decision to use Unreal Engine 5 in the latest installments of their game series.</p>
<p>Now that we’ve covered a little about Unreal Engine’s past, pedigree, and influence on gaming history, we will get things set up next so that you are ready to use Unreal Engine 5 with C++.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Installing Unreal Engine 5 and preparing your development environment</h1>
<p>Unreal Engine can be downloaded either via the Epic <a id="_idIndexMarker003"/>Games Launcher (available from https://unrealengine.com, which will install the engine for you) or as<a id="_idIndexMarker004"/> source code from GitHub (www.github.com/EpicGames), allowing users to compile the engine and modify it to fit their projects.</p>
<p>To engage with the activities in this book, you won’t need to compile the engine from source unless you really want to. The benefits of compiling from source will likely come much later into your journey of working with Unreal Engine and C++. You will, however, need to install version 5.0.3 (or above) of the engine and have an IDE installed. This section covers the download, installation, and setup of the engine from scratch using the Unreal Launcher and installation of Visual Studio 2022 Community. If you already have the engine and Visual Studio installed, you can skip over this section.</p>
<p>Firstly, you will need to download <a id="_idIndexMarker005"/>the Launcher from <a href="https://unrealengine.com">https://unrealengine.com</a> by clicking the <strong class="bold">Download</strong> button in the top-right corner of the page and clicking the <strong class="bold">Download Launcher</strong> button on the following page.</p>
<p>Once downloaded, you will need to install the Launcher from the <code>.</code><code>msi</code><em class="italic"> </em>installer.</p>
<p>The Launcher is home to the Epic Games Store, your library of purchased and downloaded games as well as versions of Unreal Engine (4 and above). You will need to navigate to <strong class="bold">Unreal Engine</strong> and then <strong class="bold">Library</strong>, then click the <em class="italic">yellow plus icon</em> and select your engine version from the resulting engine slot:</p>
<div><div><img alt="Figure 1.1 – The default Epic Games Launcher with no versions of the engine installed" src="img/B18297_01_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The default Epic Games Launcher with no versions of the engine installed</p>
<p>Alternatively, if you don’t have any versions of the engine installed, you can click the <em class="italic">yellow drop-down button</em> in the top right of the Launcher application.</p>
<p>Both approaches will present you with the option of where you would like to install the engine. It is advisable to install the <a id="_idIndexMarker006"/>engine on an SSD if possible as the engine will load significantly quicker than from an HDD:</p>
<div><div><img alt="Figure 1.2 – Install location options" src="img/B18297_01_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Install location options</p>
<p>Clicking the <strong class="bold">Options</strong> button will present you with a series of optional elements for installing the engine:</p>
<div><div><img alt="Figure 1.3 – Installation options for Unreal Engine 5.0.3" src="img/B18297_01_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Installation options for Unreal Engine 5.0.3</p>
<p>We advise installing <strong class="bold">Starter Content</strong>, <strong class="bold">Templates and Feature Packs</strong>, and <strong class="bold">Engine Source</strong>.</p>
<p><strong class="bold">Engine Source</strong> will make browsing and debugging code easier but does not allow you to rebuild the engine; for that functionality, you will need to download the source from GitHub, as mentioned earlier.</p>
<p><strong class="bold">Editor symbols for debugging</strong> allows the debugging of C++ in the Editor. This is not required but will prove useful to facilitate jumping from the Editor to engine code and allow you to explore the code behind Blueprint nodes.</p>
<p>If you decide you want to add/remove <a id="_idIndexMarker007"/>elements later, you can modify these choices by clicking the <em class="italic">down arrow</em> next to <strong class="bold">Launch</strong> on the engine slot and selecting <strong class="bold">Options</strong>:</p>
<div><div><img alt="Figure 1.4 – Location of the Options menu on an engine slot" src="img/B18297_01_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Location of the Options menu on an engine slot</p>
<p>Enable the checkbox next to <strong class="bold">Editor symbols for debugging</strong> and click <strong class="bold">Apply</strong>.</p>
<p>Once you have the engine installed, you can move on to installing Visual Studio.</p>
<p>You will need to download the Visual Studio installer from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>When you run the installer, select the <strong class="bold">Game Development with C++</strong> preset in the <strong class="bold">Workloads</strong> tab and select optional components, as shown in <em class="italic">Figure 1</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 1.5 – Suggested installation options for Visual Studio Community 2022" src="img/B18297_01_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Suggested installation options for Visual Studio Community 2022</p>
<p>Once you have Visual<a id="_idIndexMarker008"/> Studio installed, you should be ready to go. If you <a id="_idIndexMarker009"/>want to further improve your experience of working in Visual Studio with Unreal Engine 5.0.X, you can find some additional guidance from <em class="italic">Epic</em> at <a href="https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/">https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/</a>.</p>
<p>Now that we’ve installed the engine and set up our IDE, we can start exploring the link between C++ code and Blueprint.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/>The “Fuzzy” layer – bridging the gap from C++ to Blueprint</h1>
<p>Most engines work on the concept of layers. Each layer has a specific job to do, and when stacked in the correct order, they simplify the development and maintenance of an engine. For example, if a new graphics language emerges that it would be wise to support, only the layer with the graphics pipeline needs to be changed.</p>
<p>There is no hard and fast rule for the number or breakdown of layers in an engine, but what you will generally find is a <a id="_idIndexMarker010"/>separation that resembles <em class="italic">Table 1.1</em>:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Tool</strong></p>
<p>Full of Editor functions that speed up standard tasks. This suite is generally what an engine is marketed on.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Gameplay</strong></p>
<p>All of the custom systems created to facilitate interaction mechanics that will be bespoke in the built game.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Function</strong></p>
<p>Where all automatic internal systems are handled like input capture and physics processing, etc.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Resource</strong></p>
<p>Memory management and asset streaming are handled here.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Platform</strong></p>
<p>Essentially, the graphics pipeline definition and build platform native integrations if the engine supports it.</p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Base</strong></p>
<p>Full of core dependency libraries such as UI frameworks for the Editor and math libraries.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – Common engine layers and their uses</p>
<p>Although Unreal may not explicitly label its layers in this way, we can see them in action in the relationship between how Unreal processes C++ and Blueprint gameplay. Functions created with certain specifiers in C++ can be accessed in Blueprint, but the reverse is not true. This shows there is an order to our actions where signals can only be passed one way. We’ll refer to this internal separation between gameplay layers as the <em class="italic">Fuzzy layer</em>.</p>
<p>The fact that the Fuzzy layer exists<a id="_idIndexMarker011"/> places a limitation on how we design our systems, but in turn, we gain a separation that enables gameplay programmers to work alongside designers with little friction. Systems can be developed for simple creative use within accessible Blueprints with the more efficient C++ code hidden out of sight. To facilitate this construction, Unreal gives us <strong class="bold">Property Specifiers</strong> and <strong class="bold">Function Specifiers</strong> to define how signals will punch through.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Property Specifiers</h2>
<p>Property Specifiers define characteristics of C++-defined variables when viewed and accessed in the Blueprint layer. The <a id="_idIndexMarker012"/>Unreal docs provide a handy table explaining the different levels of security afforded by each, along with some more specific ones designed for<a id="_idIndexMarker013"/> events, collections, and replication over networks (<a href="https://docs.unrealengine.com/5.0/en-US/unreal-engine-uproperties/">https://docs.unrealengine.com/5.0/en-US/unreal-engine-uproperties/</a>). The six Display Property Specifiers most commonly used are as follows:</p>
<ul>
<li><code>EditAnywhere</code> – The value will be changeable in all class defaults and instance detail panels. This specifier is generally used while prototyping as it displays the variable in most places, with the most options for changing its value. However, security is the price paid for this flexibility, allowing any designer to change the default and instance values, and so access should be restricted down to what you actually need once a system is tested as working.</li>
<li><code>EditDefaultsOnly</code> – The value will only be changeable in class defaults. Useful when a variable needs to be changed for balancing and all instances are spawned at runtime, where you wouldn’t have access to instance detail panels anyway. Can also be used to ensure no spawned instance has a rogue different value if necessary for execution.</li>
<li><code>EditInstanceOnly</code> – The value will only be changeable in instance detail panels. Useful for allowing designers different values on bespoke placed actors in a scene but restricting the<a id="_idIndexMarker014"/> default value to something that is tested as working.</li>
<li><code>VisibleAnywhere</code> – The value will be visible in all class defaults and instance detail panels, with no option for changing it from the Editor. This is useful for debugging how the initialization process affects a value when it is unknown if the code is generally wrong or <a id="_idIndexMarker015"/>wrong at an edge case. The latter will show incorrect values at the instance level, whereas the former will be wrong at both levels.</li>
<li><code>VisibleInstanceOnly</code> – The value will only be visible in instance detail panels. Useful for surface-level debugging of values in each instance without cluttering the screen with debug messages when you have a large number of instances spawned.</li>
<li><code>VisibleDefaultsOnly</code> – The value will only be visible in class defaults. Useful for designers to reference what a functional value is and create a parity in the visual elements of an actor. This is the highest security level as each actor will display the starting value in one place.</li>
</ul>
<p>There are two access specifiers we need to pay attention to for now: <code>BlueprintReadOnly</code> and <code>BlueprintReadWrite</code>. They give child Blueprint-based classes access to either just the getter or both getter and setter in their graphs.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Function Specifiers</h2>
<p>Function Specifiers work similarly to Property <a id="_idIndexMarker016"/>Specifiers, defining how functions should be <a id="_idIndexMarker017"/>seen and accessed by the Blueprint layer, with some subtleties to their usage. You can find a full list of Function Specifiers in the Unreal docs (<a href="https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/">https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/</a>), but the three we are interested in are detailed next:</p>
<ul>
<li><code>BlueprintCallable</code> – As the name suggests, Blueprint classes can call this function if it is in a parent class and it has the correct encapsulation type (public or protected).</li>
<li><code>BlueprintImplementableEvent</code> – The stub for this function signature is defined in C++ without any implementation. This allows C++ systems to call it and Blueprint systems to fill out its actual body. You might use this for triggering visual effects like a laser beam on a gun when it is fired.</li>
<li><code>BlueprintNativeEvent</code> – This allows C++ to define a function that is filled out in Blueprint, but in this <a id="_idIndexMarker018"/>case, there can also be a <em class="italic">default</em> implementation, which will also be run. Unreal achieves this by generating two more function definitions for you: <code>*_Implementation()</code> and <code>Execute_*()</code>. The<a id="_idIndexMarker019"/> former is used for the C++ side that must be run, and the latter is the function that must be called in C++ to fire both implementations.</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">As with layering, the C++ side of <code>BlueprintNativeEvents</code> will execute before the Blueprint side.</p>
<p>Using Property and Function Specifiers, we can make systems that cross the Fuzzy layer, but almost as important as routing function signals is designing inheritance hierarchies that smooth this process.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Useful inheritance</h2>
<p>As standard practice, it is best to make sure that anything instanced in your world is a Blueprint class. This helps with debugging<a id="_idIndexMarker020"/> and linking classes with references as you have all the visual tools built into the Editor for tracing executions, and if classes are renamed or if they move directories, then links are live instead of text-based, preventing crashes.</p>
<p>To make this inheritance strategy work, it is recommended you think about your system from an abstract gameplay point of view. Which classes affect the mechanics? These classes need to have a C++ representation for efficiency, and so a hierarchy can be designed. From there, we inherit Blueprint classes from the end of each branch. This gives us the Blueprint classes to link, create instances of, and add visual components to:</p>
<div><div><img alt="Figure 1.6 – Example hierarchy for a weapon mechanic that includes both Projectile and HitScan mechanic types" src="img/B18297_01_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Example hierarchy for a weapon mechanic that includes both Projectile and HitScan mechanic types</p>
<p>In <em class="italic">Figure 1</em><em class="italic">.6</em>, the C++ classes would contain all the logic for ammo, damaging actors, interaction handling, and so on. Then, in the<a id="_idIndexMarker021"/> Blueprint classes, components to display the mesh, run the kickback animations, and display the muzzle flash would be added. There would most likely be a function in the <code>Weapon</code> parent class called from somewhere in the firing logic that looks like this:</p>
<pre class="source-code">
UFUNCTION(BlueprintImplementableEvent)
void Fire_Visuals();</pre> <p>This could then be implemented in the Blueprint classes to trigger visual effects. Using some of the patterns we will cover later, namely the type object pattern, you can create a vast array of weapons from these few classes with some simple asset and variable changes. This shows how the artist, designer, and programmer can all work together on one system without getting in each other’s way while still benefitting from the efficiency gain in C++.</p>
<p>In theory, this process is perfect, but theory rarely translates to the real world. A lot of dev time is usually spent working<a id="_idIndexMarker022"/> out how to do something based on forum posts, documentation, and videos. It’s great that these resources exist; almost every problem you come across has likely been solved by someone else, but there is no guarantee they have been developed with the same practice. You will come across a situation where the fix you need is in a Blueprint tutorial/example and your system needs it to be in C++, so let’s have a look at the translation process.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>Translating back from Blueprint to C++</h1>
<p>Equipping yourself with tools to translate back from Blueprint to C++ is the smart thing to do, not only for the everyday fixes as mentioned previously, but also for the triple-A setting in a large company. A typical<a id="_idIndexMarker023"/> Unreal mechanics development<a id="_idIndexMarker024"/> pipeline at a large studio might follow the following process:</p>
<ol>
<li>A designer has an idea for a mechanic and is given time to prototype it in Blueprint <a id="_idIndexMarker025"/>as a <strong class="bold">proof </strong><strong class="bold">of concept</strong>.</li>
<li>This mechanic is tested to see if it should be developed further.</li>
<li>If it receives a green light, it will be a programmer’s job to convert the prototype into a more robust C++ system.</li>
</ol>
<p>We’ve covered the tools for designing C++ systems to work with Blueprint effectively, but when faced with the aforementioned situation, how do you take another person’s vision and translate it into something that works efficiently yet doesn’t lose what made it good? Well, the obvious answer is to directly translate it. Node for node. That process is easy, as nodes in Blueprint are quite literally just C++ functions that you have to find in the engine source. Let’s take a closer look:</p>
<ol>
<li>The first step is to hover the mouse over the node. Every node has a <code>Target</code> class, and mousing over will tell you what that is.</li>
<li>Next, we go to the Unreal Engine docs (<a href="https://www.unrealengine.com/en-US/bing-search?">https://www.unrealengine.com/en-US/bing-search?</a>) and search for <em class="italic">U&lt; Target class name&gt;::&lt;Node name with </em><em class="italic">no spaces&gt;</em>.</li>
<li>The Unreal docs page for the <a id="_idIndexMarker026"/>function is likely to be bare, but it will give you the <code>#include</code> directory<a id="_idIndexMarker027"/> for the file header containing that function. Once a class has been included, it can be used and explored via autocompleting a dot accessor.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">If the target is <code>Actor</code>, then it will have an <code>A</code> instead of a <code>U</code> at the beginning, as shown in the example in <em class="italic">Figure 1</em><em class="italic">.7</em>. This is one of the oddities of UE5; each time there is one, it will be mentioned in a box like this.</p>
<div><div><img alt="Figure 1.7 – Showing the process from node to Unreal C++ documentation" src="img/B18297_01_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Showing the process from node to Unreal C++ documentation</p>
<p>This process may seem tedious but after <a id="_idIndexMarker028"/>a while of searching different things, you will start to see patterns and <a id="_idIndexMarker029"/>be able to work out where functions are likely to be. Each node with an execution pin (the white arrow) then becomes one line of code with input pins forming the function arguments, and output pins are generally the return type (multiple of which would form a struct).</p>
<p class="callout-heading">Tip</p>
<p class="callout">Reading through the following headers will be useful for mastering the translation process as they are the most frequently used: <code>AActor.h</code>, <code>UGameplayStatics.h</code>, and <code>UkismetSystemLibrary.h</code>.</p>
<p>The next question is, how do you know where to leave the line between C++ and Blueprints? Theoretically, you could<a id="_idIndexMarker030"/> make everything in C++, but as we’ve already shown, that is not a <a id="_idIndexMarker031"/>good idea for teamworking reasons. The answer has already been hinted at, but generally, you want everything visual or not to do with the gameplay mechanics  to be Blueprint-based. Where that line exactly sits is up to interpretation and not worth agonizing over.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Worked example</h2>
<p>To cement this theory, let’s work through an example. In <em class="italic">Figure 1</em><em class="italic">.8</em>, you can see an example Blueprint system<a id="_idIndexMarker032"/> designed to increment an integer when it is overlapped by a projectile; then, once it reaches 10 overlaps, it will play a sound and unhide a particle effect:</p>
<div><div><img alt="Figure 1.8 – A series of Blueprint nodes in a basic function; this piece of Blueprint has been arranged using a reroute node for readability but would normally be laid out more linearly" src="img/B18297_01_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – A series of Blueprint nodes in a basic function; this piece of Blueprint has been arranged using a reroute node for readability but would normally be laid out more linearly</p>
<p>First, we need a C++ class for this to inherit from, and seeing as it is called <code>BP_Target</code>, we can name it <code>Target</code>. The <code>Target</code> class will need some variables; we can tell from the event that there is some kind of collision component named <code>TargetCollision</code>, which has its overlap event bound to this function. As a component, it needs to be stored in a pointer; otherwise, we would be referencing the class, not an instance. We also need an integer named <code>TimesHit</code>. As discussed prior, mechanics are made by a team of programmers, designers, and artists. Linking the right particle system for user feedback is a designer’s job, so we’ll leave that as Blueprint for now, but we do need a way to fire the Blueprint side, so a <code>BlueprintImplementableEvent</code> will be needed. With that in mind, the<a id="_idIndexMarker033"/> header for our new class will look something like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Target.h</p>
<pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Target.generated.h"
class USphereComponent;
UCLASS(Abstract)
class EXAMPLE_API ATarget : public AActor
{
    GENERATED_BODY()
    UPROPERTY(EditDefaultsOnly)
    USphereComponent* _TargetCollision;
    int _TimesHit;
public:
    ATarget();
    UFUNCTION()
    void OnTargetCollisionBeginOverlap(AActor* OtherActor,
        int32 OtherBodyIndex, bool bFromSweep, const
        FHitResult&amp; SweepResult);
    UFUNCTION(BlueprintImplementableEvent)
    Void TenHitVisuals();
};</pre> <p class="callout-heading">Important note</p>
<p class="callout">Notice how the <code>UCLASS()</code> call includes the <code>Abstract</code> tag. This will stop designers from accidentally creating instances of your C++ classes that have not had any visuals set up.</p>
<p>The next step is to populate<a id="_idIndexMarker034"/> the function bodies:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Target.cpp</p>
<pre class="source-code">
#include "Target.h"
#include "Components/SphereComponent.h"
#include "ExampleProjectile.h"
ATarget::ATarget()
{
    _TargetCollision =CreateDefaultSubobject &lt;USphereComponent&gt;
        (TEXT("TargetCollision"));
    _TargetCollision-&gt;SetupAttachment(RootComponent);
    _TargetCollision-&gt;
        OnComponentBeginOverlap.AddDynamic( this,
        &amp;ATarget::OnTargetCollisionBeginOverlap);
    _TimesHit = 0;
}
void ATarget::OnTargetCollisionBeginOverlap
    (UPrimitiveComponent* OverlappedComponent, AActor*
        OtherActor, UPrimitiveComponent* OtherComp, int32
        OtherBodyIndex, bool bFromSweep, const FHitResult&amp;
        SweepResult)
{
    ExampleProjectile* otherProj =
        Cast&lt;AExampleProjectile&gt;(OtherActor);
    if (otherProj != nullptr)
    {
        _TimesHit++;
        if (_TimesHit == 10)
        {
            TenHitVisuals();
        }
    }
}</pre> <p>The constructor is going to be standard, creating the default sub-object for the collision component and binding the overlap function to that component’s overlap event (<code>OnTargetCollisionBeginOverlap</code>). In the <code>overlap</code> function, the cast node becomes a cast to a temporary “cache” variable with an <code>if</code> statement to check its value against <code>nullptr</code>. <code>_TimesHit</code> can then <a id="_idIndexMarker035"/>post increment, and the branch converts to an <code>if</code> statement which, if passed, will call the <code>BlueprintImplementableEvent</code> to pass the signal to the <code>Blueprint</code> child class.</p>
<p class="callout-heading">Note</p>
<p class="callout">You are not required to build this example; it is here for reference only.</p>
<p>There will be plenty more examples of Blueprint to C++ conversion throughout the rest of this book, but if you would like to see some first-party examples, the template projects created by Epic can be loaded in both C++ and Blueprint versions.</p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Summary</h1>
<p>In this chapter, we have discussed what Unreal Engine 5 is and how to get it set up with a useful development environment. We also defined some of the key terms and tools we will be using in later chapters and shared a best practice strategy for building mechanics.</p>
<p>Lastly, we showed the process of translating from other practices to our new best practice.</p>
<p>This forms the foundation for designing well-structured systems. At this point, you should be able to at least plan mechanics for your game and implement something that utilizes both C++ and Blueprint.</p>
<p>In the next chapter, we will cover the process of optimizing a bad project by implementing some of the patterns we will see later in the book. This should give you an understanding of why design patterns are useful before we jump into a deep dive of each one.</p>
<p>Let’s end the chapter by answering a few questions to test our knowledge and cement some of these practices covered in the chapter.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/>Questions</h1>
<ol>
<li>Which one of these describes the implementation of <code>BlueprintNativeEvent</code>?<ol><li class="Alphabets">A function that can be described in Blueprint.</li><li class="Alphabets">A function defined in C++ with both C++ and Blueprint implementations.</li><li class="Alphabets">An event declared in C++ but used in Blueprint with an <code>Execute</code> function.</li></ol></li>
<li>How does Nanite work?<ol><li class="Alphabets">Magic</li><li class="Alphabets">Mesh distance formulas</li><li class="Alphabets">Sub-mesh <strong class="bold">LOD</strong> groups</li></ol></li>
<li>Which one of these is not a Property Specifier?<ol><li class="Alphabets"><code>BlueprintWriteOnly</code></li><li class="Alphabets"><code>EditInstanceOnly</code></li><li class="Alphabets"><code>VisibleAnywhere</code></li></ol></li>
<li>Which base class adds an <code>A</code> to the start of each of its children in C++?<ol><li class="Alphabets"><code>GameplayStatics</code></li><li class="Alphabets"><code>Actor</code></li><li class="Alphabets"><code>ActorComponents</code></li></ol></li>
<li>All C++ functions should be marked as which of the following?<ol><li class="Alphabets"><code>BuildOnly</code></li><li class="Alphabets"><code>Pure</code></li><li class="Alphabets"><code>Abstract</code></li></ol></li>
</ol>
<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Answers</h2>
<ol>
<li value="1">B</li>
<li>C</li>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
</div>
</body></html>