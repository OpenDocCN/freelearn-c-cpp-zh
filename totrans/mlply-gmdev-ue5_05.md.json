["```cpp\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class USpringArmComponent> CameraBoom;\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class UCameraComponent> FollowCamera;\n```", "```cpp\nvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n```", "```cpp\nFORCEINLINE USpringArmComponent* GetCameraBoom() const { return CameraBoom; }\nFORCEINLINE UCameraComponent* GetFollowCamera() const { return FollowCamera; }\n```", "```cpp\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n```", "```cpp\nCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\nCameraBoom->SetupAttachment(RootComponent);\nCameraBoom->TargetArmLength = 800.0f;\nCameraBoom->bUsePawnControlRotation = true;\n```", "```cpp\nFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\nFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\nFollowCamera->bUsePawnControlRotation = false;\n```", "```cpp\nbUseControllerRotationPitch = false;\nbUseControllerRotationYaw = false;\nbUseControllerRotationRoll = false;\nGetCapsuleComponent()->InitCapsuleSize(60.f, 96.0f);\nGetMesh()->SetRelativeLocation(FVector(0.f, 0.f, -91.f));\nstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/KayKit/Characters/rogue\"));\nif (SkeletalMeshAsset.Succeeded())\n{\n   GetMesh()->SetSkeletalMesh(SkeletalMeshAsset.Object);\n}\nGetCharacterMovement()->bOrientRotationToMovement = true;\nGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);\nGetCharacterMovement()->MaxWalkSpeed = 500.f;\nGetCharacterMovement()->MinAnalogWalkSpeed = 20.f;\nGetCharacterMovement()->BrakingDecelerationWalking = 2000.f;\n```", "```cpp\nPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\" });\n```", "```cpp\nPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"EnhancedInput\" });\n```", "```cpp\nvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n```", "```cpp\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Input\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class UInputMappingContext> DefaultMappingContext;\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Input\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class UInputAction> MoveAction;\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Input\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<UInputAction> LookAction;\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Input\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<UInputAction> SprintAction;\nUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Input\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<UInputAction> InteractAction;\n```", "```cpp\nvoid Move(const struct FInputActionValue& Value);\nvoid Look(const FInputActionValue& Value);\nvoid SprintStart(const FInputActionValue& Value);\nvoid SprintEnd(const FInputActionValue& Value);\nvoid Interact(const FInputActionValue& Value);\n```", "```cpp\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n```", "```cpp\nif (APlayerController* PlayerController = Cast<APlayerController>(Controller))\n{\n   if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n   {\n      Subsystem->AddMappingContext(DefaultMappingContext, 0);\n   }\n}\n```", "```cpp\nif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n{\n   EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AUS_Character::Move);\n   EnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AUS_Character::Look);\n   EnhancedInputComponent->BindAction(InteractAction, ETriggerEvent::Started, this, &AUS_Character::Interact);\n   EnhancedInputComponent->BindAction(SprintAction, ETriggerEvent::Started, this, &AUS_Character::SprintStart);\n   EnhancedInputComponent->BindAction(SprintAction, ETriggerEvent::Completed, this, &AUS_Character::SprintEnd);\n}\n```", "```cpp\nvoid AUS_Character::Move(const FInputActionValue& Value)\n{\n   const auto MovementVector = Value.Get<FVector2D>();\n   GEngine->AddOnScreenDebugMessage(0, 5.f, FColor::Yellow, FString::Printf(TEXT(\"MovementVector: %s\"), *MovementVector.ToString()));\n   if (Controller != nullptr)\n   {\n      const auto Rotation = Controller->GetControlRotation();\n      const FRotator YawRotation(0, Rotation.Yaw, 0);\n      const auto ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n      const auto RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n     AddMovementInput(ForwardDirection, MovementVector.Y);\n      AddMovementInput(RightDirection, MovementVector.X);\n   }\n}\n```", "```cpp\nvoid AUS_Character::Look(const FInputActionValue& Value)\n{\n   const auto LookAxisVector = Value.Get<FVector2D>();\n   GEngine->AddOnScreenDebugMessage(1, 5.f, FColor::Green, FString::Printf(TEXT(\"LookAxisVector: %s\"), *LookAxisVector.ToString()));\n   if (Controller != nullptr)\n   {\n      AddControllerYawInput(LookAxisVector.X);\n      AddControllerPitchInput(LookAxisVector.Y);\n   }\n}\n```", "```cpp\nvoid AUS_Character::SprintStart(const FInputActionValue& Value)\n{\n   GEngine->AddOnScreenDebugMessage(2, 5.f, FColor::Blue, TEXT(\"SprintStart\"));\n   GetCharacterMovement()->MaxWalkSpeed = 3000.f;\n}\nvoid AUS_Character::SprintEnd(const FInputActionValue& Value)\n{\n   GEngine->AddOnScreenDebugMessage(2, 5.f, FColor::Blue, TEXT(\"SprintEnd\"));\n   GetCharacterMovement()->MaxWalkSpeed = 500.f;\n}\n```", "```cpp\nvoid AUS_Character::Interact(const FInputActionValue& Value)\n{\n   GEngine->AddOnScreenDebugMessage(3, 5.f, FColor::Red, TEXT(\"Interact\"));\n}\n```", "```cpp\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\",  meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class USphereComponent> SphereCollision;\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta = (AllowPrivateAccess = \"true\"))\nTObjectPtr<class UStaticMeshComponent> Mesh;\n```", "```cpp\nUFUNCTION()\nvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n```", "```cpp\nUFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = \"Pickup\", meta=(DisplayName=\"Pickup\"))\nvoid Pickup(class AUS_Character* OwningCharacter);\n```", "```cpp\nFORCEINLINE USphereComponent* GetSphereCollision() const { return SphereCollision; }\nFORCEINLINE UStaticMeshComponent* GetMesh() const { return Mesh; }\n```", "```cpp\n#include \"US_Character.h\"\n#include \"Components/SphereComponent.h\"\n```", "```cpp\nSphereCollision = CreateDefaultSubobject<USphereComponent>(\"Collision\");\nRootComponent = SphereCollision;\nSphereCollision->SetGenerateOverlapEvents(true);\nSphereCollision->SetSphereRadius(200.0f);\nMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"Mesh\");\nMesh->SetupAttachment(SphereCollision);\nMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n```", "```cpp\nbReplicates = true;\n```", "```cpp\nSphereCollision->OnComponentBeginOverlap.AddDynamic(this, &AUS_BasePickup::OnBeginOverlap);\n```", "```cpp\nvoid AUS_BasePickup::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n                                    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (const auto Character = Cast<AUS_Character>(OtherActor))\n    {\n        Pickup(Character);\n    }\n}\n```", "```cpp\nvoid AUS_BasePickup::Pickup_Implementation(AUS_Character * OwningCharacter)\n{\n   SetOwner(OwningCharacter);\n}\n```"]