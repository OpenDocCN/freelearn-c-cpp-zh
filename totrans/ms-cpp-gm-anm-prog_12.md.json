["```cpp\nFetchContent_Declare(\n  imnodes\n  GIT_REPOSITORY https://github.com/Nelarius/imnodes\n  GIT_TAG v0.5\n) \n```", "```cpp\nFetchContent_MakeAvailable(imnodes)\nFetchContent_GetProperties(imnodes)\nif(NOT imnodes_POPULATED)\n  FetchContent_Populate(imnodes)\n  add_subdirectory(${imnodes_SOURCE_DIR} EXCLUDE_FROM_ALL)\nendif() \n```", "```cpp\nfile(GLOB SOURCES\n  ...\n  **${imnodes_SOURCE_DIR}****/imnodes.cpp**\n)\n...\n**target_include_directories****(...** **${imnodes_SOURCE_DIR}****)** \n```", "```cpp\nadd_definitions(... -DIMGUI_DEFINE_MATH_OPERATORS) \n```", "```cpp\n ImGui::CreateContext();\n  **ImNodes::****CreateContext****();** \n```", "```cpp\n **ImNodes::****DestroyContext****();**\n  ImGui::DestroyContext(); \n```", "```cpp\n ImGui::StyleColorsLight();\n  ImNodes::StyleColorsLight(); \n```", "```cpp\n ImNodesIO& io = ImNodes::GetIO();\n  io.LinkDetachWithModifierClick.Modifier =\n    &ImGui::GetIO().KeyCtrl; \n```", "```cpp\nImGui::Begin(\"Node editor\");\nImNodes::BeginNodeEditor(); \n```", "```cpp\nImNodes::MiniMap();\nImNodes::EndNodeEditor();\nImGui::End(); \n```", "```cpp\nconst int nodeId = 1;\nImNodes::BeginNode(nodeId);\nImGui::Text(\"Sample Node\");\nImNodes::EndNode(); \n```", "```cpp\nImNodes::BeginNodeTitleBar();\nImGui::TextUnformatted(\"A cool node title\");\nImNodes::EndNodeTitleBar(); \n```", "```cpp\nconst int inputId = 2;\nImNodes::BeginInputAttribute(inputId);\nImGui::Text(\"in\");\nImNodes::EndInputAttribute(); \n```", "```cpp\nconst int staticId = 3;\nstatic bool checkboxState = false;\nImNodes::BeginStaticAttribute(staticId);\nImGui::Checkbox(\"A fancy checkbox\", &checkboxState);\nImNodes::EndStaticAttribute(); \n```", "```cpp\nconst int outId = 4;\nImNodes::BeginOutputAttribute(outId);\nImGui::Text(\"                 out\");\nImNodes::EndOutputAttribute(); \n```", "```cpp\nstd::map<int, std::pair<int, int>> links; \n```", "```cpp\n for (const auto& link : links) {\n    ImNodes::Link(link.first,\n      link.second.first, link.second.second);\n  } \n```", "```cpp\n int startId, endId;\n  if (ImNodes::IsLinkCreated(&startId, &endId)) {\n    linkId = findNextFreeLinkId();\n    links[linkId] = (std::make_pair(startId, endId));\n  } \n```", "```cpp\n int linkId;\n  if (ImNodes::IsLinkDestroyed(&linkId)) {\n    links.erase(linkId);\n} \n```", "```cpp\nvirtual void update(float deltaTime) = 0;\nvirtual void draw(ModelInstanceCamData modInstCamData) = 0;\nvirtual void activate() = 0;\nvirtual void deactivate(bool informParentNodes = true) = 0;\nvirtual bool isActive() = 0;\nvirtual std::shared_ptr<GraphNodeBase> clone() = 0;\nvirtual std::optional<std::map<std::string, std::string>>\n  exportData() = 0;\nvirtual void importData(\n  std::map<std::string, std::string> data) = 0; \n```", "```cpp\nvirtual void addOutputPin() {};\nvirtual int delOutputPin() { return 0; };\nvirtual int getNumOutputPins() { return 0; }; \n```", "```cpp\nvirtual void childFinishedExecution() {};\nvirtual bool listensToEvent(nodeEvent event)\n  { return false; };\nvirtual void handleEvent() { }; \n```", "```cpp\nWaitNode::WaitNode(int nodeId, float waitTime) :\n    GraphNodeBase(nodeId) {\n  int id = nodeId * 1000;\n  mInId = id;\n  mStaticIdStart = id + 100;\n  mOutId = id + 200;\n  mWaitTime = waitTime;\n  mCurrentTime = mWaitTime;\n} \n```", "```cpp\nstd::shared_ptr<GraphNodeBase> WaitNode::clone() {\n  return std::make_shared<WaitNode>(*this);\n} \n```", "```cpp\nvoid WaitNode::activate() {\n  if (mActive) {\n    return;\n  }\n  mActive = true;\n  mFired = false;\n} \n```", "```cpp\nvoid WaitNode::update(float deltaTime) {\n  if (!mActive) {\n    return;\n  }\n  mCurrentTime -= deltaTime; \n```", "```cpp\nif (mCurrentTime <= 0.0f)\n    fireNodeOutputTriggerCallback(mOutId);\n    fireNodeOutputTriggerCallback(mInId);\n    mCurrentTime = mWaitTime;\n    mActive = false;\n    mFired = true;\n  }\n} \n```", "```cpp\nstd::optional<std::map<std::string, std::string>>\n    WaitNode::exportData() {\n  std::map<std::string, std::string> data{};\n  data[\"wait-time\"] = std::to_string(mWaitTime);\n  return data;\n}\nvoid WaitNode::importData(\n    std::map<std::string, std::string> data) {\n  mWaitTime = std::stof(data[\"wait-time\"]);\n  mCurrentTime = mWaitTime;\n} \n```", "```cpp\n fireNodeOutputCallback mNodeCallbackFunction; \n```", "```cpp\n nodeActionCallback mNodeActionCallbackFunction; \n```", "```cpp\nstruct BehaviorData {\n  std::vector<std::shared_ptr<GraphNodeBase>>\n    bdGraphNodes{};\n  std::unordered_map<int, std::pair<int, int>>\n    bdGraphLinks{};\n  std::string bdEditorSettings;\n  nodeActionCallback bdNodeActionCallbackFunction{};\n}; \n```", "```cpp\nmBehaviorData->bdNodeActionCallbackFunction = [this]\n    (graphNodeType nodeType, instanceUpdateType updateType,\n    nodeCallbackVariant data, bool extraSetting) {\n  nodeActionCallback(nodeType, updateType, data,\n    extraSetting);\n  }; \n```", "```cpp\nnewNode->setNodeActionCallback(\n  newBehavior.bdNodeActionCallbackFunction); \n```", "```cpp\n mInstanceNodeActionCallback(mInstanceId, nodeType,\n    updateType, data, extraSetting); \n```", "```cpp\n mFireNodeOutputCallback = [this](int pinId)\n  { updateNodeStatus(pinId); }; \n```", "```cpp\n const bool openPopup = ImGui::IsWindowFocused(\n    ImGuiFocusedFlags_RootAndChildWindows) &&\n    ImNodes::IsEditorHovered() &&\n    ImGui::IsMouseClicked(ImGuiMouseButton_Right); \n```", "```cpp\n if (openPopup) {\n    if (ImNodes::IsNodeHovered(&mHoveredNodeId)) {\n      ImGui::OpenPopup(\"change node\");\n    } else {\n      ImGui::OpenPopup(\"add node\")\n    }\n  } \n```", "```cpp\n void loadData(std::shared_ptr<BehaviorData> data); \n```", "```cpp\n void updateGraphNodes(float deltaTime); \n```", "```cpp\nYAML::Emitter& operator<<(YAML::Emitter& out,\n const BehaviorData& behavior) { \n```", "```cpp\n if (node->exportData().has_value()) {\n        std::map<std::string, std::string> exportData =\n          node->exportData().value();\n        ...\n      } \n```", "```cpp\n template<>\n  struct convert<ExtendedBehaviorData> {\n    static Node encode(const ExtendedBehaviorData& rhs) {\n      ...\n    }\n    static bool decode(const Node& node,\n       ExtendedBehaviorData& rhs) {\n      ... \n    }\n  } \n```", "```cpp\nstruct PerNodeImportData {\n  int nodeId;\n  graphNodeType nodeType;\n  std::map<std::string, std::string> nodeProperties{};\n};\nstruct ExtendedBehaviorData : BehaviorData {\n  std::vector<PerNodeImportData> nodeImportData;\n}; \n```", "```cpp\nstd::vector<std::map<std::string, std::string>> entry =\n  nodeDataNode.as<std::vector<std::map<std::string,\n    std::string>>>(); \n```", "```cpp\n if (entry.size() > 0) {\n    for (const auto& mapEntry : entry) {\n      nodeData.nodeProperties.insert(mapEntry.begin(),\n        mapEntry.end());\n    }\n  } \n```", "```cpp\n std::map<int, SingleInstanceBehavior>\n    mInstanceToBehaviorMap{};\n  instanceNodeActionCallback mInstanceNodeActionCallback; \n```", "```cpp\nvoid BehaviorManager::update(float deltaTime) {\n  for (auto& instance : mInstanceToBehaviorMap) {\n    instance.second.update(deltaTime);\n  }\n} \n```", "```cpp\n mBehaviorManager = std::make_shared<BehaviorManager>();\n  mInstanceNodeActionCallback = [this](int instanceId,\n      graphNodeType nodeType, instanceUpdateType updateType,\n      nodeCallbackVariant data, bool extraSetting) {\n   updateInstanceSettings(instanceId, nodeType, updateType,\n     data, extraSetting);\n  };\n  mBehaviorManager->setNodeActionCallback(\n    mInstanceNodeActionCallback); \n```", "```cpp\n void addInstance(int instanceId,\n    std::shared_ptr<SingleInstanceBehavior> behavior); \n```", "```cpp\nenum class nodeEvent : uint8_t {\n  none = 0,\n  instanceToInstanceCollision,\n  instanceToEdgeCollision,\n  NUM\n}; \n```", "```cpp\n std::unordered_map<nodeEvent, std::string>\n    micNodeUpdateMap{}; \n```", "```cpp\n mModelInstCamData.micNodeEventCallbackFunction(\n    instSettings.isInstanceIndexPosition,\n    nodeEvent::instanceToEdgeCollision); \n```", "```cpp\n std::vector<nodeEvent> mPendingNodeEvents; \n```", "```cpp\n bool rdInteraction = false;\n  float rdInteractionMaxRange = 10.0f;\n  float rdInteractionMinRange = 1.5f;\n  float rdInteractionFOV = 45.0f;\n  std::set<int> rdInteractionCandidates{};\n  int rdInteractWithInstanceId = 0; \n```", "```cpp\nenum class nodeEvent : uint8_t {\n  ...\n **interaction,**\n  NUM\n}; \n```", "```cpp\n if (glfwGetKey(mRenderData.rdWindow, GLFW_KEY_U) ==\n      GLFW_PRESS) {\n    if (mRenderData.rdInteractWithInstanceId > 0) {\n      mBehaviorManager->addEvent(\n        mRenderData.rdInteractWithInstanceId,\n        nodeEvent::interaction);\n    }\n  } \n```"]