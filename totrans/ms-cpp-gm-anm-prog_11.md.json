["```cpp\nbool BoundingBox2D::intersects(BoundingBox2D otherBox) {\n  return !(\n    mPosition.x >= otherBox.getRight() ||\n    otherBox.getTopLeft().x >= getRight() ||\n    mPosition.y >= otherBox.getBottom() ||\n    otherBox.getTopLeft().y >= getBottom()\n  );\n} \n```", "```cpp\n BoundingBox2D mBoundingBox{}; \n```", "```cpp\n BoundingBox2D getBoundingBox();\n    void setBoundingBox(BoundingBox2D box); \n```", "```cpp\nfile(GLOB SOURCES\n  ...\n  **quadtree/*.cpp**\n  ...\n) \n```", "```cpp\ntarget_include_directories(${PROJECT_NAME} ... **quadtree**) \n```", "```cpp\nusing instanceGetBoundingBox2D =\n   std::function<BoundingBox2D(int)>; \n```", "```cpp\n std::shared_ptr<QuadTree> mQuadtree = nullptr; \n```", "```cpp\n mQuadtree->instanceGetBoundingBox2DCallback =\n    [this](int instanceId) {\n     return mModelInstCamData.micAssimpInstances.at(\n       instanceId)->getBoundingBox();\n    }; \n```", "```cpp\n BoundingBox2D box{position, size};\n    instances.at(i)->setBoundingBox(box);\n    mQuadtree->add(instSettings.isInstanceIndexPosition); \n```", "```cpp\n mQuadtree->clear(); \n```", "```cpp\nvoid AABB::addPoint(glm::vec3 point) {\n  mMinPos.x = std::min(mMinPos.x, point.x);\n  mMinPos.y = std::min(mMinPos.y, point.y);\n  mMinPos.z = std::min(mMinPos.z, point.z);\n  mMaxPos.x = std::max(mMaxPos.x, point.x);\n  mMaxPos.y = std::max(mMaxPos.y, point.y);\n  mMaxPos.z = std::max(mMaxPos.z, point.z);\n} \n```", "```cpp\n mAabbMesh->vertices.at(0) =\n    {{mMinPos.x, mMinPos.y, mMinPos.z}, color};\n  mAabbMesh->vertices.at(1) =\n    {{mMaxPos.x, mMinPos.y, mMinPos.z}, color};\n  ...\n  mAabbMesh->vertices.at(22) =\n    {{mMaxPos.x, mMaxPos.y, mMinPos.z}, color};\n  mAabbMesh->vertices.at(23) =\n    {{mMaxPos.x, mMaxPos.y, mMaxPos.z}, color}; \n```", "```cpp\n AABB instanceAABB = model->getAABB(instSettings); \n```", "```cpp\n glm::vec2 position =\n    glm::vec2(instanceAABB.getMinPos().x,\n    instanceAABB.getMinPos().z);\n  glm::vec2 size =\n    glm::vec2(std::fabs(instanceAABB.getMaxPos().x -\n    instanceAABB.getMinPos().x),\n    std::fabs(instanceAABB.getMaxPos().z -\n    instanceAABB.getMinPos().z)); \n```", "```cpp\n BoundingBox2D box{position, size};\n  instances.at(i)->setBoundingBox(box);\n  mQuadtree->add(instSettings.isInstanceIndexPosition); \n```", "```cpp\n mModelInstCamData.micInstanceCollisions =\n    mQuadtree->findAllIntersections(); \n```", "```cpp\nfor (const auto& instPairs :\n    mModelInstCamData.micInstanceCollisions) {\n  instances.at(instPairs.first)->rotateInstance(6.5f);\n  instances.at(instPairs.second)->rotateInstance(-5.3f);\n} \n```", "```cpp\n mLineVertexBuffer.uploadData(*mAABBMesh);\n  mLineShader.use();\n  mLineVertexBuffer.bindAndDraw(GL_LINES, 0,\n    mAABBMesh->vertices.size()); \n```", "```cpp\nvoid main() {\n  uint node = gl_GlobalInvocationID.x;\n  uint instance = gl_GlobalInvocationID.y;\n  uint numberOfBones = gl_NumWorkGroups.x;\n  uint index = node + numberOfBones * instance; \n```", "```cpp\n vec3 nodePos =\n   (worldPosMat[instance] * trsMat[index])[3].xyz;\n  nodePos += sphereAdjustment[node].xyz;\n  float radius = 1.0; \n```", "```cpp\n int parentNode = parentIndex[node]; \n```", "```cpp\n if (parentNode >= 0) {\n    uint parentIndex = parentNode +\n      numberOfBones * instance;\n    vec3 parentPos =\n     (worldPosMat[instance] * trsMat[parentIndex])[3].xyz;\n    parentPos += sphereAdjustment[parentNode].xyz; \n```", "```cpp\n vec3 center = mix(nodePos, parentPos, 0.5);\n    radius = length(center - nodePos) *\n      sphereAdjustment[node].w; \n```", "```cpp\n } else {\n    radius = sphereAdjustment[node].w;\n  } \n```", "```cpp\n if (radius < 0.05) {\n    sphereData[index] = vec4(0.0);\n  } else {\n    sphereData[index] = vec4(nodePos, radius);\n  }\n} \n```", "```cpp\nvoid main() {\n  vec3 boneCenter = sphereData[gl_InstanceID].xyz;\n  float radius = sphereData[gl_InstanceID].w; \n```", "```cpp\n mat3 scaleMat = createScaleMatrix(radius); \n```", "```cpp\n gl_Position = projection * view *\n    vec4(scaleMat * aPos + boneCenter, 1.0);\n  lineColor = vec4(aColor, 1.0);\n} \n```", "```cpp\n mLineVertexBuffer.uploadData(mSphereMesh);\n  mSphereShader.use();\n  mBoundingSphereBuffer.bind(1);\n  mLineVertexBuffer.bindAndDrawInstanced(GL_LINES, 0,\n    mSphereMesh.vertices.size(), numberOfSpheres); \n```", "```cpp\n mModelInstCamData.micInstanceCollisions =\n    mQuadtree->findAllIntersections(); \n```"]