<html><head></head><body>
		<div><h1 id="_idParaDest-16"><a id="_idTextAnchor017"/><em class="italic">Chapter 1</em>: C++, SFML, Visual Studio, and Starting the First Game</h1>
			<p>Welcome to <em class="italic">Beginning C++ Game Programming</em>. I will not waste any time in getting you started on your journey to writing great games for the PC using C++ and the OpenGL powered SFML.</p>
			<p>This is quite a hefty first chapter, but we will learn absolutely everything we need so that we have the first part of our first game up and running. Here is what we will do in this chapter:</p>
			<ul>
				<li>Find out about the games we will build</li>
				<li>Meet C++</li>
				<li>Find out about Microsoft Visual C++</li>
				<li>Explore SFML and its relationship with C++</li>
				<li>Setting up the development environment</li>
				<li>Plan and prepare for the first game project, Timber!!! </li>
				<li>Write the first C++ code of this book and make a runnable game that draws a background</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>The games we will build</h1>
			<p>This journey will be smooth as we will learn about the fundamentals of the super-fast C++ language one step at a time, and then put this new knowledge to use by adding cool features to the five games we are going to build.</p>
			<p>The following are our five projects for this book.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor019"/>Timber!!!</h2>
			<p>The first game is an addictive, fast-paced clone of the hugely successful Timberman, which can be found at <a href="http://store.steampowered.com/app/398710/">http://store.steampowered.com/app/398710/</a>. Our game, Timber!!!, will introduce us to all the basics of C++ while we build a genuinely playable game. Here is what our version of the game will look like when we are done and we have added a few last-minute enhancements:</p>
			<div><div><img src="img/B14278_01_01.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>Pong</h2>
			<p>Pong was one of the first video games to be made, and you can find out about its history here: <a href="https://en.wikipedia.org/wiki/Pong">https://en.wikipedia.org/wiki/Pong</a>. It is an excellent example of how the basics of game object animation and dynamic collision detection work. We will build this simple retro game to explore the concept of classes and object-oriented programming. The player will use the bat at the bottom of the screen and hit the ball back to the top of the screen:</p>
			<div><div><img src="img/B14278_01_01b.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Zombie Arena</h2>
			<p>Next, we will build a frantic, zombie survival shooter, not unlike the Steam hit <em class="italic">Over 9,000 Zombies!</em>, which you can find out more about at <a href="http://store.steampowered.com/app/273500/">http://store.steampowered.com/app/273500/</a>. The player will have a machine gun and must fight off ever-growing waves of zombies. All this will take place in a randomly generated, scrolling world. To achieve this, we will learn about how object-oriented programming allows us to have a large <strong class="bold">code base</strong> (lots of code) that is easy to write and maintain. Expect exciting features such as hundreds of enemies, rapid-fire weaponry, pickups, and a character that can be “leveled up” after each wave:</p>
			<div><div><img src="img/B14278_01_02_(1).jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Thomas was late</h2>
			<p>The fourth game will be a stylish and challenging single-player and co-op puzzle platformer. It is based on the very popular game <em class="italic">Thomas was Alone</em> (<a href="http://store.steampowered.com/app/220780/">http://store.steampowered.com/app/220780/</a>). Expect to learn about cool topics such as particle effects, OpenGL Shaders, and split-screen cooperative multiplayer:</p>
			<div><div><img src="img/B14278_01_03.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to play any of the games now, you can do so from the download bundle in the <code>Runnable Games</code> folder. Just double-click on the appropriate <code>.exe</code> file. Note that, in this folder, you can run either the completed games or any game in its partially completed state from any chapter.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Space Invaders ++</h2>
			<p>The final game will be a Space Invaders clone. In some ways, the game itself is not what is important about this project. The project will be used to learn about game programming patterns. As will become abundantly clear as this book progresses, our code keeps getting longer and more complicated. Each project will introduce one or more techniques for coping with this, but the complexity and length of our code will keep coming back to challenge us, despite these techniques.</p>
			<p>The Space Invaders project (called Space Invaders ++) will show us ways in which we can radically reorganize our game code also that we can take control of and properly manage our code once and for all. This will leave you with all the knowledge you need to plan and build deep, complex, and innovative games, without ending up in a tangle of code. </p>
			<p>The game will also introduce concepts such as screens, input handlers, and entity-component systems. It will also allow us to learn how to let the player use a gamepad instead of the keyboard and introduce the C++ concepts of smart pointers, casts, assertions, breakpoint debugging, and teach us the most important lesson from the whole book: how to build your own unique games:</p>
			<div><div><img src="img/B14278_01_36.jpg" alt=""/>
				</div>
			</div>
			<p>Let’s get started by introducing C++, Visual Studio, and SFML!</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor024"/>Meet C++</h1>
			<p>Now that we know what games we will be building, let’s get started by introducing C++, Visual Studio, and SFML. One question you might have is, <em class="italic">why use the C++ language at all?</em> C++ is fast – very fast. What makes this true is the fact that the code that we write is directly translated into machine-executable instructions. These instructions are what make the game. The executable game is contained within a <code>.exe</code> file, which the player can simply double-click to run.</p>
			<p>There are a few steps in the process of changing our code into an executable file. First, the <strong class="bold">preprocessor</strong> looks to see if any <em class="italic">other code</em> needs to be included within our own code and adds it. Next, all the code is <strong class="bold">compiled</strong> into <strong class="bold">object files</strong> by the <strong class="bold">compiler</strong> program. Finally, a third program, called the <strong class="bold">linker</strong>, joins all the object files into the executable file for our game.</p>
			<p>In addition, C++ is well established at the same time as being extremely up to date. C++ is an <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) language, which means we can write and organize our code using well-tested conventions that make our games efficient and manageable. The benefits as well as the necessity of this will reveal themselves as we progress through this book.</p>
			<p>Most of this <em class="italic">other code</em> that I referred to, as you might be able to guess, is SFML, and we will find out more about SFML in just a minute. The preprocessor, compiler, and linker programs I have just mentioned are all part of the Visual Studio <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>).</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor025"/>Microsoft Visual Studio</h1>
			<p>Visual Studio hides away the complexity of preprocessing, compiling, and linking. It wraps it all up into the press of a button. In addition to this, it provides a slick user interface for us to type our code into and manage what will become a large selection of code files and other project assets as well.</p>
			<p>While there are advanced versions of Visual Studio that cost hundreds of dollars, we will be able to build all five of our games in the free “<strong class="bold">Express 2019 for Community</strong>” version. This is the latest free version of Visual Studio.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor026"/>SFML</h1>
			<p><strong class="bold">SFML</strong> is the <strong class="bold">Simple Fast Media Library</strong>. It is not the only C++ library for games and multimedia. It is possible to make an argument to use other libraries, but SFML seems to come through for me every time. Firstly, it is written using object-oriented C++. The benefits of object-oriented C++ are numerous, and you will experience them as you progress through this book. </p>
			<p>SFML is also easy to get started with and is therefore a good choice if you are a beginner, yet at the same time it has the potential to build the highest-quality 2D games if you are a professional. So, a beginner can get started using SFML and not worry about having to start again with a new language/library as their experience grows.</p>
			<p>Perhaps the biggest benefit is that most modern C++ programming uses OOP. Every C++ beginner’s guide I have ever read uses and teaches OOP. OOP is the future (and the now) of coding in almost all languages, in fact. So why, if you’re learning C++ from the beginning, would you want to do it any other way?</p>
			<p>SFML has a module (code) for just about anything you would ever want to do in a 2D game. SFML works using OpenGL, which can also make 3D games. OpenGL is the de facto free-to-use graphics library for games when you want it to run on more than one platform. When you use SFML, you are automatically using OpenGL.</p>
			<p>SFML allows you to create the following:</p>
			<ul>
				<li>2D graphics and animations, including scrolling game worlds.</li>
				<li>Sound effects and music playback, including high-quality directional sound.</li>
				<li>Input handling with a keyboard, mouse, and gamepad.</li>
				<li>Online multiplayer features.</li>
				<li>The same code can be compiled and linked on all major desktop operating systems, and mobile as well!.</li>
			</ul>
			<p>Extensive research has not uncovered any more suitable ways to build 2D games for PC, even for expert developers and especially if you are a beginner and want to learn C++ in a fun gaming environment.</p>
			<p>In the sections that follow, we will set up the development environment, beginning with a discussion on what to do if you are using Mac or Linux operating systems.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor027"/>Setting up the development environment</h1>
			<p>Now that you know a bit more about how we will be making games, it is time to set up a development environment so we can get coding.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>What about Mac and Linux?</h2>
			<p>The games that we will be making can be built to run on Windows, Mac, and Linux! The code we use will be identical for each platform. However, each version does need to be compiled and linked on the platform for which it is intended, and Visual Studio will not be able to help us with Mac and Linux.</p>
			<p>It would be unfair to say, especially for complete beginners, that this book is entirely suited for Mac and Linux users. Although, I guess, if you are an enthusiastic Mac or Linux user and you are comfortable with your operating system, you will likely succeed. Most of the extra challenges you will encounter will be in the initial setup of the development environment, SFML, and the first project.</p>
			<p>To this end, I can highly recommend the following tutorials, which will hopefully replace the next 10 pages (approximately), up to the <em class="italic">Planning Timber!!!</em> section, when this book will become relevant to all operating systems.</p>
			<p>For Linux, read this to replace the next few sections: <a href="https://www.sfml-dev.org/tutorials/2.5/start-linux.php">https://www.sfml-dev.org/tutorials/2.5/start-linux.php</a>.</p>
			<p>On Mac, read this tutorial to get started: <a href="https://www.sfml-dev.org/tutorials/2.5/start-osx.php">https://www.sfml-dev.org/tutorials/2.5/start-osx.php</a>.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Installing Visual Studio 2019 Community edition</h2>
			<p>To start creating a game, we need to install Visual Studio 2019. Installing Visual Studio can be almost as simple as downloading a file and clicking a few buttons. I will walk you through the installation process a step at a time.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that, over the years, Microsoft is likely to change the name, appearance, and download page that’s used to obtain Visual Studio. They are likely to change the layout of the user interface and make the instructions that follow out of date. However, the settings that we configure for each project are fundamental to C++ and SFML, so careful interpretation of the instructions that follow in this chapter will likely be possible, even if Microsoft does something radical to Visual Studio. Anyway, at the time of writing, Visual Studio 2019 has been released for just two weeks, so hopefully this chapter will be up to date for a while. If something significant does happen, then I will add an up-to-date tutorial on <a href="http://gamecodeschool.com">http://gamecodeschool.com</a> as soon as I find out about it.</p>
			<p>Let’s get started with installing Visual Studio:</p>
			<ol>
				<li>The first thing you need is a Microsoft account and login details. If you have a Hotmail or MSN email address, then you already have one. If not, you can sign up for a free one here: <a href="https://login.live.com/">https://login.live.com/</a>.</li>
				<li>The next step is to visit <a href="https://visualstudio.microsoft.com/vs/">https://visualstudio.microsoft.com/vs/</a> and find the download link for <strong class="bold">Community 2019</strong>. This is what it looks like at the time of writing:<div><img src="img/B14278_01_04.jpg" alt=""/></div></li>
				<li>Save the file to your computer.</li>
				<li>When the download completes, run the download by double-clicking on it. My file, at the time of writing, was called <code>vs_community__33910147.1551368984.exe</code>. Yours will be different based on the current version of Visual Studio. </li>
				<li>After giving permission for Visual Studio to make changes to your computer, you will be greeted with the following window. Click <strong class="bold">Continue</strong>:<div><img src="img/B14278_01_05.jpg" alt=""/></div></li>
				<li>Wait for the installer program to download some files and set up the next stage of the installation. Shortly, you will be presented with the following window:<div><img src="img/B14278_01_05a.jpg" alt=""/></div></li>
				<li>If you want to choose a new location to install Visual Studio, locate the <strong class="bold">Change</strong> option and configure the install location. The simplest thing to do is leave the file at the default location chosen by Visual Studio. When you are ready, locate the <strong class="bold">Desktop development with C++</strong> option and select it.</li>
				<li>Next, click the <strong class="bold">Install</strong> button. Grab some refreshments as this step might take a while.</li>
				<li>When the process completes, you can close all open windows, including any that prompt you to start a new project, as we are not ready to start coding until we have installed SFML.</li>
			</ol>
			<p>Now, we are ready to turn our attention to SFML.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>Setting up SFML</h2>
			<p>This short tutorial will guide you through downloading the SFML files that allow us to include the functionality contained in the library in our projects. In addition, we will see how we can use the SFML <strong class="bold">DLL</strong> files that will enable our compiled object code to run alongside SFML. To set up SFML, follow these steps:</p>
			<ol>
				<li value="1">Visit this link on the SFML website: <a href="http://www.sfml-dev.org/download.php">http://www.sfml-dev.org/download.php</a>. Click on the button that says <strong class="bold">Latest stable version</strong>, as shown here:<div><img src="img/B14278_01_06.jpg" alt=""/></div></li>
				<li>By the time you read this book, the latest version will almost certainly have changed. This won’t matter as long as you do the next step just right. We want to download the <strong class="bold">32-bit version</strong> of <strong class="bold">Visual C++ 2017</strong>. This might sound counter-intuitive because we have just installed Visual Studio 2019 and you probably (most commonly) have a 64-bit PC. The reason we chose to download the 32-bit version is that Visual C++ 2017 is part of Visual Studio 2019 (Visual Studio does more than C++) and we will be building games in 32-bit so that they can run on <em class="italic">both</em> 32- and 64-bit machines. Click the <strong class="bold">Download</strong> button that’s shown in the following screenshot:<div><img src="img/B14278_01_07.jpg" alt=""/></div></li>
				<li>When the download completes, create a folder at the root of the same drive where you installed Visual Studio and name it <code>SFML</code>. Also, create another folder at the root of the drive where you installed Visual Studio and call it <code>VS Projects</code>.</li>
				<li>Finally, unzip the SFML download. Do this on your desktop. When unzipping is complete, you can delete the .zip folder. You will be left with a single folder on your desktop. Its name will reflect the version of SFML that you downloaded. Mine is called <code>SFML-2.5.1-windows-vc15-32-bit</code>. Your filename will likely reflect a more recent version. Double-click this folder to see its contents, then double-click again into the next folder (mine is called <code>SFML-2.5.1</code>). The following screenshot shows what my <code>SFML-2.5.1 </code>folder’s content looks like. Yours should look the same:</li>
				<li>Copy the entire contents of this folder and paste all the files and folders into the <code>SFML</code> folder that you created in <em class="italic">Step 3</em>. For the rest of this book, I will refer to this folder simply as “your <code>SFML</code> folder”.</li>
			</ol>
			<p>Now, we are ready to start using C++ and SFML in Visual Studio.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Creating a new project</h2>
			<p>As setting up a project is a fiddly process, we will go through it step by step so that we can start getting used to it: </p>
			<ol>
				<li value="1">Start Visual Studio in the same way you start any app: by clicking on its icon. The default installation options will have placed a <strong class="bold">Visual Studio 2019</strong> icon in the Windows start menu. You will see the following window:<div><img src="img/B14278_01_10.jpg" alt=""/></div></li>
				<li>Click on the <strong class="bold">Create a new project</strong> button, as highlighted in the preceding screenshot. You will see the <strong class="bold">Create a new project</strong> window, as shown in the following screenshot:<div><img src="img/B14278_01_11.jpg" alt=""/></div></li>
				<li>In the <strong class="bold">Create a new project</strong> window, we need to choose the type of project we will be creating. We will be creating a console app, so select <strong class="bold">Console App</strong>, as highlighted in the preceding screenshot, and click the <strong class="bold">Next </strong>button. You will then see the <strong class="bold">Configure your new project </strong>window. This following screenshot shows the <strong class="bold">Configure your new project</strong> window after the next three steps have been completed:<div><img src="img/B14278_01_12.jpg" alt=""/></div></li>
				<li>In the <code>Timber</code> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field. Note that this causes Visual Studio to automatically configure the <strong class="bold">Solution name</strong> field to the same name.</li>
				<li>In the <code>VS Projects</code> folder that we created in the previous tutorial. This will be the location that all our project files will be kept. </li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>.</li>
				<li>Note that the preceding screenshot shows what the window looks like when the previous three steps have been completed. When you have completed these steps, click <strong class="bold">Create</strong>. The project will be generated, including some C++ code. This following screenshot shows where we will be working throughout this book:<div><img src="img/B14278_01_13.jpg" alt=""/></div></li>
				<li>We will now configure the project to use the SFML files that we put in the <code>SFML</code> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">Timber properties…</strong>. You will see the following window:</li>
			</ol>
			<div><div><img src="img/B14278_01_14.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Tip</p>
			<p class="callout">In the preceding screenshot, the <strong class="bold">OK</strong>, <strong class="bold">Cancel</strong>, and <strong class="bold">Apply</strong> buttons are not fully formed. This is likely a glitch with Visual Studio not handling my screen resolution correctly. Yours will hopefully be fully formed. Whether your buttons appear like mine do or not, continuing with the tutorial will be the same.</p>
			<p>Next, we will begin to configure the project properties. As these steps are quite intricate, I will cover them in a new list of steps.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>Configuring the project properties</h2>
			<p>At this stage, you should have the <strong class="bold">Timber Property Pages</strong> window open, as shown in the preceding screenshot at the end of the previous section. Now, we will begin to configure some properties while using the following annotated screenshot for guidance:</p>
			<div><div><img src="img/B14278_01_15.jpg" alt=""/>
				</div>
			</div>
			<p>We will add some fairly intricate and important project settings in this section. This is the laborious part, but we will only need to do this once per project. What we need to do is tell Visual Studio where to find a special type of code file from SFML. The special type of file I am referring to is a <code>.hpp</code> file extension. All this will become clearer when we eventually start adding our own header files in the second project. In addition, we need to tell Visual Studio where it can find the SFML library files. In the <strong class="bold">Timber Property Pages</strong> window, perform the following three steps, which are numbered in the preceding screenshot:</p>
			<ol>
				<li value="1">First (<strong class="bold">1</strong>), select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> drop down.</li>
				<li>Second (<strong class="bold">2</strong>), select <strong class="bold">C/C++</strong> then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>Third (<code>\SFML\include</code>. The full path to type, if you located your <code>SFML</code> folder on your D drive, is as shown in the preceding screenshot; that is, <code>D:\SFML\include</code>. Vary your path if you installed SFML on a different drive.</li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform these steps, which refer to the following annotated screenshot. First (<strong class="bold">1</strong>), select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <code>SFML</code> folder is, followed by <code>\SFML\lib</code>. So, the full path to type if you located your <code>SFML</code> folder on your D drive is, as shown in the following screenshot, <code>D:\SFML\lib</code>. Vary your path if you installed SFML to a different drive:<div><img src="img/B14278_01_16.jpg" alt=""/></div></li>
				<li>Click <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Finally, for this stage, still in the same window, perform these steps, which refer to the following annotated screenshot. Switch the <strong class="bold">Configuration:</strong> drop down (<strong class="bold">1</strong>) to <strong class="bold">Debug </strong>as we will be running and testing our games in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong> (<strong class="bold">2</strong>).</li>
				<li>Find the <code>sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</code> at the indicated place. Be extra careful to place the cursor exactly in the right place and not to overwrite any of the text that is already there.</li>
				<li>Click <strong class="bold">OK</strong>:<div><img src="img/B14278_01_16a.jpg" alt=""/></div></li>
				<li>Click <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
			</ol>
			<p>Phew; that’s it! We have successfully configured Visual Studio and can move on to planning the Timber!!! project.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Planning Timber!!!</h1>
			<p>Whenever you make a game, it is always best to start with a pencil and paper. If you don’t know exactly how your game is going to work on the screen, how can you possibly make it work in code?</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">At this point, if you haven’t already, I suggest you go and watch a video of Timberman in action so that you can see what we are aiming for. If you feel your budget can stretch to it, then grab a copy and give it a play. It is often on sale for under $1 on Steam: <a href="http://store.steampowered.com/app/398710/">http://store.steampowered.com/app/398710/</a>.</p>
			<p>The features and objects of a game that define the gameplay are known as the <strong class="bold">mechanics</strong>. The basic mechanics of the game are as follows:</p>
			<ul>
				<li>Time is always running out.</li>
				<li>You can get more time by chopping the tree.</li>
				<li>Chopping the tree causes the branches to fall.</li>
				<li>The player must avoid the falling branches.</li>
				<li>Repeat until time runs out or the player is squished.</li>
			</ul>
			<p>Expecting you to plan the C++ code at this stage is obviously a bit silly. This is, of course, the first chapter of a C++ beginner’s guide. We can, however, take a look at all the assets we will use and an overview of what we will need to make our C++ code do.</p>
			<p>Take a look at this annotated screenshot of the game:</p>
			<div><div><img src="img/B14278_01_17.jpg" alt=""/>
				</div>
			</div>
			<p>You can see that we have the following features:</p>
			<ul>
				<li><strong class="bold">The player’s score:</strong> Each time the player chops a log, they will get one point. They can chop a log with either the left or the right arrow (cursor) key. </li>
				<li><strong class="bold">Player character:</strong> Each time the player chops, they will move to/stay on the same side of the tree relative to the cursor key they use. Therefore, the player must be careful which side they choose to chop on.</li>
				<li>When the player chops, a simple axe graphic will appear in the player character’s hands.</li>
				<li><strong class="bold">Shrinking time-bar:</strong> Each time the player chops, a small amount of time will be added to the ever-shrinking time-bar. </li>
				<li><strong class="bold">The lethal branches:</strong> The faster the player chops, the more time they will get, but also the faster the branches will move down the tree and therefore the more likely they are to get squished. The branches spawn randomly at the top of the tree and move down with each chop.</li>
				<li>When the player gets squished – and they will get squished quite regularly – a gravestone graphic will appear.</li>
				<li><strong class="bold">The chopped log:</strong> When the player chops, a chopped log graphic will whiz off, away from the player.</li>
				<li><strong class="bold">Just for decoration:</strong> There are three floating clouds that will drift at random heights and speeds, as well as a bee that does nothing but fly around.</li>
				<li><strong class="bold">The background:</strong> All this takes place on a pretty background.</li>
			</ul>
			<p>So, in a nutshell, the player must frantically chop to gain points and avoid running out of time. As a slightly perverse, but fun consequence, the faster they chop, the more likely their squishy demise is. </p>
			<p>We now know what the game looks like, how it is played, and the motivation behind the game mechanics. Now, we can go ahead and start building it. Follow these steps:</p>
			<ol>
				<li value="1">Now, we need to copy the SFML <code>.dll</code> files into the main project directory. My main project directory is <code>D:\VS Projects\Timber</code>. It was created by Visual Studio in the previous tutorial. If you put your <code>VS Projects</code> folder somewhere else, then perform this step there instead. The files we need to copy into the project folder are located in your <code>SFML\bin</code> folder. Open a window for each of the two locations and highlight all the files in the <code>SFML\bin</code> folder, as shown in the following screenshot:<div><img src="img/B14278_01_19.jpg" alt=""/></div></li>
				<li>Now, copy and paste the highlighted files into the project folder, that is, <code>D:\VS Projects\Timber</code>.</li>
			</ol>
			<p>The project is now set up and ready to go. You will be able to see the following screen. I have annotated this screenshot so you can start familiarizing yourself with Visual Studio. We will revisit all these areas, and others, soon:</p>
			<div><div><img src="img/B14278_01_20.jpg" alt=""/>
				</div>
			</div>
			<p>Your layout might look slightly different to what’s shown in the preceding screenshot because the windows of Visual Studio, like most applications, are customizable. Take the time to locate the <strong class="bold">Solution Explorer</strong> window on the right and adjust it to make its content nice and clear, like it is in the previous screenshot.</p>
			<p>We will be back here soon to start coding. But first, we will explore the project assets we will be using.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>The project assets</h1>
			<p>Assets are anything you need to make your game. In our case, these assets include the following:</p>
			<ul>
				<li>A font for the writing on the screen</li>
				<li>Sound effects for different actions, such as chopping, dying, and running out of time</li>
				<li>Graphics for the character, background, branches, and other game objects</li>
			</ul>
			<p>All the graphics and sounds that are required for this game are included in the download bundle for this book. They can be found in the <code>Chapter 1/graphics</code> and <code>Chapter 1/sound</code> folders as appropriate. </p>
			<p>The font that is required has not been supplied. This is because I wanted to avoid any possible ambiguity regarding the license. This will not cause a problem, though, as I will show you exactly where and how to choose and download fonts for yourself.</p>
			<p>Although I will provide either the assets themselves or information on where to get them, you might like to create or acquire them for yourself. </p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Outsourcing the assets</h2>
			<p>There are a number of websites that allow you to contract artists, sound engineers, and even programmers. One of the biggest is Upwork (<a href="http://www.upwork.com">www.upwork.com</a>). You can join this site for free and post your jobs. You will need to write a clear explanation of your requirements, as well as state how much you are prepared to pay. Then, you will probably get a good selection of contractors bidding to do the work. Be aware, however, that there are a lot of unqualified contractors whose work might be disappointing, but if you choose carefully, you will likely find a competent, enthusiastic, and great-value person or company to do the job.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Making your own sound FX</h2>
			<p>Sound effects can be downloaded for free from sites such as Freesound (<a href="http://www.freesound.org">www.freesound.org</a>), but often the licence won’t allow you to use them if you are selling your game. Another option is to use an open source software called BFXR from <a href="http://www.bfxr.net">www.bfxr.net</a>, which can help you generate lots of different sound effects that are yours to keep and do with as you like.</p>
			<h2 id="_idParaDest-36">Adding the assets to<a id="_idTextAnchor037"/> the project</h2>
			<p>Once you have decided which assets you will use, it is time to add them to the project. The following instructions will assume you are using all the assets that are supplied in this book’s download bundle. Where you are using your own, simply replace the appropriate sound or graphic file with your own, using exactly the same filename: </p>
			<ol>
				<li value="1">Browse to the project folder, that is, <code>D:\VS Projects\Timber</code>.</li>
				<li>Create three new folders within this folder and name them <code>graphics</code>, <code>sound</code>, and <code>fonts</code>.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 1/graphics </code>into the <code>D:\VS Projects\Timber\graphics</code> folder.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 1/sound</code> into the <code>D:\VS Projects\Timber\sound</code> folder.</li>
				<li>Now, visit <a href="http://www.1001freefonts.com/komika_poster.font">http://www.1001freefonts.com/komika_poster.font</a> in your web browser and download the <strong class="bold">Komika Poster</strong> font.</li>
				<li>Extract the contents of the zipped download and add the <code>KOMIKAP_.ttf</code> file to the <code>D:\VS Projects\Timber\fonts</code> folder. </li>
			</ol>
			<p>Let’s take a look at these assets – especially the graphics – so that we can visualize what is happening when we use them in our C++ code.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/>Exploring the assets</h2>
			<p>The graphical assets make up the parts of the scene that is our Timber!!! game. If you take a look at the graphical assets, it should be clear where in our game they will be used:</p>
			<div><div><img src="img/B14278_01_21.jpg" alt=""/>
				</div>
			</div>
			<p>The sound files are all in <code>.wav</code> format. These files contain the sound effects that we will play at certain events throughout the game. They were all generated using BFXR and are as follows:</p>
			<ul>
				<li><code>chop.wav</code>: A sound that is a bit like an axe (a retro axe) chopping a tree</li>
				<li><code>death.wav</code>: A sound a bit like a retro “losing” sound</li>
				<li><code>out_of_time.wav</code>: A sound that plays when the player loses by running out of time, as opposed to being squashed</li>
			</ul>
			<p>We have seen all the assets, including the graphics, so now we will have a short discussion related to the resolution of the screen and how we position the graphics on it.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>Understanding screen and internal coordinates</h1>
			<p>Before we move on to the actual C++ coding, let’s talk a little about coordinates. All the images that we see on our monitors are made out of pixels. Pixels are little tiny dots of light that combine to make the images we see.</p>
			<p>There are many different resolutions of monitor but, as an example, consider that a fairly typical gaming monitor might have 1,920 pixels horizontally and 1,080 pixels vertically. </p>
			<p>The pixels are numbered, starting from the top left of the screen. As you can see from the following diagram, our 1,920 x 1,080 example is numbered from 0 through to 1,919 on the horizontal (x) axis and 0 through 1,079 on the vertical (y) axis:</p>
			<div><div><img src="img/B14278_01_31.jpg" alt=""/>
				</div>
			</div>
			<p>A specific and exact screen location can therefore be identified by an x and y coordinate. We create our games by drawing the game objects such as the background, characters, bullets, and text to specific locations on the screen. These locations are identified by the coordinates of the pixels. Take a look at the following hypothetical example of how we might draw at the approximately central coordinates of the screen. In the case of a 1,920 x 1080 screen, this would be at the 960, 540 position:</p>
			<div><div><img src="img/B14278_01_32.jpg" alt=""/>
				</div>
			</div>
			<p>In addition to the screen coordinates, our game objects will each have their own similar coordinate system as well. Like the screen coordinate system, their <strong class="bold">internal </strong>or <strong class="bold">local </strong>coordinates start at 0,0 in the top left-hand corner. </p>
			<p>In the previous image, we can see that 0,0 of the character is drawn at 960, 540 of the screen.</p>
			<p>A visual, 2D game object, such as a character or perhaps a zombie, is called a <strong class="bold">Sprite</strong>. A sprite is typically made from an image file. All sprites have what is known as an <strong class="bold">origin</strong>.</p>
			<p>If we draw a sprite to a specific location on the screen, it is the origin that will be located at this specific location. The 0,0 coordinates of the sprite are its origin. The following image demonstrates this:</p>
			<div><div><img src="img/B14278_01_33.jpg" alt=""/>
				</div>
			</div>
			<p>Therefore, in the image showing the character drawn to the screen, although we drew the image at the central position (960, 540), it appears off to the right and down a bit.</p>
			<p>This is important to know as it will help us understand the coordinates we use to draw all the graphics.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that, in the real world, gamers have a huge variety of screen resolutions, and our games will need to work with as many of them as possible. In the third project, we will see how we can make our games dynamically adapt to almost any resolution. In this first project, we will need to assume that the screen resolution is 1,920 x 1,080. If your screen resolution is higher, this will be fine. Don’t worry if your screen is lower than this as I have provided a separate set of code for each chapter for the Timber!!! game. The code files are nearly identical apart from adding and swapping a few lines of code near the beginning. If you have a lower-resolution screen, then simply follow the code in this book, which assumes that you have a 1,920 x 1,080 resolution. When it comes to trying out the game, you can copy and paste the code files from the <code>low res</code> folder in the first five chapters as appropriate. In fact, once the extra lines have been added from this first chapter, all the rest of the code will be identical, regardless of your screen resolution. I have supplied the low-resolution code for each chapter, just as a convenience. How the few lines of code work their magic (scale the screen) will be discussed in the third project. The alternative code will work on resolutions as low as 960 x 540 and so should be OK on almost any PC or laptop.</p>
			<p>Now, we can write our first piece of C++ code and see it in action.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Getting started with coding the game</h1>
			<p>Open up Visual Studio if it isn’t already open. Open up the Timber!!! project by left-clicking it from the <strong class="bold">Recent</strong> list on the main Visual Studio window. </p>
			<p>Find the <code>Timber.cpp</code> file under the <strong class="bold">Source Files</strong> folder.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">.cpp stands for C plus plus.</p>
			<p>Delete the entire contents of the code window and add the following code so that you have the same code yourself. You can do so in the same way that you would with any text editor or word processor; you could even copy and paste it if you prefer. After you have made the edits, we can talk about it:</p>
			<pre>// This is where our game starts from
int main()
{
    return 0;
}</pre>
			<p>This simple C++ program is a good place to start. Let’s go through it line by line.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Making code clearer with comments</h2>
			<p>The first line of code is as follows:</p>
			<pre>// This is where our game starts from</pre>
			<p>Any line of code that starts with two forward slashes (<code>//</code>)<code> </code>is a comment and is ignored by the compiler. As such, this line of code does nothing. It is used to leave in any information that we might find useful when we come back to the code at a later date. The comment ends at the end of the line, so anything on the next line is not part of the comment. There is another type of comment called a <strong class="bold">multi-line</strong> or <strong class="bold">c-style</strong> comment, which can be used to leave comments that take up more than a single line. We will see some of them later in this chapter. Throughout this book, I will leave hundreds of comments to help add context and further explain the code.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>The main function</h2>
			<p>The next line we see in our code is as follows:</p>
			<pre>int main()</pre>
			<p><code>int</code> is an <strong class="bold">integer</strong> or whole number. Hold that thought and we will come back to it in a minute.</p>
			<p>The <code>main()</code> part is the name of the section of code that follows. The section of code is marked out between the opening curly brace (<code>{</code>) and the next closing curly brace (<code>}</code>).</p>
			<p>So, everything in between these curly braces <code>{...}</code> is a part of <code>main</code>. We call a section of code like this a <strong class="bold">function</strong>.</p>
			<p>Every C++ program has a <code>main</code> function and it is the place where the <code>main</code> function, and no matter what code we write, our game will always begin execution from the first line of code that’s inside the opening curly brace of the <code>main</code> function.</p>
			<p>For now, don’t worry about the strange brackets that follow the function name <code>()</code>. We will discuss them further in <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a><em class="italic">, Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>, when we get to see functions in a whole new and more interesting light.</p>
			<p>Let’s look closely at the one single line of code within our <code>main</code> function.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Presentation and syntax</h2>
			<p>Take a look at the entirety of our <code>main</code> function again:</p>
			<pre>int main()
{
    return 0;
}</pre>
			<p>We can see that, inside <code>Main</code>, there is just one single line of code, <code>return 0;</code>. Before we move on to find out what this line of code does, let’s look at how it is presented. This is useful because it can help us prepare to write code that is easy to read and distinguished from other parts of our code.</p>
			<p>First, notice that<code> return 0;</code> is indented to the right by one tab. This clearly marks it out as being internal to the <code>main</code> function. As our code grows in length, we will see that indenting our code and leaving white space will be essential to maintaining readability.</p>
			<p>Next, notice the punctuation on the end of the line. A semicolon (<code>;</code>) tells the compiler that it is the end of the instruction and that whatever follows it is a new instruction. We call an instruction that’s been terminated by a semicolon a <code>statement</code>.</p>
			<p>Note that the compiler doesn’t care whether you leave a new line or even a space between the semicolon and the next statement. However, not starting a new line for each statement will lead to desperately hard-to-read code, and missing the semicolon altogether will result in a <strong class="bold">syntax error</strong> and the game will not compile or run.</p>
			<p>A section of code together, often denoted by its indentation with the rest of the section, is called a <strong class="bold">block</strong>.</p>
			<p>Now that you’re comfortable with the idea of the <code>main</code> function, indenting your code to keep it tidy, and putting a semicolon on the end of each statement, we can move on to finding out exactly what the <code>return 0;</code> statement actually does.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Returning values from a function</h2>
			<p>Actually, <code>return 0;</code> does almost nothing in the context of our game. The concept, however, is an important one. When we use the <code>return</code> keyword, either on its own or followed by a value, it is an instruction for the program execution to jump/move back to the code that got the function started in the first place. </p>
			<p>Often, the code that got the function started will be yet another function somewhere else in our code. In this case, however, it is the operating system that started the <code>main</code> function. So, when <code>return 0;</code> is executed, the <code>main</code> function exits and the entire program ends.</p>
			<p>Since we have a <code>0</code> after the <code>return</code> keyword, that value is also sent to the operating system. We could change the value of 0 to something else and that value would be sent back instead.</p>
			<p>We say that the code that starts a function <strong class="bold">calls</strong> the function and that the function <strong class="bold">returns</strong> the value.</p>
			<p>You don’t need to fully grasp all this function information just yet. It is just useful to introduce it here. There’s one last thing on functions that I will cover before we move on. Remember the <code>int</code> from <code>int main()</code>? This tells the compiler that the type of value that’s returned from <code>main</code> must be an <code>int</code> (integer/whole number). We can return any value that qualifies as an <code>int</code>; perhaps 0, 1, 999, 6,358, and so on. If we try and return something that isn’t an <code>int,</code> perhaps 12.76, then the code won’t compile, and the game won’t run.</p>
			<p>Functions can return a big selection of different types, including types that we invent for ourselves! That type, however, must be made known to the compiler in the way we have just seen.</p>
			<p>This little bit of background information on functions will make things smoother as we progress.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Running the game</h2>
			<p>You can even run the game at this point. Do so by clicking the <strong class="bold">Local Windows Debugger</strong> button in the quick-launch bar of Visual Studio. Alternatively, you can use the <em class="italic">F5</em> shortcut key:</p>
			<div><div><img src="img/B14278_01_34.jpg" alt=""/>
				</div>
			</div>
			<p>You will just get a black screen. If the black screen doesn’t automatically close itself, you can tap any key to close it. This window is the C++ console, and we can use this to debug our game. We don’t need to do this now. What is happening is that our program is starting, executing from the first line of <code>main</code>, which is <code>return 0;</code>, and then immediately exiting back to the operating system.</p>
			<p>We now have the simplest program possible coded and running. We will now add some more code to open a window that the game will eventually appear in.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/>Opening a window using SFML</h1>
			<p>Now, let’s add some more code. The code that follows will open a window using SFML that Timber!!! will eventually run in. The window will be 1,920 pixels wide by 1,080 pixels high, and will be full screen (no border or title). </p>
			<p>Enter the new code that is highlighted here to the existing code and then we will examine it. As you type (or copy and paste), try and work out what is going on:</p>
			<pre>// Include important libraries here
<strong class="bold">#include &lt;SFML/Graphics.hpp&gt;</strong>
<strong class="bold">// Make code easier to type with “using namespace”</strong>
<strong class="bold">using namespace sf;</strong>
// This is where our game starts from
int main()
{
<strong class="bold">    // Create a video mode object</strong>
<strong class="bold">    VideoMode vm(1920, 1080);</strong>
<strong class="bold">    // Create and open a window for the game</strong>
<strong class="bold">    RenderWindow window(vm, “Timber!!!”, Style::Fullscreen);</strong>
<strong class="bold">    </strong>return 0;
}</pre>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>#including SFML features</h2>
			<p>The first thing we will notice in our new code is the <code>#include</code> directive.</p>
			<p>The <code>#include</code> <code>.hpp</code> file extension means it is a <strong class="bold">header</strong> file.</p>
			<p>Therefore, <code>#include &lt;SFML/Graphics.hpp&gt;</code> tells the preprocessor to include the contents of the <code>Graphics.hpp</code> file that is contained within the folder named <code>SFML.</code> It is the same folder that we created while setting up the project.</p>
			<p>This line adds code from the aforementioned file, which gives us access to some of the features of SFML. Exactly how it achieves this will become clearer when we start writing our own separate code files and using <code>#include</code> to use them.</p>
			<p>The main files that we will be including throughout this book are the SFML header files that give us access to all the cool game-coding features. We will also use <code>#include</code> to access the <strong class="bold">C++ Standard Library</strong> header files. These header files give us access to core features of the C++ language itself.</p>
			<p>What matters for now is that we have a whole bunch of new functionalities that have been provided by SFML available to use if we add that single line of code.</p>
			<p>The next new line is <code>using namespace sf;</code>. We will come back to what this line does soon.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>OOP, classes, and objects</h2>
			<p>We will fully discuss OOP, classes, and objects as we proceed through this book. What follows is a brief introduction so that we can understand what is happening. </p>
			<p>We already know that OOP stands for object-oriented programming. OOP is a programming paradigm, that is, a <em class="italic">way</em> of coding. OOP is generally accepted throughout the world of programming, in almost every language, as the best, if not the only, professional way to write code.</p>
			<p>OOP introduces a lot of coding concepts, but fundamental to them all are <strong class="bold">classes</strong> and <strong class="bold">objects</strong>. When we write code, whenever possible, we want to write code that is reusable, maintainable, and secure. The way we do this is by structuring our code as a class. We will learn how to do this in <a href="B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 6</em></a><em class="italic">, Object-Oriented Programming – Starting the Pong Game</em>.</p>
			<p>All we need to know about classes for now is that once we have coded our class, we don’t just execute that code as part of our game; instead, we create usable objects <em class="italic">from</em> the class.</p>
			<p>For example, if we wanted 100 zombie <code>Zombie</code> and then, from that single class, create as many zombie objects as we like. Each and every zombie object would have the same functionality and internal data types, but each and every zombie object would be a separate and distinct entity.</p>
			<p>To take the hypothetical zombie example further but without showing any code for the <code>Zombie</code> class, we might create a new object based on the <code>Zombie</code> class, like this:</p>
			<pre>Zombie z1;</pre>
			<p>The <code>z1</code> object is now a fully coded and functioning <code>Zombie</code> object. We could then do this:</p>
			<pre>Zombie z2;
Zombie z3;
Zombie z4;
Zombie z5;</pre>
			<p>We now have five separate <code>Zombie</code> <code>Zombie</code> class to enable us to use our <code>Zombie</code> objects, perhaps like this:</p>
			<pre>z1.attack(player);
z2.growl();
z3.headExplode();</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note again that all this zombie code is hypothetical for the moment. Don’t type this code into to Visual Studio – it will just produce a bunch of errors.</p>
			<p>We would design our class so that we can use the data and behaviors in the most appropriate manner to suit our game’s objectives. For example, we could design our class so that we can assign values for the data for each zombie object at the time we create it. </p>
			<p>Let’s say we need to assign a unique name and speed in meters per second at the time we create each zombie. Careful coding of the <code>Zombie</code> class could enable us to write code like this:</p>
			<pre>// Dave was a 100 metre Olympic champion before infection 
// He moves at 10 metres per second
Zombie z1(“Dave”, 10);
// Gill had both of her legs eaten before she was infected
// She drags along at .01 metres per second
Zombie z2(“Gill”, .01);</pre>
			<p>The point is that classes are almost infinitely flexible, and once we have coded the class, we can go about using them by creating an object/instance <em class="italic">of</em> them. It is through classes and the objects that we create from them that we will harness the power of SFML. And yes, we will also write our own classes, including a <code>Zombie</code> class. </p>
			<p>Let’s get back to the real code we just wrote.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Using namespace sf</h2>
			<p>Before we move on and look more closely at <code>VideoMode</code> and <code>RenderWindow</code>, which as you have probably guessed are classes provided by SFML, we will learn what the <code>using namespace sf; </code>line of code does.</p>
			<p>When we create a class, we do so in a <code>VideoMode</code> class. It is entirely possible that, in an environment such as Windows, somebody has already written a class called <code>VideoMode</code>. By using a namespace, we and the SFML programmers can make sure that the names of classes never clash.</p>
			<p>The full way of using the <code>VideoMode</code> class is like this:</p>
			<pre>sf::VideoMode...</pre>
			<p><code>using namespace sf; </code>enables us to omit the <code>sf::</code> prefix from everywhere in our code. Without it, there would be over 100 instances of <code>sf::</code> in this simple game alone. It also makes our code more readable, as well as shorter.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/>SFML VideoMode and RenderWindow</h2>
			<p>Inside the <code>main</code> function, we now have two new comments and two new lines of actual code. The first line of actual code is this:</p>
			<pre>VideoMode vm(1920, 1080);</pre>
			<p>This code creates an object called <code>vm</code> from the class called <code>VideoMode</code> and sets up two internal values of <code>1920</code> and <code>1080</code>. These values represent the resolution of the player’s screen.</p>
			<p>The next new line of code is as follows:</p>
			<pre>RenderWindow window(vm, “Timber!!!”, Style::Fullscreen);</pre>
			<p>In the previous line of code, we are creating a new object called <code>window</code> from the SFML-provided class called <code>RenderWindow</code>. Furthermore, we are setting up some values inside our window object. </p>
			<p>Firstly, the <code>vm</code> object is used to initialize part of <code>window</code>. At first, this might seem confusing. Remember, however, that a class can be as varied and flexible as its creator wants to make it. And yes, some classes can contain other instances of other classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It is not necessary to fully understand how this works at this point, as long as you appreciate the concept. We code a class and then make useable objects from that class – a bit like an architect might draw a blueprint. You certainly can’t move all your furniture, kids, and dog into the blueprint, but you could build a house (or many houses) from the blueprint. In this analogy, a class is like a blueprint and an object is like a house.</p>
			<p>Next, we use the <code>“Timber!!!”</code> value to give the window a name. Then, we use the predefined <code>Style::FullScreen</code> value to make our <code>window</code> object fullscreen.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><code>Style::FullScreen</code> is a value that’s defined in SFML. It is useful because we don’t need to remember the integer number the internal code uses to represent a full screen. The coding term for this type of value is <code>constant</code>. Constants and their close C++ relatives, <strong class="bold">variables</strong>, are covered in the next chapter.</p>
			<p>Let’s take a look at our window object in action.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/>Running the game</h2>
			<p>You can run the game again at this point. You will see a bigger black screen flash on and then disappear. This is the 1,920 x 1,080 fullscreen window that we just coded. Unfortunately, what is still happening is that our program is starting, executing from the first line of <code>main</code>, creating the cool new game window, then coming to <code>return 0;</code> and immediately exiting back to the operating system.</p>
			<p>Next, we will add some code that will form the basic structure of every game in this book. This is known as the game loop.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor052"/>The main game loop</h1>
			<p>We need a way to stay in the program until the player wants to quit. At the same time, we should clearly mark out where the different parts of our code will go as we progress with Timber!!!. Furthermore, if we are going to stop our game from exiting, we had better provide a way for the player to exit when they are ready; otherwise, the game will go on forever!</p>
			<p>Add the following highlighted code to the existing code and then we will go through it and discuss it all:</p>
			<pre>int main()
{
<strong class="bold">    </strong>// Create a video mode object
<strong class="bold">    </strong>VideoMode vm(1920, 1080);
<strong class="bold">    </strong>// Create and open a window for the game
<strong class="bold">    </strong>RenderWindow window(vm,	“Timber!!!”, Style::Fullscreen);
<strong class="bold">    while (window.isOpen())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        /*</strong>
<strong class="bold">        ****************************************</strong>
<strong class="bold">        Handle the players input</strong>
<strong class="bold">        ****************************************</strong>
<strong class="bold">        */</strong>
<strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::Escape))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            window.close();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        /*</strong>
<strong class="bold">        ****************************************</strong>
<strong class="bold">        Update the scene</strong>
<strong class="bold">        ****************************************</strong>
<strong class="bold">        */</strong>
<strong class="bold">        /*</strong>
<strong class="bold">        ****************************************</strong>
<strong class="bold">        Draw the scene</strong>
<strong class="bold">        ****************************************</strong>
<strong class="bold">        */</strong>
<strong class="bold">        // Clear everything from the last frame</strong>
<strong class="bold">        window.clear();</strong>
<strong class="bold">        // Draw our game scene here</strong>
<strong class="bold">        // Show everything we just drew</strong>
<strong class="bold">        window.display();</strong>
<strong class="bold">    }</strong>
    return 0;
}</pre>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>While loops</h2>
			<p>The very first thing we saw in the new code is as follows:</p>
			<pre>while (window.isOpen())
{</pre>
			<p>The very last thing we saw in the new code is a closing <code>}</code>. We have created a <code>{</code>) and closing (<code>}</code>) brackets of the <code>while</code> loop will continue to execute, over and over, potentially forever.</p>
			<p>Look closely between the parentheses <code>(...)</code> of the <code>while</code> loop, as shown here:</p>
			<pre>while (<strong class="bold">window.isOpen()</strong>)</pre>
			<p>The full explanation of this code will have to wait until we discus loops and conditions in <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a><em class="italic">, Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>. What is important for now is that when the <code>window</code> object is set to closed, the execution of the code will break out of the <code>while</code> loop and move on to the next statement. Exactly how a window is closed is covered soon.</p>
			<p>The next statement is, of course, <code>return 0;</code>, which ends our game.</p>
			<p>We now know that our <code>while</code> loop will whiz round and round, repeatedly executing the code within it, until our window object is set to closed.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>C-style code comments</h2>
			<p>Just inside the <code>while</code> loop, we can see what, at first glance, might look a bit like ASCII art:</p>
			<pre><strong class="bold">        </strong>/*
<strong class="bold">        </strong>****************************************
<strong class="bold">        </strong>Handle the player’s input
<strong class="bold">        </strong>****************************************
<strong class="bold">        </strong>*/</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">ASCII art is a niche but fun way of creating images with computer text. You can read more about it here: <a href="https://en.wikipedia.org/wiki/ASCII_art">https://en.wikipedia.org/wiki/ASCII_art</a>.</p>
			<p>The previous code is simply another type of comment. This type of comment is known as a C-style comment. The comment begins with (<code>/*</code>) and ends with (<code>*/</code>). Anything in between is just for information and is not compiled. I have used this slightly elaborate text to make it absolutely clear what we will be doing in each part of the code file. And of course, you can now work out that any code that follows will be related to handling the player’s input.</p>
			<p>Skip over a few lines of code and you will see that we have another C-style comment, announcing that in that part of the code, we will be updating the scene.</p>
			<p>If you jump to the next C-style comment, it will be clear where we will be drawing all the graphics.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Input, update, draw, repeat</h2>
			<p>Although this first project uses the simplest possible version of a game loop, every game will need these phases in the code. Let’s go over the steps:</p>
			<ol>
				<li value="1">Get the player’s input (if any).</li>
				<li>Update the scene based on things such as artificial intelligence, physics, or the player’s input.</li>
				<li>Draw the current scene.</li>
				<li>Repeat these steps at a fast-enough rate to create a smooth, animated game world.</li>
			</ol>
			<p>Now, let’s look at the code that actually does something within the game loop.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Detecting a key press</h2>
			<p>Firstly, within the section that’s identifiable by the comment with the <code>Handle the player’s input</code> text, we have the following code:</p>
			<pre>if (Keyboard::isKeyPressed(Keyboard::Escape))
{
<strong class="bold">        window.close();</strong>
}</pre>
			<p>This code checks whether the <em class="italic">Esc</em> key is currently being pressed. If it is, the highlighted code uses the <code>window</code> object to close itself. Now, the next time the <code>while</code> loop begins, it will see that the <code>window</code> object is closed and jump to the code immediately after the closing curly brace of the <code>while</code> loop and the game will exit. We will discuss<code> if</code> statements more fully in <a href="B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 2</em></a><em class="italic">, Variables, Operators, and Decisions – Animating Sprites</em>.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Clearing and drawing the scene </h2>
			<p>Currently, there is no code in the <code>Update the scene</code> section, so let’s move on to the <code>Draw the scene</code> section.</p>
			<p>The first thing we will do is rub out the previous frame of animation using the following code:</p>
			<pre>window.clear();</pre>
			<p>What we would do now is draw every object from the game. However, we don’t have any game objects.</p>
			<p>The next line of code is as follows:</p>
			<pre>window.display();</pre>
			<p>When we draw all the game objects, we are drawing them to a hidden surface ready to be displayed. The <code>window.display()</code> code flips from the previously displayed surface to the newly updated (previously hidden) one. This way, the player will never see the drawing process as the surface has all the sprites added to it. It also guarantees that the scene will be complete before it is flipped. This prevents a graphical glitch known as <strong class="bold">tearing</strong>. This process is called <strong class="bold">double buffering</strong>.</p>
			<p>Also note that all this drawing and clearing functionality is performed using our <code>window</code> object, which was created from the SFML <code>RenderWindow</code> class.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Running the game</h2>
			<p>Run the game and you will get a blank, full screen window that remains open until you press the <em class="italic">Esc</em> key. </p>
			<p>That is good progress. At this stage, we have an executing program that opens a window and loops around, waiting for the player to press the <em class="italic">Esc</em> key to exit. Now, we are able to move on to drawing the background image of the game.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>Drawing the game’s background</h1>
			<p>Now, we will get to see some graphics in our game. What we need to do is create a sprite. The first one we will create will be the game background. We can then draw it in between clearing the window and displaying/flipping it.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Preparing the Sprite using a Texture</h2>
			<p>The SFML <code>RenderWindow</code> class allowed us to create our <code>window</code> object, which basically took care of all the functionality that our game’s window needs. </p>
			<p>We will now look at two more SFML classes that will take care of drawing sprites to the screen. One of these classes, perhaps unsurprisingly, is called <code>Sprite</code>. The other class is called <code>Texture</code>. A texture is a graphic stored in memory, on the <strong class="bold">graphics processing unit</strong> (<strong class="bold">GPU</strong>).</p>
			<p>An object that’s made from the <code>Sprite</code> class needs an object made from the <code>Texture</code> class in order to display itself as an image. Add the following highlighted code. Try and work out what is going on as well. Then, we will go through it, a line at a time:</p>
			<pre>int main()
{
    // Create a video mode object
    VideoMode vm(1920, 1080);
    // Create and open a window for the game
    RenderWindow window(vm,	“Timber!!!”, Style::Fullscreen);
    <strong class="bold">// Create a texture to hold a graphic on the GPU</strong>
    <strong class="bold">Texture textureBackground;</strong>
    <strong class="bold">// Load a graphic into the texture</strong>
    <strong class="bold">textureBackground.loadFromFile(“graphics/background.png”);</strong>
    <strong class="bold">// Create a sprite</strong>
    <strong class="bold">Sprite spriteBackground;</strong>
    <strong class="bold">// Attach the texture to the sprite</strong>
    <strong class="bold">spriteBackground.setTexture(textureBackground);</strong>
    <strong class="bold">// Set the spriteBackground to cover the screen</strong>
    <strong class="bold">spriteBackground.setPosition(0,0);</strong>
    while (window.isOpen())
    {</pre>
			<p>First, we create an object called <code>textureBackground</code> from the SFML <code>Texture</code> class: </p>
			<pre>Texture textureBackground;</pre>
			<p>Once this is done, we can use the <code>textureBackground</code> object to load a graphic from our <code>graphics</code> folder into <code>textureBackground</code>, like this:</p>
			<pre>textureBackground.loadFromFile(“graphics/background.png”);</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">We only need to specify <code>graphics/background</code> as the path is relative to the Visual Studio <strong class="bold">working directory</strong> where we created the folder and added the image.</p>
			<p>Next, we create an object called <code>spriteBackground</code> from the SFML <code>Sprite</code> class with this code:</p>
			<pre>Sprite spriteBackground;</pre>
			<p>Then, we can associate the <code>Texture</code> object (<code>backgroundTexture</code>) with the <code>Sprite</code> object (<code>backgroundSprite</code>), like this:</p>
			<pre>spriteBackground.setTexture(textureBackground);</pre>
			<p>Finally, we can position the <code>spriteBackground</code> object in the <code>window</code> object at the <code>0,0</code> coordinates:</p>
			<pre>spriteBackground.setPosition(0,0);</pre>
			<p>Since the <code>background.png</code> graphic in the graphics folder is 1,920 pixels wide by 1,080 pixels high, it will neatly fill the entire screen. Just note that this previous line of code doesn’t actually show the sprite. It just sets its position, ready for when it is shown.</p>
			<p>The <code>backgroundSprite</code> object can now be used to display the background graphic. Of course, you are almost certainly wondering why we had to do things in such a convoluted way. The reason is because of the way that graphics cards and OpenGL work.</p>
			<p>Textures take up graphics memory, and this memory is a finite resource. Furthermore, the process of loading a graphic into the GPU’s memory is very slow – not so slow that you can watch it happen or that you will see your PC noticeably slow down while it is happening, but slow enough that you can’t do it every frame of the game loop. So, it is useful to disassociate the actual texture (<code>textureBackground</code>) from any code that we will manipulate during the game loop.</p>
			<p>As you will see when we start to move our graphics, we will do so using the sprite. Any objects that are made from the <code>Texture</code> class will sit happily on the GPU, just waiting for an associated <code>Sprite</code> object to tell it where to show itself. In later projects, we will also reuse the same <code>Texture</code> object with multiple different <code>Sprite</code> objects, which makes efficient use of GPU memory.</p>
			<p>In summary, we can state the following:</p>
			<ul>
				<li>Textures are very slow to load onto the GPU.</li>
				<li>Textures are very fast to access once they are on the GPU.</li>
				<li>We associate a <code>Sprite</code> object with a texture.</li>
				<li>We manipulate the position and orientation of <code>Sprite</code> objects (usually in the <code>Update the scene </code>section).</li>
			</ul>
			<p>We draw the <code>Sprite</code> object, which, in turn, displays the <code>Texture</code> object that is associated with it (usually in the <code>Draw the scene </code>section). So, all we need to do now is use our double buffering system, which is provided by our <code>window</code> object, to draw our new <code>Sprite</code> object (<code>spriteBackground</code>), and we should get to see our game in action.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Double buffering the background sprite</h2>
			<p>Finally, we need to draw that sprite and its associated texture in the appropriate place in the game loop. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note that when I present code that is all from the same block, I don’t add the indentations because it lessens the instances of line wraps in the text of the book. The indenting is implied. Check out the code file in the download bundle to see full use of indenting.</p>
			<p>Add the following highlighted code:</p>
			<pre>/*
****************************************
Draw the scene
****************************************
*/
// Clear everything from the last run frame
window.clear();
// Draw our game scene here
<strong class="bold">window.draw(spriteBackground);</strong>
// Show everything we just drew
window.display();</pre>
			<p>The new line of code simply uses the <code>window</code> object to draw the <code>spriteBackground</code> object, in between clearing the display and showing the newly drawn scene.</p>
			<p>We now know what a sprite is, and that we can associate a texture with it and then position it on the screen and finally draw it. The game is ready to be run again so that we can see the results of this code.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Running the game</h2>
			<p>If we run the program now, we will see the first signs that we have a real game in progress:</p>
			<div><div><img src="img/B14278_01_35.jpg" alt=""/>
				</div>
			</div>
			<p>It’s not going to get Indie Game of the Year on Steam in its current state, but we are on the way at least!</p>
			<p>Let’s look at some of the things that might go wrong in this chapter and as we proceed through this book.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor063"/>Handling errors</h1>
			<p>There will always be problems and errors in every project you make. This is guaranteed! The tougher the problem, the more satisfying it is when you solve it. When, after hours of struggling, a new game feature finally bursts into life, it can cause a genuine high. Without this struggle, it would somehow be less worthwhile.</p>
			<p>At some point in this book, there will probably be some struggle. Remain calm, be confident that you will overcome it, and then get to work.</p>
			<p>Remember that, whatever your problem, it is very likely you are <strong class="bold">not</strong> the first person in the world to have ever had this same problem. Think of a concise sentence that describes your problem or error and then type it into Google. You will be surprised how quickly, precisely, and often, someone else will have already solved your problem for you.</p>
			<p>Having said that, here are a few pointers (pun intended; see <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a><em class="italic">, Pointers, the Standard Template Library, and Texture Management</em>) to get you started in case you are struggling with making this first chapter work.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>Configuration errors</h2>
			<p>The most likely cause of problems in this chapter will be <strong class="bold">configuration errors</strong>. As you probably noticed during the process of setting up Visual Studio, SFML and the project itself, there’s an awful lot of filenames, folders, and settings that need to be just right. Just one wrong setting could cause one of a number of errors, whose text don’t make it clear exactly what is wrong.</p>
			<p>If you can’t get the empty project with the black screen working, it might be easier to start again. Make sure all the filenames and folders are appropriate for your specific setup and then get the simplest part of the code running. This is the part where the screen flashes black and then closes. If you can get to this stage, then configuration is probably not the issue.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Compile errors</h2>
			<p>Compile errors are probably the most common error we will experience going forward. Check that your code is identical to mine, especially semicolons on the ends of lines and subtle changes in upper and lower case for class and object names. If all else fails, open the code files in the download bundle and copy and paste it in. While it is always possible that a code typo made it into this book, the code files were made from actual working projects – they definitely work!</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Link errors</h2>
			<p>Link errors are most likely caused by missing SFML <code>.dll</code> files. Did you copy all of them into the project folder?</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>Bugs</h2>
			<p>Bugs are what happen when your code works, but not as you expect it to. Debugging can actually be fun. The more bugs you squash, the better your game and the more satisfying your day’s work will be. The trick to solving bugs is to find them early! To do this, I recommend running and playing your game every time you implement something new. The sooner you find the bug, the more likely the cause will be fresh in your mind. In this book, we will run the code to see the results at every possible stage.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Summary</h1>
			<p>This was quite a challenging chapter and perhaps a little bit mean to be the first one. It is true that configuring an IDE to use a C++ library can be a bit awkward and long. Also, the concepts of classes and objects are well known to be slightly awkward for people who are new to coding.</p>
			<p>Now that we are at this stage, however, we can totally focus on C++, SFML, and games. As we progress with this book, we will learn more and more C++, as well as implement increasingly interesting game features. As we do so, we will take a further look at things such as functions, classes, and objects to help demystify them a little more. </p>
			<p>We have achieved plenty in this chapter, including outlining a basic C++ program with the main function, constructing a simple game loop that listens for player input and draws a sprite (along with its associated texture) to the screen. </p>
			<p>In the next chapter, we will learn about all the C++ we need to draw some more sprites and animate them.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) I am struggling with the content that’s been presented so far. Am I cut out for programming?</p>
			<p>A) Setting up a development environment and getting your head around OOP as a concept is probably the toughest thing you will do in this book. As long as your game is functioning (drawing the background), you are ready to proceed with the next chapter.</p>
			<p>Q) All this talk of OOP, classes, and objects is too much and kind of spoiling the whole learning experience.</p>
			<p>A) Don’t worry. We will keep returning to OOP, classes, and objects constantly. In <a href="B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 6</em></a>, <em class="italic">Object-Oriented Programming – Starting the Pong Game</em>, we will really begin getting to grips with the whole OOP thing. All you need to understand for now is that SFML have written a whole load of useful classes and that we get to use this code by creating usable objects from those classes. </p>
			<p>Q) I really don’t get this function stuff.</p>
			<p>A) It doesn’t matter; we will be returning to it again constantly and will learn about functions more thoroughly. You just need to know that, when a function is called, its code is executed, and when it is done (reaches a <code>return</code> statement), the program jumps back to the code that called it.</p>
		</div>
	</body></html>