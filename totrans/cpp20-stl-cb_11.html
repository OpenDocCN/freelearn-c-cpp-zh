<html><head></head><body>
		<div id="_idContainer051">
			<h1 id="_idParaDest-348"><em class="italic"><a id="_idTextAnchor347"/>Chapter 11</em>: A Few More Ideas</h1>
			<p>We've learned some useful techniques in this book, including optional values, containers, iterators, algorithms, smart pointers, and more. We've seen examples of these concepts in use, and we've had the opportunity to experiment and apply them to some small projects. Let's now apply these techniques to a few more practical ideas.</p>
			<p>In this chapter, we cover the following recipes:</p>
			<ul>
				<li>Create a trie class for search suggestions</li>
				<li>Calculate the error sum of two vectors</li>
				<li>Build your own algorithm: <strong class="source-inline">split</strong></li>
				<li>Leverage existing algorithms: <strong class="source-inline">gather</strong></li>
				<li>Remove consecutive whitespace</li>
				<li>Convert numbers to words</li>
			</ul>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor348"/>Technical requirement</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11</a>.</p>
			<h1 id="_idParaDest-350"><a id="_idTextAnchor349"/>Create a trie class for search suggestions</h1>
			<p>A <em class="italic">trie</em>, sometimes <a id="_idIndexMarker1076"/>called <a id="_idIndexMarker1077"/>a <em class="italic">prefix tree</em>, is a <a id="_idIndexMarker1078"/>type of search tree, commonly used for predictive text and other search applications. A trie is a recursive structure designed for depth-first searches, where each <em class="italic">node</em> is both a key and another trie.</p>
			<p>A common use case is a <em class="italic">trie of strings</em>, where each node is a string in a sentence. For example:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B18267_11_01.jpg" alt="Figure 11.1 – A trie of strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – A trie of strings</p>
			<p>We often start a search at the <em class="italic">head</em> of a trie, looking for sentences that begin with a specific word. In this example, when I search for <strong class="source-inline">all</strong>, I get three nodes: <strong class="source-inline">you</strong>, <strong class="source-inline">the</strong>, and <strong class="source-inline">along</strong>. If I search for <strong class="source-inline">love</strong>, I get <strong class="source-inline">me</strong> and <strong class="source-inline">is</strong>.</p>
			<p>A string trie is <a id="_idIndexMarker1079"/>commonly used for creating search<a id="_idIndexMarker1080"/> suggestions. Here we will implement a string trie using <strong class="source-inline">std::map</strong> for the trie structure.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor350"/>How to do it…</h2>
			<p>In this recipe, we create a recursive <strong class="source-inline">trie</strong> class that stores nodes in a <strong class="source-inline">std::map</strong> container. It's a simple solution for a small in-memory trie. This is a rather large class, so we'll only show the important parts here.</p>
			<p>For the full class, please see the source code at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp</a>.</p>
			<ul>
				<li>We have one convenience alias:<p class="source-code">using ilcstr = initializer_list&lt;const char *&gt;;</p></li>
			</ul>
			<p>We use <strong class="source-inline">ilcstr</strong> in for searching the <strong class="source-inline">trie</strong>.</p>
			<ul>
				<li>We'll put this class in a private namespace to avoid collisions:<p class="source-code">namespace <strong class="bold">bw</strong> {</p><p class="source-code">    <strong class="bold">using</strong> std::map;</p><p class="source-code">    <strong class="bold">using</strong> std::deque;</p><p class="source-code">    <strong class="bold">using</strong> std::initializer_list;</p></li>
			</ul>
			<p>We have a few <strong class="source-inline">using</strong> statements in this namespace for convenience.</p>
			<ul>
				<li>The class <a id="_idIndexMarker1081"/>itself is called <strong class="source-inline">trie</strong>. It has <a id="_idIndexMarker1082"/>three data members:<p class="source-code">class trie {</p><p class="source-code">    using <strong class="bold">get_t</strong> = deque&lt;deque&lt;string&gt;&gt;;</p><p class="source-code">    using <strong class="bold">nodes_t</strong> = map&lt;string, trie&gt;;</p><p class="source-code">    using <strong class="bold">result_t</strong> = std::optional&lt;const trie*&gt;;</p><p class="source-code">    nodes_t <strong class="bold">nodes</strong>{};</p><p class="source-code">    mutable get_t <strong class="bold">result_dq</strong>{};</p><p class="source-code">    mutable deque&lt;string&gt; <strong class="bold">prefix_dq</strong>{};</p></li>
			</ul>
			<p>The <strong class="source-inline">trie</strong> class has a few local type aliases:</p>
			<ul>
				<li><strong class="source-inline">get_t</strong> is a <strong class="source-inline">deque</strong> of <strong class="source-inline">deque</strong> of <strong class="source-inline">string</strong>, used for string results.</li>
				<li><strong class="source-inline">nodes_t </strong>is a map of <strong class="source-inline">trie</strong> classes with <strong class="source-inline">string</strong> keys.</li>
				<li><strong class="source-inline">result_t</strong> is an <strong class="source-inline">optional</strong> of a pointer to a <strong class="source-inline">trie</strong>, for returning search results. An empty <strong class="source-inline">trie</strong> is a valid result, so we use an <strong class="source-inline">optional</strong> value.</li>
			</ul>
			<p>The <strong class="source-inline">nodes</strong> object is used for holding a recursive <strong class="source-inline">map</strong> of nodes, where each node on a <strong class="source-inline">trie</strong> is another <strong class="source-inline">trie</strong>.</p>
			<ul>
				<li>The public interface often calls utility functions in the private interface. For example, the <strong class="source-inline">insert()</strong> method takes an <strong class="source-inline">initializer_list</strong> object and calls the private function <strong class="source-inline">_insert()</strong>:<p class="source-code">void insert(const ilcstr&amp; il) {</p><p class="source-code">    _insert(il.begin(), il.end());</p><p class="source-code">}</p></li>
			</ul>
			<p>The private <strong class="source-inline">_insert()</strong> function does the work of inserting elements:</p>
			<p class="source-code">template &lt;typename It&gt;</p>
			<p class="source-code">void _insert(It it, It end_it) {</p>
			<p class="source-code">    if(it == end_it) return;</p>
			<p class="source-code">    <strong class="bold">nodes[*it]</strong>._insert(++it, end_it);</p>
			<p class="source-code">}</p>
			<p>This <a id="_idIndexMarker1083"/>facilitates<a id="_idIndexMarker1084"/> the recursive function calls necessary to navigate the <strong class="source-inline">trie</strong>. Note that referencing a key that does not appear in a <strong class="source-inline">map</strong> creates an empty element with that key. So, the line that calls <strong class="source-inline">_insert()</strong> on a <strong class="source-inline">nodes</strong> element creates an empty <strong class="source-inline">trie</strong> object if the element doesn't already exist.</p>
			<ul>
				<li>The <strong class="source-inline">get()</strong> method returns a <strong class="source-inline">get_t</strong> object, which is an alias for a <strong class="source-inline">deque</strong> of <strong class="source-inline">deque</strong> of <strong class="source-inline">string</strong>. This allows us to return multiple sets of results:<p class="source-code"><strong class="bold">get_t</strong>&amp; get() const {</p><p class="source-code">    result_dq.clear();</p><p class="source-code">    deque&lt;string&gt; dq{};</p><p class="source-code">    <strong class="bold">_get(dq, result_dq)</strong>;</p><p class="source-code">    return result_dq;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">get()</strong> method calls the private <strong class="source-inline">_get()</strong> function, which recursively traverses the <strong class="source-inline">trie</strong>:</p>
			<p class="source-code">void <strong class="bold">_get(deque&lt;string&gt;&amp; dq, get_t&amp; r_dq)</strong> const {</p>
			<p class="source-code">    if(empty()) {</p>
			<p class="source-code">        r_dq.emplace_back(dq);</p>
			<p class="source-code">        dq.clear();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    for(const auto&amp; p : nodes) {</p>
			<p class="source-code">        dq.emplace_back(p.first);</p>
			<p class="source-code">        <strong class="bold">p.second._get(dq, r_dq)</strong>;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ul>
				<li>The <strong class="source-inline">find_prefix()</strong> function <a id="_idIndexMarker1085"/>returns a <strong class="source-inline">deque</strong> with<a id="_idIndexMarker1086"/> all matches to a partial string.<p class="source-code">deque&lt;string&gt;&amp; find_prefix(const char * s) const {</p><p class="source-code">    <strong class="bold">_find_prefix(s, prefix_dq);</strong></p><p class="source-code">    return prefix_dq;</p><p class="source-code">}</p></li>
			</ul>
			<p>The public interface calls the private function <strong class="source-inline">_find_prefix()</strong>:</p>
			<p class="source-code">void _find_prefix(const string&amp; s, auto&amp; pre_dq) const {</p>
			<p class="source-code">    if(empty()) return;</p>
			<p class="source-code">    for(const auto&amp; [k, v] : nodes) {</p>
			<p class="source-code">        if(<strong class="bold">k.starts_with(s)</strong>) {</p>
			<p class="source-code">            pre_dq.emplace_back(k);</p>
			<p class="source-code">            v._find_prefix(k, pre_dq);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The private <strong class="source-inline">_find_prefix()</strong> function traverses the <strong class="source-inline">trie</strong> recursively, comparing the prefix with beginning of each key. The <strong class="source-inline">starts_with()</strong> method is new with C++20. With an older STL, you could use the <strong class="source-inline">find()</strong> method and check the return value for <strong class="source-inline">0</strong>:</p>
			<p class="source-code">if(<strong class="bold">k.find(s) == 0</strong>) {</p>
			<p class="source-code">    ...</p>
			<ul>
				<li>The <strong class="source-inline">search()</strong> function returns an <strong class="source-inline">optional&lt;const trie*&gt;</strong>, aliased as <strong class="source-inline">result_t</strong>. It has<a id="_idIndexMarker1087"/> two<a id="_idIndexMarker1088"/> overloads:<p class="source-code">result_t search(const ilcstr&amp; il) const {</p><p class="source-code">    return <strong class="bold">_search</strong>(il.begin(), il.end());</p><p class="source-code">}</p><p class="source-code">result_t search(const string&amp; s) const {</p><p class="source-code">    const ilcstr il{s.c_str()};</p><p class="source-code">    return <strong class="bold">_search</strong>(il.begin(), il.end());</p><p class="source-code">}</p></li>
			</ul>
			<p>These methods pass iterators to the private member function <strong class="source-inline">_search()</strong>, which does the work of the search:</p>
			<p class="source-code">template &lt;typename It&gt;</p>
			<p class="source-code">result_t _search(It it, It end_it) const {</p>
			<p class="source-code">    <strong class="bold">if(it == end_it) return {this};</strong></p>
			<p class="source-code">    auto found_it = nodes.find(*it);</p>
			<p class="source-code">    <strong class="bold">if(found_it == nodes.end()) return {};</strong></p>
			<p class="source-code">    <strong class="bold">return found_it-&gt;second._search(++it, end_it);</strong></p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">_search()</strong> function searches recursively until it finds a match, then returns a node in the <strong class="source-inline">result_t</strong> object. If it finds no match, it returns the non-value <strong class="source-inline">optional</strong>.</p>
			<ul>
				<li>We also have two overloads of a <strong class="source-inline">print_trie_prefix()</strong> function. This function prints the contents of a <strong class="source-inline">trie</strong> from a prefix, used as a search key. One version <a id="_idIndexMarker1089"/>uses a <strong class="source-inline">string</strong> for the prefix, the <a id="_idIndexMarker1090"/>other uses an <strong class="source-inline">initializer_list</strong> of C-strings:<p class="source-code">void print_trie_prefix(const bw::trie&amp; t,</p><p class="source-code">        <strong class="bold">const string&amp; prefix</strong>) {</p><p class="source-code">    auto&amp; trie_strings = t.get();</p><p class="source-code">    cout &lt;&lt; format("results for \"{}...\":\n", prefix);</p><p class="source-code">    for(auto&amp; dq : trie_strings) {</p><p class="source-code">        cout &lt;&lt; format("{} ", prefix);</p><p class="source-code">        for(const auto&amp; s : dq) cout &lt;&lt; format("{} ", s);</p><p class="source-code">        cout &lt;&lt; '\n';</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">void print_trie_prefix(const bw::trie&amp; t,</p><p class="source-code">        <strong class="bold">const ilcstr &amp; prefix</strong>) {</p><p class="source-code">    string sprefix{};</p><p class="source-code">    for(const auto&amp; s : prefix) sprefix += </p><p class="source-code">        format("{} ", s);</p><p class="source-code">    print_trie_prefix(t, sprefix);</p><p class="source-code">}</p></li>
			</ul>
			<p>These functions call the <strong class="source-inline">get()</strong> member function to retrieve the results from the <strong class="source-inline">trie</strong>.</p>
			<ul>
				<li>Now we can<a id="_idIndexMarker1091"/> test <a id="_idIndexMarker1092"/>the <strong class="source-inline">trie</strong> class in the <strong class="source-inline">main()</strong> function. First, we declare a <strong class="source-inline">trie</strong> and insert some sentences:<p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">bw::trie ts</strong>;</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "all", "along", "the", "watchtower" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "all", "you", "need", "is", "love" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "all", "shook", "up" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "all", "the", "best" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "all", "the", "gold", "in",</p><p class="source-code">        "california" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "at", "last" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "love", "the", "one", "you're",        "with" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "love", "me", "do" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "love", "is", "the", "answer" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "loving", "you" });</p><p class="source-code">    <strong class="bold">ts.insert</strong>({ "long", "tall", "sally" });</p><p class="source-code">    ...</p></li>
			</ul>
			<p>The <strong class="source-inline">insert()</strong> calls pass an <strong class="source-inline">initializer_list</strong> with all the strings of a sentence. Each of the strings of a sentence are inserted into the hierarchy of the <strong class="source-inline">trie</strong>.</p>
			<ul>
				<li>Now we can search the trie. Here's a simple search for the single string <strong class="source-inline">"love"</strong>.<p class="source-code">const auto <strong class="bold">prefix = {"love"}</strong>;</p><p class="source-code">if (auto st = <strong class="bold">ts.search(prefix)</strong>; st.have_result) {</p><p class="source-code">    <strong class="bold">print_trie_prefix(*st.t, prefix)</strong>;</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>This calls <strong class="source-inline">ts.search()</strong> with an <strong class="source-inline">initializer_list</strong> of one C-string, called <strong class="source-inline">prefix</strong>. The <a id="_idIndexMarker1093"/>result, along with the <strong class="source-inline">prefix</strong>, is then<a id="_idIndexMarker1094"/> passed to the <strong class="source-inline">print_trie_prefix()</strong> function.</p>
			<p>The output is:</p>
			<p class="source-code"><strong class="bold">results for "love...":</strong></p>
			<p class="source-code"><strong class="bold">love is the answer</strong></p>
			<p class="source-code"><strong class="bold">love me do</strong></p>
			<p class="source-code"><strong class="bold">love the one you're with</strong></p>
			<ul>
				<li>Here's a search for a two-string prefix:<p class="source-code">const auto <strong class="bold">prefix = {"all", "the"}</strong>;</p><p class="source-code">if (auto st = ts.search(prefix); st.have_result) {</p><p class="source-code">    print_trie_prefix(*st.t, prefix);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">results for "all the ...":</strong></p>
			<p class="source-code"><strong class="bold">all the  best</strong></p>
			<p class="source-code"><strong class="bold">all the  gold in california</strong></p>
			<ul>
				<li>And here's<a id="_idIndexMarker1095"/> a <a id="_idIndexMarker1096"/>search for a partial prefix, using the <strong class="source-inline">find_prefix()</strong> function:<p class="source-code">const char * <strong class="bold">prefix{ "lo" }</strong>;</p><p class="source-code">auto prefix_dq = <strong class="bold">ts.find_prefix(prefix)</strong>;</p><p class="source-code">for(const auto&amp; s : prefix_dq) {</p><p class="source-code">    cout &lt;&lt; format("match: {} -&gt; {}\n", prefix, s);</p><p class="source-code">    if (auto st = ts.search(s); st.have_result) {</p><p class="source-code">        print_trie_prefix(*st.t, s);</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">match: lo -&gt; long</strong></p>
			<p class="source-code"><strong class="bold">results for "long...":</strong></p>
			<p class="source-code"><strong class="bold">long tall sally</strong></p>
			<p class="source-code"><strong class="bold">match: lo -&gt; love</strong></p>
			<p class="source-code"><strong class="bold">results for "love...":</strong></p>
			<p class="source-code"><strong class="bold">love is the answer</strong></p>
			<p class="source-code"><strong class="bold">love me do</strong></p>
			<p class="source-code"><strong class="bold">love the one you're with</strong></p>
			<p class="source-code"><strong class="bold">match: lo -&gt; loving</strong></p>
			<p class="source-code"><strong class="bold">results for "loving...":</strong></p>
			<p class="source-code"><strong class="bold">loving you</strong></p>
			<p>The <strong class="source-inline">find_prefix()</strong> search returned several results, each of which we passed to a search of its own, resulting in several results for each result.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor351"/>How it works…</h2>
			<p>The data for the <strong class="source-inline">trie</strong> class is stored in recursive <strong class="source-inline">map</strong> containers. Each node in the <strong class="source-inline">map</strong> contains another <strong class="source-inline">trie</strong> object, which in turn has its own <strong class="source-inline">map</strong> node.</p>
			<p class="source-code">using nodes_t = map&lt;string, trie&gt;</p>
			<p>The <strong class="source-inline">_insert()</strong> function takes <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> iterators, and uses them to recursively call <strong class="source-inline">_insert()</strong> on<a id="_idIndexMarker1097"/> new<a id="_idIndexMarker1098"/> nodes:</p>
			<p class="source-code">template &lt;typename It&gt;</p>
			<p class="source-code">void _insert(It it, It end_it) {</p>
			<p class="source-code">    if(it == end_it) return;</p>
			<p class="source-code">    <strong class="bold">nodes[*it]._insert(++it, end_it)</strong>;</p>
			<p class="source-code">}</p>
			<p>Likewise, the <strong class="source-inline">_search()</strong> function recursively calls <strong class="source-inline">_search()</strong> on the nodes it finds:</p>
			<p class="source-code">template &lt;typename It&gt;</p>
			<p class="source-code">result_t _search(It it, It end_it) const {</p>
			<p class="source-code">    if(it == end_it) return {this};</p>
			<p class="source-code">    auto found_it = nodes.find(*it);</p>
			<p class="source-code">    if(found_it == nodes.end()) return {};</p>
			<p class="source-code">    return <strong class="bold">found_it-&gt;second._search(++it, end_it)</strong>;</p>
			<p class="source-code">}</p>
			<p>This recursiv<a id="_idIndexMarker1099"/>e approach using <strong class="source-inline">std::map</strong> allows <a id="_idIndexMarker1100"/>us to implement a trie class concisely and efficiently.</p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor352"/>Calculate the error sum of two vectors</h1>
			<p>Given two <a id="_idIndexMarker1101"/>similar vectors that differ only by quantization or <a id="_idIndexMarker1102"/>resolution, we can use the <strong class="source-inline">inner_product()</strong> algorithm to calculate an <em class="italic">error sum</em>, defined as:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B18267_11_02.jpg" alt="Figure 11.2 – Error sum definition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Error sum definition</p>
			<p>Where <em class="italic">e</em> is the error sum, the sum of the square of the difference between a series of points in two vectors.</p>
			<p>We can use the <strong class="source-inline">inner_product()</strong> algorithm, from the <strong class="source-inline">&lt;numeric&gt;</strong> header, to calculate the error sum between two vectors.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor353"/>How to do it…</h2>
			<p>In this recipe we define two vectors, each with a <em class="italic">sine wave</em>. One <strong class="source-inline">vector</strong> has values of type <strong class="source-inline">double</strong> and the other has type <strong class="source-inline">int</strong>. This gives us vectors that differ in quantization, because the <strong class="source-inline">int</strong> type cannot represent fractional values. We then use <strong class="source-inline">inner_product()</strong> to calculate the error sum between the two vectors:</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function we define our vectors and a handy <strong class="source-inline">index</strong> variable:<p class="source-code">int main() {</p><p class="source-code">    constexpr size_t vlen{ 100 };</p><p class="source-code">    vector&lt;double&gt; <strong class="bold">ds</strong>(vlen);</p><p class="source-code">    vector&lt;int&gt; <strong class="bold">is</strong>(vlen);</p><p class="source-code">    size_t <strong class="bold">index</strong>{};</p><p class="source-code">    ...</p></li>
			</ul>
			<p><strong class="source-inline">ds</strong> is the <strong class="source-inline">vector</strong> of <strong class="source-inline">double</strong> sine waves and <strong class="source-inline">is</strong> is the <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong> sine waves. Each <strong class="source-inline">vector</strong> has 100 elements to hold a sine wave. The <strong class="source-inline">index</strong> variable is used to initialize the <strong class="source-inline">vector</strong> objects.</p>
			<ul>
				<li>We generate the sine wave in the <strong class="source-inline">vector</strong> of <strong class="source-inline">double</strong>, using a loop and a lambda:<p class="source-code">auto <strong class="bold">sin_gen</strong> = [<strong class="bold">&amp;index</strong>]{</p><p class="source-code">  return 5.0 * sin(index++ * 2 * <strong class="bold">pi</strong> / 100);</p><p class="source-code">};</p><p class="source-code">for(auto&amp; v : ds) v = <strong class="bold">sin_gen()</strong>;</p></li>
			</ul>
			<p>The lambda<a id="_idIndexMarker1103"/> captures a reference to the <strong class="source-inline">index</strong> variable<a id="_idIndexMarker1104"/> so it can be incremented.</p>
			<p>The <strong class="source-inline">pi</strong> constant is from the <strong class="source-inline">std::numbers</strong> library.</p>
			<ul>
				<li>We now have a <strong class="source-inline">double</strong> sine wave and we can use it to derive the <strong class="source-inline">int</strong> version:<p class="source-code">index = 0;</p><p class="source-code">for(auto&amp; v : is) {</p><p class="source-code">    v = <strong class="bold">static_cast&lt;int&gt;(round(ds.at(index++)))</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>This takes each point from <strong class="source-inline">ds</strong>, rounds it, casts it to an <strong class="source-inline">int</strong>, and updates it in position in the <strong class="source-inline">is</strong> container.</p>
			<ul>
				<li>We display our sine waves with a simple loop:<p class="source-code">for(const auto&amp; v : ds) cout &lt;&lt; format("{:-5.2f} ", v);</p><p class="source-code">cout &lt;&lt; "\n\n";</p><p class="source-code">for(const auto&amp; v : is) cout &lt;&lt; format("{:-3d} ", v);</p><p class="source-code">cout &lt;&lt; "\n\n";</p></li>
			</ul>
			<p>Our output is the sine waves as data points in the two containers:</p>
			<p class="source-code"><strong class="bold">0.00  0.31  0.63  0.94  1.24  1.55  1.84  2.13  2.41</strong></p>
			<p class="source-code"><strong class="bold">0.00  0.31  0.63  0.94</strong><strong class="bold">  1.24  1.55  1.84  2.13  2.41</strong></p>
			<p class="source-code"><strong class="bold">2.68  2.94  3.19  3.42  3.64  3.85</strong><strong class="bold">  4.05  4.22  4.38</strong></p>
			<p class="source-code"><strong class="bold">4.52  4.65  4.76  4.84  4.91  4.96  4.99  5.00</strong><strong class="bold">  4.99</strong></p>
			<p class="source-code"><strong class="bold">4.96  4.91  4.84  4.76  4.65  4.52  4.38  4.22  4.05</strong></p>
			<p class="source-code"><strong class="bold">3.85  3.64  3.42  3.19  2.94  2.68  2.41  2.13  1.84</strong></p>
			<p class="source-code"><strong class="bold">1.55  1.24  0.94  0.63  0.31  0.00 -0.31 -0.63 -0.94 -1.24 -1.55 -1.84 -2.13 -2.41 -2.68 -2.94 -3.19 -3.42 -3.64 -3.85 -4.05 -4.22 -4.38 -4.52 -4.65 -4.76 -4.84 -4.91 -4.96 -4.99 -5.00 -4.99 -4.96 -4.91 -4.84 -4.76 -4.65 -4.52 -4.38 -4.22 -4.05 -3.85 -3.64 -3.42 -3.19 -2.94 -2.68 -2.41 -2.13 -1.84 -1.55 -1.24 -0.94 -0.63 -0.31</strong></p>
			<p class="source-code"><strong class="bold">0   0   1   1   1   2   2   2   2   3   3   3   3   4   4 4   4   4   5   5   5   5   5  </strong><strong class="bold"> 5   5   5   5   5   5   5 5</strong><strong class="bold">   5   5   4   4   4   4   </strong><strong class="bold">4   3   3   3   3   2   2   2 2   1   1   1   0   0   0   -1   -1   -1   -2   -2   -2 </strong><strong class="bold">-2   -3   -3   -3   -3   -4   -4   -4   -4   -4</strong><strong class="bold">   -5   -5 -5   -5   -5   -5   -5   -5   -5  </strong><strong class="bold"> -5   -5   -5   -5   -5 -5   -4   -4   -4   -4   -4</strong><strong class="bold">   -3   -3   -3   -3   -2   -2 -2   -2   -1   -1   -1   0</strong></p>
			<ul>
				<li>Now <a id="_idIndexMarker1105"/>we<a id="_idIndexMarker1106"/> calculate the error sum using <strong class="source-inline">inner_product()</strong>:<p class="source-code">double errsum = <strong class="bold">inner_product</strong>(ds.begin(), ds.end(), </p><p class="source-code">    is.begin(), 0.0, std::plus&lt;double&gt;(),</p><p class="source-code">    <strong class="bold">[](double a, double b){ return pow(a - b, 2); })</strong>;</p><p class="source-code">cout &lt;&lt; format("error sum: {:.3f}\n\n", errsum);</p></li>
			</ul>
			<p>The lambda expression returns the (<em class="italic">a</em><span class="subscript">i</span> – <em class="italic">b</em><span class="subscript">i</span>)<span class="superscript">2</span> part of the formula. The <strong class="source-inline">std::plus()</strong> algorithm performs the sum operation.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">error sum: 7.304</strong></p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor354"/>How it works…</h2>
			<p>The <strong class="source-inline">inner_product()</strong> algorithm computes a sum of products on the first input range. Its signature is:</p>
			<p class="source-code">T inner_product(InputIt1 first1, InputIt1 last1,</p>
			<p class="source-code">    InputIt2 first2, T init, BinaryOperator1 op1,</p>
			<p class="source-code">    BinaryOperator2 op2)</p>
			<p>The function takes two binary operator functors, <strong class="source-inline">op1</strong> and <strong class="source-inline">op2</strong>. The first <strong class="source-inline">op1</strong> is for the <em class="italic">sum</em> and the second <strong class="source-inline">op2</strong> is for the <em class="italic">product</em>. We use <strong class="source-inline">std::plus()</strong> as the sum operator, and a lambda as the product operator.</p>
			<p>The <strong class="source-inline">init</strong> parameter <a id="_idIndexMarker1107"/>can be used as a starting value or<a id="_idIndexMarker1108"/> bias. We pass it the literal value, <strong class="source-inline">0.0</strong>.</p>
			<p>The return value is the accumulated sum of the products.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor355"/>There's more…</h2>
			<p>We can <a id="_idIndexMarker1109"/>calculate an accumulated error sum by putting <strong class="source-inline">inner_product()</strong> in a loop:</p>
			<p class="source-code">cout &lt;&lt; "accumulated error:\n";</p>
			<p class="source-code">for (auto it{ds.begin()}; it != ds.end(); ++it) {</p>
			<p class="source-code">    double accumsum = inner_product(ds.begin(), it, </p>
			<p class="source-code">        is.begin(), 0.0, std::plus&lt;double&gt;(),</p>
			<p class="source-code">        [](double a, double b){ return pow(a - b, 2); });</p>
			<p class="source-code">    cout &lt;&lt; format("{:-5.2f} ", accumsum);</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">accumulated error:</p>
			<p class="source-code">0.00  0.00  0.10  0.24  0.24  0.30  0.51  0.53  0.55  0.72  0.82  0.82  0.86  1.04  1.16  1.19  1.19  1.24  1.38  1.61  1.73  1.79  1.82  1.82  1.83  1.83  1.83  1.83  1.83  1.84  1.86  1.92  2.04  2.27  2.42  2.46  2.47  2.49  2.61  2.79  2.83  2.83  2.93  3.10  3.12  3.14  3.35  3.41  3.41  3.55  3.65  3.65  3.75  3.89  3.89  3.95  4.16  4.19  4.20  4.37  4.47  4.48  4.51  4.69  4.82  4.84  4.84  4.89  5.03  5.26  5.38  5.44  5.47  5.48  5.48  5.48  5.48  5.48  5.48  5.49  5.51  5.57  5.70  5.92  6.07  6.12  6.12  6.14  6.27  6.45  6.48  6.48  6.59  6.75  6.77  6.80  7.00  7.06  7.07  7.21</p>
			<p>This may be <a id="_idIndexMarker1110"/>useful in some statistical applications.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor356"/>Build your own algorithm: split</h1>
			<p>The STL has a<a id="_idIndexMarker1111"/> rich <strong class="source-inline">algorithm</strong> library. Yet, on occasion you may find it missing something you need. One common need is a <strong class="source-inline">split</strong> function.</p>
			<p>A <strong class="source-inline">split</strong> function splits a string on a character separator. For example, here's a Unix <strong class="source-inline">/etc/passwd</strong> file from a standard Debian installation:</p>
			<p class="source-code">root:x:0:0:root:/root:/bin/bash</p>
			<p class="source-code">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</p>
			<p class="source-code">bin:x:2:2:bin:/bin:/usr/sbin/nologin</p>
			<p class="source-code">sys:x:3:3:sys:/dev:/usr/sbin/nologin</p>
			<p class="source-code">sync:x:4:65534:sync:/bin:/bin/sync</p>
			<p>Each field is separated by a colon <strong class="source-inline">:</strong> character, where the fields are:</p>
			<ol>
				<li>Login name</li>
				<li>Optional encrypted password</li>
				<li>User ID</li>
				<li>Group ID</li>
				<li>Username or comment</li>
				<li>Home directory</li>
				<li>Optional command interpreter</li>
			</ol>
			<p>This is a standard file in POSIX-based operating systems, and there are others like it. Most scripting languages include a built-in function for splitting a string on a separator. There are simple ways to do this in C++. Still, <strong class="source-inline">std::string</strong> is just another container in the STL, and a generic algorithm that splits a container on a separator could be a useful addition<a id="_idIndexMarker1112"/> to the toolbox. So, let's build one.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor357"/>How to do it…</h2>
			<p>In this recipe, we build a generic algorithm that splits a container on a separator and puts the results in a target container.</p>
			<ul>
				<li>Our algorithm is in the <strong class="source-inline">bw</strong> namespace, to avoid collisions with <strong class="source-inline">std</strong>:<p class="source-code">namespace <strong class="bold">bw</strong> {</p><p class="source-code">    template&lt;typename <strong class="bold">It</strong>, typename <strong class="bold">Oc</strong>, typename <strong class="bold">V</strong>,</p><p class="source-code">        typename <strong class="bold">Pred</strong>&gt;</p><p class="source-code">    <strong class="bold">It</strong> split(It <strong class="bold">it</strong>, It <strong class="bold">end_it</strong>, Oc&amp; <strong class="bold">dest</strong>,</p><p class="source-code">            const V&amp; <strong class="bold">sep</strong>, Pred&amp; <strong class="bold">f</strong>) {</p><p class="source-code">        using <strong class="bold">SliceContainer</strong> = typename </p><p class="source-code">          <strong class="bold">Oc::value_type</strong>;</p><p class="source-code">        while(it != end_it) {</p><p class="source-code">            <strong class="bold">SliceContainer</strong> dest_elm{};</p><p class="source-code">            auto <strong class="bold">slice</strong>{ it };</p><p class="source-code">            while(slice != end_it) {</p><p class="source-code">                if(<strong class="bold">f(*slice, sep)</strong>) break;</p><p class="source-code">                <strong class="bold">dest_elm.push_back(*slice++);</strong></p><p class="source-code">            }</p><p class="source-code">            <strong class="bold">dest.push_back(dest_elm);</strong></p><p class="source-code">            if(slice == end_it) return end_it;</p><p class="source-code">            it = ++slice;</p><p class="source-code">        }</p><p class="source-code">        return it;</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>The <strong class="source-inline">split()</strong> algorithm searches a container for separators and collects the separated slices<a id="_idIndexMarker1113"/> into a new output container, where each slice is a container within the output container.</p>
			<p>We want the <strong class="source-inline">split()</strong> algorithm to be as generic as possible, just like those in the <strong class="source-inline">algorithm</strong> library. This means that all the parameters are templated, and the code will work with a comprehensive variety of parameter types.</p>
			<p>First, let's look at the template parameters:</p>
			<ul>
				<li><strong class="source-inline">It</strong> is the input iterator type for the source container.</li>
				<li><strong class="source-inline">Oc</strong> is the output container type. This is a container of containers.</li>
				<li><strong class="source-inline">V</strong> is the separator type.</li>
				<li><strong class="source-inline">Pred</strong> is for the predicate functor.</li>
			</ul>
			<p>Our output type is a container of containers. It needs to hold containers of slices. It could be <strong class="source-inline">vector&lt;string&gt;</strong>, where the string values are slices, or <strong class="source-inline">vector&lt;vector&lt;int&gt;&gt;</strong>, where the inner <strong class="source-inline">vector&lt;int&gt;</strong> contains the slices. This means we need to derive the type of the inner container from the output container type. We do that with the <strong class="source-inline">using</strong> declaration in the body of the function.</p>
			<p class="source-code">using <strong class="bold">SliceContainer</strong> = typename <strong class="bold">Oc::value_type</strong>;</p>
			<p>This is also why we cannot use an output iterator for the output parameter. By definition, an output iterator cannot determine the type of its contents and its <strong class="source-inline">value_type</strong> is set to <strong class="source-inline">void</strong>.</p>
			<p>We use <strong class="source-inline">SliceContainer</strong> to define a temporary container that is added to the output container with the statement:</p>
			<p class="source-code">dest.push_back(dest_elm);</p>
			<ul>
				<li>The predicate<a id="_idIndexMarker1114"/> is a binary operator that compares an input element with the separator. We include a default equality operator in the <strong class="source-inline">bw</strong> namespace:<p class="source-code">constexpr auto <strong class="bold">eq</strong> = [](const auto&amp; <strong class="bold">el</strong>, const auto&amp; <strong class="bold">sep</strong>) {</p><p class="source-code">    return <strong class="bold">el</strong> == <strong class="bold">sep</strong>;</p><p class="source-code">};</p></li>
				<li>We also include a specialization of <strong class="source-inline">split()</strong> that uses the <strong class="source-inline">eq</strong> operator by default:<p class="source-code">template&lt;typename It, typename Oc, typename V&gt;</p><p class="source-code">It split(It <strong class="bold">it</strong>, const It <strong class="bold">end_it</strong>, Oc&amp; <strong class="bold">dest</strong>, const V&amp; <strong class="bold">sep</strong>) {</p><p class="source-code">    return <strong class="bold">split(it, end_it, dest, sep, eq)</strong>;</p><p class="source-code">}</p></li>
				<li>Because splitting <strong class="source-inline">string</strong> objects is a common use case for this algorithm, we include a helper function for that specific purpose:<p class="source-code">template&lt;typename <strong class="bold">Cin</strong>, typename <strong class="bold">Cout</strong>, typename <strong class="bold">V</strong>&gt;</p><p class="source-code">Cout&amp; strsplit(const Cin&amp; <strong class="bold">str</strong>, Cout&amp; <strong class="bold">dest</strong>, const V&amp; <strong class="bold">sep</strong>) {</p><p class="source-code">    <strong class="bold">split(str.begin(), str.end(), dest, sep, eq);</strong></p><p class="source-code">    return dest;</p><p class="source-code">}</p></li>
				<li>We test our <a id="_idIndexMarker1115"/>split algorithm <strong class="source-inline">main()</strong>, starting with a <strong class="source-inline">string</strong> object:<p class="source-code">int main() {</p><p class="source-code">    constexpr char <strong class="bold">strsep</strong>{ ':' };</p><p class="source-code">    const string <strong class="bold">str</strong></p><p class="source-code">        { "<strong class="bold">sync:x:4:65534:sync:/bin:/bin/sync</strong>" };</p><p class="source-code">    <strong class="bold">vector&lt;string&gt; dest_vs</strong>{};</p><p class="source-code">    <strong class="bold">bw::split(str.begin(), str.end(), dest_vs, strsep, </strong></p><p class="source-code"><strong class="bold">        bw::eq)</strong>;</p><p class="source-code">    for(const auto&amp; e : dest_vs) cout &lt;&lt;</p><p class="source-code">        format("[{}] ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>We use a string from the <strong class="source-inline">/etc/passwd</strong> file to test our algorithm, with this result:</p>
			<p class="source-code">[sync] [x] [4] [65534] [sync] [/bin] [/bin/sync]</p>
			<ul>
				<li>It's even simpler using our <strong class="source-inline">strsplit()</strong> helper function:<p class="source-code">vector&lt;string&gt; <strong class="bold">dest_vs2</strong>{};</p><p class="source-code"><strong class="bold">bw::strsplit(str, dest_vs2, strsep);</strong></p><p class="source-code">for(const auto&amp; e : dest_vs2) cout &lt;&lt; format("[{}] ", e);</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">[sync] [x] [4] [65534] [sync] [/bin] [/bin/sync]</strong></p>
			<p>This would make it easy to parse the <strong class="source-inline">/etc/passwd</strong> file.</p>
			<ul>
				<li>Of course, we <a id="_idIndexMarker1116"/>can use the same algorithm with any container:<p class="source-code">constexpr int <strong class="bold">intsep</strong>{ -1 };</p><p class="source-code"><strong class="bold">vector&lt;int&gt;</strong> vi{ 1, 2, 3, 4, <strong class="bold">intsep</strong>, 5, 6, 7, 8, <strong class="bold">intsep</strong>,</p><p class="source-code">    9, 10, 11, 12 };</p><p class="source-code"><strong class="bold">vector&lt;vector&lt;int&gt;&gt; dest_vi</strong>{};</p><p class="source-code"><strong class="bold">bw::split(vi.begin(), vi.end(), dest_vi, intsep)</strong>;</p><p class="source-code">for(const auto&amp; v : dest_vi) {</p><p class="source-code">    string s;</p><p class="source-code">    for(const auto&amp; e : v) s += format("{}", e);</p><p class="source-code">    cout &lt;&lt; format("[{}] ", s);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">[1234] [5678] [9101112]</strong></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor358"/>How it works…</h2>
			<p>The split algorithm itself is relatively simple. The magic in this recipe is in the use of templates to make it as generic as possible.</p>
			<p>The derived type in the <strong class="source-inline">using</strong> declaration allows us to create a container for use with the output container:</p>
			<p class="source-code">using <strong class="bold">SliceContainer</strong> = typename <strong class="bold">Oc::value_type</strong>;</p>
			<p>This gives us a <strong class="source-inline">SliceContainer</strong> type that we can use to create a container for the slices:</p>
			<p class="source-code"><strong class="bold">SliceContainer</strong> dest_elm{};</p>
			<p>This is a temporary<a id="_idIndexMarker1117"/> container that is added to the output container for each slice:</p>
			<p class="source-code">dest.push_back(dest_elm);</p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>Leverage existing algorithms: gather</h1>
			<p><strong class="source-inline">gather()</strong> is an example<a id="_idIndexMarker1118"/> of an algorithm that leverages existing algorithms.</p>
			<p>The <strong class="source-inline">gather()</strong> algorithm takes a pair of container iterators and moves the elements that satisfy a predicate toward a <em class="italic">pivot</em> position within the sequence, returning a <strong class="source-inline">pair</strong> of iterators that contains the elements that satisfy the predicate.</p>
			<p>For example, we could use a <strong class="source-inline">gather</strong> algorithm to sort all the even numbers to the mid-point of a <strong class="source-inline">vector</strong>:</p>
			<p class="source-code">vector&lt;int&gt; <strong class="bold">vint</strong>{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p>
			<p class="source-code"><strong class="bold">gather</strong>(vint.begin(), vint.end(), mid(vint), is_even);</p>
			<p class="source-code">for(const auto&amp; <strong class="bold">el</strong> : <strong class="bold">vint</strong>) cout &lt;&lt; <strong class="bold">el</strong>;</p>
			<p>Our output is:</p>
			<p class="source-code">13<strong class="bold">02468</strong>579</p>
			<p>Notice that the even numbers are all in the middle of the output.</p>
			<p>In this recipe, we will implement a <strong class="source-inline">gather</strong> algorithm using standard STL algorithms.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>How to do it…</h2>
			<p>Our <strong class="source-inline">gather</strong> algorithm uses the <strong class="source-inline">std::stable_partition()</strong> algorithm to move items before the pivot iterator and again to move items past the pivot.</p>
			<ul>
				<li>We put the algorithm in the <strong class="source-inline">bw</strong> namespace to avoid collisions.<p class="source-code">namespace bw {</p><p class="source-code">using std::stable_partition;</p><p class="source-code">using std::pair;</p><p class="source-code">using std::not_fn;</p><p class="source-code">template &lt;typename It, typename Pred&gt;</p><p class="source-code"><strong class="bold">pair</strong>&lt;<strong class="bold">It, It</strong>&gt; <strong class="bold">gather</strong>(It <strong class="bold">first</strong>, It <strong class="bold">last</strong>, It <strong class="bold">pivot</strong>,</p><p class="source-code">        Pred <strong class="bold">pred</strong>) {</p><p class="source-code">    return {stable_partition(<strong class="bold">first</strong>, <strong class="bold">pivot</strong>, <strong class="bold">not_fn(pred)</strong>),</p><p class="source-code">            stable_partition(<strong class="bold">pivot, last, pred)</strong>};</p><p class="source-code">}</p><p class="source-code">};</p></li>
			</ul>
			<p>The <strong class="source-inline">gather()</strong> algorithm <a id="_idIndexMarker1119"/>returns a <strong class="source-inline">pair</strong> of iterators, returned from two calls to <strong class="source-inline">stable_partition()</strong>.</p>
			<ul>
				<li>We also include some helper lambdas:<p class="source-code">constexpr auto <strong class="bold">midit</strong> = [](auto&amp; v) {</p><p class="source-code">    return v.begin() + (v.end() - v.begin()) / 2;</p><p class="source-code">};</p><p class="source-code">constexpr auto <strong class="bold">is_even</strong> = [](auto i) {</p><p class="source-code">    return i % 2 == 0;</p><p class="source-code">};</p><p class="source-code">constexpr auto <strong class="bold">is_even_char</strong> = [](auto c) {</p><p class="source-code">    if(c &gt;= '0' &amp;&amp; c &lt;= '9') return (c - '0') % 2 == 0;</p><p class="source-code">    else return false;</p><p class="source-code">};</p></li>
			</ul>
			<p>These three lambdas are as follows:</p>
			<ul>
				<li><strong class="source-inline">midit</strong> returns an iterator at the midpoint of a container, for use as a pivot point.</li>
				<li><strong class="source-inline">is_even</strong> returns Boolean <strong class="source-inline">true</strong> if the value is even, for use as a predicate.</li>
				<li><strong class="source-inline">is_even_char</strong> returns Boolean <strong class="source-inline">true</strong> if the value is a character between <strong class="source-inline">'0'</strong> and <strong class="source-inline">'9'</strong> and is even, for use as a predicate.</li>
			</ul>
			<ul>
				<li>We call <strong class="source-inline">gather()</strong> from <a id="_idIndexMarker1120"/>the <strong class="source-inline">main()</strong> function with a vector of <strong class="source-inline">int</strong> like this:<p class="source-code">int main() {</p><p class="source-code">    vector&lt;int&gt; <strong class="bold">vint</strong>{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p><p class="source-code">    auto <strong class="bold">gathered_even = bw::gather</strong>(vint.begin(),</p><p class="source-code">        vint.end(), bw::midit(vint), bw::is_even);</p><p class="source-code">    for(const auto&amp; el : vint) cout &lt;&lt; el;</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>Our output shows that the even numbers have been gathered in the middle:</p>
			<p class="source-code">13<strong class="bold">02468</strong>579</p>
			<p>The <strong class="source-inline">gather()</strong> function returns a <strong class="source-inline">pair</strong> of iterators that contain just the even values:</p>
			<p class="source-code">auto&amp; [it1, it2] = gathered_even;</p>
			<p class="source-code">for(auto it{ it1 }; it &lt; it2; ++it) cout &lt;&lt; *it;</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">02468</strong></p>
			<ul>
				<li>We can set the pivot point to the <strong class="source-inline">begin()</strong> or <strong class="source-inline">end()</strong> iterators:<p class="source-code">bw::gather(vint.begin(), vint.end(), <strong class="bold">vint.begin()</strong>, </p><p class="source-code">    bw::is_even);</p><p class="source-code">for(const auto&amp; el : vint) cout &lt;&lt; el;</p><p class="source-code">cout &lt;&lt; '\n';</p><p class="source-code">bw::gather(vint.begin(), vint.end(), <strong class="bold">vint.end()</strong>,</p><p class="source-code">    bw::is_even);</p><p class="source-code">for(const auto&amp; el : vint) cout &lt;&lt; el;</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">02468</strong>13579</p>
			<p class="source-code">13579<strong class="bold">02468</strong></p>
			<ul>
				<li>Because <strong class="source-inline">gather()</strong> is iterator-based, we can use it with any container. Here's a string of <a id="_idIndexMarker1121"/>character digits:<p class="source-code">string <strong class="bold">jenny</strong>{ "867-5309" };</p><p class="source-code">bw::gather(jenny.begin(), jenny.end(), jenny.<strong class="bold">end()</strong>,</p><p class="source-code">    <strong class="bold">bw::is_even_char</strong>);</p><p class="source-code">for(const auto&amp; el : jenny) cout &lt;&lt; el;</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>This moves all the even digits to the end of the string:</p>
			<p>Output:</p>
			<p class="source-code">7-539<strong class="bold">860</strong></p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>How it works…</h2>
			<p>The <strong class="source-inline">gather()</strong> function uses the <strong class="source-inline">std::stable_partition()</strong> algorithm to move the elements that match the predicate to the pivot point.</p>
			<p><strong class="source-inline">gather()</strong> has two calls to <strong class="source-inline">stable_partition()</strong>, one with the predicate, and one with the predicate negated:</p>
			<p class="source-code">template &lt;typename It, typename Pred&gt;</p>
			<p class="source-code"><strong class="bold">pair&lt;It, It&gt;</strong> gather(It first, It last, It pivot, Pred pred) {</p>
			<p class="source-code">    return { <strong class="bold">stable_partition(first, pivot, not_fn(pred))</strong>,</p>
			<p class="source-code">             <strong class="bold">stable_partition(pivot, last, pred)</strong> };</p>
			<p class="source-code">}</p>
			<p>The iterators<a id="_idIndexMarker1122"/> returned from the two <strong class="source-inline">stable_partition()</strong> calls are returned in the <strong class="source-inline">pair</strong>.</p>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor362"/>Remove consecutive whitespace</h1>
			<p>When receiving<a id="_idIndexMarker1123"/> input from users, it's common to end up with excessive consecutive whitespace characters in your strings. This recipe presents a function for removing consecutive spaces, even when it includes tabs or other whitespace characters.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>How to do it…</h2>
			<p>This function leverages the <strong class="source-inline">std::unique()</strong> algorithm to remove consecutive whitespace characters from a string.</p>
			<ul>
				<li>In the <strong class="source-inline">bw</strong> namespace, we start with a function to detect whitespace:<p class="source-code">template&lt;typename <strong class="bold">T</strong>&gt;</p><p class="source-code">bool isws(<strong class="bold">const T&amp;</strong> c) {</p><p class="source-code">    constexpr const <strong class="bold">T</strong> whitespace[]{ " \t\r\n\v\f" };</p><p class="source-code">    for(const <strong class="bold">T</strong>&amp; wsc : whitespace) {</p><p class="source-code">        <strong class="bold">if(c == wsc) return true</strong>;</p><p class="source-code">    }    </p><p class="source-code">    return false;</p><p class="source-code">}</p></li>
			</ul>
			<p>This templated <strong class="source-inline">isws()</strong> function should work with any character type.</p>
			<ul>
				<li>The <strong class="source-inline">delws()</strong> function uses <strong class="source-inline">std::unique()</strong> to erase consecutive whitespace<a id="_idIndexMarker1124"/> in a <strong class="source-inline">string</strong>:<p class="source-code">string delws(<strong class="bold">const string&amp; s</strong>) {</p><p class="source-code">    <strong class="bold">string outstr{s}</strong>;</p><p class="source-code">    auto its = unique(outstr.begin(), outstr.end(),</p><p class="source-code">        [](const auto &amp;a, const auto &amp;b) {</p><p class="source-code">            <strong class="bold">return isws(a) &amp;&amp; isws(b)</strong>;</p><p class="source-code">        });</p><p class="source-code">    <strong class="bold">outstr.erase(its, outstr.end());</strong></p><p class="source-code">    <strong class="bold">outstr.shrink_to_fit();</strong></p><p class="source-code">    return outstr;</p><p class="source-code">}</p></li>
			</ul>
			<p><strong class="source-inline">delws()</strong> makes a copy of the input string, removes consecutive whitespace, and returns the new string.</p>
			<ul>
				<li>We call it with a <strong class="source-inline">string</strong> from <strong class="source-inline">main()</strong>:<p class="source-code">int main() {</p><p class="source-code">    const string s{ "big     bad    \t   wolf" };</p><p class="source-code">    const string s2{ bw::delws(s) };</p><p class="source-code">    cout &lt;&lt; format("[{}]\n", s);</p><p class="source-code">    cout &lt;&lt; format("[{}]\n", s2);</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">[big     bad           wolf]</strong></p>
			<p class="source-code"><strong class="bold">[big bad wolf]</strong></p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor364"/>How it works…</h2>
			<p>This function uses the <strong class="source-inline">std::unique()</strong> algorithm with a comparison lambda to find consecutive whitespace in a <strong class="source-inline">string</strong> object.</p>
			<p>The comparison lambda calls our own <strong class="source-inline">isws()</strong> function to determine if we have found consecutive whitespace:</p>
			<p class="source-code">auto its = unique(outstr.begin(), outstr.end(),</p>
			<p class="source-code">    [](const auto &amp;a, const auto &amp;b) {</p>
			<p class="source-code">        <strong class="bold">return isws(a) &amp;&amp; isws(b)</strong>;</p>
			<p class="source-code">    });</p>
			<p>We could use the <strong class="source-inline">isspace()</strong> function from the standard library, but it's a standard C function that depends on a narrowing type conversion from <strong class="source-inline">int</strong> to <strong class="source-inline">char</strong>. This may issue warnings <a id="_idIndexMarker1125"/>on some modern C++ compilers and is not guaranteed to work without an explicit cast. Our <strong class="source-inline">isws()</strong> function uses a templated type and should work on any system, and with any specialization of <strong class="source-inline">std::string</strong>.</p>
			<h1 id="_idParaDest-366"><a id="_idTextAnchor365"/>Convert numbers to words</h1>
			<p>Over the course<a id="_idIndexMarker1126"/> of my career, I've used a lot of programming<a id="_idIndexMarker1127"/> languages. When learning a new language, I like to have a project to work on that exposes me to the nuances of the language. The <strong class="source-inline">numwords</strong> class is one of my favorite exercises for this purpose. I have written it in dozens of languages over the years, including several times in C and C++.</p>
			<p><strong class="source-inline">numwords</strong> is a class that spells out a number in words. It can be useful for banking and accounting applications. It looks like this in use:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    bw::numword nw{};</p>
			<p class="source-code">    uint64_t n;</p>
			<p class="source-code">    nw = 3; bw::print("n is {}, {}\n", nw.getnum(), nw);</p>
			<p class="source-code">    nw = 47; bw::print("n is {}, {}\n", nw.getnum(), nw);</p>
			<p class="source-code">    n = 100073; bw::print("n is {}, {}\n", n, </p>
			<p class="source-code">      bw::numword{n});</p>
			<p class="source-code">    n = 1000000001; bw::print("n is {}, {}\n", n, </p>
			<p class="source-code">      bw::numword{n});</p>
			<p class="source-code">    n = 123000000000; bw::print("n is {}, {}\n", n, </p>
			<p class="source-code">      bw::numword{n});</p>
			<p class="source-code">    n = 1474142398007; bw::print("n is {}, {}\n", n, </p>
			<p class="source-code">      nw.words(n));</p>
			<p class="source-code">    n = 999999999999999999; bw::print("n is {}, {}\n", n, </p>
			<p class="source-code">      nw.words(n));</p>
			<p class="source-code">    n = 1000000000000000000; bw::print("n is {}, {}\n", n, </p>
			<p class="source-code">        nw.words(n));</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">n is 3, three</p>
			<p class="source-code">n is 47, forty-seven</p>
			<p class="source-code">n is 100073, one hundred thousand seventy-three</p>
			<p class="source-code">n is 1000000001, one billion one</p>
			<p class="source-code">n is 123000000000, one hundred twenty-three billion</p>
			<p class="source-code">n is 1474142398007, one trillion four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand seven</p>
			<p class="source-code">n is 999999999999999999, nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine</p>
			<p class="source-code">n is 1000000000000000000, error</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor366"/>How to do it…</h2>
			<p>This recipe originated as an exercise in creating production-ready code. For that reason, it's in three different files:</p>
			<ul>
				<li><strong class="source-inline">numword.h</strong> is the header/interface file for the <strong class="source-inline">numwords</strong> class.</li>
				<li><strong class="source-inline">numword.cpp</strong> is the implementation file for the <strong class="source-inline">numwords</strong> class.</li>
				<li><strong class="source-inline">numword-test.cpp</strong> is the application file for testing the <strong class="source-inline">numword</strong> class.</li>
			</ul>
			<p>The class itself<a id="_idIndexMarker1128"/> is about 180 lines of code so we'll just cover the<a id="_idIndexMarker1129"/> highlights here. You can find the full source code at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword</a>.</p>
			<ul>
				<li>In the <strong class="source-inline">numword.h</strong> file, we put the class in the <strong class="source-inline">bw</strong> namespace and start with some <strong class="source-inline">using</strong> statements:<p class="source-code">namespace bw {</p><p class="source-code">    using <strong class="bold">std::string</strong>;</p><p class="source-code">    using <strong class="bold">std::string_view</strong>;</p><p class="source-code">    <strong class="bold">using numnum = uint64_t;</strong> </p><p class="source-code">    <strong class="bold">using bufstr = std::unique_ptr&lt;string&gt;;</strong></p></li>
			</ul>
			<p>We use <strong class="source-inline">string</strong> and <strong class="source-inline">string_view</strong> objects throughout the code.</p>
			<p><strong class="source-inline">uint64_t</strong> is our primary integer type because it will hold very large numbers. Because the class is called <strong class="source-inline">numword</strong>, I like <strong class="source-inline">numnum</strong> for the integer type.</p>
			<p><strong class="source-inline">_bufstr</strong> is the main output buffer. It's a <strong class="source-inline">string</strong> wrapped in a <strong class="source-inline">unique_ptr</strong>, which handles the memory management for automatic RAII compliance.</p>
			<ul>
				<li>We also have a few constants for various purposes:<p class="source-code">constexpr numnum maxnum = 999'999'999'999'999'999;</p><p class="source-code">constexpr int zero_i{ 0 };</p><p class="source-code">constexpr int five_i{ 5 };</p><p class="source-code">constexpr numnum zero{ 0 };</p><p class="source-code">constexpr numnum ten{ 10 };</p><p class="source-code">constexpr numnum twenty{ 20 };</p><p class="source-code">constexpr numnum hundred{ 100 };</p><p class="source-code">constexpr numnum thousand{ 1000 };</p></li>
			</ul>
			<p>The <strong class="source-inline">maxnum</strong> constant translates to "nine hundred ninety-nine quadrillion nine hundred ninety-nine<a id="_idIndexMarker1130"/> trillion nine hundred ninety-nine <a id="_idIndexMarker1131"/>billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine," which should be sufficient for most purposes.</p>
			<p>The rest of the <strong class="source-inline">numnum</strong> constants are used to avoid literals in the code.</p>
			<ul>
				<li>The main data structures are <strong class="source-inline">constexpr</strong> arrays of <strong class="source-inline">string_view</strong> objects, representing the words used in the output. The <strong class="source-inline">string_view</strong> class is perfect for these constants, as it provides encapsulation with minimum overhead:<p class="source-code">constexpr string_view errnum{ "error" };</p><p class="source-code">constexpr string_view _singles[] {</p><p class="source-code">    "zero", "one", "two", "three", "four", "five", </p><p class="source-code">    "six", "seven", "eight", "nine"</p><p class="source-code">};</p><p class="source-code">constexpr string_view _teens[] {</p><p class="source-code">    "ten", "eleven", "twelve", "thirteen", "fourteen", </p><p class="source-code">    "fifteen", "sixteen", "seventeen", "eighteen", </p><p class="source-code">    "nineteen"</p><p class="source-code">};</p><p class="source-code">constexpr string_view _tens[] {</p><p class="source-code">    errnum, errnum, "twenty", "thirty", "forty", </p><p class="source-code">    "fifty", "sixty", "seventy", "eighty", "ninety",</p><p class="source-code">};</p><p class="source-code">constexpr string_view _hundred_string = "hundred";</p><p class="source-code">constexpr string_view _powers[] {</p><p class="source-code">    errnum, "thousand", "million", "billion", </p><p class="source-code">    "trillion", "quadrillion"</p><p class="source-code">};</p></li>
			</ul>
			<p>The words <a id="_idIndexMarker1132"/>are <a id="_idIndexMarker1133"/>grouped into sections, useful in translating numbers to words. Many languages use a similar breakdown so this structure should translate easily to those languages.</p>
			<ul>
				<li>The <strong class="source-inline">numword</strong> class has a few private members:<p class="source-code">class numword {</p><p class="source-code">    bufstr _buf{ std::make_unique&lt;string&gt;(string{}) };</p><p class="source-code">    numnum _num{};</p><p class="source-code">    bool _hyphen_flag{ false };</p><ul><li><strong class="source-inline">_buf</strong> is the output string buffer. Its memory is managed by a <strong class="source-inline">unique_ptr</strong>.</li><li><strong class="source-inline">_num</strong> holds the current numeric value.</li><li><strong class="source-inline">_hyphen_flag</strong> is used during the translation process to insert a hyphen between words, rather than a space character.</li></ul></li>
				<li>These private methods are used to manipulate the output buffer.<p class="source-code">void clearbuf();</p><p class="source-code">size_t bufsize();</p><p class="source-code">void appendbuf(const string&amp; s);</p><p class="source-code">void appendbuf(const string_view&amp; s);</p><p class="source-code">void appendbuf(const char c);</p><p class="source-code">void appendspace();</p></li>
			</ul>
			<p>There is also a <strong class="source-inline">pow_i()</strong> private method used to calculate <em class="italic">x</em><span class="superscript">y</span> with <strong class="source-inline">numnum</strong> types:</p>
			<p class="source-code">numnum pow_i(const numnum n, const numnum p);</p>
			<p><strong class="source-inline">pow_i()</strong> is used<a id="_idIndexMarker1134"/> to discriminate parts of the numeric value<a id="_idIndexMarker1135"/> for word output.</p>
			<ul>
				<li>The public interface includes constructors and various ways to call the <strong class="source-inline">words()</strong> method, which does the work of translating a <strong class="source-inline">numnum</strong> to a <strong class="source-inline">string</strong> of words:<p class="source-code"><strong class="bold">numword</strong>(const numnum&amp; num = 0) : _num(num) {}</p><p class="source-code"><strong class="bold">numword</strong>(const numword&amp; nw) : _num(nw.getnum()) {}</p><p class="source-code">const char * <strong class="bold">version()</strong> const { return _version; }</p><p class="source-code">void <strong class="bold">setnum</strong>(const numnum&amp; num) { _num = num; }</p><p class="source-code">numnum <strong class="bold">getnum</strong>() const { return _num; }</p><p class="source-code">numnum <strong class="bold">operator=</strong> (const numnum&amp; num);</p><p class="source-code">const string&amp; <strong class="bold">words</strong>();</p><p class="source-code">const string&amp; <strong class="bold">words</strong>(const numnum&amp; num);</p><p class="source-code">const string&amp; <strong class="bold">operator()</strong> (const numnum&amp; num) {</p><p class="source-code">    <strong class="bold">return words(num)</strong>; };</p></li>
				<li>In the implementation <a id="_idIndexMarker1136"/>file, <strong class="source-inline">numword.cpp</strong>, the bulk of the work is handled in the <strong class="source-inline">words()</strong> member <a id="_idIndexMarker1137"/>function:<p class="source-code">const string&amp; numword::words( const numnum&amp; num ) {</p><p class="source-code">    numnum n{ num };</p><p class="source-code">    clearbuf();</p><p class="source-code">    if(n &gt; maxnum) {</p><p class="source-code">        appendbuf(errnum);</p><p class="source-code">        return *_buf;</p><p class="source-code">    }</p><p class="source-code">    if (n == 0) {</p><p class="source-code">        appendbuf(_singles[n]);</p><p class="source-code">        return *_buf;</p><p class="source-code">    }</p><p class="source-code">    // powers of 1000</p><p class="source-code">    if (n &gt;= thousand) {</p><p class="source-code">        for(int i{ five_i }; i &gt; zero_i; --i) {</p><p class="source-code">            numnum power{ pow_i(thousand, i) };</p><p class="source-code">            numnum _n{ ( n - ( n % power ) ) / power };</p><p class="source-code">            if (_n) {</p><p class="source-code">                int index = i;</p><p class="source-code">                <strong class="bold">numword _nw{ _n };</strong></p><p class="source-code">                <strong class="bold">appendbuf(_nw.words());</strong></p><p class="source-code">                <strong class="bold">appendbuf(_powers[index]);</strong></p><p class="source-code">                n -= _n * power;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    // hundreds</p><p class="source-code">    if (n &gt;= hundred &amp;&amp; n &lt; thousand) {</p><p class="source-code">        numnum _n{ ( n - ( n % hundred ) ) / hundred };</p><p class="source-code">        numword _nw{ _n };</p><p class="source-code">        <strong class="bold">appendbuf(_nw.words());</strong></p><p class="source-code">        <strong class="bold">appendbuf(_hundred_string);</strong></p><p class="source-code">        n -= _n * hundred;</p><p class="source-code">    }</p><p class="source-code">    // tens</p><p class="source-code">    if (n &gt;= twenty &amp;&amp; n &lt; hundred) {</p><p class="source-code">        numnum _n{ ( n - ( n % ten ) ) / ten };</p><p class="source-code">        <strong class="bold">appendbuf(_tens[_n]);</strong></p><p class="source-code">        n -= _n * ten;</p><p class="source-code">        <strong class="bold">_hyphen_flag = true;</strong></p><p class="source-code">    }</p><p class="source-code">    // teens</p><p class="source-code">    if (n &gt;= ten &amp;&amp; n &lt; twenty) {</p><p class="source-code">        <strong class="bold">appendbuf(_teens[n - ten]);</strong></p><p class="source-code">        n = zero;</p><p class="source-code">    }</p><p class="source-code">    // singles</p><p class="source-code">    if (n &gt; zero &amp;&amp; n &lt; ten) {</p><p class="source-code">        <strong class="bold">appendbuf(_singles[n]);</strong></p><p class="source-code">    }</p><p class="source-code">    return *_buf;</p><p class="source-code">}</p></li>
			</ul>
			<p>Each part of the function peels off part of the number with a <em class="italic">modulus of a power of ten</em>, recursively in the case of the thousands, and appends strings from the <strong class="source-inline">string_view</strong> constant arrays.</p>
			<ul>
				<li>There are <a id="_idIndexMarker1138"/>three <a id="_idIndexMarker1139"/>overloads of <strong class="source-inline">appendbuf()</strong>. One appends a <strong class="source-inline">string</strong>:<p class="source-code">void numword::appendbuf(const string&amp; s) {</p><p class="source-code">    appendspace();</p><p class="source-code">    _buf-&gt;append(s);</p><p class="source-code">}</p></li>
			</ul>
			<p>Another appends a <strong class="source-inline">string_view</strong>:</p>
			<p class="source-code">void numword::appendbuf(const string_view&amp; s) {</p>
			<p class="source-code">    appendspace();</p>
			<p class="source-code">    _buf-&gt;append(s.data());</p>
			<p class="source-code">}</p>
			<p>And the third appends a single character:</p>
			<p class="source-code">void numword::appendbuf(const char c) {</p>
			<p class="source-code">    _buf-&gt;append(1, c);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">appendspace()</strong> method appends a space character or a hyphen, depending on the context:</p>
			<p class="source-code">void numword::appendspace() {</p>
			<p class="source-code">    if(bufsize()) {</p>
			<p class="source-code">        appendbuf( _hyphen_flag ? _hyphen : _space);</p>
			<p class="source-code">        _hyphen_flag = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ul>
				<li>The <strong class="source-inline">numword-test.cpp</strong> file is the testing environment for <strong class="source-inline">bw::numword</strong>. It<a id="_idIndexMarker1140"/> includes<a id="_idIndexMarker1141"/> a <strong class="source-inline">formatter</strong> specialization:<p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">bw::numword</strong>&gt;: std::formatter&lt;unsigned&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(const <strong class="bold">bw::numword&amp; nw</strong>, </p><p class="source-code">      FormatContext&amp; ctx) {</p><p class="source-code">        bw::numword _nw{nw};</p><p class="source-code">        return format_to(ctx.out(), "{}", </p><p class="source-code">          <strong class="bold">_nw.words()</strong>);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>This allows us to pass a <strong class="source-inline">bw::numword</strong> object directly to <strong class="source-inline">format()</strong>.</p>
			<ul>
				<li>There's also a <strong class="source-inline">print()</strong> function that sends <strong class="source-inline">formatter</strong> output directly to <strong class="source-inline">stdout</strong>, bypassing <strong class="source-inline">cout</strong> and the <strong class="source-inline">iostream</strong> library entirely:<p class="source-code">namespace bw {</p><p class="source-code">    template&lt;typename... Args&gt; constexpr void print(</p><p class="source-code">            const std::string_view str_fmt, Args&amp;&amp;... </p><p class="source-code">              args) {</p><p class="source-code">        fputs(std::vformat(str_fmt, </p><p class="source-code">            std::make_format_args(args...)).c_str(), </p><p class="source-code">            stdout);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>This allows us to use <strong class="source-inline">print("{}\n", nw)</strong> instead of piping <strong class="source-inline">format()</strong> through <strong class="source-inline">cout</strong>. A function like this will be included in the C++23 standard. It's simple enough to include it like this for now.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we <a id="_idIndexMarker1142"/>declare a <strong class="source-inline">bw::numword</strong> object <a id="_idIndexMarker1143"/>and a <strong class="source-inline">uint64_t</strong> for use in testing:<p class="source-code">int main() {</p><p class="source-code">    bw::numword nw{};</p><p class="source-code">    uint64_t n{};</p><p class="source-code">    bw::print("n is {}, {}\n", nw.getnum(), nw);</p><p class="source-code">    ...</p></li>
			</ul>
			<p>The <strong class="source-inline">numword</strong> object is initialized to zero, giving us this output from our <strong class="source-inline">print()</strong> statement:</p>
			<p class="source-code"><strong class="bold">n is 0, zero</strong></p>
			<ul>
				<li>We test a variety of ways to call <strong class="source-inline">numword</strong>:<p class="source-code">nw = 3; bw::print("n is {}, {}\n", nw.getnum(), nw);</p><p class="source-code">nw = 47; bw::print("n is {}, {}\n", nw.getnum(), nw);</p><p class="source-code">...</p><p class="source-code">n = 100073; bw::print("n is {}, {}\n", n, bw::numword{n});</p><p class="source-code">n = 1000000001; bw::print("n is {}, {}\n", n, bw::numword{n});</p><p class="source-code">...</p><p class="source-code">n = 474142398123; bw::print("n is {}, {}\n", n, nw(n));</p><p class="source-code">n = 1474142398007; bw::print("n is {}, {}\n", n, nw(n));</p><p class="source-code">...</p><p class="source-code">n = 999999999999999999; bw::print("n is {}, {}\n", n, nw(n));</p><p class="source-code">n = 1000000000000000000; bw::print("n is {}, {}\n", n, nw(n));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">n is 3, three</strong></p>
			<p class="source-code"><strong class="bold">n is 47, forty-seven</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">n is 100073, one hundred thousand seventy-three</strong></p>
			<p class="source-code"><strong class="bold">n is 1000000001, one billion one</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">n is 474142398123, four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand one hundred twenty-three</strong></p>
			<p class="source-code"><strong class="bold">n is 1474142398007, one trillion four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand seven</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">n is 999999999999999999, nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine</strong></p>
			<p class="source-code"><strong class="bold">n is 1000000000000000000, error</strong></p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor367"/>How it works…</h2>
			<p>This class is significantly driven by the data structures. By organizing <strong class="source-inline">string_view</strong> objects into arrays, we <a id="_idIndexMarker1144"/>can easily translate scalar values into <a id="_idIndexMarker1145"/>corresponding words:</p>
			<p class="source-code">appendbuf(_tens[_n]);  // e.g., _tens[5] = "fifty"</p>
			<p>The rest of it is mostly the math:</p>
			<p class="source-code">numnum power{ <strong class="bold">pow_i(thousand, i)</strong> };</p>
			<p class="source-code">numnum _n{ <strong class="bold">( n - ( n % power ) ) / power</strong> };</p>
			<p class="source-code">if (_n) {</p>
			<p class="source-code">    int index = i;</p>
			<p class="source-code">    numword _nw{ _n };</p>
			<p class="source-code">    <strong class="bold">appendbuf(_nw.words());</strong></p>
			<p class="source-code">    <strong class="bold">appendbuf(_powers[index]);</strong></p>
			<p class="source-code">    <strong class="bold">n -= _n * power;</strong></p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor368"/>There's more…</h2>
			<p>I also have a utility that uses the <strong class="source-inline">numwords</strong> class to tell time in words. Its output looks like this:</p>
			<p class="source-code">$ ./saytime</p>
			<p class="source-code">three past five</p>
			<p>In test mode, it gives this output:</p>
			<p class="source-code">$ ./saytime test</p>
			<p class="source-code">00:00 midnight</p>
			<p class="source-code">00:01 one past midnight</p>
			<p class="source-code">11:00 eleven o'clock</p>
			<p class="source-code">12:00 noon</p>
			<p class="source-code">13:00 one o'clock</p>
			<p class="source-code">12:29 twenty-nine past noon</p>
			<p class="source-code">12:30 half past noon</p>
			<p class="source-code">12:31 twenty-nine til one</p>
			<p class="source-code">12:15 quarter past noon</p>
			<p class="source-code">12:30 half past noon</p>
			<p class="source-code">12:45 quarter til one</p>
			<p class="source-code">11:59 one til noon</p>
			<p class="source-code">23:15 quarter past eleven</p>
			<p class="source-code">23:59 one til midnight</p>
			<p class="source-code">12:59 one til one</p>
			<p class="source-code">13:59 one til two</p>
			<p class="source-code">01:60 OOR</p>
			<p class="source-code">24:00 OOR</p>
			<p>I leave<a id="_idIndexMarker1146"/> its<a id="_idIndexMarker1147"/> implementation as an exercise for the reader.</p>
		</div>
	</body></html>