<html><head></head><body>
		<div><h1 id="_idParaDest-348"><em class="italic"><a id="_idTextAnchor347"/>Chapter 11</em>: A Few More Ideas</h1>
			<p>We've learned some useful techniques in this book, including optional values, containers, iterators, algorithms, smart pointers, and more. We've seen examples of these concepts in use, and we've had the opportunity to experiment and apply them to some small projects. Let's now apply these techniques to a few more practical ideas.</p>
			<p>In this chapter, we cover the following recipes:</p>
			<ul>
				<li>Create a trie class for search suggestions</li>
				<li>Calculate the error sum of two vectors</li>
				<li>Build your own algorithm: <code>split</code></li>
				<li>Leverage existing algorithms: <code>gather</code></li>
				<li>Remove consecutive whitespace</li>
				<li>Convert numbers to words</li>
			</ul>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor348"/>Technical requirement</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11</a>.</p>
			<h1 id="_idParaDest-350"><a id="_idTextAnchor349"/>Create a trie class for search suggestions</h1>
			<p>A <em class="italic">trie</em>, sometimes <a id="_idIndexMarker1076"/>called <a id="_idIndexMarker1077"/>a <em class="italic">prefix tree</em>, is a <a id="_idIndexMarker1078"/>type of search tree, commonly used for predictive text and other search applications. A trie is a recursive structure designed for depth-first searches, where each <em class="italic">node</em> is both a key and another trie.</p>
			<p>A common use case is a <em class="italic">trie of strings</em>, where each node is a string in a sentence. For example:</p>
			<div><div><img src="img/B18267_11_01.jpg" alt="Figure 11.1 – A trie of strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – A trie of strings</p>
			<p>We often start a search at the <em class="italic">head</em> of a trie, looking for sentences that begin with a specific word. In this example, when I search for <code>all</code>, I get three nodes: <code>you</code>, <code>the</code>, and <code>along</code>. If I search for <code>love</code>, I get <code>me</code> and <code>is</code>.</p>
			<p>A string trie is <a id="_idIndexMarker1079"/>commonly used for creating search<a id="_idIndexMarker1080"/> suggestions. Here we will implement a string trie using <code>std::map</code> for the trie structure.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor350"/>How to do it…</h2>
			<p>In this recipe, we create a recursive <code>trie</code> class that stores nodes in a <code>std::map</code> container. It's a simple solution for a small in-memory trie. This is a rather large class, so we'll only show the important parts here.</p>
			<p>For the full class, please see the source code at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap11/trie.cpp</a>.</p>
			<ul>
				<li>We have one convenience alias:<pre>using ilcstr = initializer_list&lt;const char *&gt;;</pre></li>
			</ul>
			<p>We use <code>ilcstr</code> in for searching the <code>trie</code>.</p>
			<ul>
				<li>We'll put this class in a private namespace to avoid collisions:<pre>namespace <strong class="bold">bw</strong> {
    <strong class="bold">using</strong> std::map;
    <strong class="bold">using</strong> std::deque;
    <strong class="bold">using</strong> std::initializer_list;</pre></li>
			</ul>
			<p>We have a few <code>using</code> statements in this namespace for convenience.</p>
			<ul>
				<li>The class <a id="_idIndexMarker1081"/>itself is called <code>trie</code>. It has <a id="_idIndexMarker1082"/>three data members:<pre>class trie {
    using <strong class="bold">get_t</strong> = deque&lt;deque&lt;string&gt;&gt;;
    using <strong class="bold">nodes_t</strong> = map&lt;string, trie&gt;;
    using <strong class="bold">result_t</strong> = std::optional&lt;const trie*&gt;;
    nodes_t <strong class="bold">nodes</strong>{};
    mutable get_t <strong class="bold">result_dq</strong>{};
    mutable deque&lt;string&gt; <strong class="bold">prefix_dq</strong>{};</pre></li>
			</ul>
			<p>The <code>trie</code> class has a few local type aliases:</p>
			<ul>
				<li><code>get_t</code> is a <code>deque</code> of <code>deque</code> of <code>string</code>, used for string results.</li>
				<li><code>nodes_t </code>is a map of <code>trie</code> classes with <code>string</code> keys.</li>
				<li><code>result_t</code> is an <code>optional</code> of a pointer to a <code>trie</code>, for returning search results. An empty <code>trie</code> is a valid result, so we use an <code>optional</code> value.</li>
			</ul>
			<p>The <code>nodes</code> object is used for holding a recursive <code>map</code> of nodes, where each node on a <code>trie</code> is another <code>trie</code>.</p>
			<ul>
				<li>The public interface often calls utility functions in the private interface. For example, the <code>insert()</code> method takes an <code>initializer_list</code> object and calls the private function <code>_insert()</code>:<pre>void insert(const ilcstr&amp; il) {
    _insert(il.begin(), il.end());
}</pre></li>
			</ul>
			<p>The private <code>_insert()</code> function does the work of inserting elements:</p>
			<pre>template &lt;typename It&gt;
void _insert(It it, It end_it) {
    if(it == end_it) return;
    <strong class="bold">nodes[*it]</strong>._insert(++it, end_it);
}</pre>
			<p>This <a id="_idIndexMarker1083"/>facilitates<a id="_idIndexMarker1084"/> the recursive function calls necessary to navigate the <code>trie</code>. Note that referencing a key that does not appear in a <code>map</code> creates an empty element with that key. So, the line that calls <code>_insert()</code> on a <code>nodes</code> element creates an empty <code>trie</code> object if the element doesn't already exist.</p>
			<ul>
				<li>The <code>get()</code> method returns a <code>get_t</code> object, which is an alias for a <code>deque</code> of <code>deque</code> of <code>string</code>. This allows us to return multiple sets of results:<pre><strong class="bold">get_t</strong>&amp; get() const {
    result_dq.clear();
    deque&lt;string&gt; dq{};
    <strong class="bold">_get(dq, result_dq)</strong>;
    return result_dq;
}</pre></li>
			</ul>
			<p>The <code>get()</code> method calls the private <code>_get()</code> function, which recursively traverses the <code>trie</code>:</p>
			<pre>void <strong class="bold">_get(deque&lt;string&gt;&amp; dq, get_t&amp; r_dq)</strong> const {
    if(empty()) {
        r_dq.emplace_back(dq);
        dq.clear();
    }
    for(const auto&amp; p : nodes) {
        dq.emplace_back(p.first);
        <strong class="bold">p.second._get(dq, r_dq)</strong>;
    }
}</pre>
			<ul>
				<li>The <code>find_prefix()</code> function <a id="_idIndexMarker1085"/>returns a <code>deque</code> with<a id="_idIndexMarker1086"/> all matches to a partial string.<pre>deque&lt;string&gt;&amp; find_prefix(const char * s) const {
    <strong class="bold">_find_prefix(s, prefix_dq);</strong>
    return prefix_dq;
}</pre></li>
			</ul>
			<p>The public interface calls the private function <code>_find_prefix()</code>:</p>
			<pre>void _find_prefix(const string&amp; s, auto&amp; pre_dq) const {
    if(empty()) return;
    for(const auto&amp; [k, v] : nodes) {
        if(<strong class="bold">k.starts_with(s)</strong>) {
            pre_dq.emplace_back(k);
            v._find_prefix(k, pre_dq);
        }
    }
}</pre>
			<p>The private <code>_find_prefix()</code> function traverses the <code>trie</code> recursively, comparing the prefix with beginning of each key. The <code>starts_with()</code> method is new with C++20. With an older STL, you could use the <code>find()</code> method and check the return value for <code>0</code>:</p>
			<pre>if(<strong class="bold">k.find(s) == 0</strong>) {
    ...</pre>
			<ul>
				<li>The <code>search()</code> function returns an <code>optional&lt;const trie*&gt;</code>, aliased as <code>result_t</code>. It has<a id="_idIndexMarker1087"/> two<a id="_idIndexMarker1088"/> overloads:<pre>result_t search(const ilcstr&amp; il) const {
    return <strong class="bold">_search</strong>(il.begin(), il.end());
}
result_t search(const string&amp; s) const {
    const ilcstr il{s.c_str()};
    return <strong class="bold">_search</strong>(il.begin(), il.end());
}</pre></li>
			</ul>
			<p>These methods pass iterators to the private member function <code>_search()</code>, which does the work of the search:</p>
			<pre>template &lt;typename It&gt;
result_t _search(It it, It end_it) const {
    <strong class="bold">if(it == end_it) return {this};</strong>
    auto found_it = nodes.find(*it);
    <strong class="bold">if(found_it == nodes.end()) return {};</strong>
    <strong class="bold">return found_it-&gt;second._search(++it, end_it);</strong>
}</pre>
			<p>The <code>_search()</code> function searches recursively until it finds a match, then returns a node in the <code>result_t</code> object. If it finds no match, it returns the non-value <code>optional</code>.</p>
			<ul>
				<li>We also have two overloads of a <code>print_trie_prefix()</code> function. This function prints the contents of a <code>trie</code> from a prefix, used as a search key. One version <a id="_idIndexMarker1089"/>uses a <code>string</code> for the prefix, the <a id="_idIndexMarker1090"/>other uses an <code>initializer_list</code> of C-strings:<pre>void print_trie_prefix(const bw::trie&amp; t,
        <strong class="bold">const string&amp; prefix</strong>) {
    auto&amp; trie_strings = t.get();
    cout &lt;&lt; format("results for \"{}...\":\n", prefix);
    for(auto&amp; dq : trie_strings) {
        cout &lt;&lt; format("{} ", prefix);
        for(const auto&amp; s : dq) cout &lt;&lt; format("{} ", s);
        cout &lt;&lt; '\n';
    }
}
void print_trie_prefix(const bw::trie&amp; t,
        <strong class="bold">const ilcstr &amp; prefix</strong>) {
    string sprefix{};
    for(const auto&amp; s : prefix) sprefix += 
        format("{} ", s);
    print_trie_prefix(t, sprefix);
}</pre></li>
			</ul>
			<p>These functions call the <code>get()</code> member function to retrieve the results from the <code>trie</code>.</p>
			<ul>
				<li>Now we can<a id="_idIndexMarker1091"/> test <a id="_idIndexMarker1092"/>the <code>trie</code> class in the <code>main()</code> function. First, we declare a <code>trie</code> and insert some sentences:<pre>int main() {
    <strong class="bold">bw::trie ts</strong>;
    <strong class="bold">ts.insert</strong>({ "all", "along", "the", "watchtower" });
    <strong class="bold">ts.insert</strong>({ "all", "you", "need", "is", "love" });
    <strong class="bold">ts.insert</strong>({ "all", "shook", "up" });
    <strong class="bold">ts.insert</strong>({ "all", "the", "best" });
    <strong class="bold">ts.insert</strong>({ "all", "the", "gold", "in",
        "california" });
    <strong class="bold">ts.insert</strong>({ "at", "last" });
    <strong class="bold">ts.insert</strong>({ "love", "the", "one", "you're",        "with" });
    <strong class="bold">ts.insert</strong>({ "love", "me", "do" });
    <strong class="bold">ts.insert</strong>({ "love", "is", "the", "answer" });
    <strong class="bold">ts.insert</strong>({ "loving", "you" });
    <strong class="bold">ts.insert</strong>({ "long", "tall", "sally" });
    ...</pre></li>
			</ul>
			<p>The <code>insert()</code> calls pass an <code>initializer_list</code> with all the strings of a sentence. Each of the strings of a sentence are inserted into the hierarchy of the <code>trie</code>.</p>
			<ul>
				<li>Now we can search the trie. Here's a simple search for the single string <code>"love"</code>.<pre>const auto <strong class="bold">prefix = {"love"}</strong>;
if (auto st = <strong class="bold">ts.search(prefix)</strong>; st.have_result) {
    <strong class="bold">print_trie_prefix(*st.t, prefix)</strong>;
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>This calls <code>ts.search()</code> with an <code>initializer_list</code> of one C-string, called <code>prefix</code>. The <a id="_idIndexMarker1093"/>result, along with the <code>prefix</code>, is then<a id="_idIndexMarker1094"/> passed to the <code>print_trie_prefix()</code> function.</p>
			<p>The output is:</p>
			<pre><strong class="bold">results for "love...":</strong>
<strong class="bold">love is the answer</strong>
<strong class="bold">love me do</strong>
<strong class="bold">love the one you're with</strong></pre>
			<ul>
				<li>Here's a search for a two-string prefix:<pre>const auto <strong class="bold">prefix = {"all", "the"}</strong>;
if (auto st = ts.search(prefix); st.have_result) {
    print_trie_prefix(*st.t, prefix);
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">results for "all the ...":</strong>
<strong class="bold">all the  best</strong>
<strong class="bold">all the  gold in california</strong></pre>
			<ul>
				<li>And here's<a id="_idIndexMarker1095"/> a <a id="_idIndexMarker1096"/>search for a partial prefix, using the <code>find_prefix()</code> function:<pre>const char * <strong class="bold">prefix{ "lo" }</strong>;
auto prefix_dq = <strong class="bold">ts.find_prefix(prefix)</strong>;
for(const auto&amp; s : prefix_dq) {
    cout &lt;&lt; format("match: {} -&gt; {}\n", prefix, s);
    if (auto st = ts.search(s); st.have_result) {
        print_trie_prefix(*st.t, s);
    }
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">match: lo -&gt; long</strong>
<strong class="bold">results for "long...":</strong>
<strong class="bold">long tall sally</strong>
<strong class="bold">match: lo -&gt; love</strong>
<strong class="bold">results for "love...":</strong>
<strong class="bold">love is the answer</strong>
<strong class="bold">love me do</strong>
<strong class="bold">love the one you're with</strong>
<strong class="bold">match: lo -&gt; loving</strong>
<strong class="bold">results for "loving...":</strong>
<strong class="bold">loving you</strong></pre>
			<p>The <code>find_prefix()</code> search returned several results, each of which we passed to a search of its own, resulting in several results for each result.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor351"/>How it works…</h2>
			<p>The data for the <code>trie</code> class is stored in recursive <code>map</code> containers. Each node in the <code>map</code> contains another <code>trie</code> object, which in turn has its own <code>map</code> node.</p>
			<pre>using nodes_t = map&lt;string, trie&gt;</pre>
			<p>The <code>_insert()</code> function takes <code>begin</code> and <code>end</code> iterators, and uses them to recursively call <code>_insert()</code> on<a id="_idIndexMarker1097"/> new<a id="_idIndexMarker1098"/> nodes:</p>
			<pre>template &lt;typename It&gt;
void _insert(It it, It end_it) {
    if(it == end_it) return;
    <strong class="bold">nodes[*it]._insert(++it, end_it)</strong>;
}</pre>
			<p>Likewise, the <code>_search()</code> function recursively calls <code>_search()</code> on the nodes it finds:</p>
			<pre>template &lt;typename It&gt;
result_t _search(It it, It end_it) const {
    if(it == end_it) return {this};
    auto found_it = nodes.find(*it);
    if(found_it == nodes.end()) return {};
    return <strong class="bold">found_it-&gt;second._search(++it, end_it)</strong>;
}</pre>
			<p>This recursiv<a id="_idIndexMarker1099"/>e approach using <code>std::map</code> allows <a id="_idIndexMarker1100"/>us to implement a trie class concisely and efficiently.</p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor352"/>Calculate the error sum of two vectors</h1>
			<p>Given two <a id="_idIndexMarker1101"/>similar vectors that differ only by quantization or <a id="_idIndexMarker1102"/>resolution, we can use the <code>inner_product()</code> algorithm to calculate an <em class="italic">error sum</em>, defined as:</p>
			<div><div><img src="img/B18267_11_02.jpg" alt="Figure 11.2 – Error sum definition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Error sum definition</p>
			<p>Where <em class="italic">e</em> is the error sum, the sum of the square of the difference between a series of points in two vectors.</p>
			<p>We can use the <code>inner_product()</code> algorithm, from the <code>&lt;numeric&gt;</code> header, to calculate the error sum between two vectors.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor353"/>How to do it…</h2>
			<p>In this recipe we define two vectors, each with a <em class="italic">sine wave</em>. One <code>vector</code> has values of type <code>double</code> and the other has type <code>int</code>. This gives us vectors that differ in quantization, because the <code>int</code> type cannot represent fractional values. We then use <code>inner_product()</code> to calculate the error sum between the two vectors:</p>
			<ul>
				<li>In our <code>main()</code> function we define our vectors and a handy <code>index</code> variable:<pre>int main() {
    constexpr size_t vlen{ 100 };
    vector&lt;double&gt; <strong class="bold">ds</strong>(vlen);
    vector&lt;int&gt; <strong class="bold">is</strong>(vlen);
    size_t <strong class="bold">index</strong>{};
    ...</pre></li>
			</ul>
			<p><code>ds</code> is the <code>vector</code> of <code>double</code> sine waves and <code>is</code> is the <code>vector</code> of <code>int</code> sine waves. Each <code>vector</code> has 100 elements to hold a sine wave. The <code>index</code> variable is used to initialize the <code>vector</code> objects.</p>
			<ul>
				<li>We generate the sine wave in the <code>vector</code> of <code>double</code>, using a loop and a lambda:<pre>auto <strong class="bold">sin_gen</strong> = [<strong class="bold">&amp;index</strong>]{
  return 5.0 * sin(index++ * 2 * <strong class="bold">pi</strong> / 100);
};
for(auto&amp; v : ds) v = <strong class="bold">sin_gen()</strong>;</pre></li>
			</ul>
			<p>The lambda<a id="_idIndexMarker1103"/> captures a reference to the <code>index</code> variable<a id="_idIndexMarker1104"/> so it can be incremented.</p>
			<p>The <code>pi</code> constant is from the <code>std::numbers</code> library.</p>
			<ul>
				<li>We now have a <code>double</code> sine wave and we can use it to derive the <code>int</code> version:<pre>index = 0;
for(auto&amp; v : is) {
    v = <strong class="bold">static_cast&lt;int&gt;(round(ds.at(index++)))</strong>;
}</pre></li>
			</ul>
			<p>This takes each point from <code>ds</code>, rounds it, casts it to an <code>int</code>, and updates it in position in the <code>is</code> container.</p>
			<ul>
				<li>We display our sine waves with a simple loop:<pre>for(const auto&amp; v : ds) cout &lt;&lt; format("{:-5.2f} ", v);
cout &lt;&lt; "\n\n";
for(const auto&amp; v : is) cout &lt;&lt; format("{:-3d} ", v);
cout &lt;&lt; "\n\n";</pre></li>
			</ul>
			<p>Our output is the sine waves as data points in the two containers:</p>
			<pre><strong class="bold">0.00  0.31  0.63  0.94  1.24  1.55  1.84  2.13  2.41</strong>
<strong class="bold">0.00  0.31  0.63  0.94</strong><strong class="bold">  1.24  1.55  1.84  2.13  2.41</strong>
<strong class="bold">2.68  2.94  3.19  3.42  3.64  3.85</strong><strong class="bold">  4.05  4.22  4.38</strong>
<strong class="bold">4.52  4.65  4.76  4.84  4.91  4.96  4.99  5.00</strong><strong class="bold">  4.99</strong>
<strong class="bold">4.96  4.91  4.84  4.76  4.65  4.52  4.38  4.22  4.05</strong>
<strong class="bold">3.85  3.64  3.42  3.19  2.94  2.68  2.41  2.13  1.84</strong>
<strong class="bold">1.55  1.24  0.94  0.63  0.31  0.00 -0.31 -0.63 -0.94 -1.24 -1.55 -1.84 -2.13 -2.41 -2.68 -2.94 -3.19 -3.42 -3.64 -3.85 -4.05 -4.22 -4.38 -4.52 -4.65 -4.76 -4.84 -4.91 -4.96 -4.99 -5.00 -4.99 -4.96 -4.91 -4.84 -4.76 -4.65 -4.52 -4.38 -4.22 -4.05 -3.85 -3.64 -3.42 -3.19 -2.94 -2.68 -2.41 -2.13 -1.84 -1.55 -1.24 -0.94 -0.63 -0.31</strong>
<strong class="bold">0   0   1   1   1   2   2   2   2   3   3   3   3   4   4 4   4   4   5   5   5   5   5  </strong><strong class="bold"> 5   5   5   5   5   5   5 5</strong><strong class="bold">   5   5   4   4   4   4   </strong><strong class="bold">4   3   3   3   3   2   2   2 2   1   1   1   0   0   0   -1   -1   -1   -2   -2   -2 </strong><strong class="bold">-2   -3   -3   -3   -3   -4   -4   -4   -4   -4</strong><strong class="bold">   -5   -5 -5   -5   -5   -5   -5   -5   -5  </strong><strong class="bold"> -5   -5   -5   -5   -5 -5   -4   -4   -4   -4   -4</strong><strong class="bold">   -3   -3   -3   -3   -2   -2 -2   -2   -1   -1   -1   0</strong></pre>
			<ul>
				<li>Now <a id="_idIndexMarker1105"/>we<a id="_idIndexMarker1106"/> calculate the error sum using <code>inner_product()</code>:<pre>double errsum = <strong class="bold">inner_product</strong>(ds.begin(), ds.end(), 
    is.begin(), 0.0, std::plus&lt;double&gt;(),
    <strong class="bold">[](double a, double b){ return pow(a - b, 2); })</strong>;
cout &lt;&lt; format("error sum: {:.3f}\n\n", errsum);</pre></li>
			</ul>
			<p>The lambda expression returns the (<em class="italic">a</em>i – <em class="italic">b</em>i)2 part of the formula. The <code>std::plus()</code> algorithm performs the sum operation.</p>
			<p>Output:</p>
			<pre><strong class="bold">error sum: 7.304</strong></pre>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor354"/>How it works…</h2>
			<p>The <code>inner_product()</code> algorithm computes a sum of products on the first input range. Its signature is:</p>
			<pre>T inner_product(InputIt1 first1, InputIt1 last1,
    InputIt2 first2, T init, BinaryOperator1 op1,
    BinaryOperator2 op2)</pre>
			<p>The function takes two binary operator functors, <code>op1</code> and <code>op2</code>. The first <code>op1</code> is for the <em class="italic">sum</em> and the second <code>op2</code> is for the <em class="italic">product</em>. We use <code>std::plus()</code> as the sum operator, and a lambda as the product operator.</p>
			<p>The <code>init</code> parameter <a id="_idIndexMarker1107"/>can be used as a starting value or<a id="_idIndexMarker1108"/> bias. We pass it the literal value, <code>0.0</code>.</p>
			<p>The return value is the accumulated sum of the products.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor355"/>There's more…</h2>
			<p>We can <a id="_idIndexMarker1109"/>calculate an accumulated error sum by putting <code>inner_product()</code> in a loop:</p>
			<pre>cout &lt;&lt; "accumulated error:\n";
for (auto it{ds.begin()}; it != ds.end(); ++it) {
    double accumsum = inner_product(ds.begin(), it, 
        is.begin(), 0.0, std::plus&lt;double&gt;(),
        [](double a, double b){ return pow(a - b, 2); });
    cout &lt;&lt; format("{:-5.2f} ", accumsum);
}
cout &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>accumulated error:
0.00  0.00  0.10  0.24  0.24  0.30  0.51  0.53  0.55  0.72  0.82  0.82  0.86  1.04  1.16  1.19  1.19  1.24  1.38  1.61  1.73  1.79  1.82  1.82  1.83  1.83  1.83  1.83  1.83  1.84  1.86  1.92  2.04  2.27  2.42  2.46  2.47  2.49  2.61  2.79  2.83  2.83  2.93  3.10  3.12  3.14  3.35  3.41  3.41  3.55  3.65  3.65  3.75  3.89  3.89  3.95  4.16  4.19  4.20  4.37  4.47  4.48  4.51  4.69  4.82  4.84  4.84  4.89  5.03  5.26  5.38  5.44  5.47  5.48  5.48  5.48  5.48  5.48  5.48  5.49  5.51  5.57  5.70  5.92  6.07  6.12  6.12  6.14  6.27  6.45  6.48  6.48  6.59  6.75  6.77  6.80  7.00  7.06  7.07  7.21</pre>
			<p>This may be <a id="_idIndexMarker1110"/>useful in some statistical applications.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor356"/>Build your own algorithm: split</h1>
			<p>The STL has a<a id="_idIndexMarker1111"/> rich <code>algorithm</code> library. Yet, on occasion you may find it missing something you need. One common need is a <code>split</code> function.</p>
			<p>A <code>split</code> function splits a string on a character separator. For example, here's a Unix <code>/etc/passwd</code> file from a standard Debian installation:</p>
			<pre>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync</pre>
			<p>Each field is separated by a colon <code>:</code> character, where the fields are:</p>
			<ol>
				<li>Login name</li>
				<li>Optional encrypted password</li>
				<li>User ID</li>
				<li>Group ID</li>
				<li>Username or comment</li>
				<li>Home directory</li>
				<li>Optional command interpreter</li>
			</ol>
			<p>This is a standard file in POSIX-based operating systems, and there are others like it. Most scripting languages include a built-in function for splitting a string on a separator. There are simple ways to do this in C++. Still, <code>std::string</code> is just another container in the STL, and a generic algorithm that splits a container on a separator could be a useful addition<a id="_idIndexMarker1112"/> to the toolbox. So, let's build one.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor357"/>How to do it…</h2>
			<p>In this recipe, we build a generic algorithm that splits a container on a separator and puts the results in a target container.</p>
			<ul>
				<li>Our algorithm is in the <code>bw</code> namespace, to avoid collisions with <code>std</code>:<pre>namespace <strong class="bold">bw</strong> {
    template&lt;typename <strong class="bold">It</strong>, typename <strong class="bold">Oc</strong>, typename <strong class="bold">V</strong>,
        typename <strong class="bold">Pred</strong>&gt;
    <strong class="bold">It</strong> split(It <strong class="bold">it</strong>, It <strong class="bold">end_it</strong>, Oc&amp; <strong class="bold">dest</strong>,
            const V&amp; <strong class="bold">sep</strong>, Pred&amp; <strong class="bold">f</strong>) {
        using <strong class="bold">SliceContainer</strong> = typename 
          <strong class="bold">Oc::value_type</strong>;
        while(it != end_it) {
            <strong class="bold">SliceContainer</strong> dest_elm{};
            auto <strong class="bold">slice</strong>{ it };
            while(slice != end_it) {
                if(<strong class="bold">f(*slice, sep)</strong>) break;
                <strong class="bold">dest_elm.push_back(*slice++);</strong>
            }
            <strong class="bold">dest.push_back(dest_elm);</strong>
            if(slice == end_it) return end_it;
            it = ++slice;
        }
        return it;
    }
};</pre></li>
			</ul>
			<p>The <code>split()</code> algorithm searches a container for separators and collects the separated slices<a id="_idIndexMarker1113"/> into a new output container, where each slice is a container within the output container.</p>
			<p>We want the <code>split()</code> algorithm to be as generic as possible, just like those in the <code>algorithm</code> library. This means that all the parameters are templated, and the code will work with a comprehensive variety of parameter types.</p>
			<p>First, let's look at the template parameters:</p>
			<ul>
				<li><code>It</code> is the input iterator type for the source container.</li>
				<li><code>Oc</code> is the output container type. This is a container of containers.</li>
				<li><code>V</code> is the separator type.</li>
				<li><code>Pred</code> is for the predicate functor.</li>
			</ul>
			<p>Our output type is a container of containers. It needs to hold containers of slices. It could be <code>vector&lt;string&gt;</code>, where the string values are slices, or <code>vector&lt;vector&lt;int&gt;&gt;</code>, where the inner <code>vector&lt;int&gt;</code> contains the slices. This means we need to derive the type of the inner container from the output container type. We do that with the <code>using</code> declaration in the body of the function.</p>
			<pre>using <strong class="bold">SliceContainer</strong> = typename <strong class="bold">Oc::value_type</strong>;</pre>
			<p>This is also why we cannot use an output iterator for the output parameter. By definition, an output iterator cannot determine the type of its contents and its <code>value_type</code> is set to <code>void</code>.</p>
			<p>We use <code>SliceContainer</code> to define a temporary container that is added to the output container with the statement:</p>
			<pre>dest.push_back(dest_elm);</pre>
			<ul>
				<li>The predicate<a id="_idIndexMarker1114"/> is a binary operator that compares an input element with the separator. We include a default equality operator in the <code>bw</code> namespace:<pre>constexpr auto <strong class="bold">eq</strong> = [](const auto&amp; <strong class="bold">el</strong>, const auto&amp; <strong class="bold">sep</strong>) {
    return <strong class="bold">el</strong> == <strong class="bold">sep</strong>;
};</pre></li>
				<li>We also include a specialization of <code>split()</code> that uses the <code>eq</code> operator by default:<pre>template&lt;typename It, typename Oc, typename V&gt;
It split(It <strong class="bold">it</strong>, const It <strong class="bold">end_it</strong>, Oc&amp; <strong class="bold">dest</strong>, const V&amp; <strong class="bold">sep</strong>) {
    return <strong class="bold">split(it, end_it, dest, sep, eq)</strong>;
}</pre></li>
				<li>Because splitting <code>string</code> objects is a common use case for this algorithm, we include a helper function for that specific purpose:<pre>template&lt;typename <strong class="bold">Cin</strong>, typename <strong class="bold">Cout</strong>, typename <strong class="bold">V</strong>&gt;
Cout&amp; strsplit(const Cin&amp; <strong class="bold">str</strong>, Cout&amp; <strong class="bold">dest</strong>, const V&amp; <strong class="bold">sep</strong>) {
    <strong class="bold">split(str.begin(), str.end(), dest, sep, eq);</strong>
    return dest;
}</pre></li>
				<li>We test our <a id="_idIndexMarker1115"/>split algorithm <code>main()</code>, starting with a <code>string</code> object:<pre>int main() {
    constexpr char <strong class="bold">strsep</strong>{ ':' };
    const string <strong class="bold">str</strong>
        { "<strong class="bold">sync:x:4:65534:sync:/bin:/bin/sync</strong>" };
    <strong class="bold">vector&lt;string&gt; dest_vs</strong>{};
    <strong class="bold">bw::split(str.begin(), str.end(), dest_vs, strsep, </strong>
<strong class="bold">        bw::eq)</strong>;
    for(const auto&amp; e : dest_vs) cout &lt;&lt;
        format("[{}] ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>We use a string from the <code>/etc/passwd</code> file to test our algorithm, with this result:</p>
			<pre>[sync] [x] [4] [65534] [sync] [/bin] [/bin/sync]</pre>
			<ul>
				<li>It's even simpler using our <code>strsplit()</code> helper function:<pre>vector&lt;string&gt; <strong class="bold">dest_vs2</strong>{};
<strong class="bold">bw::strsplit(str, dest_vs2, strsep);</strong>
for(const auto&amp; e : dest_vs2) cout &lt;&lt; format("[{}] ", e);
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">[sync] [x] [4] [65534] [sync] [/bin] [/bin/sync]</strong></pre>
			<p>This would make it easy to parse the <code>/etc/passwd</code> file.</p>
			<ul>
				<li>Of course, we <a id="_idIndexMarker1116"/>can use the same algorithm with any container:<pre>constexpr int <strong class="bold">intsep</strong>{ -1 };
<strong class="bold">vector&lt;int&gt;</strong> vi{ 1, 2, 3, 4, <strong class="bold">intsep</strong>, 5, 6, 7, 8, <strong class="bold">intsep</strong>,
    9, 10, 11, 12 };
<strong class="bold">vector&lt;vector&lt;int&gt;&gt; dest_vi</strong>{};
<strong class="bold">bw::split(vi.begin(), vi.end(), dest_vi, intsep)</strong>;
for(const auto&amp; v : dest_vi) {
    string s;
    for(const auto&amp; e : v) s += format("{}", e);
    cout &lt;&lt; format("[{}] ", s);
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">[1234] [5678] [9101112]</strong></pre>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor358"/>How it works…</h2>
			<p>The split algorithm itself is relatively simple. The magic in this recipe is in the use of templates to make it as generic as possible.</p>
			<p>The derived type in the <code>using</code> declaration allows us to create a container for use with the output container:</p>
			<pre>using <strong class="bold">SliceContainer</strong> = typename <strong class="bold">Oc::value_type</strong>;</pre>
			<p>This gives us a <code>SliceContainer</code> type that we can use to create a container for the slices:</p>
			<pre><strong class="bold">SliceContainer</strong> dest_elm{};</pre>
			<p>This is a temporary<a id="_idIndexMarker1117"/> container that is added to the output container for each slice:</p>
			<pre>dest.push_back(dest_elm);</pre>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>Leverage existing algorithms: gather</h1>
			<p><code>gather()</code> is an example<a id="_idIndexMarker1118"/> of an algorithm that leverages existing algorithms.</p>
			<p>The <code>gather()</code> algorithm takes a pair of container iterators and moves the elements that satisfy a predicate toward a <em class="italic">pivot</em> position within the sequence, returning a <code>pair</code> of iterators that contains the elements that satisfy the predicate.</p>
			<p>For example, we could use a <code>gather</code> algorithm to sort all the even numbers to the mid-point of a <code>vector</code>:</p>
			<pre>vector&lt;int&gt; <strong class="bold">vint</strong>{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
<strong class="bold">gather</strong>(vint.begin(), vint.end(), mid(vint), is_even);
for(const auto&amp; <strong class="bold">el</strong> : <strong class="bold">vint</strong>) cout &lt;&lt; <strong class="bold">el</strong>;</pre>
			<p>Our output is:</p>
			<pre>13<strong class="bold">02468</strong>579</pre>
			<p>Notice that the even numbers are all in the middle of the output.</p>
			<p>In this recipe, we will implement a <code>gather</code> algorithm using standard STL algorithms.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>How to do it…</h2>
			<p>Our <code>gather</code> algorithm uses the <code>std::stable_partition()</code> algorithm to move items before the pivot iterator and again to move items past the pivot.</p>
			<ul>
				<li>We put the algorithm in the <code>bw</code> namespace to avoid collisions.<pre>namespace bw {
using std::stable_partition;
using std::pair;
using std::not_fn;
template &lt;typename It, typename Pred&gt;
<strong class="bold">pair</strong>&lt;<strong class="bold">It, It</strong>&gt; <strong class="bold">gather</strong>(It <strong class="bold">first</strong>, It <strong class="bold">last</strong>, It <strong class="bold">pivot</strong>,
        Pred <strong class="bold">pred</strong>) {
    return {stable_partition(<strong class="bold">first</strong>, <strong class="bold">pivot</strong>, <strong class="bold">not_fn(pred)</strong>),
            stable_partition(<strong class="bold">pivot, last, pred)</strong>};
}
};</pre></li>
			</ul>
			<p>The <code>gather()</code> algorithm <a id="_idIndexMarker1119"/>returns a <code>pair</code> of iterators, returned from two calls to <code>stable_partition()</code>.</p>
			<ul>
				<li>We also include some helper lambdas:<pre>constexpr auto <strong class="bold">midit</strong> = [](auto&amp; v) {
    return v.begin() + (v.end() - v.begin()) / 2;
};
constexpr auto <strong class="bold">is_even</strong> = [](auto i) {
    return i % 2 == 0;
};
constexpr auto <strong class="bold">is_even_char</strong> = [](auto c) {
    if(c &gt;= '0' &amp;&amp; c &lt;= '9') return (c - '0') % 2 == 0;
    else return false;
};</pre></li>
			</ul>
			<p>These three lambdas are as follows:</p>
			<ul>
				<li><code>midit</code> returns an iterator at the midpoint of a container, for use as a pivot point.</li>
				<li><code>is_even</code> returns Boolean <code>true</code> if the value is even, for use as a predicate.</li>
				<li><code>is_even_char</code> returns Boolean <code>true</code> if the value is a character between <code>'0'</code> and <code>'9'</code> and is even, for use as a predicate.</li>
			</ul>
			<ul>
				<li>We call <code>gather()</code> from <a id="_idIndexMarker1120"/>the <code>main()</code> function with a vector of <code>int</code> like this:<pre>int main() {
    vector&lt;int&gt; <strong class="bold">vint</strong>{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    auto <strong class="bold">gathered_even = bw::gather</strong>(vint.begin(),
        vint.end(), bw::midit(vint), bw::is_even);
    for(const auto&amp; el : vint) cout &lt;&lt; el;
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>Our output shows that the even numbers have been gathered in the middle:</p>
			<pre>13<strong class="bold">02468</strong>579</pre>
			<p>The <code>gather()</code> function returns a <code>pair</code> of iterators that contain just the even values:</p>
			<pre>auto&amp; [it1, it2] = gathered_even;
for(auto it{ it1 }; it &lt; it2; ++it) cout &lt;&lt; *it;
cout &lt;&lt; '\n';</pre>
			<p>Output: </p>
			<pre><strong class="bold">02468</strong></pre>
			<ul>
				<li>We can set the pivot point to the <code>begin()</code> or <code>end()</code> iterators:<pre>bw::gather(vint.begin(), vint.end(), <strong class="bold">vint.begin()</strong>, 
    bw::is_even);
for(const auto&amp; el : vint) cout &lt;&lt; el;
cout &lt;&lt; '\n';
bw::gather(vint.begin(), vint.end(), <strong class="bold">vint.end()</strong>,
    bw::is_even);
for(const auto&amp; el : vint) cout &lt;&lt; el;
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">02468</strong>13579
13579<strong class="bold">02468</strong></pre>
			<ul>
				<li>Because <code>gather()</code> is iterator-based, we can use it with any container. Here's a string of <a id="_idIndexMarker1121"/>character digits:<pre>string <strong class="bold">jenny</strong>{ "867-5309" };
bw::gather(jenny.begin(), jenny.end(), jenny.<strong class="bold">end()</strong>,
    <strong class="bold">bw::is_even_char</strong>);
for(const auto&amp; el : jenny) cout &lt;&lt; el;
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>This moves all the even digits to the end of the string:</p>
			<p>Output:</p>
			<pre>7-539<strong class="bold">860</strong></pre>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>How it works…</h2>
			<p>The <code>gather()</code> function uses the <code>std::stable_partition()</code> algorithm to move the elements that match the predicate to the pivot point.</p>
			<p><code>gather()</code> has two calls to <code>stable_partition()</code>, one with the predicate, and one with the predicate negated:</p>
			<pre>template &lt;typename It, typename Pred&gt;
<strong class="bold">pair&lt;It, It&gt;</strong> gather(It first, It last, It pivot, Pred pred) {
    return { <strong class="bold">stable_partition(first, pivot, not_fn(pred))</strong>,
             <strong class="bold">stable_partition(pivot, last, pred)</strong> };
}</pre>
			<p>The iterators<a id="_idIndexMarker1122"/> returned from the two <code>stable_partition()</code> calls are returned in the <code>pair</code>.</p>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor362"/>Remove consecutive whitespace</h1>
			<p>When receiving<a id="_idIndexMarker1123"/> input from users, it's common to end up with excessive consecutive whitespace characters in your strings. This recipe presents a function for removing consecutive spaces, even when it includes tabs or other whitespace characters.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>How to do it…</h2>
			<p>This function leverages the <code>std::unique()</code> algorithm to remove consecutive whitespace characters from a string.</p>
			<ul>
				<li>In the <code>bw</code> namespace, we start with a function to detect whitespace:<pre>template&lt;typename <strong class="bold">T</strong>&gt;
bool isws(<strong class="bold">const T&amp;</strong> c) {
    constexpr const <strong class="bold">T</strong> whitespace[]{ " \t\r\n\v\f" };
    for(const <strong class="bold">T</strong>&amp; wsc : whitespace) {
        <strong class="bold">if(c == wsc) return true</strong>;
    }    
    return false;
}</pre></li>
			</ul>
			<p>This templated <code>isws()</code> function should work with any character type.</p>
			<ul>
				<li>The <code>delws()</code> function uses <code>std::unique()</code> to erase consecutive whitespace<a id="_idIndexMarker1124"/> in a <code>string</code>:<pre>string delws(<strong class="bold">const string&amp; s</strong>) {
    <strong class="bold">string outstr{s}</strong>;
    auto its = unique(outstr.begin(), outstr.end(),
        [](const auto &amp;a, const auto &amp;b) {
            <strong class="bold">return isws(a) &amp;&amp; isws(b)</strong>;
        });
    <strong class="bold">outstr.erase(its, outstr.end());</strong>
    <strong class="bold">outstr.shrink_to_fit();</strong>
    return outstr;
}</pre></li>
			</ul>
			<p><code>delws()</code> makes a copy of the input string, removes consecutive whitespace, and returns the new string.</p>
			<ul>
				<li>We call it with a <code>string</code> from <code>main()</code>:<pre>int main() {
    const string s{ "big     bad    \t   wolf" };
    const string s2{ bw::delws(s) };
    cout &lt;&lt; format("[{}]\n", s);
    cout &lt;&lt; format("[{}]\n", s2);
    return 0;
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">[big     bad           wolf]</strong>
<strong class="bold">[big bad wolf]</strong></pre>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor364"/>How it works…</h2>
			<p>This function uses the <code>std::unique()</code> algorithm with a comparison lambda to find consecutive whitespace in a <code>string</code> object.</p>
			<p>The comparison lambda calls our own <code>isws()</code> function to determine if we have found consecutive whitespace:</p>
			<pre>auto its = unique(outstr.begin(), outstr.end(),
    [](const auto &amp;a, const auto &amp;b) {
        <strong class="bold">return isws(a) &amp;&amp; isws(b)</strong>;
    });</pre>
			<p>We could use the <code>isspace()</code> function from the standard library, but it's a standard C function that depends on a narrowing type conversion from <code>int</code> to <code>char</code>. This may issue warnings <a id="_idIndexMarker1125"/>on some modern C++ compilers and is not guaranteed to work without an explicit cast. Our <code>isws()</code> function uses a templated type and should work on any system, and with any specialization of <code>std::string</code>.</p>
			<h1 id="_idParaDest-366"><a id="_idTextAnchor365"/>Convert numbers to words</h1>
			<p>Over the course<a id="_idIndexMarker1126"/> of my career, I've used a lot of programming<a id="_idIndexMarker1127"/> languages. When learning a new language, I like to have a project to work on that exposes me to the nuances of the language. The <code>numwords</code> class is one of my favorite exercises for this purpose. I have written it in dozens of languages over the years, including several times in C and C++.</p>
			<p><code>numwords</code> is a class that spells out a number in words. It can be useful for banking and accounting applications. It looks like this in use:</p>
			<pre>int main() {
    bw::numword nw{};
    uint64_t n;
    nw = 3; bw::print("n is {}, {}\n", nw.getnum(), nw);
    nw = 47; bw::print("n is {}, {}\n", nw.getnum(), nw);
    n = 100073; bw::print("n is {}, {}\n", n, 
      bw::numword{n});
    n = 1000000001; bw::print("n is {}, {}\n", n, 
      bw::numword{n});
    n = 123000000000; bw::print("n is {}, {}\n", n, 
      bw::numword{n});
    n = 1474142398007; bw::print("n is {}, {}\n", n, 
      nw.words(n));
    n = 999999999999999999; bw::print("n is {}, {}\n", n, 
      nw.words(n));
    n = 1000000000000000000; bw::print("n is {}, {}\n", n, 
        nw.words(n));
}</pre>
			<p>Output:</p>
			<pre>n is 3, three
n is 47, forty-seven
n is 100073, one hundred thousand seventy-three
n is 1000000001, one billion one
n is 123000000000, one hundred twenty-three billion
n is 1474142398007, one trillion four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand seven
n is 999999999999999999, nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine
n is 1000000000000000000, error</pre>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor366"/>How to do it…</h2>
			<p>This recipe originated as an exercise in creating production-ready code. For that reason, it's in three different files:</p>
			<ul>
				<li><code>numword.h</code> is the header/interface file for the <code>numwords</code> class.</li>
				<li><code>numword.cpp</code> is the implementation file for the <code>numwords</code> class.</li>
				<li><code>numword-test.cpp</code> is the application file for testing the <code>numword</code> class.</li>
			</ul>
			<p>The class itself<a id="_idIndexMarker1128"/> is about 180 lines of code so we'll just cover the<a id="_idIndexMarker1129"/> highlights here. You can find the full source code at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap11/numword</a>.</p>
			<ul>
				<li>In the <code>numword.h</code> file, we put the class in the <code>bw</code> namespace and start with some <code>using</code> statements:<pre>namespace bw {
    using <strong class="bold">std::string</strong>;
    using <strong class="bold">std::string_view</strong>;
    <strong class="bold">using numnum = uint64_t;</strong> 
    <strong class="bold">using bufstr = std::unique_ptr&lt;string&gt;;</strong></pre></li>
			</ul>
			<p>We use <code>string</code> and <code>string_view</code> objects throughout the code.</p>
			<p><code>uint64_t</code> is our primary integer type because it will hold very large numbers. Because the class is called <code>numword</code>, I like <code>numnum</code> for the integer type.</p>
			<p><code>_bufstr</code> is the main output buffer. It's a <code>string</code> wrapped in a <code>unique_ptr</code>, which handles the memory management for automatic RAII compliance.</p>
			<ul>
				<li>We also have a few constants for various purposes:<pre>constexpr numnum maxnum = 999'999'999'999'999'999;
constexpr int zero_i{ 0 };
constexpr int five_i{ 5 };
constexpr numnum zero{ 0 };
constexpr numnum ten{ 10 };
constexpr numnum twenty{ 20 };
constexpr numnum hundred{ 100 };
constexpr numnum thousand{ 1000 };</pre></li>
			</ul>
			<p>The <code>maxnum</code> constant translates to "nine hundred ninety-nine quadrillion nine hundred ninety-nine<a id="_idIndexMarker1130"/> trillion nine hundred ninety-nine <a id="_idIndexMarker1131"/>billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine," which should be sufficient for most purposes.</p>
			<p>The rest of the <code>numnum</code> constants are used to avoid literals in the code.</p>
			<ul>
				<li>The main data structures are <code>constexpr</code> arrays of <code>string_view</code> objects, representing the words used in the output. The <code>string_view</code> class is perfect for these constants, as it provides encapsulation with minimum overhead:<pre>constexpr string_view errnum{ "error" };
constexpr string_view _singles[] {
    "zero", "one", "two", "three", "four", "five", 
    "six", "seven", "eight", "nine"
};
constexpr string_view _teens[] {
    "ten", "eleven", "twelve", "thirteen", "fourteen", 
    "fifteen", "sixteen", "seventeen", "eighteen", 
    "nineteen"
};
constexpr string_view _tens[] {
    errnum, errnum, "twenty", "thirty", "forty", 
    "fifty", "sixty", "seventy", "eighty", "ninety",
};
constexpr string_view _hundred_string = "hundred";
constexpr string_view _powers[] {
    errnum, "thousand", "million", "billion", 
    "trillion", "quadrillion"
};</pre></li>
			</ul>
			<p>The words <a id="_idIndexMarker1132"/>are <a id="_idIndexMarker1133"/>grouped into sections, useful in translating numbers to words. Many languages use a similar breakdown so this structure should translate easily to those languages.</p>
			<ul>
				<li>The <code>numword</code> class has a few private members:<pre>class numword {
    bufstr _buf{ std::make_unique&lt;string&gt;(string{}) };
    numnum _num{};
    bool _hyphen_flag{ false };</pre><ul><li><code>_buf</code> is the output string buffer. Its memory is managed by a <code>unique_ptr</code>.</li><li><code>_num</code> holds the current numeric value.</li><li><code>_hyphen_flag</code> is used during the translation process to insert a hyphen between words, rather than a space character.</li></ul></li>
				<li>These private methods are used to manipulate the output buffer.<pre>void clearbuf();
size_t bufsize();
void appendbuf(const string&amp; s);
void appendbuf(const string_view&amp; s);
void appendbuf(const char c);
void appendspace();</pre></li>
			</ul>
			<p>There is also a <code>pow_i()</code> private method used to calculate <em class="italic">x</em>y with <code>numnum</code> types:</p>
			<pre>numnum pow_i(const numnum n, const numnum p);</pre>
			<p><code>pow_i()</code> is used<a id="_idIndexMarker1134"/> to discriminate parts of the numeric value<a id="_idIndexMarker1135"/> for word output.</p>
			<ul>
				<li>The public interface includes constructors and various ways to call the <code>words()</code> method, which does the work of translating a <code>numnum</code> to a <code>string</code> of words:<pre><strong class="bold">numword</strong>(const numnum&amp; num = 0) : _num(num) {}
<strong class="bold">numword</strong>(const numword&amp; nw) : _num(nw.getnum()) {}
const char * <strong class="bold">version()</strong> const { return _version; }
void <strong class="bold">setnum</strong>(const numnum&amp; num) { _num = num; }
numnum <strong class="bold">getnum</strong>() const { return _num; }
numnum <strong class="bold">operator=</strong> (const numnum&amp; num);
const string&amp; <strong class="bold">words</strong>();
const string&amp; <strong class="bold">words</strong>(const numnum&amp; num);
const string&amp; <strong class="bold">operator()</strong> (const numnum&amp; num) {
    <strong class="bold">return words(num)</strong>; };</pre></li>
				<li>In the implementation <a id="_idIndexMarker1136"/>file, <code>numword.cpp</code>, the bulk of the work is handled in the <code>words()</code> member <a id="_idIndexMarker1137"/>function:<pre>const string&amp; numword::words( const numnum&amp; num ) {
    numnum n{ num };
    clearbuf();
    if(n &gt; maxnum) {
        appendbuf(errnum);
        return *_buf;
    }
    if (n == 0) {
        appendbuf(_singles[n]);
        return *_buf;
    }
    // powers of 1000
    if (n &gt;= thousand) {
        for(int i{ five_i }; i &gt; zero_i; --i) {
            numnum power{ pow_i(thousand, i) };
            numnum _n{ ( n - ( n % power ) ) / power };
            if (_n) {
                int index = i;
                <strong class="bold">numword _nw{ _n };</strong>
                <strong class="bold">appendbuf(_nw.words());</strong>
                <strong class="bold">appendbuf(_powers[index]);</strong>
                n -= _n * power;
            }
        }
    }
    // hundreds
    if (n &gt;= hundred &amp;&amp; n &lt; thousand) {
        numnum _n{ ( n - ( n % hundred ) ) / hundred };
        numword _nw{ _n };
        <strong class="bold">appendbuf(_nw.words());</strong>
        <strong class="bold">appendbuf(_hundred_string);</strong>
        n -= _n * hundred;
    }
    // tens
    if (n &gt;= twenty &amp;&amp; n &lt; hundred) {
        numnum _n{ ( n - ( n % ten ) ) / ten };
        <strong class="bold">appendbuf(_tens[_n]);</strong>
        n -= _n * ten;
        <strong class="bold">_hyphen_flag = true;</strong>
    }
    // teens
    if (n &gt;= ten &amp;&amp; n &lt; twenty) {
        <strong class="bold">appendbuf(_teens[n - ten]);</strong>
        n = zero;
    }
    // singles
    if (n &gt; zero &amp;&amp; n &lt; ten) {
        <strong class="bold">appendbuf(_singles[n]);</strong>
    }
    return *_buf;
}</pre></li>
			</ul>
			<p>Each part of the function peels off part of the number with a <em class="italic">modulus of a power of ten</em>, recursively in the case of the thousands, and appends strings from the <code>string_view</code> constant arrays.</p>
			<ul>
				<li>There are <a id="_idIndexMarker1138"/>three <a id="_idIndexMarker1139"/>overloads of <code>appendbuf()</code>. One appends a <code>string</code>:<pre>void numword::appendbuf(const string&amp; s) {
    appendspace();
    _buf-&gt;append(s);
}</pre></li>
			</ul>
			<p>Another appends a <code>string_view</code>:</p>
			<pre>void numword::appendbuf(const string_view&amp; s) {
    appendspace();
    _buf-&gt;append(s.data());
}</pre>
			<p>And the third appends a single character:</p>
			<pre>void numword::appendbuf(const char c) {
    _buf-&gt;append(1, c);
}</pre>
			<p>The <code>appendspace()</code> method appends a space character or a hyphen, depending on the context:</p>
			<pre>void numword::appendspace() {
    if(bufsize()) {
        appendbuf( _hyphen_flag ? _hyphen : _space);
        _hyphen_flag = false;
    }
}</pre>
			<ul>
				<li>The <code>numword-test.cpp</code> file is the testing environment for <code>bw::numword</code>. It<a id="_idIndexMarker1140"/> includes<a id="_idIndexMarker1141"/> a <code>formatter</code> specialization:<pre>template&lt;&gt;
struct std::formatter&lt;<strong class="bold">bw::numword</strong>&gt;: std::formatter&lt;unsigned&gt; {
    template&lt;typename FormatContext&gt;
    auto format(const <strong class="bold">bw::numword&amp; nw</strong>, 
      FormatContext&amp; ctx) {
        bw::numword _nw{nw};
        return format_to(ctx.out(), "{}", 
          <strong class="bold">_nw.words()</strong>);
    }
};</pre></li>
			</ul>
			<p>This allows us to pass a <code>bw::numword</code> object directly to <code>format()</code>.</p>
			<ul>
				<li>There's also a <code>print()</code> function that sends <code>formatter</code> output directly to <code>stdout</code>, bypassing <code>cout</code> and the <code>iostream</code> library entirely:<pre>namespace bw {
    template&lt;typename... Args&gt; constexpr void print(
            const std::string_view str_fmt, Args&amp;&amp;... 
              args) {
        fputs(std::vformat(str_fmt, 
            std::make_format_args(args...)).c_str(), 
            stdout);
    }
};</pre></li>
			</ul>
			<p>This allows us to use <code>print("{}\n", nw)</code> instead of piping <code>format()</code> through <code>cout</code>. A function like this will be included in the C++23 standard. It's simple enough to include it like this for now.</p>
			<ul>
				<li>In <code>main()</code>, we <a id="_idIndexMarker1142"/>declare a <code>bw::numword</code> object <a id="_idIndexMarker1143"/>and a <code>uint64_t</code> for use in testing:<pre>int main() {
    bw::numword nw{};
    uint64_t n{};
    bw::print("n is {}, {}\n", nw.getnum(), nw);
    ...</pre></li>
			</ul>
			<p>The <code>numword</code> object is initialized to zero, giving us this output from our <code>print()</code> statement:</p>
			<pre><strong class="bold">n is 0, zero</strong></pre>
			<ul>
				<li>We test a variety of ways to call <code>numword</code>:<pre>nw = 3; bw::print("n is {}, {}\n", nw.getnum(), nw);
nw = 47; bw::print("n is {}, {}\n", nw.getnum(), nw);
...
n = 100073; bw::print("n is {}, {}\n", n, bw::numword{n});
n = 1000000001; bw::print("n is {}, {}\n", n, bw::numword{n});
...
n = 474142398123; bw::print("n is {}, {}\n", n, nw(n));
n = 1474142398007; bw::print("n is {}, {}\n", n, nw(n));
...
n = 999999999999999999; bw::print("n is {}, {}\n", n, nw(n));
n = 1000000000000000000; bw::print("n is {}, {}\n", n, nw(n));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">n is 3, three</strong>
<strong class="bold">n is 47, forty-seven</strong>
<strong class="bold">...</strong>
<strong class="bold">n is 100073, one hundred thousand seventy-three</strong>
<strong class="bold">n is 1000000001, one billion one</strong>
<strong class="bold">...</strong>
<strong class="bold">n is 474142398123, four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand one hundred twenty-three</strong>
<strong class="bold">n is 1474142398007, one trillion four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand seven</strong>
<strong class="bold">...</strong>
<strong class="bold">n is 999999999999999999, nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine</strong>
<strong class="bold">n is 1000000000000000000, error</strong></pre>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor367"/>How it works…</h2>
			<p>This class is significantly driven by the data structures. By organizing <code>string_view</code> objects into arrays, we <a id="_idIndexMarker1144"/>can easily translate scalar values into <a id="_idIndexMarker1145"/>corresponding words:</p>
			<pre>appendbuf(_tens[_n]);  // e.g., _tens[5] = "fifty"</pre>
			<p>The rest of it is mostly the math:</p>
			<pre>numnum power{ <strong class="bold">pow_i(thousand, i)</strong> };
numnum _n{ <strong class="bold">( n - ( n % power ) ) / power</strong> };
if (_n) {
    int index = i;
    numword _nw{ _n };
    <strong class="bold">appendbuf(_nw.words());</strong>
    <strong class="bold">appendbuf(_powers[index]);</strong>
    <strong class="bold">n -= _n * power;</strong>
}</pre>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor368"/>There's more…</h2>
			<p>I also have a utility that uses the <code>numwords</code> class to tell time in words. Its output looks like this:</p>
			<pre>$ ./saytime
three past five</pre>
			<p>In test mode, it gives this output:</p>
			<pre>$ ./saytime test
00:00 midnight
00:01 one past midnight
11:00 eleven o'clock
12:00 noon
13:00 one o'clock
12:29 twenty-nine past noon
12:30 half past noon
12:31 twenty-nine til one
12:15 quarter past noon
12:30 half past noon
12:45 quarter til one
11:59 one til noon
23:15 quarter past eleven
23:59 one til midnight
12:59 one til one
13:59 one til two
01:60 OOR
24:00 OOR</pre>
			<p>I leave<a id="_idIndexMarker1146"/> its<a id="_idIndexMarker1147"/> implementation as an exercise for the reader.</p>
		</div>
	</body></html>