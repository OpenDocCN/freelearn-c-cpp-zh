["```cpp\n#include <sstream>\n\n    std::istringstream iss(\"100\");\n    int i;\n    iss >> i;\n    // And now, 'iss' variable will get in the way all the time, \n    // till end of the scope\n    // It is better not to think, how many unnecessary operations, \n    // virtual function calls and memory allocations occurred \n    // during those operations\n```", "```cpp\n#include <cstdlib>\n    char * end;\n    int i = std::strtol (\"100\", &end, 10);\n    // Did it converted all the value to int, or stopped somewhere \n    // in the middle?\n    // And now we have 'end' variable will getting in the way\n    // By the way, we want an integer, but strtol returns long \n    // int... Did the converted value fit in int?\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n\nint i = boost::lexical_cast<int>(\"100\");\n```", "```cpp\n    char chars[] = {'1', '0', '0' };\n    int i = boost::lexical_cast<int>(chars, 3);\n    assert(i == 100);\n```", "```cpp\n    try {\n   // on x86 short usually may not store values greater than 32767\n        short s = boost::lexical_cast<short>(\"1000000\");\n        assert(false); // Must not reach this\n    } catch (const boost::bad_lexical_cast& /*e*/) {}\n```", "```cpp\n    try {\n        int i = boost::lexical_cast<int>(\"This is not a number!\");\n        assert(false); // Must not reach this\n        (void)i; // Suppressing warning about unused variable\n    } catch (const boost::bad_lexical_cast& /*e*/) {}\n```", "```cpp\n#include <locale>\n\n    std::locale::global(std::locale(\"ru_RU.UTF8\"));\n    // In Russia coma sign is used as a decimal separator\n    float f = boost::lexical_cast<float>(\"1,0\");\n    assert(f < 1.01 && f > 0.99);\n```", "```cpp\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <boost/lexical_cast.hpp>\n\ntemplate <class ContainerT>\nstd::vector<long int> container_to_longs(const ContainerT& container) {\n    typedef typename ContainerT::value_type value_type;\n    std::vector<long int> ret;\n    typedef long int (*func_t)(const value_type&);\n    func_t f = &boost::lexical_cast<long int, value_type>;\n    std::transform(container.begin(), container.end(), std::back_inserter(ret), f);\n    return ret;\n}\n\n    // Somewhere in source file...\n    std::set<std::string> str_set;\n    str_set.insert(\"1\");\n    assert(container_to_longs(str_set).front() == 1);\n    std::deque<const char*> char_deque;\n    char_deque.push_front(\"1\");\n    char_deque.push_back(\"2\");\n    assert(container_to_longs(char_deque).front() == 1);\n    assert(container_to_longs(char_deque).back() == 2);\n\n    // Obfuscating people with curly braces is fun!\n    typedef boost::array<unsigned char, 2> element_t;\n    boost::array<element_t, 2> arrays = {{ {{'1', '0'}}, {{'2', '0'}} }};\n    assert(container_to_longs(arrays).front() == 10);\n    assert(container_to_longs(arrays).back() == 20);\n```", "```cpp\n    #include <boost/lexical_cast.hpp>\n\n        std::string s = boost::lexical_cast<std::string>(100);\n        assert(s == \"100\");\n    ```", "```cpp\n    #include <sstream>\n\n        // C++ way of converting to strings\n        std::stringstream ss;\n        ss << 100;\n        std::string s;\n        ss >> s;\n        // Variable 'ss' will dangle all the way, till the end \n        // of scope\n        // Multiple virtual methods were called during \n        // conversion\n        assert(s == \"100\");\n    ```", "```cpp\n    #include <cstdlib>\n\n        // C way of converting to strings\n        char buffer[100];\n        std::sprintf(buffer, \"%i\", 100);\n        // You will need an unsigned long long int type to \n        // count how many times errors were made in 'printf' \n        // like functions all around the world. 'printf' \n        // functions are a constant security threat!\n        // But wait, we still need to construct a std::string\n        std::string s(buffer);\n        // And now we have an buffer variable that won't be \n        // used\n        assert(s == \"100\");\n    ```", "```cpp\nvoid some_function(unsigned short param);\n\nint foo();\n    // Somewhere in code\n    // Some compilers may warn that int is being converted to \n    // unsigned short and that there is a possibility of losing \n    // data\n    some_function(foo());\n```", "```cpp\n    // Warning suppressed. Looks like a correct code\n    some_function(\n        static_cast<unsigned short>(foo())\n    );\n```", "```cpp\n// Returns -1 if error occurred\nint foo() {\n    if (some_extremely_rare_condition()) {\n        return -1;\n    } else if (another_extremely_rare_condition()) {\n        return 1000000;\n    }\n    return 65535;\n}\n```", "```cpp\n    #include <boost/numeric/conversion/cast.hpp>\n\n    void correct_implementation() {\n        // 100% correct\n        some_function(\n            boost::numeric_cast<unsigned short>(foo())\n        );\n    }\n\n    void test_function() {\n        for (unsigned int i = 0; i < 100; ++i) {\n            try {\n                correct_implementation();\n            } catch (const boost::numeric::bad_numeric_cast& e) {\n                std::cout << '#' << i << ' ' << e.what() << std::endl;\n            }\n        }\n    }\n    ```", "```cpp\n    #47 bad numeric conversion: negative overflow \n    #58 bad numeric conversion: positive overflow \n    ```", "```cpp\n    void test_function1() {\n       for (unsigned int i = 0; i < 100; ++i) {\n           try {\n               correct_implementation();\n           } catch (const boost::numeric::positive_overflow& e) {\n               // Do something specific for positive overflow\n               std::cout << \"POS OVERFLOW in #\" << i << ' ' << e.what() << std::endl;\n           } catch (const boost::numeric::negative_overflow& e) {\n               // Do something specific for negative overwlow\n               std::cout <<\"NEG OVERFLOW in #\" << i << ' ' << e.what() << std::endl;\n           }\n       }\n    }\n    ```", "```cpp\n    NEG OVERFLOW in #47 bad numeric conversion: negative overflow \n    POS OVERFLOW in #59 bad numeric conversion: positive overflow\n    ```", "```cpp\ntemplate <class SourceT, class TargetT>\nstruct mythrow_overflow_handler {\n    void operator() (boost::numeric::range_check_result r) {\n        if (r != boost::numeric::cInRange) {\n            throw std::logic_error(\"Not in range!\");\n        }\n    }\n};\n\ntemplate <class TargetT, class SourceT>\nTargetT my_numeric_cast(const SourceT& in) {\n    using namespace boost;\n    typedef numeric::conversion_traits<TargetT, SourceT>   conv_traits;\n    typedef numeric::numeric_cast_traits<TargetT, SourceT> cast_traits;\n    typedef boost::numeric::converter\n        <\n            TargetT,\n            SourceT,\n            conv_traits,\n            mythrow_overflow_handler<SourceT, TargetT> // !!!\n        > converter;\n    return converter::convert(in);\n}\n\n    // Somewhere in code\n    try {\n        my_numeric_cast<short>(100000);\n    } catch (const std::logic_error& e) {\n        std::cout << \"It works! \" << e.what() << std::endl;\n    }\n```", "```cpp\nIt works! Not in range!\n```", "```cpp\n    #include <iosfwd>\n    #include <stdexcept>\n\n    // Somewhere in header file\n    // Negative number, that does not store minus sign\n    class negative_number {\n        unsigned short number_;\n    public:\n        explicit negative_number(unsigned short number)\n            : number_(number)\n        {}\n        // operators and functions defined lower\n        // ...\n        unsigned short value_without_sign() const {\n            return number_;\n        }\n    };\n\n    std::ostream& operator<<(std::ostream& os,\n       const negative_number& num)\n    {\n       os << '-' << num.value_without_sign();\n       return os;\n    }\n\n    std::istream& operator>>(std::istream& is, negative_number& num) {\n        char ch;\n        is >> ch;\n        if (ch != '-') {\n            throw std::logic_error(\"negative_number class designed \"\n                          \"to store ONLY negative values\");\n        }\n        unsigned short s;\n        is >> s;\n        num = negative_number(s);\n        return os;\n    }\n    ```", "```cpp\n    #include <boost/lexical_cast.hpp>\n    #include <assert.h>\n    int main() {\n        negative_number n\n          = boost::lexical_cast<negative_number>(\"-100\");\n        assert(n.value_without_sign() == 100);\n        int i = boost::lexical_cast<int>(n);\n        assert(i == -100);\n\n        typedef boost::array<char, 10> arr_t;\n        arr_t arr = boost::lexical_cast<arr_t>(n);\n        assert(arr[0] == '-');\n        assert(arr[1] == '1');\n        assert(arr[2] == '0');\n        assert(arr[3] == '0');\n        assert(arr[4] == '\\0');\n    }\n    ```", "```cpp\ntemplate <class CharT>\nstd::basic_ostream<CharT>& operator<<(std::basic_ostream<CharT>& os,\n   const negative_number& num)\n{\n   os << static_cast<CharT>('-') << num.value_without_sign();\n   return os;\n}\n\ntemplate <class CharT>\nstd::basic_istream<CharT>& operator>>(std::basic_istream<CharT>& is, negative_number& num) {\n    CharT ch;\n    is >> ch;\n    if (ch != static_cast<CharT>('-')) {\n        throw std::logic_error(\"negative_number class designed to \"\n                      \"store ONLY negative values\");\n    }\n    unsigned short s;\n    is >> s;\n    num = negative_number(s);\n    return is;\n}\n\nint main() {\n    negative_number n = boost::lexical_cast<negative_number>(L\"-1\");\n    assert(n.value_without_sign() == 1);\n    typedef boost::array<wchar_t, 10> warr_t;\n    warr_t arr = boost::lexical_cast<warr_t>(n);\n    assert(arr[0] == L'-');\n    assert(arr[1] == L'1');\n    assert(arr[4] == L'\\0');\n}\n```", "```cpp\nstruct object {\n    virtual ~object() {}\n};\n\nstruct banana: public object {\n    void eat() const {}\n    virtual ~banana(){}\n};\n\nstruct pidgin: public object {\n    void fly() const {}\n    virtual ~pidgin(){}\n};\n\nobject* try_produce_banana();\n```", "```cpp\nvoid try_eat_banana_impl1() {\n    const object* obj = try_produce_banana();\n    if (!obj) {\n        throw std::bad_cast();\n    }\n    dynamic_cast<const banana&>(*obj).eat();\n}\n```", "```cpp\n#include <boost/cast.hpp>\nvoid try_eat_banana_impl2() {\n    const object* obj = try_produce_banana();\n    boost::polymorphic_cast<const banana*>(obj)->eat();\n}\n```", "```cpp\nYYYY-MM-DD\n```", "```cpp\n2013-03-01\n2012-12-31  // (woo-hoo, it almost a new year!)\n```", "```cpp\n   date-fullyear   = 4DIGIT\n   date-month      = 2DIGIT  ; 01-12\n   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                             ; month/year\n   full-date       = date-fullyear \"-\" date-month \"-\" date-mday\n```", "```cpp\n    #include <boost/spirit/include/qi.hpp>\n    #include <boost/spirit/include/phoenix_core.hpp>\n    #include <boost/spirit/include/phoenix_operator.hpp>\n    #include <assert.h>\n    ```", "```cpp\n    struct date {\n        unsigned short year;\n        unsigned short month;\n        unsigned short day;\n    };\n    ```", "```cpp\n    // See recipe \"Using a reference to string type\" in Chapter 7, \n    // Manipulating Strings for a better type\n    // than std::string for parameter 's'\n    date parse_date_time1(const std::string& s) {\n        using boost::spirit::qi::_1;\n        using boost::spirit::qi::ushort_;\n        using boost::spirit::qi::char_;\n        using boost::phoenix::ref;\n\n        date res;\n        const char* first = s.data();\n        const char* const end = first + s.size();\n        bool success = boost::spirit::qi::parse(first, end,\n          ushort_[ ref(res.year) = 1 ] >> char('-')\n          >> ushort_[ ref(res.month) = 1 ] >> char('-')\n          >> ushort_[ ref(res.day) = _1 ]\n        );\n\n        if (!success || first != end) {\n            throw std::logic_error(\"Parsing failed\");\n        }\n        return res;\n    }\n    ```", "```cpp\n    int main() {\n        date d = parse_date_time1(\"2012-12-31\");\n        assert(d.year == 2012);\n        assert(d.month == 12);\n        assert(d.day == 31);\n    }\n    ```", "```cpp\n   bool success = boost::spirit::qi::parse(first, end,\n        ushort_ >> char_('-') >> ushort_ >> char_('-') >> ushort_\n    );\n```", "```cpp\n    date-fullyear \"-\" date-month \"-\" date-md\n```", "```cpp\n    ushort_[ [&res](unsigned short s) {res.year = s;} ]\n```", "```cpp\n    ushort_[ ref(res.month) = _1 ]\n```", "```cpp\ndate parse_date_time2(const std::string& s) {\n    using boost::spirit::qi::_1;\n    using boost::spirit::qi::uint_parser;\n    using boost::spirit::qi::char_;\n    using boost::phoenix::ref;\n\n    // Use unsigned short as output type, require Radix 10, and from 2\n    // to 2 digits\n    uint_parser<unsigned short, 10, 2, 2> u2_;\n\n    // Use unsigned short as output type, require Radix 10, and from 4\n    // to 4 digits\n    uint_parser<unsigned short, 10, 4, 4> u4_;\n\n    date res;\n    const char* first = s.data();\n    const char* const end = first + s.size();\n    bool success = boost::spirit::qi::parse(first, end,\n        u4_ [ ref(res.year) = _1 ] >> char_('-')\n        >> u2_ [ ref(res.month) = _1 ] >> char_('-')\n        >> u2_ [ ref(res.day) = _1 ]\n    );\n\n    if (!success || first != end) {\n        throw std::logic_error(\"Parsing failed\");\n    }\n    return res;\n}\n```", "```cpp\n2012-10-20T10:00:00Z      // date time with zero zone offset\n2012-10-20T10:00:00       // date time with unspecified zone offset\n2012-10-20T10:00:00+09:15 // date time with zone offset\n2012-10-20-09:15          // date time with zone offset\n10:00:09+09:15            // time with zone offset\n```", "```cpp\n    struct datetime {\n        enum zone_offsets_t {\n            OFFSET_NOT_SET,\n            OFFSET_Z,\n            OFFSET_UTC_PLUS,\n            OFFSET_UTC_MINUS\n        };\n\n    private:\n        unsigned short year_;\n        unsigned short month_;\n        unsigned short day_;\n        unsigned short hours_;\n        unsigned short minutes_;\n        unsigned short seconds_;\n        zone_offsets_t zone_offset_type_;\n        unsigned int zone_offset_in_min_;\n\n        static void dt_assert(bool v, const char* msg) {\n            if (!v) {\n                throw std::logic_error(\"Assertion failed: \"\n                    + std::string(msg));\n            }\n        }\n\n    public:\n        datetime()\n           : year_(0), month_(0), day_(0)\n           , hours_(0), minutes_(0), seconds_(0)\n           , zone_offset_type_(OFFSET_NOT_SET), zone_offset_in_min_(0)\n        {}\n        // Getters: year(), month(), day(), hours(), minutes(),\n        // seconds(), zone_offset_type(), zone_offset_in_min()\n        // ...\n\n        // Setters\n        // void set_*(unsigned short val) { /*some assert and setting the *_ to val */ }\n        // ...\n\n    };\n    ```", "```cpp\n    void set_zone_offset(datetime& dt, char sign, unsigned short hours, unsigned short minutes) {\n        dt.set_zone_offset_type(sign == '+' ?\n           datetime::OFFSET_UTC_PLUS : datetime::OFFSET_UTC_MINUS);\n        dt.set_zone_offset_in_min(hours * 60 + minutes);\n    }\n    ```", "```cpp\n    //Default includes for Boost.Spirit\n    #include <boost/spirit/include/qi.hpp>\n    #include <boost/spirit/include/phoenix_core.hpp>\n    #include <boost/spirit/include/phoenix_operator.hpp>\n\n    // We'll use bind() function from Boost.Spirit,\n    // because it iterates better with parsers\n    #include <boost/spirit/include/phoenix_bind.hpp>\n\n    datetime parse_datetime(const std::string& s) {\n        using boost::spirit::qi::_1;\n        using boost::spirit::qi::_2;\n        using boost::spirit::qi::_3;\n        using boost::spirit::qi::uint_parser;\n        using boost::spirit::qi::char_;\n        using boost::phoenix::bind;\n        using boost::phoenix::ref;\n\n        datetime ret;\n\n        // Use unsigned short as output type, require Radix 10, and\n        // from 2 to 2 digits\n        uint_parser<unsigned short, 10, 2, 2> u2_;\n\n        // Use unsigned short as output type, require Radix 10, and\n        // from 4 to 4 digits\n        uint_parser<unsigned short, 10, 4, 4> u4_;\n\n        boost::spirit::qi::rule<const char*, void()> timezone_parser\n            = -(   // unary minus means optional rule\n                   // Zero offset\n                   char_('Z')[ bind(&datetime::set_zone_offset_type, &ret, datetime::OFFSET_Z) ]\n                   |  // OR\n                   // Specific zone offset\n                   ((char_('+')|char_('-')) >> u2_ >> ':' >> u2_) [ bind(&set_zone_offset, ref(ret), _1, _2, _3) ]\n            );\n        // ...\n        return ret;\n    }\n    ```", "```cpp\n      boost::spirit::qi::rule<const char*, void()> date_parser =\n        u4_ [ bind(&datetime::set_year, &ret, _1) ]  >> char_('-')\n        >> u2_ [ bind(&datetime::set_month, &ret, _1) ] >> char_('-')\n        >> u2_ [ bind(&datetime::set_day, &ret, _1) ];\n\n      boost::spirit::qi::rule<const char*, void()> time_parser =\n        u2_ [ bind(&datetime::set_hours, &ret, _1) ] >> char_(':')\n        >> u2_ [ bind(&datetime::set_minutes, &ret, _1) ] >> char_(':')\n        >> u2_ [ bind(&datetime::set_seconds, &ret, _1) ];\n\n        const char* first = s.data();\n        const char* const end = first + s.size();\n        bool success = boost::spirit::qi::parse(first, end,\n            ((date_parser >> char_('T') >> time_parser) | date_parser | time_parser)\n             >> timezone_parser\n        );\n\n        if (!success || first != end) {\n            throw std::logic_error(\"Parsing of '\" + s + \"' failed\");\n        }\n        return ret;\n    } // end of parse_datetime() function\n    ```", "```cpp\n// Somewhere in header file\nclass example_1 {\n    boost::spirit::qi::rule<const char*, void()> some_rule_;\npublic:\n    example_1();\n};\n\n// In source file\nexample_1::example_1() {\n    some_rule_ = /* ... */;\n}\n```"]