<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-206"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.2.1">Dynamic Analysis</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the intricate world of software development, ensuring the correctness, efficiency, and security of code is not just a goal but a necessity. </span><span class="koboSpan" id="kobo.3.2">This is particularly true in C++ programming, where the power and complexity of the language present both opportunities and challenges. </span><span class="koboSpan" id="kobo.3.3">One of the most effective approaches to maintaining high </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.4.1">code quality in C++ is </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">dynamic code analysis</span></strong><span class="koboSpan" id="kobo.6.1"> – a process that scrutinizes program behavior as it runs to detect a range of </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">potential issues.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Dynamic code analysis stands in contrast to static analysis, which examines source code without executing it. </span><span class="koboSpan" id="kobo.8.2">While static analysis is invaluable for catching syntax errors, code smells, and certain types of bugs early in the development cycle, dynamic analysis delves deeper. </span><span class="koboSpan" id="kobo.8.3">It uncovers issues that only manifest during the actual execution of the program, such as memory leaks, race conditions, and other runtime errors that can lead to crashes, erratic behavior, or </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">security vulnerabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">This chapter aims to explore the landscape of dynamic code analysis tools in C++, with a particular focus on some of the </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.11.1">most powerful and widely used tools in the industry: a </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.12.1">suite of compiler-based sanitizers, including </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">AddressSanitizer</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.15.1">ASan</span></strong><span class="koboSpan" id="kobo.16.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">ThreadSanitizer</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.19.1">TSan</span></strong><span class="koboSpan" id="kobo.20.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">UndefinedBehaviorSanitizer</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.23.1">UBSan</span></strong><span class="koboSpan" id="kobo.24.1">), as well as</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.25.1"> Valgrind, a versatile tool known for its thorough memory </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">debugging capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Compiler sanitizers, part of the LLVM project and GCC project, offer a range of options for dynamic analysis. </span><span class="koboSpan" id="kobo.27.2">ASan is remarkable for its ability to detect various memory-related errors, TSan excels in identifying race conditions in multi-threaded code, and UBSan helps in catching undefined behaviors that can lead to unpredictable program behavior. </span><span class="koboSpan" id="kobo.27.3">These tools are praised for their efficiency, precision, and ease of integration into existing development workflows. </span><span class="koboSpan" id="kobo.27.4">Most of them are supported by GCC and MSVC </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">On the other hand, Valgrind, an instrumentation framework for building dynamic analysis tools, shines with its comprehensive memory leak detection and the ability to analyze binary executables without requiring source code recompilation. </span><span class="koboSpan" id="kobo.29.2">It’s a go-to solution for complex scenarios where in-depth memory analysis is paramount, albeit at the cost of higher </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">performance overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Throughout this chapter, we will delve into each of these tools, understanding their strengths, weaknesses, and appropriate use cases. </span><span class="koboSpan" id="kobo.31.2">We’ll explore how they can be effectively integrated into your C++ development process, and how they complement each other to provide a robust framework for ensuring the quality and reliability of </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">C++ applications.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">By the end of this chapter, you will have a thorough understanding of dynamic code analysis in C++, equipped with the knowledge to choose and utilize the right tools for your specific development needs, ultimately leading to cleaner, more efficient, and reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">C++ code.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.35.1">Compiler-based dynamic code analysis</span></h1>
<p><span class="koboSpan" id="kobo.36.1">Compiler-based sanitizers contain</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.37.1"> two parts: compiler instrumentation and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">runtime diagnostics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Compiler instrumentation</span></strong><span class="koboSpan" id="kobo.40.1">: When you compile your C++ code with sanitizers enabled, the </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.41.1">compiler instruments the generated binary with additional checks. </span><span class="koboSpan" id="kobo.41.2">These checks are strategically inserted into the code to monitor for specific types of errors. </span><span class="koboSpan" id="kobo.41.3">For instance, ASan adds code to track memory allocations and accesses, enabling it to detect memory misuses such as buffer overflows and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">memory leaks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Runtime diagnostics</span></strong><span class="koboSpan" id="kobo.44.1">: As </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.45.1">the instrumented program runs, these checks actively monitor the program’s behavior. </span><span class="koboSpan" id="kobo.45.2">When a sanitizer detects an error (such as a memory access violation or a data race), it immediately reports this, often with detailed information about the location and nature of the error. </span><span class="koboSpan" id="kobo.45.3">This real-time feedback is invaluable for identifying and fixing elusive bugs that might be difficult to catch through </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">traditional testing.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.47.1">Despite all compiler teams constantly working on adding new sanitizers and improving the existing ones, there are still </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.48.1">some limitations to the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">compiler-based sanitizers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Clang and GCC</span></strong><span class="koboSpan" id="kobo.51.1">: Most </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.52.1">sanitizers, including ASan, TSan, and UBSan, are supported by both Clang and GCC. </span><span class="koboSpan" id="kobo.52.2">This</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.53.1"> wide support makes them accessible to a large portion of the C++ development community, regardless of the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">preferred compiler.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.55.1">Microsoft Visual C++ (MSVC)</span></strong><span class="koboSpan" id="kobo.56.1">: MSVC also supports some sanitizers, though the range and</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.57.1"> capabilities might differ from those in Clang and GCC. </span><span class="koboSpan" id="kobo.57.2">For example, MSVC has support for ASan, which is useful for Windows-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">C++ development.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Cross-platform utility</span></strong><span class="koboSpan" id="kobo.60.1">: The cross-compiler and cross-platform nature of these tools mean they can be used in a variety of development environments, from Linux and macOS to Windows, enhancing their utility in diverse </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">C++ projects.</span></span></li>
</ul>
<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.62.1">ASan</span></h2>
<p><span class="koboSpan" id="kobo.63.1">ASan is a</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.64.1"> runtime memory error detector, part of the LLVM compiler infrastructure, GCC, and MSVC. </span><span class="koboSpan" id="kobo.64.2">It serves as a specialized tool for developers to identify and resolve various kinds of memory-related errors, including, but not limited to, buffer overflows, dangling pointer accesses, and memory leaks. </span><span class="koboSpan" id="kobo.64.3">The tool achieves this by instrumenting the code during the compilation process, enabling it to monitor memory accesses and allocations </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">One of the key strengths of ASan is its ability to provide detailed error reports. </span><span class="koboSpan" id="kobo.66.2">When a memory error is detected, ASan outputs comprehensive information, including the type of error, the memory location involved, and the stack trace. </span><span class="koboSpan" id="kobo.66.3">This level of detail significantly aids in the debugging process, allowing developers to pinpoint the source of the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">issue quickly.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Integrating ASan into a C++ development workflow is straightforward. </span><span class="koboSpan" id="kobo.68.2">It requires minimal changes to the build process, typically involving the addition of a compiler flag (</span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">-fsanitize=address</span></strong><span class="koboSpan" id="kobo.70.1">) during compilation. </span><span class="koboSpan" id="kobo.70.2">For better results, it makes sense to use reasonable performance adda</span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">-O1</span></strong><span class="koboSpan" id="kobo.72.1"> or higher. </span><span class="koboSpan" id="kobo.72.2">To get nicer stack traces in error messages, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">-fno-omit-frame-pointer</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">This ease of integration, combined with its effectiveness in catching memory errors, makes ASan an indispensable tool for developers aiming to enhance the reliability and security of their </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">C++ applications.</span></span></p>
<h3><span class="koboSpan" id="kobo.76.1">Symbolizing reports in ASan</span></h3>
<p><span class="koboSpan" id="kobo.77.1">When using</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.78.1"> ASan to detect memory errors in C++ applications, it’s crucial to symbolize the error reports. </span><span class="koboSpan" id="kobo.78.2">Symbolization translates memory addresses and offsets in ASan’s output into human-readable function names, file names, and line numbers. </span><span class="koboSpan" id="kobo.78.3">This process is vital for effective debugging, as it allows developers to easily identify where in the source code the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">error occurred.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Without symbolization, the ASan report provides less meaningful raw memory addresses, making it challenging to trace back to the exact location in the source code where the error happened. </span><span class="koboSpan" id="kobo.80.2">Symbolized reports, on the other hand, offer clear and actionable insights, enabling developers to quickly understand and fix the underlying issues in </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">their code.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The configuration of ASan symbolization is typically automatic, requiring no additional steps. </span><span class="koboSpan" id="kobo.82.2">However, in some cases, you might need to explicitly set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">ASAN_SYMBOLIZER_PATH</span></strong><span class="koboSpan" id="kobo.84.1"> environment variable to point to the symbolizer tool. </span><span class="koboSpan" id="kobo.84.2">This is especially true on non-Linux Unix systems, where </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.85.1">additional tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">addr2line</span></strong><span class="koboSpan" id="kobo.87.1"> might be required for symbolization. </span><span class="koboSpan" id="kobo.87.2">If it does not work out of the box, please go over the following steps to ensure that symbolization is </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">configured correctly:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Compile with </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.90.1">debug information</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">:</span></span><ul><li><span class="koboSpan" id="kobo.92.1">Ensure that your program is compiled with debug information. </span><span class="koboSpan" id="kobo.92.2">This is typically done by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">-g</span></strong><span class="koboSpan" id="kobo.94.1"> flag to your compilation command. </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">For instance:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.96.1">
clang++ -fsanitize=address -g -o your_program your_file.cpp</span></pre></li><li><span class="koboSpan" id="kobo.97.1">Compiling with </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">-g</span></strong><span class="koboSpan" id="kobo.99.1"> includes debugging symbols in the binary, which are essential </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">for symbolization.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Use an </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.102.1">ASan symbolizer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">:</span></span><ul><li><span class="koboSpan" id="kobo.104.1">ASan typically autoconfigures its symbolizer if the required tools are available on your system. </span><span class="koboSpan" id="kobo.104.2">This means symbolization often works out of </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the box.</span></span></li><li><span class="koboSpan" id="kobo.106.1">On Unix-like systems, ASan uses the LLVM symbolizer by default. </span><span class="koboSpan" id="kobo.106.2">Ensure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">llvm-symbolizer</span></strong><span class="koboSpan" id="kobo.108.1"> tool is in your </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">system’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">PATH</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Check for additional </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.113.1">tools (optional)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">:</span></span><ul><li><span class="koboSpan" id="kobo.115.1">On some systems, especially non-Linux Unix systems, you might need additional tools </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">for symbolization.</span></span></li><li><span class="koboSpan" id="kobo.117.1">Tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">addr2line</span></strong><span class="koboSpan" id="kobo.119.1"> (part of GNU Binutils) can be used for symbolizing </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">stack traces.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.121.1">Environment variables (</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.122.1">if needed)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">:</span></span><ul><li><span class="koboSpan" id="kobo.124.1">In cases where automatic symbolization doesn’t work, you can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">ASAN_SYMBOLIZER_PATH</span></strong><span class="koboSpan" id="kobo.126.1"> environment variable to point to the symbolizer tool. </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">For example:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.128.1">
export ASAN_SYMBOLIZER_PATH=/path/to/llvm-symbolizer</span></pre></li><li><span class="koboSpan" id="kobo.129.1">This explicitly tells ASan which symbolizer </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">to use.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Running </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.132.1">your program</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">:</span></span><ul><li><span class="koboSpan" id="kobo.134.1">Run your </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.135.1">compiled program as usual. </span><span class="koboSpan" id="kobo.135.2">If a memory error is detected, ASan will output a symbolized </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">stack trace.</span></span></li><li><span class="koboSpan" id="kobo.137.1">The report will include function names, file names, and line numbers, making it easier to locate and address the error in </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">your code.</span></span></li></ul></li>
</ol>
<h3><span class="koboSpan" id="kobo.139.1">Out-of-bounds access</span></h3>
<p><span class="koboSpan" id="kobo.140.1">Let us try to </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.141.1">catch one of the most critical errors of C++ programming: </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">out-of-bounds access</span></strong><span class="koboSpan" id="kobo.143.1">. </span><span class="koboSpan" id="kobo.143.2">This issue spans various segments of memory management – the heap, the stack, and global variables, each presenting unique challenges </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">and risks.</span></span></p>
<h4><span class="koboSpan" id="kobo.145.1">Out-of-bounds access on the heap</span></h4>
<p><span class="koboSpan" id="kobo.146.1">We begin </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.147.1">by exploring out-of-bounds access on the heap, where dynamic memory allocation can lead to pointers exceeding the allocated memory boundaries. </span><span class="koboSpan" id="kobo.147.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
int main() {
    int *heapArray = new int[5];
    heapArray[5]   = 10; // Out-of-bounds write on the heap
    delete[] heapArray;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.150.1">This code snippet demonstrates an out-of-bounds write, attempting to access an index that is beyond the allocated range, leading to undefined behavior and potential </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">memory corruption.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">If we run this code with ASan enabled, we get the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.154.1">
make &amp;&amp; ./a.out
=================================================================
==3102850==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000054 at pc 0x55af5525f222 bp 0x7ffde596fb60 sp 0x7ffde596fb50
WRITE of size 4 at 0x603000000054 thread T0
    #0 0x55af5525f221 in main /home/user/clang-sanitizers/main.cpp:3
    #1 0x7f1ad0a29d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
    #2 0x7f1ad0a29e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)
    #3 0x55af5525f104 in _start (/home/user/clang-sanitizers/build/a.out+0x1104)
0x603000000054 is located 0 bytes to the right of 20-byte region [0x603000000040,0x603000000054)
allocated by thread T0 here:
    #0 0x7f1ad12b6357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102
    #1 0x55af5525f1de in main /home/user/clang-sanitizers/main.cpp:2
    #2 0x7f1ad0a29d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/clang-sanitizers/main.cpp:3 in main
Shadow bytes around the buggy address:
  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x0c067fff8000: fa fa 00 00 00 fa fa fa 00 00[04]fa fa fa fa fa
  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==3102850==ABORTING</span></pre>
<p><span class="koboSpan" id="kobo.155.1">As you can see, the </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.156.1">report includes a detailed stack trace, highlighting the exact location of the error in the source code. </span><span class="koboSpan" id="kobo.156.2">This information is invaluable for debugging and fixing </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the issue.</span></span></p>
<h4><span class="koboSpan" id="kobo.158.1">Out-of-bounds access on the stack</span></h4>
<p><span class="koboSpan" id="kobo.159.1">Next, we</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.160.1"> focus on the stack. </span><span class="koboSpan" id="kobo.160.2">Here, out-of-bounds accesses often occur with local variables due to incorrect indexing or buffer overruns. </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">For example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
int main() {
    int stackArray[5];
    stackArray[5] = 10; // Out-of-bounds write on the stack
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.163.1">In this case, accessing </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">stackArray[5]</span></strong><span class="koboSpan" id="kobo.165.1"> is out of bounds, as valid indices are from </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">0</span></strong><span class="koboSpan" id="kobo.167.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">4</span></strong><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">Such errors can result in crashes or exploitable vulnerabilities. </span><span class="koboSpan" id="kobo.169.3">The output of ASan for this example is very similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">previous one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
==3190568==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffd166961e4 at pc 0x55b4cd113295 bp 0x7ffd166961a0 sp 0x7ffd16696190
WRITE of size 4 at 0x7ffd166961e4 thread T0
    #0 0x55b4cd113294 in main /home/user/clang-sanitizers/main.cpp:3
    #1 0x7f90fc829d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
    #2 0x7f90fc829e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)
    #3 0x55b4cd113104 in _start (/home/user/clang-sanitizers/build/a.out+0x1104)
Address 0x7ffd166961e4 is located in stack of thread T0 at offset 52 in frame
    #0 0x55b4cd1131d8 in main /home/user/clang-sanitizers/main.cpp:1
  This frame has 1 object(s):
    [32, 52) ‘stackArray’ (line 2) &lt;== Memory access at offset 52 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/user/clang-sanitizers/main.cpp:3 in main
Shadow bytes around the buggy address:
  0x100022ccabe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccabf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x100022ccac30: 00 00 00 00 00 00 f1 f1 f1 f1 00 00[04]f3 f3 f3
  0x100022ccac40: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100022ccac80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==3190568==ABORTING</span></pre>
<h4><span class="koboSpan" id="kobo.172.1">Out-of-bounds access to global variables</span></h4>
<p><span class="koboSpan" id="kobo.173.1">Finally, we </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.174.1">examine global variables. </span><span class="koboSpan" id="kobo.174.2">These are susceptible to similar risks when accessed beyond their </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">defined boundaries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
int globalArray[5];
int main() {
    globalArray[5] = 10;  // Out-of-bounds access to a global array
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.177.1">Here, the attempt to write to </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">globalArray[5]</span></strong><span class="koboSpan" id="kobo.179.1"> is an out-of-bounds operation, leading to undefined behavior. </span><span class="koboSpan" id="kobo.179.2">Since the output of ASan is similar to the previous examples, we won’t include </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">it here.</span></span></p>
<h3><span class="koboSpan" id="kobo.181.1">Addressing use-after-free vulnerabilities in C++</span></h3>
<p><span class="koboSpan" id="kobo.182.1">In the</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.183.1"> following section, we will address a critical and often challenging issue in C++ programming: </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">use-after-free vulnerabilities</span></strong><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">This type of error occurs when a program continues to use a memory location after it has been freed, leading to undefined behavior, program crashes, security vulnerabilities, and data corruption. </span><span class="koboSpan" id="kobo.185.3">We’ll explore this issue in various contexts, providing insights into its identification </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">and prevention.</span></span></p>
<h4><span class="koboSpan" id="kobo.187.1">Use-after-free in dynamic memory (heap)</span></h4>
<p><span class="koboSpan" id="kobo.188.1">The </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.189.1">most common scenario for use-after-free errors occurs with dynamically allocated memory on the heap. </span><span class="koboSpan" id="kobo.189.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
#include &lt;iostream&gt;
template &lt;typename T&gt;
struct Node {
    T data;
    Node *next;
    Node(T val) : data(val), next(nullptr) {}
};
int main() {
    auto *head = new Node(1);
    auto *temp = head;
    head       = head-&gt;next;
    delete temp;
    std::cout &lt;&lt; temp-&gt;data; // Use-after-free in a linked list
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.192.1">In this </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.193.1">snippet, the memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">ptr</span></strong><span class="koboSpan" id="kobo.195.1"> is accessed after it has been freed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">delete</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">This access can lead to unpredictable behavior, as the freed memory might be allocated for other purposes or modified by </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the system.</span></span></p>
<h4><span class="koboSpan" id="kobo.199.1">Use-after-free with object references</span></h4>
<p><span class="koboSpan" id="kobo.200.1">Use-after-free can also</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.201.1"> occur in object-oriented programming, especially when dealing with references or pointers to objects that have been destroyed. </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">For instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
class Example {
public:
    int value;
    Example() : value(0) {}
};
Example* obj = new Example();
Example&amp; ref = *obj;
delete obj;
std::cout &lt;&lt; ref.value;  // Use-after-free through a reference</span></pre>
<p><span class="koboSpan" id="kobo.204.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ref</span></strong><span class="koboSpan" id="kobo.206.1"> refers to an object that has been deleted, and any operation on </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">ref</span></strong><span class="koboSpan" id="kobo.208.1"> after the deletion leads </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">to use-after-free.</span></span></p>
<h4><span class="koboSpan" id="kobo.210.1">Use-After-Free in Complex Data Structures</span></h4>
<p><span class="koboSpan" id="kobo.211.1">Complex data structures, such</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.212.1"> as linked lists or trees, are also prone to use-after-free errors, particularly during deletion or restructuring operations. </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">For example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};
Node* head = new Node(1);
Node* temp = head;
head = head-&gt;next;
delete temp;
std::cout &lt;&lt; temp-&gt;data;  // Use-after-free in a linked list</span></pre>
<p><span class="koboSpan" id="kobo.215.1">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">temp</span></strong><span class="koboSpan" id="kobo.217.1"> is used after it has been freed, which can lead to serious issues, especially if the list is large or part of a critical </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">system component.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">ASan can </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.220.1">help in detecting use-after-free errors in C++ programs. </span><span class="koboSpan" id="kobo.220.2">For instance, if we run the previous example with ASan enabled, we get the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
make &amp;&amp; ./a.out
Consolidate compiler generated dependencies of target a.out
[100%] Built target a.out
=================================================================
==3448347==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x55fbcc2ca3b2 bp 0x7fff2f3af7a0 sp 0x7fff2f3af790
READ of size 4 at 0x602000000010 thread T0
    #0 0x55fbcc2ca3b1 in main /home/user/clang-sanitizers/main.cpp:15
    #1 0x7efdb6429d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
    #2 0x7efdb6429e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)
    #3 0x55fbcc2ca244 in _start (/home/user/clang-sanitizers/build/a.out+0x1244)</span></pre>
<h4><span class="koboSpan" id="kobo.223.1">Use-after-return detection in ASan</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.224.1">Use-after-return</span></strong><span class="koboSpan" id="kobo.225.1"> is a</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.226.1"> type of </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.227.1">memory error in C++ programming where a function returns a pointer or a reference to a local (stack-allocated) variable. </span><span class="koboSpan" id="kobo.227.2">This local variable ceases to exist once the function returns, making any subsequent access through the returned pointer or reference invalid and dangerous. </span><span class="koboSpan" id="kobo.227.3">This can lead to undefined behavior and potential </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">security vulnerabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">ASan provides a mechanism to detect use-after-return errors. </span><span class="koboSpan" id="kobo.229.2">It can be controlled using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">-fsanitize-address-use-after-return</span></strong><span class="koboSpan" id="kobo.231.1"> flag during compilation and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">ASAN_OPTIONS</span></strong><span class="koboSpan" id="kobo.233.1"> environment variable </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">The following </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.236.1">describes the configuration of </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">use-after-return detection:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.238.1">Compilation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.239.1">flag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">-fsanitize-address-use-after-return=(never|</span></strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">runtime|always)</span></strong></span><p class="list-inset"><span class="koboSpan" id="kobo.243.1">The flag accepts </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">three settings:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">never</span></strong><span class="koboSpan" id="kobo.246.1">: This disables </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">use-after-return detection</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">runtime</span></strong><span class="koboSpan" id="kobo.249.1">: This enables detection, but it can be overridden at runtime (</span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">default setting)</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">always</span></strong><span class="koboSpan" id="kobo.252.1">: This always enables detection, irrespective of </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">runtime settings</span></span></li></ul></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.254.1">Runtime configuration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.256.1">To explicitly enable or disable use-after-return detection at runtime, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">ASAN_OPTIONS</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.258.1">environment variable:</span></span></p><ul><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.259.1">Enable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">ASAN_OPTIONS=detect_stack_use_after_return=1</span></strong></span></li><li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.262.1">Disable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ASAN_OPTIONS=detect_stack_use_after_return=0</span></strong></span></li><li><span class="koboSpan" id="kobo.265.1">On Linux, detection is enabled </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">by default</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.267.1">Here is an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">its usage:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.269.1">Compiling with use-after-return </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.270.1">detection enabled</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.272.1">
clang++ -fsanitize=address -fsanitize-address-use-after-return=always -g -o your_program your_file.cpp</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.273.1">This command compiles </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">your_file.cpp</span></strong><span class="koboSpan" id="kobo.275.1"> with ASan and explicitly enables </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">use-after-return detection.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.277.1">Running with </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.278.1">detection enabled/disabled</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">:</span></span><ul><li><span class="koboSpan" id="kobo.280.1">To run the program with use-after-return detection enabled (on platforms where it’s not </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">the default):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
ASAN_OPTIONS=detect_stack_use_after_return=1 ./your_program</span></pre></li><li><span class="koboSpan" id="kobo.283.1">To disable detection, even if it was enabled at </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">compile time:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.285.1">
ASAN_OPTIONS=detect_stack_use_after_return=0 ./your_program</span></pre></li></ul></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.286.1">Example code </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.287.1">demonstrating use-after-return</span></strong></span></p>
<p><span class="koboSpan" id="kobo.288.1">The provided C++ code</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.289.1"> example</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.290.1"> demonstrates a use-after-return scenario, which is a type of undefined behavior caused by returning a reference to a local variable from a function. </span><span class="koboSpan" id="kobo.290.2">Let’s analyze the example and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the implications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
#include &lt;iostream&gt;
const std::string &amp;get_binary_name() {
    const std::string name = “main”;
    return name; // Returning address of a local variable
}
int main() {
    const auto &amp;name = get_binary_name();
    // Use after return: accessing memory through name is undefined behavior
    std::cout &lt;&lt; name &lt;&lt; std::endl;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.293.1">In the </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.294.1">given code example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">get_binary_name</span></strong><span class="koboSpan" id="kobo.296.1"> function is designed to create a local </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">std::string</span></strong><span class="koboSpan" id="kobo.298.1"> object named </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">name</span></strong><span class="koboSpan" id="kobo.300.1"> and return a reference to it. </span><span class="koboSpan" id="kobo.300.2">The critical issue arises from the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">name</span></strong><span class="koboSpan" id="kobo.302.1"> is a</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.303.1"> local variable, which gets destroyed as soon as the function scope ends. </span><span class="koboSpan" id="kobo.303.2">As a result, the reference that </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">get_binary_name</span></strong><span class="koboSpan" id="kobo.305.1"> returns becomes invalid the moment the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">function exits.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">main</span></strong><span class="koboSpan" id="kobo.309.1"> function, this returned reference, now stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">name</span></strong><span class="koboSpan" id="kobo.311.1">, is used to access the string value. </span><span class="koboSpan" id="kobo.311.2">However, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">name</span></strong><span class="koboSpan" id="kobo.313.1"> refers to a local variable that has already been destroyed, using it in this manner leads to undefined behavior. </span><span class="koboSpan" id="kobo.313.2">This is a classic example of a use-after-return error, where the program attempts to access memory that is no </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">longer valid.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The function’s intended functionality seems to be to return the program’s name. </span><span class="koboSpan" id="kobo.315.2">However, for this to work correctly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">name</span></strong><span class="koboSpan" id="kobo.317.1"> variable should have a static or global lifetime rather than being a local variable confined to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">get_binary_name</span></strong><span class="koboSpan" id="kobo.319.1"> function. </span><span class="koboSpan" id="kobo.319.2">This would ensure that the returned reference remains valid beyond the scope of the function, avoiding the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">use-after-return error.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Modern compilers are equipped with the ability to issue warnings about potentially problematic code patterns, such as returning references to local variables. </span><span class="koboSpan" id="kobo.321.2">In the context of our example, a compiler might flag the return of a local variable reference as a warning, signaling a possible </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">use-after-return error.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">However, to effectively demonstrate the capabilities of ASan in catching use-after-return errors, it’s sometimes necessary to bypass these compile-time warnings. </span><span class="koboSpan" id="kobo.323.2">This can be achieved by explicitly disabling the compiler’s warning. </span><span class="koboSpan" id="kobo.323.3">For instance, by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">-Wno-return-local-addr</span></strong><span class="koboSpan" id="kobo.325.1"> flag to the compilation command, we can prevent the compiler from issuing a warning about returning a local address. </span><span class="koboSpan" id="kobo.325.2">Doing so allows us to shift the focus from compile-time detection to runtime detection, where ASan’s capabilities in identifying use-after-return errors can be more prominently displayed and tested. </span><span class="koboSpan" id="kobo.325.3">This approach underscores the runtime diagnostic strengths of ASan, particularly in cases where compile-time analysis might not </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">be sufficient.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.327.1">Compiling </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.328.1">with ASan</span></strong></span></p>
<p><span class="koboSpan" id="kobo.329.1">To compile this program with ASan’s use-after-return detection enabled, you would use a command</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.330.1"> such as </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
clang++ -fsanitize=address -Wno-return-local-addr -g your_file.cpp -o your_program</span></pre>
<p><span class="koboSpan" id="kobo.333.1">This </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.334.1">command compiles the program with ASan enabled while suppressing the specific compiler warning about returning the address of a local variable. </span><span class="koboSpan" id="kobo.334.2">Running the compiled program will allow ASan to detect and report the use-after-return error </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">at runtime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
Consolidate compiler generated dependencies of target a.out
[100%] Built target a.out
AddressSanitizer:DEADLYSIGNAL
=================================================================
==4104819==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000008 (pc 0x7f74e354f4c4 bp 0x7ffefcd298e0 sp 0x7ffefcd298c8 T0)
==4104819==The signal is caused by a READ memory access.
</span><span class="koboSpan" id="kobo.336.2">==4104819==Hint: address points to the zero page.
</span><span class="koboSpan" id="kobo.336.3">    #0 0x7f74e354f4c4 in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) (/lib/x86_64-linux-gnu/libstdc++.so.6+0x14f4c4)
    #1 0x559799ab4785 in main /home/user/clang-sanitizers/main.cpp:11
    #2 0x7f74e3029d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
    #3 0x7f74e3029e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)
    #4 0x559799ab4504 in _start (/home/user/clang-sanitizers/build/a.out+0x2504)
AddressSanitizer can not provide additional info.
</span><span class="koboSpan" id="kobo.336.4">SUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libstdc++.so.6+0x14f4c4) in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)
==4104819==ABORTING</span></pre>
<p><span class="koboSpan" id="kobo.337.1">This</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.338.1"> example highlights the</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.339.1"> importance of understanding object lifetimes in C++ and how misuse can lead to undefined behavior. </span><span class="koboSpan" id="kobo.339.2">While compiler warnings are valuable for catching such issues at compile time, tools such as ASan provide an additional layer of runtime error detection, which is especially useful in complex scenarios where compile-time analysis might </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">not suffice.</span></span></p>
<h4><span class="koboSpan" id="kobo.341.1">Use-after-return detection</span></h4>
<p><span class="koboSpan" id="kobo.342.1">The </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.343.1">concept of use-after-scope in C++ involves accessing a variable after its scope has ended, leading to undefined behavior. </span><span class="koboSpan" id="kobo.343.2">This type of error is subtle and can be particularly challenging to detect and debug. </span><span class="koboSpan" id="kobo.343.3">ASan offers a feature to detect use-after-scope errors, which can be enabled using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">-fsanitize-address-use-after-scope</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.345.1">compilation flag.</span></span></p>
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.346.1">Understanding use-after-scope</span></strong></span></p>
<p><span class="koboSpan" id="kobo.347.1">Use-after-scope</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.348.1"> occurs when a program continues to use a pointer or reference to a variable that has gone out of scope. </span><span class="koboSpan" id="kobo.348.2">Unlike use-after-return, where the issue is with function-local variables, use-after-scope can occur within any scope, such as within a block of code, such as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">if</span></strong><span class="koboSpan" id="kobo.350.1"> statement or </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">a loop.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">When a variable goes out of scope, its memory location may still hold the old data for some time, but this memory can be overwritten at any moment. </span><span class="koboSpan" id="kobo.352.2">Accessing this memory is undefined behavior and can lead to erratic program behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">or crashes.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.354.1">Configuring ASan for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.355.1">use-after-scope detection</span></strong></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.356.1">Compilation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.357.1">flag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">-fsanitize-address-use-after-scope</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.361.1">Adding</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.362.1"> this flag to your compilation command instructs ASan to instrument the code to detect </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">use-after-scope errors</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">It’s important to note that this detection is not enabled by default and must be </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">explicitly enabled</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.366.1">Example code </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.367.1">demonstrating use-after-scope</span></strong></span></p>
<p><span class="koboSpan" id="kobo.368.1">The provided </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.369.1">code snippet</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.370.1"> demonstrates a classic case of use-after-scope error in C++. </span><span class="koboSpan" id="kobo.370.2">Let’s analyze the code and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the issue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
int* create_array(bool condition) {
  int *p;
  if (condition) {
    int x[10];
    p = x;
  }
  *p = 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.373.1">In the given code snippet, we begin by declaring a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">p</span></strong><span class="koboSpan" id="kobo.375.1"> pointer without initializing it. </span><span class="koboSpan" id="kobo.375.2">The function then enters a conditional scope where, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">condition</span></strong><span class="koboSpan" id="kobo.377.1"> is true, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">x[10]</span></strong><span class="koboSpan" id="kobo.379.1"> array is created on the stack. </span><span class="koboSpan" id="kobo.379.2">Within this scope, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">p</span></strong><span class="koboSpan" id="kobo.381.1"> pointer is assigned to point to the start of this array, effectively making </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">p</span></strong><span class="koboSpan" id="kobo.383.1"> point </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">x</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">The critical issue arises after the conditional block is exited. </span><span class="koboSpan" id="kobo.387.2">At this point, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">x</span></strong><span class="koboSpan" id="kobo.389.1"> array, being local to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">if</span></strong><span class="koboSpan" id="kobo.391.1"> block, goes out of scope and is no longer valid. </span><span class="koboSpan" id="kobo.391.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">p</span></strong><span class="koboSpan" id="kobo.393.1"> pointer still holds the address of where </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">x</span></strong><span class="koboSpan" id="kobo.395.1"> was located. </span><span class="koboSpan" id="kobo.395.2">When the code attempts to write to this memory location using </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">*p = 1;</span></strong><span class="koboSpan" id="kobo.397.1">, it is trying to access the memory of the now out-of-scope </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">x</span></strong><span class="koboSpan" id="kobo.399.1"> array. </span><span class="koboSpan" id="kobo.399.2">This action leads to a use-after-scope error, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">p</span></strong><span class="koboSpan" id="kobo.401.1"> is dereferenced to access memory that is no longer valid within the current scope. </span><span class="koboSpan" id="kobo.401.2">This kind of error is a classic example of use-after-scope, highlighting the dangers of accessing memory through pointers that point to </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">out-of-scope variables.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Accessing memory through a pointer that points to an out-of-scope variable, as demonstrated in the provided code snippet, leads to undefined behavior. </span><span class="koboSpan" id="kobo.403.2">This is because once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">x</span></strong><span class="koboSpan" id="kobo.405.1"> variable goes out of scope, the memory location to which </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">p</span></strong><span class="koboSpan" id="kobo.407.1"> points becomes indeterminate. </span><span class="koboSpan" id="kobo.407.2">The undefined behavior arising from this scenario is problematic for </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">several reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Firstly, it poses</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.410.1"> significant security and stability risks to the program. </span><span class="koboSpan" id="kobo.410.2">The undefined nature of the behavior means that the program could crash or behave unpredictably. </span><span class="koboSpan" id="kobo.410.3">Such instability in a program’s execution can have far-reaching consequences, particularly in applications where reliability is critical. </span><span class="koboSpan" id="kobo.410.4">Furthermore, if the memory location previously occupied by </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">x</span></strong><span class="koboSpan" id="kobo.412.1"> gets overwritten by other parts of the program, it could potentially lead to security vulnerabilities. </span><span class="koboSpan" id="kobo.412.2">These vulnerabilities might be exploited to compromise the program or the system on which it </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">In summary, the </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.415.1">undefined behavior resulting from accessing memory through pointers to out-of-scope variables is a serious concern in software development, necessitating careful management of variable scope and memory access patterns to ensure the security and stability of </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the program.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">To compile the program with ASan’s use-after-scope detection enabled, you would use a command such as </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
g++ -fsanitize=address -fsanitize-address-use-after-scope -g your_file.cpp -o your_program</span></pre>
<p><span class="koboSpan" id="kobo.420.1">Running the compiled program with these settings enables ASan to detect and report use-after-scope errors </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Use-after-scope errors can be insidious and difficult to trace due to their dependence on the program’s runtime state and memory layout. </span><span class="koboSpan" id="kobo.422.2">By enabling use-after-scope detection in ASan, developers gain a valuable tool for identifying these errors, leading to more robust and reliable C++ applications. </span><span class="koboSpan" id="kobo.422.3">Understanding and preventing such issues is crucial for writing safe and correct </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">C++ code.</span></span></p>
<h4><span class="koboSpan" id="kobo.424.1">Double-free and invalid-free checks in ASan</span></h4>
<p><span class="koboSpan" id="kobo.425.1">ASan, a part</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.426.1"> of the LLVM project, provides robust mechanisms to detect and diagnose two critical types of memory errors in C++ programs: double free and invalid free. </span><span class="koboSpan" id="kobo.426.2">These errors are not only common in complex C++ applications but can also lead to severe issues such as program crashes, undefined behavior, and </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">security vulnerabilities.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.428.1">Understanding double free and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.429.1">invalid free</span></strong></span></p>
<p><span class="koboSpan" id="kobo.430.1">Understanding </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.431.1">double-free and invalid-free errors is essential in managing memory in C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">programs effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">A double-free error occurs when an attempt is made to free a memory block more than once using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">delete</span></strong><span class="koboSpan" id="kobo.435.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">delete[]</span></strong><span class="koboSpan" id="kobo.437.1"> operators. </span><span class="koboSpan" id="kobo.437.2">This typically happens when the same memory allocation is passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">delete</span></strong><span class="koboSpan" id="kobo.439.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">delete[]</span></strong><span class="koboSpan" id="kobo.441.1"> twice. </span><span class="koboSpan" id="kobo.441.2">The first call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">delete</span></strong><span class="koboSpan" id="kobo.443.1"> frees the memory, but the</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.444.1"> second call attempts to free memory that has already been released. </span><span class="koboSpan" id="kobo.444.2">This can lead to heap corruption, as the program might subsequently modify or reallocate the freed memory for other uses. </span><span class="koboSpan" id="kobo.444.3">Double-free errors can cause unpredictable behavior in your program, including crashes and </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">data corruption.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Invalid-free errors, on</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.447.1"> the other hand, occur when </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">delete</span></strong><span class="koboSpan" id="kobo.449.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">delete[]</span></strong><span class="koboSpan" id="kobo.451.1"> is used on a pointer that wasn’t allocated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">new</span></strong><span class="koboSpan" id="kobo.453.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">new[]</span></strong><span class="koboSpan" id="kobo.455.1">, or that has already been freed. </span><span class="koboSpan" id="kobo.455.2">This category includes attempts to free a null pointer, pointers to stack memory (which are not dynamically allocated), or pointers to uninitialized memory. </span><span class="koboSpan" id="kobo.455.3">Like double-free errors, invalid frees can also lead to heap corruption and unpredictable program behavior. </span><span class="koboSpan" id="kobo.455.4">They are particularly insidious because they can corrupt the memory management structures of the C++ runtime, leading to subtle and </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">hard-to-diagnose bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">Both of these errors stem from improper handling of dynamic memory, underscoring the importance of adhering to best practices in memory management, such as ensuring every </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">new</span></strong><span class="koboSpan" id="kobo.459.1"> has a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">delete</span></strong><span class="koboSpan" id="kobo.461.1"> and avoiding the reuse of pointers after they have </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">been freed.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">This list outlines the features of ASan’s </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">detection mechanism:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.465.1">Heap corruption detection</span></strong><span class="koboSpan" id="kobo.466.1">: ASan instruments the program to keep track of all heap allocations and deallocations. </span><span class="koboSpan" id="kobo.466.2">When a </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">delete</span></strong><span class="koboSpan" id="kobo.468.1"> operation is performed, ASan checks whether the pointer corresponds to a valid, previously allocated, and not-yet-freed </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">memory block.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.470.1">Error reporting</span></strong><span class="koboSpan" id="kobo.471.1">: If a double-free or invalid-free error is detected, ASan aborts the program’s execution and provides a detailed error report. </span><span class="koboSpan" id="kobo.471.2">This report includes the location in the code where the error occurred, the memory address involved, and the allocation history of that memory (</span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">if available).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.473.1">Here is some example code demonstrating </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">double-free errors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
int main() {
    int* ptr = new int(10);
    delete ptr;
    delete ptr;  // Double-free error
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.476.1">ASan would report</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.477.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">following error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
make &amp;&amp; ./a.out
Consolidate compiler generated dependencies of target a.out
[ 50%] Building CXX object CMakeFiles/a.out.dir/main.cpp.o
[100%] Linking CXX executable a.out
[100%] Built target a.out
=================================================================
==765374==ERROR: AddressSanitizer: attempting double-free on 0x602000000010 in thread T0:
    #0 0x7f7ff5eb724f in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172
    #1 0x55839eca830b in main /home/user/clang-sanitizers/main.cpp:6
    #2 0x7f7ff5629d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
    #3 0x7f7ff5629e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)
    #4 0x55839eca81c4 in _start (/home/user/clang-sanitizers/build/a.out+0x11c4)
0x602000000010 is located 0 bytes inside of 4-byte region [0x602000000010,0x602000000014)
freed by thread T0 here:
    #0 0x7f7ff5eb724f in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172
    #1 0x55839eca82f5 in main /home/user/clang-sanitizers/main.cpp:5
    #2 0x7f7ff5629d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
previously allocated by thread T0 here:
    #0 0x7f7ff5eb61e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99
    #1 0x55839eca829e in main /home/user/clang-sanitizers/main.cpp:4
    #2 0x7f7ff5629d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
SUMMARY: AddressSanitizer: double-free ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172 in operator delete(void*, unsigned long)
==765374==ABORTING</span></pre>
<p><span class="koboSpan" id="kobo.480.1">In this example, the </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.481.1">same memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">ptr</span></strong><span class="koboSpan" id="kobo.483.1"> is freed twice, leading to a </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">double-free error.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.485.1">Example code demonstrating </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.486.1">invalid free</span></strong></span></p>
<p><span class="koboSpan" id="kobo.487.1">The </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.488.1">provided code snippet demonstrates an invalid-free error, which is a type of memory management mistake that can occur in C++ programming. </span><span class="koboSpan" id="kobo.488.2">Let’s dissect the example to understand the issue and </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">its implications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
int main() {
    int local_var = 42;
    int* ptr = &amp;local_var;
    delete ptr;  // Invalid free error
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.491.1">In a given code segment, we start by declaring and initializing a local </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">int local_var = 42;</span></strong><span class="koboSpan" id="kobo.493.1"> variable. </span><span class="koboSpan" id="kobo.493.2">This creates a stack-allocated integer variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">local_var</span></strong><span class="koboSpan" id="kobo.495.1">. </span><span class="koboSpan" id="kobo.495.2">Following this, a pointer assignment is made with </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">int* ptr = &amp;local_var;</span></strong><span class="koboSpan" id="kobo.497.1">, where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">ptr</span></strong><span class="koboSpan" id="kobo.499.1"> pointer is set to point to the address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">local_var</span></strong><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">This establishes a link between the pointer and the </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">stack-allocated variable.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">However, an</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.504.1"> issue arises with the subsequent operation: </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">delete ptr;</span></strong><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">This line of code attempts to free the memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">ptr</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">The problem here is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">ptr</span></strong><span class="koboSpan" id="kobo.510.1"> is pointing to a stack-allocated variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">local_var</span></strong><span class="koboSpan" id="kobo.512.1">, rather than a dynamically allocated piece of memory from the heap. </span><span class="koboSpan" id="kobo.512.2">In C++, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">delete</span></strong><span class="koboSpan" id="kobo.514.1"> operator is intended to be used exclusively with pointers that have been allocated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">new</span></strong><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">local_var</span></strong><span class="koboSpan" id="kobo.518.1"> was not allocated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">new</span></strong><span class="koboSpan" id="kobo.520.1"> (being a stack-allocated variable), using </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">delete</span></strong><span class="koboSpan" id="kobo.522.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">ptr</span></strong><span class="koboSpan" id="kobo.524.1"> is invalid and leads to undefined behavior. </span><span class="koboSpan" id="kobo.524.2">This misuse of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">delete</span></strong><span class="koboSpan" id="kobo.526.1"> operator on a non-heap pointer is a common mistake that can lead to serious runtime</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.527.1"> errors in a </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">C++ program.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">Here are some modern </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">compiler warnings:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.531.1">Modern C++ compilers typically issue warnings or errors when </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">delete</span></strong><span class="koboSpan" id="kobo.533.1"> is used on a pointer that doesn’t point to dynamically allocated memory, as this is a common source </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">of bugs.</span></span></li>
<li><span class="koboSpan" id="kobo.535.1">To compile this code without modification and demonstrate ASan’s ability to catch such errors, you might need to suppress the compiler warning. </span><span class="koboSpan" id="kobo.535.2">This can be done by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">-Wno-free-nonheap-object</span></strong><span class="koboSpan" id="kobo.537.1"> flag to the </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">compilation command.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.539.1">Compiling with ASan for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.540.1">invalid-free detection</span></strong></span></p>
<p><span class="koboSpan" id="kobo.541.1">To compile</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.542.1"> the program </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.543.1">with ASan to detect the invalid free operation, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
clang++ -fsanitize=address -Wno-free-nonheap-object -g your_file.cpp -o your_program</span></pre>
<p><span class="koboSpan" id="kobo.546.1">This command compiles the program with ASan enabled and suppresses the specific compiler warning about freeing non-heap objects. </span><span class="koboSpan" id="kobo.546.2">When you run the compiled program, ASan will detect and report the invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">free operation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.548.1">
=================================================================
==900629==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7fff390f21d0 in thread T0
    #0 0x7f30b82b724f in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172
    #1 0x563f21cd72c7 in main /home/user/clang-sanitizers/main.cpp:4
    #2 0x7f30b7a29d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
    #3 0x7f30b7a29e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)
    #4 0x563f21cd7124 in _start (/home/user/clang-sanitizers/build/a.out+0x1124)
Address 0x7fff390f21d0 is located in stack of thread T0 at offset 32 in frame
    #0 0x563f21cd71f8 in main /home/user/clang-sanitizers/main.cpp:1
  This frame has 1 object(s):
    [32, 36) ‘local_var’ (line 2) &lt;== Memory access at offset 32 is inside this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: bad-free ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172 in operator delete(void*, unsigned long)
==900629==ABORTING</span></pre>
<p><span class="koboSpan" id="kobo.549.1">The</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.550.1"> attempt to delete a pointer to a non-heap object, as shown in the example, is a misuse of memory </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.551.1">management operations in C++. </span><span class="koboSpan" id="kobo.551.2">Such practices can lead to undefined behavior and can potentially cause crashes or other erratic program behavior. </span><span class="koboSpan" id="kobo.551.3">ASan serves as a valuable tool in detecting these kinds of errors, contributing significantly to the development of robust and error-free </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">C++ applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.553.1">Fine-tuning ASan for enhanced control</span></h4>
<p><span class="koboSpan" id="kobo.554.1">While ASan </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.555.1">is a powerful tool for detecting memory errors in C++ programs, there are scenarios where its behavior needs to be fine-tuned. </span><span class="koboSpan" id="kobo.555.2">This fine-tuning is crucial for efficiently managing the analysis process, especially when dealing with complex projects that involve external libraries, legacy code, or specific </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">code patterns.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.557.1">Suppressing warnings from </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.558.1">external libraries</span></strong></span></p>
<p><span class="koboSpan" id="kobo.559.1">In the context of many projects, the use of external libraries is a common practice. </span><span class="koboSpan" id="kobo.559.2">However, these libraries, over which you might not have control, can sometimes contain memory issues. </span><span class="koboSpan" id="kobo.559.3">When running tools such as ASan, these issues within the external libraries may get flagged, leading to cluttered diagnostics filled with warnings not directly relevant to your project’s code. </span><span class="koboSpan" id="kobo.559.4">This can be problematic as it may obscure the real issues within your own code base that </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">need attention.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">To mitigate this, ASan offers a useful feature that allows you to suppress warnings specifically coming from these external libraries. </span><span class="koboSpan" id="kobo.561.2">This ability to filter out irrelevant warnings is valuable in maintaining a clear focus on fixing issues that are within the scope of your own code base. </span><span class="koboSpan" id="kobo.561.3">The implementation of this feature typically involves the use of sanitizer special case lists or specifying certain linker flags during the compilation process. </span><span class="koboSpan" id="kobo.561.4">These mechanisms provide a means to tell ASan to ignore certain paths or patterns in the diagnostics, effectively reducing the noise from external sources and aiding in a more targeted and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">debugging process.</span></span></p>
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.563.1">Conditional compilation</span></strong></span></p>
<p><span class="koboSpan" id="kobo.564.1">There are scenarios in software development where you might want to include specific segments of code only when compiling your program with ASan. </span><span class="koboSpan" id="kobo.564.2">This approach can be particularly useful for a variety of purposes, such as incorporating additional diagnostics or modifying memory allocations to make them more compatible or friendly with </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">ASan’s operations.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">To implement this strategy, you can utilize conditional compilation, a technique that includes or excludes parts of the code based on certain conditions. </span><span class="koboSpan" id="kobo.566.2">In the case of ASan, you can check for its presence using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">__has_feature</span></strong><span class="koboSpan" id="kobo.568.1"> macro. </span><span class="koboSpan" id="kobo.568.2">This macro evaluates at compile-time whether a particular feature (in this case, ASan) is available in the current compilation context. </span><span class="koboSpan" id="kobo.568.3">If ASan is being used, the code within the conditional compilation block will be included in the final executable; otherwise, it will </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">be excluded:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
#if defined(__has_feature)
#  if __has_feature(address_sanitizer)
// Do something specific for AddressSanitizer
#  endif
#endif</span></pre>
<p><span class="koboSpan" id="kobo.571.1">This method of conditional compilation allows developers to tailor their code specifically for scenarios where ASan is in use, enhancing the effectiveness of the sanitizer and possibly avoiding issues that might arise only in its presence. </span><span class="koboSpan" id="kobo.571.2">It provides a flexible way to adjust the behavior of the program depending on the build configuration, which can be invaluable in complex development environments where different configurations are used for development, testing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">production stages.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.573.1">Disabling sanitizer for specific lines </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.574.1">of code</span></strong></span></p>
<p><span class="koboSpan" id="kobo.575.1">In the course </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.576.1">of developing complex software, there are instances where certain operations might be intentionally performed, even though they could be flagged as errors by ASan. </span><span class="koboSpan" id="kobo.576.2">Alternatively, you might have segments of your code base that you wish to exclude from ASan’s analysis for specific reasons. </span><span class="koboSpan" id="kobo.576.3">This could be due to known benign behaviors in your code that ASan might misinterpret as errors, or parts of the code where the overhead introduced by ASan is </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">not desirable.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">To address these scenarios, both GCC and Clang compilers provide a method to selectively disable ASan for particular functions or blocks of code. </span><span class="koboSpan" id="kobo.578.2">This is achieved through the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">__attribute__((no_sanitize(“address”)))</span></strong><span class="koboSpan" id="kobo.580.1"> attribute. </span><span class="koboSpan" id="kobo.580.2">By applying this attribute to a function or a specific block of code, you can instruct the compiler to omit ASan instrumentation for that </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">particular segment.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">This feature is particularly useful as it allows for granular control over what parts of the code are subject to ASan’s scrutiny. </span><span class="koboSpan" id="kobo.582.2">It enables developers to fine-tune the balance between thorough error detection and the practical realities of their code’s behavior or performance requirements. </span><span class="koboSpan" id="kobo.582.3">By judiciously applying this attribute, you can ensure that ASan’s analysis is both effective and efficient, focusing its efforts where they are </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">most beneficial.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.584.1">Utilizing the sanitizer special </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.585.1">case list</span></strong></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.586.1">Source files and functions (src and fun)</span></strong><span class="koboSpan" id="kobo.587.1">: ASan allows you to suppress error reports in specified source files or functions. </span><span class="koboSpan" id="kobo.587.2">This is particularly useful when you want to ignore certain known issues or </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">third-party code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.589.1">Globals and types (global and type)</span></strong><span class="koboSpan" id="kobo.590.1">: Additionally, ASan introduces the ability to suppress errors for out-of-bound access to globals with certain names and types. </span><span class="koboSpan" id="kobo.590.2">This feature is specifically handy for global variables and class/struct types, allowing more targeted </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">error suppression.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.592.1">Example of a sanitizer special case </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.593.1">list entry</span></strong></span></p>
<p><span class="koboSpan" id="kobo.594.1">Fine-tuning ASan is an essential aspect of integrating it into a large-scale, complex development environment. </span><span class="koboSpan" id="kobo.594.2">It allows developers to customize the behavior of ASan to fit the specific needs of the project, be it by </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.595.1">excluding external libraries, conditioning code for ASan builds, or ignoring certain errors to focus on more critical issues. </span><span class="koboSpan" id="kobo.595.2">By effectively utilizing these fine-tuning capabilities, teams can harness the full power of ASan to ensure robust and reliable C++ applications. </span><span class="koboSpan" id="kobo.595.3">The suppression rules can be set in a textual file </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">
fun:FunctionName  # Suppresses errors from FunctionName
global:GlobalVarName  # Suppresses out-of-bound errors on GlobalVarName
type:TypeName  # Suppresses errors for TypeName objects</span></pre>
<p><span class="koboSpan" id="kobo.598.1">This file can then be passed to the runtime via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">ASAN_OPTIONS</span></strong><span class="koboSpan" id="kobo.600.1"> environment variable, such </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">ASAN_OPTIONS=suppressions=path/to/suppressionfile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.604.1">Performance overhead of ASan</span></h4>
<p><span class="koboSpan" id="kobo.605.1">The </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.606.1">use of ASan in detecting memory management issues, such as invalid free operations, is highly beneficial in identifying and resolving potential bugs in C++ applications. </span><span class="koboSpan" id="kobo.606.2">However, it’s important to be aware of the performance implications of </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">using ASan.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.608.1">Performance impact, limitations, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.609.1">and recommendations</span></strong></span></p>
<p><span class="koboSpan" id="kobo.610.1">Integrating ASan into the development and testing process brings with it a certain level of performance overhead. </span><span class="koboSpan" id="kobo.610.2">Typically, the slowdown introduced by ASan is in the region of 2x, meaning a program instrumented with ASan may run approximately twice as slowly compared to its non-instrumented version. </span><span class="koboSpan" id="kobo.610.3">This increased execution time is primarily due to the additional checks and monitoring that ASan performs to meticulously detect memory errors. </span><span class="koboSpan" id="kobo.610.4">Every memory access, along with each memory allocation and deallocation operation, is subject to these checks, inevitably resulting in additional CPU cycles </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">being consumed.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">Given this performance impact, ASan is predominantly utilized during the development and testing phases of the software life cycle. </span><span class="koboSpan" id="kobo.612.2">This usage pattern represents a trade-off: while there is a performance cost to using ASan, the benefits of catching and fixing critical memory-related errors early in the development process are significant. </span><span class="koboSpan" id="kobo.612.3">Early detection of such issues helps in maintaining code quality and can substantially reduce the time and resources required for debugging and fixing bugs later in </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">the cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">However, deploying</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.615.1"> ASan-instrumented binaries in a production environment is generally not recommended, especially in scenarios where performance is a critical factor. </span><span class="koboSpan" id="kobo.615.2">The overhead introduced by ASan can impact the application’s responsiveness and efficiency. </span><span class="koboSpan" id="kobo.615.3">That said, in certain contexts, particularly in applications where reliability and security are of paramount importance, and performance considerations are secondary, using ASan in a production-like environment for thorough testing might be justified. </span><span class="koboSpan" id="kobo.615.4">In such cases, the additional assurance of stability and security provided by ASan can outweigh the concerns regarding </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">performance degradation.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">ASan is supported on </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.619.1">Linux i386/x86_64 (tested on </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">Ubuntu 12.04)</span></span></li>
<li><span class="koboSpan" id="kobo.621.1">macOS 10.7 – </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">10.11 (i386/x86_64)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.623.1">iOS Simulator</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.624.1">Android ARM</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.625.1">NetBSD i386/x86_64</span></span></li>
<li><span class="koboSpan" id="kobo.626.1">FreeBSD i386/x86_64 (tested on </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">FreeBSD 11-current)</span></span></li>
<li><span class="koboSpan" id="kobo.628.1">Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">8.1+ (i386/x86_64)</span></span></li>
</ul>
<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.630.1">LeakSanitizer (LSan)</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.631.1">LSan</span></strong><span class="koboSpan" id="kobo.632.1"> is a</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.633.1"> dedicated memory leak detection tool that is part of the ASan suite but can also be used independently. </span><span class="koboSpan" id="kobo.633.2">It is specifically designed to identify memory leaks in C++ programs – situations where allocated memory is not freed, leading to increased memory consumption </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">over time.</span></span></p>
<h3><span class="koboSpan" id="kobo.635.1">Integration with ASan</span></h3>
<p><span class="koboSpan" id="kobo.636.1">LSan is </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.637.1">often used in conjunction with ASan. </span><span class="koboSpan" id="kobo.637.2">When you enable ASan in your build, LSan is automatically enabled as well, providing a comprehensive analysis for both memory errors </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">and leaks.</span></span></p>
<h3><span class="koboSpan" id="kobo.639.1">Standalone mode</span></h3>
<p><span class="koboSpan" id="kobo.640.1">If you wish</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.641.1"> to use LSan without ASan, you can enable it by compiling your program with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">-fsanitize=leak</span></strong><span class="koboSpan" id="kobo.643.1"> flag. </span><span class="koboSpan" id="kobo.643.2">This is particularly useful when you want to focus solely on memory leak detection without the overhead of other </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">address sanitizations.</span></span></p>
<h3><span class="koboSpan" id="kobo.645.1">Example of memory leak detection</span></h3>
<p><span class="koboSpan" id="kobo.646.1">Consider </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.647.1">the following C++ code with a </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">memory leak:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
int main() {
    int* leaky_memory = new int[100]; // Memory allocated and never freed
    leaky_memory      = nullptr;      // Memory leaked
    (void)leaky_memory;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.650.1">In this example, an array of integers is dynamically allocated and not freed, resulting in a </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">memory leak.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">When you compile and run this code with LSan, the output might look something </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.654.1">
=================================================================
==1743181==ERROR: LeakSanitizer: detected memory leaks
Direct leak of 400 byte(s) in 1 object(s) allocated from:
    #0 0x7fa14b6b6357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102
    #1 0x55888aabd19e in main /home/user/clang-sanitizers/main.cpp:2
    #2 0x7fa14ae29d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)
SUMMARY: AddressSanitizer: 400 byte(s) leaked in 1 allocation(s).</span></pre>
<p><span class="koboSpan" id="kobo.655.1">This output</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.656.1"> pinpoints the location and size of the memory leak, aiding in quick and </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">effective debugging.</span></span></p>
<h3><span class="koboSpan" id="kobo.658.1">Platform support</span></h3>
<p><span class="koboSpan" id="kobo.659.1">As of the </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.660.1">latest information available, LSan is supported on Linux, macOS, and Android. </span><span class="koboSpan" id="kobo.660.2">The support can vary based on the toolchain and the version of the compiler </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">being used.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">LSan is a valuable tool for C++ developers to identify and resolve memory leaks in their applications. </span><span class="koboSpan" id="kobo.662.2">Its ability to be used both in conjunction with ASan and in standalone mode offers flexibility in addressing specific memory-related issues. </span><span class="koboSpan" id="kobo.662.3">By integrating LSan into the development and testing process, developers can ensure more efficient memory usage and overall improved </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">application stability.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.664.1">MemorySanitizer (MSan)</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.665.1">MSan</span></strong><span class="koboSpan" id="kobo.666.1"> is a </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.667.1">dynamic analysis tool, part of the LLVM project, designed to detect the use of uninitialized memory in C++ programs. </span><span class="koboSpan" id="kobo.667.2">Uninitialized memory use is a common source of bugs that can lead to unpredictable behavior, security vulnerabilities, and </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">difficult-to-diagnose errors.</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">To use MSan, compile your program with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">-fsanitize=memory</span></strong><span class="koboSpan" id="kobo.671.1"> flag. </span><span class="koboSpan" id="kobo.671.2">This instructs the compiler to instrument the code with checks for uninitialized memory usage. </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">For example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
clang++ -fsanitize=memory -g -o your_program your_file.cpp</span></pre>
<h3><span class="koboSpan" id="kobo.674.1">Example code demonstrating uninitialized memory usage</span></h3>
<p><span class="koboSpan" id="kobo.675.1">Consider the</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.676.1"> following simple </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">C++ example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
#include &lt;iostream&gt;
int main() {
    int* ptr = new int[10];
    if (ptr[1]) {
        std::cout &lt;&lt; “xx\n”;
    }
    delete[] ptr;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.679.1">In this code, the</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.680.1"> integers are allocated in the heap but </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">not initialized.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">When compiled and run with MSan, the output might look </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
==48607==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x560a37e0f557 in main /home/user/clang-sanitizers/main.cpp:5:9
    #1 0x7fa118029d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #2 0x7fa118029e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)
    #3 0x560a37d87354 in _start (/home/user/clang-sanitizers/build/a.out+0x1e354) (BuildId: 5a727e2c09217ae0a9d72b8a7ec767ce03f4e6ce)
SUMMARY: MemorySanitizer: use-of-uninitialized-value /home/user/clang-sanitizers/main.cpp:5:9 in main</span></pre>
<p><span class="koboSpan" id="kobo.685.1">MSan detects the use of the uninitialized variable and points to the exact location in the code where </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">this occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">In this case, a fix can be as simple as initializing </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">the array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
    int* ptr = new int[10]{};</span></pre>
<h3><span class="koboSpan" id="kobo.690.1">Fine-tuning, performance impact, and limitations</span></h3>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.691.1">Fine-tuning</span></strong><span class="koboSpan" id="kobo.692.1">: MSan’s</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.693.1"> fine-tuning options are similar to those of ASan. </span><span class="koboSpan" id="kobo.693.2">Users can refer to the official documentation for detailed </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">customization options.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.695.1">Performance impact</span></strong><span class="koboSpan" id="kobo.696.1">: Typically, using </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.697.1">MSan introduces a runtime slowdown of about 3x. </span><span class="koboSpan" id="kobo.697.2">This overhead is due to the additional checks that MSan performs to detect uses of </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">uninitialized memory.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.699.1">Supported platforms</span></strong><span class="koboSpan" id="kobo.700.1">: MSan </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.701.1">is supported on Linux, NetBSD, and FreeBSD. </span><span class="koboSpan" id="kobo.701.2">Its effectiveness in detecting uninitialized memory usage makes it a powerful tool for developers working on </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">these platforms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.703.1">Limitations</span></strong><span class="koboSpan" id="kobo.704.1">: As</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.705.1"> with other sanitizers, MSan’s runtime overhead makes it most suitable for use in testing environments rather than in production. </span><span class="koboSpan" id="kobo.705.2">Additionally, MSan requires that the entire program, including all libraries it uses, be instrumented. </span><span class="koboSpan" id="kobo.705.3">This can be a limitation in cases where source code for certain libraries is </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">not available.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.707.1">MSan is an essential tool for detecting the elusive but potentially critical issue of uninitialized memory usage in C++ programs. </span><span class="koboSpan" id="kobo.707.2">By providing detailed reports on where and how such issues occur, MSan enables developers to identify and fix these errors, significantly improving the reliability and security of their applications. </span><span class="koboSpan" id="kobo.707.3">Integrating MSan into the development and testing phases, despite its performance impact, is a prudent step toward ensuring robust </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">software quality.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.709.1">TSan</span></h2>
<p><span class="koboSpan" id="kobo.710.1">In the realm</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.711.1"> of C++ programming, effectively managing concurrency and multithreading is both vital and challenging. </span><span class="koboSpan" id="kobo.711.2">Thread-related issues, particularly data races, are notoriously difficult to detect and debug. </span><span class="koboSpan" id="kobo.711.3">Unlike other bugs that can often be uncovered through deterministic testing methods such as unit tests, threading issues are elusive and non-deterministic in nature. </span><span class="koboSpan" id="kobo.711.4">They may not manifest under every run of a program, leading to unpredictable and erratic behavior that can be extremely hard to replicate </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">and diagnose.</span></span></p>
<h3><span class="koboSpan" id="kobo.713.1">The complexity of thread-related issues</span></h3>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.714.1">Non-deterministic behavior</span></strong><span class="koboSpan" id="kobo.715.1">: Concurrency issues, including data races, deadlocks, and thread </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.716.1">leaks, are inherently non-deterministic. </span><span class="koboSpan" id="kobo.716.2">This means that they do not consistently reproduce under the same conditions, making them elusive </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">and unpredictable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.718.1">Challenges in detection</span></strong><span class="koboSpan" id="kobo.719.1">: Traditional testing methods, including comprehensive unit tests, often fail to detect these issues. </span><span class="koboSpan" id="kobo.719.2">The outcome of a test involving concurrency can vary from one execution to another, depending on factors such as timing, thread scheduling, and </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">system load.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.721.1">Subtle and severe bugs</span></strong><span class="koboSpan" id="kobo.722.1">: Thread-related bugs can remain dormant, only to surface in </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.723.1">production under specific conditions, potentially leading to severe implications such as data corruption, performance degradation, and </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">system crashes.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.725.1">The necessity of TSan</span></h3>
<p><span class="koboSpan" id="kobo.726.1">Given</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.727.1"> the inherent challenges in managing concurrency in C++, tools such as TSan provided by Clang and GCC become essential. </span><span class="koboSpan" id="kobo.727.2">TSan is a sophisticated tool designed to detect threading issues, with a particular focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">data races.</span></span></p>
<h3><span class="koboSpan" id="kobo.729.1">Enabling TSan</span></h3>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.730.1">How to turn TSan on</span></strong><span class="koboSpan" id="kobo.731.1">: To </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.732.1">enable TSan, compile your C++ code with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">-fsanitize=thread</span></strong><span class="koboSpan" id="kobo.734.1"> flag. </span><span class="koboSpan" id="kobo.734.2">This instructs Clang and GCC to instrument your code for runtime detection of </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">threading issues.</span></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.736.1">Compilation example</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.738.1">
clang++ -fsanitize=thread -g -o your_program your_file.cpp</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.739.1">This command will compile </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">your_file.cpp</span></strong><span class="koboSpan" id="kobo.741.1"> with TSan enabled, ready to detect and report threading issues. </span><span class="koboSpan" id="kobo.741.2">Note that it is impossible to turn on both thread and ASans at the </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">same time.</span></span></p>
<h3><span class="koboSpan" id="kobo.743.1">Example of a data race in C++</span></h3>
<p><span class="koboSpan" id="kobo.744.1">Consider</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.745.1"> this simple yet </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">illustrative example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.747.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
int shared_counter = 0;
void increment_counter() {
    for (int i = 0; i &lt; 10000; ++i) {
        shared_counter++; // Potential data race
    }
}
int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);
    t1.join();
    t2.join();
    std::cout &lt;&lt; “Shared counter: “ &lt;&lt; shared_counter &lt;&lt; std::endl;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.748.1">Here, two</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.749.1"> threads modify the same shared resource without synchronization, leading to a </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">data race.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">If we build and run this code with TSan enabled, we get the </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
==================
WARNING: ThreadSanitizer: data race (pid=2560038)
  Read of size 4 at 0x555fd304f154 by thread T2:
    #0 increment_counter() /home/user/clang-sanitizers/main.cpp:8 (a.out+0x13f9)
    #1 void std::__invoke_impl&lt;void, void (*)()&gt;(std::__invoke_other, void (*&amp;&amp;)()) /usr/include/c++/11/bits/invoke.h:61 (a.out+0x228a)
    #2 std::__invoke_result&lt;void (*)()&gt;::type std::__invoke&lt;void (*)()&gt;(void (*&amp;&amp;)()) /usr/include/c++/11/bits/invoke.h:96 (a.out+0x21df)
    #3 void std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) /usr/include/c++/11/bits/std_thread.h:259 (a.out+0x2134)
    #4 std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator()() /usr/include/c++/11/bits/std_thread.h:266 (a.out+0x20d6)
    #5 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run() /usr/include/c++/11/bits/std_thread.h:211 (a.out+0x2088)
    #6 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xdc252)
  Previous write of size 4 at 0x555fd304f154 by thread T1:
    #0 increment_counter() /home/user/clang-sanitizers/main.cpp:8 (a.out+0x1411)
    #1 void std::__invoke_impl&lt;void, void (*)()&gt;(std::__invoke_other, void (*&amp;&amp;)()) /usr/include/c++/11/bits/invoke.h:61 (a.out+0x228a)
    #2 std::__invoke_result&lt;void (*)()&gt;::type std::__invoke&lt;void (*)()&gt;(void (*&amp;&amp;)()) /usr/include/c++/11/bits/invoke.h:96 (a.out+0x21df)
    #3 void std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) /usr/include/c++/11/bits/std_thread.h:259 (a.out+0x2134)
    #4 std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator()() /usr/include/c++/11/bits/std_thread.h:266 (a.out+0x20d6)
    #5 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run() /usr/include/c++/11/bits/std_thread.h:211 (a.out+0x2088)
    #6 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xdc252)
  Location is global ‘shared_counter’ of size 4 at 0x555fd304f154 (a.out+0x000000005154)
  Thread T2 (tid=2560041, running) created by main thread at:
    #0 pthread_create ../../../../src/libsanitizer/tsan/tsan_interceptors_posix.cpp:969 (libtsan.so.0+0x605b8)
    #1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0xdc328)
    #2 main /home/user/clang-sanitizers/main.cpp:14 (a.out+0x1484)
  Thread T1 (tid=2560040, finished) created by main thread at:
    #0 pthread_create ../../../../src/libsanitizer/tsan/tsan_interceptors_posix.cpp:969 (libtsan.so.0+0x605b8)
    #1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0xdc328)
    #2 main /home/user/clang-sanitizers/main.cpp:13 (a.out+0x146e)
SUMMARY: ThreadSanitizer: data race /home/user/clang-sanitizers/main.cpp:8 in increment_counter()
==================
Shared counter: 20000
ThreadSanitizer: reported 1 warnings</span></pre>
<p><span class="koboSpan" id="kobo.754.1">This output </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.755.1">from TSan indicates a data race condition in a C++ program. </span><span class="koboSpan" id="kobo.755.2">Let’s break down the key elements of this report to understand what it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">telling us:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.757.1">Type of error</span></strong><span class="koboSpan" id="kobo.758.1">: The report begins with a clear indication that a data race has been detected (</span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">WARNING: ThreadSanitizer: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">data race</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.762.1">Location of accesses</span></strong><span class="koboSpan" id="kobo.763.1">: </span><p class="list-inset"><span class="koboSpan" id="kobo.764.1">The report specifies two conflicting memory accesses (a read and a previous write) to the same location, both of which constitute the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">data race.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.766.1">The accesses occur at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">0x555fd304f154</span></strong><span class="koboSpan" id="kobo.768.1"> memory address, which is identified as a global </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">shared_counter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.770.1"> variable.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.771.1">Details of </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.772.1">conflicting accesses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.774.1">Read access by </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.775.1">thread T2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">:</span></span><ul><li><span class="koboSpan" id="kobo.777.1">The read operation is performed by thread T2, as indicated in </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">the report.</span></span></li><li><span class="koboSpan" id="kobo.779.1">The exact line of code where this read occurs is pinpointed: </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">increment_counter() /home/user/clang-sanitizers/main.cpp:8</span></strong><span class="koboSpan" id="kobo.781.1">. </span><span class="koboSpan" id="kobo.781.2">This means the data race read happens in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">increment_counter</span></strong><span class="koboSpan" id="kobo.783.1"> function, specifically at </span><em class="italic"><span class="koboSpan" id="kobo.784.1">line 8</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.785.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">main.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">.</span></span></li><li><span class="koboSpan" id="kobo.788.1">The report also provides a stack trace leading up to this read, showing the sequence of </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">function calls.</span></span></li></ul></li><li><strong class="bold"><span class="koboSpan" id="kobo.790.1">Write access by </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.791.1">thread T1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">:</span></span><ul><li><span class="koboSpan" id="kobo.793.1">Similar to the read access, the report details a write operation by thread T1 to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">global variable.</span></span></li><li><span class="koboSpan" id="kobo.795.1">The location of this write is also in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">increment_counter</span></strong><span class="koboSpan" id="kobo.797.1"> function at </span><em class="italic"><span class="koboSpan" id="kobo.798.1">line 8</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.799.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">main.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">.</span></span></li></ul></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.802.1">Thread </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.803.1">creation information</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.805.1">The</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.806.1"> report includes information about where threads T1 and T2 were created in the program (</span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">main.cpp</span></strong><span class="koboSpan" id="kobo.808.1"> at </span><em class="italic"><span class="koboSpan" id="kobo.809.1">lines 13</span></em><span class="koboSpan" id="kobo.810.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.811.1">14</span></em><span class="koboSpan" id="kobo.812.1">, respectively). </span><span class="koboSpan" id="kobo.812.2">This helps in understanding the program’s flow leading to the </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">data race.</span></span></p></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.814.1">Summary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.816.1">The summary restates the nature of the issue: </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">SUMMARY: ThreadSanitizer: data race /home/user/clang-sanitizers/main.cpp:8 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">in increment_counter()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.820.1">This concisely points to the function and file where the data race </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">is detected.</span></span></p></li>
</ul>
<h3><span class="koboSpan" id="kobo.822.1">Fine-tuning, performance impact, limitations, and recommendations for TSan</span></h3>
<p><span class="koboSpan" id="kobo.823.1">TSan typically introduces a runtime slowdown of approximately 5x-15x. </span><span class="koboSpan" id="kobo.823.2">This significant increase in execution time is due to the comprehensive checks performed by TSan to detect data races and other threading issues. </span><span class="koboSpan" id="kobo.823.3">Along with the slowdown, TSan also increases memory usage, generally by about 5x-10x. </span><span class="koboSpan" id="kobo.823.4">This overhead arises from the additional data structures TSan uses to monitor thread interactions and identify potential </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">race conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.825.1">This list outlines the</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.826.1"> limitations and current state </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">of TSan:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.828.1">Beta stage</span></strong><span class="koboSpan" id="kobo.829.1">: TSan is currently in the beta stage. </span><span class="koboSpan" id="kobo.829.2">While it has been effective in large C++ programs using pthreads, there is no guarantee of its effectiveness for </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">every scenario.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.831.1">Supported threading models</span></strong><span class="koboSpan" id="kobo.832.1">: TSan supports C++11 threading when compiled with llvm’s libc++. </span><span class="koboSpan" id="kobo.832.2">This compatibility includes the threading features introduced with the </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">C++11 standard.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.834.1">TSan is supported by several operating systems </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">and architectures:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.836.1">Android</span></strong><span class="koboSpan" id="kobo.837.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">aarch64, x86_64</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.839.1">Darwin (macOS)</span></strong><span class="koboSpan" id="kobo.840.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">arm64, x86_64</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.842.1">FreeBSD</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.843.1">Linux</span></strong><span class="koboSpan" id="kobo.844.1">: aarch64, x86_64, </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">powerpc64, powerpc64le</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.846.1">NetBSD</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.847.1">Support is mainly </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.848.1">focused on 64-bit architectures. </span><span class="koboSpan" id="kobo.848.2">The support for 32-bit platforms is problematic and </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">not planned.</span></span></p>
<h3><span class="koboSpan" id="kobo.850.1">Fine-tuning TSan</span></h3>
<p><span class="koboSpan" id="kobo.851.1">The</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.852.1"> fine-tuning of TSan is very similar to that of ASan. </span><span class="koboSpan" id="kobo.852.2">Users interested in detailed fine-tuning options can refer to the official documentation, which provides comprehensive guidance on customizing TSan’s behavior to suit specific needs </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">and scenarios.</span></span></p>
<h3><span class="koboSpan" id="kobo.854.1">Recommendations for using TSan</span></h3>
<p><span class="koboSpan" id="kobo.855.1">Due to the</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.856.1"> overhead in performance and memory, TSan is ideally used during the development and testing phases of a project. </span><span class="koboSpan" id="kobo.856.2">Its use in production environments should be carefully evaluated against the performance requirements. </span><span class="koboSpan" id="kobo.856.3">TSan is particularly useful in projects with significant multithreaded components, where the likelihood of data races and </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.857.1">threading issues is higher. </span><span class="koboSpan" id="kobo.857.2">Incorporating TSan into </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">continuous integration</span></strong><span class="koboSpan" id="kobo.859.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.860.1">CI</span></strong><span class="koboSpan" id="kobo.861.1">) pipelines can help catch threading issues early in the development cycle, reducing the risk of these bugs making it </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">into production.</span></span></p>
<p><span class="koboSpan" id="kobo.863.1">TSan is a critical tool for developers dealing with the complexities of concurrency in C++. </span><span class="koboSpan" id="kobo.863.2">It provides an invaluable service in detecting elusive threading issues that traditional testing methods often miss. </span><span class="koboSpan" id="kobo.863.3">By integrating TSan into the development and testing process, developers can significantly enhance the reliability and stability of their multithreaded </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">C++ applications.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.865.1">UBSan</span></h2>
<p><span class="koboSpan" id="kobo.866.1">UBSan is</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.867.1"> a dynamic analysis tool designed to detect undefined behavior in C++ programs. </span><span class="koboSpan" id="kobo.867.2">Undefined behavior, as defined by the C++ standard, refers to code whose behavior is not prescribed, leading to unpredictable program execution. </span><span class="koboSpan" id="kobo.867.3">This can include issues such as integer overflow, division by zero, or misuse of null pointers. </span><span class="koboSpan" id="kobo.867.4">Undefined behavior can cause erratic program behavior, crashes, and security vulnerabilities. </span><span class="koboSpan" id="kobo.867.5">However, it is often used by compiler developers to optimize code. </span><span class="koboSpan" id="kobo.867.6">UBSan is crucial for identifying these problems, which are often subtle and hard to detect through standard testing but can cause significant issues in software reliability </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">and security.</span></span></p>
<h3><span class="koboSpan" id="kobo.869.1">Configuring UBSan</span></h3>
<p><span class="koboSpan" id="kobo.870.1">To use</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.871.1"> UBSan, compile your program with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">-fsanitize=undefined</span></strong><span class="koboSpan" id="kobo.873.1"> flag. </span><span class="koboSpan" id="kobo.873.2">This instructs the compiler to instrument the code with checks for various forms of undefined behavior. </span><span class="koboSpan" id="kobo.873.3">These commands compile the program with UBSan enabled using either Clang </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">or GCC.</span></span></p>
<h3><span class="koboSpan" id="kobo.875.1">Example code demonstrating undefined behavior</span></h3>
<p><span class="koboSpan" id="kobo.876.1">Consider </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.877.1">this </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.879.1">
#include &lt;iostream&gt;
int main() {
    int x = 0;
    std::cout &lt;&lt; 10 / x &lt;&lt; std::endl;  // Division by zero, undefined behavior
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.880.1">In this code, attempting to divide by zero (</span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">10 / x</span></strong><span class="koboSpan" id="kobo.882.1">) is an instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">undefined behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">When compiled and run with UBSan, the output might include something </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.886.1">
/home/user/clang-sanitizers/main.cpp:5:21: runtime error: division by zero
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/user/clang-sanitizers/main.cpp:5:21 in
0</span></pre>
<p><span class="koboSpan" id="kobo.887.1">UBSan detects the division by zero and reports the exact location in the code where </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">this occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">Fine-tuning, performance impact, </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">and limitations</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.891.1">Fine-tuning</span></strong><span class="koboSpan" id="kobo.892.1">: UBSan </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.893.1">provides various options to control its behavior, allowing developers to focus on specific kinds of undefined behavior. </span><span class="koboSpan" id="kobo.893.2">Users interested in detailed customization can refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">official documentation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.895.1">Performance impact</span></strong><span class="koboSpan" id="kobo.896.1">: The</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.897.1"> runtime performance impact of UBSan is generally lower compared to tools such as ASan and TSan, but it can vary depending on the types of checks enabled. </span><span class="koboSpan" id="kobo.897.2">A typical slowdown is </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">usually minimal.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.899.1">Supported platforms</span></strong><span class="koboSpan" id="kobo.900.1">: UBSan </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.901.1">is supported on major platforms such as Linux, macOS, and Windows, making it widely accessible for </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">C++ developers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.903.1">Limitations</span></strong><span class="koboSpan" id="kobo.904.1">: While</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.905.1"> UBSan is powerful in detecting undefined behavior, it cannot catch every instance, especially those that are highly dependent on specific program states or </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">hardware configurations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.907.1">UBSan is an invaluable tool for C++ developers, aiding in the early detection of subtle yet critical issues that can lead to unstable and insecure software. </span><span class="koboSpan" id="kobo.907.2">Its integration into the development and testing process is a proactive step towards ensuring the robustness and reliability of C++ applications. </span><span class="koboSpan" id="kobo.907.3">With its minimal performance impact and broad platform support, UBSan is a practical addition to any C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">developer’s toolkit.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.909.1">Dynamic code analysis with Valgrind</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.910.1">Valgrind</span></strong><span class="koboSpan" id="kobo.911.1"> is a</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.912.1"> powerful tool for memory debugging, memory leak detection, and profiling. </span><span class="koboSpan" id="kobo.912.2">It is instrumental in identifying issues such as memory mismanagement and access errors, which </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.913.1">are common in complex C++ programs. </span><span class="koboSpan" id="kobo.913.2">Unlike</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.914.1"> compiler-based tools such as Sanitizers, Valgrind works by running the program in a virtual-machine-like environment, checking for </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">memory-related errors.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.916.1">Setting up Valgrind</span></h2>
<p><span class="koboSpan" id="kobo.917.1">Valgrind can</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.918.1"> typically be installed from your system’s package manager. </span><span class="koboSpan" id="kobo.918.2">For example, on Ubuntu, you can install it using </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">sudo apt-get install valgrind</span></strong><span class="koboSpan" id="kobo.920.1">. </span><span class="koboSpan" id="kobo.920.2">To run a program under Valgrind, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">valgrind ./your_program</span></strong><span class="koboSpan" id="kobo.922.1"> command. </span><span class="koboSpan" id="kobo.922.2">This command executes your program within the Valgrind environment, where it performs its analysis. </span><span class="koboSpan" id="kobo.922.3">No special compilation flags are needed for basic memory checking with Valgrind, but including debugging symbols with </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">-g</span></strong><span class="koboSpan" id="kobo.924.1"> can help make its output </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">more useful.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.926.1">Memcheck – the comprehensive memory debugger</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.927.1">Memcheck</span></strong><span class="koboSpan" id="kobo.928.1">, the</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.929.1"> core tool </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.930.1">of the Valgrind suite, is a sophisticated memory debugger for C++ applications. </span><span class="koboSpan" id="kobo.930.2">It combines the functionality of address, memory, and LSans, providing a comprehensive analysis of memory usage. </span><span class="koboSpan" id="kobo.930.3">Memcheck detects memory-related errors such as the use of uninitialized memory, improper use of memory allocation and deallocation functions, and </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">memory leaks.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">To use </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.933.1">Memcheck, no special compilation flags are needed, but compiling with debugging information (using </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">-g</span></strong><span class="koboSpan" id="kobo.935.1">) can enhance the usefulness of Memcheck’s reports. </span><span class="koboSpan" id="kobo.935.2">Execute your program with Valgrind by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">valgrind ./your_program</span></strong><span class="koboSpan" id="kobo.937.1"> command. </span><span class="koboSpan" id="kobo.937.2">For detecting memory leaks, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">--leak-check=full</span></strong><span class="koboSpan" id="kobo.939.1"> for more detailed information. </span><span class="koboSpan" id="kobo.939.2">Here is an </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">example command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.941.1">
valgrind --leak-check=full ./your_program</span></pre>
<p><span class="koboSpan" id="kobo.942.1">Since Memcheck covers a wide range of memory-related issues, I am going to show only an example of detecting a memory leak since they are often the hardest to detect. </span><span class="koboSpan" id="kobo.942.2">Let us consider the following C++ code with a </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">memory leak:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.944.1">
int main() {
    int* ptr = new int(10); // Memory allocated but not freed
    return 0; // Memory leak occurs here
}</span></pre>
<p><span class="koboSpan" id="kobo.945.1">Memcheck will detect and report the memory leak, indicating where the memory was allocated and that it was </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">not freed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.947.1">
==12345== Memcheck, a memory error detector
==12345== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x...: operator new(unsigned long) (vg_replace_malloc.c:...)
==12345==    by 0x...: main (your_file.cpp:2)
...
</span><span class="koboSpan" id="kobo.947.2">==12345== LEAK SUMMARY:
==12345==    definitely lost: 4 bytes in 1 blocks
...</span></pre>
<p><span class="koboSpan" id="kobo.948.1">Performance impact, fine-tuning, </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">and limitations</span></span></p>
<p><span class="koboSpan" id="kobo.950.1">It is important</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.951.1"> to remember that Memcheck can significantly slow down program execution, often by 10-30 times, and increase memory usage. </span><span class="koboSpan" id="kobo.951.2">This is due to the extensive checks performed on each </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">memory operation.</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">Memcheck offers several options to control its behavior. </span><span class="koboSpan" id="kobo.953.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">--track-origins=yes</span></strong><span class="koboSpan" id="kobo.955.1"> can help find the sources of uninitialized memory use, although it may further slow down </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">the analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.957.1">The main limitation of Memcheck is its performance overhead, which makes it unsuitable for production environments. </span><span class="koboSpan" id="kobo.957.2">Additionally, while it is thorough in memory leak detection, it may not catch every instance of uninitialized memory use, especially in complex scenarios or when specific compiler optimizations </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">are applied.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">Memcheck stands as a vital tool in the C++ developer’s toolkit for memory debugging. </span><span class="koboSpan" id="kobo.959.2">By providing a detailed analysis of memory errors and leaks, it plays a critical role in enhancing the reliability and correctness of C++ applications. </span><span class="koboSpan" id="kobo.959.3">Despite its performance overhead, Memcheck’s benefits in identifying and resolving memory issues make it indispensable for the development and testing phases of </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">software development.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.961.1">Helgrind – threading error detector</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.962.1">Helgrind</span></strong><span class="koboSpan" id="kobo.963.1"> is a tool </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.964.1">within the Valgrind suite, specifically designed to detect synchronization</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.965.1"> errors in C++ multithreaded applications. </span><span class="koboSpan" id="kobo.965.2">It focuses on identifying race conditions, deadlocks, and </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.966.1">misuses of the pthreads API. </span><span class="koboSpan" id="kobo.966.2">Helgrind operates by monitoring the interactions between threads, ensuring that shared resources are accessed safely and correctly. </span><span class="koboSpan" id="kobo.966.3">Its ability to detect threading errors makes it comparable to TSan but with a different underlying approach </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">and usage.</span></span></p>
<p><span class="koboSpan" id="kobo.968.1">To use</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.969.1"> Helgrind, you do not need to recompile your program with special flags (although compiling with </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">-g</span></strong><span class="koboSpan" id="kobo.971.1"> to include debugging symbols is recommended). </span><span class="koboSpan" id="kobo.971.2">Run your program with Valgrind using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">--tool=helgrind</span></strong><span class="koboSpan" id="kobo.973.1"> option. </span><span class="koboSpan" id="kobo.973.2">Here is an </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">example command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.975.1">
valgrind --tool=helgrind ./your_program</span></pre>
<p><span class="koboSpan" id="kobo.976.1">Let us consider the data race example that we analyzed before </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">with TSan:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
int shared_counter = 0;
void increment_counter() {
    for (int i = 0; i &lt; 10000; ++i) {
        shared_counter++; // Potential data race
    }
}
int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);
    t1.join();
    t2.join();
    std::cout &lt;&lt; “Shared counter: “ &lt;&lt; shared_counter &lt;&lt; std::endl;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.979.1">Helgrind </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.980.1">will detect and report the data race, showing where the threads are concurrently modifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">shared_counter</span></strong><span class="koboSpan" id="kobo.982.1"> without proper synchronization. </span><span class="koboSpan" id="kobo.982.2">In addition to identifying data races, Helgrind’s output contains thread creation announcements, stack traces, and </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">other details:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.984.1">
valgrind --tool=helgrind ./a.out
==178401== Helgrind, a thread error detector
==178401== Copyright (C) 2007-2017, and GNU GPL’d, by OpenWorks LLP et al.
</span><span class="koboSpan" id="kobo.984.2">==178401== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==178401== Command: ./a.out
==178401== ---Thread-Announcement------------------------------------------
==178401==
==178401== Thread #3 was created
==178401==    at 0x4CCE9F3: clone (clone.S:76)
==178401==    by 0x4CCF8EE: __clone_internal (clone-internal.c:83)
==178401==    by 0x4C3D6D8: create_thread (pthread_create.c:295)
==178401==    by 0x4C3E1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==178401==    by 0x4853767: ??? </span><span class="koboSpan" id="kobo.984.3">(in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==178401==    by 0x4952328: std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30)
==178401==    by 0x1093F9: std::thread::thread&lt;void (&amp;)(), , void&gt;(void (&amp;)()) (std_thread.h:143)
==178401==    by 0x1092AF: main (main.cpp:14)
==178401==
==178401== ---Thread-Announcement------------------------------------------
==178401==
==178401== Thread #2 was created
==178401== ----------------------------------------------------------------
==178401==
==178401== Possible data race during read of size 4 at 0x10C0A0 by thread #3
==178401== Locks held: none
==178401==    at 0x109258: increment_counter() (main.cpp:8)
==178401==    by 0x109866: void std::__invoke_impl&lt;void, void (*)()&gt;(std::__invoke_other, void (*&amp;&amp;)()) (invoke.h:61)
==178401==    by 0x1097FC: std::__invoke_result&lt;void (*)()&gt;::type std::__invoke&lt;void (*)()&gt;(void (*&amp;&amp;)()) (invoke.h:96)
==178401==    by 0x1097D4: void std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) (std_thread.h:259)
==178401==    by 0x1097A4: std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator()() (std_thread.h:266)
==178401==    by 0x1096F8: std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run() (std_thread.h:211)
==178401==    by 0x4952252: ??? </span><span class="koboSpan" id="kobo.984.4">(in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30)
==178401==    by 0x485396A: ??? </span><span class="koboSpan" id="kobo.984.5">(in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==178401==    by 0x4C3DAC2: start_thread (pthread_create.c:442)
==178401==    by 0x4CCEA03: clone (clone.S:100)
==178401==
==178401== This conflicts with a previous write of size 4 by thread #2
==178401== Locks held: none
==178401==    at 0x109261: increment_counter() (main.cpp:8)
==178401==    by 0x109866: void std::__invoke_impl&lt;void, void (*)()&gt;(std::__invoke_other, void (*&amp;&amp;)()) (invoke.h:61)
==178401==    by 0x1097FC: std::__invoke_result&lt;void (*)()&gt;::type std::__invoke&lt;void (*)()&gt;(void (*&amp;&amp;)()) (invoke.h:96)
==178401==    by 0x1097D4: void std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) (std_thread.h:259)
==178401==    by 0x1097A4: std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator()() (std_thread.h:266)
==178401==    by 0x1096F8: std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run() (std_thread.h:211)
==178401==    by 0x4952252: ??? </span><span class="koboSpan" id="kobo.984.6">(in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30)
==178401==    by 0x485396A: ??? </span><span class="koboSpan" id="kobo.984.7">(in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==178401==  Address 0x10c0a0 is 0 bytes inside data symbol “shared_counter”
==178401==
Shared counter: 20000
==178401==
==178401== Use --history-level=approx or =none to gain increased speed, at
==178401== the cost of reduced accuracy of conflicting-access information
==178401== For lists of detected and suppressed errors, rerun with: -s
==178401== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)`</span></pre>
<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.985.1">Performance impact, fine-tuning, and limitations</span></h2>
<p><span class="koboSpan" id="kobo.986.1">Using </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.987.1">Helgrind can slow down your program execution significantly (often by 20x or more) due to the detailed analysis of threading interactions. </span><span class="koboSpan" id="kobo.987.2">This makes it most suitable for testing environments. </span><span class="koboSpan" id="kobo.987.3">Helgrind provides several options to customize its behavior, such </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.988.1">as controlling the level of checking or ignoring certain errors. </span><span class="koboSpan" id="kobo.988.2">The</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.989.1"> primary limitation is the performance overhead, making it impractical for use in production. </span><span class="koboSpan" id="kobo.989.2">Additionally, Helgrind may produce false positives, especially in complex threading scenarios or when using advanced synchronization primitives not fully understood </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">by Helgrind.</span></span></p>
<p><span class="koboSpan" id="kobo.991.1">Helgrind is an essential tool for developers working with multithreaded C++ applications, providing insights into challenging concurrency problems. </span><span class="koboSpan" id="kobo.991.2">It aids in creating more reliable and thread-safe applications by detecting and helping to resolve complex synchronization issues. </span><span class="koboSpan" id="kobo.991.3">While its use may be limited to development and testing phases due to performance overhead, the benefits it offers in enhancing the correctness of multithreaded code </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">are invaluable.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.993.1">Other notable tools in the Valgrind suite</span></h1>
<p><span class="koboSpan" id="kobo.994.1">In addition to Helgrind, the Valgrind suite includes several other tools, each with distinct functionalities catering to different aspects of program analysis and </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">performance profiling.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.996.1">Data Race Detector (DRD) – a thread error detector</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.997.1">DRD</span></strong><span class="koboSpan" id="kobo.998.1"> is </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.999.1">another tool for detecting thread errors, similar to Helgrind. </span><span class="koboSpan" id="kobo.999.2">It</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.1000.1"> focuses specifically on identifying data races in multithreaded programs. </span><span class="koboSpan" id="kobo.1000.2">While both Helgrind and DRD are designed to detect threading issues, DRD is more optimized for detecting data races and generally has a lower performance overhead compared to Helgrind. </span><span class="koboSpan" id="kobo.1000.3">DRD might produce fewer false positives in certain scenarios but may not be as thorough as Helgrind in detecting all kinds of </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">synchronization errors.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.1002.1">Cachegrind</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1003.1">Cachegrind</span></strong><span class="koboSpan" id="kobo.1004.1"> is a cache and</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.1005.1"> branch-prediction profiler. </span><span class="koboSpan" id="kobo.1005.2">It provides detailed information </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.1006.1">about how your program interacts with the computer’s cache hierarchy and the efficiency of branch prediction. </span><span class="koboSpan" id="kobo.1006.2">This tool is invaluable for optimizing program performance, particularly in CPU-bound applications. </span><span class="koboSpan" id="kobo.1006.3">It helps identify inefficient memory access patterns and areas of code that can benefit from optimization to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">cache utilization.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.1008.1">Callgrind</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1009.1">Callgrind</span></strong><span class="koboSpan" id="kobo.1010.1"> extends </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.1011.1">the functionality of Cachegrind by adding call-graph generation</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.1012.1"> capabilities. </span><span class="koboSpan" id="kobo.1012.2">It records the call history among functions in a program, allowing developers to analyze the execution flow and identify performance bottlenecks. </span><span class="koboSpan" id="kobo.1012.3">Callgrind is particularly useful for understanding the overall structure and interactions in </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">complex applications.</span></span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.1014.1">Massif</span></h2>
<p><span class="koboSpan" id="kobo.1015.1">Massif is</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.1016.1"> a heap profiler that provides insights into a program’s memory usage. </span><span class="koboSpan" id="kobo.1016.2">It </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.1017.1">helps developers understand and optimize memory consumption, track down memory leaks, and identify where and how memory allocation occurs within </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">a program.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.1019.1">Dynamic heap analysis tool (DHAT)</span></h2>
<p><span class="koboSpan" id="kobo.1020.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">DHAT</span></strong><span class="koboSpan" id="kobo.1022.1"> is focused on</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.1023.1"> profiling heap allocation patterns. </span><span class="koboSpan" id="kobo.1023.2">It’s particularly useful for finding inefficient use of heap memory, such as excessive small allocations or short-lived allocations that could </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">be optimized.</span></span></p>
<p><span class="koboSpan" id="kobo.1025.1">Each tool in</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.1026.1"> the Valgrind suite offers unique capabilities for analyzing different aspects of program performance and behavior. </span><span class="koboSpan" id="kobo.1026.2">From threading issues to memory usage and CPU optimization, these tools provide a comprehensive set of functionalities for enhancing the efficiency, reliability, and correctness of C++ applications. </span><span class="koboSpan" id="kobo.1026.3">Their integration into the development and testing process allows developers to gain deep insights into their code, leading to well-optimized and robust </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">software solutions.</span></span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.1028.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1029.1">Compiler-based sanitizers and Valgrind bring distinct advantages and challenges to the debugging and </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">profiling process.</span></span></p>
<p><span class="koboSpan" id="kobo.1031.1">Compiler-based tools such as ASan, TSan, and UBSan are generally more accessible and easier to integrate into the development workflow. </span><span class="koboSpan" id="kobo.1031.2">They are “cheaper” in terms of the performance overhead they introduce and are relatively straightforward to configure and use. </span><span class="koboSpan" id="kobo.1031.3">These sanitizers are integrated directly into the compilation process, making them convenient for developers to employ regularly. </span><span class="koboSpan" id="kobo.1031.4">Their primary advantage lies in their ability to provide immediate feedback during the development phase, catching errors and issues as the code is being written and tested. </span><span class="koboSpan" id="kobo.1031.5">However, since these tools perform analysis during runtime, their effectiveness is directly tied to the extent of the test coverage. </span><span class="koboSpan" id="kobo.1031.6">The more comprehensive the tests, the more effective the dynamic analysis, as only the executed code paths are analyzed. </span><span class="koboSpan" id="kobo.1031.7">This aspect highlights the importance of thorough testing: the better the test coverage, the more issues these tools can </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">potentially uncover.</span></span></p>
<p><span class="koboSpan" id="kobo.1033.1">Valgrind, on the other hand, offers a more powerful and thorough analysis, capable of detecting a wider range of issues, particularly in memory management and threading. </span><span class="koboSpan" id="kobo.1033.2">Its suite of tools – Memcheck, Helgrind, DRD, Cachegrind, Callgrind, Massif, and DHAT – provides a comprehensive analysis of various aspects of program performance and behavior. </span><span class="koboSpan" id="kobo.1033.3">However, this power comes with a cost: Valgrind is generally more complex to use and introduces a significant performance overhead compared to compiler-based tools. </span><span class="koboSpan" id="kobo.1033.4">The choice of whether to use Valgrind or a compiler-based sanitizer often depends on the specific needs of the project and the issues being targeted. </span><span class="koboSpan" id="kobo.1033.5">While Valgrind’s extensive diagnostics offer deep insights into the program, the ease of use and lower performance cost of compiler-based sanitizers make them more suitable for regular use in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">CI pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.1035.1">In summary, while both compiler-based tools and Valgrind have their place in the dynamic analysis landscape, their differences in diagnostics, ease of use, and performance impact make them suited to different stages and aspects of the software development process. </span><span class="koboSpan" id="kobo.1035.2">Employing these tools as part of a regular CI pipeline is highly recommended, as it allows for the early detection and resolution of issues, contributing significantly to the overall quality and robustness of the software. </span><span class="koboSpan" id="kobo.1035.3">The subsequent chapter will delve into tools for measuring test coverage, providing insights into how effectively the code base is being tested and thus complementing the dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">analysis process.</span></span></p>
</div>
</body></html>