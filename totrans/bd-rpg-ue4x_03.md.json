["```cpp\nUCLASS(config = Game)\nclass ARPGCharacter : public ACharacter\n{\n  GENERATED_BODY()\n\n  /** Camera boom positioning the camera behind the character */\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\")) class USpringArmComponent* CameraBoom;\n\n  /** Follow camera */\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\")) class UCameraComponent* FollowCamera;\npublic:\n  ARPGCharacter();\n\n  /**Base turn rate, in deg/sec. Other scaling may affect final turn rate.*/\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera)\n    float BaseTurnRate;\n\nprotected:\n\n  /** Called for forwards/backward input */\n  void MoveForward(float Value);\n\n  /** Called for side to side input */\n  void MoveRight(float Value);\n\n  /**\n  * Called via input to turn at a given rate.\n  * @param Rate  This is a normalized rate, i.e. 1.0 means 100% of desired turn rate\n  */\n  void TurnAtRate(float Rate);\n\nprotected:\n  // APawn interface\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n  // End of APawn interface\n\npublic:\n  /** Returns CameraBoom subobject **/\nFORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }\n  /** Returns FollowCamera subobject **/\nFORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"RPGCharacter.h\"\n\nARPGCharacter::ARPGCharacter()\n{\n  // Set size for collision capsule\n  GetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\n  // set our turn rates for input\n  BaseTurnRate = 45.f;\n\n// Don't rotate when the controller rotates. //Let that just affect the camera.\n  bUseControllerRotationPitch = false;\n  bUseControllerRotationYaw = false;\n  bUseControllerRotationRoll = false;\n\n  // Configure character movement\n// Character moves in the direction of input...\nGetCharacterMovement()->bOrientRotationToMovement = true; // ...at this rotation rate  \nGetCharacterMovement()->RotationRate = FRotator(0.0f, 540.0f, 0.0f); \n\n  // Create a camera boom\nCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n  CameraBoom->SetupAttachment(RootComponent);\n// The camera follows at this distance behind the character  CameraBoom->TargetArmLength = 300.0f; \nCameraBoom->RelativeLocation = FVector(0.f, 0.f, 500.f);// Rotate the arm based on the controller\nCameraBoom->bUsePawnControlRotation = true; \n\n// Create a follow camera\nFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\nFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Camera does not rotate relative to arm\nFollowCamera->bUsePawnControlRotation = false;  FollowCamera->RelativeRotation = FRotator(-45.f, 0.f, 0.f);\n\n/* Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) are set in the derived blueprint asset named MyCharacter (to avoid direct content references in C++)*/\n}\n\n//////////////////////////////////////////////////////////////////\n// Input\n\nvoid ARPGCharacter::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\n  // Set up gameplay key bindings\n  check(InputComponent);\n\nInputComponent->BindAxis(\"MoveForward\", this, &ARPGCharacter::MoveForward);\nInputComponent->BindAxis(\"MoveRight\", this, &ARPGCharacter::MoveRight);\n\n/* We have 2 versions of the rotation bindings to handle different kinds of devices differently \"turn\" handles devices that provide an absolute delta, such as a mouse. \"turnrate\" is for devices that we choose to treat as a rate of change, such as an analog joystick*/\nInputComponent->BindAxis(\"Turn\", this, &APawn::AddControllerYawInput);\nInputComponent->BindAxis(\"TurnRate\", this, &ARPGCharacter::TurnAtRate);\n}\n\nvoid ARPGCharacter::TurnAtRate(float Rate)\n{\n  // calculate delta for this frame from the rate information\nAddControllerYawInput(Rate * BaseTurnRate * GetWorld()->GetDeltaSeconds());\n}\n\nvoid ARPGCharacter::MoveForward(float Value)\n{\n  if ((Controller != NULL) && (Value != 0.0f))\n  {\n    // find out which way is forward\n    const FRotator Rotation = Controller->GetControlRotation();\n    const FRotator YawRotation(0, Rotation.Yaw, 0);\n\n    // get forward vector\n    const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n    AddMovementInput(Direction, Value);\n  }\n}\n\nvoid ARPGCharacter::MoveRight(float Value)\n{\n  if ((Controller != NULL) && (Value != 0.0f))\n  {\n    // find out which way is right\n    const FRotator Rotation = Controller->GetControlRotation();\n    const FRotator YawRotation(0, Rotation.Yaw, 0);\n\n    // get right vector \n    const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n    // add movement in that direction\n    AddMovementInput(Direction, Value);\n  }\n}\n```", "```cpp\nUCLASS()\nclass RPG_API ARPGGameMode : public AGameMode\n{\n  GENERATED_BODY()\n\n  ARPGGameMode( const class FObjectInitializer& ObjectInitializer );\n};\n```", "```cpp\n#include \"RPGCharacter.h\"\n\nARPGGameMode::ARPGGameMode( const class FObjectInitializer& ObjectInitializer )\n  : Super( ObjectInitializer )\n{\n\n  DefaultPawnClass = ARPGCharacter::StaticClass();\n}\n```", "```cpp\nUSTRUCT( BlueprintType )\nstruct FCharacterClassInfo : public FTableRowBase\n{\n  GENERATED_USTRUCT_BODY()\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    FString Class_Name;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 StartMHP;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 StartMMP;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 StartATK;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 StartDEF;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 StartLuck;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 EndMHP;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 EndMMP;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 EndATK;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 EndDEF;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    int32 EndLuck;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    TArray<FString> StartingAbilities;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    TArray<FString> LearnedAbilities;\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"ClassInfo\" )\n    TArray<int32> LearnedAbilityLevels;\n};\n```", "```cpp\nUSTRUCT(BlueprintType)\nstruct FCharacterInfo : public FTableRowBase\n{\n  GENERATED_USTRUCT_BODY()\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"CharacterInfo\" )\n  FString Character_Name;\n\n  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = \"CharacterInfo\" )\n  FString Class_ID;\n};\n```", "```cpp\nUSTRUCT( BlueprintType )\nstruct FEnemyInfo : public FTableRowBase\n{\n  GENERATED_USTRUCT_BODY()\n\n  UPROPERTY( BlueprintReadWrite, EditAnywhere, Category = \"EnemyInfo\" )\n    FString EnemyName;\n\n  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = \"EnemyInfo\" )\n    int32 MHP;\n\n  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = \"EnemyInfo\" )\n    int32 ATK;\n\n  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = \"EnemyInfo\" )\n    int32 DEF;\n\n  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = \"EnemyInfo\" )\n    int32 Luck;\n\n  UPROPERTY( BlueprintReadOnly, EditAnywhere, Category = \"EnemyInfo\" )\n    TArray<FString> Abilities;\n};\n```", "```cpp\n#pragma once\n\n#include \"Data/FCharacterInfo.h\"\n#include \"Data/FCharacterClassInfo.h\"\n\n#include \"GameCharacter.generated.h\"\n\nUCLASS( BlueprintType )\nclass RPG_API UGameCharacter : public UObject\n{\n  GENERATED_BODY()\n\npublic:\n  FCharacterClassInfo* ClassInfo;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  FString CharacterName;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 MHP;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 MMP;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 HP;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 MP;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 ATK;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 DEF;\n\n  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = CharacterInfo )\n  int32 LUCK;\n\npublic:\n  static UGameCharacter* CreateGameCharacter( FCharacterInfo* characterInfo, UObject* outer );\n\npublic:\n  void BeginDestroy() override;\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"GameCharacter.h\"\n\nUGameCharacter* UGameCharacter::CreateGameCharacter( FCharacterInfo* characterInfo, UObject* outer )\n{\n  UGameCharacter* character = NewObject<UGameCharacter>( outer );\n\n  // locate character classes asset\n  UDataTable* characterClasses = Cast<UDataTable>( StaticLoadObject( UDataTable::StaticClass(), NULL, TEXT( \"DataTable'/Game/Data/CharacterClasses.CharacterClasses'\" ) ) );\n\n  if( characterClasses == NULL )\n  {\n    UE_LOG( LogTemp, Error, TEXT( \"Character classes datatable not found!\" ) );\n  }\n  else\n  {\n    character->CharacterName = characterInfo->Character_Name;\n    FCharacterClassInfo* row = characterClasses->FindRow<FCharacterClassInfo>( *( characterInfo->Class_ID ), TEXT( \"LookupCharacterClass\" ) );\n    character->ClassInfo = row;\n\n    character->MHP = character->ClassInfo->StartMHP;\n    character->MMP = character->ClassInfo->StartMMP;\n    character->HP = character->MHP;\n    character->MP = character->MMP;\n\n    character->ATK = character->ClassInfo->StartATK;\n    character->DEF = character->ClassInfo->StartDEF;\n    character->LUCK = character->ClassInfo->StartLuck;\n  }\n\n  return character;\n}\n\nvoid UGameCharacter::BeginDestroy()\n{\n  Super::BeginDestroy();\n}\n```", "```cpp\n#pragma once\n\n#include \"Engine/GameInstance.h\"\n#include \"GameCharacter.h\"\n#include \"RPGGameInstance.generated.h\"\nUCLASS()\nclass RPG_API URPGGameInstance : public UGameInstance\n{\n  GENERATED_BODY()\n\n  URPGGameInstance( const class FObjectInitializer& ObjectInitializer );\n\npublic:\n  TArray<UGameCharacter*> PartyMembers;\n\nprotected:\n  bool isInitialized;\n\npublic:\n  void Init();\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"RPGGameInstance.h\"\nURPGGameInstance::URPGGameInstance(const class FObjectInitializer& \nObjectInitializer)\n: Super(ObjectInitializer)\n{\n  isInitialized = false;\n}\n\nvoid URPGGameInstance::Init()\n{\n  if( this->isInitialized ) return;\n\n  this->isInitialized = true;\n\n  // locate characters asset\n  UDataTable* characters = Cast<UDataTable>( StaticLoadObject( UDataTable::StaticClass(), NULL, \nTEXT( \"DataTable'/Game/Data/Characters.Characters'\" ) ) );\n        if( characters == NULL )\n  {\n    UE_LOG( LogTemp, Error, TEXT( \"Characters data table not found!\" ) );\n\n    return;\n  }\n\n  // locate character\n  FCharacterInfo* row = characters->FindRow<FCharacterInfo>( TEXT( \"S1\" ), TEXT( \"LookupCharacterClass\" ) );\n\n  if( row == NULL )\n  {\n    UE_LOG( LogTemp, Error, TEXT( \"Character ID 'S1' not found!\" ) );\n    return;\n  }\n\n  // add character to party\n  this->PartyMembers.Add( UGameCharacter::CreateGameCharacter( row, this ) );\n}\n```", "```cpp\n#pragma once\n\n#include \"GameFramework/GameMode.h\"\n#include \"RPGGameMode.generated.h\"\n\nUCLASS()\nclass RPG_API ARPGGameMode : public AGameMode\n{\n  GENERATED_BODY()\n\n  ARPGGameMode(const class FObjectInitializer& ObjectInitializer);\n  virtual void BeginPlay() override;\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"RPGGameMode.h\"\n#include \"RPGCharacter.h\"\n#include \"RPGGameInstance.h\"\n\nARPGGameMode::ARPGGameMode(const class FObjectInitializer& \nObjectInitializer)\n: Super(ObjectInitializer)\n{\n  DefaultPawnClass = ARPGCharacter::StaticClass();\n   }\n\nvoid ARPGGameMode::BeginPlay()\n{\n  Cast<URPGGameInstance>(GetGameInstance())->Init();\n}\n```", "```cpp\n#pragma once\n#include \"RPG.h\"\n#include \"GameCharacter.h\"\n\nenum class CombatPhase : uint8\n{\n  CPHASE_Decision,\n  CPHASE_Action,\n  CPHASE_Victory,\n  CPHASE_GameOver,\n};\n\nclass RPG_API CombatEngine\n{\npublic:\n  TArray<UGameCharacter*> combatantOrder;\n  TArray<UGameCharacter*> playerParty;\n  TArray<UGameCharacter*> enemyParty;\n\n  CombatPhase phase;\n\nprotected:\n  UGameCharacter* currentTickTarget;\n  int tickTargetIndex;\n\npublic:\n  CombatEngine( TArray<UGameCharacter*> playerParty, TArray<UGameCharacter*> enemyParty );\n  ~CombatEngine();\n\n  bool Tick( float DeltaSeconds );\n\nprotected:\n  void SetPhase( CombatPhase phase );\n  void SelectNextCharacter();\n};\n```", "```cpp\nCombatEngine::CombatEngine( TArray<UGameCharacter*> playerParty, TArray<UGameCharacter*> enemyParty )\n{\n  this->playerParty = playerParty;\n  this->enemyParty = enemyParty;\n\n  // first add all players to combat order\n  for( int i = 0; i < playerParty.Num(); i++ )\n  {\n    this->combatantOrder.Add( playerParty[i] );\n  }\n\n  // next add all enemies to combat order\n  for( int i = 0; i < enemyParty.Num(); i++ )\n  {\n    this->combatantOrder.Add( enemyParty[i] );\n  }\n\n  this->tickTargetIndex = 0;\n  this->SetPhase( CombatPhase::CPHASE_Decision );\n}\n\nCombatEngine::~CombatEngine()\n{\n}\n```", "```cpp\nbool CombatEngine::Tick( float DeltaSeconds )\n{\n  switch( phase )\n  {\n    case CombatPhase::CPHASE_Decision:\n      // todo: ask current character to make decision\n\n      // todo: if decision made\n      SelectNextCharacter();\n\n      // no next character, switch to action phase\n      if( this->tickTargetIndex == -1 )\n      {\n        this->SetPhase( CombatPhase::CPHASE_Action );\n      }\n      break;\n    case CombatPhase::CPHASE_Action:\n      // todo: ask current character to execute decision\n\n      // todo: when action executed\n      SelectNextCharacter();\n\n      // no next character, loop back to decision phase\n      if( this->tickTargetIndex == -1 )\n      {\n        this->SetPhase( CombatPhase::CPHASE_Decision );\n      }\n      break;\n    // in case of victory or combat, return true (combat is finished)\n    case CombatPhase::CPHASE_GameOver:\n    case CombatPhase::CPHASE_Victory:\n      return true;\n      break;\n  }\n\n  // check for game over\n  int deadCount = 0;\n  for( int i = 0; i < this->playerParty.Num(); i++ )\n  {\n    if( this->playerParty[ i ]->HP <= 0 ) deadCount++;\n  }\n\n  // all players have died, switch to game over phase\n  if( deadCount == this->playerParty.Num() )\n  {\n    this->SetPhase( CombatPhase::CPHASE_GameOver );\n    return false;\n  }\n\n  // check for victory\n  deadCount = 0;\n  for( int i = 0; i < this->enemyParty.Num(); i++ )\n  {\n    if( this->enemyParty[ i ]->HP <= 0 ) deadCount++;\n  }\n\n  // all enemies have died, switch to victory phase\n  if( deadCount == this->enemyParty.Num() )\n  {\n    this->SetPhase( CombatPhase::CPHASE_Victory );\n    return false;\n  }\n\n  // if execution reaches here, combat has not finished - return false\n  return false;\n}\n```", "```cpp\nvoid CombatEngine::SetPhase( CombatPhase phase )\n{\n  this->phase = phase;\n\n  switch( phase )\n  {\n    case CombatPhase::CPHASE_Action:\n    case CombatPhase::CPHASE_Decision:\n      // set the active target to the first character in the combat order\n      this->tickTargetIndex = 0;\n      this->SelectNextCharacter();\n      break;\n    case CombatPhase::CPHASE_Victory:\n      // todo: handle victory\n      break;\n    case CombatPhase::CPHASE_GameOver:\n      // todo: handle game over\n      break;\n  }\n}\n```", "```cpp\nvoid CombatEngine::SelectNextCharacter()\n{\n  for( int i = this->tickTargetIndex; i < this->combatantOrder.Num(); i++ )\n  {\n    GameCharacter* character = this->combatantOrder[ i ];\n\n    if( character->HP > 0 )\n    {\n      this->tickTargetIndex = i + 1;\n      this->currentTickTarget = character;\n      return;\n    }\n  }\n\n  this->tickTargetIndex = -1;\n  this->currentTickTarget = nullptr;\n}\n```", "```cpp\nprotected:\n  float testDelayTimer;\n```", "```cpp\npublic:\n  void BeginMakeDecision();\n  bool MakeDecision( float DeltaSeconds );\n\n  void BeginExecuteAction();\n  bool ExecuteAction( float DeltaSeconds );\n```", "```cpp\nvoid UGameCharacter::BeginMakeDecision()\n{\n  UE_LOG( LogTemp, Log, TEXT( \"Character %s making decision\" ), *this->CharacterName );\n  this->testDelayTimer = 1;\n}\n\nbool UGameCharacter::MakeDecision( float DeltaSeconds )\n{\n  this->testDelayTimer -= DeltaSeconds;\n  return this->testDelayTimer <= 0;\n}\n\nvoid UGameCharacter::BeginExecuteAction()\n{\n  UE_LOG( LogTemp, Log, TEXT( \"Character %s executing action\" ), *this->CharacterName );\n  this->testDelayTimer = 1;\n}\n\nbool UGameCharacter::ExecuteAction( float DeltaSeconds )\n{\n  this->testDelayTimer -= DeltaSeconds;\n  return this->testDelayTimer <= 0;\n}\n```", "```cpp\nclass CombatEngine;\n```", "```cpp\n#include \"Combat/CombatEngine.h\"\n```", "```cpp\nbool waitingForCharacter;\n```", "```cpp\ncase CombatPhase::CPHASE_Decision:\n{\n  if( !this->waitingForCharacter )\n  {\n    this->currentTickTarget->BeginMakeDecision();\n    this->waitingForCharacter = true;\n  }\n\n  bool decisionMade = this->currentTickTarget->MakeDecision( DeltaSeconds );\n\n  if( decisionMade )\n  {\n    SelectNextCharacter();\n\n    // no next character, switch to action phase\n    if( this->tickTargetIndex == -1 )\n    {\n      this->SetPhase( CombatPhase::CPHASE_Action );\n    }\n  }\n}\nbreak;\n```", "```cpp\ncase CombatPhase::CPHASE_Action:\n{\n  if( !this->waitingForCharacter )\n  {\n    this->currentTickTarget->BeginExecuteAction();\n    this->waitingForCharacter = true;\n  }\n\n  bool actionFinished = this->currentTickTarget->ExecuteAction( DeltaSeconds );\n\n  if( actionFinished )\n  {\n    SelectNextCharacter();\n\n    // no next character, switch to action phase\n    if( this->tickTargetIndex == -1 )\n    {\n      this->SetPhase( CombatPhase::CPHASE_Decision );\n    }\n  }\n}\nbreak;\n```", "```cpp\nvoid CombatEngine::SelectNextCharacter()\n{\n  this->waitingForCharacter = false;\n  for (int i = this->tickTargetIndex; i < this->combatantOrder.\n    Num(); i++)\n  {\n    UGameCharacter* character = this->combatantOrder[i];\n\n    if (character->HP > 0)\n    {\n      this->tickTargetIndex = i + 1;\n      this->currentTickTarget = character;\n      return;\n    }\n  }\n\n  this->tickTargetIndex = -1;\n  this->currentTickTarget = nullptr;\n}\n```", "```cpp\nCombatEngine* combatInstance;\n```", "```cpp\nCombatEngine::CombatEngine( TArray<UGameCharacter*> playerParty, TArray<UGameCharacter*> enemyParty )\n{\n  this->playerParty = playerParty;\n  this->enemyParty = enemyParty;\n\n  // first add all players to combat order\n  for (int i = 0; i < playerParty.Num(); i++)\n  {\n    this->combatantOrder.Add(playerParty[i]);\n  }\n\n  // next add all enemies to combat order\n  for (int i = 0; i < enemyParty.Num(); i++)\n  {\n    this->combatantOrder.Add(enemyParty[i]);\n  }\n\n  this->tickTargetIndex = 0;\n  this->SetPhase(CombatPhase::CPHASE_Decision);\n\n  for( int i = 0; i < this->combatantOrder.Num(); i++ )\n  {\n    this->combatantOrder[i]->combatInstance = this;\n  }\n\n  this->tickTargetIndex = 0;\n  this->SetPhase( CombatPhase::CPHASE_Decision );\n}\n\nCombatEngine::~CombatEngine()\n{\n  // free enemies\n  for( int i = 0; i < this->enemyParty.Num(); i++ )\n  {\n    this->enemyParty[i] = nullptr;\n  }\n\n  for( int i = 0; i < this->combatantOrder.Num(); i++ )\n  {\n    this->combatantOrder[i]->combatInstance = nullptr;\n  }\n}\n```", "```cpp\n#pragma once\n#include \"GameFramework/GameMode.h\"\n#include \"GameCharacter.h\"\n#include \"Combat/CombatEngine.h\"\n#include \"RPGGameMode.generated.h\"\n\nUCLASS()\nclass RPG_API ARPGGameMode : public AGameMode\n{\n  GENERATED_BODY()\n\n  ARPGGameMode( const class FObjectInitializer& ObjectInitializer );\n  virtual void BeginPlay() override;\n  virtual void Tick( float DeltaTime ) override;\n\npublic:\n  CombatEngine* currentCombatInstance;\n  TArray<UGameCharacter*> enemyParty;\n};\n```", "```cpp\nvoid ARPGGameMode::Tick( float DeltaTime )\n{\n  if( this->currentCombatInstance != nullptr )\n  {\n    bool combatOver = this->currentCombatInstance->Tick( DeltaTime );\n    if( combatOver )\n    {\n      if( this->currentCombatInstance->phase == CombatPhase::CPHASE_GameOver )\n      {\n        UE_LOG( LogTemp, Log, TEXT( \"Player loses combat, game over\" ) );\n                }\n      else if( this->currentCombatInstance->phase == CombatPhase::CPHASE_Victory )\n      {\n        UE_LOG( LogTemp, Log, TEXT( \"Player wins combat\" ) );\n      }\n\n      // enable player actor\n      UGameplayStatics::GetPlayerController( GetWorld(), 0 )->SetActorTickEnabled( true );\n\n      delete( this->currentCombatInstance );\n      this->currentCombatInstance = nullptr;\n      this->enemyParty.Empty();\n    }\n  }\n}\n```", "```cpp\nstatic UGameCharacter* CreateGameCharacter( FEnemyInfo* enemyInfo, UObject* outer );\n```", "```cpp\nUGameCharacter* UGameCharacter::CreateGameCharacter( FEnemyInfo* enemyInfo, UObject* outer )\n{\n  UGameCharacter* character = NewObject<UGameCharacter>( outer );\n\n  character->CharacterName = enemyInfo->EnemyName;\n  character->ClassInfo = nullptr;\n\n  character->MHP = enemyInfo->MHP;\n  character->MMP = 0;\n  character->HP = enemyInfo->MHP;\n  character->MP = 0;\n\n  character->ATK = enemyInfo->ATK;\n  character->DEF = enemyInfo->DEF;\n  character->LUCK = enemyInfo->Luck;\n\n  return character;\n}\n```", "```cpp\nUFUNCTION(exec)\nvoid TestCombat();\n```", "```cpp\nvoid ARPGGameMode::TestCombat()\n{\n  // locate enemies asset\n  UDataTable* enemyTable = Cast<UDataTable>( StaticLoadObject( UDataTable::StaticClass(), NULL, \nTEXT( \"DataTable'/Game/Data/Enemies.Enemies'\" ) ) );\n\n  if( enemyTable == NULL )\n  {\n    UE_LOG( LogTemp, Error, TEXT( \"Enemies data table not found!\" ) );\n    return;\n  }\n\n  // locate enemy\n  FEnemyInfo* row = enemyTable->FindRow<FEnemyInfo>( TEXT( \"S1\" ), TEXT( \"LookupEnemyInfo\" ) );\n\n  if( row == NULL )\n  {\n    UE_LOG( LogTemp, Error, TEXT( \"Enemy ID 'S1' not found!\" ) );\n    return;\n  }\n\n  // disable player actor\n  UGameplayStatics::GetPlayerController( GetWorld(), 0 )->SetActorTickEnabled( false );\n\n  // add character to enemy party\n  UGameCharacter* enemy = UGameCharacter::CreateGameCharacter( row, this );\n  this->enemyParty.Add( enemy );\n\n  URPGGameInstance* gameInstance = Cast<URPGGameInstance>( GetGameInstance() );\n\n  this->currentCombatInstance = new CombatEngine( gameInstance->PartyMembers, this->enemyParty );\n\n  UE_LOG( LogTemp, Log, TEXT( \"Combat started\" ) );\n}\n```", "```cpp\nLogTemp: Combat started\nLogTemp: Character Kumo making decision\nLogTemp: Character Goblin making decision\nLogTemp: Character Kumo executing action\nLogTemp: Character Goblin executing action\nLogTemp: Character Kumo making decision\nLogTemp: Character Goblin making decision\nLogTemp: Character Kumo executing action\nLogTemp: Character Goblin executing action\nLogTemp: Character Kumo making decision\nLogTemp: Character Goblin making decision\nLogTemp: Character Kumo executing action\nLogTemp: Character Goblin executing action\nLogTemp: Character Kumo making decision\n\n```", "```cpp\n#pragma once\n\n#include \"GameCharacter.h\"\n\nclass UGameCharacter;\n\nclass ICombatAction\n{\npublic:\n  virtual void BeginExecuteAction( UGameCharacter* character ) = 0;\n  virtual bool ExecuteAction( float DeltaSeconds ) = 0;\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"ICombatAction.h\"\n```", "```cpp\n#pragma once\n\n#include \"ICombatAction.h\"\n\nclass TestCombatAction : public ICombatAction\n{\nprotected:\n  float delayTimer;\n\npublic:\n  virtual void BeginExecuteAction( UGameCharacter* character ) override;\n  virtual bool ExecuteAction( float DeltaSeconds ) override;\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"TestCombatAction.h\"\n\nvoid TestCombatAction::BeginExecuteAction( UGameCharacter* character )\n{\n  UE_LOG( LogTemp, Log, TEXT( \"%s does nothing\" ), *character->CharacterName );\n  this->delayTimer = 1.0f;\n}\n\nbool TestCombatAction::ExecuteAction( float DeltaSeconds )\n{\n  this->delayTimer -= DeltaSeconds;\n  return this->delayTimer <= 0.0f;\n}\n```", "```cpp\npublic:\n  ICombatAction* combatAction;\n```", "```cpp\n#pragma once\n\n#include \"Data/FCharacterInfo.h\"\n#include \"Data/FEnemyInfo.h\"\n#include \"Data/FCharacterClassInfo.h\"\n#include \"Combat/Actions/ICombatAction.h\"\n#include \"GameCharacter.generated.h\"\n\nclass CombatEngine;\nclass ICombatAction;\n```", "```cpp\nvoid UGameCharacter::BeginMakeDecision()\n{\n  UE_LOG( LogTemp, Log, TEXT( \"Character %s making decision\" ), *( this->CharacterName ) );\n  this->combatAction = new TestCombatAction();\n}\n\nbool UGameCharacter::MakeDecision( float DeltaSeconds )\n{\n  return true;\n}\n\nvoid UGameCharacter::BeginExecuteAction()\n{\n  this->combatAction->BeginExecuteAction( this );\n}\n\nbool UGameCharacter::ExecuteAction( float DeltaSeconds )\n{\n  bool finishedAction = this->combatAction->ExecuteAction( DeltaSeconds );\n  if( finishedAction )\n  {\n    delete( this->combatAction );\n    return true;\n  }\n\n  return false;\n}\n```", "```cpp\n#include \"Combat/Actions/TestCombatAction.h\"\n```", "```cpp\n#pragma once\n\n#include \"GameCharacter.h\"\n\nclass UGameCharacter;\n\nclass IDecisionMaker\n{\npublic:\n  virtual void BeginMakeDecision( UGameCharacter* character ) = 0;\n  virtual bool MakeDecision( float DeltaSeconds ) = 0;\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"IDecisionMaker.h\"\n```", "```cpp\n#pragma once\n#include \"IDecisionMaker.h\"\n\nclass RPG_API TestDecisionMaker : public IDecisionMaker\n{\npublic:\n  virtual void BeginMakeDecision( UGameCharacter* character ) override;\n  virtual bool MakeDecision( float DeltaSeconds ) override;\n};\n```", "```cpp\n#include \"RPG.h\"\n#include \"TestDecisionMaker.h\"\n\n#include \"../Actions/TestCombatAction.h\"\n\nvoid TestDecisionMaker::BeginMakeDecision( UGameCharacter* character )\n{\n  character->combatAction = new TestCombatAction();\n}\n\nbool TestDecisionMaker::MakeDecision( float DeltaSeconds )\n{\n  return true;\n}\n```", "```cpp\npublic:\n  IDecisionMaker* decisionMaker;\n```", "```cpp\n#pragma once\n\n#include \"Data/FCharacterInfo.h\"\n#include \"Data/FEnemyInfo.h\"\n#include \"Data/FCharacterClassInfo.h\"\n#include \"Combat/Actions/ICombatAction.h\"\n#include \"Combat/DecisionMakers/IDecisionMaker.h\"\n#include \"GameCharacter.generated.h\"\n\nclass CombatEngine;\nclass ICombatAction;\nclass IDecisionMaker;\n```", "```cpp\nvoid UGameCharacter::BeginDestroy()\n{\n  Super::BeginDestroy();\n  delete( this->decisionMaker );\n}\n\nvoid UGameCharacter::BeginMakeDecision()\n{\n  this->decisionMaker->BeginMakeDecision( this );}\n\nbool UGameCharacter::MakeDecision( float DeltaSeconds )\n{\n  return this->decisionMaker->MakeDecision( DeltaSeconds );\n}\n```", "```cpp\n#include \"Combat/DecisionMakers/TestDecisionMaker.h\"\n```", "```cpp\nUGameCharacter* UGameCharacter::CreateGameCharacter(\n  FCharacterInfo* characterInfo, UObject* outer)\n{\n  UGameCharacter* character = NewObject<UGameCharacter>(outer);\n\n  // locate character classes asset\n  UDataTable* characterClasses = Cast<UDataTable>(\n    StaticLoadObject(UDataTable::StaticClass(), NULL, TEXT(\n      \"DataTable'/Game/Data/CharacterClasses.CharacterClasses'\"))\n    );\n\n  if (characterClasses == NULL)\n  {\n    UE_LOG(LogTemp, Error, \nTEXT(\"Character classes datatable not found!\" ) );\n  }\n  else\n  {\n    character->CharacterName = characterInfo->Character_Name;\n    FCharacterClassInfo* row = \ncharacterClasses->FindRow<FCharacterClassInfo>\n(*(characterInfo->Class_ID), TEXT(\"LookupCharacterClass\"));\n    character->ClassInfo = row;\n\n    character->MHP = character->ClassInfo->StartMHP;\n    character->MMP = character->ClassInfo->StartMMP;\n    character->HP = character->MHP;\n    character->MP = character->MMP;\n\n    character->ATK = character->ClassInfo->StartATK;\n    character->DEF = character->ClassInfo->StartDEF;\n    character->LUCK = character->ClassInfo->StartLuck;\n\n    character->decisionMaker = new TestDecisionMaker();\n  }\n\n  return character;\n}\n\nUGameCharacter* UGameCharacter::CreateGameCharacter(FEnemyInfo* enemyInfo, UObject* outer)\n{\n  UGameCharacter* character = NewObject<UGameCharacter>(outer);\n\n  character->CharacterName = enemyInfo->EnemyName;\n  character->ClassInfo = nullptr;\n\n  character->MHP = enemyInfo->MHP;\n  character->MMP = 0;\n  character->HP = enemyInfo->MHP;\n  character->MP = 0;\n\n  character->ATK = enemyInfo->ATK;\n  character->DEF = enemyInfo->DEF;\n  character->LUCK = enemyInfo->Luck;\n\n  character->decisionMaker = new TestDecisionMaker();\n\n  return character;\n}\n```", "```cpp\nbool isPlayer;\n```", "```cpp\nUGameCharacter* SelectTarget();\n```", "```cpp\nUGameCharacter* UGameCharacter::CreateGameCharacter(\n  FCharacterInfo* characterInfo, UObject* outer)\n{\n  UGameCharacter* character = NewObject<UGameCharacter>(outer);\n\n  // locate character classes asset\n  UDataTable* characterClasses = Cast<UDataTable>(\n    StaticLoadObject(UDataTable::StaticClass(), NULL, TEXT(\n      \"DataTable'/Game/Data/CharacterClasses.CharacterClasses'\"))\n    );\n\n  if (characterClasses == NULL)\n  {\n    UE_LOG(LogTemp, Error,\n      TEXT(\"Character classes datatable not found!\"));\n  }\n  else\n  {\n    character->CharacterName = characterInfo->Character_Name;\n    FCharacterClassInfo* row =\n      characterClasses->FindRow<FCharacterClassInfo>\n(*(characterInfo->Class_ID), TEXT(\"LookupCharacterClass\"));\n    character->ClassInfo = row;\n\n    character->MHP = character->ClassInfo->StartMHP;\n    character->MMP = character->ClassInfo->StartMMP;\n    character->HP = character->MHP;\n    character->MP = character->MMP;\n\n    character->ATK = character->ClassInfo->StartATK;\n    character->DEF = character->ClassInfo->StartDEF;\n    character->LUCK = character->ClassInfo->StartLuck;\n\n    character->decisionMaker = new TestDecisionMaker();\n  }\n  character->isPlayer = true;\n  return character;\n}\n\nUGameCharacter* UGameCharacter::CreateGameCharacter(FEnemyInfo* enemyInfo, UObject* outer)\n{\n  UGameCharacter* character = NewObject<UGameCharacter>(outer);\n\n  character->CharacterName = enemyInfo->EnemyName;\n  character->ClassInfo = nullptr;\n\n  character->MHP = enemyInfo->MHP;\n  character->MMP = 0;\n  character->HP = enemyInfo->MHP;\n  character->MP = 0;\n\n  character->ATK = enemyInfo->ATK;\n  character->DEF = enemyInfo->DEF;\n  character->LUCK = enemyInfo->Luck;\n\n  character->decisionMaker = new TestDecisionMaker();\n  character->isPlayer = false;\n  return character;\n}\n```", "```cpp\nUGameCharacter* UGameCharacter::SelectTarget()\n{\n  UGameCharacter* target = nullptr;\n\n  TArray<UGameCharacter*> targetList = this->combatInstance->enemyParty;\n  if( !this->isPlayer )\n  {\n    targetList = this->combatInstance->playerParty;\n  }\n\n  for( int i = 0; i < targetList.Num(); i++ )\n  {\n    if( targetList[ i ]->HP > 0 )\n    {\n      target = targetList[i];\n      break;\n    }\n  }\n\n  if( target->HP <= 0 )\n  {\n    return nullptr;\n  }\n\n  return target;\n}\n```", "```cpp\nprotected:\n  UGameCharacter* character;\n  UGameCharacter* target;\n\npublic:\n  TestCombatAction( UGameCharacter* target );\n```", "```cpp\nvoid TestCombatAction::BeginExecuteAction( UGameCharacter* character )\n{\n  this->character = character;\n\n  // target is dead, select another target\n  if( this->target->HP <= 0 )\n  {\n    this->target = this->character->SelectTarget();\n  }\n\n  // no target, just return\n  if( this->target == nullptr )\n  {\n    return;\n  }\n\n  UE_LOG( LogTemp, Log, TEXT( \"%s attacks %s\" ), *character->CharacterName, *target->CharacterName );\n\n  target->HP -= 10;\n\n  this->delayTimer = 1.0f;\n}\n```", "```cpp\nTestCombatAction::TestCombatAction(UGameCharacter* target)\n{\n  this->target = target;\n}\n```", "```cpp\nvoid TestDecisionMaker::BeginMakeDecision( UGameCharacter* character )\n{\n  // pick a target\n  UGameCharacter* target = character->SelectTarget();\n  character->combatAction = new TestCombatAction( target );\n}\n```", "```cpp\nLogTemp: Combat started\nLogTemp: Kumo attacks Goblin\nLogTemp: Goblin attacks Kumo\nLogTemp: Kumo attacks Goblin\nLogTemp: Player wins combat\n\n```", "```cpp\nPublicDependencyModuleNames.AddRange( new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"UMG\", \"Slate\", \"SlateCore\" } );\n```", "```cpp\n#include \"Runtime/UMG/Public/UMG.h\"\n#include \"Runtime/UMG/Public/UMGStyle.h\"\n#include \"Runtime/UMG/Public/Slate/SObjectWidget.h\"\n#include \"Runtime/UMG/Public/IUMGModule.h\"\n#include \"Runtime/UMG/Public/Blueprint/UserWidget.h\"\n```", "```cpp\n#pragma once\n#include \"GameCharacter.h\"\n\n#include \"Blueprint/UserWidget.h\"\n#include \"CombatUIWidget.generated.h\"\n\nUCLASS()\nclass RPG_API UCombatUIWidget : public UUserWidget\n{\n  GENERATED_BODY()\n\npublic:\n  UFUNCTION( BlueprintImplementableEvent, Category = \"Combat UI\" )\n  void AddPlayerCharacterPanel( UGameCharacter* target );\n\n  UFUNCTION( BlueprintImplementableEvent, Category = \"Combat UI\" )\n  void AddEnemyCharacterPanel( UGameCharacter* target );\n};\n```", "```cpp\nUPROPERTY()\nUCombatUIWidget* CombatUIInstance;\n\nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = \"UI\" )\nTSubclassOf<class UCombatUIWidget> CombatUIClass;\n```", "```cpp\n#include \"GameFramework/GameMode.h\"\n#include \"GameCharacter.h\"\n#include \"Combat/CombatEngine.h\"\n#include \"UI/CombatUIWidget.h\"\n#include \"RPGGameMode.generated.h\"\n```", "```cpp\nthis->CombatUIInstance = CreateWidget<UCombatUIWidget>( GetGameInstance(), this->CombatUIClass );\nthis->CombatUIInstance->AddToViewport();\n\nUGameplayStatics::GetPlayerController(GetWorld(), 0)\n->bShowMouseCursor = true;\n\nfor( int i = 0; i < gameInstance->PartyMembers.Num(); i++ )\n  this->CombatUIInstance->AddPlayerCharacterPanel( gameInstance->PartyMembers[i] );\n\nfor( int i = 0; i < this->enemyParty.Num(); i++ )\n  this->CombatUIInstance->AddEnemyCharacterPanel( this->enemyParty[i] );\n```", "```cpp\nvoid ARPGGameMode::Tick(float DeltaTime)\n{\n  if (this->currentCombatInstance != nullptr)\n  {\n    bool combatOver = this->currentCombatInstance->Tick(DeltaTime\n    );\n    if (combatOver)\n    {\n      if (this->currentCombatInstance->phase == CombatPhase::\n        CPHASE_GameOver)\n      {\n        UE_LOG(LogTemp, Log, \n        TEXT(\"Player loses combat, game over\" ) );\n      }\n      else if \n      (this->currentCombatInstance->phase == \n      CombatPhase::  CPHASE_Victory)\n      {\n        UE_LOG(LogTemp, Log, TEXT(\"Player wins combat\"));\n      }\n      UGameplayStatics::GetPlayerController(GetWorld(),0)\n      ->bShowMouseCursor = false;\n\n      // enable player actor\n      UGameplayStatics::GetPlayerController(GetWorld(), 0)->\n        SetActorTickEnabled(true);\n\n      this->CombatUIInstance->RemoveFromViewport();\n      this->CombatUIInstance = nullptr;\n\n      delete(this->currentCombatInstance);\n      this->currentCombatInstance = nullptr;\n      this->enemyParty.Empty();\n    }\n  }\n}\n```", "```cpp\ncharacter->decisionMaker = new TestDecisionMaker();\n```", "```cpp\nif( !this->isPlayer )\n  delete( this->decisionMaker );\n```", "```cpp\n#pragma once\n#include \"GameCharacter.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CombatUIWidget.generated.h\"\n\nUCLASS()\nclass RPG_API UCombatUIWidget : public UUserWidget, public IDecisionMaker\n{\n  GENERATED_BODY()\n\npublic:\n  UFUNCTION(BlueprintImplementableEvent, Category = \"Combat UI\")\n    void AddPlayerCharacterPanel(UGameCharacter* target);\n\n  UFUNCTION(BlueprintImplementableEvent, Category = \"Combat UI\")\n    void AddEnemyCharacterPanel(UGameCharacter* target);\n\n  void BeginMakeDecision(UGameCharacter* target);\n  bool MakeDecision(float DeltaSeconds);\n};\n```", "```cpp\npublic:\n  UFUNCTION( BlueprintCallable, Category = \"Combat UI\" )\n  TArray<UGameCharacter*> GetCharacterTargets();\n\n  UFUNCTION( BlueprintCallable, Category = \"Combat UI\" )\n  void AttackTarget( UGameCharacter* target );\n```", "```cpp\nUFUNCTION( BlueprintImplementableEvent, Category = \"Combat UI\" )\nvoid ShowActionsPanel( UGameCharacter* target );\n```", "```cpp\nprotected:\n UGameCharacter* currentTarget;\n  bool finishedDecision;\n```", "```cpp\n#include \"RPG.h\"\n#include \"CombatUIWidget.h\"\n#include \"../Combat/CombatEngine.h\"\n#include \"../Combat/Actions/TestCombatAction.h\"\n\nvoid UCombatUIWidget::BeginMakeDecision( UGameCharacter* target )\n{\n  this->currentTarget = target;\n  this->finishedDecision = false;\n\n  ShowActionsPanel( target );\n}\n\nbool UCombatUIWidget::MakeDecision( float DeltaSeconds )\n{\n  return this->finishedDecision;\n}\n\nvoid UCombatUIWidget::AttackTarget( UGameCharacter* target )\n{\n  TestCombatAction* action = new TestCombatAction( target );\n  this->currentTarget->combatAction = action;\n\n  this->finishedDecision = true;\n}\n\nTArray<UGameCharacter*> UCombatUIWidget::GetCharacterTargets()\n{\n  if( this->currentTarget->isPlayer )\n  {\n    return this->currentTarget->combatInstance->enemyParty;\n  }\n  else\n  {\n    return this->currentTarget->combatInstance->playerParty;\n  }\n}\n```", "```cpp\nfor( int i = 0; i < gameInstance->PartyMembers.Num(); i++ )\n{\n  this->CombatUIInstance->AddPlayerCharacterPanel( gameInstance->PartyMembers[i] );\n  gameInstance->PartyMembers[i]->decisionMaker = this->CombatUIInstance;\n}\n```", "```cpp\nfor( int i = 0; i < this->currentCombatInstance->playerParty.Num(); i++ )\n{\n  this->currentCombatInstance->playerParty[i]->decisionMaker = nullptr;\n}\n```", "```cpp\nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = \"UI\" )\nTSubclassOf<class UUserWidget> GameOverUIClass;\n```", "```cpp\nif( this->currentCombatInstance->phase == CombatPhase::CPHASE_GameOver )\n{\n  UE_LOG( LogTemp, Log, TEXT( \"Player loses combat, game over\" ) );\n\n  Cast<URPGGameInstance>( GetGameInstance() )->PrepareReset();\n\n  UUserWidget* GameOverUIInstance = CreateWidget<UUserWidget>( GetGameInstance(), this->GameOverUIClass );\n  GameOverUIInstance->AddToViewport();\n}\n```", "```cpp\npublic:\n  void PrepareReset();\n```", "```cpp\ncpp.void URPGGameInstance::PrepareReset()\n{\n  this->isInitialized = false;\n  this->PartyMembers.Empty();\n}\n```"]