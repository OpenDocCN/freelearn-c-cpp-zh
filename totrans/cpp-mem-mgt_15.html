<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-207"><a id="_idTextAnchor213"/>15</h1>
<h1 id="_idParaDest-208"><a id="_idTextAnchor214"/>Contemporary Issues</h1>
<p>We are reaching the end of our journey, dear reader. Over the course of this book, we have examined fundamental aspects of the C++ object model and discussed dangerous aspects of low-level programming. We have looked at the fundamentals of resource management in C++ through the RAII idiom, looked at how smart pointers are used, and explored how to write such a type. We also took control of the memory allocation functions at our disposal (and we did that in many ways!), and we wrote containers that manage memory themselves as well as through other objects or types, including allocators.</p>
<p>That was quite an experience!</p>
<p>What do we still have to cover? Well, so much… but there’s a limit to what we can put in a single book. So, to conclude our discussion of memory management in C++, I thought we might have a chat (yes, dear reader, just you and I) about some of the interesting topics in contemporary memory management in C++. Yes, things that were so recently standardized (as of this writing) that most, if not all, libraries still do not implement them, and things the standards committee is actively working on.</p>
<p>It’s important to look at C++ as it is today and how it might be in the near future because the language continues to evolve, and at quite a quick pace: a new version of the C++ standard is issued every three years, and this has been the case since 2011. The evolution of C++ is too slow for some and too quick for others, but it is unrelenting (we call this publishing rhythm the “train model” to highlight its sustained pace) and brings regular progress and innovation to this language that we love so much.</p>
<p>As of this writing, in the early weeks of 2025, C++23 is a freshly adopted standard, having been officialized in November 2024 (yes, I know: the ISO process does take some time), and the committee is discussing proposals meant for C++26 (yes, already!) and C++29.</p>
<p>The memory management-related topics we will discuss in this chapter are either aspects of the C++23 standard that we have not discussed in this book yet or are some that, as this chapter is being written, are under discussion for upcoming standards. Be aware, dear reader, that what you will now read may become reality in the form you will read about, but it might also come along in another form after discussions and debates in the C++ standards committee… or it might, in the end, never come to be.</p>
<p>Even if these topics do not end up entering the C++ standard in the form in which they were initially discussed, you will know that they will have been discussed, along with the problems they were meant to solve, and that these features might become part of the language at some point. Who knows; maybe you will have an epiphany and find the words to turn one of these ideas into a proposal that the C++ standards committee will discuss, and then adopt.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Explicitly starting the lifetime of one or many objects without resorting to their constructors</li>
<li>Trivial relocation: what it means and in what ways the standards committee is trying to address it</li>
<li>Type-aware allocation and deallocation functions: what they would do and how to benefit from them</li>
</ul>
<p>Our approach in this chapter will be to present these new features (or features-to-be) through the perspective of the problems we are trying to solve. The intent behind this approach is to make it clear that these features address actual issues and will help real programmers do their jobs better.</p>
<p>I hope this chapter will give you insights into an interesting (albeit non-exhaustive) set of contemporary issues in memory management and associated facilities as they pertain to C++.</p>
<p class="callout-heading">A note on code examples for this chapter</p>
<p class="callout">If you try to compile the examples in this chapter, esteemed reader, you might find yourself saddened by the fact that some will not compile yet and others might not compile for a while, or ever. This situation is normal for a chapter such as this one: we will be discussing a combination of features that have been very recently added to the C++ language (recently enough that they have not yet been implemented at the time of authoring this book) and features that are under discussion by the C++ standards committee. Take the examples as illustrations, then, and adjust them as the features take a more formal shape.</p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor215"/>Technical requirements</h1>
<p><a id="_idTextAnchor216"/>You can find the code files for this chapter in the book’s GitHub repository: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15</a>.</p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor217"/>Starting object lifetime without constructors</h1>
<p>Consider the<a id="_idIndexMarker884"/> case of a program that consumes serialized data from a stream and that seeks to make objects from that data. Here’s an example:</p>
<pre class="source-code">
#include &lt;fstream&gt;
#include &lt;cstdint&gt;
#include &lt;array&gt;
#include &lt;memory&gt;
#include &lt;string_view&gt;
struct Point3D {
   float x{}, y{}, z{};
   Point3D() = default;
   constexpr Point3D(float x, float y, float z)
      : x{ x }, y{ y }, z{ z } {
   }
};
// ...
// reads at most N bytes from file named file_name and
// writes these bytes into buf. Returns the number of
// bytes read (postcondition: return value &lt;= N)
//
template &lt;int N&gt;
   int read_from_stream(std::array&lt;unsigned char, N&gt; &amp;buf,
                        std::string_view file_name) {
   // ...
}
// ...</pre> <p>As <a id="_idIndexMarker885"/>you can see, in this example, we have the <code>Point3D</code> class. An object of this type represents a set of <em class="italic">x,y,z</em> coordinates. We also have a <code>read_from_stream&lt;N&gt;()</code> function that consumes bytes from a file. The function then stores at most <code>N</code> bytes into argument <code>buf</code>, which is passed by reference and returns the number of bytes read (which might be zero but will never be more than <code>N</code>).</p>
<p>For the sake of this example, we will suppose that the file from which we plan to read is known to contain the binary form of serialized <code>Point3D</code> objects, equivalent to objects of type <code>float</code> serialized in binary format by groups of three. Now, consider the following program, which consumes the byte representation of at most four objects of type <code>Point3D</code> from a file named <code>some_file.dat</code>:</p>
<pre class="source-code">
// ...
#include &lt;print&gt;
#include &lt;cassert&gt;
using namespace std::literals;
int main() {
<strong class="bold">   static constexpr int NB_PTS = 4;</strong>
<strong class="bold">   static constexpr int NB_BYTES =</strong>
<strong class="bold">      NB_PTS * sizeof(Point3D);</strong>
<strong class="bold">   alignas(Point3D)</strong>
<strong class="bold">      std::array&lt;unsigned char, NB_BYTES&gt; buf{};</strong>
   if (int n = read_from_stream&lt;<strong class="bold">NB_BYTES</strong>&gt;(
          buf, "some_file.dat"sv
       ); n != 0) {
      // print out the bytes: 0-filled left, 2
      // characters-wide, hex format
      for (int i = 0; i != n; ++i)
         std::print("{:0&lt;2x} ", buf[i]);
      std::println();
<strong class="bold">      // if we want to treat the bytes as Point3D objects,</strong>
<strong class="bold">      // we need to start the lifetime of these Point3D</strong>
<strong class="bold">      // objects. If we do not, we are in UB territory (it</strong>
<strong class="bold">      // might work or it might not, and even if it works</strong>
<strong class="bold">      // we cannot count on it)</strong>
<strong class="bold">      const Point3D* pts =</strong>
<strong class="bold">         std::start_lifetime_as_array(buf.data(), n);</strong>
<strong class="bold">      assert(n % 3 == 0);</strong>
<strong class="bold">      for (std::size_t i = 0;</strong>
<strong class="bold">           i != n / sizeof(Point3D); ++i)</strong>
<strong class="bold">         std::print("{} {} {}\n",</strong>
<strong class="bold">                    pts[i].x, pts[i].y, pts[i].z);</strong>
   }
}</pre> <p>This example<a id="_idIndexMarker886"/> program reads bytes from a file into a <code>std::array</code> object big enough to contain the bytes of four objects of type <code>Point3D</code>, having first ensured that this array would be aligned appropriately if it were to hold objects of that type. This alignment consideration is essential as we plan to treat the bytes as objects of that type once those bytes have been read.</p>
<p>The <a id="_idIndexMarker887"/>point of this example is that once the bytes have been read, the programmer is confident (well, as confident as one could be) that <em class="italic">all the bytes are correct</em> for some hypothetical <code>Point3D</code> objects but still cannot use these objects as <em class="italic">their lifetime has not </em><em class="italic">yet started</em>.</p>
<p>This sort of situation traditionally makes many C programmers smile and some C++ programmers cringe: the C++ object model imposes constraints on programs that make it <strong class="bold">UB</strong> (see <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a>) to use objects outside of their lifetime, even if all the bytes are right and alignment constraints have been respected, whereas C is less restrictive. To use the contents of the buffer we just used to read from that file, our options are traditionally as follows:</p>
<ul>
<li>To loop through the array of bytes, write appropriately-sized subsets of those bytes into objects of type <code>float</code>, then call the constructors of <code>Point3D</code> objects and put them in another container.</li>
<li>To <code>reinterpret_cast</code> the array of bytes into an array of <code>Point3D</code> objects and hope for the best, leading to code that might or might not work and, being UB, would not be portable anyway (not even between versions of a given compiler). With our <code>Point3D</code> objects, it will probably give the results one would hope for, but replace these with, say, <code>std::complex&lt;float&gt;</code> objects from the standard library (a type that probably has a similar inner structure as our <code>Point3D</code> type) and… well, who knows what might happen?</li>
<li>To <code>std::memcpy()</code> the array of bytes into itself, casting the return value to type <code>Point3D*</code> and using the resulting pointer as if it were an array of <code>Point3D</code> objects. That’s actually valid (the <code>std::memcpy()</code> function is part of a select set of functions that are allowed to start the lifetime of objects). There is, of course, the risk of creating an actual copy of the bytes (which would be wasted execution time); some standard libraries are said to recognize that pattern and just behave as if the call was a no-op, but a special kind of no-op that can start the lifetime of objects.</li>
</ul>
<p>None of<a id="_idIndexMarker888"/> these options seems truly satisfactory, however, so a cleaner solution that does not rely on compiler-specific optimizations is needed. To that effect, the C++23 standard introduces a set of <code>constexpr</code> functions (accompanied by a number of overloads) that are called <code>std::start_lifetime_as_array&lt;T&gt;(p,n)</code> and <code>std::start_lifetime_as&lt;T&gt;(p)</code>. Both are portable forms of magical no-op functions that inform the compiler that the bytes are OK and to consider the lifetime of the pointees as having begun.</p>
<p>Of course, if for some reason the pointees have non-trivial destructors, you should make sure that your code calls these destructors when appropriate. Expect this situation to be rare and unusual. Since we consumed raw bytes from some source of data and turned these bytes into objects, the probability that the resulting objects own resources is somewhat slim. Of course, these objects can acquire resources once their lifetimes have begun. Let’s be honest, dear reader; C++ programmers are nothing if not creative!</p>
<p>This set of <code>std::start_lifetime_...</code> functions is expected to be a boon to network programmers everywhere, in particular. These individuals often receive data frames of well-formed byte sequences that they need to turn into objects for the purpose of further processing. These functions are also expected to be useful to programs that consume bytes from files in order to form aggregates. Many programmers think that just reading bytes into an array of bytes and casting that array to an intended type (or array thereof) suffices to get access to the (hypothetical) object (or objects) therein and are surprised when their C++ code starts behaving unexpectedly. C++ is a systems programming language, and the set made of these <code>std::start_lifetime_...</code> functions closes a gap where it could be said to be underperforming.</p>
<p>Of course, these functions form a very sharp toolset due to the risks involved: non-trivially destructible objects whose lifetime starts this way are especially suspicious, and you have to be highly trusting of whatever facility provided the bytes in which an object’s lifetime is manually and explicitly started. Thus, these facilities should be used with utmost care.</p>
<p>A note to complete this section: as of this writing, no major compiler yet implements these functions, even though they have been standardized and are part of C++23. Maybe they will be implemented by the time you get to read this, who knows?</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor218"/>Trivial relocation</h1>
<p>As you know, dear reader, C++ is known in the <a id="_idIndexMarker889"/>programming community as one of those languages that we use when we need to get the most out of our computer or whatever hardware platform interests us. Some of the language’s credos can be paraphrased as “you shall not pay for what you do not use” and “there shall be no room for a lower-level language (except for the occasional bit of assembly code)”, after all. The latter explains the importance of the <code>std::start_lifetime_...</code> functions of the previous section.</p>
<p>That’s probably why, when it becomes evident that we could do even better than we are already doing in terms of execution speed, that becomes a subject of interest to the C++ programmer community in general, and more specifically to members of the C++ standards committee. We all take these core credos of the language to heart.</p>
<p>One case where we could do better is when we encounter types for which moving a source object to a destination object, followed by destroying the original object, could in practice be replaced by a call to <code>std::memcpy()</code>: directly copying an array of bytes is faster than performing a series of moves and destructors (and if it isn’t, there’s probably some work required on your <code>std::memcpy()</code> implementation), even though move assignments and destructors make for a fast combination.</p>
<p>It turns out that there are many types for which such an optimization could be considered, including <code>std::string</code>, <code>std::any</code>, and <code>std::optional&lt;T&gt;</code> (depending on what type <code>T</code> is), classes such as <code>Point3D</code> from the previous section, any type that does not define any of the six special member functions seen in <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> (including fundamental types), and so on.</p>
<p>To understand the impact, consider the following <code>resize()</code> free function, which mimics a <code>C::resize()</code> member function for some container, <code>C</code>, that manages contiguous memory such as our <code>Vector&lt;T&gt;</code> type in the various incarnations seen in this book. This function resizes <code>arr</code> from <code>old_cap</code> (the old capacity) to <code>new_cap</code> (the new capacity), filling the space at the end with default <code>T</code> objects. The highlighted lines of the function are what interests us here:</p>
<pre class="source-code">
//
// This is not a good function interface, but we want to
// keep the example relatively simple
//
template &lt;class T&gt;
  void resize
    (T *&amp;arr, std::size_t old_cap, std::size_t new_cap) {
    //
    // we could deal with throwing a default constructor
    // but it would complicate our code a bit and these
    // added complexities, worthwhile as they are, are
    // besides the point for what we are discussing here
    //
    static_assert(
      std::is_nothrow_default_contructible_v&lt;T&gt;
    );
    //
    // sometimes, there's just nothing to do
    //
    if(new_cap &lt;= old_cap) return arr;
    //
    // allocate a chunk of raw memory (no object created)
    //
    auto p = static_cast&lt;T*&gt;(
      std::malloc(new_cap * sizeof(T))
    );
    if(!p) throw std::bad_alloc{};
    // ...</pre> <p>At this point, we are ready to<a id="_idIndexMarker890"/> copy (or move) objects:</p>
<pre class="source-code">
    // ...
    //
    // if move assignment does not throw, be aggressive
    //
    <strong class="bold">if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {</strong>
<strong class="bold">      std::uninitialized_move(arr, arr + old_cap, p);</strong>
<strong class="bold">      std::destroy(arr, arr + old_cap);</strong>
<strong class="bold">    }</strong> else {
      //
      // since move assignment could throw, let's be
      // conservative and copy instead
      //
      try {
        std::uninitialized_copy(arr, arr + old_cap, p);
        std::destroy(arr, arr + old_cap);
      } catch (...) {
        std::free(p);
        throw;
      }
    }
    //
    // fill the remaining space with default objects
    // (remember: we statically asserted that T::T() is
    // non-throwing)
    //
    std::uninitialized_default_construct(
      p + old_cap, p + new_cap
    );
    //
    // replace the old memory block (now without objects)
    // with the new one
    //
    std::free(arr);
    arr = p;
  }</pre> <p>Looking at the highlighted lines of that function, even though the combination of <code>std::uninitialized_move()</code> followed by <code>std::destroy()</code> makes for a fast path, we could be even faster than this and replace a linear number of move assignment operators followed by a linear number of destructor calls with a single call to <code>std::memcpy()</code>.</p>
<p>How do we achieve this? Well, there are many competing proposals by Arthur O’Dwyer, Mingxin Wang, Alisdair Meredith, and Mungo Gill, among others. Each of these proposals has merits, but these proposals <a id="_idIndexMarker891"/>have in common the following factors:</p>
<ul>
<li>Providing a way to test a type for “trivial relocatability” at compile time, for example, a <code>std::is_trivially_relocatable_v&lt;T&gt;</code> trait.</li>
<li>Providing a function that actually relocates the objects, for example, <code>std::relocate()</code> or <code>std::trivially_relocate()</code>, which take a source pointer and a destination pointer as arguments and relocate the source object to the destination location, concluding the lifetime of the original object and then starting the lifetime of the new one</li>
<li>Providing a way to mark a type as being trivially relocatable, for example through a keyword or an attribute</li>
<li>Providing rules to deduce trivial relocatability for a type at compile time</li>
</ul>
<p>The details can vary <a id="_idIndexMarker892"/>depending on the approach, but if we suppose these tools, the same <code>resize()</code> function could benefit from trivial relocation by a slight adjustment to the previously presented implementation:</p>
<pre class="source-code">
template &lt;class T&gt;
   void resize
     (T * &amp;arr, std::size_t old_cap, std::size_t new_cap) {
      static_assert(
         std::is_nothrow_default_contructible_v&lt;T&gt;
      );
      if(new_cap &lt;= old_cap) return arr;
      auto p = static_cast&lt;T*&gt;(
         std::malloc(new_cap * sizeof(T))
      );
      if(!p) throw std::bad_alloc{};
<strong class="bold">      //</strong>
<strong class="bold">      // this is our ideal case</strong>
<strong class="bold">      //</strong>
<strong class="bold">      if constexpr (std::is_trivially_relocatable_v&lt;T&gt;) {</strong>
<strong class="bold">         // equivalent to memcpy() plus consider the</strong>
<strong class="bold">         // lifetime of objects in [arr, arr + old_cap)</strong>
<strong class="bold">         // finished and the lifetime of objects in</strong>
<strong class="bold">         // [p, p + old_cap) started</strong>
<strong class="bold">         //</strong>
<strong class="bold">         // note: this supposes that the trait</strong>
<strong class="bold">         // std::is_trivially_relocatable&lt;T&gt;</strong>
<strong class="bold">         // implies std::is_trivially_destructible&lt;T&gt;</strong>
<strong class="bold">         std::relocate(arr, arr + old_cap, p);</strong>
      //
      // if move assignment does not throw, be aggressive
      //
      } else if constexpr(
           std::is_nothrow_move_assignable_v&lt;T&gt;
      ){
         std::uninitialized_move(arr, arr + old_cap, p);
         std::destroy(arr, arr + old_cap);
      } else {
<strong class="bold">         // ... see previous code example for the rest</strong>
      }
   }</pre> <p>This seemingly simple <a id="_idIndexMarker893"/>optimization has been reported to provide considerable benefits, with some having claimed up to 30% speedup in common cases, but this is experimental work, and more benchmarks are expected to come if proposals coalesce (as we expect them to) into something that will be integrated into the C++ standard.</p>
<p>Such potential speedups are part of what the C++ language aims to make possible, so we can reasonably expect trivial relocatability to become reality in the foreseeable future. The question is “how”: how should compilers detect the trivial relocatability property? How should programmers be able to indicate that property on their own types when the default trivial relocatability deduction<a id="_idIndexMarker894"/> rules are not met?</p>
<p>As of February 2025, the standard committee voted trivial relocation into what will become C++26 standard. This means we can expect that some programs that compiled with previous standards of the C++ language and are recompiled with C++26 could just run faster without changing a single line of source code.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor219"/>Type-aware allocation and deallocation functions</h1>
<p>Our last topic for this chapter <a id="_idIndexMarker895"/>on new approaches to memory management <a id="_idIndexMarker896"/>and optimization opportunities that pertain to object lifetime is type-aware allocation and deallocation functions. This is a novel approach to allocation functions for cases where user code might want to somehow use information with respect to what type is undergoing allocation (and eventual construction) to guide the allocation process.</p>
<p>We saw one facet of such features in <a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a> when describing the <code>T::operator delete()</code> is passed <code>T*</code> instead of the abstract <code>void*</code> as an argument, and is for that reason made responsible for both the finalization of the object and the deallocation of its underlying storage. We saw that there are cases where this reveals interesting optimization opportunities.</p>
<p>What is under discussion for C++26 is a new family of <code>operator new()</code> and <code>operator delete()</code> member functions, as well as free functions that take a <code>std::type_identity&lt;T&gt;</code> object as the first argument for some type <code>T</code>, guiding the selected operator towards some specialized behavior for that type <code>T</code>. Note that these type-aware allocation functions are really allocation functions: they do not perform construction, nor does their deallocation counterpart perform finalization.</p>
<p class="callout-heading">What is the std::type_identity&lt;T&gt; trait?</p>
<p class="callout">The expression <code>typename std::type_identity&lt;T&gt;::type</code> corresponds to <code>T</code>. OK, that seems trivial enough. So, what role does this trait play in contemporary C++ programming? It happens that trait <code>std::type_identity&lt;T&gt;</code>, introduced with C++20, is a tool that is typically used to provide additional control over argument type deduction in generic functions.</p>
<p class="callout">For example, with the function signature <code>template &lt;class T&gt; void f(T,T)</code>, you could call <code>f(3,3)</code> as both arguments are of the same type, but not <code>f(3,3.0)</code> as <code>int</code> and <code>double</code> are distinct types. That being said, by replacing either argument type with <code>std::type_identity_t&lt;T&gt;</code>, you could call <code>f(3,3.0)</code>, and since <code>T</code> would be deduced with the other argument (the one of type <code>T</code>), that type would be used for the other (the argument for which the type is <code>std::type_identity_t&lt;T&gt;</code>). That would lead to both arguments being <code>int</code> or <code>double</code>, depending on which argument is of type <code>T</code>.</p>
<p class="callout">The idea of using <code>std::type_identity&lt;T&gt;</code> (not <code>std::type_identity_t&lt;T&gt;</code>) instead of plain <code>T</code> as the type of the first argument in type-aware allocation functions is to make it clear that we are using this specific specialized overload of <code>operator new()</code> and that this is not an accident or a call to some other specialized form of this allocation function, such as those described in <a href="B21071_09.xhtml#_idTextAnchor141"><em class="italic">Chapter 9</em></a>.</p>
<p>This means that you <a id="_idIndexMarker898"/>could provide specialized allocation functions for <a id="_idIndexMarker899"/>a specific class, <code>X</code>, through the following function signatures:</p>
<pre class="source-code">
#include &lt;new&gt;
#include &lt;type_traits&gt;
void* operator new(<strong class="bold">std::type_identity&lt;X&gt;</strong>, std::size_t n);
void operator delete(<code>new X</code>, for example, the specialized form will be preferred to the usual form of <code>operator new()</code> and <code>operator delete()</code>, being assumed to be more appropriate unless the programmer takes steps to prevent it.</p>
<p>It also means that, given a specialized allocation algorithm that applies to type <code>T</code> only if <code>special_alloc_alg&lt;T&gt;</code> is satisfied, you could provide allocation functions that use this specialized algorithm for type <code>T</code> through the following function signatures:</p>
<pre class="source-code">
#include &lt;new&gt;
#include &lt;type_traits&gt;
<strong class="bold">template &lt;class T&gt; requires special_alloc_alg&lt;T&gt;</strong>
  void* operator new(<strong class="bold">std::type_identity&lt;T&gt;</strong>, std::size_t n);
<strong class="bold">template &lt;class T&gt; requires special_alloc_alg&lt;T&gt;</strong>
  void operator delete(<code>X</code> and <code>Y</code>, but that algorithm does not apply to other classes, such as <code>Z</code>:</p>
<pre class="source-code">
#include &lt;concepts&gt;
#include &lt;type_traits&gt;
class X { /* ... */ };
class Y { /* ... */ };
class Z { /* ... */ };
<strong class="bold">template &lt;class C&gt;</strong>
<strong class="bold">   concept cool_alloc_algorithm =</strong>
<strong class="bold">      std::is_same_v&lt;C, X&gt; || std::is_same_v&lt;C, Y&gt;;</strong>
<strong class="bold">template &lt;class T&gt; requires cool_alloc_algorithm&lt;T&gt;</strong>
  void* operator new(<strong class="bold">std::type_identity&lt;T&gt;</strong>, std::size_t n){
<strong class="bold">     // apply the cool allocation algorithm</strong>
  }
<strong class="bold">template &lt;class T&gt; requires cool_alloc_algorithm&lt;T&gt;</strong>
  void operator delete(<strong class="bold">std::type_identity&lt;T&gt;</strong>, void* p) {
<strong class="bold">     // apply the cool deallocation algorithm</strong>
  }
#include &lt;memory&gt;
int main() {
<strong class="bold">   // uses the "cool" allocation algorithm</strong>
<strong class="bold">   auto p = std::make_unique&lt;X&gt;();</strong>
<strong class="bold">   // uses the standard allocation algorithm</strong>
<strong class="bold">   auto q = std::make_unique&lt;Z&gt;();</strong>
} <strong class="bold">// uses the standard deallocation algorithm for q</strong>
  <strong class="bold">// uses the "cool" deallocation algorithm for p</strong></pre> <p>The type-aware<a id="_idIndexMarker902"/> allocation functions can also be member function<a id="_idIndexMarker903"/> overloads, leading to algorithms that apply to the class where these functions are defined, as well as to derived classes thereof.</p>
<p>Consider the following example, inspired by a more complex example found in the proposal for the feature that is described at <a href="https://wg21.link/p2719">https://wg21.link/p2719</a>:</p>
<pre class="source-code">
<strong class="bold">class D0; // forward class declaration</strong>
struct B {
<strong class="bold">  // i)</strong>
  <strong class="bold">template &lt;class T&gt;</strong>
  void* operator new(<strong class="bold">std::type_identity&lt;T&gt;</strong>, std::size_t);
<strong class="bold">  // ii)</strong>
  void* operator new(<strong class="bold">std::type_identity&lt;D0&gt;</strong>, std::size_t);
};
// ...</pre> <p>As expressed, <code>i)</code> applies to <code>B</code> and its derived classes, but <code>ii)</code> applies to the specific case of the forward-declared class <code>D0</code> and will only be used if <code>D0</code> is indeed a derived class of <code>B</code>.</p>
<p>Continuing this example, we now add three classes that each derive from <code>B</code>, with <code>D2</code> adding <code>iii)</code>, which is a non-type-aware member function overload of <code>operator new()</code>:</p>
<pre class="source-code">
// ...
struct D0 : B { };
struct D1 : B { };
struct D2 : B {
<strong class="bold">  // iii)</strong>
  void *operator new(std::size_t);
};
// ...</pre> <p>Given these overloads, here are some examples of expressions calling overloads <code>i)</code>, <code>ii)</code>, and <code>iii)</code>:</p>
<pre class="source-code">
// ...
void f() {
  new B;       // i) where T is B
  new D0;      // ii)
  new D1;      // i) where T is D1
  new D2;      // iii)
  ::new B;     // uses appropriate global operator new
}</pre> <p>As you can see, dear <a id="_idIndexMarker904"/>reader, type-aware allocation functions will, if<a id="_idIndexMarker905"/> accepted into the C++ standard, provide new ways to control what memory allocation algorithm will be used (depending on the circumstances) while still leaving user code in control, leaving it able to defer to the global <code>operator new()</code> function if that is the preferred option, as the last line of the <code>f()</code> function in the previous example shows.</p>
<p>Contrary to the destroying delete feature of C++20, which performs both the finalization of the object and the deallocation of the underlying storage, the type-aware versions of <code>operator new()</code> and <code>operator delete()</code> are only allocation functions, and as of this writing, there is no plan to provide a type-aware version of destroying delete.</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor220"/>Summary</h1>
<p>In this chapter, we have had a glimpse of the future with the <code>std::start_lifetime_...</code> functions that are part of C++23 but, as of this writing, have not been implemented by any major compiler. We have also looked at probable (but not yet official) parts of the future of C++ with the potential support of trivial relocatability and the possibility of introducing type-aware versions of <code>operator new()</code> and <code>operator delete()</code>.</p>
<p>With every step, C++ becomes a richer and more versatile language with which we can do more and express our ideas in more precise ways. C++ is a language that provides ever more significant control over the behavior of our programs. As powerful as C++ is today, and as powerful as it makes programmers like us, this chapter shows we can still continue to get better.</p>
<p>We are at the end of our journey, at least for now. I hope the trip was just eventful enough to be pleasant and entertaining to you, esteemed reader, and that you have learned a thing or two along the way. I also hope that some of the ideas discussed here will help you in your tasks and enrich your perspective of C++ programming.</p>
<p>Thanks for accompanying me. I hope the journeys ahead for you will be enjoyable, just as I hope this book will make your toolbox better and that you will continue exploring on your own. Safe travels.</p>
</div>


<div><h1 class="chapter-number" id="_idParaDest-214"><a id="_idTextAnchor221"/>Annexure: </h1>
<h1 id="_idParaDest-215"><a id="_idTextAnchor222"/>Things You Should Know</h1>
<p>This book supposes readers possess some technical background that some might not consider to be "common knowledge". In the following sections, you might find the complementary information that will help you get the most out of this book. Refer to it as needed, and enjoy!</p>
<p>Feel free to skim through the following sections if you think you know their contents well and take a closer look at those you’re less comfortable with. You could even skip this entire section and come back if you realize while reading this book that these topics are not things you know as well as you thought you did.</p>
<p>The overall goal is to get the most out of this book after all!</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor223"/>struct and class</h1>
<p>In C++, the <a id="_idIndexMarker906"/>words <code>struct</code> and <code>class</code> essentially<a id="_idIndexMarker907"/> mean the same thing, and code such as the following is perfectly legal:</p>
<pre class="source-code">
struct Drawable {
   virtual void draw() = 0;
   virtual ~Drawable() = default;
};
class Painting : public Drawable {
   void draw() override;
};</pre> <p>Here are some details to note:</p>
<ul>
<li>C++ has no <code>abstract</code> keyword like some other languages do. An abstract member function in C++ is <code>virtual</code> and has <code>=0</code> instead of a definition. The <code>virtual</code> keyword means <em class="italic">can be specialized by derived classes</em> (the <code>=0</code> part essentially means <em class="italic">must be specialized…</em>). We often talk <a id="_idIndexMarker908"/>of <code>virtual</code> member function. Functions that must be overridden are said to <a id="_idIndexMarker909"/>be <strong class="bold">pure </strong><strong class="bold">virtual</strong> functions.</li>
</ul>
<p class="callout-heading">Providing a default implementation for a pure virtual function</p>
<p class="callout">One can provide a definition for an abstract member function: it’s not typical, but it’s possible. That can be useful in cases where the base class wants to provide a default implementation of a service but requires that the derived classes at least consider providing their own. Here is an example:</p>
<p class="callout"><code>#</code><code>include &lt;iostream&gt;</code></p>
<p class="callout"><code>struct X { virtual int f() const = </code><code>0; };</code></p>
<p class="callout"><code>int X::f() const { return </code><code>3; }</code></p>
<p class="callout"><code>struct D : X { int f() const </code><code>override {</code></p>
<p class="callout"><code>   return X::f() + </code><code>1; }</code></p>
<p class="callout"><code>};</code></p>
<p class="callout"><code>void g(X &amp;x) { std::cout &lt;&lt; x.f() &lt;&lt; '\</code><code>n'; }</code></p>
<p class="callout"><code>int </code><code>main() {</code></p>
<p class="callout"><code> </code><code>D d;</code></p>
<p class="callout"><code>   // X x; // illegal: X has a pure virtual </code><code>member function</code></p>
<p class="callout"><code> </code><code>g(d);</code></p>
<p class="callout"><code>}</code></p>
<ul>
<li>C++ classes <a id="_idIndexMarker910"/>have destructors that handle what happens when an object reaches the end of its lifetime. Contrary to many other popular languages, automatic and static objects in C++ have deterministic lifetimes, and using destructors efficiently is idiomatic in that language. In<a id="_idIndexMarker911"/> a <code>virtual</code> member function), it is customary to have a <code>virtual</code> destructor (here, <code>virtual ~Drawable()</code>) to indicate that in a situation such as the following, destroying an object used through an indirection such as <code>p</code> should effectively destroy the pointed-to object (<code>Painting</code>), not the one denoted by the pointer’s static type (<code>Drawable</code>):<pre class="source-code">
//
// the following supposes that Painting is a public
// derived class of Drawable as suggested earlier in
// this section
//
Drawable *p = new Painting;
// ...
delete p; // &lt;-- here</pre></li> <li>A <code>class</code> can derive from a <code>struct</code> just as a <code>struct</code> can derive from a <code>class</code> as both are structurally<a id="_idIndexMarker912"/> equivalent. The main differences are that for a <code>struct</code>, inheritance is <code>public</code> by default (but that can be changed using <code>protected</code> or <code>private</code>) and the same goes for members, whereas for a <code>class</code>, inheritance and members are <code>private</code> by default (but again, that can be changed).</li>
</ul>
<p>Note, in passing, that it’s perfectly fine in C++ to have a member function with an access qualifier in the base class (for example, <code>Drawable::draw()</code>, which is <code>public</code>) and in a derived class (for example, <code>Painting::draw()</code>, which is <code>private</code>). Some other popular languages do not allow this.</p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor224"/>std::size_t</h1>
<p>Type <code>std::size_t</code> is <a id="_idIndexMarker913"/>an alias for some unsigned integral type, but the actual type can vary from compiler to compiler (it could be <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>, and so on).</p>
<p>One frequently encounters type <code>std::size_t</code> when discussing container sizes and the space occupied in memory by an object as expressed by operator <code>sizeof</code>.</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor225"/>The sizeof operator</h1>
<p>The <code>sizeof</code> operator <a id="_idIndexMarker914"/>yields the size in bytes of an object or a type. It is evaluated at compile time and will be used extensively throughout this book as we will need that information to allocate properly sized blocks of memory:</p>
<pre class="source-code">
auto s0 = sizeof(int); // s0 is the number of bytes in an
                       // int (parentheses required)
int n;
auto s1 = sizeof n; // s1 is the number of bytes occupied
                    // by s1, which is identical to s0.
                    // Note: for objects, parentheses are
                    // allowed but not mandated</pre> <p>Object size is one of the key components of memory management and influences the speed at which programs will execute. For that reason, it is a recurring theme throughout this book.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor226"/>Assertions</h1>
<p><code>int</code><em class="italic"> occupies four bytes of storage.</em>” In the latter case, we have a program that has been written based on a non-portable assumption and we have to live with this choice, but we do not want our code to compile on platforms where that assumption does not hold.</p>
<p>For dynamic assertions, it is customary to use the <code>assert()</code> macro from the <code>&lt;cassert&gt;</code> header. That macro takes as argument a boolean expression and halts program execution if it evaluates to <code>false</code>:</p>
<pre class="source-code">
void f(int *p) {
   assert(p); // we hold p != nullptr to be true
   // use *p
}</pre> <p>Note that many projects <a id="_idIndexMarker916"/>disable <code>assert()</code> from production code, something that can be done by defining the <code>NDEBUG</code> macro before compilation. As such, make sure never to put expressions with side effects in <code>assert()</code> as it might be removed by compiler options:</p>
<pre class="source-code">
int *obtain_buf(int);
void danger(int n) {
   int *p; // uninitialized
<strong class="bold">   assert(p = obtain_buf(n)); // dangerous!!!</strong>
   // use *p, but p might be uninitialized if assert()
   // has been disabled. This is very bad
}</pre> <p>Contrary to <code>assert()</code>, which is a library macro, <code>static_assert</code> is a language feature that prevents compilation if its condition is not met. Based on the example mentioned previously where a company might have built software based on a non-portable assumption such as <code>sizeof(int)==4</code>, we could make sure that code does not compile (and do bad things) for platforms that are not really supported:</p>
<pre class="source-code">
static_assert(sizeof(int)==4); // only compiles if the
                               // condition holds</pre> <p>Fixing bugs before<a id="_idIndexMarker917"/> shipping a software product is significantly better for developers and users alike than fixing bugs after the software has been sent “in the wild.” Consequently, <code>static_assert</code> can be seen as a powerful tool for delivering higher-quality products.</p>
<p>In this book, we will use <code>static_assert</code> regularly: it has no runtime cost and documents our assertions in a verifiable manner. It’s the sort of feature that essentially has no downsides.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor227"/>Undefined behavior</h1>
<p><strong class="bold">Undefined behavior</strong>, often<a id="_idIndexMarker918"/> abbreviated to <strong class="bold">UB</strong>, results from a situation in which the standard does not prescribe a specific behavior. In the C++ standard, UB is behavior for which no requirements are imposed. It can lead to the problem being ignored, just as it can lead to a diagnostic or program termination. The key idea is that if your program has undefined behavior, then it’s not playing by the rules of the language and is broken; its behavior is not guaranteed on your platform, it’s not portable between platforms or compilers, and it cannot be relied upon.</p>
<p>A correctly written C++ program has no undefined behavior. When faced with a function that contains undefined behavior, the compiler can do just about anything with the code in that function, which makes reasoning from source code essentially impossible.</p>
<p>Undefined behavior is one of the preeminent “things to be careful with” listed in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a>. Strive to avoid undefined behavior: it always comes back to bite you if you leave it in.</p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor228"/>Type traits</h1>
<p>Over the years, C++ programmers have developed various techniques to reason about the properties of their types, mostly at compile time. Inferring such things as <em class="italic">“Is the </em><code>T</code><em class="italic"> type const?</em>” or <em class="italic">“Is the </em><code>T</code><em class="italic"> type trivially copyable?”</em> can be very useful, particularly in the context of generic code. The constructs resulting from these techniques are called <code>&lt;</code><code>type_traits&gt;</code> header.</p>
<p>The ways in which standard <a id="_idIndexMarker920"/>type traits are expressed have standardized over time, going from complex beasts such as <code>std::numeric_limits&lt;T&gt;</code>, which provide a lot of different services for type  <code>T</code>, to more specific services such as <code>std::is_const&lt;T&gt;</code> (<em class="italic">Is the </em><code>type T</code><em class="italic"> actually </em><code>const</code><em class="italic">?</em>) or <code>std::remove_const&lt;T&gt;</code> (<em class="italic">Please give me the type that’s like </em><code>T</code><em class="italic"> but without the </em><code>const</code><em class="italic"> qualification if there was one</em>), which yield either a single type or a single value. Practice has shown that small, unitary type traits that yield either a type (named <code>type</code>) or a compile-time-known value (named <code>value</code>) can be considered “best practices,” and most contemporary type traits (including standard ones) are written this way.</p>
<p>Since C++14, the traits that yield types have aliases that end with <code>_t</code> (for example, instead of writing the rather painful <code>typename std::remove_const&lt;T&gt;::type</code> incantation, one can now write <code>std::remove_const_t&lt;T&gt;</code> instead) and since C++17, the traits that yield values have aliases that end with <code>_v</code> (for example, instead of writing <code>std::is_const&lt;T&gt;::value</code>, one can now write <code>std::is_const_v&lt;T&gt;</code>).</p>
<p class="callout-heading">What about concepts?</p>
<p class="callout">Type traits are a programming technique that’s been part of C++ for decades, but since C++20, we have had <strong class="bold">concepts</strong>, and<a id="_idIndexMarker921"/> concepts are sort of like traits (often, they are expressed <em class="italic">through</em> traits) but are stronger in the sense that they are part of the type system. This book does not use concepts much, but you (as a programmer) really should get acquainted with them. They are extremely powerful and extremely useful to contemporary C++ programming.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor229"/>The std::true_type and std::false_type traits</h1>
<p>When expressing type<a id="_idIndexMarker922"/> traits, the standard library applies the common practice of using the names <code>type</code> for types and <code>value</code> for values, as in this example:</p>
<pre class="source-code">
// hand-made is_const&lt;T&gt; and remove_const&lt;T&gt; traits
// (please use the standard versions from &lt;type_traits&gt;
// instead of writing your own!)
template &lt;class&gt; struct is_const {
   static constexpr bool <strong class="bold">value</strong> = false; // general case
};
// specialization for const types
template &lt;class T&gt; struct is_const&lt;const T&gt; {
   static constexpr bool <strong class="bold">value</strong> = true;
};
// general case
template &lt;<strong class="bold">class T</strong>&gt; struct remove_const {
   using <strong class="bold">type</strong> = T;
};
// specialization for const T
template &lt;<strong class="bold">class T</strong>&gt; struct remove_const&lt;<strong class="bold">const T</strong>&gt; {
   using <strong class="bold">type</strong> = T;
};</pre> <p>It happens that many<a id="_idIndexMarker923"/> type traits have Boolean values. To simplify the task of writing such traits and to ensure that the form of these traits is homogeneous, you will find types <code>std::true_type</code> and <code>std::false_type</code> in the <code>&lt;type_traits&gt;</code> header. These<a id="_idIndexMarker924"/> types can be seen as the type system counterparts of constants <code>true</code> and <code>false</code>.</p>
<p>With these types, we can rewrite traits such as <code>is_const</code> as follows:</p>
<pre class="source-code">
#include &lt;type_traits&gt;
// hand-made is_const&lt;T&gt; (prefer the std:: versions...)
template &lt;class&gt; struct is_const : <strong class="bold">std::false_type</strong> {
};
template &lt;class T&gt;
   struct is_const&lt;const T&gt; : <strong class="bold">std::true_type</strong> {
   };</pre> <p>These types are both a convenience and a way to express ideas more clearly.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor230"/>The std::conditional&lt;B,T,F&gt; trait</h1>
<p>It’s sometimes useful to <a id="_idIndexMarker925"/>choose between two types based on a condition known at compile time. Consider the following example where we seek to implement a comparison between two values of some type <code>T</code> that behave differently for floating-point types and for “other” types such as <code>int</code> all grouped together for simplicity:</p>
<pre class="source-code">
#include &lt;cmath&gt;
// we will allow comparisons between exact representations
// or floating point representations based on so-called tag
// types (empty classes used to distinguish function
// signatures)
<strong class="bold">struct floating {};</strong>
<strong class="bold">struct exact {};</strong>
// the three-argument versions are not meant to be called
// directly from user code
template &lt;class T&gt;
   bool close_enough(T a, T b, <strong class="bold">exact</strong>) {
      return a == b; // fine for int, short, bool, etc.
   }
template &lt;class T&gt;
   bool close_enough(T a, T b, <strong class="bold">floating</strong>) {
      // note: this could benefit from more rigor, but
      // that's orthogonal to our discussion
      return std::abs(a - b) &lt; static_cast&lt;T&gt;(0.000001);
   }
// this two-argument version is the one user code is
// meant to call
template &lt;class T&gt;
   bool close_enough(T a, T b) {
<strong class="bold">      // OUR GOAL: call the "floating" version for types</strong>
<strong class="bold">      // float, double and long double; call the "exact"</strong>
<strong class="bold">      // version otherwise</strong>
   }</pre> <p>You might notice that we did <a id="_idIndexMarker926"/>not name the arguments of type <code>exact</code> and <code>floating</code> in our <code>close_enough()</code> functions. That’s fine as we are not using these objects at all; the reason for these arguments is to ensure both functions have distinct signatures.</p>
<p>There is a <code>std::is_floating_point&lt;T&gt;</code> trait in the <code>&lt;type_traits&gt;</code> header with the value of <code>true</code> for floating-point numbers, and <code>false</code> otherwise. If we did not have this trait, we could write our own:</p>
<pre class="source-code">
// we could write is_floating_point&lt;T&gt; as follows
// (but please use std::is_floating_point&lt;T&gt; instead!
template &lt;class&gt; struct is_floating_point
   : std::false_type {}; // general case
// specializations
template &lt;&gt; struct is_floating_point&lt;float&gt;
   : std::true_type {};
template &lt;&gt; struct is_floating_point&lt;double&gt;
   : std::true_type {};
template &lt;&gt; struct is_floating_point&lt;long double&gt;
   : std::true_type {};
// convenience to simplify user code
template &lt;class T&gt;
   constexpr bool is_floating_point_v =
      is_floating_point&lt;T&gt;::value;</pre> <p>We can use this to make our decision. However, we do not want to make a runtime decision here since the nature of type <code>T</code> is fully known at compile time, and nobody wants to pay for a branch instruction when comparing integers!</p>
<p>The <code>std::conditional&lt;B,T,F&gt;</code> trait can<a id="_idIndexMarker927"/> be used to make such a decision. If we wrote our own, it could look like this:</p>
<pre class="source-code">
// example, home-made conditional&lt;B,T,F&gt; type trait
// (prefer the std:: version in &lt;type_traits&gt;)
// general case (incomplete type)
template &lt;<strong class="bold">bool</strong>, class T, class F&gt; struct conditional;
// specializations
template &lt; class T, class F&gt;
   struct conditional&lt;<strong class="bold">true</strong>, T, F&gt; {
<strong class="bold">      using type = T; // constant true, picks type T</strong>
   };
template &lt; class T, class F&gt;
   struct conditional&lt;<strong class="bold">false</strong>, T, F&gt; {
<strong class="bold">   using type = F; // constant true, picks type F</strong>
};
// convenience to simplify user code
template &lt;bool B, class T, class F&gt;
   using conditional_t = typename conditional&lt;B,T,F&gt;::type;</pre> <p>Given this trait, we can choose, at <a id="_idIndexMarker928"/>compile time, one of two types based on a compile-time Boolean value, which is exactly what we were trying to do:</p>
<pre class="source-code">
// ...
// this version will be called from user code
template &lt;class T&gt;
   bool close_enough(T a, T b) {
      return close_enough(
         a, b, <strong class="bold">conditional_t&lt;</strong>
<strong class="bold">            is_floating_point_v&lt;T&gt;,</strong>
<strong class="bold">            floating,</strong>
<strong class="bold">            exact</strong>
<strong class="bold">         &gt; {}</strong>
      );
   }</pre> <p>The way to read this is that the third argument in the call to <code>close_enough()</code> (found within our two-argument, user-facing <code>close_enough()</code> function) will either be an object of type <code>floating</code> or an object of type <code>exact</code> , but the exact type will be picked at compile time based on the value of the <code>is_floating_point_v&lt;T&gt;</code> compile-time constant. The end result is that we instantiate an object of one of these two empty classes, call the appropriate algorithm, and let function inlining do the rest and optimize the entire scaffolding away.</p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor231"/>Algorithms</h1>
<p>The C++ standard library contains, among other gems, a<a id="_idIndexMarker929"/> set of algorithms. Each of these functions performs the tasks that a very well-written loop would do but with specific names, complexity guarantees, and optimizations. As such, let’s say we write the following:</p>
<pre class="source-code">
int vals[]{ 2,3,5,7,11 };
int dest[5];
for(int i = 0; i != 5; ++i)
   dest[i] = vals[i];</pre> <p>It is idiomatic in C++ to write the following instead:</p>
<pre class="source-code">
int vals[]{ 2,3,5,7,11 };
int dest[5];
<code>[begin,end)</code>, meaning that for all algorithms, the beginning iterator (here, <code>begin(vals)</code>) is included and the ending iterator (here, <code>end(vals)</code>) is excluded, making <code>[begin,end)</code> a half-open range. All algorithms in <code>&lt;algorithm&gt;</code> and in its cousin header, <code>&lt;numeric&gt;</code>, follow<a id="_idIndexMarker930"/> that simple convention.</p>
<p class="callout-heading">What about ranges?</p>
<p class="callout">The <code>&lt;ranges&gt;</code> library is a major addition <a id="_idIndexMarker931"/>to the C++ standard library since C++20 and can sometimes be used to lead to even better code than the already tremendous <code>&lt;algorithm&gt;</code> library. This book does not use ranges much, but that does not mean this library is not wonderful, so please feel free to use it and investigate ways through which it can be used to make your code better.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor232"/>Functors (function objects) and lambdas</h1>
<p>It is customary in C++ to <a id="_idIndexMarker932"/>use <strong class="bold">functors</strong>, otherwise called <strong class="bold">function objects</strong>, to<a id="_idIndexMarker933"/> represent stateful computations. Think, for example, of a program that would print integers to the standard output using an algorithm:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
using namespace std;
void display(int n) { cout &lt;&lt; n &lt;&lt; ' '; }
int main() {
   int vals[]{ 2,3,5,7,11 };
   for_each(begin(vals), end(vals), display);
}</pre> <p>This small program works fine, but should we want to print elsewhere than on the standard output, we would find ourselves in an unpleasant situation: the <code>for_each()</code> algorithm expects a unary function in the sense of “function accepting a single argument” (here, the value to print), so there’s no syntactic space to add an argument such as the output stream to use. We could “solve” this issue through a global variable, or using a different function for every output stream, but that would fall short of a reasonable design.</p>
<p>If we replace the <code>display</code> function <a id="_idIndexMarker934"/>with a class, which we’ll name <code>Display</code> to make them visually<a id="_idIndexMarker935"/> distinct, we end up with the following:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
using namespace std;
<strong class="bold">class Display {</strong>
<strong class="bold">   ostream &amp;os;</strong>
<strong class="bold">public:</strong>
<strong class="bold">   Display(ostream &amp;os) : os{ os } {</strong>
<strong class="bold">   }</strong>
<strong class="bold">   void operator()(int n) const { os &lt;&lt; n &lt;&lt; ' '; }</strong>
<strong class="bold">};</strong>
int main() {
   int vals[]{ 2,3,5,7,11 };
<strong class="bold">   // display on the standard output</strong>
<strong class="bold">   for_each(begin(vals), end(vals), Display{ cout });</strong>
   ofstream out{"out.txt" };
<strong class="bold">   // write to file out.txt</strong>
<strong class="bold">   for_each(begin(vals), end(vals), Display{ out });</strong>
}</pre> <p>This leads to nice, readable code with added flexibility. Note that, conceptually, lambda expressions are <a id="_idIndexMarker936"/>functors (you can even use lambdas<a id="_idIndexMarker937"/> as base classes!), so the previous example can be rewritten equivalently as <a id="_idIndexMarker938"/>follows:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
using namespace std;
int main() {
   int vals[]{ 2,3,5,7,11 };
<strong class="bold">   // display on the standard output</strong>
<strong class="bold">   for_each(begin(vals), end(vals), [](int n) {</strong>
<strong class="bold">      cout &lt;&lt; n &lt;&lt; ' ';</strong>
<strong class="bold">   });</strong>
   ofstream out{"out.txt" };
<strong class="bold">   // write to file out.txt</strong>
<strong class="bold">   for_each(begin(vals), end(vals), [&amp;out](int n) {</strong>
<strong class="bold">      out &lt;&lt; n &lt;&lt; ' ';</strong>
<strong class="bold">   });</strong>
}</pre> <p>Lambdas are thus essentially functors<a id="_idIndexMarker939"/> that limit themselves to a constructor and an <code>operator()</code> member function, and this combination represents the most common case by far for such objects. You can, of course, still use full-blown, explicit functors if you want more than this.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor233"/>Friends</h1>
<p>C++ offers an access qualifier that’s not commonly found in other languages and is often misunderstood: the <code>friend</code> qualifier. A <a id="_idIndexMarker940"/>class can specify another class or a function as one of its friends, giving said <code>friend</code> qualifier full access to all of that class’s members, including those qualified as <code>protected</code> or <code>private</code>.</p>
<p>Some consider <code>friend</code> to break encapsulation, and indeed it can do this if used recklessly, but the intent here is to provide privileged access to specific entities rather than exposing them as <code>public</code> or <code>protected</code> members that were not designed to that end, leading to an even wider encapsulation breakage.</p>
<p>Consider, for example, the following classes, where <code>thing</code> is something that is meant to be built from the contents of a file named <code>name</code> by a <code>thing_factory</code> that’s able to validate the file’s content before constructing the <code>thing</code>:</p>
<pre class="source-code">
class thing {
   thing(string_view); // note: private
   // ... various interesting members
<strong class="bold">   // thing_factory can access private members of</strong>
<strong class="bold">   // class thing</strong>
<strong class="bold">   friend class thing_factory;</strong>
};
// in case we read an incorrect file
class invalid_format{};
class thing_factory {
   // ... various interesting things here too
   string read_file(const string &amp;name) const {
      ifstream in{ name };
      // consume the file in one fell swoop, returning
      // the entire contents in a single string
      return { istreambuf_iterator&lt;char&gt;{ in },
               istreambuf_iterator&lt;char&gt;{ } };
   }
   bool is_valid_content(string_view) const;
public:
   <strong class="bold">thing</strong> create_thing_from(const string &amp;name) const {
      auto contents = read_file(name);
      if(!is_valid_content(contents))
         throw invalid_format{};
<strong class="bold">      // note: calls private thing constructor</strong>
<strong class="bold">      return { contents };</strong>
   }
};</pre> <p>We do not want the whole world to be able to call the <code>private</code>-qualified <code>thing</code> constructor that takes an<a id="_idIndexMarker941"/> arbitrary <code>string_view</code> as an argument since that constructor is not meant to handle character strings that have not been validated in the first place. For this reason, we only let <code>thing_factory</code> use it, thus strengthening encapsulation rather than weakening it.</p>
<p>It is customary to put a class and its friends together when shipping code as they go together: a friend of a class, in essence, is an external addition to that class’s interface. Finally, note that restrictions <a id="_idIndexMarker942"/>apply to friendship. Friendship is not reflexive; if <code>A</code> declares <code>B</code> to be its friend, it does not follow that <code>B</code> declares <code>A</code> to be its friend:</p>
<pre class="source-code">
class A {
   int n = 3;
<strong class="bold">   friend class B;</strong>
public:
   void f(B);
};
class B {
   int m = 4;
public:
   void f(A);
};
void <strong class="bold">A::f(B b)</strong> {
<strong class="bold">   // int val = b.m; // no, A is not a friend of B</strong>
}
void <strong class="bold">B::f(A a)</strong> {
<strong class="bold">   int val = a.n; // Ok, B is a friend of A</strong>
}</pre> <p>Friendship is not transitive; if <code>A</code> declares <code>B</code> to be its friend and <code>B</code> declares <code>C</code> to be its friend, it does not follow that <code>A</code> declares <code>C</code> to be its friend:</p>
<pre class="source-code">
class A {
   int n = 3;
<strong class="bold">   friend class B;</strong>
};
class B {
<strong class="bold">   friend class C;</strong>
public:
   void f(<strong class="bold">A a</strong>) {
<strong class="bold">      int val = a.n; // Ok, B is a friend of A</strong>
   }
};
class C {
public:
   void f(<strong class="bold">A a</strong>) {
<strong class="bold">      // int val = a.n; // no, C is not a friend of A</strong>
   }
};</pre> <p>Last but not least, friendship is not inherited; if <code>A</code> declares <code>B</code> to be its friend, it does not follow that if <code>C</code> is a child class of <code>B</code>, <code>A</code> has<a id="_idIndexMarker943"/> declared <code>C</code> to be its friend:</p>
<pre class="source-code">
class A {
   int n = 3;
<strong class="bold">   friend class B;</strong>
};
class B {
public:
   void f(<strong class="bold">A a</strong>) {
<strong class="bold">      int val = a.n; // Ok, B is a friend of A</strong>
   }
};
class <strong class="bold">C : B</strong> {
public:
   void f(<strong class="bold">A a</strong>) {
<strong class="bold">      // int val = a.n; // no, C is not a friend of A</strong>
   }
};</pre> <p>Used judiciously, <code>friend</code> solves <a id="_idIndexMarker944"/>encapsulation problems that would be difficult to deal with otherwise.</p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor234"/>The decltype operator</h1>
<p>The type system of C++ is powerful and <a id="_idIndexMarker945"/>nuanced, offering (among other things) a set of type deduction facilities. The best-known type deduction tool is probably <code>auto</code>, used to infer the type of an expression from the type of its initializer:</p>
<pre class="source-code">
const int n = f();
auto m = n; // m is of type int
auto &amp; r = m; // r is of type int&amp;
const auto &amp; cr0 = m; // cr0 is of type const int&amp;
auto &amp; cr1 = n; // cr1 is of type const int&amp;</pre> <p>As you might notice from the preceding example, by default, <code>auto</code> makes copies (see the declaration of variable <code>m</code> ), but you can qualify <code>auto</code> with <code>&amp;</code>, <code>&amp;&amp;</code>, <code>const</code>, and so on if needed.</p>
<p>Sometimes, you want to deduce the type of an expression with more precision, keeping the various qualifiers that accompany it. That might be useful when inferring the type of an arithmetic expression, the type of a lambda, the return type of a complicated generic function, and so on. For this, you have the <code>decltype</code> operator:</p>
<pre class="source-code">
template &lt;class T&gt;
   T&amp; pass_thru(T &amp;arg) {
      return arg;
   }
int main() {
   int n = 3;
   <strong class="bold">auto</strong> m = pass_thru(n); // m is an int
   ++m;
   cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; '\n'; // 3 4
   <strong class="bold">decltype(pass_thru(n))</strong> r = pass_thru(n); // r is an int&amp;
   ++r;
   cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n'; // 4 4
}</pre> <p>The use of <code>auto</code> has become commonplace in C++ code since C++11, at least in some circles. The <code>decltype</code> operator, also<a id="_idIndexMarker946"/> part of C++ since C++11, is a sharper tool, still widely used but for more specialized use cases.</p>
<p class="callout-heading">When the types get painful to spell</p>
<p class="callout">In the preceding <code>decltype</code> example, we spelled <code>pass_thru(n)</code> twice: once in the <code>decltype</code> operator and once in the actual function call. That’s not practical in general since it duplicates the maintenance effort and… well, it’s just noise, really. Since C++14, one can use <code>decltype(auto)</code> to express “the fully qualified type of the initializing expression.”</p>
<p class="callout">Thus, we would customarily write <code>decltype(auto) r = pass_thru(n);</code> to express that <code>r</code> is to have the fully qualified type of the expression <code>pass_thru(n)</code> .</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor235"/>Perfect forwarding</h1>
<p>The advent of variadic templates in C++11 <a id="_idIndexMarker947"/>has made it necessary to ensure there is a way for the semantics at the call site of a function to be conveyed throughout the call chain. This might seem abstract but it’s quite real and has implications on the effect of function calls.</p>
<p>Consider the following class:</p>
<pre class="source-code">
#include &lt;string&gt;
struct X {
   X(int, const std::string&amp;); // A
   X(int, std::string&amp;&amp;); // B
   // ... other constructors and various members
};</pre> <p>This class exposes at least two constructors, one that takes an <code>int</code> and <code>const string&amp;</code> as argument and another that takes an <code>int</code> and a <code>string&amp;&amp;</code> instead. To make the example more general, we’ll also suppose the existence of other <code>X</code> constructors that we might want to call while still focusing on these two. If we called these two constructors explicitly, we could do so with the following:</p>
<pre class="source-code">
X x0{ 3, "hello" }; // calls A
string s = "hi!";
X x1{ 4, s }; // also calls A
X x2{ 5, string{ "there" } }; // calls B
X x3{ 5, "there too"s }; // also calls B</pre> <p>The constructor of <code>x0</code> calls <code>A</code>, as <code>"hello"</code> is a <code>const char(&amp;)[6]</code> (including the trailing <code>'\0'</code>), not a <code>string</code> type, but the compiler’s allowed to synthesize a temporary <code>string</code> to pass as a <code>const string&amp;</code> in this case (it could not if the <code>string&amp;</code> was non-<code>const</code> as it would require referring to a modifiable object).</p>
<p>The constructor of <code>x1</code> also calls <code>A</code>, as <code>s</code> is a named <code>string</code> type, which means it cannot be implicitly passed by movement.</p>
<p>The constructors of <code>x2</code> and <code>x3</code> both call <code>B</code>, which takes a <code>string&amp;&amp;</code> as an argument, as they are both passed temporary, anonymous <code>string</code> objects that can be implicitly passed by movement.</p>
<p>Now, suppose we want to <a id="_idIndexMarker948"/>write a factory of <code>X</code> objects that relays arguments to the appropriate <code>X</code> constructor (one of the two we’re looking at or any other <code>X</code> constructor) after having done some preliminary work; for the sake of this example, we’ll simply log the fact that we are constructing an <code>X</code> object. Let’s say we wrote it this way:</p>
<pre class="source-code">
template &lt;class ... Args&gt;
   X makeX(Args ... args) {
      clog &lt;&lt; "Creating a X object\n";
      return X(args...); // &lt;-- HERE
   }</pre> <p>In this case, arguments would all have names and be passed by value, so the constructor that takes a <code>string&amp;&amp;</code> would never be chosen.</p>
<p>Now, let’s say we wrote it this way:</p>
<pre class="source-code">
template &lt;class ... Args&gt;
   X makeX(Args &amp;... args) {
      clog &lt;&lt; "Creating a X object\n";
      return X(args...); // &lt;-- HERE
   }</pre> <p>In this case, arguments would all be passed by reference, and a call that passed a <code>char</code> array such as <code>"hello"</code> as an argument would not compile. What we need to do is write our factory function in such a way that each argument keeps the semantics it had at the function’s call site, and is forwarded by the function with the exact same semantics.</p>
<p>The way to express this in C++ involves <code>std::forward&lt;T&gt;()</code> (from <code>&lt;utility&gt;</code>), which behaves as a cast. A forwarding reference superficially and syntactically looks like the <code>rvalue</code> references used for move semantics, but their impact on argument semantics is quite<a id="_idIndexMarker950"/> different. Consider the following example:</p>
<pre class="source-code">
// v passed by movement (type vector&lt;int&gt; fully specified)
void f0(vector&lt;int&gt; &amp;&amp;v);
// v passed by movement (type vector&lt;T&gt; fully specified
// for some type T)
template &lt;class T&gt;
   void f1(vector&lt;T&gt; &amp;&amp;v);
<strong class="bold">// v is a forwarding reference (type discovered by</strong>
<strong class="bold">// the compiler)</strong>
<strong class="bold">template &lt;class T&gt;</strong>
<code>f2()</code>:</p>
<pre class="source-code">
<strong class="bold">// T is vector&lt;int&gt;&amp;&amp; (pass by movement)</strong>
<strong class="bold">f2(vector&lt;int&gt;{ 2,3,5,7,11 });</strong>
vector&lt;int&gt; v0{ 2,3,5,7,11 };
<strong class="bold">f2(v0); // T is vector&lt;int&gt;&amp; (pass by reference)</strong>
const vector&lt;int&gt; v1{ 2,3,5,7,11 };
<code>X</code> objects, in this case, the appropriate signature for <code>makeX()</code> would be as follows:</p>
<pre class="source-code">
template &lt;class ... Args&gt;
<strong class="bold">   X makeX(Args &amp;&amp;... args) {</strong>
      clog &lt;&lt; "Creating a X object\n";
<strong class="bold">      return X(args...); // &lt;-- HERE (still incorrect)</strong>
   }</pre> <p>This version of our function almost works. The signature of <code>makeX()</code> is correct as each argument will be accepted with the type used at the call site, be it a reference, a reference to <code>const</code>, or an <code>rvalue</code> reference. What’s missing is that the arguments we are receiving as <code>rvalue</code> references now have a name within <code>makeX()</code> (they’re part of the pack named <code>args</code>!), so when calling the constructor of <code>X</code>, there’s no implicit move involved anymore.</p>
<p>What we need to do to complete our <a id="_idIndexMarker951"/>effort is to <em class="italic">cast back each argument to the type it had at the call site</em>. That type is inscribed in <code>Args</code>, the type of our pack, and the way to perform that cast is to apply <code>std::forward&lt;T&gt;()</code> to each argument in the pack. A correct <code>makeX()</code> function, at long last, would be as follows:</p>
<pre class="source-code">
template &lt;class ... Args&gt;
<strong class="bold">   X makeX(Args &amp;&amp;... args) {</strong>
      clog &lt;&lt; "Creating a X object\n";
<strong class="bold">      return X(std::forward&lt;Args&gt;(args)...); // &lt;-- HERE</strong>
   }</pre> <p>Whew! There are simpler syntaxes indeed, but we made it.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor236"/>The singleton design pattern</h1>
<p>There are many design patterns out there. Design patterns are a topic of their own, representing well-known ways of solving problems that one can represent in the abstract, give a name to, explain to others, and then reify within the constraints and idioms of one’s chosen programming language.</p>
<p>The <strong class="bold">singleton</strong> design pattern<a id="_idIndexMarker952"/> describes ways in which we can write a class that ensures it is instantiated only once in a program.</p>
<p>Singleton is not a well-liked pattern: it makes testing difficult, introduces dependencies on global state, represents a single point of failure in a program as well as a potential program-wide bottleneck, complicates multithreading (if the singleton is mutable, then its state requires synchronization), and so on, but it has its uses, is used in practice, and we use it on occasion in this book.</p>
<p>There are many ways to write a class that is instantiated only once in a program with the C++ language. All of them share<a id="_idIndexMarker953"/> some key characteristics:</p>
<ul>
<li>The type’s <code>copy</code> operations have to be deleted. If one can copy a singleton, then there will be more than one instance of that type, which leads to a contradiction.</li>
<li>There should be no <code>public</code> constructor. If there were, the client code could call it and create more than one instance.</li>
<li>There should be no <code>protected</code> members. Objects of derived classes are also, conceptually, objects of the base class, again leading to a contradiction (there would, in practice, be more than one instance of the singleton!).</li>
<li>Since there is no <code>public</code> constructor, there should be a <code>private</code> constructor (probably a default constructor), and that one will only be accessible to the class itself or to its friends (if any). For simplicity, we’ll suppose that the way to access a singleton is to go through a <code>static</code> (obviously) member function of the singleton.</li>
</ul>
<p>We’ll look at ways to implement an overly simplistic singleton in C++. For the sake of this example, the singleton will provide sequential integers on demand. The general idea for that class will be the following:</p>
<pre class="source-code">
#include &lt;atomic&gt;
class SequentialIdProvider {
   // ...
   std::atomic&lt;long long&gt; cur; // state (synchronized)
   // default constructor (private)
   SequentialIdProvider() : cur{ 0LL } {
   }
public:
   // service offered by the singleton (synchronized)
   auto next() { return cur++; }
   // deleted copy operations
   SequentialIdProvider(const SequentialIdProvider&amp;)
      = delete;
   SequentialIdProvider&amp;
      operator=(const SequentialIdProvider&amp;) = delete;
   // ...
};</pre> <p>The following subsections show two different techniques to create and provide access to the singleton.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor237"/>Instantiation at program startup</h2>
<p>One way to instantiate a <a id="_idIndexMarker954"/>singleton is to create it before <code>main()</code> starts by actually making it a <code>static</code> data member of its class. This requires <em class="italic">declaring</em> the singleton in the class and <em class="italic">defining</em> it in a separate source file in order to avoid ODR problems.</p>
<p class="callout-heading">ODR, you say?</p>
<p class="callout">The <strong class="bold">One Definition Rule</strong> (<strong class="bold">ODR</strong>) and<a id="_idIndexMarker955"/> associated issues are described in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a> of this book, but the gist of it is that in C++, every object can have many declarations but only one definition.</p>
<p>A possible implementation would be as follows:</p>
<pre class="source-code">
#include &lt;atomic&gt;
class SequentialIdProvider {
<strong class="bold">   // declaration (private)</strong>
<strong class="bold">   static SequentialIdProvider singleton;</strong>
   std::atomic&lt;long long&gt; cur; // state (synchronized)
   // default constructor (private)
   SequentialIdProvider() : cur{ 0LL } {
   }
public:
<strong class="bold">   // static member function providing access to the object</strong>
<strong class="bold">   static auto &amp; get() { return singleton; }</strong>
   // service offered by the singleton (synchronized)
   auto next() { return cur++; }
   // deleted copy operations
   SequentialIdProvider(const SequentialIdProvider&amp;)
      = delete;
   SequentialIdProvider&amp;
      operator=(const SequentialIdProvider&amp;) = delete;
   // ...
};
// in a source file somewhere, say SequentialIdProvider.cpp
<strong class="bold">#include "SequentialIdProvider.h"</strong>
<strong class="bold">// definition (calls the default constructor)</strong>
<code>SequentialIdProvider</code>, we could run into trouble as C++ does not guarantee the order in which global objects from multiple files are instantiated.</p>
<p>Possible client code for this implementation would be as follows:</p>
<pre class="source-code">
auto &amp; provider = SequentialIdProvider::get();
for(int i = 0; i != 5; ++i)
   cout &lt;&lt; provider.next() &lt;&lt; ' ';</pre> <p>This would display <a id="_idIndexMarker957"/>monotonically increasing integers, maybe consecutively (as long as there is no other thread concurrently calling the singleton’s services).</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor238"/>Instantiation of the first call</h2>
<p>Another way to <a id="_idIndexMarker958"/>instantiate a singleton is to create it the first time its services are solicited by making it a <code>static</code> variable of the function that provides access to the singleton. This way, as <code>static</code> local variables are created the first time the function is called and keep their state thereafter, a singleton could provide services to other singletons as long as this does not create cycles.</p>
<p>A possible implementation would be the following:</p>
<pre class="source-code">
#include &lt;atomic&gt;
class SequentialIdProvider {
   std::atomic&lt;long long&gt; cur; // state (synchronized)
   // default constructor (private)
   SequentialIdProvider() : cur{ 0LL } {
   }
public:
<strong class="bold">   // static member function providing access to the object</strong>
<strong class="bold">   static auto &amp; get() {</strong>
<strong class="bold">      static SequentialIdProvider singleton; // definition</strong>
<strong class="bold">      return singleton;</strong>
<strong class="bold">   }</strong>
   // service offered by the singleton (synchronized)
   auto next() { return cur++; }
   // deleted copy operations
   SequentialIdProvider(const SequentialIdProvider&amp;)
      = delete;
   SequentialIdProvider&amp;
      operator=(const SequentialIdProvider&amp;) = delete;
   // ...
};</pre> <p>Possible client code for this implementation would be as follows:</p>
<pre class="source-code">
auto &amp; provider = SequentialIdProvider::get();
for(int i = 0; i != 5; ++i)
   cout &lt;&lt; provider.next() &lt;&lt; ' ';</pre> <p>This would display monotonically increasing integers, maybe consecutively (as long as there is no other thread concurrently calling the singleton’s services).</p>
<p>Note that this version has<a id="_idIndexMarker959"/> a hidden cost: <code>static</code> variables local to functions are <a id="_idIndexMarker960"/>called <code>static</code> variable involves some synchronization and that this synchronization is paid on every call to that function. The preceding client code alleviates that cost by calling <code>SequentialIdProvider::get()</code> once, then reusing the reference obtained through that call afterward; it’s the call to <code>get()</code> that introduces the synchronization cost.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor239"/>The std::exchange() function</h1>
<p>There are (at least) two very <a id="_idIndexMarker961"/>useful and fundamental functions hidden in the <code>&lt;utility&gt;</code> header file. One is well-known and has been there for a long time: <code>std::swap()</code>, which is used for many purposes throughout the standard library as well as throughout user code.</p>
<p>The other, more recent one is <code>std::exchange()</code>. Where <code>swap(a,b)</code> swaps the values of objects <code>a</code> and <code>b</code> , expression <code>a = exchange(b,c)</code> changes the value of <code>b</code> with the value of <code>c</code>, returning the old value of <code>b</code> (to assign it to <code>a</code>). This might look strange at first but it’s actually a very useful facility.</p>
<p>Consider the move constructor <a id="_idIndexMarker962"/>for the following simplified <code>fixed_size_array</code>:</p>
<pre class="source-code">
template &lt;class T&gt;
   class fixed_size_array {
      T *elems{};
      std::size_t nelems{};
   public:
      // ...
<strong class="bold">      fixed_size_array(fixed_size_array &amp;&amp;other)</strong>
<strong class="bold">         : elems{ other.elems }, nelems{ other.nelems } {</strong>
<strong class="bold">         other.elems = nullptr;</strong>
<strong class="bold">         other.nelems = 0;</strong>
<strong class="bold">      }</strong>
      // ...
   };</pre> <p>You might notice that this constructor does two things: it grabs the data members from <code>other</code>, and then replaces the members of <code>other</code> with default values. That’s the posterchild for <code>std::exchange()</code>, so this constructor can be simplified as follows:</p>
<pre class="source-code">
template &lt;class T&gt;
   class fixed_size_array {
      T *elems{};
      std::size_t nelems{};
   public:
      // ...
<strong class="bold">      fixed_size_array(fixed_size_array &amp;&amp;other)</strong>
<strong class="bold">         : elems{ std::exchange(other.elems, nullptr) },</strong>
<strong class="bold">           nelems{ std::exchange(other.nelems, 0) } {</strong>
<strong class="bold">      }</strong>
      // ...
   };</pre> <p>With <code>std::exchange()</code>, this common<a id="_idIndexMarker963"/> two-step operation can be reduced to a function call, simplifying code and making it more efficient (in this case, turning assignments into constructor calls).</p>
</div>
</body></html>