<html><head></head><body>
<div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-207"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-208"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.2.1">Contemporary Issues</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We are reaching the end of our journey, dear reader. </span><span class="koboSpan" id="kobo.3.2">Over the course of this book, we have examined fundamental aspects of the C++ object model and discussed dangerous aspects of low-level programming. </span><span class="koboSpan" id="kobo.3.3">We have looked at the fundamentals of resource management in C++ through the RAII idiom, looked at how smart pointers are used, and explored how to write such a type. </span><span class="koboSpan" id="kobo.3.4">We also took control of the memory allocation functions at our disposal (and we did that in many ways!), and we wrote containers that manage memory themselves as well as through other objects or types, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">including allocators.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">That was quite </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">an experience!</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">What do we still have to cover? </span><span class="koboSpan" id="kobo.7.2">Well, so much… but there’s a limit to what we can put in a single book. </span><span class="koboSpan" id="kobo.7.3">So, to conclude our discussion of memory management in C++, I thought we might have a chat (yes, dear reader, just you and I) about some of the interesting topics in contemporary memory management in C++. </span><span class="koboSpan" id="kobo.7.4">Yes, things that were so recently standardized (as of this writing) that most, if not all, libraries still do not implement them, and things the standards committee is actively </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">working on.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">It’s important to look at C++ as it is today and how it might be in the near future because the language continues to evolve, and at quite a quick pace: a new version of the C++ standard is issued every three years, and this has been the case since 2011. </span><span class="koboSpan" id="kobo.9.2">The evolution of C++ is too slow for some and too quick for others, but it is unrelenting (we call this publishing rhythm the “train model” to highlight its sustained pace) and brings regular progress and innovation to this language that we love </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">so much.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">As of this writing, in the early weeks of 2025, C++23 is a freshly adopted standard, having been officialized in November 2024 (yes, I know: the ISO process does take some time), and the committee is discussing proposals meant for C++26 (yes, already!) </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and C++29.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">The memory management-related topics we will discuss in this chapter are either aspects of the C++23 standard that we have not discussed in this book yet or are some that, as this chapter is being written, are under discussion for upcoming standards. </span><span class="koboSpan" id="kobo.13.2">Be aware, dear reader, that what you will now read may become reality in the form you will read about, but it might also come along in another form after discussions and debates in the C++ standards committee… or it might, in the end, never come </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Even if these topics do not end up entering the C++ standard in the form in which they were initially discussed, you will know that they will have been discussed, along with the problems they were meant to solve, and that these features might become part of the language at some point. </span><span class="koboSpan" id="kobo.15.2">Who knows; maybe you will have an epiphany and find the words to turn one of these ideas into a proposal that the C++ standards committee will discuss, and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">then adopt.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Explicitly starting the lifetime of one or many objects without resorting to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">their constructors</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Trivial relocation: what it means and in what ways the standards committee is trying to </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">address it</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Type-aware allocation and deallocation functions: what they would do and how to benefit </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">from them</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.25.1">Our approach in this chapter will be to present these new features (or features-to-be) through the perspective of the problems we are trying to solve. </span><span class="koboSpan" id="kobo.25.2">The intent behind this approach is to make it clear that these features address actual issues and will help real programmers do their </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">jobs better.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">I hope this chapter will give you insights into an interesting (albeit non-exhaustive) set of contemporary issues in memory management and associated facilities as they pertain </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">to C++.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.29.1">A note on code examples for this chapter</span></p>
<p class="callout"><span class="koboSpan" id="kobo.30.1">If you try to compile the examples in this chapter, esteemed reader, you might find yourself saddened by the fact that some will not compile yet and others might not compile for a while, or ever. </span><span class="koboSpan" id="kobo.30.2">This situation is normal for a chapter such as this one: we will be discussing a combination of features that have been very recently added to the C++ language (recently enough that they have not yet been implemented at the time of authoring this book) and features that are under discussion by the C++ standards committee. </span><span class="koboSpan" id="kobo.30.3">Take the examples as illustrations, then, and adjust them as the features take a more </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">formal shape.</span></span></p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.32.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.33.1">You can find the code files for this chapter in the book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">repository: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.37.1">Starting object lifetime without constructors</span></h1>
<p><span class="koboSpan" id="kobo.38.1">Consider the</span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.39.1"> case of a program that consumes serialized data from a stream and that seeks to make objects from that data. </span><span class="koboSpan" id="kobo.39.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.41.1">
#include &lt;fstream&gt;
#include &lt;cstdint&gt;
#include &lt;array&gt;
#include &lt;memory&gt;
#include &lt;string_view&gt;
struct Point3D {
   float x{}, y{}, z{};
   Point3D() = default;
   constexpr Point3D(float x, float y, float z)
      : x{ x }, y{ y }, z{ z } {
   }
};
// ...
</span><span class="koboSpan" id="kobo.41.2">// reads at most N bytes from file named file_name and
// writes these bytes into buf. </span><span class="koboSpan" id="kobo.41.3">Returns the number of
// bytes read (postcondition: return value &lt;= N)
//
template &lt;int N&gt;
   int read_from_stream(std::array&lt;unsigned char, N&gt; &amp;buf,
                        std::string_view file_name) {
   // ...
</span><span class="koboSpan" id="kobo.41.4">}
// ...</span></pre> <p><span class="koboSpan" id="kobo.42.1">As </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.43.1">you can see, in this example, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">Point3D</span></strong><span class="koboSpan" id="kobo.45.1"> class. </span><span class="koboSpan" id="kobo.45.2">An object of this type represents a set of </span><em class="italic"><span class="koboSpan" id="kobo.46.1">x,y,z</span></em><span class="koboSpan" id="kobo.47.1"> coordinates. </span><span class="koboSpan" id="kobo.47.2">We also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">read_from_stream&lt;N&gt;()</span></strong><span class="koboSpan" id="kobo.49.1"> function that consumes bytes from a file. </span><span class="koboSpan" id="kobo.49.2">The function then stores at most </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">N</span></strong><span class="koboSpan" id="kobo.51.1"> bytes into argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">buf</span></strong><span class="koboSpan" id="kobo.53.1">, which is passed by reference and returns the number of bytes read (which might be zero but will never be more </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">than </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">N</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">For the sake of this example, we will suppose that the file from which we plan to read is known to contain the binary form of serialized </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">Point3D</span></strong><span class="koboSpan" id="kobo.59.1"> objects, equivalent to objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">float</span></strong><span class="koboSpan" id="kobo.61.1"> serialized in binary format by groups of three. </span><span class="koboSpan" id="kobo.61.2">Now, consider the following program, which consumes the byte representation of at most four objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">Point3D</span></strong><span class="koboSpan" id="kobo.63.1"> from a file </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">some_file.dat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
// ...
</span><span class="koboSpan" id="kobo.67.2">#include &lt;print&gt;
#include &lt;cassert&gt;
using namespace std::literals;
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.68.1">   static constexpr int NB_PTS = 4;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.69.1">   static constexpr int NB_BYTES =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.70.1">      NB_PTS * sizeof(Point3D);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.71.1">   alignas(Point3D)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.72.1">      std::array&lt;unsigned char, NB_BYTES&gt; buf{};</span></strong><span class="koboSpan" id="kobo.73.1">
   if (int n = read_from_stream&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.74.1">NB_BYTES</span></strong><span class="koboSpan" id="kobo.75.1">&gt;(
          buf, "some_file.dat"sv
       ); n != 0) {
      // print out the bytes: 0-filled left, 2
      // characters-wide, hex format
      for (int i = 0; i != n; ++i)
         std::print("{:0&lt;2x} ", buf[i]);
      std::println();
</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">      // if we want to treat the bytes as Point3D objects,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.77.1">      // we need to start the lifetime of these Point3D</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.78.1">      // objects. </span><span class="koboSpan" id="kobo.78.2">If we do not, we are in UB territory (it</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.79.1">      // might work or it might not, and even if it works</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.80.1">      // we cannot count on it)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.81.1">      const Point3D* pts =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.82.1">         std::start_lifetime_as_array(buf.data(), n);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.83.1">      assert(n % 3 == 0);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.84.1">      for (std::size_t i = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.85.1">           i != n / sizeof(Point3D); ++i)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.86.1">         std::print("{} {} {}\n",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.87.1">                    pts[i].x, pts[i].y, pts[i].z);</span></strong><span class="koboSpan" id="kobo.88.1">
   }
}</span></pre> <p><span class="koboSpan" id="kobo.89.1">This example</span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.90.1"> program reads bytes from a file into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">std::array</span></strong><span class="koboSpan" id="kobo.92.1"> object big enough to contain the bytes of four objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Point3D</span></strong><span class="koboSpan" id="kobo.94.1">, having first ensured that this array would be aligned appropriately if it were to hold objects of that type. </span><span class="koboSpan" id="kobo.94.2">This alignment consideration is essential as we plan to treat the bytes as objects of that type once those bytes have </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">been read.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">The </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.97.1">point of this example is that once the bytes have been read, the programmer is confident (well, as confident as one could be) that </span><em class="italic"><span class="koboSpan" id="kobo.98.1">all the bytes are correct</span></em><span class="koboSpan" id="kobo.99.1"> for some hypothetical </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">Point3D</span></strong><span class="koboSpan" id="kobo.101.1"> objects but still cannot use these objects as </span><em class="italic"><span class="koboSpan" id="kobo.102.1">their lifetime has not </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.103.1">yet started</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">This sort of situation traditionally makes many C programmers smile and some C++ programmers cringe: the C++ object model imposes constraints on programs that make it </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">UB</span></strong><span class="koboSpan" id="kobo.107.1"> (see </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.108.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.109.1">) to use objects outside of their lifetime, even if all the bytes are right and alignment constraints have been respected, whereas C is less restrictive. </span><span class="koboSpan" id="kobo.109.2">To use the contents of the buffer we just used to read from that file, our options are traditionally </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.111.1">To loop through the array of bytes, write appropriately-sized subsets of those bytes into objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">float</span></strong><span class="koboSpan" id="kobo.113.1">, then call the constructors of </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Point3D</span></strong><span class="koboSpan" id="kobo.115.1"> objects and put them in </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">another container.</span></span></li>
<li><span class="koboSpan" id="kobo.117.1">To </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.119.1"> the array of bytes into an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Point3D</span></strong><span class="koboSpan" id="kobo.121.1"> objects and hope for the best, leading to code that might or might not work and, being UB, would not be portable anyway (not even between versions of a given compiler). </span><span class="koboSpan" id="kobo.121.2">With our </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Point3D</span></strong><span class="koboSpan" id="kobo.123.1"> objects, it will probably give the results one would hope for, but replace these with, say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">std::complex&lt;float&gt;</span></strong><span class="koboSpan" id="kobo.125.1"> objects from the standard library (a type that probably has a similar inner structure as our </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Point3D</span></strong><span class="koboSpan" id="kobo.127.1"> type) and… well, who knows what </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">might happen?</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">To </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.131.1"> the array of bytes into itself, casting the return value to type </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Point3D*</span></strong><span class="koboSpan" id="kobo.133.1"> and using the resulting pointer as if it were an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Point3D</span></strong><span class="koboSpan" id="kobo.135.1"> objects. </span><span class="koboSpan" id="kobo.135.2">That’s actually valid (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.137.1"> function is part of a select set of functions that are allowed to start the lifetime of objects). </span><span class="koboSpan" id="kobo.137.2">There is, of course, the risk of creating an actual copy of the bytes (which would be wasted execution time); some standard libraries are said to recognize that pattern and just behave as if the call was a no-op, but a special kind of no-op that can start the lifetime </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">of objects.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.139.1">None of</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.140.1"> these options seems truly satisfactory, however, so a cleaner solution that does not rely on compiler-specific optimizations is needed. </span><span class="koboSpan" id="kobo.140.2">To that effect, the C++23 standard introduces a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">constexpr</span></strong><span class="koboSpan" id="kobo.142.1"> functions (accompanied by a number of overloads) that are called </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">std::start_lifetime_as_array&lt;T&gt;(p,n)</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">std::start_lifetime_as&lt;T&gt;(p)</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">Both are portable forms of magical no-op functions that inform the compiler that the bytes are OK and to consider the lifetime of the pointees as </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">having begun.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">Of course, if for some reason the pointees have non-trivial destructors, you should make sure that your code calls these destructors when appropriate. </span><span class="koboSpan" id="kobo.148.2">Expect this situation to be rare and unusual. </span><span class="koboSpan" id="kobo.148.3">Since we consumed raw bytes from some source of data and turned these bytes into objects, the probability that the resulting objects own resources is somewhat slim. </span><span class="koboSpan" id="kobo.148.4">Of course, these objects can acquire resources once their lifetimes have begun. </span><span class="koboSpan" id="kobo.148.5">Let’s be honest, dear reader; C++ programmers are nothing if </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">not creative!</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">This set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">std::start_lifetime_...</span></strong><span class="koboSpan" id="kobo.152.1"> functions is expected to be a boon to network programmers everywhere, in particular. </span><span class="koboSpan" id="kobo.152.2">These individuals often receive data frames of well-formed byte sequences that they need to turn into objects for the purpose of further processing. </span><span class="koboSpan" id="kobo.152.3">These functions are also expected to be useful to programs that consume bytes from files in order to form aggregates. </span><span class="koboSpan" id="kobo.152.4">Many programmers think that just reading bytes into an array of bytes and casting that array to an intended type (or array thereof) suffices to get access to the (hypothetical) object (or objects) therein and are surprised when their C++ code starts behaving unexpectedly. </span><span class="koboSpan" id="kobo.152.5">C++ is a systems programming language, and the set made of these </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">std::start_lifetime_...</span></strong><span class="koboSpan" id="kobo.154.1"> functions closes a gap where it could be said to </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">be underperforming.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Of course, these functions form a very sharp toolset due to the risks involved: non-trivially destructible objects whose lifetime starts this way are especially suspicious, and you have to be highly trusting of whatever facility provided the bytes in which an object’s lifetime is manually and explicitly started. </span><span class="koboSpan" id="kobo.156.2">Thus, these facilities should be used with </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">utmost care.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">A note to complete this section: as of this writing, no major compiler yet implements these functions, even though they have been standardized and are part of C++23. </span><span class="koboSpan" id="kobo.158.2">Maybe they will be implemented by the time you get to read this, </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">who knows?</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.160.1">Trivial relocation</span></h1>
<p><span class="koboSpan" id="kobo.161.1">As you know, dear reader, C++ is known in the </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.162.1">programming community as one of those languages that we use when we need to get the most out of our computer or whatever hardware platform interests us. </span><span class="koboSpan" id="kobo.162.2">Some of the language’s credos can be paraphrased as “you shall not pay for what you do not use” and “there shall be no room for a lower-level language (except for the occasional bit of assembly code)”, after all. </span><span class="koboSpan" id="kobo.162.3">The latter explains the importance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">std::start_lifetime_...</span></strong><span class="koboSpan" id="kobo.164.1"> functions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">previous section.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">That’s probably why, when it becomes evident that we could do even better than we are already doing in terms of execution speed, that becomes a subject of interest to the C++ programmer community in general, and more specifically to members of the C++ standards committee. </span><span class="koboSpan" id="kobo.166.2">We all take these core credos of the language </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">to heart.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">One case where we could do better is when we encounter types for which moving a source object to a destination object, followed by destroying the original object, could in practice be replaced by a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.170.1">: directly copying an array of bytes is faster than performing a series of moves and destructors (and if it isn’t, there’s probably some work required on your </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.172.1"> implementation), even though move assignments and destructors make for a </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">fast combination.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">It turns out that there are many types for which such an optimization could be considered, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">std::string</span></strong><span class="koboSpan" id="kobo.176.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">std::any</span></strong><span class="koboSpan" id="kobo.178.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">std::optional&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.180.1"> (depending on what type </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">T</span></strong><span class="koboSpan" id="kobo.182.1"> is), classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Point3D</span></strong><span class="koboSpan" id="kobo.184.1"> from the previous section, any type that does not define any of the six special member functions seen in </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.185.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.186.1"> (including fundamental types), and </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">To understand the impact, consider the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">resize()</span></strong><span class="koboSpan" id="kobo.190.1"> free function, which mimics a </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">C::resize()</span></strong><span class="koboSpan" id="kobo.192.1"> member function for some container, </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">C</span></strong><span class="koboSpan" id="kobo.194.1">, that manages contiguous memory such as our </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.196.1"> type in the various incarnations seen in this book. </span><span class="koboSpan" id="kobo.196.2">This function resizes </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">arr</span></strong><span class="koboSpan" id="kobo.198.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">old_cap</span></strong><span class="koboSpan" id="kobo.200.1"> (the old capacity) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">new_cap</span></strong><span class="koboSpan" id="kobo.202.1"> (the new capacity), filling the space at the end with default </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">T</span></strong><span class="koboSpan" id="kobo.204.1"> objects. </span><span class="koboSpan" id="kobo.204.2">The highlighted lines of the function are what interests </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">us here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
//
// This is not a good function interface, but we want to
// keep the example relatively simple
//
template &lt;class T&gt;
  void resize
    (T *&amp;arr, std::size_t old_cap, std::size_t new_cap) {
    //
    // we could deal with throwing a default constructor
    // but it would complicate our code a bit and these
    // added complexities, worthwhile as they are, are
    // besides the point for what we are discussing here
    //
    static_assert(
      std::is_nothrow_default_contructible_v&lt;T&gt;
    );
    //
    // sometimes, there's just nothing to do
    //
    if(new_cap &lt;= old_cap) return arr;
    //
    // allocate a chunk of raw memory (no object created)
    //
    auto p = static_cast&lt;T*&gt;(
      std::malloc(new_cap * sizeof(T))
    );
    if(!p) throw std::bad_alloc{};
    // ...</span></pre> <p><span class="koboSpan" id="kobo.207.1">At this point, we are ready to</span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.208.1"> copy (or </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">move) objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
    // ...
</span><span class="koboSpan" id="kobo.210.2">    //
    // if move assignment does not throw, be aggressive
    //
    </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.212.1">      std::uninitialized_move(arr, arr + old_cap, p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.213.1">      std::destroy(arr, arr + old_cap);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.214.1">    }</span></strong><span class="koboSpan" id="kobo.215.1"> else {
      //
      // since move assignment could throw, let's be
      // conservative and copy instead
      //
      try {
        std::uninitialized_copy(arr, arr + old_cap, p);
        std::destroy(arr, arr + old_cap);
      } catch (...) {
        std::free(p);
        throw;
      }
    }
    //
    // fill the remaining space with default objects
    // (remember: we statically asserted that T::T() is
    // non-throwing)
    //
    std::uninitialized_default_construct(
      p + old_cap, p + new_cap
    );
    //
    // replace the old memory block (now without objects)
    // with the new one
    //
    std::free(arr);
    arr = p;
  }</span></pre> <p><span class="koboSpan" id="kobo.216.1">Looking at the highlighted lines of that function, even though the combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">std::uninitialized_move()</span></strong><span class="koboSpan" id="kobo.218.1"> followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">std::destroy()</span></strong><span class="koboSpan" id="kobo.220.1"> makes for a fast path, we could be even faster than this and replace a linear number of move assignment operators followed by a linear number of destructor calls with a single call </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">std::memcpy()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">How do we achieve this? </span><span class="koboSpan" id="kobo.224.2">Well, there are many competing proposals by Arthur O’Dwyer, Mingxin Wang, Alisdair Meredith, and Mungo Gill, among others. </span><span class="koboSpan" id="kobo.224.3">Each of these proposals has merits, but these proposals </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.225.1">have in common the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">following factors:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.227.1">Providing a way to test a type for “trivial relocatability” at compile time, for example, a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">std::is_trivially_relocatable_v&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1"> trait.</span></span></li>
<li><span class="koboSpan" id="kobo.230.1">Providing a function that actually relocates the objects, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">std::relocate()</span></strong><span class="koboSpan" id="kobo.232.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">std::trivially_relocate()</span></strong><span class="koboSpan" id="kobo.234.1">, which take a source pointer and a destination pointer as arguments and relocate the source object to the destination location, concluding the lifetime of the original object and then starting the lifetime of the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">new one</span></span></li>
<li><span class="koboSpan" id="kobo.236.1">Providing a way to mark a type as being trivially relocatable, for example through a keyword or </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">an attribute</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">Providing rules to deduce trivial relocatability for a type at </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">compile time</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.240.1">The details can vary </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.241.1">depending on the approach, but if we suppose these tools, the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">resize()</span></strong><span class="koboSpan" id="kobo.243.1"> function could benefit from trivial relocation by a slight adjustment to the previously </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">presented implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
template &lt;class T&gt;
   void resize
     (T * &amp;arr, std::size_t old_cap, std::size_t new_cap) {
      static_assert(
         std::is_nothrow_default_contructible_v&lt;T&gt;
      );
      if(new_cap &lt;= old_cap) return arr;
      auto p = static_cast&lt;T*&gt;(
         std::malloc(new_cap * sizeof(T))
      );
      if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.246.1">      //</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.247.1">      // this is our ideal case</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.248.1">      //</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.249.1">      if constexpr (std::is_trivially_relocatable_v&lt;T&gt;) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.250.1">         // equivalent to memcpy() plus consider the</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">         // lifetime of objects in [arr, arr + old_cap)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.252.1">         // finished and the lifetime of objects in</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.253.1">         // [p, p + old_cap) started</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.254.1">         //</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.255.1">         // note: this supposes that the trait</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.256.1">         // std::is_trivially_relocatable&lt;T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.257.1">         // implies std::is_trivially_destructible&lt;T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.258.1">         std::relocate(arr, arr + old_cap, p);</span></strong><span class="koboSpan" id="kobo.259.1">
      //
      // if move assignment does not throw, be aggressive
      //
      } else if constexpr(
           std::is_nothrow_move_assignable_v&lt;T&gt;
      ){
         std::uninitialized_move(arr, arr + old_cap, p);
         std::destroy(arr, arr + old_cap);
      } else {
</span><strong class="bold"><span class="koboSpan" id="kobo.260.1">         // ... </span><span class="koboSpan" id="kobo.260.2">see previous code example for the rest</span></strong><span class="koboSpan" id="kobo.261.1">
      }
   }</span></pre> <p><span class="koboSpan" id="kobo.262.1">This seemingly simple </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.263.1">optimization has been reported to provide considerable benefits, with some having claimed up to 30% speedup in common cases, but this is experimental work, and more benchmarks are expected to come if proposals coalesce (as we expect them to) into something that will be integrated into the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">C++ standard.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Such potential speedups are part of what the C++ language aims to make possible, so we can reasonably expect trivial relocatability to become reality in the foreseeable future. </span><span class="koboSpan" id="kobo.265.2">The question is “how”: how should compilers detect the trivial relocatability property? </span><span class="koboSpan" id="kobo.265.3">How should programmers be able to indicate that property on their own types when the default trivial relocatability deduction</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.266.1"> rules are </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">not met?</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">As of February 2025, the standard committee voted trivial relocation into what will become C++26 standard. </span><span class="koboSpan" id="kobo.268.2">This means we can expect that some programs that compiled with previous standards of the C++ language and are recompiled with C++26 could just run faster without changing a single line of </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">source code.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.270.1">Type-aware allocation and deallocation functions</span></h1>
<p><span class="koboSpan" id="kobo.271.1">Our last topic for this chapter </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.272.1">on new approaches to memory management </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.273.1">and optimization opportunities that pertain to object lifetime is type-aware allocation and deallocation functions. </span><span class="koboSpan" id="kobo.273.2">This is a novel approach to allocation functions for cases where user code might want to somehow use information with respect to what type is undergoing allocation (and eventual construction) to guide the </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">allocation process.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">We saw one facet of such features in </span><a href="B21071_09.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.276.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.277.1"> when describing the </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">destroying delete</span></strong><span class="koboSpan" id="kobo.279.1"> mechanism</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.280.1"> made possible by C++20, where a member-function version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">T::operator delete()</span></strong><span class="koboSpan" id="kobo.282.1"> is passed </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">T*</span></strong><span class="koboSpan" id="kobo.284.1"> instead of the abstract </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">void*</span></strong><span class="koboSpan" id="kobo.286.1"> as an argument, and is for that reason made responsible for both the finalization of the object and the deallocation of its underlying storage. </span><span class="koboSpan" id="kobo.286.2">We saw that there are cases where this reveals interesting </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">optimization opportunities.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">What is under discussion for C++26 is a new family of </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">operator new()</span></strong><span class="koboSpan" id="kobo.290.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">operator delete()</span></strong><span class="koboSpan" id="kobo.292.1"> member functions, as well as free functions that take a </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.294.1"> object as the first argument for some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">T</span></strong><span class="koboSpan" id="kobo.296.1">, guiding the selected operator towards some specialized behavior for that type </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">T</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">Note that these type-aware allocation functions are really allocation functions: they do not perform construction, nor does their deallocation counterpart </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">perform finalization.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.300.1">What is the std::type_identity&lt;T&gt; trait?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.301.1">The expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">typename std::type_identity&lt;T&gt;::type</span></strong><span class="koboSpan" id="kobo.303.1"> corresponds to </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">T</span></strong><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">OK, that seems trivial enough. </span><span class="koboSpan" id="kobo.305.3">So, what role does this trait play in contemporary C++ programming? </span><span class="koboSpan" id="kobo.305.4">It happens that trait </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.307.1">, introduced with C++20, is a tool that is typically used to provide additional control over argument type deduction in </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">generic functions.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.309.1">For example, with the function signature </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">template &lt;class T&gt; void f(T,T)</span></strong><span class="koboSpan" id="kobo.311.1">, you could call </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">f(3,3)</span></strong><span class="koboSpan" id="kobo.313.1"> as both arguments are of the same type, but not </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">f(3,3.0)</span></strong><span class="koboSpan" id="kobo.315.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">int</span></strong><span class="koboSpan" id="kobo.317.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">double</span></strong><span class="koboSpan" id="kobo.319.1"> are distinct types. </span><span class="koboSpan" id="kobo.319.2">That being said, by replacing either argument type with </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">std::type_identity_t&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.321.1">, you could call </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">f(3,3.0)</span></strong><span class="koboSpan" id="kobo.323.1">, and since </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">T</span></strong><span class="koboSpan" id="kobo.325.1"> would be deduced with the other argument (the one of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">T</span></strong><span class="koboSpan" id="kobo.327.1">), that type would be used for the other (the argument for which the type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">std::type_identity_t&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.329.1">). </span><span class="koboSpan" id="kobo.329.2">That would lead to both arguments being </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">int</span></strong><span class="koboSpan" id="kobo.331.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">double</span></strong><span class="koboSpan" id="kobo.333.1">, depending on which argument is of </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.337.1">The idea of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.339.1"> (not </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">std::type_identity_t&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.341.1">) instead of plain </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">T</span></strong><span class="koboSpan" id="kobo.343.1"> as the type of the first argument in type-aware allocation functions is to make it clear that we are using this specific specialized overload of </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">operator new()</span></strong><span class="koboSpan" id="kobo.345.1"> and that this is not an accident or a call to some other specialized form of this allocation function, such as those described in </span><a href="B21071_09.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.346.1">Chapter 9</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">This means that you </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.349.1">could provide specialized allocation functions for </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.350.1">a specific class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">X</span></strong><span class="koboSpan" id="kobo.352.1">, through the following </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">function signatures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
#include &lt;new&gt;
#include &lt;type_traits&gt;
void* operator new(</span><strong class="bold"><span class="koboSpan" id="kobo.355.1">std::type_identity&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.356.1">, std::size_t n);
void operator delete(</span><strong class="bold"><span class="koboSpan" id="kobo.357.1">std::type_identity&lt;X&gt;</span></strong><span class="koboSpan" id="kobo.358.1">, void* p);</span></pre> <p><span class="koboSpan" id="kobo.359.1">In such cases, when calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">new X</span></strong><span class="koboSpan" id="kobo.361.1">, for example, the specialized form will be preferred to the usual form of </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">operator new()</span></strong><span class="koboSpan" id="kobo.363.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">operator delete()</span></strong><span class="koboSpan" id="kobo.365.1">, being assumed to be more appropriate unless the programmer takes steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">prevent it.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">It also means that, given a specialized allocation algorithm that applies to type </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">T</span></strong><span class="koboSpan" id="kobo.369.1"> only if </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">special_alloc_alg&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.371.1"> is satisfied, you could provide allocation functions that use this specialized algorithm for type </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">T</span></strong><span class="koboSpan" id="kobo.373.1"> through the following </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">function signatures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
#include &lt;new&gt;
#include &lt;type_traits&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.376.1">template &lt;class T&gt; requires special_alloc_alg&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.377.1">
  void* operator new(</span><strong class="bold"><span class="koboSpan" id="kobo.378.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.379.1">, std::size_t n);
</span><strong class="bold"><span class="koboSpan" id="kobo.380.1">template &lt;class T&gt; requires special_alloc_alg&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.381.1">
  void operator delete(</span><strong class="bold"><span class="koboSpan" id="kobo.382.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.383.1">, void* p);</span></pre> <p><span class="koboSpan" id="kobo.384.1">This </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.385.1">provides new avenues for optimizations such as </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.386.1">those described in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.387.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.388.1">, for example. </span><span class="koboSpan" id="kobo.388.2">Consider this simple example where we have a cool allocation algorithm for types </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">X</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Y</span></strong><span class="koboSpan" id="kobo.392.1">, but that algorithm does not apply to other classes, such </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Z</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
#include &lt;concepts&gt;
#include &lt;type_traits&gt;
class X { /* ... </span><span class="koboSpan" id="kobo.396.2">*/ };
class Y { /* ... </span><span class="koboSpan" id="kobo.396.3">*/ };
class Z { /* ... </span><span class="koboSpan" id="kobo.396.4">*/ };
</span><strong class="bold"><span class="koboSpan" id="kobo.397.1">template &lt;class C&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.398.1">   concept cool_alloc_algorithm =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.399.1">      std::is_same_v&lt;C, X&gt; || std::is_same_v&lt;C, Y&gt;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.400.1">template &lt;class T&gt; requires cool_alloc_algorithm&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.401.1">
  void* operator new(</span><strong class="bold"><span class="koboSpan" id="kobo.402.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.403.1">, std::size_t n){
</span><strong class="bold"><span class="koboSpan" id="kobo.404.1">     // apply the cool allocation algorithm</span></strong><span class="koboSpan" id="kobo.405.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.406.1">template &lt;class T&gt; requires cool_alloc_algorithm&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.407.1">
  void operator delete(</span><strong class="bold"><span class="koboSpan" id="kobo.408.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.409.1">, void* p) {
</span><strong class="bold"><span class="koboSpan" id="kobo.410.1">     // apply the cool deallocation algorithm</span></strong><span class="koboSpan" id="kobo.411.1">
  }
#include &lt;memory&gt;
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.412.1">   // uses the "cool" allocation algorithm</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.413.1">   auto p = std::make_unique&lt;X&gt;();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.414.1">   // uses the standard allocation algorithm</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.415.1">   auto q = std::make_unique&lt;Z&gt;();</span></strong><span class="koboSpan" id="kobo.416.1">
} </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">// uses the standard deallocation algorithm for q</span></strong><span class="koboSpan" id="kobo.418.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">// uses the "cool" deallocation algorithm for p</span></strong></pre> <p><span class="koboSpan" id="kobo.420.1">The type-aware</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.421.1"> allocation functions can also be member function</span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.422.1"> overloads, leading to algorithms that apply to the class where these functions are defined, as well as to derived </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">classes thereof.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Consider the following example, inspired by a more complex example found in the proposal for the feature that is described </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">at </span></span><a href="https://wg21.link/p2719"><span class="No-Break"><span class="koboSpan" id="kobo.426.1">https://wg21.link/p2719</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.427.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.428.1">class D0; // forward class declaration</span></strong><span class="koboSpan" id="kobo.429.1">
struct B {
</span><strong class="bold"><span class="koboSpan" id="kobo.430.1">  // i)</span></strong><span class="koboSpan" id="kobo.431.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">template &lt;class T&gt;</span></strong><span class="koboSpan" id="kobo.433.1">
  void* operator new(</span><strong class="bold"><span class="koboSpan" id="kobo.434.1">std::type_identity&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.435.1">, std::size_t);
</span><strong class="bold"><span class="koboSpan" id="kobo.436.1">  // ii)</span></strong><span class="koboSpan" id="kobo.437.1">
  void* operator new(</span><strong class="bold"><span class="koboSpan" id="kobo.438.1">std::type_identity&lt;D0&gt;</span></strong><span class="koboSpan" id="kobo.439.1">, std::size_t);
};
// ...</span></pre> <p><span class="koboSpan" id="kobo.440.1">As expressed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">i)</span></strong><span class="koboSpan" id="kobo.442.1"> applies to </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">B</span></strong><span class="koboSpan" id="kobo.444.1"> and its derived classes, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">ii)</span></strong><span class="koboSpan" id="kobo.446.1"> applies to the specific case of the forward-declared class </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">D0</span></strong><span class="koboSpan" id="kobo.448.1"> and will only be used if </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">D0</span></strong><span class="koboSpan" id="kobo.450.1"> is indeed a derived class </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Continuing this example, we now add three classes that each derive from </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">B</span></strong><span class="koboSpan" id="kobo.456.1">, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">D2</span></strong><span class="koboSpan" id="kobo.458.1"> adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">iii)</span></strong><span class="koboSpan" id="kobo.460.1">, which is a non-type-aware member function overload of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
// ...
</span><span class="koboSpan" id="kobo.463.2">struct D0 : B { };
struct D1 : B { };
struct D2 : B {
</span><strong class="bold"><span class="koboSpan" id="kobo.464.1">  // iii)</span></strong><span class="koboSpan" id="kobo.465.1">
  void *operator new(std::size_t);
};
// ...</span></pre> <p><span class="koboSpan" id="kobo.466.1">Given these overloads, here are some examples of expressions calling overloads </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">i)</span></strong><span class="koboSpan" id="kobo.468.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">ii)</span></strong><span class="koboSpan" id="kobo.470.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">iii)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
// ...
</span><span class="koboSpan" id="kobo.474.2">void f() {
  new B;       // i) where T is B
  new D0;      // ii)
  new D1;      // i) where T is D1
  new D2;      // iii)
  ::new B;     // uses appropriate global operator new
}</span></pre> <p><span class="koboSpan" id="kobo.475.1">As you can see, dear </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.476.1">reader, type-aware allocation functions will, if</span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.477.1"> accepted into the C++ standard, provide new ways to control what memory allocation algorithm will be used (depending on the circumstances) while still leaving user code in control, leaving it able to defer to the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">operator new()</span></strong><span class="koboSpan" id="kobo.479.1"> function if that is the preferred option, as the last line of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">f()</span></strong><span class="koboSpan" id="kobo.481.1"> function in the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">example shows.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">Contrary to the destroying delete feature of C++20, which performs both the finalization of the object and the deallocation of the underlying storage, the type-aware versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">operator new()</span></strong><span class="koboSpan" id="kobo.485.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">operator delete()</span></strong><span class="koboSpan" id="kobo.487.1"> are only allocation functions, and as of this writing, there is no plan to provide a type-aware version of </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">destroying delete.</span></span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.489.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.490.1">In this chapter, we have had a glimpse of the future with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">std::start_lifetime_...</span></strong><span class="koboSpan" id="kobo.492.1"> functions that are part of C++23 but, as of this writing, have not been implemented by any major compiler. </span><span class="koboSpan" id="kobo.492.2">We have also looked at probable (but not yet official) parts of the future of C++ with the potential support of trivial relocatability and the possibility of introducing type-aware versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">operator new()</span></strong><span class="koboSpan" id="kobo.494.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">operator delete()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">With every step, C++ becomes a richer and more versatile language with which we can do more and express our ideas in more precise ways. </span><span class="koboSpan" id="kobo.497.2">C++ is a language that provides ever more significant control over the behavior of our programs. </span><span class="koboSpan" id="kobo.497.3">As powerful as C++ is today, and as powerful as it makes programmers like us, this chapter shows we can still continue to </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">get better.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">We are at the end of our journey, at least for now. </span><span class="koboSpan" id="kobo.499.2">I hope the trip was just eventful enough to be pleasant and entertaining to you, esteemed reader, and that you have learned a thing or two along the way. </span><span class="koboSpan" id="kobo.499.3">I also hope that some of the ideas discussed here will help you in your tasks and enrich your perspective of </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">C++ programming.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Thanks for accompanying me. </span><span class="koboSpan" id="kobo.501.2">I hope the journeys ahead for you will be enjoyable, just as I hope this book will make your toolbox better and that you will continue exploring on your own. </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">Safe travels.</span></span></p>
</div>


<div id="_idContainer048">
<h1 class="chapter-number" id="_idParaDest-214"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.1.1">Annexure: </span></h1>
<h1 id="_idParaDest-215"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.2.1">Things You Should Know</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This book supposes readers possess some technical background that some might not consider to be "common knowledge". </span><span class="koboSpan" id="kobo.3.2">In the following sections, you might find the complementary information that will help you get the most out of this book. </span><span class="koboSpan" id="kobo.3.3">Refer to it as needed, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and enjoy!</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Feel free to skim through the following sections if you think you know their contents well and take a closer look at those you’re less comfortable with. </span><span class="koboSpan" id="kobo.5.2">You could even skip this entire section and come back if you realize while reading this book that these topics are not things you know as well as you thought </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">you did.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The overall goal is to get the most out of this book </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">after all!</span></span></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.9.1">struct and class</span></h1>
<p><span class="koboSpan" id="kobo.10.1">In C++, the </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.11.1">words </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">struct</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">class</span></strong><span class="koboSpan" id="kobo.15.1"> essentially</span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.16.1"> mean the same thing, and code such as the following is </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">perfectly legal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.18.1">
struct Drawable {
   virtual void draw() = 0;
   virtual ~Drawable() = default;
};
class Painting : public Drawable {
   void draw() override;
};</span></pre> <p><span class="koboSpan" id="kobo.19.1">Here are some details </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">to note:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">C++ has no </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">abstract</span></strong><span class="koboSpan" id="kobo.23.1"> keyword like some other languages do. </span><span class="koboSpan" id="kobo.23.2">An abstract member function in C++ is </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">virtual</span></strong><span class="koboSpan" id="kobo.25.1"> and has </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">=0</span></strong><span class="koboSpan" id="kobo.27.1"> instead of a definition. </span><span class="koboSpan" id="kobo.27.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">virtual</span></strong><span class="koboSpan" id="kobo.29.1"> keyword means </span><em class="italic"><span class="koboSpan" id="kobo.30.1">can be specialized by derived classes</span></em><span class="koboSpan" id="kobo.31.1"> (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">=0</span></strong><span class="koboSpan" id="kobo.33.1"> part essentially means </span><em class="italic"><span class="koboSpan" id="kobo.34.1">must be specialized…</span></em><span class="koboSpan" id="kobo.35.1">). </span><span class="koboSpan" id="kobo.35.2">We often talk </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.36.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">overriding</span></strong><span class="koboSpan" id="kobo.38.1"> the function when specializing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">virtual</span></strong><span class="koboSpan" id="kobo.40.1"> member function. </span><span class="koboSpan" id="kobo.40.2">Functions that must be overridden are said to </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.41.1">be </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">pure </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.43.1">virtual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1"> functions.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.45.1">Providing a default implementation for a pure virtual function</span></p>
<p class="callout"><span class="koboSpan" id="kobo.46.1">One can provide a definition for an abstract member function: it’s not typical, but it’s possible. </span><span class="koboSpan" id="kobo.46.2">That can be useful in cases where the base class wants to provide a default implementation of a service but requires that the derived classes at least consider providing their own. </span><span class="koboSpan" id="kobo.46.3">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">an example:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">#</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">include &lt;iostream&gt;</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">struct X { virtual int f() const = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">0; };</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">int X::f() const { return </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">3; }</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">struct D : X { int f() const </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">override {</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">   return X::f() + </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">1; }</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">};</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">void g(X &amp;x) { std::cout &lt;&lt; x.f() &lt;&lt; '\</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">n'; }</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">int </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">main() {</span></strong></span></p>
<p class="callout"><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">D d;</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">   // X x; // illegal: X has a pure virtual </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">member function</span></strong></span></p>
<p class="callout"><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">g(d);</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">}</span></strong></p>
<ul>
<li><span class="koboSpan" id="kobo.68.1">C++ classes </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.69.1">have destructors that handle what happens when an object reaches the end of its lifetime. </span><span class="koboSpan" id="kobo.69.2">Contrary to many other popular languages, automatic and static objects in C++ have deterministic lifetimes, and using destructors efficiently is idiomatic in that language. </span><span class="koboSpan" id="kobo.69.3">In</span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.70.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">polymorphic</span></strong><span class="koboSpan" id="kobo.72.1"> class (a class with at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">virtual</span></strong><span class="koboSpan" id="kobo.74.1"> member function), it is customary to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">virtual</span></strong><span class="koboSpan" id="kobo.76.1"> destructor (here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">virtual ~Drawable()</span></strong><span class="koboSpan" id="kobo.78.1">) to indicate that in a situation such as the following, destroying an object used through an indirection such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">p</span></strong><span class="koboSpan" id="kobo.80.1"> should effectively destroy the pointed-to object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Painting</span></strong><span class="koboSpan" id="kobo.82.1">), not the one denoted by the pointer’s static </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">type (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">Drawable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.86.1">
//
// the following supposes that Painting is a public
// derived class of Drawable as suggested earlier in
// this section
//
Drawable *p = new Painting;
// ...
</span><span class="koboSpan" id="kobo.86.2">delete p; // &lt;-- here</span></pre></li> <li><span class="koboSpan" id="kobo.87.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">class</span></strong><span class="koboSpan" id="kobo.89.1"> can derive from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">struct</span></strong><span class="koboSpan" id="kobo.91.1"> just as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">struct</span></strong><span class="koboSpan" id="kobo.93.1"> can derive from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">class</span></strong><span class="koboSpan" id="kobo.95.1"> as both are structurally</span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.96.1"> equivalent. </span><span class="koboSpan" id="kobo.96.2">The main differences are that for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">struct</span></strong><span class="koboSpan" id="kobo.98.1">, inheritance is </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">public</span></strong><span class="koboSpan" id="kobo.100.1"> by default (but that can be changed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">protected</span></strong><span class="koboSpan" id="kobo.102.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">private</span></strong><span class="koboSpan" id="kobo.104.1">) and the same goes for members, whereas for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">class</span></strong><span class="koboSpan" id="kobo.106.1">, inheritance and members are </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">private</span></strong><span class="koboSpan" id="kobo.108.1"> by default (but again, that can </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">be changed).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.110.1">Note, in passing, that it’s perfectly fine in C++ to have a member function with an access qualifier in the base class (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">Drawable::draw()</span></strong><span class="koboSpan" id="kobo.112.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">public</span></strong><span class="koboSpan" id="kobo.114.1">) and in a derived class (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Painting::draw()</span></strong><span class="koboSpan" id="kobo.116.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">private</span></strong><span class="koboSpan" id="kobo.118.1">). </span><span class="koboSpan" id="kobo.118.2">Some other popular languages do not </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">allow this.</span></span></p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.120.1">std::size_t</span></h1>
<p><span class="koboSpan" id="kobo.121.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">std::size_t</span></strong><span class="koboSpan" id="kobo.123.1"> is </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.124.1">an alias for some unsigned integral type, but the actual type can vary from compiler to compiler (it could be </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">unsigned int</span></strong><span class="koboSpan" id="kobo.126.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">unsigned long</span></strong><span class="koboSpan" id="kobo.128.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">unsigned long long</span></strong><span class="koboSpan" id="kobo.130.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">so on).</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">One frequently encounters type </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">std::size_t</span></strong><span class="koboSpan" id="kobo.134.1"> when discussing container sizes and the space occupied in memory by an object as expressed by </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">operator </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">sizeof</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">.</span></span></p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.138.1">The sizeof operator</span></h1>
<p><span class="koboSpan" id="kobo.139.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">sizeof</span></strong><span class="koboSpan" id="kobo.141.1"> operator </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.142.1">yields the size in bytes of an object or a type. </span><span class="koboSpan" id="kobo.142.2">It is evaluated at compile time and will be used extensively throughout this book as we will need that information to allocate properly sized blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">of memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
auto s0 = sizeof(int); // s0 is the number of bytes in an
                       // int (parentheses required)
int n;
auto s1 = sizeof n; // s1 is the number of bytes occupied
                    // by s1, which is identical to s0.
</span><span class="koboSpan" id="kobo.144.2">                    // Note: for objects, parentheses are
                    // allowed but not mandated</span></pre> <p><span class="koboSpan" id="kobo.145.1">Object size is one of the key components of memory management and influences the speed at which programs will execute. </span><span class="koboSpan" id="kobo.145.2">For that reason, it is a recurring theme throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">this book.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.147.1">Assertions</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.148.1">Assertions</span></strong><span class="koboSpan" id="kobo.149.1"> are statements </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.150.1">of fact that programmers think should be upheld by code. </span><span class="koboSpan" id="kobo.150.2">Some are dynamic, based on information known at runtime, for example, “</span><em class="italic"><span class="koboSpan" id="kobo.151.1">The following pointer should not be null at this point.</span></em><span class="koboSpan" id="kobo.152.1">” Others are static, based on information known at compile time, for example, “</span><em class="italic"><span class="koboSpan" id="kobo.153.1">This program has been written with the non-portable assumption that an </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">int</span></strong><em class="italic"><span class="koboSpan" id="kobo.155.1"> occupies four bytes of storage.</span></em><span class="koboSpan" id="kobo.156.1">” In the latter case, we have a program that has been written based on a non-portable assumption and we have to live with this choice, but we do not want our code to compile on platforms where that assumption does </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">not hold.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">For dynamic assertions, it is customary to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">assert()</span></strong><span class="koboSpan" id="kobo.160.1"> macro from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">&lt;cassert&gt;</span></strong><span class="koboSpan" id="kobo.162.1"> header. </span><span class="koboSpan" id="kobo.162.2">That macro takes as argument a boolean expression and halts program execution if it evaluates </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.166.1">
void f(int *p) {
   assert(p); // we hold p != nullptr to be true
   // use *p
}</span></pre> <p><span class="koboSpan" id="kobo.167.1">Note that many projects </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.168.1">disable </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">assert()</span></strong><span class="koboSpan" id="kobo.170.1"> from production code, something that can be done by defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">NDEBUG</span></strong><span class="koboSpan" id="kobo.172.1"> macro before compilation. </span><span class="koboSpan" id="kobo.172.2">As such, make sure never to put expressions with side effects in </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">assert()</span></strong><span class="koboSpan" id="kobo.174.1"> as it might be removed by </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">compiler options:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
int *obtain_buf(int);
void danger(int n) {
   int *p; // uninitialized
</span><strong class="bold"><span class="koboSpan" id="kobo.177.1">   assert(p = obtain_buf(n)); // dangerous!!!</span></strong><span class="koboSpan" id="kobo.178.1">
   // use *p, but p might be uninitialized if assert()
   // has been disabled. </span><span class="koboSpan" id="kobo.178.2">This is very bad
}</span></pre> <p><span class="koboSpan" id="kobo.179.1">Contrary to </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">assert()</span></strong><span class="koboSpan" id="kobo.181.1">, which is a library macro, </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">static_assert</span></strong><span class="koboSpan" id="kobo.183.1"> is a language feature that prevents compilation if its condition is not met. </span><span class="koboSpan" id="kobo.183.2">Based on the example mentioned previously where a company might have built software based on a non-portable assumption such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.185.1">, we could make sure that code does not compile (and do bad things) for platforms that are not </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">really supported:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
static_assert(sizeof(int)==4); // only compiles if the
                               // condition holds</span></pre> <p><span class="koboSpan" id="kobo.188.1">Fixing bugs before</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.189.1"> shipping a software product is significantly better for developers and users alike than fixing bugs after the software has been sent “in the wild.” </span><span class="koboSpan" id="kobo.189.2">Consequently, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">static_assert</span></strong><span class="koboSpan" id="kobo.191.1"> can be seen as a powerful tool for delivering </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">higher-quality products.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">In this book, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">static_assert</span></strong><span class="koboSpan" id="kobo.195.1"> regularly: it has no runtime cost and documents our assertions in a verifiable manner. </span><span class="koboSpan" id="kobo.195.2">It’s the sort of feature that essentially has </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">no downsides.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.197.1">Undefined behavior</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.198.1">Undefined behavior</span></strong><span class="koboSpan" id="kobo.199.1">, often</span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.200.1"> abbreviated to </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">UB</span></strong><span class="koboSpan" id="kobo.202.1">, results from a situation in which the standard does not prescribe a specific behavior. </span><span class="koboSpan" id="kobo.202.2">In the C++ standard, UB is behavior for which no requirements are imposed. </span><span class="koboSpan" id="kobo.202.3">It can lead to the problem being ignored, just as it can lead to a diagnostic or program termination. </span><span class="koboSpan" id="kobo.202.4">The key idea is that if your program has undefined behavior, then it’s not playing by the rules of the language and is broken; its behavior is not guaranteed on your platform, it’s not portable between platforms or compilers, and it cannot be </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">relied upon.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">A correctly written C++ program has no undefined behavior. </span><span class="koboSpan" id="kobo.204.2">When faced with a function that contains undefined behavior, the compiler can do just about anything with the code in that function, which makes reasoning from source code </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">essentially impossible.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Undefined behavior is one of the preeminent “things to be careful with” listed in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.207.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">Strive to avoid undefined behavior: it always comes back to bite you if you leave </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">it in.</span></span></p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.210.1">Type traits</span></h1>
<p><span class="koboSpan" id="kobo.211.1">Over the years, C++ programmers have developed various techniques to reason about the properties of their types, mostly at compile time. </span><span class="koboSpan" id="kobo.211.2">Inferring such things as </span><em class="italic"><span class="koboSpan" id="kobo.212.1">“Is the </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">T</span></strong><em class="italic"><span class="koboSpan" id="kobo.214.1"> type const?</span></em><span class="koboSpan" id="kobo.215.1">” or </span><em class="italic"><span class="koboSpan" id="kobo.216.1">“Is the </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">T</span></strong><em class="italic"><span class="koboSpan" id="kobo.218.1"> type trivially copyable?”</span></em><span class="koboSpan" id="kobo.219.1"> can be very useful, particularly in the context of generic code. </span><span class="koboSpan" id="kobo.219.2">The constructs resulting from these techniques are called </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">type traits</span></strong><span class="koboSpan" id="kobo.221.1">, and</span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.222.1"> many of those that came into common practice over time (as well as some that require compiler support to be implemented) were standardized and can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">type_traits&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1"> header.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">The ways in which standard </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.227.1">type traits are expressed have standardized over time, going from complex beasts such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">std::numeric_limits&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.229.1">, which provide a lot of different services for type  </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">T</span></strong><span class="koboSpan" id="kobo.231.1">, to more specific services such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">std::is_const&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.233.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.234.1">Is the </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">type T</span></strong><em class="italic"><span class="koboSpan" id="kobo.236.1"> actually </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">const</span></strong><em class="italic"><span class="koboSpan" id="kobo.238.1">?</span></em><span class="koboSpan" id="kobo.239.1">) or </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">std::remove_const&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.241.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.242.1">Please give me the type that’s like </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">T</span></strong><em class="italic"><span class="koboSpan" id="kobo.244.1"> but without the </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">const</span></strong><em class="italic"><span class="koboSpan" id="kobo.246.1"> qualification if there was one</span></em><span class="koboSpan" id="kobo.247.1">), which yield either a single type or a single value. </span><span class="koboSpan" id="kobo.247.2">Practice has shown that small, unitary type traits that yield either a type (named </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">type</span></strong><span class="koboSpan" id="kobo.249.1">) or a compile-time-known value (named </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">value</span></strong><span class="koboSpan" id="kobo.251.1">) can be considered “best practices,” and most contemporary type traits (including standard ones) are written </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">this way.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Since C++14, the traits that yield types have aliases that end with </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">_t</span></strong><span class="koboSpan" id="kobo.255.1"> (for example, instead of writing the rather painful </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">typename std::remove_const&lt;T&gt;::type</span></strong><span class="koboSpan" id="kobo.257.1"> incantation, one can now write </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">std::remove_const_t&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.259.1"> instead) and since C++17, the traits that yield values have aliases that end with </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">_v</span></strong><span class="koboSpan" id="kobo.261.1"> (for example, instead of writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">std::is_const&lt;T&gt;::value</span></strong><span class="koboSpan" id="kobo.263.1">, one can now </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">write </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">std::is_const_v&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.267.1">What about concepts?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.268.1">Type traits are a programming technique that’s been part of C++ for decades, but since C++20, we have had </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">concepts</span></strong><span class="koboSpan" id="kobo.270.1">, and</span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.271.1"> concepts are sort of like traits (often, they are expressed </span><em class="italic"><span class="koboSpan" id="kobo.272.1">through</span></em><span class="koboSpan" id="kobo.273.1"> traits) but are stronger in the sense that they are part of the type system. </span><span class="koboSpan" id="kobo.273.2">This book does not use concepts much, but you (as a programmer) really should get acquainted with them. </span><span class="koboSpan" id="kobo.273.3">They are extremely powerful and extremely useful to contemporary </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">C++ programming.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.275.1">The std::true_type and std::false_type traits</span></h1>
<p><span class="koboSpan" id="kobo.276.1">When expressing type</span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.277.1"> traits, the standard library applies the common practice of using the names </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">type</span></strong><span class="koboSpan" id="kobo.279.1"> for types and </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">value</span></strong><span class="koboSpan" id="kobo.281.1"> for values, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
// hand-made is_const&lt;T&gt; and remove_const&lt;T&gt; traits
// (please use the standard versions from &lt;type_traits&gt;
// instead of writing your own!)
template &lt;class&gt; struct is_const {
   static constexpr bool </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">value</span></strong><span class="koboSpan" id="kobo.285.1"> = false; // general case
};
// specialization for const types
template &lt;class T&gt; struct is_const&lt;const T&gt; {
   static constexpr bool </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">value</span></strong><span class="koboSpan" id="kobo.287.1"> = true;
};
// general case
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.288.1">class T</span></strong><span class="koboSpan" id="kobo.289.1">&gt; struct remove_const {
   using </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">type</span></strong><span class="koboSpan" id="kobo.291.1"> = T;
};
// specialization for const T
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.292.1">class T</span></strong><span class="koboSpan" id="kobo.293.1">&gt; struct remove_const&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">const T</span></strong><span class="koboSpan" id="kobo.295.1">&gt; {
   using </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">type</span></strong><span class="koboSpan" id="kobo.297.1"> = T;
};</span></pre> <p><span class="koboSpan" id="kobo.298.1">It happens that many</span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.299.1"> type traits have Boolean values. </span><span class="koboSpan" id="kobo.299.2">To simplify the task of writing such traits and to ensure that the form of these traits is homogeneous, you will find types </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">std::true_type</span></strong><span class="koboSpan" id="kobo.301.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">std::false_type</span></strong><span class="koboSpan" id="kobo.303.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">&lt;type_traits&gt;</span></strong><span class="koboSpan" id="kobo.305.1"> header. </span><span class="koboSpan" id="kobo.305.2">These</span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.306.1"> types can be seen as the type system counterparts of constants </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">true</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.308.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">With these types, we can rewrite traits such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">is_const</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.313.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
#include &lt;type_traits&gt;
// hand-made is_const&lt;T&gt; (prefer the std:: versions...)
template &lt;class&gt; struct is_const : </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">std::false_type</span></strong><span class="koboSpan" id="kobo.316.1"> {
};
template &lt;class T&gt;
   struct is_const&lt;const T&gt; : </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">std::true_type</span></strong><span class="koboSpan" id="kobo.318.1"> {
   };</span></pre> <p><span class="koboSpan" id="kobo.319.1">These types are both a convenience and a way to express ideas </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">more clearly.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.321.1">The std::conditional&lt;B,T,F&gt; trait</span></h1>
<p><span class="koboSpan" id="kobo.322.1">It’s sometimes useful to </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.323.1">choose between two types based on a condition known at compile time. </span><span class="koboSpan" id="kobo.323.2">Consider the following example where we seek to implement a comparison between two values of some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">T</span></strong><span class="koboSpan" id="kobo.325.1"> that behave differently for floating-point types and for “other” types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">int</span></strong><span class="koboSpan" id="kobo.327.1"> all grouped together </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">for simplicity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
#include &lt;cmath&gt;
// we will allow comparisons between exact representations
// or floating point representations based on so-called tag
// types (empty classes used to distinguish function
// signatures)
</span><strong class="bold"><span class="koboSpan" id="kobo.330.1">struct floating {};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.331.1">struct exact {};</span></strong><span class="koboSpan" id="kobo.332.1">
// the three-argument versions are not meant to be called
// directly from user code
template &lt;class T&gt;
   bool close_enough(T a, T b, </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">exact</span></strong><span class="koboSpan" id="kobo.334.1">) {
      return a == b; // fine for int, short, bool, etc.
</span><span class="koboSpan" id="kobo.334.2">   }
template &lt;class T&gt;
   bool close_enough(T a, T b, </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">floating</span></strong><span class="koboSpan" id="kobo.336.1">) {
      // note: this could benefit from more rigor, but
      // that's orthogonal to our discussion
      return std::abs(a - b) &lt; static_cast&lt;T&gt;(0.000001);
   }
// this two-argument version is the one user code is
// meant to call
template &lt;class T&gt;
   bool close_enough(T a, T b) {
</span><strong class="bold"><span class="koboSpan" id="kobo.337.1">      // OUR GOAL: call the "floating" version for types</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.338.1">      // float, double and long double; call the "exact"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.339.1">      // version otherwise</span></strong><span class="koboSpan" id="kobo.340.1">
   }</span></pre> <p><span class="koboSpan" id="kobo.341.1">You might notice that we did </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.342.1">not name the arguments of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">exact</span></strong><span class="koboSpan" id="kobo.344.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">floating</span></strong><span class="koboSpan" id="kobo.346.1"> in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">close_enough()</span></strong><span class="koboSpan" id="kobo.348.1"> functions. </span><span class="koboSpan" id="kobo.348.2">That’s fine as we are not using these objects at all; the reason for these arguments is to ensure both functions have </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">distinct signatures.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">There is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">std::is_floating_point&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.352.1"> trait in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">&lt;type_traits&gt;</span></strong><span class="koboSpan" id="kobo.354.1"> header with the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">true</span></strong><span class="koboSpan" id="kobo.356.1"> for floating-point numbers, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">false</span></strong><span class="koboSpan" id="kobo.358.1"> otherwise. </span><span class="koboSpan" id="kobo.358.2">If we did not have this trait, we could write </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">our own:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
// we could write is_floating_point&lt;T&gt; as follows
// (but please use std::is_floating_point&lt;T&gt; instead!
</span><span class="koboSpan" id="kobo.360.2">template &lt;class&gt; struct is_floating_point
   : std::false_type {}; // general case
// specializations
template &lt;&gt; struct is_floating_point&lt;float&gt;
   : std::true_type {};
template &lt;&gt; struct is_floating_point&lt;double&gt;
   : std::true_type {};
template &lt;&gt; struct is_floating_point&lt;long double&gt;
   : std::true_type {};
// convenience to simplify user code
template &lt;class T&gt;
   constexpr bool is_floating_point_v =
      is_floating_point&lt;T&gt;::value;</span></pre> <p><span class="koboSpan" id="kobo.361.1">We can use this to make our decision. </span><span class="koboSpan" id="kobo.361.2">However, we do not want to make a runtime decision here since the nature of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">T</span></strong><span class="koboSpan" id="kobo.363.1"> is fully known at compile time, and nobody wants to pay for a branch instruction when </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">comparing integers!</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">std::conditional&lt;B,T,F&gt;</span></strong><span class="koboSpan" id="kobo.367.1"> trait can</span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.368.1"> be used to make such a decision. </span><span class="koboSpan" id="kobo.368.2">If we wrote our own, it could look </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
// example, home-made conditional&lt;B,T,F&gt; type trait
// (prefer the std:: version in &lt;type_traits&gt;)
// general case (incomplete type)
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.371.1">bool</span></strong><span class="koboSpan" id="kobo.372.1">, class T, class F&gt; struct conditional;
// specializations
template &lt; class T, class F&gt;
   struct conditional&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.373.1">true</span></strong><span class="koboSpan" id="kobo.374.1">, T, F&gt; {
</span><strong class="bold"><span class="koboSpan" id="kobo.375.1">      using type = T; // constant true, picks type T</span></strong><span class="koboSpan" id="kobo.376.1">
   };
template &lt; class T, class F&gt;
   struct conditional&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.377.1">false</span></strong><span class="koboSpan" id="kobo.378.1">, T, F&gt; {
</span><strong class="bold"><span class="koboSpan" id="kobo.379.1">   using type = F; // constant true, picks type F</span></strong><span class="koboSpan" id="kobo.380.1">
};
// convenience to simplify user code
template &lt;bool B, class T, class F&gt;
   using conditional_t = typename conditional&lt;B,T,F&gt;::type;</span></pre> <p><span class="koboSpan" id="kobo.381.1">Given this trait, we can choose, at </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.382.1">compile time, one of two types based on a compile-time Boolean value, which is exactly what we were trying </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">to do:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
// ...
</span><span class="koboSpan" id="kobo.384.2">// this version will be called from user code
template &lt;class T&gt;
   bool close_enough(T a, T b) {
      return close_enough(
         a, b, </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">conditional_t&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.386.1">            is_floating_point_v&lt;T&gt;,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.387.1">            floating,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.388.1">            exact</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.389.1">         &gt; {}</span></strong><span class="koboSpan" id="kobo.390.1">
      );
   }</span></pre> <p><span class="koboSpan" id="kobo.391.1">The way to read this is that the third argument in the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">close_enough()</span></strong><span class="koboSpan" id="kobo.393.1"> (found within our two-argument, user-facing </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">close_enough()</span></strong><span class="koboSpan" id="kobo.395.1"> function) will either be an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">floating</span></strong><span class="koboSpan" id="kobo.397.1"> or an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">exact</span></strong><span class="koboSpan" id="kobo.399.1"> , but the exact type will be picked at compile time based on the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">is_floating_point_v&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.401.1"> compile-time constant. </span><span class="koboSpan" id="kobo.401.2">The end result is that we instantiate an object of one of these two empty classes, call the appropriate algorithm, and let function inlining do the rest and optimize the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">scaffolding away.</span></span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.403.1">Algorithms</span></h1>
<p><span class="koboSpan" id="kobo.404.1">The C++ standard library contains, among other gems, a</span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.405.1"> set of algorithms. </span><span class="koboSpan" id="kobo.405.2">Each of these functions performs the tasks that a very well-written loop would do but with specific names, complexity guarantees, and optimizations. </span><span class="koboSpan" id="kobo.405.3">As such, let’s say we write </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
int vals[]{ 2,3,5,7,11 };
int dest[5];
for(int i = 0; i != 5; ++i)
   dest[i] = vals[i];</span></pre> <p><span class="koboSpan" id="kobo.408.1">It is idiomatic in C++ to write the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">following instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
int vals[]{ 2,3,5,7,11 };
int dest[5];
</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">std::copy(begin(vals), end(vals), begin(dest));</span></strong></pre> <p><span class="koboSpan" id="kobo.412.1">The important thing to know here is that C++ sequences are of the form </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">[begin,end)</span></strong><span class="koboSpan" id="kobo.414.1">, meaning that for all algorithms, the beginning iterator (here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">begin(vals)</span></strong><span class="koboSpan" id="kobo.416.1">) is included and the ending iterator (here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">end(vals)</span></strong><span class="koboSpan" id="kobo.418.1">) is excluded, making </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">[begin,end)</span></strong><span class="koboSpan" id="kobo.420.1"> a half-open range. </span><span class="koboSpan" id="kobo.420.2">All algorithms in </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">&lt;algorithm&gt;</span></strong><span class="koboSpan" id="kobo.422.1"> and in its cousin header, </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">&lt;numeric&gt;</span></strong><span class="koboSpan" id="kobo.424.1">, follow</span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.425.1"> that </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">simple convention.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.427.1">What about ranges?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.428.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">&lt;ranges&gt;</span></strong><span class="koboSpan" id="kobo.430.1"> library is a major addition </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.431.1">to the C++ standard library since C++20 and can sometimes be used to lead to even better code than the already tremendous </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">&lt;algorithm&gt;</span></strong><span class="koboSpan" id="kobo.433.1"> library. </span><span class="koboSpan" id="kobo.433.2">This book does not use ranges much, but that does not mean this library is not wonderful, so please feel free to use it and investigate ways through which it can be used to make your </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">code better.</span></span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.435.1">Functors (function objects) and lambdas</span></h1>
<p><span class="koboSpan" id="kobo.436.1">It is customary in C++ to </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.437.1">use </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">functors</span></strong><span class="koboSpan" id="kobo.439.1">, otherwise called </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">function objects</span></strong><span class="koboSpan" id="kobo.441.1">, to</span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.442.1"> represent stateful computations. </span><span class="koboSpan" id="kobo.442.2">Think, for example, of a program that would print integers to the standard output using </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">an algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
using namespace std;
void display(int n) { cout &lt;&lt; n &lt;&lt; ' '; }
int main() {
   int vals[]{ 2,3,5,7,11 };
   for_each(begin(vals), end(vals), display);
}</span></pre> <p><span class="koboSpan" id="kobo.445.1">This small program works fine, but should we want to print elsewhere than on the standard output, we would find ourselves in an unpleasant situation: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">for_each()</span></strong><span class="koboSpan" id="kobo.447.1"> algorithm expects a unary function in the sense of “function accepting a single argument” (here, the value to print), so there’s no syntactic space to add an argument such as the output stream to use. </span><span class="koboSpan" id="kobo.447.2">We could “solve” this issue through a global variable, or using a different function for every output stream, but that would fall short of a </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">reasonable design.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">If we replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">display</span></strong><span class="koboSpan" id="kobo.451.1"> function </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.452.1">with a class, which we’ll name </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Display</span></strong><span class="koboSpan" id="kobo.454.1"> to make them visually</span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.455.1"> distinct, we end up with </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
using namespace std;
</span><strong class="bold"><span class="koboSpan" id="kobo.458.1">class Display {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.459.1">   ostream &amp;os;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.460.1">public:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.461.1">   Display(ostream &amp;os) : os{ os } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.462.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.463.1">   void operator()(int n) const { os &lt;&lt; n &lt;&lt; ' '; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.464.1">};</span></strong><span class="koboSpan" id="kobo.465.1">
int main() {
   int vals[]{ 2,3,5,7,11 };
</span><strong class="bold"><span class="koboSpan" id="kobo.466.1">   // display on the standard output</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.467.1">   for_each(begin(vals), end(vals), Display{ cout });</span></strong><span class="koboSpan" id="kobo.468.1">
   ofstream out{"out.txt" };
</span><strong class="bold"><span class="koboSpan" id="kobo.469.1">   // write to file out.txt</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.470.1">   for_each(begin(vals), end(vals), Display{ out });</span></strong><span class="koboSpan" id="kobo.471.1">
}</span></pre> <p><span class="koboSpan" id="kobo.472.1">This leads to nice, readable code with added flexibility. </span><span class="koboSpan" id="kobo.472.2">Note that, conceptually, lambda expressions are </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.473.1">functors (you can even use lambdas</span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.474.1"> as base classes!), so the previous example can be rewritten equivalently </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">as </span></span><span class="No-Break"><a id="_idIndexMarker938"/></span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
using namespace std;
int main() {
   int vals[]{ 2,3,5,7,11 };
</span><strong class="bold"><span class="koboSpan" id="kobo.478.1">   // display on the standard output</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.479.1">   for_each(begin(vals), end(vals), [](int n) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.480.1">      cout &lt;&lt; n &lt;&lt; ' ';</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.481.1">   });</span></strong><span class="koboSpan" id="kobo.482.1">
   ofstream out{"out.txt" };
</span><strong class="bold"><span class="koboSpan" id="kobo.483.1">   // write to file out.txt</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.484.1">   for_each(begin(vals), end(vals), [&amp;out](int n) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.485.1">      out &lt;&lt; n &lt;&lt; ' ';</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.486.1">   });</span></strong><span class="koboSpan" id="kobo.487.1">
}</span></pre> <p><span class="koboSpan" id="kobo.488.1">Lambdas are thus essentially functors</span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.489.1"> that limit themselves to a constructor and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">operator()</span></strong><span class="koboSpan" id="kobo.491.1"> member function, and this combination represents the most common case by far for such objects. </span><span class="koboSpan" id="kobo.491.2">You can, of course, still use full-blown, explicit functors if you want more </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">than this.</span></span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.493.1">Friends</span></h1>
<p><span class="koboSpan" id="kobo.494.1">C++ offers an access qualifier that’s not commonly found in other languages and is often misunderstood: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">friend</span></strong><span class="koboSpan" id="kobo.496.1"> qualifier. </span><span class="koboSpan" id="kobo.496.2">A </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.497.1">class can specify another class or a function as one of its friends, giving said </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">friend</span></strong><span class="koboSpan" id="kobo.499.1"> qualifier full access to all of that class’s members, including those qualified as </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">protected</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.501.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Some consider </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">friend</span></strong><span class="koboSpan" id="kobo.506.1"> to break encapsulation, and indeed it can do this if used recklessly, but the intent here is to provide privileged access to specific entities rather than exposing them as </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">public</span></strong><span class="koboSpan" id="kobo.508.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">protected</span></strong><span class="koboSpan" id="kobo.510.1"> members that were not designed to that end, leading to an even wider </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">encapsulation breakage.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">Consider, for example, the following classes, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">thing</span></strong><span class="koboSpan" id="kobo.514.1"> is something that is meant to be built from the contents of a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">name</span></strong><span class="koboSpan" id="kobo.516.1"> by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">thing_factory</span></strong><span class="koboSpan" id="kobo.518.1"> that’s able to validate the file’s content before constructing </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">thing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
class thing {
   thing(string_view); // note: private
   // ... </span><span class="koboSpan" id="kobo.522.2">various interesting members
</span><strong class="bold"><span class="koboSpan" id="kobo.523.1">   // thing_factory can access private members of</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.524.1">   // class thing</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.525.1">   friend class thing_factory;</span></strong><span class="koboSpan" id="kobo.526.1">
};
// in case we read an incorrect file
class invalid_format{};
class thing_factory {
   // ... </span><span class="koboSpan" id="kobo.526.2">various interesting things here too
   string read_file(const string &amp;name) const {
      ifstream in{ name };
      // consume the file in one fell swoop, returning
      // the entire contents in a single string
      return { istreambuf_iterator&lt;char&gt;{ in },
               istreambuf_iterator&lt;char&gt;{ } };
   }
   bool is_valid_content(string_view) const;
public:
   </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">thing</span></strong><span class="koboSpan" id="kobo.528.1"> create_thing_from(const string &amp;name) const {
      auto contents = read_file(name);
      if(!is_valid_content(contents))
         throw invalid_format{};
</span><strong class="bold"><span class="koboSpan" id="kobo.529.1">      // note: calls private thing constructor</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.530.1">      return { contents };</span></strong><span class="koboSpan" id="kobo.531.1">
   }
};</span></pre> <p><span class="koboSpan" id="kobo.532.1">We do not want the whole world to be able to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">private</span></strong><span class="koboSpan" id="kobo.534.1">-qualified </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">thing</span></strong><span class="koboSpan" id="kobo.536.1"> constructor that takes an</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.537.1"> arbitrary </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">string_view</span></strong><span class="koboSpan" id="kobo.539.1"> as an argument since that constructor is not meant to handle character strings that have not been validated in the first place. </span><span class="koboSpan" id="kobo.539.2">For this reason, we only let </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">thing_factory</span></strong><span class="koboSpan" id="kobo.541.1"> use it, thus strengthening encapsulation rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">weakening it.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">It is customary to put a class and its friends together when shipping code as they go together: a friend of a class, in essence, is an external addition to that class’s interface. </span><span class="koboSpan" id="kobo.543.2">Finally, note that restrictions </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.544.1">apply to friendship. </span><span class="koboSpan" id="kobo.544.2">Friendship is not reflexive; if </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">A</span></strong><span class="koboSpan" id="kobo.546.1"> declares </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">B</span></strong><span class="koboSpan" id="kobo.548.1"> to be its friend, it does not follow that </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">B</span></strong><span class="koboSpan" id="kobo.550.1"> declares </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">A</span></strong><span class="koboSpan" id="kobo.552.1"> to be </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">its friend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
class A {
   int n = 3;
</span><strong class="bold"><span class="koboSpan" id="kobo.555.1">   friend class B;</span></strong><span class="koboSpan" id="kobo.556.1">
public:
   void f(B);
};
class B {
   int m = 4;
public:
   void f(A);
};
void </span><strong class="bold"><span class="koboSpan" id="kobo.557.1">A::f(B b)</span></strong><span class="koboSpan" id="kobo.558.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.559.1">   // int val = b.m; // no, A is not a friend of B</span></strong><span class="koboSpan" id="kobo.560.1">
}
void </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">B::f(A a)</span></strong><span class="koboSpan" id="kobo.562.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.563.1">   int val = a.n; // Ok, B is a friend of A</span></strong><span class="koboSpan" id="kobo.564.1">
}</span></pre> <p><span class="koboSpan" id="kobo.565.1">Friendship is not transitive; if </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">A</span></strong><span class="koboSpan" id="kobo.567.1"> declares </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">B</span></strong><span class="koboSpan" id="kobo.569.1"> to be its friend and </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">B</span></strong><span class="koboSpan" id="kobo.571.1"> declares </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">C</span></strong><span class="koboSpan" id="kobo.573.1"> to be its friend, it does not follow that </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">A</span></strong><span class="koboSpan" id="kobo.575.1"> declares </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">C</span></strong><span class="koboSpan" id="kobo.577.1"> to be </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">its friend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
class A {
   int n = 3;
</span><strong class="bold"><span class="koboSpan" id="kobo.580.1">   friend class B;</span></strong><span class="koboSpan" id="kobo.581.1">
};
class B {
</span><strong class="bold"><span class="koboSpan" id="kobo.582.1">   friend class C;</span></strong><span class="koboSpan" id="kobo.583.1">
public:
   void f(</span><strong class="bold"><span class="koboSpan" id="kobo.584.1">A a</span></strong><span class="koboSpan" id="kobo.585.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.586.1">      int val = a.n; // Ok, B is a friend of A</span></strong><span class="koboSpan" id="kobo.587.1">
   }
};
class C {
public:
   void f(</span><strong class="bold"><span class="koboSpan" id="kobo.588.1">A a</span></strong><span class="koboSpan" id="kobo.589.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.590.1">      // int val = a.n; // no, C is not a friend of A</span></strong><span class="koboSpan" id="kobo.591.1">
   }
};</span></pre> <p><span class="koboSpan" id="kobo.592.1">Last but not least, friendship is not inherited; if </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">A</span></strong><span class="koboSpan" id="kobo.594.1"> declares </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">B</span></strong><span class="koboSpan" id="kobo.596.1"> to be its friend, it does not follow that if </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">C</span></strong><span class="koboSpan" id="kobo.598.1"> is a child class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">B</span></strong><span class="koboSpan" id="kobo.600.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">A</span></strong><span class="koboSpan" id="kobo.602.1"> has</span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.603.1"> declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">C</span></strong><span class="koboSpan" id="kobo.605.1"> to be </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">its friend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
class A {
   int n = 3;
</span><strong class="bold"><span class="koboSpan" id="kobo.608.1">   friend class B;</span></strong><span class="koboSpan" id="kobo.609.1">
};
class B {
public:
   void f(</span><strong class="bold"><span class="koboSpan" id="kobo.610.1">A a</span></strong><span class="koboSpan" id="kobo.611.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.612.1">      int val = a.n; // Ok, B is a friend of A</span></strong><span class="koboSpan" id="kobo.613.1">
   }
};
class </span><strong class="bold"><span class="koboSpan" id="kobo.614.1">C : B</span></strong><span class="koboSpan" id="kobo.615.1"> {
public:
   void f(</span><strong class="bold"><span class="koboSpan" id="kobo.616.1">A a</span></strong><span class="koboSpan" id="kobo.617.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.618.1">      // int val = a.n; // no, C is not a friend of A</span></strong><span class="koboSpan" id="kobo.619.1">
   }
};</span></pre> <p><span class="koboSpan" id="kobo.620.1">Used judiciously, </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">friend</span></strong><span class="koboSpan" id="kobo.622.1"> solves </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.623.1">encapsulation problems that would be difficult to deal </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">with otherwise.</span></span></p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.625.1">The decltype operator</span></h1>
<p><span class="koboSpan" id="kobo.626.1">The type system of C++ is powerful and </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.627.1">nuanced, offering (among other things) a set of type deduction facilities. </span><span class="koboSpan" id="kobo.627.2">The best-known type deduction tool is probably </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">auto</span></strong><span class="koboSpan" id="kobo.629.1">, used to infer the type of an expression from the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">its initializer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
const int n = f();
auto m = n; // m is of type int
auto &amp; r = m; // r is of type int&amp;
const auto &amp; cr0 = m; // cr0 is of type const int&amp;
auto &amp; cr1 = n; // cr1 is of type const int&amp;</span></pre> <p><span class="koboSpan" id="kobo.632.1">As you might notice from the preceding example, by default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">auto</span></strong><span class="koboSpan" id="kobo.634.1"> makes copies (see the declaration of variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">m</span></strong><span class="koboSpan" id="kobo.636.1"> ), but you can qualify </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">auto</span></strong><span class="koboSpan" id="kobo.638.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">&amp;</span></strong><span class="koboSpan" id="kobo.640.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">&amp;&amp;</span></strong><span class="koboSpan" id="kobo.642.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">const</span></strong><span class="koboSpan" id="kobo.644.1">, and so on </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">Sometimes, you want to deduce the type of an expression with more precision, keeping the various qualifiers that accompany it. </span><span class="koboSpan" id="kobo.646.2">That might be useful when inferring the type of an arithmetic expression, the type of a lambda, the return type of a complicated generic function, and so on. </span><span class="koboSpan" id="kobo.646.3">For this, you have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">decltype</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
template &lt;class T&gt;
   T&amp; pass_thru(T &amp;arg) {
      return arg;
   }
int main() {
   int n = 3;
   </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">auto</span></strong><span class="koboSpan" id="kobo.651.1"> m = pass_thru(n); // m is an int
   ++m;
   cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; '\n'; // 3 4
   </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">decltype(pass_thru(n))</span></strong><span class="koboSpan" id="kobo.653.1"> r = pass_thru(n); // r is an int&amp;
   ++r;
   cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n'; // 4 4
}</span></pre> <p><span class="koboSpan" id="kobo.654.1">The use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">auto</span></strong><span class="koboSpan" id="kobo.656.1"> has become commonplace in C++ code since C++11, at least in some circles. </span><span class="koboSpan" id="kobo.656.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">decltype</span></strong><span class="koboSpan" id="kobo.658.1"> operator, also</span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.659.1"> part of C++ since C++11, is a sharper tool, still widely used but for more specialized </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">use cases.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.661.1">When the types get painful to spell</span></p>
<p class="callout"><span class="koboSpan" id="kobo.662.1">In the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">decltype</span></strong><span class="koboSpan" id="kobo.664.1"> example, we spelled </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">pass_thru(n)</span></strong><span class="koboSpan" id="kobo.666.1"> twice: once in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">decltype</span></strong><span class="koboSpan" id="kobo.668.1"> operator and once in the actual function call. </span><span class="koboSpan" id="kobo.668.2">That’s not practical in general since it duplicates the maintenance effort and… well, it’s just noise, really. </span><span class="koboSpan" id="kobo.668.3">Since C++14, one can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">decltype(auto)</span></strong><span class="koboSpan" id="kobo.670.1"> to express “the fully qualified type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">initializing expression.”</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.672.1">Thus, we would customarily write </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">decltype(auto) r = pass_thru(n);</span></strong><span class="koboSpan" id="kobo.674.1"> to express that </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">r</span></strong><span class="koboSpan" id="kobo.676.1"> is to have the fully qualified type of the expression </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">pass_thru(n)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.678.1"> .</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.679.1">Perfect forwarding</span></h1>
<p><span class="koboSpan" id="kobo.680.1">The advent of variadic templates in C++11 </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.681.1">has made it necessary to ensure there is a way for the semantics at the call site of a function to be conveyed throughout the call chain. </span><span class="koboSpan" id="kobo.681.2">This might seem abstract but it’s quite real and has implications on the effect of </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">function calls.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">following class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.685.1">
#include &lt;string&gt;
struct X {
   X(int, const std::string&amp;); // A
   X(int, std::string&amp;&amp;); // B
   // ... </span><span class="koboSpan" id="kobo.685.2">other constructors and various members
};</span></pre> <p><span class="koboSpan" id="kobo.686.1">This class exposes at least two constructors, one that takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">int</span></strong><span class="koboSpan" id="kobo.688.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">const string&amp;</span></strong><span class="koboSpan" id="kobo.690.1"> as argument and another that takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">int</span></strong><span class="koboSpan" id="kobo.692.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">string&amp;&amp;</span></strong><span class="koboSpan" id="kobo.694.1"> instead. </span><span class="koboSpan" id="kobo.694.2">To make the example more general, we’ll also suppose the existence of other </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">X</span></strong><span class="koboSpan" id="kobo.696.1"> constructors that we might want to call while still focusing on these two. </span><span class="koboSpan" id="kobo.696.2">If we called these two constructors explicitly, we could do so with </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
X x0{ 3, "hello" }; // calls A
string s = "hi!";
X x1{ 4, s }; // also calls A
X x2{ 5, string{ "there" } }; // calls B
X x3{ 5, "there too"s }; // also calls B</span></pre> <p><span class="koboSpan" id="kobo.699.1">The constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">x0</span></strong><span class="koboSpan" id="kobo.701.1"> calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">A</span></strong><span class="koboSpan" id="kobo.703.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">"hello"</span></strong><span class="koboSpan" id="kobo.705.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">const char(&amp;)[6]</span></strong><span class="koboSpan" id="kobo.707.1"> (including the trailing </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">'\0'</span></strong><span class="koboSpan" id="kobo.709.1">), not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">string</span></strong><span class="koboSpan" id="kobo.711.1"> type, but the compiler’s allowed to synthesize a temporary </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">string</span></strong><span class="koboSpan" id="kobo.713.1"> to pass as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">const string&amp;</span></strong><span class="koboSpan" id="kobo.715.1"> in this case (it could not if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">string&amp;</span></strong><span class="koboSpan" id="kobo.717.1"> was non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">const</span></strong><span class="koboSpan" id="kobo.719.1"> as it would require referring to a </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">modifiable object).</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">The constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">x1</span></strong><span class="koboSpan" id="kobo.723.1"> also calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">A</span></strong><span class="koboSpan" id="kobo.725.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">s</span></strong><span class="koboSpan" id="kobo.727.1"> is a named </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">string</span></strong><span class="koboSpan" id="kobo.729.1"> type, which means it cannot be implicitly passed </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">by movement.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">The constructors of </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">x2</span></strong><span class="koboSpan" id="kobo.733.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">x3</span></strong><span class="koboSpan" id="kobo.735.1"> both call </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">B</span></strong><span class="koboSpan" id="kobo.737.1">, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">string&amp;&amp;</span></strong><span class="koboSpan" id="kobo.739.1"> as an argument, as they are both passed temporary, anonymous </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">string</span></strong><span class="koboSpan" id="kobo.741.1"> objects that can be implicitly passed </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">by movement.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">Now, suppose we want to </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.744.1">write a factory of </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">X</span></strong><span class="koboSpan" id="kobo.746.1"> objects that relays arguments to the appropriate </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">X</span></strong><span class="koboSpan" id="kobo.748.1"> constructor (one of the two we’re looking at or any other </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">X</span></strong><span class="koboSpan" id="kobo.750.1"> constructor) after having done some preliminary work; for the sake of this example, we’ll simply log the fact that we are constructing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">X</span></strong><span class="koboSpan" id="kobo.752.1"> object. </span><span class="koboSpan" id="kobo.752.2">Let’s say we wrote it </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">this way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.754.1">
template &lt;class ... </span><span class="koboSpan" id="kobo.754.2">Args&gt;
   X makeX(Args ... </span><span class="koboSpan" id="kobo.754.3">args) {
      clog &lt;&lt; "Creating a X object\n";
      return X(args...); // &lt;-- HERE
   }</span></pre> <p><span class="koboSpan" id="kobo.755.1">In this case, arguments would all have names and be passed by value, so the constructor that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">string&amp;&amp;</span></strong><span class="koboSpan" id="kobo.757.1"> would never </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">be chosen.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">Now, let’s say we wrote it </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">this way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.761.1">
template &lt;class ... </span><span class="koboSpan" id="kobo.761.2">Args&gt;
   X makeX(Args &amp;... </span><span class="koboSpan" id="kobo.761.3">args) {
      clog &lt;&lt; "Creating a X object\n";
      return X(args...); // &lt;-- HERE
   }</span></pre> <p><span class="koboSpan" id="kobo.762.1">In this case, arguments would all be passed by reference, and a call that passed a </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">char</span></strong><span class="koboSpan" id="kobo.764.1"> array such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">"hello"</span></strong><span class="koboSpan" id="kobo.766.1"> as an argument would not compile. </span><span class="koboSpan" id="kobo.766.2">What we need to do is write our factory function in such a way that each argument keeps the semantics it had at the function’s call site, and is forwarded by the function with the exact </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">same semantics.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">The way to express this in C++ involves </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">forwarding references</span></strong><span class="koboSpan" id="kobo.770.1"> and a</span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.771.1"> special library function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">std::forward&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.773.1"> (from </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">&lt;utility&gt;</span></strong><span class="koboSpan" id="kobo.775.1">), which behaves as a cast. </span><span class="koboSpan" id="kobo.775.2">A forwarding reference superficially and syntactically looks like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">rvalue</span></strong><span class="koboSpan" id="kobo.777.1"> references used for move semantics, but their impact on argument semantics is quite</span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.778.1"> different. </span><span class="koboSpan" id="kobo.778.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.780.1">
// v passed by movement (type vector&lt;int&gt; fully specified)
void f0(vector&lt;int&gt; &amp;&amp;v);
// v passed by movement (type vector&lt;T&gt; fully specified
// for some type T)
template &lt;class T&gt;
   void f1(vector&lt;T&gt; &amp;&amp;v);
</span><strong class="bold"><span class="koboSpan" id="kobo.781.1">// v is a forwarding reference (type discovered by</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.782.1">// the compiler)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.783.1">template &lt;class T&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.784.1">   void f2(T&amp;&amp; v);</span></strong></pre> <p><span class="koboSpan" id="kobo.785.1">With a forwarding reference, the argument semantics depend on the call site. </span><span class="koboSpan" id="kobo.785.2">For example, let’s say we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">f2()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.789.1">// T is vector&lt;int&gt;&amp;&amp; (pass by movement)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.790.1">f2(vector&lt;int&gt;{ 2,3,5,7,11 });</span></strong><span class="koboSpan" id="kobo.791.1">
vector&lt;int&gt; v0{ 2,3,5,7,11 };
</span><strong class="bold"><span class="koboSpan" id="kobo.792.1">f2(v0); // T is vector&lt;int&gt;&amp; (pass by reference)</span></strong><span class="koboSpan" id="kobo.793.1">
const vector&lt;int&gt; v1{ 2,3,5,7,11 };
</span><strong class="bold"><span class="koboSpan" id="kobo.794.1">f2(v1); // T is const vector&lt;int&gt;&amp; (pass by ref-to-const)</span></strong></pre> <p><span class="koboSpan" id="kobo.795.1">Returning to our factory of </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">X</span></strong><span class="koboSpan" id="kobo.797.1"> objects, in this case, the appropriate signature for </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">makeX()</span></strong><span class="koboSpan" id="kobo.799.1"> would be </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
template &lt;class ... </span><span class="koboSpan" id="kobo.801.2">Args&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.802.1">   X makeX(Args &amp;&amp;... </span><span class="koboSpan" id="kobo.802.2">args) {</span></strong><span class="koboSpan" id="kobo.803.1">
      clog &lt;&lt; "Creating a X object\n";
</span><strong class="bold"><span class="koboSpan" id="kobo.804.1">      return X(args...); // &lt;-- HERE (still incorrect)</span></strong><span class="koboSpan" id="kobo.805.1">
   }</span></pre> <p><span class="koboSpan" id="kobo.806.1">This version of our function almost works. </span><span class="koboSpan" id="kobo.806.2">The signature of </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">makeX()</span></strong><span class="koboSpan" id="kobo.808.1"> is correct as each argument will be accepted with the type used at the call site, be it a reference, a reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">const</span></strong><span class="koboSpan" id="kobo.810.1">, or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">rvalue</span></strong><span class="koboSpan" id="kobo.812.1"> reference. </span><span class="koboSpan" id="kobo.812.2">What’s missing is that the arguments we are receiving as </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">rvalue</span></strong><span class="koboSpan" id="kobo.814.1"> references now have a name within </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">makeX()</span></strong><span class="koboSpan" id="kobo.816.1"> (they’re part of the pack named </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">args</span></strong><span class="koboSpan" id="kobo.818.1">!), so when calling the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">X</span></strong><span class="koboSpan" id="kobo.820.1">, there’s no implicit move </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">involved anymore.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">What we need to do to complete our </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.823.1">effort is to </span><em class="italic"><span class="koboSpan" id="kobo.824.1">cast back each argument to the type it had at the call site</span></em><span class="koboSpan" id="kobo.825.1">. </span><span class="koboSpan" id="kobo.825.2">That type is inscribed in </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">Args</span></strong><span class="koboSpan" id="kobo.827.1">, the type of our pack, and the way to perform that cast is to apply </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">std::forward&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.829.1"> to each argument in the pack. </span><span class="koboSpan" id="kobo.829.2">A correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">makeX()</span></strong><span class="koboSpan" id="kobo.831.1"> function, at long last, would be </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
template &lt;class ... </span><span class="koboSpan" id="kobo.833.2">Args&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.834.1">   X makeX(Args &amp;&amp;... </span><span class="koboSpan" id="kobo.834.2">args) {</span></strong><span class="koboSpan" id="kobo.835.1">
      clog &lt;&lt; "Creating a X object\n";
</span><strong class="bold"><span class="koboSpan" id="kobo.836.1">      return X(std::forward&lt;Args&gt;(args)...); // &lt;-- HERE</span></strong><span class="koboSpan" id="kobo.837.1">
   }</span></pre> <p><span class="koboSpan" id="kobo.838.1">Whew! </span><span class="koboSpan" id="kobo.838.2">There are simpler syntaxes indeed, but we </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">made it.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.840.1">The singleton design pattern</span></h1>
<p><span class="koboSpan" id="kobo.841.1">There are many design patterns out there. </span><span class="koboSpan" id="kobo.841.2">Design patterns are a topic of their own, representing well-known ways of solving problems that one can represent in the abstract, give a name to, explain to others, and then reify within the constraints and idioms of one’s chosen </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">programming language.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.844.1">singleton</span></strong><span class="koboSpan" id="kobo.845.1"> design pattern</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.846.1"> describes ways in which we can write a class that ensures it is instantiated only once in </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">a program.</span></span></p>
<p><span class="koboSpan" id="kobo.848.1">Singleton is not a well-liked pattern: it makes testing difficult, introduces dependencies on global state, represents a single point of failure in a program as well as a potential program-wide bottleneck, complicates multithreading (if the singleton is mutable, then its state requires synchronization), and so on, but it has its uses, is used in practice, and we use it on occasion in </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">There are many ways to write a class that is instantiated only once in a program with the C++ language. </span><span class="koboSpan" id="kobo.850.2">All of them share</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.851.1"> some </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">key characteristics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.853.1">The type’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">copy</span></strong><span class="koboSpan" id="kobo.855.1"> operations have to be deleted. </span><span class="koboSpan" id="kobo.855.2">If one can copy a singleton, then there will be more than one instance of that type, which leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">a contradiction.</span></span></li>
<li><span class="koboSpan" id="kobo.857.1">There should be no </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">public</span></strong><span class="koboSpan" id="kobo.859.1"> constructor. </span><span class="koboSpan" id="kobo.859.2">If there were, the client code could call it and create more than </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">one instance.</span></span></li>
<li><span class="koboSpan" id="kobo.861.1">There should be no </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">protected</span></strong><span class="koboSpan" id="kobo.863.1"> members. </span><span class="koboSpan" id="kobo.863.2">Objects of derived classes are also, conceptually, objects of the base class, again leading to a contradiction (there would, in practice, be more than one instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">the singleton!).</span></span></li>
<li><span class="koboSpan" id="kobo.865.1">Since there is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">public</span></strong><span class="koboSpan" id="kobo.867.1"> constructor, there should be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">private</span></strong><span class="koboSpan" id="kobo.869.1"> constructor (probably a default constructor), and that one will only be accessible to the class itself or to its friends (if any). </span><span class="koboSpan" id="kobo.869.2">For simplicity, we’ll suppose that the way to access a singleton is to go through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">static</span></strong><span class="koboSpan" id="kobo.871.1"> (obviously) member function of </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">the singleton.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.873.1">We’ll look at ways to implement an overly simplistic singleton in C++. </span><span class="koboSpan" id="kobo.873.2">For the sake of this example, the singleton will provide sequential integers on demand. </span><span class="koboSpan" id="kobo.873.3">The general idea for that class will be </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.875.1">
#include &lt;atomic&gt;
class SequentialIdProvider {
   // ...
</span><span class="koboSpan" id="kobo.875.2">   std::atomic&lt;long long&gt; cur; // state (synchronized)
   // default constructor (private)
   SequentialIdProvider() : cur{ 0LL } {
   }
public:
   // service offered by the singleton (synchronized)
   auto next() { return cur++; }
   // deleted copy operations
   SequentialIdProvider(const SequentialIdProvider&amp;)
      = delete;
   SequentialIdProvider&amp;
      operator=(const SequentialIdProvider&amp;) = delete;
   // ...
</span><span class="koboSpan" id="kobo.875.3">};</span></pre> <p><span class="koboSpan" id="kobo.876.1">The following subsections show two different techniques to create and provide access to </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">the singleton.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.878.1">Instantiation at program startup</span></h2>
<p><span class="koboSpan" id="kobo.879.1">One way to instantiate a </span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.880.1">singleton is to create it before </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">main()</span></strong><span class="koboSpan" id="kobo.882.1"> starts by actually making it a </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">static</span></strong><span class="koboSpan" id="kobo.884.1"> data member of its class. </span><span class="koboSpan" id="kobo.884.2">This requires </span><em class="italic"><span class="koboSpan" id="kobo.885.1">declaring</span></em><span class="koboSpan" id="kobo.886.1"> the singleton in the class and </span><em class="italic"><span class="koboSpan" id="kobo.887.1">defining</span></em><span class="koboSpan" id="kobo.888.1"> it in a separate source file in order to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">ODR problems.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.890.1">ODR, you say?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.891.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.892.1">One Definition Rule</span></strong><span class="koboSpan" id="kobo.893.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.894.1">ODR</span></strong><span class="koboSpan" id="kobo.895.1">) and</span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.896.1"> associated issues are described in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.897.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.898.1"> of this book, but the gist of it is that in C++, every object can have many declarations but only </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">one definition.</span></span></p>
<p><span class="koboSpan" id="kobo.900.1">A possible implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.902.1">
#include &lt;atomic&gt;
class SequentialIdProvider {
</span><strong class="bold"><span class="koboSpan" id="kobo.903.1">   // declaration (private)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.904.1">   static SequentialIdProvider singleton;</span></strong><span class="koboSpan" id="kobo.905.1">
   std::atomic&lt;long long&gt; cur; // state (synchronized)
   // default constructor (private)
   SequentialIdProvider() : cur{ 0LL } {
   }
public:
</span><strong class="bold"><span class="koboSpan" id="kobo.906.1">   // static member function providing access to the object</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.907.1">   static auto &amp; get() { return singleton; }</span></strong><span class="koboSpan" id="kobo.908.1">
   // service offered by the singleton (synchronized)
   auto next() { return cur++; }
   // deleted copy operations
   SequentialIdProvider(const SequentialIdProvider&amp;)
      = delete;
   SequentialIdProvider&amp;
      operator=(const SequentialIdProvider&amp;) = delete;
   // ...
</span><span class="koboSpan" id="kobo.908.2">};
// in a source file somewhere, say SequentialIdProvider.cpp
</span><strong class="bold"><span class="koboSpan" id="kobo.909.1">#include "SequentialIdProvider.h"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.910.1">// definition (calls the default constructor)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.911.1">SequentialIdProvider SequentialIdProvider::singleton;</span></strong></pre> <p><span class="koboSpan" id="kobo.912.1">This works fine and </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.913.1">is efficient as long as there is no dependency between separate global objects. </span><span class="koboSpan" id="kobo.913.2">For example, if another singleton in the same program needed access to the services of </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">SequentialIdProvider</span></strong><span class="koboSpan" id="kobo.915.1">, we could run into trouble as C++ does not guarantee the order in which global objects from multiple files </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">are instantiated.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">Possible client code for this implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.919.1">
auto &amp; provider = SequentialIdProvider::get();
for(int i = 0; i != 5; ++i)
   cout &lt;&lt; provider.next() &lt;&lt; ' ';</span></pre> <p><span class="koboSpan" id="kobo.920.1">This would display </span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.921.1">monotonically increasing integers, maybe consecutively (as long as there is no other thread concurrently calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">singleton’s services).</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.923.1">Instantiation of the first call</span></h2>
<p><span class="koboSpan" id="kobo.924.1">Another way to </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.925.1">instantiate a singleton is to create it the first time its services are solicited by making it a </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">static</span></strong><span class="koboSpan" id="kobo.927.1"> variable of the function that provides access to the singleton. </span><span class="koboSpan" id="kobo.927.2">This way, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">static</span></strong><span class="koboSpan" id="kobo.929.1"> local variables are created the first time the function is called and keep their state thereafter, a singleton could provide services to other singletons as long as this does not </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">create cycles.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">A possible implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.933.1">
#include &lt;atomic&gt;
class SequentialIdProvider {
   std::atomic&lt;long long&gt; cur; // state (synchronized)
   // default constructor (private)
   SequentialIdProvider() : cur{ 0LL } {
   }
public:
</span><strong class="bold"><span class="koboSpan" id="kobo.934.1">   // static member function providing access to the object</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.935.1">   static auto &amp; get() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.936.1">      static SequentialIdProvider singleton; // definition</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.937.1">      return singleton;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.938.1">   }</span></strong><span class="koboSpan" id="kobo.939.1">
   // service offered by the singleton (synchronized)
   auto next() { return cur++; }
   // deleted copy operations
   SequentialIdProvider(const SequentialIdProvider&amp;)
      = delete;
   SequentialIdProvider&amp;
      operator=(const SequentialIdProvider&amp;) = delete;
   // ...
</span><span class="koboSpan" id="kobo.939.2">};</span></pre> <p><span class="koboSpan" id="kobo.940.1">Possible client code for this implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.942.1">
auto &amp; provider = SequentialIdProvider::get();
for(int i = 0; i != 5; ++i)
   cout &lt;&lt; provider.next() &lt;&lt; ' ';</span></pre> <p><span class="koboSpan" id="kobo.943.1">This would display monotonically increasing integers, maybe consecutively (as long as there is no other thread concurrently calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">singleton’s services).</span></span></p>
<p><span class="koboSpan" id="kobo.945.1">Note that this version has</span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.946.1"> a hidden cost: </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">static</span></strong><span class="koboSpan" id="kobo.948.1"> variables local to functions are </span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.949.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.950.1">magic statics</span></strong><span class="koboSpan" id="kobo.951.1"> in C++ as the language guarantees that they will be constructed only once, even if two or more threads call the function concurrently. </span><span class="koboSpan" id="kobo.951.2">This property implies that access to that </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">static</span></strong><span class="koboSpan" id="kobo.953.1"> variable involves some synchronization and that this synchronization is paid on every call to that function. </span><span class="koboSpan" id="kobo.953.2">The preceding client code alleviates that cost by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">SequentialIdProvider::get()</span></strong><span class="koboSpan" id="kobo.955.1"> once, then reusing the reference obtained through that call afterward; it’s the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">get()</span></strong><span class="koboSpan" id="kobo.957.1"> that introduces the </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">synchronization cost.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.959.1">The std::exchange() function</span></h1>
<p><span class="koboSpan" id="kobo.960.1">There are (at least) two very </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.961.1">useful and fundamental functions hidden in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">&lt;utility&gt;</span></strong><span class="koboSpan" id="kobo.963.1"> header file. </span><span class="koboSpan" id="kobo.963.2">One is well-known and has been there for a long time: </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">std::swap()</span></strong><span class="koboSpan" id="kobo.965.1">, which is used for many purposes throughout the standard library as well as throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">user code.</span></span></p>
<p><span class="koboSpan" id="kobo.967.1">The other, more recent one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">std::exchange()</span></strong><span class="koboSpan" id="kobo.969.1">. </span><span class="koboSpan" id="kobo.969.2">Where </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">swap(a,b)</span></strong><span class="koboSpan" id="kobo.971.1"> swaps the values of objects </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">a</span></strong><span class="koboSpan" id="kobo.973.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">b</span></strong><span class="koboSpan" id="kobo.975.1"> , expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">a = exchange(b,c)</span></strong><span class="koboSpan" id="kobo.977.1"> changes the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">b</span></strong><span class="koboSpan" id="kobo.979.1"> with the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">c</span></strong><span class="koboSpan" id="kobo.981.1">, returning the old value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">b</span></strong><span class="koboSpan" id="kobo.983.1"> (to assign it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">a</span></strong><span class="koboSpan" id="kobo.985.1">). </span><span class="koboSpan" id="kobo.985.2">This might look strange at first but it’s actually a very </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">useful facility.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">Consider the move constructor </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.988.1">for the following </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">simplified </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">fixed_size_array</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.992.1">
template &lt;class T&gt;
   class fixed_size_array {
      T *elems{};
      std::size_t nelems{};
   public:
      // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.993.1">      fixed_size_array(fixed_size_array &amp;&amp;other)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.994.1">         : elems{ other.elems }, nelems{ other.nelems } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.995.1">         other.elems = nullptr;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.996.1">         other.nelems = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.997.1">      }</span></strong><span class="koboSpan" id="kobo.998.1">
      // ...
</span><span class="koboSpan" id="kobo.998.2">   };</span></pre> <p><span class="koboSpan" id="kobo.999.1">You might notice that this constructor does two things: it grabs the data members from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">other</span></strong><span class="koboSpan" id="kobo.1001.1">, and then replaces the members of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">other</span></strong><span class="koboSpan" id="kobo.1003.1"> with default values. </span><span class="koboSpan" id="kobo.1003.2">That’s the posterchild for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">std::exchange()</span></strong><span class="koboSpan" id="kobo.1005.1">, so this constructor can be simplified </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1007.1">
template &lt;class T&gt;
   class fixed_size_array {
      T *elems{};
      std::size_t nelems{};
   public:
      // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.1008.1">      fixed_size_array(fixed_size_array &amp;&amp;other)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1009.1">         : elems{ std::exchange(other.elems, nullptr) },</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1010.1">           nelems{ std::exchange(other.nelems, 0) } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1011.1">      }</span></strong><span class="koboSpan" id="kobo.1012.1">
      // ...
</span><span class="koboSpan" id="kobo.1012.2">   };</span></pre> <p><span class="koboSpan" id="kobo.1013.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">std::exchange()</span></strong><span class="koboSpan" id="kobo.1015.1">, this common</span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.1016.1"> two-step operation can be reduced to a function call, simplifying code and making it more efficient (in this case, turning assignments into </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">constructor calls).</span></span></p>
</div>
</body></html>