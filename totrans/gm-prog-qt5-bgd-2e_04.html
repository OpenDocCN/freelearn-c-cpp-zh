<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom 2D Graphics with Graphics View</h1>
                </header>
            
            <article>
                
<p class="mce-root">Widgets are great for designing graphical user interfaces, but they are not convenient if you want to use multiple objects with custom painting and behavior together, such as in a 2D game. You will also run into problems if you wish to animate multiple widgets at the same time, by constantly moving them around in the application. For these situations, or generally for frequently transforming 2D graphics, Qt offers you Graphics View. In this chapter, you will learn the basics of the Graphics View architecture and its items. You will also learn how to combine widgets with Graphics View items.</p>
<p class="mce-root">The main topics covered in this chapter are as follows:</p>
<ul>
<li>Graphics View architecture</li>
<li>Coordinate systems</li>
<li>Standard graphics items</li>
<li>Pens and brushes</li>
<li>Useful features of Graphics View</li>
<li>Creating custom items</li>
<li>Event handling</li>
<li>Embedding widgets in the view</li>
<li>Optimizations</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Graphics View architecture</h1>
                </header>
            
            <article>
                
<p>The Graphics View Framework is part of the Qt Widgets module and provides a higher level of abstraction useful for custom 2D graphics. It uses software rendering by default, but it is very optimized and extremely convenient to use. Three components form the core of Graphics View, as shown:</p>
<ul>
<li>An instance of <kbd>QGraphicsView</kbd>, which is referred to as <strong>View</strong></li>
<li>An instance of <kbd>QGraphicsScene</kbd>, which is referred to as <strong>Scene</strong></li>
<li>Instances of <kbd>QGraphicsItem</kbd>, which are referred to as <strong>Items</strong></li>
</ul>
<p>The usual workflow is to first create a couple of items, add them to a scene, and then show that scene on a view:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6eb777be-ab33-4d5e-811b-a337b1ab917f.png" style="width:23.17em;height:12.83em;" width="1000" height="551"/></div>
<p>After that, you can manipulate items from the code and add new items, while the user also has the ability to interact with visible items.</p>
<p>Think of the <strong>items</strong> as Post-it notes. You take a note and write a message on it, paint an image on it, both write and paint on it, or, quite possibly, just leave it blank. Qt provides a lot of item classes, all of which inherit <kbd>QGraphicsItem</kbd>. You can also create your own item classes. Each class must provide an implementation of the <kbd>paint()</kbd> function, which performs painting of the current item, and the <kbd>boundingRect()</kbd> function, which must return the boundary of the area the <kbd>paint()</kbd> function paints on.</p>
<p>What is the <strong>scene</strong>, then? Well, think of it as a larger sheet of paper on to which you attach your smaller Post-its, that is, the notes. On the scene, you can freely move the items around while applying funny transformations to them. It is the scene's responsibility to correctly display the items' position and any transformations applied to them. The scene further informs the items about any events that affect them.</p>
<p>Last, but not least, let's turn our attention to the <strong>view</strong>. Think of the view as an inspection window or a person who holds the paper with the notes in their hands. You can see the paper as a whole, or you can only look at specific parts. Also, as a person can rotate and shear the paper with their hands, so the view can rotate and shear the scene's content and do a lot more transformations with it. <kbd>QGraphicsView</kbd> is a widget, so you can use the view like any other widget and place it into layouts for creating neat graphical user interfaces.</p>
<div class="packt_infobox">You might have looked at the preceding diagram and worried about all the items being outside the view. Aren't they wasting CPU time? Don't you need to take care of them by adding a so-called <em>view frustum culling</em> mechanism (to detect which item not to draw/render because it is not visible)? Well, the short answer is "no", because Qt is already taking care of this.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Creating a project with a Graphics View</h1>
                </header>
            
            <article>
                
<p>Let's put all these components together in a minimalistic project. From the <span class="packt_screen">Welcome</span> screen, click on the <span class="packt_screen">New Project</span> button and select <span class="packt_screen">Qt Widgets Application</span> again. Name the project <kbd>graphics_view_demo</kbd>, select the correct kit, uncheck the <span class="packt_screen">Generate form</span> checkbox, and finish the wizard. We don't actually need the <kbd>MainWindow</kbd> class that was generated for us, so let's delete it from the project. In the project tree, locate <kbd>mainwindow.h</kbd> and select <span class="packt_screen">Remove file</span> in the context menu. Enable the <span class="packt_screen">Delete file permanently</span> checkbox and click on <span class="packt_screen">OK</span>. This will result in deleting the <kbd>mainwindow.h</kbd> file from the disk and removing its name from the <kbd>graphics_view_demo.pro</kbd> file. If the file was open in Qt Creator, it will suggest that you close it. Repeat the process for <kbd>mainwindow.cpp</kbd>.</p>
<p>Open the <kbd>main.cpp</kbd> file, remove <kbd>#include "mainwindow.h"</kbd>, and write the following code:</p>
<pre>int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    QGraphicsScene scene;
    QGraphicsRectItem *rectItem = <br/>        new QGraphicsRectItem(QRectF(0, 0, 100, 50));
    scene.addItem(rectItem);
    QGraphicsEllipseItem *circleItem =
        new QGraphicsEllipseItem(QRect(0, 50, 25, 25));
    scene.addItem(circleItem);
    QGraphicsSimpleTextItem *textItem =
        new QGraphicsSimpleTextItem(QObject::tr("Demo"));
    scene.addItem(textItem);
    QGraphicsView view(&amp;scene);
    view.show();
    return a.exec();
}</pre>
<p>When you run the project, you should get the following result:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/8bcc98a5-4f2e-4bc6-b1fd-c80d34c92bde.png" style="width:13.92em;height:8.50em;" width="208" height="126"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What just happened?</h1>
                </header>
            
            <article>
                
<p>Our new project is so simple that all its code is located in the <kbd>main()</kbd> function. Let's examine the code. First, we create a <kbd>QApplication</kbd> object, as in any Qt Widgets project. Next, we create a scene object and three instances of different item classes. The constructor of each item class accepts an argument that defines the content of the item:</p>
<ul>
<li>The <kbd>QGraphicsRectItem</kbd> constructor receives a <kbd>QRectF</kbd> object that contains the coordinates of the rectangle</li>
<li>The <kbd>QGraphicsEllipseItem</kbd> constructor, similarly, receives a <kbd>QRectF</kbd> object that defines the bounding rectangle of the circle</li>
<li>The <kbd>QGraphicsSimpleTextItem</kbd> constructor receives the text to display</li>
</ul>
<div class="packt_infobox"><kbd>QRectF</kbd> is basically a helpful struct with four fields that allow us to specify four coordinates of the rectangle's boundaries (left, top, width, and height). Qt also offers <kbd>QPointF</kbd> that contains <em>x</em> and <em>y</em> coordinates of a point, <kbd>QLineF</kbd> that contains <em>x</em> and <em>y</em> coordinates of two ends of a line, and <kbd>QPolygonF</kbd> that contains a vector of points. The <kbd>F</kbd> letter stands for "floating point" and indicates that these classes hold real numbers. They are widely used in Graphics View, as it always works with floating point coordinates. The corresponding classes without <kbd>F</kbd> (<kbd>QPoint</kbd>, <kbd>QRect</kbd>, and so on) store integer coordinates and are more useful when working with widgets.</div>
<p>After creating each item, we use the <kbd>QGraphicsScene::addItem</kbd> function to add the item to the scene. Finally, we create a <kbd>QGraphicsView</kbd> object and pass the pointer to the scene to its constructor. The <kbd>show()</kbd> method will make the view visible, as it does for any <kbd>QWidget</kbd>. The program ends with an <kbd>a.exec()</kbd> call, necessary to start the event loop and keep the application alive.</p>
<p>The scene takes ownership of the items, so they will be automatically deleted along with the scene. This also means that an item can only be added to one single scene. If the item was previously added to another scene, it gets removed from there before it is added to the new scene.</p>
<div class="packt_tip">If you want to remove an item from a scene without setting it directly to another scene or without deleting it, you can call <kbd>scene.removeItem(rectItem)</kbd>. Be aware, however, that now it is your responsibility to delete <kbd>rectItem</kbd> to free the allocated memory!</div>
<p>Examine the resulting window and compare it to the coordinates of the rectangles in the code (the <kbd>QRectF</kbd> constructor we use accepts four arguments in the following order: left, top, width, height). You should be able to see that all three elements are positioned in a single coordinate system, where the <em>x</em> axis points to the right and the <em>y</em> axis points down. We didn't specify any coordinates for the text item, so it's displayed at the <strong>origin</strong> point (that is, the point with zero coordinates), next to the top-left corner of the rectangle. However, that (0, 0) point does not correspond to the top-left corner of the window. In fact, if you resize the window, you'll note that the origin has shifted relative to the window, because the view tries to display the scene's content as centered.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Coordinate systems</h1>
                </header>
            
            <article>
                
<p>To use Graphics View correctly, you need to understand how the coordinate systems in this framework work. We'll go through all the levels of hierarchy and see how we can change the positioning of items and the whole scene, on each level. We will provide examples of the code that you can paste into our demo project and examine the effect.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The item's coordinate system</h1>
                </header>
            
            <article>
                
<p>Each item has its own coordinate system. In our example of Post-it notes, the content of each note is defined relative to the top-left corner of the note. No matter how you move or rotate the item, these coordinates remain the same. The coordinates of a drawn object can usually be passed to the constructor of the class, like we did in our demo project, or to a special setter function (for example, <kbd>rectItem-&gt;setRect(0, 10, 20, 25)</kbd>). These are coordinates in the item's coordinate system.</p>
<p>Some classes, such as <kbd>QGraphicsSimpleTextItem</kbd>, do not provide the ability to change the coordinates of the content, so they're always positioned at the origin of the item's coordinate system. This is not a problem at all; as we'll see next, there are ways to change the visible position of the content.</p>
<p>If you try to create your own graphics item class (we'll get to it later in this chapter), you'll need to implement the <kbd>paint()</kbd> and <kbd>boundingRect()</kbd> functions, and they always operate in the item's coordinate system. That's right, when you're painting the content, you can just pretend that your item will never be moved or transformed. When that actually happens, Qt will take care of transforming paint operations for you. Additionally, coordinates in any events the item receives (for example, coordinates of a mouse button click) are expressed in the item's coordinate system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The scene's coordinate system</h1>
                </header>
            
            <article>
                
<p>Any item can be moved in the scene using the <kbd>setPos()</kbd> function. Try to call <kbd>textItem-&gt;setPos(50, 50)</kbd> and verify that the text was moved in the scene. Technically, this operation changes the <strong>transformation</strong> between the item's coordinate system and the scene's coordinate system. A convenience function called <kbd>moveBy()</kbd> allows you to shift the position by specified amounts.</p>
<p>An item can also be rotated with <kbd>setRotation()</kbd> and scaled with <kbd>setScale()</kbd>. Try calling <kbd>textItem-&gt;setRotation(20)</kbd> to see this in action. If you need a more advanced transformation, such as shearing, or you want to perform multiple translations in a particular order, you can create a <kbd>QTransform</kbd> object, apply the required transformations, and use the <kbd>setTransform()</kbd> function of the item.</p>
<div class="packt_infobox">The <kbd>setRotation()</kbd> function accepts <kbd>qreal</kbd> as the argument value, which is usually a typedef for <kbd>double</kbd>. The function interprets the number as degrees for a clockwise rotation around the <em>z</em> coordinate. If you set a negative value, a counter-clockwise rotation is performed. Even if it does not make much sense, you can rotate an item by 450 degrees, which will result in a rotation of 90 degrees.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The viewport's coordinate system</h1>
                </header>
            
            <article>
                
<p>The view consists of the <strong>viewport</strong> and two scrollbars. The viewport is a subwidget that actually contains the content of the scene. The view performs conversion from the scene coordinates to the viewport coordinates based on multiple parameters.</p>
<p>First, the view needs to know the bounding rectangle of everything we could want to see in the scene. It's called the <strong>scene rect</strong> and is measured in the scene's coordinate system. By default, the scene rect is the bounding rectangle of all items that were added at the scene since it was created. This is usually fine, but if you move or delete an item, that bounding rectangle will not shrink (because of performance reasons), so it may result in showing a lot of unwanted empty space. Luckily, in such cases, you can set the scene rect manually using the <kbd>setSceneRect</kbd> function of the scene or view.</p>
<div class="packt_infobox">The difference between <kbd>QGraphicsScene::setSceneRect</kbd> and <kbd>QGraphicsView::setSceneRect</kbd> is usually marginal, since you will typically have one view per scene. However, it is possible to have multiple views for a single scene. In this case, <kbd>QGraphicsScene::setSceneRect</kbd> sets the scene rect for all views, and <kbd>QGraphicsView::setSceneRect</kbd> allows you to override the scene rect for each view.</div>
<p>If the area corresponding to the scene rect is small enough to fit in the viewport, the view will align the content according to the view's <kbd>alignment</kbd> property. As we saw earlier, it positions the content at the center by default. For example, calling <kbd>view.setAlignment(Qt::AlignTop | Qt::AlignLeft)</kbd> will result in the scene staying in the upper-left corner of the view.</p>
<p>If the scene rect area is too large to fit in the viewport, the horizontal or vertical scrollbars appear by default. They can be used to scroll the view and see any point inside the scene rect (but not beyond it). The presence of scrollbars can also be configured using the  <kbd>horizontalScrollBarPolicy</kbd> and the <kbd>verticalScrollBarPolicy</kbd> properties of the view.</p>
<p>Try to call <kbd>scene.setSceneRect(0, 20, 100, 100)</kbd> and see how the view acts when resizing the window. If the window is too small, the top part of the scene will no longer be visible. If the window is large enough and the view has the default alignment, the top part of the scene will be visible, but only the defined scene rect will be centered, with no regard to the items outside of it.</p>
<p>The view provides the ability to transform the entire scene. For example, you can call <kbd>view.scale(5, 5)</kbd> to make everything five times larger, <kbd>view.rotate(20)</kbd> to rotate the scene as a whole, or <kbd>view.shear(1, 0)</kbd> to shear it. As with items, you can apply a more complex transformation using <kbd>setTransform()</kbd>.</p>
<div class="packt_infobox">You may note that Graphics View (and Qt Widgets in general) uses a <strong>left-handed</strong> coordinate system by default, where <em>x</em> axis points right and <em>y</em> axis points down. However, OpenGL and science-related applications usually use a <strong>right-handed</strong> or standard coordinate system, where <em>y</em> axis points up. If you need to change the direction of the <em>y</em> axis, the simplest solution is to transform the view by calling <kbd>view.scale(1, -1)</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Origin point of the transformation</h1>
                </header>
            
            <article>
                
<p>In our next example, we will create a cross at (0, 0) point and add a rectangle to the scene:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/29c10c5a-6843-4284-88d8-08444454723b.png" style="width:18.42em;height:19.58em;" width="310" height="328"/></div>
<p>You can do it with the following code:</p>
<pre>scene.addLine(-100, 0, 100, 0);
scene.addLine(0, -100, 0, 100);
QGraphicsRectItem* rectItem = scene.addRect(50, 50, 50, 50);</pre>
<p>In this code, we use the <kbd>addLine()</kbd> and <kbd>addRect()</kbd> <span>convenience functions</span>. This is the same as creating a <kbd>QGraphicsLineItem</kbd> or <kbd>QGraphicsRectItem</kbd> and adding it to the scene manually.</p>
<p>Now, imagine that you want to rotate the rectangle by 45 degrees to produce the following result:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/b9f23d56-4ce9-44ac-9718-77d4cfb7be27.png" style="width:17.33em;height:18.42em;" width="310" height="328"/></div>
<p>A straightforward attempt to do it will use the <kbd>setRotation()</kbd> method:</p>
<pre>QGraphicsRectItem* rectItem = scene.addRect(50, 50, 50, 50);
rectItem-&gt;setRotation(45);</pre>
<p>However, if you try to do that, you will get the following result:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/de15be54-8700-4b6f-beb0-8a9516a4baf2.png" style="width:18.92em;height:20.08em;" width="310" height="328"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What just happened?</h1>
                </header>
            
            <article>
                
<p>Most transformations depend on the <strong>origin</strong> point of the coordinate system. For rotation and scaling, the origin point is the only point that remains in place. In the preceding example, we used a rectangle with the top-left corner at (50, 50) and the size of (50, 50). These coordinates are in the item's coordinate system. Since we originally didn't move the item, the item's coordinate system was the same as the scene's coordinate system, and the origin point is the same as the scene's origin (it's the point marked with the cross). The applied rotation uses (0, 0) as the center of rotation, thus providing an unexpected result.</p>
<p>There are multiple ways to overcome this problem. The first way is to change the transform's origin point:</p>
<pre>QGraphicsRectItem* rectItem = scene.addRect(50, 50, 50, 50);
<strong>rectItem-&gt;setTransformOriginPoint(75, 75);</strong>
rectItem-&gt;setRotation(45);</pre>
<p>This code produces the rotation we want, because it changes the origin point used by the <kbd>setRotation()</kbd> and <kbd>setScale()</kbd> functions. Note that the item's coordinate system was not translated, and (75, 75) point continues to be the center of the rectangle in the item's coordinates.</p>
<p>However, this solution has its limitations. If you use <kbd>setTransform()</kbd> instead of <kbd>setRotation()</kbd>, you will get the unwanted result again:</p>
<pre>QGraphicsRectItem* rectItem = scene.addRect(50, 50, 50, 50);
rectItem-&gt;setTransformOriginPoint(75, 75);
<strong>QTransform transform;
transform.rotate(45);
rectItem-&gt;setTransform(transform);</strong></pre>
<p>Another solution is to set up the rectangle in such a way that its center is in the origin of the item's coordinate system:</p>
<pre>QGraphicsRectItem* rectItem = scene.addRect(-25, -25, 50, 50);
rectItem-&gt;setPos(75, 75);</pre>
<p>This code uses completely different rectangle coordinates, but the result is exactly the same as in our first example. However, now, (75, 75) point in the scene's coordinates corresponds to (0, 0) point in the item's coordinates, so all transformations will use it as the origin:</p>
<pre>QGraphicsRectItem* rectItem = scene.addRect(-25, -25, 50, 50);
rectItem-&gt;setPos(75, 75);
rectItem-&gt;setRotation(45);</pre>
<div class="packt_infobox">This example shows that it is usually more convenient to set up the items so that their origin point corresponds to their actual location.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Have a go hero – Applying multiple transformations</h1>
                </header>
            
            <article>
                
<p>To understand the concept of transformations and their origin point, try to apply <kbd>rotate()</kbd> and <kbd>scale()</kbd> to an item. Also, change the point of origin and see how the item will react. As a second step, use <kbd>QTransform</kbd> in conjunction with <kbd>setTransform()</kbd> to apply multiple transformations to an item in a specific order.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parent–child relationship between items</h1>
                </header>
            
            <article>
                
<p>Imagine that you need to create a graphics item that contains multiple geometric primitives, for example, a circle inside a rectangle. You can create both items and add them to the scene individually, but this solution is inconvenient. First, when you need to remove that combination from the scene, you would need to manually delete both items. However, more importantly, when you need to move or transform the combination, you will need to calculate positions and complex transformations for each graphics item.</p>
<p>Fortunately, graphics items do not have to be a flat list of items added directly into the scene. Items can be added into any other items, forming a parent–child relationship very similar to the relationship of <kbd>QObject</kbd> that we observed in the last chapter:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/a5c4acc7-403c-40cc-a181-ea784a629bfa.png" style="width:22.58em;height:10.75em;" width="1000" height="476"/></div>
<p>Adding an item as a child of another item has the following consequences:</p>
<ul>
<li>When the parent item is added to the scene, the child item automatically becomes part of that scene, so there is no need to call <kbd>QGraphicsScene::addItem()</kbd> for it.</li>
<li>When the parent item is deleted, its children are also deleted.</li>
<li>When the parent item is hidden using the <kbd>hide()</kbd> or <kbd>setVisible(false)</kbd> functions, the child items will also be hidden.</li>
<li>Most importantly, the child's coordinate system is derived from the parent's coordinate system instead of the scene's. This means that when the parent is moved or transformed, all children are also affected. The child's position and transformations are relative to the parent's coordinate system.</li>
</ul>
<div class="packt_tip">You can always check whether an item has a parent using the <kbd>parentItem()</kbd> function, and check the returned <kbd>QGraphicsItem</kbd> pointer against <kbd>nullptr</kbd>, which means that the item does not have a parent. To figure out whether there are any children, call the <kbd>childItems()</kbd> function on the item. A <kbd>QList</kbd> method with the <kbd>QGraphicsItem</kbd> pointers to all child items is returned.</div>
<p>For a better understanding of <kbd>pos()</kbd> and the involved coordinate systems, think of post-it notes again. If you put a note on a larger sheet of paper and then had to determine its exact position, how would you do it? Probably like this: "The note's upper-left corner is positioned 3 cm to the right and 5 cm to the bottom from the paper's top-left edge". In the Graphics View world, this will correspond to a parentless item whose <kbd>pos()</kbd> function returns a position in the scene coordinates, since the item's origin is directly pinned to the scene. On the other hand, say you put a note A on top of a (larger) note B, which is already pinned on a paper, and you have to determine A's position; how would you describe it this time? Probably by saying that note A is placed on top of note B or "2 cm to the right and 1 cm to the bottom from the top-left edge of note B". You most likely wouldn't use the underlying paper as a reference since it is not the next point of reference. This is because if you move note B, A's position regarding the paper will change, whereas A's relative position to B still remains unchanged. To switch back to Graphics View, the equivalent situation is an item that has a parent item. In this case, the <kbd>pos()</kbd> function's returned value is expressed in the coordinate system of its parent. So, <kbd>setPos()</kbd> and <kbd>pos()</kbd> specify the position of the item's origin in relation to the next (higher) point of reference. This can be the scene or the item's parent item.</p>
<p>Keep in mind, however, that changing an item's position does not affect the item's internal coordinate system.</p>
<div class="packt_infobox">For widgets, the child always occupies a subarea of its direct parent. For graphics items, such a rule does not apply by default. A child item can be displayed outside the bounding rectangle or visible content of the parent. In fact, a common situation is when the parent item does not have any visual content by itself and only serves as a container for a set of primitives belonging to one object.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Using child items</h1>
                </header>
            
            <article>
                
<p>Let's try to make an item containing multiple children. We want to create a rectangle with a filled circle in each corner and be able to move and rotate it as a whole, like this:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/94aa7f68-0fd5-43ec-bd98-c60c8da3a39b.png" style="width:20.25em;height:9.92em;" width="366" height="177"/></div>
<p>First, you need to create a function that creates a single complex rectangle, by using the following code:</p>
<pre>QGraphicsRectItem *createComplexItem(<br/>    qreal width, qreal height, qreal radius) <br/>{
    QRectF rect(-width / 2, -height / 2, width, height);
    QGraphicsRectItem *parent = new QGraphicsRectItem(rect);
    QRectF circleBoundary(-radius, -radius, 2 * radius, 2 * radius);
    for(int i = 0; i &lt; 4; i++) {
        QGraphicsEllipseItem *child =
            new QGraphicsEllipseItem(circleBoundary, parent);
        child-&gt;setBrush(Qt::black);
        QPointF pos;
        switch(i) {
        case 0:
            pos = rect.topLeft();
            break;
        case 1:
            pos = rect.bottomLeft();
            break;
        case 2:
            pos = rect.topRight();
            break;
        case 3:
            pos = rect.bottomRight();
            break;
        }
        child-&gt;setPos(pos);
    }
    return parent;
}</pre>
<p>We start with creating a <kbd>QRectF</kbd> variable that contains the rectangle coordinates in the item's coordinate system. Following the tip we provided earlier, we create a rectangle centered at the origin point. Next, we create a rectangle graphics item called <kbd>parent</kbd>, as usual. The <kbd>circleBoundary</kbd> rectangle is set to contain the boundary rect of a single circle (again, the center is at the origin point). When we create a new <kbd>QGraphicsEllipseItem</kbd> for each corner, we pass <kbd>parent</kbd> to the constructor, so the new circle item is automatically added as a child of the rectangle item.</p>
<p>To set up a child circle, we first use the <kbd>setBrush()</kbd> function that enables filling of the circle. This function expects a <kbd>QBrush</kbd> object that allows you to specify an advanced filling style, but in our simple case, we use an implicit conversion from the <kbd>Qt::GlobalColor</kbd> enum to <kbd>QBrush</kbd>. You will learn more about brushes later in this chapter.</p>
<p>Next, we select a different corner of the rectangle for each circle and call <kbd>setPos()</kbd> to move the circle to that corner. Finally, we return the parent item to the caller.</p>
<p>You can use this function as follows:</p>
<pre>QGraphicsRectItem *item1 = createComplexItem(100, 60, 8);
scene.addItem(item1);

QGraphicsRectItem *item2 = createComplexItem(100, 60, 8);
scene.addItem(item2);
item2-&gt;setPos(200, 0);
item2-&gt;setRotation(20);</pre>
<p>Note that when you call <kbd>setPos()</kbd>, the circles are moved along with the parent item, but the <kbd>pos()</kbd> values of the circles do not change. This is the consequence of the fact that <kbd>pos()</kbd> means the position relative to the parent item (or the scene's origin, if there is no parent item). When the rectangle is rotated, circles rotate with it, as if they were fixed to the corners. If the circles weren't children of the rectangle, positioning them properly, in this case, would be a more challenging task.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Have a go hero – Implementing the custom rectangle as a class</h1>
                </header>
            
            <article>
                
<p>In this example, we avoided creating a class for our custom rectangle to keep the code as simple as possible. Following the principles of object-oriented programming, subclassing <kbd>QGraphicsRectItem</kbd> and creating children items in the constructor of the new class is a good idea. Doing this doesn't require anything you don't already know. For example, when subclassing <kbd>QGraphicsRectItem</kbd>, you don't need to implement any virtual functions, because they are all properly implemented in the base classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Conversions between coordinate systems</h1>
                </header>
            
            <article>
                
<p>If an item is simply moved using <kbd>setPos()</kbd>, conversion from the item's coordinates to the scene coordinates is as simple as <kbd>sceneCoord = itemCoord + item-&gt;pos()</kbd>. However, this conversion quickly becomes very complex when you use transformations and parent–child relationships, so you should always use dedicated functions to perform such conversions. <kbd>QGraphicsItem</kbd> provides the following functions:</p>
<p> </p>
<table class="table">
<tbody>
<tr>
<td><strong>Function</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>
<p><br/>
<kbd>mapToScene(</kbd><br/>
<kbd>  const QPointF &amp;point)</kbd></p>
</td>
<td>
<p>Maps the point <kbd>point</kbd> that is in the item's coordinate system to the corresponding point in the scene's coordinate system.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>scenePos()</kbd></p>
</td>
<td>
<p>Maps the item's origin point to the scene's coordinate system. This is the same as <kbd>mapToScene(0, 0)</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sceneBoundingRect()</kbd></p>
</td>
<td>
<p>Returns the item's bounding rectangle in the scene's coordinate system.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mapFromScene(</kbd><br/>
<kbd>  const QPointF &amp;point)</kbd></p>
</td>
<td>
<p>Maps the point <kbd>point</kbd> that is in the scene's coordinate system to the corresponding point in the item's coordinate system. This function is the reverse function to <kbd>mapToScene()</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mapToParent(</kbd><br/>
<kbd>  const QPointF &amp;point)</kbd></p>
</td>
<td>
<p>Maps the point <kbd>point</kbd> that is in the item's coordinate system to the corresponding point in the coordinate system of the item's parent. If the item does not have a parent, this function behaves like <kbd>mapToScene()</kbd>; thus, it returns the corresponding point in the scene's coordinate system.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mapFromParent(</kbd><br/>
<kbd>  const QPointF &amp;point)</kbd></p>
</td>
<td>
<p>Maps the point <kbd>point</kbd> that is in the coordinate system of the item's parent to the corresponding point in the item's own coordinate system. This function is the reverse function to <kbd>mapToParent()</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mapToItem(</kbd><br/>
<kbd>  const QGraphicsItem *item,</kbd><br/>
<kbd> const QPointF &amp;point)</kbd></p>
</td>
<td>
<p>Maps the point <kbd>point</kbd> that is in the item's own coordinate system to the corresponding point in the coordinate system of the item <kbd>item</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mapFromItem(</kbd><br/>
<kbd>  const QGraphicsItem *item,</kbd><br/>
<kbd> const QPointF  &amp;point)</kbd></p>
</td>
<td>
<p>Maps the point <kbd>point</kbd> that is in the coordinate system of the item <kbd>item</kbd> to the corresponding point in the item's own coordinate system. This function is the reverse function to <kbd>mapToItem()</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>What is great about these functions is that they are not only available for <kbd>QPointF</kbd>. The same functions are also available for <kbd>QRectF</kbd>, <kbd>QPolygonF</kbd>, and <kbd>QPainterPath</kbd>, not to mention that there are some convenience functions:</p>
<ul>
<li>If you call these functions with two numbers of the <kbd>qreal</kbd> <span>type, </span>the numbers are interpreted as the <em>x</em> and <em>y</em> coordinates of a <kbd>QPointF</kbd> pointer</li>
<li>If you call the functions with four numbers, the numbers are interpreted as the <em>x</em> and <em>y</em> coordinates and the width and height of a <kbd>QRectF</kbd> parameter</li>
</ul>
<p>The <kbd>QGraphicsView</kbd> class also contains a set of <kbd>mapToScene()</kbd> functions that map coordinates from the viewport's coordinate system to the scene coordinates and <kbd>mapFromScene()</kbd> functions that map the scene coordinates to the viewport coordinates.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Overview of functionality</h1>
                </header>
            
            <article>
                
<p>You should now have some understanding of Graphics View's architecture and transformation mechanics. We will now describe some easy-to-use functionality that you'll probably need when creating a Graphics View application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Standard items</h1>
                </header>
            
            <article>
                
<p>In order to effectively use the framework, you need to know what graphics item classes it provides. It's important to identify the classes you can use to construct the desirable picture and resort to creating a custom item class, only if there is no suitable item or you need better performance. Qt comes with the following standard items that make your life as a developer much easier:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Standard item</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsLineItem</kbd></p>
</td>
<td>
<p>Draws a line. You can define the line with <kbd>setLine(const QLineF&amp;)</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsRectItem</kbd></p>
</td>
<td>
<p>Draws a rectangle. You can define the rectangle's geometry with <kbd>setRect(const QRectF&amp;)</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsEllipseItem</kbd></p>
</td>
<td>
<p>Draws an ellipse or an ellipse segment. You can define the rectangle within which the ellipse is being drawn with <kbd>setRect(const QRectF&amp;)</kbd>. Additionally, you can define whether only a segment of the ellipse should be drawn by calling <kbd>setStartAngle(int)</kbd> and <kbd>setSpanAngle(int)</kbd>. The arguments of both functions are in sixteenths of a degree.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsPolygonItem</kbd></p>
</td>
<td>
<p>Draws a polygon. You can define the polygon with <kbd>setPolygon(const QPolygonF&amp;)</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsPathItem</kbd></p>
</td>
<td>
<p>Draws a path, that is, a set of various geometric primitives. You can define the path with <kbd>setPath(const QPainterPath&amp;)</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsSimpleTextItem</kbd></p>
</td>
<td>
<p>Draws plain text. You can define the text with <kbd>setText(const QString&amp;)</kbd> and the font with <kbd>setFont(const QFont&amp;)</kbd>. This item doesn't support rich formatting.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsTextItem</kbd></p>
</td>
<td>
<p>Draws formatted text. Unlike <kbd>QGraphicsSimpleTextItem</kbd>, this item can display HTML stored in a <kbd>QTextDocument</kbd> object. You can set HTML with <kbd>setHtml(const QString&amp;)</kbd> and the document with <kbd>setDocument(QTextDocument*)</kbd>. <kbd>QGraphicsTextItem</kbd> can even interact with the displayed text so that text editing or URL opening is possible.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsPixmapItem</kbd></p>
</td>
<td>
<p>Draws a pixmap (a raster image). You can define the pixmap with <kbd>setPixmap(const QPixmap&amp;)</kbd>. It's possible to load pixmaps from local files or resources, similar to icons (refer to <a href="ebffc011-752f-4dbe-a383-0917a002841d.xhtml">Chapter 3</a>, <em>Qt GUI Programming</em>, for more information about resources).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QGraphicsProxyWidget</kbd></p>
</td>
<td>
<p>Draws an arbitrary <kbd>QWidget</kbd> and allows you to interact with it. You can set the widget with <kbd>setWidget(QWidget*)</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As we already saw, you can usually pass the content of the item to the constructor instead of calling a setter method such as <kbd>setRect()</kbd>. However, keep in mind that compact code may be harder to maintain than code that sets all the variables through setter methods.</p>
<p>For most items, you can also define which pen and which brush should be used. The pen is set with <kbd>setPen()</kbd> and the brush with <kbd>setBrush()</kbd> (we've already used it for the child circles in the previous example). These two functions, however, do not exist for <kbd>QGraphicsTextItem</kbd>. To define the appearance of a <kbd>QGraphicsTextItem</kbd> item, you have to use <kbd>setDefaultTextColor()</kbd> or HTML tags supported by Qt. <kbd>QGraphicsPixmapItem</kbd> has no similar methods, as the concepts of pen and brush cannot be applied to pixmaps.</p>
<div class="packt_tip">Use <kbd>QGraphicsSimpleTextItem</kbd> wherever possible and try to avoid <kbd>QGraphicsTextItem,</kbd> if it is not absolutely necessary. The reason is that <kbd>QGraphicsTextItem</kbd> is a subclass of <kbd>QObject</kbd> and uses <kbd>QTextDocument</kbd>, which is basically an HTML engine (although quite limited). This is way heavier than an average graphics item and is definitely too much overhead for displaying simple text.</div>
<p>It is generally easier to use standard items than to implement them from scratch. Whenever you will use Graphics View, ask yourself these questions: Which standard items are suited for my specific needs? Am I re-inventing the wheel over and over again? However, from time to time, you need to create custom graphics items, and we'll cover this topic later in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Anti-aliasing</h1>
                </header>
            
            <article>
                
<p>If you look at the result of the previous screenshot, you can probably note that the drawing looks pixelated. This happens because each pixel in a line is completely black, and all the surrounding pixels are completely white. The physical display's resolution is limited, but a technique called <strong>anti-aliasing</strong> allows you to produce more smooth images with the same resolution. When drawing a line with anti-aliasing, some pixels will be more or less blacker than others, depending on how the line crosses the pixel grid.</p>
<p>You can easily enable anti-aliasing in Graphics View using the following code:</p>
<pre>view.setRenderHint(QPainter::Antialiasing);</pre>
<p>With the anti-aliasing flag turned on, the painting is done much more smoothly:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/8e604129-e7ec-41fd-83f2-046bf4eb0d4c.png" style="width:21.83em;height:9.50em;" width="370" height="161"/></div>
<p>However, lines in the rectangle on the left now look thicker. This happens because we used lines with integer coordinates and 1 pixel width. Such a line is located exactly on the border between two rows of pixels, and when anti-aliased, both adjacent rows of pixels will be partially painted. This can be fixed by adding 0.5 to all coordinates:</p>
<pre>QRectF rect(-width / 2, -height / 2, width, height);
<strong>rect.translate(0.5, 0.5);</strong>
QGraphicsRectItem *parent = new QGraphicsRectItem(rect);</pre>
<p>Now the line is positioned right in the middle of a pixel row, so it only occupies a single row:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/fee58494-72a0-401e-b359-2751ce199ed7.png" style="width:21.33em;height:9.92em;" width="392" height="182"/></div>
<p>Another solution is to implement a custom item class and disable anti-aliasing when painting a horizontal or vertical line.</p>
<p><kbd>QGraphicsView</kbd> also supports the <kbd>QPainter::TextAntialiasing</kbd> flag that enables anti-aliasing when drawing text, and the <kbd>QPainter::SmoothPixmapTransform</kbd> flag that enables smooth pixmap transformation. Note the anti-aliasing and smoothing impact performance of your application, so use them only when needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pens and brushes</h1>
                </header>
            
            <article>
                
<p>The pen and brush are two attributes that define how different drawing operations are performed. The pen (represented by the <kbd>QPen</kbd><span> class)</span> defines the outline, and the brush  <span>(represented by the </span><kbd>QBrush</kbd><span> class) </span>fills the drawn shapes. Each of them is really a set of parameters. The most simple one is the color defined, either as a predefined global color enumeration value (such as <kbd>Qt::red</kbd> or <kbd>Qt::transparent</kbd>), or an instance of the <kbd>QColor</kbd> class. The effective color is made up of four attributes: three color components (red, green, and blue) and an optional alpha channel value that determines the transparency of the color (the larger the value, the more opaque the color). By default, all components are expressed as 8-bit values (0 to 255) but can also be expressed as real values representing a percentage of the maximum saturation of the component; for example, 0.6 corresponds to 153 (0.6⋅255). For convenience, one of the <kbd>QColor</kbd> constructors accepts hexadecimal color codes used in HTML (with <kbd>#0000FF</kbd> being an opaque blue color) or even bare color names (for example, <kbd>blue</kbd>) from a predefined list of colors returned by a static function—<kbd>QColor::colorNames()</kbd>. Once a color object is defined using RGB components, it can be queried using different color spaces (for example, CMYK or HSV). Also, a set of static methods are available that act as constructors for colors expressed in different color spaces.</p>
<p>For example, to construct a clear magenta color any of the following expressions can be used:</p>
<ul>
<li><kbd>QColor("magenta")</kbd></li>
<li><kbd>QColor("#FF00FF")</kbd></li>
<li><kbd>QColor(255, 0, 255)</kbd></li>
<li><kbd>QColor::fromRgbF(1, 0, 1)</kbd></li>
<li><kbd>QColor::fromHsv(300, 255, 255)</kbd></li>
<li><kbd>QColor::fromCmyk(0, 255, 0, 0)</kbd></li>
<li><kbd>Qt::magenta</kbd></li>
</ul>
<p>Apart from the color, <kbd>QBrush</kbd> has two additional ways of expressing the fill of a shape. You can use <kbd>QBrush::setTexture()</kbd> to set a pixmap that will be used as a stamp or <kbd>QBrush::setGradient()</kbd> to make the brush use a gradient to do the filling. For example, to use a gradient that goes diagonally and starts as yellow in the top-left corner of the shape, becomes red in the middle of the shape, and ends as magenta at the bottom-right corner of the shape, the following code can be used:</p>
<pre>QLinearGradient gradient(0, 0, width, height);
gradient.setColorAt(0,   Qt::yellow);
gradient.setColorAt(0.5, Qt::red);
gradient.setColorAt(1.0, Qt::magenta);
QBrush brush = gradient; </pre>
<p>When used with drawing a rectangle, this code will give the following output:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/507836c9-026d-43d4-a40e-2906b785ae8f.png" style="width:14.58em;height:14.58em;" width="400" height="400"/></div>
<p>Qt can handle linear (<kbd>QLinearGradient</kbd>), radial (<kbd>QRadialGradient</kbd>), and conical (<kbd>QConicalGradient</kbd>) gradients. Qt provides a <span class="packt_screen">Gradients</span> example (shown in the following screenshot) where you can see different gradients in action:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/d0639b60-4645-4d39-81b8-cbdc0c722790.png" style="width:37.83em;height:34.83em;" width="752" height="693"/></div>
<p>As for the pen, its main attribute is its width (expressed in pixels), which determines the thickness of the shape outline. A pen can, of course, have a color set but, in addition to that, you can use any brush as a pen. The result of such an operation is that you can draw thick outlines of shapes using gradients or textures.</p>
<p>There are three more important properties for a pen. The first is the pen style, set using <kbd>QPen::setStyle()</kbd>. It determines whether lines drawn by the pen are continuous or divided in some way (dashes, dots, and so on). You can see the available line styles here:</p>
<div class="figure CDPAlignLeft CDPAlign">                                     <img src="Images/0f854294-e767-4d1f-a34a-ee44fb5137fa.png" style="width:30.83em;height:4.42em;" width="649" height="93"/></div>
<p>The second attribute is the cap style, which can be flat, square, or round. The third attribute—the join style—is important for polyline outlines and dictates how different segments of the polyline are connected. You can make the joins sharp (with <kbd>Qt::MiterJoin</kbd> or <kbd>Qt::SvgMiterJoin</kbd>), round (<kbd>Qt::RoundJoin</kbd>), or a hybrid of the two (<kbd>Qt::BevelJoin</kbd>). You can see the different pen attribute configurations (including different join and cap styles) in action by launching the <span class="packt_screen">Path Stroking</span> example shown in the following screenshot:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/d6804e9a-8cc2-44e2-9be5-2cbaf2cb9ff5.png" style="width:32.92em;height:37.75em;" width="663" height="759"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Item selection</h1>
                </header>
            
            <article>
                
<p>The scene supports the ability of selecting items, similar to how you select files in a file manager. To be selectable, an item must have the <kbd>QGraphicsItem::ItemIsSelectable</kbd> flag turned on. Try to add <kbd>parent-&gt;setFlag(QGraphicsItem::ItemIsSelectable, true)</kbd> to the <kbd>createComplexItem()</kbd> function we created earlier. Now, if you run the application and click on a rectangle, it is selected, which is indicated by dashed lines:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/8e77e8b5-c994-4b3d-b06b-932f690e8da7.png" style="width:22.58em;height:11.17em;" width="370" height="182"/></div>
<p>You can use the <em><span class="KeyPACKT">Ctrl</span></em> button to select multiple items at once. Alternatively, you can call <kbd>view.setDragMode(QGraphicsView::RubberBandDrag)</kbd> to activate the rubber band selection for the view.</p>
<div class="packt_tip">Another useful drag mode of the <span>Graphics View</span> is <kbd>ScrollHandDrag</kbd>. It allows you to scroll the view by dragging the scene with the left mouse button, without the need to use scrollbars.</div>
<p>Besides that, there are different ways to select items programmatically. There is the item's <kbd>QGraphicsItem::setSelected()</kbd> function, which takes a <kbd>bool</kbd> value to toggle the selection state on or off, or you can call <kbd>QGraphicsScene::setSelectionArea()</kbd> on the scene, which takes a <kbd>QPainterPath</kbd> parameter as an argument, in which case all items within the area are selected.</p>
<p>With the scene's <kbd>QGraphicsScene::selectedItems()</kbd> function, you can query the actual selected items. The function returns a <kbd>QList</kbd> holding <kbd>QGraphicsItem</kbd> pointers to the selected items. For example, calling <kbd>QList::count()</kbd> on that list will give you the number of selected items. To clear the selection, call <kbd>QGraphicsScene::clearSelection()</kbd>. To query the selection state of an item, use <kbd>QGraphicsItem::isSelected()</kbd>, which returns <kbd>true</kbd> if the item is selected and <kbd>false</kbd> otherwise.</p>
<div class="packt_tip">Another interesting flag of <kbd>GraphicsItem</kbd> is <kbd>ItemIsMovable</kbd>. It enables you to drag the item within the scene by holding it with the left mouse button, effectively changing the <kbd>pos()</kbd> of the item. Try to add <kbd>parent-&gt;setFlag(QGraphicsItem::ItemIsMovable, true)</kbd> to our <kbd>createComplexItem</kbd> function and drag around the rectangles.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Keyboard focus in graphics scene</h1>
                </header>
            
            <article>
                
<p>The scene implements the concept of focus that works similar to keyboard focus in widgets. Only one item can have focus at a time. When the scene receives a keyboard event, it is dispatched to the focus item.</p>
<p>To be focusable, an item must have the <kbd>QGraphicsItem::ItemIsFocusable</kbd> flag enabled:</p>
<pre>item1-&gt;setFlag(QGraphicsItem::ItemIsFocusable, true);<br/>item2-&gt;setFlag(QGraphicsItem::ItemIsFocusable, true);</pre>
<p>Then, an item can be focused by a mouse click. You can also change the focused item from the code:</p>
<pre>item1-&gt;setFocus();</pre>
<p>Another way to set the focus is to use the scene's <kbd>QGraphicsScene::setFocusItem()</kbd> function, which expects a pointer to the item you like to focus as a parameter. Every time an item gains focus, the previously focused item (if any) will automatically <span>lose focus</span>.</p>
<p>To determine whether an item has focus, you again have two possibilities. One is that you can call <kbd>QGraphicsItem::hasFocus()</kbd> on an item, which returns <kbd>true</kbd> if the item has focus or <kbd>false</kbd> otherwise. Alternatively, you can get the actual focused item by calling the scene's <kbd>QGraphicsScene::focusItem()</kbd> method. On the other hand, if you call the item's <kbd>QGraphicsItem::focusItem()</kbd> function, the focused item is returned if the item itself or any descendant item has focus; otherwise, <kbd>nullptr</kbd> is returned. To remove focus, call <kbd>clearFocus()</kbd> on the focused item or click somewhere in the scene's background or on an item that cannot get focus.</p>
<div class="packt_tip">If you want a click on the scene's background not to cause the focused item to lose its focus, set the scene's <kbd>stickyFocus</kbd> property to <kbd>true</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Painter paths</h1>
                </header>
            
            <article>
                
<p>If you want to create a graphics item that consists of multiple geometric primitives, creating multiple <kbd>QGraphicsItem</kbd> objects seems to be tedious. Fortunately, Qt provides a  <kbd>QGraphicsPathItem</kbd> class that allows you to specify a number of primitives in a <kbd>QPainterPath</kbd> object. <kbd>QPainterPath</kbd> allows you to "record" multiple painting instructions (including filling, outlining, and clipping), and then efficiently reuse them multiple times.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Adding path items to the scene</h1>
                </header>
            
            <article>
                
<p>Let's paint a few objects consisting of a large number of lines:</p>
<pre>static const int SIZE = 100;
static const int MARGIN = 10;
static const int FIGURE_COUNT = 5;
static const int LINE_COUNT = 500;
for(int figureNum = 0; figureNum &lt; FIGURE_COUNT; ++figureNum) {
    QPainterPath path;
    path.moveTo(0, 0);
    for(int i = 0; i &lt; LINE_COUNT; ++i) {
        path.lineTo(qrand() % SIZE, qrand() % SIZE);
    }
    QGraphicsPathItem *item = scene.addPath(path);
    item-&gt;setPos(figureNum * (SIZE + MARGIN), 0);
}</pre>
<p>For each item, we first create a <kbd>QPainterPath</kbd> and set the current position to (0, 0). Then, we use the <kbd>qrand()</kbd> function to generate random numbers, apply the modulus operator (<kbd>%</kbd>) to produce a number from 0 to <kbd>SIZE</kbd> (excluding <kbd>SIZE</kbd>), and feed them to the <kbd>lineTo()</kbd> function that strokes a line from the current position to the given position and sets it as the new current position. Next, we use the <kbd>addPath()</kbd> convenience function that creates a <kbd>QGraphicsPathItem</kbd> object and adds it to the scene. Finally, we use <kbd>setPos()</kbd> to move each item to a different position in the scene. The result looks like this:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/4ad6b1a5-f2dd-4d74-bec6-c3136354f36e.png" style="width:38.75em;height:10.17em;" width="612" height="160"/></div>
<div class="packt_infobox"><kbd>QPainterPath</kbd> allows you to use practically every paint operation Qt supports. For example, <kbd>QGraphicsPathItem</kbd> is the only standard item able to draw Bezier curves in the scene, as <kbd>QPainterPath</kbd> supports them. Refer to the <span>documentation of </span><kbd>QPainterPath</kbd> for more information.</div>
<p>Using painter paths in this example is very efficient, because we avoided creating thousands of individual line objects on the heap. However, putting a large part of a scene in a single item may reduce the performance. When parts of the scene are separate graphics items, Qt can efficiently determine which items are not visible and skip drawing them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Z-order of items</h1>
                </header>
            
            <article>
                
<p>Have you wondered what happens when multiple items are painted in the same area of the scene? Let's try to do this:</p>
<pre>QGraphicsEllipseItem *item1 = scene.addEllipse(0, 0, 100, 50);
item1-&gt;setBrush(Qt::red);
QGraphicsEllipseItem *item2 = scene.addEllipse(50, 0, 100, 50);
item2-&gt;setBrush(Qt::green);
QGraphicsEllipseItem *item3 = scene.addEllipse(0, 25, 100, 50);
item3-&gt;setBrush(Qt::blue);
QGraphicsEllipseItem *item4 = scene.addEllipse(50, 25, 100, 50);
item4-&gt;setBrush(Qt::gray);</pre>
<p class="mce-root">By default, items are painted in the order they were added, so the last item will be displayed in front of the others:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/58e6925e-58dc-4a7e-bd50-c84426f473c5.png" style="width:12.83em;height:7.83em;" width="208" height="126"/></div>
<p>However, you can change the <strong>z-order</strong> by calling the <kbd>setZValue()</kbd> function:</p>
<pre>item2-&gt;setZValue(1);</pre>
<p>The second item is now displayed in front of the others:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/39ea5b10-7e79-4c56-ab83-06a045cf001b.png" style="width:15.17em;height:9.25em;" width="208" height="126"/></div>
<p>Items with a higher <em>z</em> value are displayed on top of the items with lower <em>z</em> values. The default <em>z</em> value is 0. Negative values are also possible. If items have the same <em>z</em> value, the order of insertion decides the placement, and items added later overlap those added earlier.</p>
<p>Ability to change the z-order of items is very important when developing 2D games. Any scene typically consists of a number of layers that must be painted in a specific order. You can set a <em>z</em> value for each item based on the layer this item belongs to.</p>
<div class="packt_infobox">The parent–child relationship between items also has an impact on the z-order. Children are displayed on top of their parent. Additionally, if an item is displayed in front of another item, the children of the former are also displayed in front of the children of the latter.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ignoring transformations</h1>
                </header>
            
            <article>
                
<p>If you try to zoom in on our custom rectangles scene (for example, by calling <kbd>view.scale(4, 4)</kbd>) , you will note that everything is scaled proportionally, as you would expect. However, there are situations where you don't want some elements to be affected by scale or other transformations. Qt provides multiple ways to deal with it.</p>
<p>If you want lines to always have the same width, regardless of the zoom, you need to make the pen cosmetic:</p>
<pre>QPen pen = parent-&gt;pen();
pen.setCosmetic(true);
parent-&gt;setPen(pen);</pre>
<p>Now, the rectangles will always have lines with one-pixel width, regardless of the view's scale (anti-aliasing can still blur them, though). It's also possible to have cosmetic pens with any width, but using them in Graphics View is not recommended.</p>
<p>Another common situation where you don't want transformation to apply is displaying text. Rotating and shearing text usually makes it unreadable, so you'd usually want to make it horizontal and untransformed. Let's try to add some text to our project and look at how we can solve this problem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Adding text to a custom rectangle</h1>
                </header>
            
            <article>
                
<p>Let's add a number to each of the corner circles:</p>
<pre>child-&gt;setPos(pos);
QGraphicsSimpleTextItem *text =
    new QGraphicsSimpleTextItem(QString::number(i), child);
text-&gt;setBrush(Qt::green);
text-&gt;setPos(-text-&gt;boundingRect().width() / 2,
             -text-&gt;boundingRect().height() / 2);</pre>
<p>The <kbd>QString::number(i)</kbd> function returns the string representation of number <kbd>i</kbd>. The text item is a child of the circle item, so its position is relative to the circle's origin point (in our case, its center). As we saw earlier, the text is displayed to the top-left of the item's origin, so if we want to center the text within the circle, we need to shift it up and right by half of the item's size. Now the text is positioned and rotated along with its parent circle:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/cce0ca8a-314d-4c25-8641-d16a88cdd8bd.png" style="width:25.33em;height:10.25em;" width="453" height="183"/></div>
<p>However, we don't want the text to be rotated, so we need to enable the <kbd>ItemIgnoresTransformations</kbd> flag for the text item:</p>
<pre>text-&gt;setFlag(QGraphicsItem::ItemIgnoresTransformations);</pre>
<p>This flag makes the item ignore any transformations of its parent items or the view. However, the origin of its coordinate system is still defined by the position of <kbd>pos()</kbd> in the parent's coordinate system. So, the text item will still follow the circle, but it will no longer be scaled or rotated:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/ed297d98-80a2-48cd-ae0d-b721952e66eb.png" style="width:23.83em;height:11.92em;" width="364" height="182"/></div>
<p>However, now we hit another problem: the text is no longer properly centered in the circle. It will become more apparent if you scale the view again. Why did that happen? With the <kbd>ItemIgnoresTransformations</kbd> flag, our <kbd>text-&gt;setPos(...)</kbd> statement is no longer correct. Indeed, <kbd>pos()</kbd> uses coordinates in the parent's coordinate system, but we used the result of <kbd>boundingRect()</kbd>, which uses the item's coordinate system. These two coordinate systems were the same before, but with the <kbd>ItemIgnoresTransformations</kbd> flag enabled, they are now different.</p>
<p>To elaborate on this problem, let's see what happens with the coordinates (we will consider only <em>x</em> coordinate, since <em>y</em> behaves the same). Let's say that our text item's width is eight pixels, so the <kbd>pos()</kbd> we set has <kbd>x = -4</kbd>. When no transformations are applied, this <kbd>pos()</kbd> results in shifting the text to the left by four pixels. If the <kbd>ItemIgnoresTransformations</kbd> flag is disabled and the view is scaled by 2, the text is shifted by eight pixels relative to the circle's center, but the size of the text itself is now 16 pixels, so it's still centered. If the <kbd>ItemIgnoresTransformations</kbd> flag is enabled, the text is still shifted to the left by eight pixels relative to the circle's center (because <kbd>pos()</kbd> operates in the parent item's coordinate system, and the circle is scaled), but the width of the item is now 8, because it ignores the scale and so it's no longer centered. When the view is rotated, the result is even more incorrect, because <kbd>setPos()</kbd> will shift the item in the direction that depends on the rotation. Since the text item itself is not rotated, we always want to shift it up and left.</p>
<p>This problem would go away if the item were already centered around its origin. Unfortunately, <kbd>QGraphicsSimpleTextItem</kbd> can't do this. Now, if it were  <kbd>QGraphicsRectItem</kbd>, doing this would be easy, but nothing stops us from adding a rectangle that ignores transformations and then adding text inside that rectangle! Let's do this:</p>
<pre>QGraphicsSimpleTextItem *text =
        new QGraphicsSimpleTextItem(QString::number(i));
QRectF textRect = text-&gt;boundingRect();
textRect.translate(-textRect.center());
QGraphicsRectItem *rectItem = new QGraphicsRectItem(textRect, child);
rectItem-&gt;setPen(QPen(Qt::green));
rectItem-&gt;setFlag(QGraphicsItem::ItemIgnoresTransformations);
text-&gt;setParentItem(rectItem);
text-&gt;setPos(textRect.topLeft());
text-&gt;setBrush(Qt::green);</pre>
<p>In this code, we first create a text item, but don't set its parent. Next, we get the bounding rect of the item that will tell us how much space the text needs. Then, we shift the rect so that its center is at the origin point (0, 0). Now we can create a rect item for this rectangle, set the circle as its parent, and disable transformations for the rect item. Finally, we set the rect item as the parent of the text item and change the position of the text item to place it inside the rectangle.</p>
<p>The rectangle is now properly positioned at the center of the circle, and the text item always follows the rectangle, as children usually do:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/1c50bcd2-4d81-4f14-9218-4cc2d2ad76d4.png" style="width:40.92em;height:16.58em;" width="713" height="289"/></div>
<div class="packt_tip">Since we didn't originally want the rectangle, we may want to hide it. We can't use <kbd>rectItem-&gt;hide()</kbd> in this case, because that would also result in hiding its child item (the text). The solution is to disable the painting of the rectangle by calling <kbd>rectItem-&gt;setPen(Qt::NoPen)</kbd>.</div>
<p>An alternative solution to this problem is to translate the text item's coordinate system instead of using <kbd>setPos()</kbd>. <kbd>QGraphicsItem</kbd> doesn't have a dedicated function for translation, so we will need to use <kbd>setTransform</kbd>:</p>
<pre>QTransform transform;
transform.translate(-text-&gt;boundingRect().width() / 2,
                    -text-&gt;boundingRect().height() / 2);
text-&gt;setTransform(transform);</pre>
<p>Contrary to what you would expect, <kbd>ItemIgnoresTransformations</kbd> doesn't cause the item to ignore its own transformations, and this code will position the text correctly without needing an additional rectangle item.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding items by position</h1>
                </header>
            
            <article>
                
<p>If you want to know which item is shown at a certain position, you can use the <kbd>QGraphicsScene::itemAt()</kbd> fu<span>nction</span> <span>that takes the position in the scene's coordinate system (either a <kbd>QPointF</kbd> or two <kbd>qreal</kbd> numbers) and the device transformation object (<kbd>QTransform</kbd>) that can be obtained using the </span><kbd>QGraphicsView::transform()</kbd> <span>function</span><span>. The function returns the topmost item at the specified position or a null pointer if no item was found. The device transformation only matters if your scene contains items that ignore transformations. If you have no such items, you can use the default-constructed <kbd>QTransform</kbd> value:</span></p>
<pre>QGraphicsItem *foundItem = scene.itemAt(scenePos, QTransform());</pre>
<p>If your scene contains items that ignore transformations, it may be more convenient to use the <kbd>QGraphicsView::itemAt()</kbd> function that automatically takes the device transform into account. Note that this function expects the position to be in the viewport's coordinate system.</p>
<p>If you want all items that are located at some position, say in cases where multiple items are on top of each other, or if you need to search for items in some area, use the  <kbd>QGraphicsScene::items()</kbd> function. It will return a list of items defined by the specified arguments. This function has a number of overloads that allow you to specify a single point, a rectangle, a polygon, or a painter path. The <kbd>deviceTransform</kbd> argument works in the same way as for the <kbd>QGraphicsScene::itemAt()</kbd> function discussed earlier. The <kbd>mode</kbd> argument allows you to alter how the items in the area will be determined. The following table shows the different modes:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Mode</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>
<p><kbd>Qt::ContainsItemBoundingRect</kbd></p>
</td>
<td>
<p>The item's bounding rectangle must be completely inside the selection area.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Qt::IntersectsItemBoundingRect</kbd></p>
</td>
<td>
<p>Similar to <kbd>Qt::ContainsItemBoundingRect</kbd> but also returns items whose bounding rectangles intersect with the selection area.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Qt::ContainsItemShape</kbd></p>
</td>
<td>
<p>The item's shape must be completely inside the selection area. The shape may describe the item's boundaries more precisely than the bounding rectangle, but this operation is more computationally intensive.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Qt::IntersectsItemShape</kbd></p>
</td>
<td>
<p>Similar to <kbd>Qt::ContainsItemShape</kbd> but also returns items whose shapes intersect with the selection area.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>items()</kbd> function sorts items according to their stacking order. The <kbd>order</kbd> argument allows you to choose the order in which the results will be returned.  <kbd>Qt::DescendingOrder</kbd> (default) will place the topmost item at the beginning, and  <kbd>Qt::AscendingOrder</kbd> will result in a reversed order.</p>
<p>The view also provides a similar <kbd>QGraphicsView::items()</kbd> function that operates in viewport coordinates.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Showing specific areas of the scene</h1>
                </header>
            
            <article>
                
<p>As soon as the scene's bounding rectangle exceeds the viewport's size, the view will show scroll bars. Besides using them with the mouse to navigate to a specific item or point on the scene, you can also access them by code. Since the view inherits <kbd>QAbstractScrollArea</kbd>, you can use all its functions for accessing the scroll bars; <kbd>horizontalScrollBar()</kbd> and <kbd>verticalScrollBar()</kbd> return a pointer to <kbd>QScrollBar</kbd>, and thus you can query their range with <kbd>minimum()</kbd> and <kbd>maximum()</kbd>. By invoking <kbd>value()</kbd> and <kbd>setValue()</kbd>, you get and can set the current value, which results in scrolling the scene.</p>
<p>However, normally, you do not need to control free scrolling inside the view from your source code. The normal task would be to scroll to a specific item. In order to do that, you do not need to do any calculations yourself; the view offers a pretty simple way to do that for you—<kbd>centerOn()</kbd>. With <kbd>centerOn()</kbd>, the view ensures that the item, which you have passed as an argument, is centered on the view unless it is too close to the scene's border or even outside. Then, the view tries to move it as far as possible on the center. The <kbd>centerOn()</kbd> function does not only take a <kbd>QGraphicsItem</kbd> item as argument; you can also center on a <kbd>QPointF</kbd> pointer or as a convenience on an <em>x</em> and <em>y</em> coordinate.</p>
<p>If you do not care where an item is shown, you can simply call <kbd>ensureVisible()</kbd> with the item as an argument. Then, the view scrolls the scene as little as possible so that the item's center remains or becomes visible. As a second and third argument, you can define a horizontal and vertical margin, which are both the minimum space between the item's bounding rectangle and the view's border. Both values have 50 pixels as their default value. Besides a <kbd>QGraphicsItem</kbd> item, you can also ensure the visibility of a <kbd>QRectF</kbd> element (of course, there is also the convenience function taking four <kbd>qreal</kbd> elements).</p>
<div class="packt_tip">If you need to ensure the entire visibility of an item, use <kbd>ensureVisible(item-&gt;boundingRect())</kbd> (since <kbd>ensureVisible(item)</kbd> only takes the item's center into account).</div>
<p><kbd>centerOn()</kbd> and <kbd>ensureVisible()</kbd> only scroll the scene but do not change its transformation state. If you absolutely want to ensure the visibility of an item or a rectangle that exceeds the size of the view, you have to transform the scene as well. With this task, again the view will help you. By calling <kbd>fitInView()</kbd> with <kbd>QGraphicsItem</kbd> or a <kbd>QRectF</kbd> element as an argument, the view will scroll and scale the scene so that it fits in the viewport size.</p>
<p>As a second argument, you can control how the scaling is done. You have the following options:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Value</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>
<p><kbd>Qt::IgnoreAspectRatio</kbd></p>
</td>
<td>
<p>The scaling is done absolutely freely regardless of the item's or rectangle's aspect ratio.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Qt::KeepAspectRatio</kbd></p>
</td>
<td>
<p>The item's or rectangle's aspect ratio is taken into account while trying to expand as far as possible while respecting the viewport's size.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Qt::KeepAspectRatioByExpanding</kbd></p>
</td>
<td>
<p>The item's or rectangle's aspect ratio is taken into account, but the view tries to fill the whole viewport's size with the smallest overlap.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>fitInView()</kbd> function does not only scale larger items down to fit the viewport, it also enlarges items to fill the whole viewport. The following diagram illustrates the different scaling options for an item that is enlarged (the circle on the left is the original item, and the black rectangle is the viewport):</p>
<div class="figure CDPAlignLeft CDPAlign">                   <img src="Images/a698c68a-d4b2-49a1-acaa-0a27d1936f2c.png" style="width:37.25em;height:11.00em;" width="1500" height="443"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Saving a scene to an image file</h1>
                </header>
            
            <article>
                
<p>We've only displayed our scene in the view so far, but it is also possible to render it to an image, a printer, or any other object Qt can use for painting. Let's save our scene to a PNG file:</p>
<pre>QRect rect = scene.sceneRect().toAlignedRect();
QImage image(rect.size(), QImage::Format_ARGB32);
image.fill(Qt::transparent);
QPainter painter(&amp;image);
scene.render(&amp;painter);
image.save("scene.png");</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What just happened?</h1>
                </header>
            
            <article>
                
<p>First, you determined the rectangle of the scene with <kbd>sceneRect()</kbd>. Since this returns a <kbd>QRectF</kbd> parameter and <kbd>QImage</kbd> can only handle <kbd>QRect</kbd>, you transformed it on the fly by calling <kbd>toAlignedRect()</kbd>. The difference between the <kbd>toRect()</kbd> function and <kbd>toAlignedRect()</kbd> is that the former rounds to the nearest integer, which may result in a smaller rectangle, whereas the latter expands to the smallest possible rectangle containing the original <kbd>QRectF</kbd> parameter.</p>
<p>Then, you created a <kbd>QImage</kbd> file with the size of the aligned scene's rectangle. As the image is created with uninitialized data, you need to call <kbd>fill()</kbd> with <kbd>Qt::transparent</kbd> to receive a transparent background. You can assign any color you like as an argument both as a value of <kbd>Qt::GlobalColor</kbd> enumeration and an ordinary <kbd>QColor</kbd> object; <kbd>QColor(0, 0, 255)</kbd> will result in a blue background. Next, you create a <kbd>QPainter</kbd> object that points to the image. This painter object is then used in the scene's <kbd>render()</kbd> function to draw the scene. After that, all you have to do is use the <kbd>save()</kbd> function to save the image to a place of your choice. <span>The format of the output file is determined by its extension. Qt supports a variety of formats, and Qt plugins can add support for new formats. </span>Since we haven't specified a path, the image will be saved in the application's working directory (which is usually the build directory, unless you changed it using the <span class="packt_screen">Projects</span> pane of Qt Creator). You can also specify an absolute path, such as <kbd>/path/to/image.png</kbd>.</p>
<div class="packt_tip">Of course, you'll need to construct a path that's valid on the current system instead of hard-coding it in the sources. For example, you can use the <kbd>QFileDialog::getSaveFileName()</kbd> function to ask the user for a path.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Have a go hero – Rendering only specific parts of a scene</h1>
                </header>
            
            <article>
                
<p>This example draws the whole scene. Of course, you can also render only specific parts of the scene using the other arguments of <kbd>render()</kbd>. We will not go into this here, but you may want to try it as an exercise.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom items</h1>
                </header>
            
            <article>
                
<p>As we already saw, Graphics View provides a lot of useful functionality that covers most typical use cases. However, the real power of Qt is its extensibility, and Graphics View allows us to create custom subclasses of <kbd>QGraphicsItem</kbd> to implement items that are tailored for your application. You may want to implement a custom item class when you need to do the following:</p>
<ul>
<li>Paint something that is not possible or difficult to do with standard item classes</li>
<li>Implement some logic related to the item, for example, add your own methods</li>
<li>Handle events in individual items</li>
</ul>
<p>In our next small project, we will create an item that can draw a graph of the sine function <kbd>sin(x)</kbd> and implement some event handling.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Creating a sine graph project</h1>
                </header>
            
            <article>
                
<p>Use Qt Creator to create a new Qt Widgets project and name it <kbd>sine_graph</kbd>. On the <span class="packt_screen">Class Information</span> page of the wizard, select <kbd>QWidget</kbd> as the base class and input <kbd>View</kbd> as the class name. Uncheck the <span class="packt_screen">Generate form</span> checkbox and finish the wizard.</p>
<p>We want the <kbd>View</kbd> class to be the g<span>raphics view</span>, so you need to change the base class to <kbd>QGraphicsView</kbd> (the wizard doesn't suggest such an option). For this, edit the class declaration to look like <kbd>class View : public QGraphicsView ...</kbd> and the constructor implementation to look like <kbd>View::View(QWidget *parent) : QGraphicsView(parent) ...</kbd>.</p>
<p>Next, edit the <kbd>View</kbd> constructor to enable anti-aliasing and set a new graphics scene for our view:</p>
<pre>setRenderHint(QPainter::Antialiasing);
setScene(new QGraphicsScene);</pre>
<p>The view doesn't delete the associated scene on destruction (because you may have multiple views for the same scene), so you should delete the scene manually in the destructor:</p>
<pre>delete scene();</pre>
<p>You can try to run the application and check that it displays an empty view.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Creating a graphics item class</h1>
                </header>
            
            <article>
                
<p>Ask Qt Creator to add a new <span class="packt_screen">C++ class</span> to the project. Input <kbd>SineItem</kbd> as the class name, leave <span class="packt_screen">&lt;Custom&gt;</span> in the <span class="packt_screen">Base class</span> drop-down list, and input <kbd>QGraphicsItem</kbd> in the field below it. Finish the wizard and open the created <kbd>sineitem.h</kbd> file.</p>
<p>Set the text cursor inside <kbd>QGraphicsItem</kbd> in the class declaration and press <em><span class="KeyPACKT">Alt</span></em> + <em><span class="KeyPACKT">Enter</span></em>. At first; Qt Creator will suggest that you <span class="packt_screen">Add</span> <kbd>#include &lt;QGraphicsItem&gt;</kbd>. Confirm that and press <em><span class="KeyPACKT">Alt</span></em> + <em><span class="KeyPACKT">Enter</span></em> on <kbd>QGraphicsItem</kbd> again. Now, Qt Creator should suggest that you select <span class="packt_screen">Insert Virtual Functions of Base Classes</span>. When you select this option, a special dialog will appear:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/22622853-aad8-4b25-99fe-2631b66ffda4.png" style="width:42.50em;height:36.75em;" width="844" height="728"/></div>
<p>The function list contains all virtual functions of the base class. The pure virtual functions (which must be implemented if you want to create objects of the class) are enabled by default. Check that everything is set as in the preceding screenshot, and then click on <span class="packt_screen">OK</span>. This convenient operation adds declaration and implementation of the selected virtual functions to the source files of our class. You can write them manually instead, if you want.</p>
<p>Let's edit <kbd>sineitem.cpp</kbd> to implement the two pure virtual functions. First of all, a couple of constants at the top of the file:</p>
<pre>static const float DX = 1;
static const float MAX_X = 50;</pre>
<p>In our graph, <em>x</em> will vary from 0 to <kbd>MAX_X</kbd>, and <kbd>DX</kbd> will be the difference between the two consequent points of the graph. As you may know, <kbd>sin(x)</kbd> can have values from -1 to 1. This information is enough to implement the <kbd>boundingRect()</kbd> function:</p>
<pre>QRectF SineItem::boundingRect() const
{
    return QRectF(0, -1, MAX_X, 2);
}</pre>
<p>This function simply returns the same rectangle every time. In this rectangle, <em>x</em> changes from 0 to <kbd>MAX_X</kbd>, and <em>y</em> changes from -1 to 1. This returned rectangle is a promise to the scene that the item will only paint in this area. The scene relies on the correctness of that information, so you should strictly obey that promise. Otherwise, the scene will become cluttered up with relics of your drawing!</p>
<p>Now, implement the <kbd>paint()</kbd> function, as follows:</p>
<pre>void SineItem::paint(QPainter *painter, <br/>    const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    QPen pen;
    pen.setCosmetic(true);
    <strong>painter-&gt;setPen(pen);</strong>
    const int steps = qRound(MAX_X / DX);
    QPointF previousPoint(0, sin(0));
    for(int i = 1; i &lt; steps; ++i) {
        const float x = DX * i;
        QPointF point(x, sin(x));
        <strong>painter-&gt;drawLine(previousPoint, point);</strong>
        previousPoint = point;
    }
    Q_UNUSED(option)
    Q_UNUSED(widget)
}</pre>
<p>Add <kbd>#include &lt;QtMath&gt;</kbd> to the top section of the file to make math functions available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What just happened?</h1>
                </header>
            
            <article>
                
<p>When the view needs to display the scene, it calls the <kbd>paint()</kbd> function of each visible item and provides three arguments: a <kbd>QPainter</kbd> pointer that should be used for painting, a <kbd>QStyleOptionGraphicsItem</kbd> pointer that contains painting-related parameters for this item, and an optional <kbd>QWidget</kbd> pointer that may point to the currently painted widget. In the implementation of the function, we start with setting a cosmetic pen in the <kbd>painter</kbd> so that the line width of our graph is always 1. Next, we calculate the number of points in the graph and save it to the <kbd>steps</kbd> variable. Then, we create a variable to store the previous point of the graph and initialize it with the position of the first point of the graph (corresponding to <kbd>x = 0</kbd>). Next, we iterate through points, calculate <em>x</em> and <em>y</em> for each point, and then use the <kbd>painter</kbd> object to draw a line from the previous point to the current point. After this, we update the value of the <kbd>previousPoint</kbd> variable. We use the <kbd>Q_UNUSED()</kbd> macro to suppress compiler warnings about unused arguments and to indicate that we, intentionally, didn't use them.</p>
<p>Edit the constructor of our <kbd>View</kbd> class to create an instance of our new item:</p>
<pre>SineItem *item = new SineItem();
scene()-&gt;addItem(item);</pre>
<p>The application should display the sine graph now, but it is very small:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/23ef1e22-8726-480b-baaa-2cb0b21a05f3.png" style="width:11.75em;height:5.08em;" width="159" height="69"/></div>
<p>We should add a way for users to scale our view using the mouse wheel. However, before we get to this, you need to learn a little more about event handling.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Events</h1>
                </header>
            
            <article>
                
<p>Any GUI application needs to react to the input events. We are already familiar with the signals and slots mechanism in <kbd>QObject</kbd>-based classes. However, <kbd>QObject</kbd> is not exactly a lightweight class. Signals and slots are powerful and convenient for connecting parts of the application, but invoking a signal for processing each keyboard press or mouse move will be too inefficient. To process such events, Qt has a special system that uses the <kbd>QEvent</kbd> class.</p>
<p>The dispatcher of the events is the <strong>event loop</strong>. Almost any Qt application uses the main event loop that is started by calling <kbd>QCoreApplication::exec</kbd> at the end of the <kbd>main()</kbd> function. While the application is running, the control flow is either in your code (that is, in the implementation of any function in the project) or in the event loop. When the operating system or a component of the application asks the event loop to process an event, it determines the receiver and calls a virtual function that corresponds to the event type. A <kbd>QEvent</kbd> object containing information about the event is passed to that function. The virtual function has a choice to <strong>accept</strong> or <strong>ignore</strong> the event. If the event was not accepted, the event is <strong>propagated</strong> to the parent object in the hierarchy (for example, from a widget to its parent widget, and from a graphics item to the parent item). You can subclass a Qt class and reimplement a virtual function to add custom events processing.</p>
<p>The following table shows the most useful events:</p>
<table>
<tbody>
<tr>
<td><strong>Event types</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>QEvent::KeyPress</kbd>, <kbd>QEvent::KeyRelease</kbd></td>
<td>A keyboard button was pressed or released.</td>
</tr>
<tr>
<td><kbd>QEvent::MouseButtonPress</kbd>, <kbd>QEvent::MouseButtonRelease</kbd>, <kbd>QEvent::MouseButtonDblClick</kbd></td>
<td>The mouse buttons were pressed or released.</td>
</tr>
<tr>
<td><kbd>QEvent::Wheel</kbd></td>
<td>The mouse wheel was rolled.</td>
</tr>
<tr>
<td><kbd>QEvent::Enter</kbd></td>
<td>The mouse cursor entered the object's boundaries.</td>
</tr>
<tr>
<td><kbd>QEvent::MouseMove</kbd></td>
<td>The mouse cursor was moved.</td>
</tr>
<tr>
<td><kbd>QEvent::Leave</kbd></td>
<td>The mouse cursor left the object's boundaries.</td>
</tr>
<tr>
<td><kbd>QEvent::Resize</kbd></td>
<td>The widget was resized (for example, because the user resized the window or the layout changed).</td>
</tr>
<tr>
<td><kbd>QEvent::Close</kbd></td>
<td>The user attempted to close the widget's window.</td>
</tr>
<tr>
<td><kbd>QEvent::ContextMenu</kbd></td>
<td>The user requested a context menu (the exact action depends on the operating system's way to open the context menu).</td>
</tr>
<tr>
<td><kbd>QEvent::Paint</kbd></td>
<td>The widget needs to be repainted.</td>
</tr>
<tr>
<td><kbd>QEvent::DragEnter</kbd>, <kbd>QEvent::DragLeave</kbd>, <kbd>QEvent::DragMove</kbd>, <kbd>QEvent::Drop</kbd></td>
<td>The user performs a drag and drop action.</td>
</tr>
<tr>
<td><kbd>QEvent::TouchBegin</kbd>, <kbd>QEvent::TouchUpdate</kbd>, <kbd>QEvent::TouchEnd</kbd>, <kbd>QEvent::TouchCancel</kbd></td>
<td>A touchscreen or a trackpad reported an event.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Each event type has a corresponding class that inherits <kbd>QEvent</kbd> (for example, <kbd>QMouseEvent</kbd>). Many event types have the dedicated virtual function, for example, <kbd>QWidget::mousePressEvent</kbd> and <kbd>QGraphicsItem::mousePressEvent</kbd>. More exotic events must be processed by re-implementing the <kbd>QWidget::event</kbd> (or <kbd>QGraphicsItem::sceneEvent</kbd>) function that receives all events, and using <kbd>event-&gt;type()</kbd> to check the event type.</p>
<p>Events dispatched in the graphics scene have special types (for example, <kbd>QEvent::GraphicsSceneMousePress</kbd>) and special classes (<span>for example,</span> <kbd>QGraphicsSceneMouseEvent</kbd>) because they have an extended set of information about the event. In particular, mouse events contain information about the coordinates in the item's and the scene's coordinate systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Implementing the ability to scale the scene</h1>
                </header>
            
            <article>
                
<p>Let's allow the user to scale the scene using the mouse wheel on the view. Switch to the <kbd>view.h</kbd> file and add a declaration and an implementation of the <kbd>wheelEvent()</kbd> virtual function using the same method we just used in the <kbd>SineItem</kbd> class. Write the following code in the <kbd>view.cpp</kbd> file:</p>
<pre>void View::wheelEvent(QWheelEvent *event)
{
    QGraphicsView::wheelEvent(event);
    if (event-&gt;isAccepted()) {
        return;
    }
    const qreal factor = 1.1;
    if (event-&gt;angleDelta().y() &gt; 0) {
        scale(factor, factor);
    } else {
        scale(1 / factor, 1 / factor);
    }
    event-&gt;accept();
}</pre>
<p>If you run the application now, you can scale the sine graph using the mouse wheel.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What just happened?</h1>
                </header>
            
            <article>
                
<p>When an event occurs, Qt calls the corresponding virtual function in the widget in which the event occurred. In our case, whenever the user uses the mouse wheel on our view, the <kbd>wheelEvent()</kbd> virtual function will be called, and the <kbd>event</kbd> argument will hold information about the event.</p>
<p>In our implementation, we start with calling the base class's implementation. It is very important to do this whenever you reimplement a virtual function, unless you want the default behavior to be completely disabled. In our case, <kbd>QGraphicsView::wheelEvent()</kbd> will pass the event to the scene, and if we forget to call this function, neither the scene nor any of its items will receive any wheel events, which can be very much unwanted in some cases.</p>
<p>After the default implementation is complete, we use the <kbd>isAccepted()</kbd> function to check whether an event was accepted by the scene or any items. The event will be rejected by default, but if we later add some item that can process wheel events (for example, a text document with its own scrollbar), it will receive and accept the event. In that case, we don't want to perform any other action based on this event, as it's usually desirable that any event is only processed (and accepted) in one location.</p>
<div class="packt_infobox">In some cases, you may want your custom implementation to take priority over the default one. In that case, move the call to the default implementation to the end of the function body. When you want to prevent a particular event from being dispatched to the scene, use an early <kbd>return</kbd> to prevent the default implementation from executing.</div>
<p>The <kbd>factor</kbd> parameter for the zooming can be freely defined. You can also create a getter and setter method for it. For us, 1.1 will do the work. With <kbd>event-&gt;angleDelta()</kbd>, you get the distance of the mouse's wheel rotation as a <kbd>QPoint</kbd> pointer. Since we only care about vertical scrolling, just the <em>y</em> axis is relevant for us. In our example, we also do not care about how far the wheel was turned because, normally, every step is delivered separately to <kbd>wheelEvent()</kbd>. However, if you should need it, it's in eighths of a degree, and since most mouses work in general steps of 15 degrees, the value should be 120 or -120, depending on whether you move the wheel forward or backward. On a forward wheel move, if <kbd>y()</kbd> is greater than zero, we zoom in using the already familiar <kbd>scale()</kbd> function. Otherwise, if the wheel was moved backward, we zoom out. Finally, we accept the event, indicating that the user's input was understood, and there is no need to propagate the event to parent widgets (although the view currently doesn't have a parent). That's all there is to it.</p>
<p>When you try this example, you will note that, while zooming, the view zooms in and out on the center of the view, which is the default behavior for the view. You can change this behavior with <kbd>setTransformationAnchor()</kbd>. <kbd>QGraphicsView::AnchorViewCenter</kbd> is, as described, the default behavior. With <kbd>QGraphicsView::NoAnchor</kbd>, the zoom center is in the top-left corner of the view, and the value you probably want to use is <kbd>QGraphicsView::AnchorUnderMouse</kbd>. With that option, the point under the mouse builds the center of the zooming and thus stays at the same position inside the view.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Taking the zoom level into account</h1>
                </header>
            
            <article>
                
<p>Our graph currently contains points with integer <em>x</em> values because we set <kbd>DX = 1</kbd>. This is exactly what we want for the default level of zoom, but once the view is zoomed in, it becomes apparent that the graph's line is not smooth. We need to change <kbd>DX</kbd> based on the current zoom level. We can do this by adding the following code to the beginning of the <kbd>paint()</kbd> function():</p>
<pre>const qreal detail = QStyleOptionGraphicsItem::levelOfDetailFromTransform(
    painter-&gt;worldTransform());
const qreal dx = 1 / detail;</pre>
<p>Delete the <kbd>DX</kbd> constant and replace <kbd>DX</kbd> with <kbd>dx</kbd> in the rest of the code. Now, when you scale the view, the graph's line keeps being smooth because the number of points increases dynamically. The <kbd>levelOfDetailFromTransform</kbd> helper function examines the value of the painter's transformation (which is a combination of all transformations applied to the item) and returns the <strong>level of detail</strong>. If the item is zoomed in 2:1, the level of detail is 2, and if the item is zoomed out 1:2, the level of detail is 0.5.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Reacting to an item's selection state</h1>
                </header>
            
            <article>
                
<p>Standard items, when selected, change appearance (for example, the outline usually becomes dashed). When we're creating a custom item, we need to implement this feature manually. Let's make our item selectable in the <kbd>View</kbd> constructor:</p>
<pre>SineItem *item = new SineItem();
item-&gt;setFlag(QGraphicsItem::ItemIsSelectable);</pre>
<p>Now, let's make the graph line green when the item is selected:</p>
<pre>if (option-&gt;state &amp; QStyle::State_Selected) {
    pen.setColor(Qt::green);
}
painter-&gt;setPen(pen);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What just happened?</h1>
                </header>
            
            <article>
                
<p>The <kbd>state</kbd> variable is a bitmask holding the possible states of the item. You can check its value against the values of the <kbd>QStyle::StateFlag</kbd> parameter using bitwise operators. In the preceding case, the <kbd>state</kbd> variable is checked against the <kbd>State_Selected</kbd> parameter. If this flag is set, we use green color for the pen.</p>
<div class="packt_tip">The type of state is <kbd>QFlags&lt;StateFlag&gt;</kbd>. So, instead of using the bitwise operator to test whether a flag is set, you can use the convenient function <kbd>testFlag()</kbd>.</div>
<p class="">Used with the preceding example, it would be as follows:</p>
<pre>if (option-&gt;state.testFlag(QStyle::State_Selected)) {  </pre>
<p>The most important states you can use with items are described in the following table:</p>
<table class="table">
<tbody>
<tr>
<td><strong>State</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>
<p><kbd>State_Enabled</kbd></p>
</td>
<td>
<p>Indicates that the item is enabled. If the item is disabled, you may want to draw it as grayed out.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>State_HasFocus</kbd></p>
</td>
<td>
<p>Indicates that the item has the input focus. To receive this state, the item needs to have the <kbd>ItemIsFocusable</kbd> flag set.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>State_MouseOver</kbd></p>
</td>
<td>
<p>Indicates that the cursor is currently hovering over the item. To receive this state, the item needs to have the <kbd>acceptHoverEvents</kbd> variable set to <kbd>true</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>State_Selected</kbd></p>
</td>
<td>
<p>Indicates that the item is selected. To receive this state, the item needs to have the <kbd>ItemIsSelectable</kbd> flag set. The normal behavior would be to draw a dashed line around the item as a selection marker.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Besides the state, <kbd>QStyleOptionGraphicsItem</kbd> offers much more information about the currently used style, such as the palette and the font used, accessible through the <kbd>QStyleOptionGraphicsItem::palette</kbd> and <kbd>QStyleOptionGraphicsItem::fontMetrics</kbd> parameters, respectively. If you aim for style-aware items, take a deeper look at this class in the documentation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Event handling in a custom item</h1>
                </header>
            
            <article>
                
<p>Items, like widgets, can receive events in virtual functions. If you click on a scene (to be precise, you click on a view that propagates the event to the scene), the scene receives the mouse press event, and it then becomes the scene's responsibility to determine which item was meant by the click.</p>
<p>Let's override the <kbd>SineItem::mousePressEvent</kbd> function that is called when the user presses a mouse button inside the item:</p>
<pre>void SineItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    if (event-&gt;button() &amp; Qt::LeftButton) {
        float x = event-&gt;pos().x();
        QPointF point(x, sin(x));
        static const float r = 0.3;
        QGraphicsEllipseItem *ellipse =
                new QGraphicsEllipseItem(-r, -r, 2 * r, 2 * r, this);
        ellipse-&gt;setPen(Qt::NoPen);
        ellipse-&gt;setBrush(QBrush(Qt::red));
        ellipse-&gt;setPos(point);
        event-&gt;accept();
    } else {
        event-&gt;ignore();
    }
}</pre>
<p>When a mouse press event occurs, this function is called and the passed <kbd>event</kbd> object contains information about the event. In our case, we check whether the left mouse button was pressed and use the <kbd>event-&gt;pos()</kbd> function that returns coordinates of the clicked point <em>in the item's coordinate system</em>. In this example, we ignored the <em>y</em> coordinate and used the <em>x</em> coordinate to find the corresponding point on our graph. Then, we simply created a child circle item that shows that point. We <kbd>accept</kbd> the event if we did understand the action performed and <kbd>ignore</kbd> it if we don't know what it means so that it can be passed to another item. You can run the application and click on the graph to see these circles. Note that when you click outside of the graph's bounding rect, the scene doesn't dispatch the event to our item, and its <kbd>mousePressEvent()</kbd> function is not called.</p>
<p>The <kbd>event</kbd> object also contains the <kbd>button()</kbd> function that returns the button that was pressed, and the <kbd>scenePos()</kbd> function that returns the clicked point in the scene's coordinate system. The scene's responsibility for delivering events does not only apply to mouse events, but also to key events and all other sorts of events.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Implementing the ability to create and delete elements with mouse</h1>
                </header>
            
            <article>
                
<p>Let's allow the users to create new instances of our sine item when they click on the view with the left mouse button and delete the items if they use the right mouse button. Reimplement the <kbd>View::mousePressEvent</kbd> virtual function, as follows:</p>
<pre>void View::mousePressEvent(QMouseEvent *event)
{
    QGraphicsView::mousePressEvent(event);
    if (event-&gt;isAccepted()) {
        return;
    }
    <strong>switch (event-&gt;button()) {
        case Qt::LeftButton: {
            SineItem *item = new SineItem();
            item-&gt;setPos(mapToScene(event-&gt;pos()));
            scene()-&gt;addItem(item);
            event-&gt;accept();
            break;
        }
        case Qt::RightButton: {
            QGraphicsItem *item = itemAt(event-&gt;pos());
            if (item) {
                delete item;
            }
            event-&gt;accept();
            break;
        }
        default:
            break;
    }</strong>
}</pre>
<p>Here, we first check whether the event was accepted by the scene or any of its items. If not, we determine which button was pressed. For the left button, we create a new item and place it in the corresponding point of the scene. For the right button, we search for an item at that position and delete it. In both cases, we accept the event. When you run the application, you will note that if the user clicks on an existing item, a new circle will be added, and if the user clicks outside of any items, a new sine item will be added. That's because we properly set and read the <kbd>accepted</kbd> property of the event.</p>
<div class="packt_tip">You may note that the scene jumps within the view when we add a new item. This is caused by changes of the scene rect. To prevent this, you can set a constant rect using <kbd>setSceneRect()</kbd> or change the alignment using <kbd>setAlignment(Qt::AlignTop | Qt::AlignLeft)</kbd> in the view's constructor.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time for action – Changing the item's size</h1>
                </header>
            
            <article>
                
<p>Our custom graphics item always displays the graph for <em>x</em> values between 0 and 50. It would be neat to make this a configurable setting. Declare a private <kbd>float m_maxX</kbd> field in the <kbd>SineItem</kbd> class, remove the <kbd>MAX_X</kbd> constant, and replace its uses with <kbd>m_maxX</kbd> in the rest of the code. As always, you must set the initial value of the field in the constructor, or bad things can happen. Finally, implement a getter and a setter for it, as shown:</p>
<pre>float SineItem::maxX()
{
    return m_maxX;
}

void SineItem::setMaxX(float value)
{
    if (m_maxX == value) {
        return;
    }
    <strong>prepareGeometryChange();</strong>
    m_maxX = value;
}</pre>
<p>The only non-trivial part here is the <kbd>prepareGeometryChange()</kbd> call. This method is inherited from <kbd>QGraphicsItem</kbd> and notifies the scene that our <kbd>boundingRect()</kbd> function will return a different value on the next update. The scene caches bounding rectangles of the items, so if you don't call <kbd>prepareGeometryChange()</kbd>, the change of the bounding rectangle may not take effect. This action also schedules an update for our item.</p>
<div class="packt_tip">When the bounding rect does not change but the actual content of the item changes, you need to call <kbd>update()</kbd> on the item to notify the scene that it should repaint the item.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Have a go hero – Extending the item's functionality</h1>
                </header>
            
            <article>
                
<p>The abilities of <kbd>SineItem</kbd> are still pretty limited. As an exercise, you can try to add an option to change the minimum <em>x</em> value of the graph or set a different pen. You can even allow the user to specify an arbitrary function pointer to replace the <kbd>sin()</kbd> function. However, keep in mind that the bounding rect of the item depends on the value range of the function, so you need to update the item's geometry accurately.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets inside Graphics View</h1>
                </header>
            
            <article>
                
<p>In order to show a neat feature of Graphics View, take a look at the following code snippet, which adds a widget to the scene:</p>
<pre>QSpinBox *box = new QSpinBox;
QGraphicsProxyWidget *proxyItem = new QGraphicsProxyWidget;
proxyItem-&gt;setWidget(box);
scene()-&gt;addItem(proxyItem);
proxyItem-&gt;setScale(2);
proxyItem-&gt;setRotation(45); </pre>
<p>First, we create a <kbd>QSpinBox</kbd> and a <kbd>QGraphicsProxyWidget</kbd> element, which act as containers for widgets and indirectly inherit <kbd>QGraphicsItem.</kbd> Then, we add the spin box to the proxy widget by calling <kbd>addWidget()</kbd>. When <kbd>QGraphicsProxyWidget</kbd> gets deleted, it calls <kbd>delete</kbd> on all assigned widgets, so we do not have to worry about that ourselves. The widget you add should be parentless and must not be shown elsewhere. After setting the widget to the proxy, you can treat the proxy widget like any other item. Next, we add it to the scene and apply a transformation for demonstration. As a result, we get this:</p>
<div class="figure CDPAlignCenter CDPAlign"><img src="Images/2f93b81a-9072-445b-af32-a9ee80065407.png" style="width:14.33em;height:7.17em;" width="200" height="100"/></div>
<p>Be aware that, originally, Graphics View wasn't designed for holding widgets. So when you add a lot of widgets to the scene, you will quickly notice performance issues, but in most situations, it should be fast enough.</p>
<p>If you want to arrange some widgets in a layout, you can use <kbd>QGraphicsAnchorLayout</kbd>, <kbd>QGraphicsGridLayout</kbd>, or <kbd>QGraphicsLinearLayout</kbd>. Create all widgets, create a layout of your choice, add the widgets to that layout, and set the layout to a <kbd>QGraphicsWidget</kbd> element, which is the base class for all widgets and is, easily spoken, the <kbd>QWidget</kbd> equivalent for Graphics View by calling <kbd>setLayout()</kbd>:</p>
<pre>QGraphicsProxyWidget *edit = scene()-&gt;addWidget(
  new QLineEdit(tr("Some Text")));
QGraphicsProxyWidget *button = scene()-&gt;addWidget(
  new QPushButton(tr("Click me!")));
QGraphicsLinearLayout *layout = new QGraphicsLinearLayout;
layout-&gt;addItem(edit);
layout-&gt;addItem(button);
QGraphicsWidget *graphicsWidget = new QGraphicsWidget;
graphicsWidget-&gt;setLayout(layout);
scene()-&gt;addItem(graphicsWidget); </pre>
<p>The scene's <kbd>addWidget()</kbd> function is a convenience function and behaves similar to <kbd>addRect</kbd>, as shown in the following code snippet:</p>
<pre>QGraphicsProxyWidget *proxy = new QGraphicsProxyWidget(0);
proxy-&gt;setWidget(new QLineEdit(QObject::tr("Some Text")));
scene()-&gt;addItem(proxy); </pre>
<p>The item with the layout will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f01f4b1c-7c36-4056-82c4-79869bbcb137.png" style="width:17.17em;height:6.75em;" width="254" height="100"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Optimization</h1>
                </header>
            
            <article>
                
<p>When adding many items to a scene or using items with complex<span> </span><kbd>paint()</kbd><span> functions, the performance of your application may decrease</span>. While default optimizations of Graphics View are suitable for most cases, you may need to tweak them to achieve better performance. Let's now take a look at some of the optimizations we can perform to speed up the scene.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A binary space partition tree</h1>
                </header>
            
            <article>
                
<p>The scene constantly keeps a record of the position of the item in its internal binary space partition tree. Thus, on every move of an item, the scene has to update the tree, an operation that can become quite time-consuming, and also memory consuming. This is especially true of scenes with a large number of animated items. On the other hand, the tree enables you to find an item (for example, with <kbd>items()</kbd> or <kbd>itemAt()</kbd>) incredibly quickly, even if you have thousands of items.</p>
<p>So when you do not need any positional information about the items—this also includes collision detection—you can disable the index function by calling <kbd>setItemIndexMethod(QGraphicsScene::NoIndex)</kbd>. Be aware, however, that a call to <kbd>items()</kbd> or <kbd>itemAt()</kbd> results in a loop through all items in order to do the collision detection, which can cause performance problems for scenes with many items. If you cannot relinquish the tree in total, you can <span>still </span>adjust the depth of the tree with <kbd>setBspTreeDepth()</kbd>, taking the depth as an argument. By default, the scene will guess a reasonable value after it takes several parameters, such as the size and the number of items, into account.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Caching the item's paint function</h1>
                </header>
            
            <article>
                
<p>If you have items with a time-consuming paint function, you can change the item's cache mode. By default, no rendering is cached. With <kbd>setCacheMode()</kbd>, you can set the mode to either <kbd>ItemCoordinateCache</kbd> or <kbd>DeviceCoordinateCache</kbd>. The former renders the item in a cache of a given <kbd>QSize</kbd> element. The size of that cache can be controlled with the second argument of <kbd>setCacheMode()</kbd>, so the quality depends on how much space you assign. The cache is then used for every subsequent paint call. The cache is even used for applying transformations. If the quality deteriorates too much, just adjust the resolution by calling <kbd>setCacheMode()</kbd> again, but with a larger <kbd>QSize</kbd> element. <kbd>DeviceCoordinateCache</kbd>, on the other hand, does not cache the item on an item base but on a device level. This is, therefore, optimal for items that do not get transformed all the time because every new transformation will cause a new caching. Moving the item, however, does not invalidate the cache. If you use this cache mode, you do not have to define a resolution with the second argument. The caching is always performed at maximum quality.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Optimizing the view</h1>
                </header>
            
            <article>
                
<p>Since we are talking about the item's <kbd>paint()</kbd> function, let's touch on something related. By default, the view ensures that the painter state is saved before calling the item's paint function and that the state gets restored afterward. This will end up saving and restoring the painter state, say 50 times, if you have a scene with 50 items. However, you can disable this behavior by calling <kbd>setOptimizationFlag(DontSavePainterState, true)</kbd> on the view. If you do this, it is now your responsibility to ensure that any <kbd>paint()</kbd> function that changes the state of the painter (including pen, brush, transformation, and many other properties) must restore the previous state at the end. If you prevent automatic saving and restoring, keep in mind that now the standard items will alter the painter state. So if you use both standard and custom items, either stay with the default behavior or set <kbd>DontSavePainterState</kbd>, but then set up the pen and brush with a default value in each item's paint function.</p>
<p>Another flag that can be used with <kbd>setOptimizationFlag()</kbd> is <kbd>DontAdjustForAntialiasing</kbd>. By default, the view adjusts the painting area of each item by two pixels in all directions. This is useful because when one paints anti-aliased, one easily draws outside the bounding rectangle. Enable that optimization if you do not paint anti-aliased or if you are sure that your painting will stay inside the bounding rectangle. If you enable this flag and spot painting artifacts on the view, you haven't respected the item's bounding rectangle!</p>
<p>As a further optimization, you can define how the view should update its viewport when the scene changes. You can set the different modes with <kbd>setViewportUpdateMode()</kbd>. By default (<kbd>QGraphicsView::MinimalViewportUpdate</kbd>), the view tries to determine only those areas that need an update and repaints only these. However, sometimes it is more time-consuming to find all the areas that need a redraw than to just paint the entire viewport. This applies if you have many small updates. Then, <kbd>QGraphicsView::FullViewportUpdate</kbd> is the better choice since it simply repaints the whole viewport. A kind of combination of the last two modes is <kbd>QGraphicsView::BoundingRectViewportUpdate</kbd>. In this mode, Qt detects all areas that need a redraw, and then it redraws a rectangle of the viewport that covers all areas affected by the change. If the optimal update mode changes over time, you can tell Qt to determine the best mode using <kbd>QGraphicsView::SmartViewportUpdate</kbd>. The view then tries to find the best update mode.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">OpenGL in the Graphics View</h1>
                </header>
            
            <article>
                
<p>As a last optimization, you can take advantage of OpenGL. Instead of using the default viewport based on <kbd>QWidget</kbd>, advise Graphics View to use an OpenGL widget:</p>
<pre>QGraphicsView view;
view.setViewport(new QOpenGLWidget()); </pre>
<p>This usually improves the rendering performance. However, Graphics View wasn't designed for GPUs and can't use them effectively. There are ways to improve the situation, but that goes beyond the topic and scope of this chapter. You can find more information about OpenGL and Graphics View in the <span class="packt_screen">Boxes</span> Qt example as well as in Rødal's article "Accelerate your Widgets with OpenGL", which can be found online at <a href="https://doc.qt.io/archives/qq/qq26-openglcanvas.html"><span class="URLPACKT">https://doc.qt.io/archives/qq/qq26-openglcanvas.html</span></a>.</p>
<p>If you want to use a framework designed to be GPU accelerated, you should turn your attention to Qt Quick (we will start working with it in <a href="b81d9c47-58fa-49dd-931a-864c7be05840.xhtml">Chapter 11</a>, <em>Introduction to Qt Quick</em>). However, Qt Quick has its own limitations compared to Graphics View. This topic is elaborated in Nichols's article <em>Should you still be using QGraphicsView?</em>, available at <a href="https://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/"><span class="URLPACKT">https://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/</span></a>. Alternatively, you can access the full power of OpenGL directly using its API and helpful Qt utilities. We will describe this approach in <a href="15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a><em>, <span>OpenGL and Vulkan in Qt applications</span></em>.</p>
<div class="packt_infobox">Unfortunately, we can't say that you have to do this or that to optimize Graphics View as it highly depends on your system and view/scene. What we can tell you, however, is how to proceed. Once you have finished your game based on Graphics View, measure the performance of your game using a profiler. Make an optimization you think may pay or simply guess, and then profile your game again. If the results are better, keep the change, otherwise reject it. This sounds simple and is the only way optimization can be done. There are no hidden tricks or deeper knowledge. With time, however, your forecasting will get better.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pop quiz</h1>
                </header>
            
            <article>
                
<p>Q1. Which of the following classes is a widget class?</p>
<ol>
<li><kbd>QGraphicsView</kbd></li>
<li><kbd>QGraphicsScene</kbd></li>
<li><kbd>QGraphicsItem</kbd></li>
</ol>
<p>Q2. Which of the following actions does not change the graphics item's position on the screen?</p>
<ol>
<li>Scaling the view.</li>
<li>Shearing this item's parent item.</li>
<li>Translating this item.</li>
<li>Rotating this item's child item.</li>
</ol>
<p>Q3. Which function is not mandatory to implement in a new class derived from <kbd>QGraphicsItem</kbd>?</p>
<ol>
<li><kbd>boundingRect()</kbd></li>
<li><kbd>shape()</kbd></li>
<li><kbd>paint()</kbd></li>
</ol>
<p>Q4. Which item class should be used to display a raster image in the <span>Graphics View</span>?</p>
<ol>
<li><kbd>QGraphicsRectItem</kbd></li>
<li><kbd>QGraphicsWidget</kbd></li>
<li><kbd>QGraphicsPixmapItem</kbd></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how the Graphics View architecture works. We went through the building blocks of the framework (items, scene, and view). Next, you learned how their coordinate systems are related and how to use them to get the picture you want. Later on, we described the most useful and frequently needed features of Graphics View. Next, we covered creating custom items and handling input events. In order to build a bridge to the world of widgets, you also learned how to incorporate items based on <kbd>QWidget</kbd> into Graphics View. Finally, we discussed ways to optimize the scene.</p>
<p>Now, you really know most of the functions of the Graphics View framework. With this knowledge, you can already do a lot of cool stuff. However, for a game, it is still too static. In the next chapter, we will go through the process of creating a complete game and learn to use the Animation framework.</p>


            </article>

            
        </section>
    </div>



  </body></html>