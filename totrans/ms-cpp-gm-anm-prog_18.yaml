- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Creating Immersive Interactive Worlds
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建沉浸式交互式世界
- en: Welcome to *Chapter 14*! In the previous chapter, we added pathfinding and navigation
    to the instances. We started with a brief overview of navigation methods in computer
    games. Then we explored and implemented the A* algorithm to find a path between
    the instance position and a point in the virtual world. Next, we enhanced the
    models to serve as navigation targets and extended the instances to find a path
    to one of the targets. At the end of the chapter, we added the ability for an
    instance to follow the path and reach the desired target.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第14章**！在前一章中，我们为实例添加了路径寻找和导航。我们从一个关于计算机游戏中导航方法的简要概述开始。然后我们探讨了并实现了A*算法，以在实例位置和虚拟世界中的一个点之间找到路径。接下来，我们增强了模型以作为导航目标，并扩展了实例以找到通往其中一个目标的路。在本章的结尾，我们添加了实例能够跟随路径并达到期望目标的能力。
- en: In this chapter, we will explore different ideas to enhance the example code
    for more immersion and visual quality. We will look at the audible side for tools
    and methods to add sound effects and music to the application. Also, we will implement
    a simple audio manager class to play sounds and background music. To please not
    just the ears but also the eyes, we will collect some ideas about how to enhance
    the visual appearance next and implement two of the graphical enhancements to
    the application. We will end the book with this chapter by looking at the effects
    of daytime and weather changes on the virtual world and add a basic day/night
    cycle to the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的想法来增强示例代码，以实现更多的沉浸感和视觉质量。我们将查看可听部分，寻找添加声音效果和音乐到应用程序的工具和方法。此外，我们将实现一个简单的音频管理类来播放声音和背景音乐。为了取悦耳朵和眼睛，我们还将收集一些关于如何增强视觉外观的想法，并实现应用程序的两个图形增强。我们将通过查看白天和天气变化对虚拟世界的影响，并在应用程序中添加基本的日夜循环来结束本书。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding sound effects and background music
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加声音效果和背景音乐
- en: Enhancing visuals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升视觉效果
- en: Extending immersion with daytime and weather
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过日夜和天气增强沉浸感
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter is available in the `chapter14` folder: the
    `01_opengl_ideas` subfolder for OpenGL and the `02_vulkan_ideas` subfolder for
    Vulkan.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于`chapter14`文件夹中：OpenGL的`01_opengl_ideas`子文件夹和Vulkan的`02_vulkan_ideas`子文件夹。
- en: Adding sound effects and background music
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音效果和背景音乐
- en: Running the example code from [*Chapter 13*](Chapter_13.xhtml) provides a lot
    of features, such as face animations, level loading, collision detection, and
    pathfinding and navigation. But sadly, all the animations on the screen are running
    in dead silence. No bleeping or beeping, no sound, and no music. Just silence.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第13章*](Chapter_13.xhtml)中的示例代码运行提供了许多功能，例如面部动画、关卡加载、碰撞检测以及路径寻找和导航。但遗憾的是，屏幕上的所有动画都在无声中进行。没有哔哔声或嘟嘟声，没有声音，也没有音乐。只有寂静。
- en: But sound and music are an important part of games for very good reasons. Whether
    you are enjoying the calm meadows or deep caves of Minecraft, grooving to the
    happy music of one of the Super Mario titles and hearing the sound effects as
    acoustic feedback of our actions, prefer roaming through the haunting worlds of
    the Dead Space or Silent Hill series while listening carefully to the environment
    sounds to be aware of your surroundings, or driving cars to the pumping music
    and fat sounds of racing games such as the Need for Speed series – without music
    and sound, games wouldn’t deliver the same experience for the player.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但声音和音乐是游戏的重要组成部分，原因非常充分。无论是你在享受Minecraft的宁静草地或深邃洞穴，随着超级马里奥系列中欢快的音乐摇摆，听着我们行动的声学反馈音效，还是偏好漫游在《死亡空间》或《寂静岭》系列中那些令人毛骨悚然的世界上，仔细聆听环境声音以了解你的周围环境，或者在《极品飞车》系列等赛车游戏中驾驶汽车，听着节奏强劲的音乐和低沉的声音——没有音乐和声音，游戏就无法为玩家提供同样的体验。
- en: To add sound output, we can include a freely available sound library, allowing
    us to easily play sound effects or music. Let’s look at some of the libraries
    first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加声音输出，我们可以包含一个免费可用的声音库，使我们能够轻松地播放声音效果或音乐。让我们首先看看一些库。
- en: Using an audio library
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用音频库
- en: Most audio libraries are written in C, but bindings for C++ can be found, encapsulating
    the operating-system-specific low-level function calls in an object-oriented manner.
    Just using the C functions and building a custom abstraction is also possible,
    similar to GLFW, OpenGL, and Vulkan.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数音频库是用 C 编写的，但可以找到 C++ 的绑定，以面向对象的方式封装操作系统特定的低级函数调用。仅使用 C 函数并构建自定义抽象也是可能的，类似于
    GLFW、OpenGL 和 Vulkan。
- en: Simple DirectMedia Layer
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Simple DirectMedia Layer
- en: '**Simple DirectMedia Layer** (**SDL**) is a cross-platform library for multimedia
    hardware components of a computer. SDL manages audio and can serve as a framework
    for window functions, graphics context, and input handling, like GLFW. In addition,
    there are several official libraries that provide support for importing and exporting
    images, custom networking, and font rendering to display text on the screen.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Simple DirectMedia Layer** (**SDL**) 是一个跨平台库，用于计算机的多媒体硬件组件。SDL 管理音频，可以作为窗口功能、图形上下文和输入处理的框架，如
    GLFW。此外，还有几个官方库提供对导入和导出图像、自定义网络和字体渲染以在屏幕上显示文本的支持。'
- en: OpenAL
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAL
- en: '**OpenAL** is a cross-platform library that focuses on multi-channel, three-dimensional
    audio. By using 3D audio, the sound can be modeled to be in front of or behind
    the player, not just to the left or right, deepening the immersion.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenAL** 是一个专注于多通道、三维音频的跨平台库。通过使用三维音频，可以将声音建模为在玩家前方或后方，而不仅仅是左右，从而加深沉浸感。'
- en: PortAudio
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PortAudio
- en: '**PortAudio** is another cross-platform audio library. It targets real-time
    audio playback and recording. PortAudio can be used if the scope of SDL and OpenAL
    is too large for the project, and the goal is to just have some audio playing.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**PortAudio** 是另一个跨平台音频库。它针对实时音频播放和录制。如果 SDL 和 OpenAL 的范围对于项目来说太大，可以使用 PortAudio，目标是仅仅播放一些音频。'
- en: FMOD
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FMOD
- en: Although **FMOD** is a proprietary sound engine, it can be included in the list
    of freely available libraries as a non-commercial license exists, allowing us
    to use FMOD for free. A paid FMOD license is only needed if the final application
    or game will be distributed commercially. FMOD supports 3D engines such as Unreal
    and Unity, so you might even get in touch with FMOD if you are working on a game
    at some point in time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **FMOD** 是一个专有音效引擎，但由于存在非商业许可，它可以被列入免费可用的库列表，允许我们免费使用 FMOD。只有当最终的应用程序或游戏将商业分发时，才需要付费的
    FMOD 许可证。FMOD 支持如 Unreal 和 Unity 这样的 3D 引擎，所以如果你在某个时间点正在制作游戏，甚至可能会接触到 FMOD。
- en: After exploring *which software* for sound and music replay could be included,
    let’s check out *what* could and should be played.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了可以包含哪些软件用于声音和音乐回放之后，让我们来看看可以播放以及应该播放的内容。
- en: Playing sound effects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音效
- en: Since sound plays a key role in our lives, we will have some expectations of
    what we should hear in a game or a simulation. Failing to meet these expectations
    may harm immersion.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音在我们的生活中扮演着关键角色，我们会对在游戏或模拟中应该听到的内容有所期望。未能满足这些期望可能会损害沉浸感。
- en: The game character’s footsteps
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏角色的脚步声
- en: Probably the most important sound effects a player wants to hear are the footsteps
    of the character on the ground. By adjusting the sound in relation to the ground
    material and the speed of the character, instant feedback about the environment
    is delivered to the player. There is a significant difference between silently
    sneaking through grass or running on metal ground, and the player should be made
    aware of the “loudness” of the character’s actions, and by using collision detection
    and ground triangle discovery, as described in the *Finding ground triangles in
    level data* section of [*Chapter 12*](Chapter_12.xhtml)*,* the material type of
    the ground triangle can be found easily.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可能玩家最想听到的最重要的音效是角色在地面上行走的声音。通过调整与地面材料和角色速度相关的声音，向玩家提供关于环境的即时反馈。在无声地穿过草地或在地面上奔跑之间有显著的区别，玩家应该意识到角色的“响度”，并且通过使用碰撞检测和地面三角形发现，如[*第
    12 章*](Chapter_12.xhtml)中的*在关卡数据中查找地面三角形*部分所述，可以轻松找到地面三角形的材质类型。
- en: Other character sounds
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他角色声音
- en: The character makes a lot more sounds, not just footsteps. Jumping and landing,
    climbing a ladder, swimming, or being hurt by an enemy character should also give
    audible feedback to the player for additional information about what happens with
    the character in the virtual world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 角色会发出更多的声音，不仅仅是脚步声。跳跃和着陆、爬梯子、游泳或被敌人角色伤害也应该给玩家提供可听见的反馈，以提供关于虚拟世界中角色发生情况的额外信息。
- en: Local sound sources
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地声音源
- en: Not only does the player-controlled character need sound effects, but also for
    the computer-controlled characters and inanimate objects in the virtual worlds
    audio effects should be played. Hearing doors opening and closing, the hammering
    of a blacksmith, or the call of a bird, and listening to the crackles of fireplaces,
    the sound of a waterfall, or wind in a high place in the world will intensify
    immersion greatly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玩家控制的角色需要声音效果，虚拟世界中的计算机控制的角色和静止物体也应该播放音频效果。听到门开关的声音、铁匠的锤击声，或鸟儿的鸣叫，以及听到壁炉的噼啪声、瀑布声或世界高处风的声音，将极大地增强沉浸感。
- en: Ambient sounds
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境声音
- en: Ambient sounds are a mix of different sounds and frequencies coming from locations
    far away, losing some of their information on the way to the listener. A large
    group of people, the wind in a forest, or a street some meters away all produce
    well-known sounds for us that should be added to corresponding places of the virtual
    world.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 环境声音是由来自遥远地点的不同声音和频率混合而成，在传递到听者过程中会丢失一些信息。一大群人、森林中的风，或者几米外的街道都会产生我们熟知的声响，这些声响应该被添加到虚拟世界的相应位置。
- en: Weather effects
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 天气效果
- en: If the world includes some kind of weather system, the sounds and effects should
    be added too. A distant thunderstorm or the silence of the ground after a snowfall
    can change the perception of the virtual world by the player.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果世界上存在某种天气系统，那么相应的声音和效果也应该被添加。远处的雷暴或雪后地面的寂静都可以改变玩家对虚拟世界的感知。
- en: But not only can sound effects be useful for immersion; playing music can also
    help to keep a player’s attention.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但声音效果不仅有助于沉浸感；播放音乐也有助于保持玩家的注意力。
- en: Playing music
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音乐
- en: Since the early days of computer games, music has been added to games to keep
    players interested. As a result, we may still remember the music of a game when
    we see the title but not details of the gameplay or the game’s characters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自从计算机游戏早期开始，音乐就被添加到游戏中以保持玩家的兴趣。因此，当我们看到游戏标题时，我们可能仍然记得游戏的音乐，而不是游戏玩法或游戏角色的细节。
- en: Menu music
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单音乐
- en: The first screen a player will see when starting the application is most probably
    some kind of main menu. Throwing a player directly into the action, without being
    able to configure the controls for the virtual character, the visual quality,
    or the sound volume first, may not be the best idea. While the player explores
    the options in the menu, music can help to prevent the player from getting lost
    or bored straight away.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家启动应用程序后看到的第一个屏幕很可能是某种主菜单。直接将玩家投入战斗，而无法首先配置虚拟角色的控制、视觉效果或音量，可能不是最好的选择。当玩家在菜单中探索选项时，音乐可以帮助防止玩家立即感到迷茫或无聊。
- en: Ambient music
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境音乐
- en: Similar to ambient sounds, ambient music helps to prevent dead silence in a
    game. Playing no sounds at all may be intended to build up tension, but running
    for hours and hours in silence through a game can become boring. Adding a music
    track with a style and tempo that fits the gameplay helps the player to enjoy
    even slow passages of the game.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与环境声音类似，环境音乐有助于防止游戏中的死寂。完全不播放声音可能是为了建立紧张感，但长时间在寂静中玩游戏可能会变得无聊。添加一个风格和节奏适合游戏玩法的音乐曲目，可以帮助玩家享受游戏的缓慢段落。
- en: Adaptive music play
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自适应音乐播放
- en: When the player moves into a different area in an open world or enters an environment
    with a different style, or another room, changing the music to match the new place
    is a good idea. The famous “hearing boss music” moment when entering a room, combined
    with the sound of doors locking, will create unforgettable moments for a player.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入开放世界中的不同区域，或进入具有不同风格的场景，或另一个房间时，改变音乐以匹配新地方是一个好主意。进入房间时著名的“听到Boss音乐”的时刻，结合门锁的声音，将为玩家创造难忘的体验。
- en: Allowing custom music
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许自定义音乐
- en: An interesting option for music selection is to let the player add local music
    to the list of tracks played in the game or even replace the music entirely. Seeing
    the game’s character exploring a virtual world while listening to some favorite
    music tracks may be a plus for players.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐选择的一个有趣选项是让玩家将本地音乐添加到游戏中播放的曲目列表中，甚至完全替换音乐。看到游戏角色在听一些喜欢的音乐曲目时探索虚拟世界，可能会为玩家增添乐趣。
- en: To experience the difference audio replay can make, we will add a C++ class
    to manage sound effects and music replay.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了体验音频回放可以带来的差异，我们将添加一个C++类来管理声音效果和音乐回放。
- en: 'Hands-on: Implementing an audio manager'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践：实现音频管理器
- en: The audio manager class consists of two distinct parts. On one hand, we need
    a high-level interface between the audio manager and the renderer and other classes.
    On the other hand, the encapsulated low-level interface linking the audio manager
    functionality to the audio library of the operating system would allow us to replace
    the audio library with another variant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 音频管理类由两个不同的部分组成。一方面，我们需要音频管理器和渲染器以及其他类之间的高层接口。另一方面，封装的底层接口将音频管理器功能与操作系统的音频库链接起来，这将允许我们用另一个变体替换音频库。
- en: We will start with a brief overview of the high-level interface and dive into
    the low-level implementation afterward.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简要概述高层接口，然后深入到底层实现。
- en: Defining the high-level interface
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义高层接口
- en: 'The new `AudioManager` class, consisting of the `AudioManager.h` header file
    and the `AudioManager.cpp` implementation file will be added to the `tools` folder.
    We will add the basic functions a usual music/sound player should have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`AudioManager`类，包括`AudioManager.h`头文件和`AudioManager.cpp`实现文件，将被添加到`tools`文件夹中。我们将添加通常音乐/声音播放器应具备的基本功能：
- en: Initializing and cleaning up the audio library
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和清理音频库
- en: Loading music tracks from files on the file system
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件系统上的文件加载音乐曲目
- en: Loading sound effects from files on the file system
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件系统上的文件加载音效
- en: Playing and stopping music and sound effects
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放和停止音乐和音效
- en: Pausing, resuming, and skipping the music tracks to the next and previous
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停、恢复和跳转到下一首和上一首音乐曲目
- en: Retrieving, shuffling, and clearing the current playlist
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取、随机播放和清除当前播放列表
- en: Changing the volume of music and sound effects
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变音乐和音效的音量
- en: 'For instance, the `public` `setMusicVolume()` and `getMusicVolume()` methods
    are added to the `AudioManager` class to control the music volume:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，向`AudioManager`类中添加了`public`的`setMusicVolume()`和`getMusicVolume()`方法来控制音乐音量：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition, the `private` member variable named `mMusicVolume` is used to
    store the current volume of the music:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，名为`mMusicVolume`的`private`成员变量用于存储当前的音乐音量：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the remaining functionalities in the list of functions, `public` methods
    and `private` member variables are created. Check the `AudioManager.h` file to
    see the full number of methods and member variables that are available in the
    `AudioManager` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能列表中剩余的功能，创建了`public`方法和`private`成员变量。请查看`AudioManager.h`文件以了解`AudioManager`类中可用的方法和成员变量的完整数量。
- en: Now we must add a member variable for an object of the `AudioManager` class
    along with the initialization and cleanup calls of the audio functionality to
    the application code. To keep the renderer for the video part only, the `AudioManager`
    member variable and methods will be added to the `Window` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将`AudioManager`类的对象成员变量以及音频功能的初始化和清理调用添加到应用程序代码中。为了仅保留视频部分的渲染器，`AudioManager`成员变量和方法将被添加到`Window`类中。
- en: Adding the AudioManager class to the Window class
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将`AudioManager`类添加到`Window`类中
- en: 'The two primary steps to add the audio functions to the `Window` class are
    the same as for all other classes: including the `AudioManager.h` header file
    at the top of the `Window.h` header file and declaring the `private` member variable
    named `mAudioManager`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将音频功能添加到`Window`类的两个主要步骤与其他所有类相同：在`Window.h`头文件的顶部包含`AudioManager.h`头文件，并声明名为`mAudioManager`的`private`成员变量：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in the `init()` method of the `Window` class in the `Window.cpp` file,
    we try to initialize the `AudioManager` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Window.cpp`文件中`Window`类的`init()`方法中，我们尝试初始化`AudioManager`对象：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we use the `Logger` class to print an error message, but we *do not*
    end the window initialization if the `AudioManager` initialization fails. Audio
    replay should be kept optional, and we continue without music and sound replay
    instead of failing the application startup process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Logger`类来打印错误信息，但如果`AudioManager`初始化失败，我们不会结束窗口初始化。音频回放应保持可选，我们将继续进行，而不是在音乐和声音回放失败时终止应用程序启动过程。
- en: 'Loading the music tracks into the `AudioManager` can be done right after the
    initialization call:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化调用后立即将音乐曲目加载到`AudioManager`中：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are trying to load all MP3 files in the `assets/music` folder into
    the `AudioManager` if the initialization is successful. Again, we don’t fail if
    no music files are found in the asset folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们尝试在初始化成功的情况下将 `assets/music` 文件夹中的所有 MP3 文件加载到 `AudioManager` 中。同样，如果在资产文件夹中没有找到音乐文件，我们不会失败。
- en: Adding music tracks to the playlist
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将音乐曲目添加到播放列表
- en: In the `AudioManager` class, support for loading MP3 and OGG files from the
    local folder `assets/music` into a playlist has been implemented. You can add
    your own music to the `assets/music` folder as the playlist will be populated
    when the application is started. In the *Practical sessions* section, a task is
    available to add a **Refresh** button to the UI, allowing you to add or remove
    music tracks at application runtime.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AudioManager` 类中，已经实现了从本地文件夹 `assets/music` 加载 MP3 和 OGG 文件到播放列表的支持。您可以将自己的音乐添加到
    `assets/music` 文件夹中，因为当应用程序启动时播放列表将被填充。在 *实践课程* 部分中，有一个任务可以添加一个 **刷新** 按钮到 UI
    中，允许您在应用程序运行时添加或删除音乐曲目。
- en: 'Finally, we need to clean up the `AudioManager` when shutting down the application.
    So, we add a call to the `cleanup()` method of `AudioManager` to the `cleanup()`
    method of the `Window` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在关闭应用程序时清理 `AudioManager`。因此，我们将对 `Window` 类的 `cleanup()` 方法添加对 `AudioManager`
    的 `cleanup()` 方法的调用：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since we created the `AudioManager` in the `Window` class, we need to create
    callback functions to access the music and sound-effect functions from the renderer
    or the user interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `Window` 类中创建了 `AudioManager`，我们需要创建回调函数以从渲染器或用户界面访问音乐和音效函数。
- en: Using callbacks to make the AudioManager class available everywhere
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用回调使 AudioManager 类在所有地方可用
- en: By using these callback functions, changing the music track or playing footstep
    sounds can be done from anywhere in the code. As an example, we will use the functionality
    to play a specific music track here, given the track name as a parameter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些回调函数，可以从代码的任何地方更改音乐曲目或播放脚步声。作为一个例子，我们将在这里使用播放特定音乐曲目的功能，给定曲目名称作为参数。
- en: 'First, we add the function signature for the callback named `playMusicTitleCallback`
    to the `Callbacks.h` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将名为 `playMusicTitleCallback` 的回调函数签名添加到 `Callbacks.h` 文件中：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we create a variable named `micPlayMusicTitleCallbackFunction` to the
    `ModelInstanceCamData` `struct` in the `ModelInstanceCamData.h` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `ModelInstanceCamData.h` 文件中为 `ModelInstanceCamData` `struct` 创建一个名为
    `micPlayMusicTitleCallbackFunction` 的变量：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use the `ModelInstanceCamData` `struct` to avoid spreading the callback functions
    all over the code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ModelInstanceCamData` `struct` 来避免在代码中到处传播回调函数。
- en: 'Then, the callback variable will be bound to the corresponding `AudioManager`
    function in the `init()` method of the `Window` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回调变量将被绑定到 `Window` 类的 `init()` 方法中对应的 `AudioManager` 函数：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we get a reference to the variable containing the `ModelInstanceCamData`
    `struct` of the renderer class and assign the `playTitle()` method of the `AudioManager`
    class by using a lambda function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们获取渲染器类中包含 `ModelInstanceCamData` `struct` 的变量的引用，并使用 lambda 函数分配 `AudioManager`
    类的 `playTitle()` 方法。
- en: The same three steps of creating the callback function signature, adding a variable
    to the `ModelInstanceCamData` `struct`, and binding the callback function to the
    method of the `AudioManger` class must be repeated for every audio method that
    should be available in the renderer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建回调函数签名、将变量添加到 `ModelInstanceCamData` `struct` 以及将回调函数绑定到 `AudioManger` 类的方法这三个相同的步骤必须为渲染器中应可用的每个音频方法重复执行。
- en: Now, let’s look at the implementation of the low-level part of the audio manager.
    We will use SDL as the audio functions are easy to use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看音频管理器低级部分的实现。我们将使用 SDL，因为音频函数易于使用。
- en: Using SDL for the low-level layer
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在低级层使用 SDL
- en: Although SDL can handle more features than audio, it is possible to use only
    a subset of the functions provided by the SDL library. So, instead of using SDL
    for window and keyboard handling, which is done by GLFW in the application, we
    will only use the sound replay and mix functionality of SDL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SDL可以处理比音频更多的功能，但仍然可以使用SDL库提供的函数子集。因此，我们不会使用SDL来处理窗口和键盘，这由应用程序中的GLFW完成，我们只会使用SDL的声音回放和混音功能。
- en: To use audio replay with SDL, we need the core SDL library plus the separate
    mixer library named `SDL_mixer`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SDL 进行音频回放，我们需要核心 SDL 库以及名为 `SDL_mixer` 的单独混音库。
- en: Installing SDL and SDL_mixer on Windows
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 SDL 和 SDL_mixer
- en: 'For Windows, precompiled versions of SDL and `SDL_mixer` are available on GitHub.
    Go to the releases page at the following two URLs and download the latest stable
    development zip files for Visual Studio, containing both `devel` and `VC` in their
    names. As an example, the current development package of the main SDL library
    for Visual Studio is named `SDL2-devel-2.30.9-VC.zip`. Here are the URLs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，GitHub 上提供了 SDL 和 `SDL_mixer` 的预编译版本。访问以下两个 URL 的发布页面，下载最新的稳定开发 zip
    文件，文件名中包含 `devel` 和 `VC`，用于 Visual Studio。例如，当前 Visual Studio 的主 SDL 库开发包名为 `SDL2-devel-2.30.9-VC.zip`。以下是
    URL：
- en: 'SDL: [https://github.com/libsdl-org/SDL/releases](https://github.com/libsdl-org/SDL/releases)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SDL: [https://github.com/libsdl-org/SDL/releases](https://github.com/libsdl-org/SDL/releases)'
- en: '`SDL_mixer`: [https://github.com/libsdl-org/SDL_mixer/releases](https://github.com/libsdl-org/)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL_mixer`: [https://github.com/libsdl-org/SDL_mixer/releases](https://github.com/libsdl-org/)'
- en: Now, unpack the two zip files to your computer, but take care to avoid spaces
    and special characters like German umlauts in the path names to avoid problems
    since even in 2024 many tools have still problems with special characters in the
    paths.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将两个 zip 文件解压到您的计算机上，但请注意避免在路径名称中使用空格和特殊字符，如德语的重音符号，以避免问题，因为即使在 2024 年，许多工具仍然在路径中的特殊字符上存在问题。
- en: 'Next, add two **environment variables** to help the CMake search scripts find
    the headers and libraries:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加两个 **环境变量** 以帮助 CMake 搜索脚本找到头文件和库：
- en: The first variable is named `SDL2DIR` and must point to the folder where the
    main SDL library was unpacked.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个变量名为 `SDL2DIR`，必须指向主 SDL 库解压的文件夹。
- en: The second variable is named `SDL2MIXERDIR` and must point to the folder of
    the `SDL_mixer` library.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个变量名为 `SDL2MIXERDIR`，必须指向 `SDL_mixer` 库的文件夹。
- en: '*Figure 14.1* shows an example of the environment variables:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.1* 展示了环境变量的示例：'
- en: '![](img/figure_14_01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_14_01.png)'
- en: 'Figure 14.1: Example environment variables for SDL'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：SDL 的示例环境变量
- en: After installing the two libraries and adding the environment variables, the
    code for this chapter can be compiled. The CMake build script takes care of placing
    the two DLL files next to the executable file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安装两个库并添加环境变量后，可以编译本章的代码。CMake 构建脚本负责将两个 DLL 文件放置在可执行文件旁边。
- en: Installing SDL and SDL_mixer on Linux
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 SDL 和 SDL_mixer
- en: 'On Linux, the SDL libraries can be added by using the integrated package management.
    On Ubuntu or Debian, you can use the `apt` package manager to install the main
    SDL library, the `SDL_mixer` library, and all development headers and libraries
    by issuing the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，可以通过集成软件包管理器添加 SDL 库。在 Ubuntu 或 Debian 上，您可以使用 `apt` 软件包管理器通过以下命令安装主
    SDL 库、`SDL_mixer` 库以及所有开发头文件和库：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For an Arch-based distribution, use the `pacman` package manager to add the
    two libraries to the system with the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Arch 的发行版，使用 `pacman` 软件包管理器通过以下命令将两个库添加到系统中：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To add SDL and `SDL_mixer` to the `AudioManager` class in order to use the
    SDL functions, we must include the two SDL headers after the existing `#include`
    directives in the `AudioManager.h` header file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 SDL 和 `SDL_mixer` 添加到 `AudioManager` 类中以便使用 SDL 函数，我们必须在 `AudioManager.h`
    头文件中现有的 `#include` 指令之后包含两个 SDL 头文件：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since SDL is a C library, all structures only use raw pointers. The audio manager
    is one of the places where you will find variables with raw pointers in the code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SDL 是一个 C 库，所有结构只使用原始指针。音频管理器是您将在代码中找到带有原始指针变量的地方之一：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `mMusicTitles` variable is a map containing several SDL music objects, which
    are accessible by the name of the track as the key for the map. Every track is
    saved in a variable named `Mix_Music`, where the prefix Mix states that this is
    a variable used by the `SDL_mixer` library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`mMusicTitles` 变量是一个包含多个 SDL 音乐对象的映射，可以通过轨道名称作为映射的键访问。每个轨道都保存在名为 `Mix_Music`
    的变量中，前缀 Mix 表示这是一个由 `SDL_mixer` 库使用的变量。'
- en: In the `mWalkFootsteps` variable, a so-called chunk of audio (using the terms
    of SDL) is stored. An `SDL_mixer` chunk can be played by calling the respective
    sound effect’s replay function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mWalkFootsteps` 变量中，存储了一个所谓的音频块（使用 SDL 的术语）。可以通过调用相应音效的回放函数来播放 `SDL_mixer`
    音频块。
- en: Before sound effects or music can be played, the audio part of SDL must be initialized
    properly, and at the end of the application, the audio functions must be ended
    too.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放音效或音乐之前，SDL 的音频部分必须正确初始化，并在应用程序结束时结束音频功能。
- en: Initializing and shutting down SDL and the SDL_mixer
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化和关闭 SDL 及 SDL_mixer
- en: 'As the first step in the `init()` method of the `AudioManager` class, we try
    to initialize the audio part of SDL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `AudioManager` 类的 `init()` 方法的第一步，我们尝试初始化 SDL 的音频部分：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `SDL` prefix of both `SDL_Init()` and the `SDL_INIT_AUDIO` flag denotes
    that we are using the core functionality of SDL. If we cannot initialize the audio
    part of SDL, we stop the initialization of the `AudioManager` right here. Beware
    that the initialization of the audio device can fail for various reasons, for
    instance, if the audio device is in use by another application that forbids sharing
    the device.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_Init()` 和 `SDL_INIT_AUDIO` 标志的 `SDL` 前缀表示我们正在使用 SDL 的核心功能。如果我们无法初始化 SDL
    的音频部分，我们将在这里停止 `AudioManager` 的初始化。请注意，音频设备的初始化可能会因各种原因而失败，例如，如果音频设备被另一个应用程序使用并禁止共享该设备。'
- en: 'Next, we try to set the parameters for the audio device by calling `Mix_OpenAudio()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试通过调用 `Mix_OpenAudio()` 来设置音频设备的参数：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we are in the realm of `SDL_mixer`, which is visible on the `Mix` prefix
    of `Mix_OpenAudio`. The first parameter of `Mix_OpenAudio` is the replay frequency
    in Hz. We are using the well-known value of 44.1 kHz, introduced by Sony’s **compact
    disc** specifications. As the second parameter, the internal audio format is configured.
    `MIX_DEFAULT_FORMAT` stands for 16-bit signed integer values, which is also a
    common value in the audio world.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入了 `SDL_mixer` 的领域，这在 `Mix_OpenAudio` 的 `Mix` 前缀中可见。`Mix_OpenAudio` 的第一个参数是重放频率（Hz）。我们使用由索尼的
    **光盘** 规范引入的知名值 44.1 kHz。作为第二个参数，配置了内部音频格式。`MIX_DEFAULT_FORMAT` 代表 16 位有符号整数值，这在音频领域也是一个常见值。
- en: The third parameter is the number of output channels to use. One output channel
    uses mono replay, and the two channels from the initialization call are for stereo
    output. Depending on the audio hardware and driver support, up to eight output
    channels for a 7.1 system are possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是要使用的输出通道数。一个输出通道使用单声道重放，初始化调用中的两个通道用于立体声输出。根据音频硬件和驱动程序支持，对于 7.1 系统来说，可能最多有八个输出通道。
- en: With the fourth and last parameter, an internal audio buffer in the `SDL_mixer`
    library is configured. A small buffer value may cause audio dropouts if the CPU
    load gets too high while filling the buffer, and a large buffer leads to delays
    since the buffer needs to be filled before the samples can be played. The unit
    of the buffer parameter is “sample frames,” so we configure `SDL_mixer` to reserve
    space for 2,048 frames, every frame contains two 16-bit signed integers, one for
    every output channel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第四个和最后一个参数，配置了 `SDL_mixer` 库中的内部音频缓冲区。如果 CPU 负载过高而填充缓冲区时，较小的缓冲区值可能会导致音频中断，而较大的缓冲区会导致延迟，因为缓冲区需要被填充后才能播放样本。缓冲区参数的单位是“样本帧”，因此我们配置
    `SDL_mixer` 为保留 2,048 个帧的空间，每个帧包含两个 16 位有符号整数，每个输出通道一个。
- en: 'At the termination time of the application, the `cleanup()` method of the `AudioManager`
    is called by the `cleanup()` method of the `Window` class. Inside the `cleanup()`
    method of the `AudioManager` class, we close the audio device and signal both
    `SDL_mixer` and SDL to run their respective cleanup code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的终止时间，`Window` 类的 `cleanup()` 方法会调用 `AudioManager` 的 `cleanup()` 方法。在 `AudioManager`
    类的 `cleanup()` 方法内部，我们关闭音频设备，并通知 `SDL_mixer` 和 SDL 运行它们各自的清理代码：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we did not call `Mix_Init()` in the `init()` method, but we have to
    call `Mix_Quit()` here. SDL manages the mixer initialization for us without an
    explicit call to `Mix_Init()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `init()` 方法中没有调用 `Mix_Init()`，但我们必须在这里调用 `Mix_Quit()`。SDL 在没有显式调用 `Mix_Init()`
    的情况下为我们管理混音初始化。
- en: Now we are ready to play music and sound effects. Let’s start with a look at
    the music replay code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备播放音乐和音效。让我们先看看音乐重放代码。
- en: Controlling music replay
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制音乐重放
- en: 'Loading a music track is done by calling `Mix_LoadMUS()` with the C-style character
    array as a parameter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用带有 C 风格字符数组作为参数的 `Mix_LoadMUS()` 来加载音乐曲目：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`SDL_mixer` supports several music formats, such as WAV, MP3, and OGG. The
    return value of `Mix_LoadMUS()` is a pointer to the `Mix_Music` `struct`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_mixer` 支持多种音乐格式，如 WAV、MP3 和 OGG。`Mix_LoadMUS()` 的返回值是指向 `Mix_Music` `struct`
    的指针。'
- en: 'To clean up a loaded music track, `Mix_FreeMusic()` must be called with the
    pointer to the above `Mix_Music` `struct`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理加载的音乐曲目，必须使用指向上述 `Mix_Music` `struct` 的指针调用 `Mix_FreeMusic()`：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A music track can be played by calling `Mix_PlayMusic()` with two parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一条音乐曲目可以通过调用带有两个参数的 `Mix_PlayMusic()` 来播放：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first parameter is a pointer to a valid `Mix_Music` `struct`, while the
    second parameter tells `SDL_mixer` the number of loops to play. A loop value of
    `0` disables looping and a value of `-1` will loop the music infinitely.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是指向有效 `Mix_Music` `结构体` 的指针，而第二个参数告诉 `SDL_mixer` 要播放的循环次数。循环值为 `0` 将禁用循环，而值为
    `-1` 将无限循环音乐。
- en: 'Stopping the music is done by calling `Mix_HaltMusic()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `Mix_HaltMusic()` 来停止音乐：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since there is only one music track playing at a time, no parameters are needed,
    and in case the current track should be paused or resumed, the two `Mix_PauseMusic()`
    and `Mix_ResumeMusic()` calls are available:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一次只播放一个音乐曲目，因此不需要参数，并且如果当前曲目应该暂停或恢复，则有两个 `Mix_PauseMusic()` 和 `Mix_ResumeMusic()`
    调用可用：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the music volume is controlled by `Mix_VolumeMusic()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过 `Mix_VolumeMusic()` 控制音乐音量：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The parameter for `Mix_VolumeMusic()` is an `int` value between `0` and `128`
    to set the new volume, or a value of `-1` to query the current volume of the music.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mix_VolumeMusic()` 的参数是一个介于 `0` 和 `128` 之间的 `int` 值，用于设置新的音量，或者值为 `-1` 用于查询音乐的当前音量。'
- en: By using the default `SDL_mixer` calls, we can only play one music track once
    or with an infinite number of loops. If a dynamic music system is required, a
    manual implementation is needed, or even a different sound replay API should be
    considered. For the simple ability to advance to the next track in a playlist
    at the end of a track, we just need to implement a callback.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用默认的 `SDL_mixer` 调用，我们只能播放一个音乐曲目一次或使用无限循环。如果需要动态音乐系统，则需要手动实现，甚至可能需要考虑不同的声音重放
    API。对于在曲目结束时简单前进到播放列表中下一个曲目的简单能力，我们只需要实现一个回调。
- en: Adding a callback for continuous music playback
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加用于连续音乐播放的回调
- en: '`SDL_mixer` supports a callback to inform the application that the current
    music track has finished the number of loops. In this callback, we can simply
    forward to the next track in the playlist.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_mixer` 支持一个回调，用于通知应用程序当前音乐曲目已完成指定次数的循环。在这个回调中，我们可以简单地转发到播放列表中的下一个曲目。'
- en: Sadly, `SDL_mixer` is a C audio library, and the callback must fulfill the C-style
    calling convention. The C++ calling convention is not compatible with the C calling
    convention and allows only calling static member functions of the `AudioManager`
    class. We need to add a small hack to be able to call a non-static method of the
    `AudioManager` class that has access to the playlist and the current position
    in the playlist.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，`SDL_mixer` 是一个 C 音频库，回调必须满足 C 风格的调用约定。C++ 调用约定与 C 调用约定不兼容，并且只允许调用 `AudioManager`
    类的静态成员函数。我们需要添加一个小技巧，以便能够调用具有访问播放列表和播放列表当前位置的 `AudioManager` 类的非静态方法。
- en: 'First, we declare a raw pointer named `mCurrentManager` as `private` member
    variable, plus the `private` static `staticMuscFinishedCallback()` member method
    for the C-style callback and a `private` non-static member `musicFinishedCallback()`
    for the translated callback:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个名为 `mCurrentManager` 的原始指针作为 `private` 成员变量，加上用于 C 风格回调的 `private`
    静态 `staticMuscFinishedCallback()` 成员方法和用于翻译回调的 `private` 非静态成员 `musicFinishedCallback()`：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `init()` method of the `AudioManager` class, we set the `mCurrentManager`
    pointer to the current instance and call the callback hook setup method `Mix_HookMusicFinished()`
    with the static callback method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AudioManager` 类的 `init()` 方法中，我们将 `mCurrentManager` 指针设置为当前实例，并使用静态回调方法调用回调钩子设置方法
    `Mix_HookMusicFinished()`：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Whenever a music track ends now, `staticMusicFinishedCallback()` is called
    by `SDL_mixer`. To translate the callback to C++, we use the pointer to the current
    `AudioManager` instance stored in `mCurrentManager` to call the non-static callback
    `musicFinishedCallback()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当音乐曲目结束时，`SDL_mixer` 会调用 `staticMusicFinishedCallback()`。要将回调转换为 C++，我们使用存储在
    `mCurrentManager` 中的当前 `AudioManager` 实例的指针来调用非静态回调 `musicFinishedCallback()`
    方法：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside `musicFinishedCallback()`, we can now add code to advance one track
    in the playlist, enabling a continuous replay of all tracks in the playlist:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `musicFinishedCallback()` 内部，我们现在可以添加代码以在播放列表中前进一个曲目，从而实现所有曲目的连续重放：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the music replay is implemented, let’s go to the sound effect replay code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在音乐重放实现后，让我们转到声音效果重放代码。
- en: Playing sound effects
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放声音效果
- en: Using `SDL_mixer` to play sound effects has some subtle differences compared
    to playing music. The main difference is that by default eight sound effects can
    be played at the same time since `SDL_mixer` allocates eight internal sound channels
    for the sound effect output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与播放音乐相比，使用`SDL_mixer`播放音效有一些细微的差别。主要区别是默认情况下可以同时播放八个音效，因为`SDL_mixer`为音效输出分配了八个内部音效通道。
- en: Note that these internal sound channels are not the same as the two output sound
    channels configured when we initialized the audio device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些内部音效通道与我们初始化音频设备时配置的两个输出音效通道不同。
- en: 'Allocating more or even less than these eight sound channels can be done by
    calling `Mix_AllocateChannels()` with the number of desired channels as a parameter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`Mix_AllocateChannels()`并传入期望的通道数作为参数来分配更多或更少的这八个音效通道：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will use only one channel in the `AudioManager` for now to allow a simple
    implementation of the footstep sound replay.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们将在`AudioManager`中仅使用一个通道，以便简单实现脚步声回放的功能。
- en: As `SDL_mixer` has only one channel available now, a second sound effect cannot
    be played if another sound effect is still playing. So, by limiting the number
    of channels to only one, we can avoid creating a complex system to switch between
    walking and running footstep sounds for the example implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SDL_mixer`目前只有一个通道可用，如果另一个音效仍在播放，则无法播放第二个音效。因此，通过将通道数限制为只有一个，我们可以避免在示例实现中创建一个复杂的系统来在行走和跑步脚步声之间切换。
- en: 'Loading a sound file from the file system is similar to the music loading process.
    We call `Mix_LoadWav()` with the C-style character array of the file name and
    store the returned result in a `Mix_Chunk` `struct`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件系统中加载音文件的过程与音乐加载过程类似。我们通过调用`Mix_LoadWav()`并传入文件名的C风格字符数组来加载音文件，并将返回的结果存储在`Mix_Chunk`结构体中：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Cleaning up the sound effect is done by calling `Mix_FreeChunk()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Mix_FreeChunk()`来清理音效：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Playing and stopping the replay of a sound effect is also like playing or stopping
    the music. A sound effect will be played by using `Mix_PlayChannel()`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 播放和停止音效回放的方式与播放或停止音乐类似。通过使用`Mix_PlayChannel()`来播放音效：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first parameter of `Mix_PlayChannel()` is the sound channel to use. The
    special value of `-1` just uses the next available sound channel for the sound
    effect replay. The second parameter is a pointer to the `Mix_Chunk` `struct` to
    play, and the third parameter is again the number of loops.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mix_PlayChannel()`的第一个参数是要使用的音效通道。特殊值`-1`将使用下一个可用的音效通道进行音效回放。第二个参数是播放的`Mix_Chunk`结构体的指针，第三个参数是循环次数。'
- en: 'As the return parameter of `Mix_PlayChannel()`, we get the sound channel number,
    on which this sound effect is played. We save the channel number in the `mSoundChannel`
    member variable to be able to stop the replay with `Mix_HaltChannel()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Mix_PlayChannel()`的返回参数，我们得到播放此音效的音效通道号。我们将通道号保存在`mSoundChannel`成员变量中，以便能够通过`Mix_HaltChannel()`停止回放：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Like for the music, we can control the volume of the sound channel by calling
    `Mix_Volume()` with the channel number and desired volume as parameters:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像音乐一样，我们可以通过调用`Mix_Volume()`并传入通道号和期望的音量作为参数来控制音效通道的音量：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After we know how to play sound effects, we need to add a bit of code to the
    renderer to play a footstep sound whenever our instance is walking or running.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们知道如何播放音效之后，我们需要在渲染器中添加一些代码，以便在实例行走或跑步时播放脚步声。
- en: Using the footstep sound effects in the renderer
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在渲染器中使用脚步声效果
- en: The implementation of the footstep replay will be just the bare minimum to show
    how and where the callbacks for the sound effects could be added. A full-featured
    sound effects replay system requires much more work and is out of the scope of
    this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 脚步声回放的实现将是最基本的，以展示如何以及在哪里添加音效的回调函数。一个功能齐全的音效回放系统需要更多的工作，并且超出了本书的范围。
- en: To add the footstep sounds, the following piece of code needs to be added to
    the `handleMovementKeys()` method of the renderer, right after we set the next
    state of the instance by calling `setNextInstanceState()`. At this point, we have
    all data about the current movement state of the instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加脚步声，需要在渲染器的`handleMovementKeys()`方法中添加以下代码片段，紧接在通过调用`setNextInstanceState()`设置实例的下一个状态之后。此时，我们已经拥有了实例当前运动状态的所有数据。
- en: 'First, we retrieve the current animation state of the current instance and
    check if the instance is in the idle/walk/run cycle:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索当前实例的当前动画状态，并检查实例是否处于空闲/行走/跑步循环：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We only want to add sound effects at the same time as the walking and running
    animations replay.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在行走和跑步动画回放的同时添加音效。
- en: 'Then we check for the movement state of the instance and call the proper callback
    for the state:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查实例的运动状态，并调用适当的状态回调：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the instance is in the running state, we play the sound effect for running
    footsteps. And if the instance is in the walking state, we play the walking footsteps.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例处于运行状态时，我们播放跑步脚步声音效。如果实例处于行走状态，则播放行走脚步声。
- en: 'If the instance is neither running nor walking, we stop the footstep sounds:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例既不运行也不行走，我们停止脚步声音效：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And if the instance is not in the idle/walk/run cycle, we also stop any sounds.
    This way, we catch all the actions like jumping or punching where no sound effect
    is available yet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例不在空闲/行走/跑步循环中，我们也会停止任何声音。这样，我们可以捕捉到所有尚未提供音效的动作，如跳跃或出拳：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To hear the footsteps sounds, the following steps are required:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要听到脚步声，需要执行以下步骤：
- en: Start the application and load a configuration with animation mapping.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并加载具有动画映射的配置。
- en: Select (or create) a first-person or third-person camera.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择（或创建）一个第一人称或第三人称相机。
- en: Select an instance and set the instance by clicking on **Use Selected Instance**
    in the **Camera** section of the **Control** window of the UI.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI的**控制**窗口的**相机**部分中，选择实例并通过点击**使用所选实例**来设置实例。
- en: Press `F10` to switch to view mode.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`F10`键切换到查看模式。
- en: If you move around the controlled instance now by using the mouse and the *W*/*A*/*S*/*D*
    keys, you should hear two different footstep sounds, depending on the instance
    walking or running around in the virtual world.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在通过使用鼠标和*W*/*A*/*S*/*D*键移动受控实例，你应该听到两种不同的脚步声，这取决于实例在虚拟世界中行走或跑步。
- en: Extending the audio manager class
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展音频管理器类
- en: To outline a possible expansion of the `AudioManager` class to support more
    channels to achieve a more game-like sound management, we would need to keep track
    of the channel playing the footstep sound returned by the `Mix_PlayChannel()`
    call. By reserving one channel exclusively for the local footstep sounds, we can
    achieve the same behavior, but we would be able to play more sound effects at
    the same time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概述`AudioManager`类可能的扩展，以支持更多通道以实现更类似游戏的声音管理，我们需要跟踪`Mix_PlayChannel()`调用返回的播放脚步声音通道。通过为本地脚步声保留一个专用通道，我们可以实现相同的行为，但我们将能够同时播放更多音效。
- en: Handling multiple sound effects can be achieved by adding a creating a pool
    of sound channels and adding a callback to the `Mix_ChannelFinished()` SDL function,
    similar to `Mix_HookMusicFinished()`. SDL triggers the `Mix_ChannelFinished()`
    callback whenever a channel has finished the current sound clip, or when `Mix_HaltChannel()`
    is called and delivers the number of the finished sound channel in the callback.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个声音通道池并向`Mix_ChannelFinished()` SDL函数添加回调，可以实现对多个音效的处理，类似于`Mix_HookMusicFinished()`。SDL在通道完成当前音剪辑或调用`Mix_HaltChannel()`时触发`Mix_ChannelFinished()`回调，并在回调中传递完成的声音通道编号。
- en: The sound channel pool can be updated when a sound effect is played and when
    the effect replay has finished. By using the distance to the object creating the
    sound effect and scaling down the volume of the channel with `Mix_Volume()` or
    by using `Mix_SetDistance()`, the different distances of the source can be modeled.
    In addition, `Mix_SetPanning()` can be used to adjust the position of the sound
    source to the left and right.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当播放音效和音效回放完成后，可以更新声音通道池。通过使用产生音效的对象的距离并使用`Mix_Volume()`或`Mix_SetDistance()`缩小通道音量，可以模拟不同源的距离。此外，可以使用`Mix_SetPanning()`调整声音源的位置到左右。
- en: Several tasks in the *Practical sessions* section are available to evolve the
    sound replay from the current state.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在“实际操作”部分中，有几个任务可用于从当前状态演变声音回放。
- en: As an example of how to use the `AudioManager` callbacks from the `UserInterface`
    class, a simple music replay control has been added to the user interface. In
    the **Music & Sound** section of the **Control** window, you will find a combo
    box and some buttons to play the music from the playlist created from the `assets/music`
    folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为如何使用`UserInterface`类的`AudioManager`回调的示例，一个简单的音乐重放控制已被添加到用户界面中。在**控制**窗口的**音乐与音效**部分，您将找到一个组合框和一些按钮，可以播放从`assets/music`文件夹创建的播放列表中的音乐。
- en: Using the music player in the UI
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在UI中使用音乐播放器
- en: Adding music replay functionality to the `UserInterface` class is a quick and
    simple task. By using the callbacks to the `AudioManager` class, a basic music
    player is implemented with only a few code blocks to the UI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将音乐重放功能添加到`UserInterface`类是一个快速且简单的工作。通过使用对`AudioManager`类的回调，仅用几个代码块就实现了基本的音乐播放器。
- en: 'In *Figure 14.2*, the ImGui section with a basic music player using the `AudioManager`
    class is shown:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.2*中，展示了使用`AudioManager`类的基本音乐播放器的ImGui部分：
- en: '![](img/figure_14_02.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_14_02.png)'
- en: 'Figure 14.2: A music player based on the AudioManager added to the user interface'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：添加到用户界面的基于AudioManager的音乐播放器
- en: The desired music track to play can be chosen by using the **Tracks** combo
    box, the current track can be played by pressing the **Play** button, or a random
    track from the playlist will be chosen from the shuffled playlist by pressing
    **Play Random**. The other four buttons, **Prev**, **Pause**, **Stop**, and **Next**,
    do exactly what the label states, and by using the sliders, the volume of music
    and sound effects can be set to a value between `0` (for silence) and `128`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用**曲目**组合框来选择要播放的音乐曲目，通过按下**播放**按钮播放当前曲目，或者通过按下**播放随机**按钮从随机播放列表中选择一个曲目。其他四个按钮，**上一曲**、**暂停**、**停止**和**下一曲**，正好执行标签上所指示的操作，并且通过使用滑块，可以将音乐和音效的音量设置为介于`0`（静音）和`128`之间的值。
- en: Alternative sound manager implementations
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的声音管理器实现
- en: The `AudioManager` class used for the application uses a straightforward implementation
    with direct control through C++ callback functions. For an advanced sound system,
    an event- or message-based implementation could be used. Such an implementation
    can use event managing code already in the game, and events or messages also decouple
    the sound effects replay from the code that is requesting to replay a sound effect
    or a music change.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中使用的`AudioManager`类采用了一种简单的实现方式，通过C++回调函数直接控制。对于高级声音系统，可以使用基于事件或消息的实现。这种实现可以使用游戏中已有的事件管理代码，并且事件或消息还可以将音效重放与请求重放音效或更改音乐的代码解耦。
- en: After having sound and music available in the virtual world, an update to the
    graphics of the application may appear also on the to-do list. Let’s explore some
    visual enhancements now.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟世界中有了声音和音乐之后，应用程序图形的更新也可能出现在待办事项列表中。现在让我们探索一些视觉增强功能。
- en: Enhancing visuals
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强视觉效果
- en: 'The OpenGL and Vulkan renderers in the example code support only a minimal
    set of features to bring an image to the screen: Both renderers can only draw
    textures triangles and colored lines. Adding one or more of the following enhancements
    will be a fantastic extension to the quality of the images.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码中的OpenGL和Vulkan渲染器仅支持最小功能集，以将图像渲染到屏幕上：两个渲染器都只能绘制纹理三角形和彩色线条。添加以下增强功能之一将极大地提升图像质量。
- en: Bringing colors to the world by using physically based rendering
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用基于物理的渲染为世界带来色彩
- en: Right now, we are using only the textures of the Assimp objects to render the
    model instances and level geometry to the screen. By using **physically based
    rendering**, short **PBR**, we could also model surface properties in the form
    of materials. With such PBR materials, it is easy to create surfaces that have
    a shininess and reflectivity of metal or make surfaces like concrete or bricks
    look more natural.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只使用Assimp对象的纹理来将模型实例和关卡几何渲染到屏幕上。通过使用**基于物理的渲染**，简称**PBR**，我们还可以以材料的形式模拟表面属性。使用这种PBR材料，可以轻松创建具有金属光泽和反射性的表面，或者使混凝土或砖块等表面看起来更加自然。
- en: '*Figure 14.3* shows spheres drawn by the Vulkan PBR example code from Sascha
    Willems (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.3*展示了Sascha Willems（代码可在[https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)）的Vulkan
    PBR示例代码绘制的球体：'
- en: '![](img/figure_14_03.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3](img/figure_14_03.png)'
- en: 'Figure 14.3: Different PBR materials'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：不同的PBR材质
- en: On the left side of *Figure 14.3*, the reflectiveness of the environment is
    set to a high value, resulting in a golden sphere. Between the spheres, the reflection
    settings change gradually, and on the right side, no reflectiveness at all is
    set.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.3*的左侧，环境的反光性被设置为高值，结果产生了一个金色球体。在球体之间，反射设置逐渐变化，在右侧则完全没有设置反光性。
- en: A link to the source code of the PBR rendering and other examples is available
    in the *Additional resources* section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: PBR渲染和其他示例的源代码链接可在*附加资源*部分找到。
- en: Adding transparency
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加透明度
- en: A virtual world without windows and objects made of transparent materials may
    feel a bit strange since we are surrounded by transparent objects in the real
    world. However, rendering transparency is tricky due to the physics behind the
    color changes of the light on the path through more than one transparent object,
    requiring multiple transparent pixels on the same screen position to be drawn
    from back to front to calculate the correct final color for a pixel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们周围充满了透明物体，因此一个没有窗户和由透明材料制成的物体的虚拟世界可能会感觉有点奇怪。然而，由于光线在通过多个透明物体时颜色变化背后的物理原理，渲染透明度是复杂的。这需要在同一屏幕位置从后向前绘制多个透明像素，以计算像素的正确最终颜色。
- en: Two different approaches exist, called ordered and order-independent transparency.
    While ordered transparency requires all transparent objects to be sorted from
    back to front, order-independent transparency rearranges the pixels to be drawn
    by itself into the correct order. Both methods have advantages and disadvantages,
    so the best way to choose is to test both versions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种不同的方法，称为有序透明度和无序透明度。有序透明度要求所有透明物体从后向前排序，而无序透明度会自动重新排列要绘制的像素以进入正确的顺序。两种方法都有优缺点，因此最好的选择是测试两种版本。
- en: '*Figure 14.4* shows two transparency examples from LearnOpenGL ([https://learnopengl.com/](https://learnopengl.com/))
    by Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.4*展示了LearnOpenGL（[https://learnopengl.com/](https://learnopengl.com/)）中Joey
    de Vries（[https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)）提供的两个透明度示例：'
- en: '![](img/figure_14_04.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4](img/figure_14_04.png)'
- en: 'Figure 14.4: Transparent plants (left) and translucent red glass (right)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：透明植物（左侧）和半透明红色玻璃（右侧）
- en: On the left side of *Figure 14.4*, partially transparent plants are rendered.
    By discarding pixels in the empty areas of the texture, a realistic effect of
    a plant can be achieved. On the right side of *Figure 14.4*, colored glass is
    rendered. Imitating glass for windows and other translucent objects by using transparent
    textures helps to create a better copy of the real world.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.4*的左侧，展示了部分透明的植物。通过丢弃纹理中的空白区域像素，可以实现对植物的逼真渲染。在*图14.4*的右侧，渲染了彩色玻璃。通过使用透明纹理来模仿窗户和其他半透明物体，有助于创建更逼真的现实世界复制品。
- en: Looking up at a beautiful sky
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仰望美丽的天空
- en: If you start the virtual world created with the example code of the book and
    load a level that is partially made to be outside of a building, you will not
    see some sort of sky but just the default background color. Adding a beautiful
    sky to the scene requires not just a simple sky texture, but also a so-called
    cubemap and a distorted sky texture.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动了使用本书示例代码创建的虚拟世界，并加载一个部分设计在建筑之外的关卡，你将看不到某种天空，而只是默认的背景颜色。向场景添加美丽的天空不仅需要简单的天空纹理，还需要所谓的立方体贴图和扭曲的天空纹理。
- en: A cubemap is a special kind of rendering object that represents the six sides
    of a cube, and the sky texture is projected onto the cubemap. The resulting skybox
    will create a seamless background that follows the view of the virtual camera,
    placing the level geometry and the instances into a realistic environment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图是一种特殊的渲染对象，它表示立方体的六个面，天空纹理被投影到立方体贴图上。生成的天空盒将创建一个无缝的背景，跟随虚拟摄像机的视角，将关卡几何体和实例放置在逼真的环境中。
- en: '*Figure 14.5* shows a skybox as environment around a wooden box, created with
    code from LearnOpenGL ([https://learnopengl.com/](https://learnopengl.com/)) by
    Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.5*展示了由Joey de Vries使用LearnOpenGL（[https://learnopengl.com/](https://learnopengl.com/)）代码创建的木箱周围的天空盒环境，[Joey
    de Vries](https://x.com/JoeyDeVriez)：'
- en: '![](img/figure_14_05.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5](img/figure_14_05.png)'
- en: 'Figure 14.5: A wooden box with a skybox as the background'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：以天空盒为背景的木箱
- en: The effect of using a skybox can be seen best when moving the view around. In
    a static picture like in *Figure 14.5*, the difference between the wooden box
    and the skybox can be seen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动视图时，可以看到使用天空盒的效果。在静态图片如*图14.5*中，可以看到木质盒子与天空盒之间的区别。
- en: We will implement a skybox to our virtual world at the end of this section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节结束时在我们的虚拟世界中实现一个天空盒。
- en: Playing with light and shadows
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转光与阴影
- en: The current vertex shaders are using a hard-coded light source as virtual sun,
    emitting white light from a fixed position into the world. This basic lighting
    helps to identify the dimensions of the level geometry and the instances, even
    by using only flat shading. By adding more lights to the virtual world, other
    light-emitting objects can be modeled in a more realistic way, such as lamps,
    lanterns, fire, or torches. The flickering light of a fire in a dark place can
    be used to create various kinds of tension since it could mean a safe place to
    stay the night or an enemy position.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的顶点着色器正在使用一个硬编码的光源作为虚拟太阳，从固定位置向世界发射白光。这种基本照明有助于识别关卡几何形状和实例的尺寸，即使只使用平面着色也能做到。通过向虚拟世界添加更多灯光，可以以更逼真的方式模拟其他发光物体，例如灯具、灯笼、火焰或火炬。在黑暗的地方，火焰的闪烁灯光可以用来创造各种类型的紧张感，因为它可能意味着一个可以过夜的安心地方或敌人的位置。
- en: 'The scene in *Figure 14.6* is illuminated by several thousand different colored
    light sources:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.6*中的场景由几千种不同颜色的光源照亮：'
- en: '![](img/figure_14_06.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_14_06.png)'
- en: 'Figure 14.6: Multiple lights in a virtual world (image courtesy of Hannes Nevalainen)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：虚拟世界中的多光源（图片由汉内斯·内瓦莱宁提供）
- en: The image in *Figure 14.6* is a tech demo for the jMonkeyEngine made by Hannes
    Nevalainen, and the effect of many individual lights can be seen. The full video
    is available in the *Additional resources* section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.6*中的图像是由汉内斯·内瓦莱宁制作的jMonkeyEngine技术演示，可以看到许多单独灯光的效果。完整的视频可在*附加资源*部分查看。'
- en: When lights are added, shadows should be implemented too. For a simple start,
    the shadows of the objects cast by the virtual sun could be projected to the ground
    by using the so-called shadow mapping, creating the impression of lights and shadows
    taken from the real world. Shadows for the other lights can be added too, although
    the implementation is more complex. But the visual results will compensate for
    the effort as a lamp casting only the lit part of a window to the ground will
    bring a big smile to the programmer’s face.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加灯光时，也应该实现阴影。作为一个简单的开始，可以通过所谓的阴影映射将虚拟太阳投射出的物体阴影投影到地面上，从而产生从现实世界获取的光影效果。也可以为其他灯光添加阴影，尽管实现起来更复杂。但视觉效果将弥补这种努力，因为只有将窗户的亮部投射到地面的灯会为程序员带来大大的微笑。
- en: '*Figure 14.7* was created from the Vulkan example code made by Sascha Willens
    (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)),
    showing the shadows of trees created by using cascaded shadow maps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.7*是由萨沙·威尔伦斯制作的Vulkan示例代码创建的，代码可在[https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)找到)，展示了使用级联阴影映射创建的树木阴影：'
- en: '![](img/figure_14_07.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_14_07.png)'
- en: 'Figure 14.7: Cascaded shadow maps of trees'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：树木的级联阴影映射
- en: Similar to the skybox, the effect of using shadow maps can be seen much better
    when light, objects, and/or cameras are moving. Shadows like in *Figure 14.7*
    are a great addition to the virtual world.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与天空盒类似，当光、物体和/或相机移动时，使用阴影映射的效果可以看得更清楚。如图14.7所示的阴影是虚拟世界的一个很好的补充。
- en: Swimming in realistic water
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在逼真的水中游泳
- en: If water was added as part of the extended level environment, the visual appearance
    should also be checked and enhanced. While using a simple, static transparent
    water texture may be fine for the first implementation, the urge to create better
    water may come up at some point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将水作为扩展关卡环境的一部分添加，也应该检查并增强其视觉外观。虽然使用简单的静态透明水纹理可能对第一次实现来说足够好，但最终可能会产生创建更好水的需求。
- en: By using a combination of reflection, refraction, and distortion of the light
    hitting the virtual water surface, realistic water can be created, and if the
    player should be able to dive into the water, a different kind of distortion could
    be utilized to create the illusion of being underwater.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用反射、折射和虚拟水面受到的光线扭曲的组合，可以创建逼真的水，如果玩家应该能够潜入水中，可以利用不同类型的扭曲来创造水下错觉。
- en: '*Figure 14.8* shows a water simulation made in WebGL by Evan Wallace (the code
    is available at [https://github.com/evanw/webgl-water/blob/master/index.html](https://github.com/evanw/webgl-water/blob/master/index.html)):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.8* 展示了由Evan Wallace（代码可在[https://github.com/evanw/webgl-water/blob/master/index.html](https://github.com/evanw/webgl-water/blob/master/index.html)获取）使用WebGL制作的水模拟：'
- en: '![](img/figure_14_08.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8](img/figure_14_08.png)'
- en: 'Figure 14.8: Realistic water with waves and underwater caustics (courtesy of
    Evan Wallace)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：带有波浪和水下全息图的逼真水（由Evan Wallace提供）
- en: In *Figure 14.8*, the waves of the sphere falling into the water can be seen.
    Also, the refraction of the walls created by the water and the refraction of the
    light on the bottom of the pool are clearly visible.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.8*中，可以看到球体落入水中的波浪。此外，水造成的墙壁折射和池底的光线折射都清晰可见。
- en: Adding stunning post-processing effects
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加令人惊叹的后处理效果
- en: 'For even more realism in the virtual world, post-processing effects can be
    added to the renderers. The list of possible effects is long, so here is just
    a brief list of ideas that can be implemented quite quickly while creating great
    visuals:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在虚拟世界中获得更多的现实主义，可以在渲染器中添加后处理效果。可能的效果列表很长，所以这里只简要列出了一些可以在创建出色视觉效果的同时快速实施的想法：
- en: Lens flares for the illusion of looking through a camera
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头光晕以模拟通过相机看的效果
- en: 'God rays: visible rays in haze when the direct view into the sun is blocked'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光束：当直接看到太阳被阻挡时，在雾中的可见光线
- en: Bloom effect simulating glowing objects
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟发光物体的光晕效果
- en: Motion blur blurring the image when the view is moved
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动模糊在视图移动时模糊图像
- en: Depth of field blurring the world around a sharp center
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 景深模糊使尖锐中心周围的场景模糊
- en: Screen Space Ambient Occlusion darkening gaps and edges
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕空间环境光遮蔽使缝隙和边缘变暗
- en: Screen Space Reflection, a cheap way to create reflective surfaces
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕空间反射，一种创建反射表面的廉价方法
- en: All these effects are created by using shaders and have different performance
    impacts. Nevertheless, even a bunch of the effects listed here will give the visual
    appearance a huge boost.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些效果都是通过使用着色器创建的，并且有不同的性能影响。尽管如此，即使这里列出的效果中的一小部分也会极大地提升视觉效果。
- en: '*Figure 14.9* shows two post-processing effects, Bloom and **Screen Space Ambient
    Occlusion** (**SSAO**). The Bloom effect was created with code from LearnOpenGL
    ([https://learnopengl.com/](https://learnopengl.com/)) by Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez))
    and the SSAO picture is made with code from Sascha Willems’ Vulkan examples (the
    code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.9*展示了两个后处理效果，光晕和**屏幕空间环境光遮蔽**（**SSAO**）。光晕效果是用Joey de Vries从LearnOpenGL（[https://learnopengl.com/](https://learnopengl.com/)）的代码创建的，SSAO图片是用Sascha
    Willems的Vulkan示例中的代码制作的（代码可在[https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)获取）：'
- en: '![](img/figure_14_09.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9](img/figure_14_09.png)'
- en: 'Figure 14.9: Bloom (left) and SSAO (right)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：光晕（左）和SSAO（右）
- en: On the left side of *Figure 14.9*, the Bloom effect is shown. The characteristic
    part of the Bloom effect is the halo effect around the light sources. For the
    green light source, the light even overlaps the top left edge of the wooden crate.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.9*的左侧，展示了光晕效果。光晕效果的特征是光源周围的光环效果。对于绿色光源，光线甚至重叠在木箱的左上角。
- en: 'On the right side of *Figure 14.9*, SSAO is shown. The SSAO effect may be subtle,
    but it is visible: look at the floor below the curtains on the right side of the
    white line. The shadow creates the illusion of a darker room behind the curtains.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.9*的右侧，展示了SSAO（屏幕空间环境光遮蔽）。SSAO效果可能很微妙，但它是可见的：看看白色线条右侧窗帘下面的地板。阴影创造出窗帘后面更暗房间的错觉。
- en: Upgrading to ray tracing
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级到光线追踪
- en: As the next step to realism, ray tracing can be added as an optional enhancement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向现实主义的下一步，可以添加光线追踪作为可选增强。
- en: Ray tracing uses virtual light rays emitted from the camera to compute the resulting
    pixel color by following the ray through the collisions with objects in the virtual
    world. Instead of just using the object color, the virtual ray is reflected by
    the physical rules and followed until the amount of light added falls below a
    threshold.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 光线追踪使用从相机发出的虚拟光线，通过追踪光线与虚拟世界中对象的碰撞来计算结果像素颜色。而不是仅仅使用对象颜色，虚拟光线遵循物理规则并跟随，直到添加的光量低于阈值。
- en: With ray tracing, effects like a global illumination of the world, causing dark
    areas to be lit by light being reflected from the objects, or realistic reflections
    could be achieved. Imagine running through a room full of mirrors and seeing your
    character multiple times, drawn in a correct physical way.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用光线追踪，可以实现诸如全局光照、由物体反射的光照亮暗区，或逼真的反射等效果。想象一下在满是镜子的房间里奔跑，看到你的角色多次以正确的方式绘制出来。
- en: '*Figure 14.10* shows a scene created by a ray tracing example from Sascha Willems
    Vulkan code (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.10*展示了由Sascha Willems的Vulkan代码中的光线追踪示例创建的场景（代码可在[https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)找到）：'
- en: '![](img/figure_14_10.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_14_10.png)'
- en: 'Figure 14.10: Real-time ray tracing scene'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：实时光线追踪场景
- en: The reflections on the floor, the spheres, and the teapot in *Figure 14.10*
    are calculated in real time by using ray tracing with the Vulkan API on an Nvidia
    RTX 4000 series GPU.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.10*中，地板、球体和茶壶上的反射是通过在Nvidia RTX 4000系列GPU上使用Vulkan API进行光线追踪实时计算的。
- en: The FPS counter was included to show how fast the current GPU generation is
    able to create ray tracing images. Only a few decades ago, a single frame of the
    same picture required several days to render.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了FPS计数器以显示当前GPU代绀创建光线追踪图像的速度。仅仅几十年前，同一张图片的一帧渲染就需要几天时间。
- en: Ray tracing should be optional
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 光线追踪应该是可选的
- en: Note that the calculations for ray tracing require lots of computing power and
    creating complex scenes in real time needs both a GPU and a graphics API that
    support ray tracing. Right now, only Vulkan and DirectX 12 are able to use the
    ray tracing capabilities of modern GPUs. You need to check the availability of
    hardware and software support before switching to a graphics pipeline with ray
    tracing enabled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，光线追踪的计算需要大量的计算能力，实时创建复杂场景需要GPU和支持光线追踪的图形API。目前，只有Vulkan和DirectX 12能够使用现代GPU的光线追踪功能。在切换到启用光线追踪的图形管线之前，需要检查硬件和软件支持的情况。
- en: Diving into virtual reality
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜入虚拟现实
- en: Even though virtual reality (VR) is still a small niche, implementing VR support
    can be a great step ahead for immersion. Being able not just to see the virtual
    world on a flat screen but to stand right in the middle of the world can become
    a memorable moment for a player. Using head tracking to move the virtual camera
    simultaneously to the head of the player and adding virtual hands for the VR controllers
    creates a lot of new opportunities for interaction.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管虚拟现实（VR）仍然是一个小众领域，但实现VR支持可以是一个向前迈出的一大步，以增强沉浸感。不仅能够看到虚拟世界在平面屏幕上，而且能够站在世界的正中央，这可以成为玩家难忘的时刻。使用头部追踪将虚拟摄像头同时移动到玩家的头部，并为VR控制器添加虚拟手，为交互创造了大量新机会。
- en: '*Figure 14.11* shows a scene from the Godot XR Tool Demo (the code is available
    at [https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template)):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.11*展示了Godot XR 工具演示中的一个场景（代码可在[https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template)找到）：'
- en: '![](img/figure_14_11.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_14_11.png)'
- en: 'Figure 14.11: Godot XR Tools Demo'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：Godot XR 工具演示
- en: The most notable detail of *Figure 14.11* is the two virtual hands. By using
    the integrated sensors of the Valve Index® controllers, not only the position
    of the controllers can be deduced in all 6 degrees of freedom, but also the individual
    fingers can be tracked to allow gestures or actions depending on the position
    of a finger.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.11*最引人注目的细节是两只虚拟手。通过使用Valve Index®控制器的集成传感器，不仅可以推断出控制器在所有6个自由度中的位置，还可以跟踪每个手指，以允许根据手指的位置进行手势或动作。'
- en: After the theoretical part of this section, we will now add a skybox to the
    application, acting as the global background.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的理沦部分之后，我们现在将向应用程序添加一个天空盒，作为全局背景。
- en: 'Hands-on: Adding a skybox to the virtual world'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践：将天空盒添加到虚拟世界
- en: A virtual sky is a great addition to a virtual world, especially above any open
    areas, as shown in *Figure 14.5*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟天空是虚拟世界的一个很好的补充，尤其是在任何开阔区域上方，如图14.5所示。
- en: Exploring the technical details
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索技术细节
- en: 'From the technical side, a skybox is drawn from a texture applied on the inside
    of a unit cube. *Figure 14.12* shows the cube and the coordinates around the virtual
    camera placed in the center of the cube:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，天空盒是从应用于单位立方体内部的纹理绘制的。图14.12显示了立方体和放置在立方体中心虚拟相机周围的坐标：
- en: '![](img/figure_14_12.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图14.12](img/figure_14_12.png)'
- en: 'Figure 14.12: The sampled area from the inside of a cubemap'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：从立方体贴图内部采样的区域
- en: In *Figure 14.1*2, the red area of the cube will be sampled to create the background
    of the current frame. Note that the area is wrapping around the corner of the
    cube, but that is nothing to worry about. Both graphics libraries take care of
    such edge cases (pun intended) and will sample the respective areas of the two
    affected cube sides.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在图14.1中，立方体的红色区域将被采样以创建当前帧的背景。请注意，该区域在立方体的角落处环绕，但这不是什么值得担心的事情。两个图形库都处理这类边缘情况（有意为之），并将采样两个受影响立方体贴图面的相应区域。
- en: 'The cubemap texture is usually stored as a set of six separate images or as
    a single image with the sides of the cube at specific locations in the image.
    *Figure 14.13* shows a skybox texture made by Jockum Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))
    in a commonly used format plus the cube faces:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图通常存储为六张单独的图像或作为一张单图，其中立方体的侧面位于图像中的特定位置。图14.13显示了由Jockum Skoglund（又名hipshot
    – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox)）制作的常见格式天空盒纹理以及立方体贴图面：
- en: '![](img/figure_14_13.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图14.13](img/figure_14_13.png)'
- en: 'Figure 14.13: A cubemap texture and the cube face of each picture'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：立方体贴图纹理和每张图片的立方体贴图面
- en: On the left side of *Figure 14.13*, an example cubemap texture for a skymap
    is shown. You will find many cubemap textures as this kind of cross. On the right
    side of *Figure 14.13*, the cube faces for each of the smaller sub-images of the
    cubemap texture are listed. Remember that OpenGL and Vulkan with an inverted viewport
    have the negative Z-axis pointing into the virtual world, hence `–Z` for the front
    image.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在图14.13左侧，显示了用于天空图的示例立方体贴图纹理。你将找到许多这种类型的交叉立方体贴图纹理。在图14.13右侧，列出了立方体贴图纹理中每个较小子图像的立方体贴图面。请记住，OpenGL和Vulkan使用反转视口时，负Z轴指向虚拟世界，因此前图像为`-Z`。
- en: 'Another noteworthy detail is the distortion of a cubemap image. Since the cubemap
    texture is applied to a cube but the virtual sky around us can be seen as a sphere,
    the pixels of a cubemap texture must be adjusted to appear as if the image was
    taken with a camera from inside a sphere. In *Figure 14.14*, the discrepancy between
    the projection inside a cube and inside a sphere is shown:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的细节是立方体贴图图像的畸变。由于立方体贴图纹理应用于立方体，但围绕我们的虚拟天空可以看作是一个球体，因此立方体贴图纹理的像素必须调整，以使其看起来像是从球体内部拍摄的图像。图14.14显示了立方体内部和球体内部的投影差异：
- en: '![](img/figure_14_14.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图14.14](img/figure_14_14.png)'
- en: 'Figure 14.14: Sampled point of a cube vs. the corrected projection of a sphere'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：立方体的采样点与球体校正投影的比较
- en: As you can see on the left side of *Figure 14.14*, the difference between a
    sample point taken from the cubemap and the position on the surface of the sphere
    gets larger the more we get near the edge of one side of the cubemap. On the right
    side of *Figure 14.14*, an area sampled from the cubemap and the required projection
    onto the surface of a sphere are highlighted as black bars. You can see that both
    the size and the angle of the areas differ. When building a cubemap texture for
    a skybox, a spherical distortion of the images for each of the cube faces must
    be applied to create a plausible sky.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如图14.14左侧所示，从立方体贴图取样的采样点与球体表面的位置差异随着我们接近立方体贴图一侧的边缘而增大。在图14.14右侧，从立方体贴图采样的区域和投影到球体表面的所需区域以黑色条带突出显示。你可以看到这两个区域的尺寸和角度都不同。在为天空盒构建立方体贴图纹理时，必须对每个立方体贴图面的图像应用球形畸变，以创建一个合理的天空。
- en: Implementing the skybox
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现天空盒
- en: 'Adding the skybox to the code needs only a few components:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将天空盒添加到代码中只需要几个组件：
- en: New vertex and mesh types
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的顶点和网格类型
- en: A new vertex buffer
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的顶点缓冲区
- en: A unit cube model containing the coordinates of the faces.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含面坐标的单位立方体模型。
- en: A new shader
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的着色器
- en: Loading a cubemap texture from a file
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中加载立方体贴图纹理
- en: 'We start with creating a new vertex type called `OGLSkyboxVertex` and a new
    mesh type called `OGLSkyboxMesh` in the `OGLRenderData.h` file in the `opengl`
    folder:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`opengl`文件夹中的`OGLRenderData.h`文件中创建一个新的顶点类型`OGLSkyboxVertex`和一个新的网格类型`OGLSkyboxMesh`：
- en: '[PRE36]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As always, for Vulkan, the two new `struct` elements must be added to the `VkRenderData.h`
    file in the `vulkan` folder. For all the details of the Vulkan implementation,
    check the renderer class file, `VkRenderer.cpp`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，必须将两个新的`struct`元素添加到`vulkan`文件夹中的`VkRenderData.h`文件中。有关Vulkan实现的详细信息，请查看渲染器类文件`VkRenderer.cpp`。
- en: 'While we could reuse the vertex buffer of the models, doing so would waste
    a lot of resources since the cube only needs the position data for the vertices.
    The new vertex buffer class called `SkyboxBuffer` uses only the `position` element
    of the new vertex, `struct` `OGLSkyboxVertex`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以重用模型的顶点缓冲区，但这样做会浪费大量资源，因为立方体只需要顶点的位置数据。新的顶点缓冲区类`SkyboxBuffer`仅使用新顶点的`position`元素，`struct`
    `OGLSkyboxVertex`：
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For the cube model, we create a class called `SkyboxModel` returning an `OGLSkyboxMesh`
    consisting of 36 vertices, using two triangles for each side. In all three axes,
    the model coordinates are either `1.0` or `-1.0`, defining a unit cube.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体模型，我们创建一个名为`SkyboxModel`的类，返回一个由36个顶点组成的`OGLSkyboxMesh`，每个侧面使用两个三角形。在所有三个轴上，模型坐标要么是`1.0`要么是`-1.0`，定义了一个单位立方体。
- en: 'The new vertex shader named `skybox.vert` outputs a `vec3` with 3-dimensional
    texture coordinates. We need 3-dimensional coordinates here since we are inside
    a cube:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 新的顶点着色器`skybox.vert`输出一个包含三维纹理坐标的`vec3`。在这里我们需要三维坐标，因为我们处于一个立方体内部：
- en: '[PRE38]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `main()` method of the vertex shader, we invert the projection matrix
    and transpose the view matrix first:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器的`main()`方法中，我们首先反转投影矩阵并转置视图矩阵：
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For the view matrix, we can use a cheaper transpose operation instead of taking
    the inverse matrix since we need to get rid of the translational part to stop
    the cube moving around with the camera.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图矩阵，我们可以使用更便宜的转置操作而不是取逆矩阵，因为我们需要去除平移部分以停止立方体随摄像机移动。
- en: 'By multiplying the inverse matrices with the incoming point positions of the
    cube, we calculate the texture coordinates in world space:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将逆矩阵与立方体的传入点位置相乘，我们计算世界空间中的纹理坐标：
- en: '[PRE40]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the texture coordinates to sample are from the inside of the cube, as shown
    in Figure *14.12*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要采样的纹理坐标来自立方体的内部，如图*14.12*所示。
- en: 'As the last step for the vertex shader, we set the GLSL-internal variable `gl_Position`
    to the incoming vertex position:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为顶点着色器的最后一步，我们将GLSL内部变量`gl_Position`设置为传入的顶点位置：
- en: '[PRE41]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By setting the `z` component of `gl_Position` to the value of the `w` component,
    we make sure to draw the pixels of the cubemap on the far-Z plane, creating a
    background that will not be overwritten by other pixels.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`gl_Position`的`z`分量设置为`w`分量的值，我们确保在远-Z平面上绘制立方体贴图的像素，从而创建一个不会被其他像素覆盖的背景。
- en: 'The new fragment shader, `skybox.frag`, uses the incoming texture coordinates
    to look up the texture data in the cubemap:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 新的片段着色器`skybox.frag`使用传入的纹理坐标在立方体贴图中查找纹理数据：
- en: '[PRE42]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please note that the type of the texture `tex` is a `samplerCube` and not a
    `sampler2D` like on the other fragment shaders.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，纹理`tex`的类型是`samplerCube`而不是其他片段着色器中的`sampler2D`。
- en: 'Loading the cubemap texture is done in the `Texture` class. In the new `loadCubemapTexture()`
    method, we load an image shown in *Figure 14.1*3 and extract the six images. And
    since the values of the values of the texture map side definitions are in ascending
    order, we can just use the first side definition `GL_TEXTURE_CUBE_MAP_POSITIVE_X`
    and add an integer value for the remaining sides to upload:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图纹理的加载在`Texture`类中完成。在新的`loadCubemapTexture()`方法中，我们加载如图*14.1*3所示的图像并提取六个图像。由于纹理映射侧面定义的值是按升序排列的，我们可以直接使用第一个侧面定义`GL_TEXTURE_CUBE_MAP_POSITIVE_X`并为剩余的侧面添加整数值以上传：
- en: '[PRE43]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For the full implementation of the cubemap texture loading, please check the
    details in the `Texture` class.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体贴图纹理加载的完整实现，请查看`Texture`类的详细信息。
- en: Drawing the skybox
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制天空盒
- en: 'Bringing the skybox to the screen is now done in two steps. First, we upload
    the unit cube model data to the vertex buffer in the `init()` method of the `OGLRenderer.cpp`
    renderer class file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 将天空盒显示在屏幕上现在分为两个步骤。首先，我们在`OGLRenderer.cpp`渲染类文件的`init()`方法中将单位立方体模型数据上传到顶点缓冲区：
- en: '[PRE44]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, before drawing the level data, we draw the skybox by using the new shader,
    binding the texture and drawing the cube from the vertex buffer:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在绘制级别数据之前，我们使用新的着色器绘制天空盒，绑定纹理并从顶点缓冲区绘制立方体：
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For Vulkan, we also upload the skybox model and the texture in the `init()`
    method of the `VkRenderData.cpp` file, bind the skybox pipeline, and draw the
    skybox model before the level data in the `draw()` method.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，我们也在`VkRenderData.cpp`文件的`init()`方法中上传天空盒模型和纹理，绑定天空盒管线，并在`draw()`方法中绘制级别数据之前绘制天空盒模型。
- en: 'For both OpenGL and Vulkan renderers, a simple change should be made when drawing
    the skybox as the first object: disabling the depth test function. Without the
    depth test, the skybox texture overwrites all values of the previous color buffer,
    acting as the global background for the remaining objects, such as level data
    and instances. And that’s all.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OpenGL和Vulkan渲染器，在绘制天空盒作为第一个对象时，应进行简单的更改：禁用深度测试功能。没有深度测试，天空盒纹理将覆盖先前颜色缓冲区中的所有值，作为剩余对象（如级别数据和实例）的全局背景。就这样。
- en: 'If everything was added correctly, the new and glorious sky above the level
    can be seen in *Figure 14.15* (the image is made from glTF level created by Zarudko
    ([https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)) using a texture created by Jockum
    Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))
    as the skybox):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切添加正确，可以在*图14.15*中看到级别上方的新鲜和壮丽的天空（该图像由Zarudko使用glTF级别创建，[https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)，使用Jockum
    Skoglund（又名hipshot）创建的纹理作为天空盒）：
- en: '![](img/figure_14_15.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_14_15.png)'
- en: 'Figure 14.15: Example level with an activated skybox'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：激活了天空盒的示例级别
- en: As you can see in *Figure 14.15*, the skybox brings a real-world feel to levels
    with open areas. And since the cube does not move when the view changes like the
    level data, the illusion of an infinitely distant sky is created.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图14.15*所示，天空盒为开放区域级别的场景带来了真实世界的感受。由于立方体在视图变化时不会像级别数据那样移动，因此创造了一种无限远的天空幻觉。
- en: But even with great graphics and cool sound effects and music, there’s room
    for improvement. The environment of the virtual world is still somehow static,
    so let’s add changes to the world itself.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有出色的图形和酷炫的声音效果和音乐，仍有改进的空间。虚拟世界的环境仍然有些静态，所以让我们给世界本身添加一些变化。
- en: Extending immersion with daytime and weather
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过白天和天气增强沉浸感
- en: Although they are natural phenomena in our lives, the cycle between day and
    night, weather effects, and different seasons are rarely used in computer games.
    But all these aspects can be a great boost for immersion in a game. Slight changes
    to the virtual world depending on an internal clock may help to create an environment
    that a player wants to stay in for a much longer time to experience the full cycle.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然昼夜交替、天气效果和不同季节在我们的生活中是自然现象，但在计算机游戏中这些方面很少被使用。但所有这些都可以极大地增强游戏的沉浸感。根据内部时钟对虚拟世界进行轻微的变化，可能有助于创造一个玩家愿意长时间停留以体验完整周期的环境。
- en: Adding a day/night cycle
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加白天/黑夜循环
- en: A day/night cycle adds some sort of familiarity to a game. Seeing the sun rise
    or enjoying a colorful sunset, watching the changes when running through the world
    around noon or late at night… every aspect will remind the player of being in
    a more realistic world. And if not only the light changes, but also other characters
    and animals react to the time of day, the immersion will become better and better.
    For instance, it may be good to see some animals only at night, and kids only
    in the morning, characters appearing at work at some time and leaving for a pub
    in the afternoon.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 白天/黑夜循环为游戏增添了一种熟悉感。看到太阳升起或欣赏绚丽的日落，观察中午或深夜周围世界的变换……每一个细节都会让玩家感觉自己身处一个更加真实的世界。如果不仅光线发生变化，其他角色和动物也会对一天中的时间做出反应，那么沉浸感会越来越好。例如，可能只在夜间看到某些动物，只在早晨看到孩子们，某些角色可能在某个时间出现在工作场所，下午则去酒吧。
- en: The in-game time could be running much faster than real time, reducing an entire
    day to a couple of minutes. Such a speedup can help if events that are frequently
    needed only occur at a specific time of the day.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的时间可能比真实时间快得多，将整整一天缩短为几分钟。这种加速可以帮助如果需要的事件只在一天中的特定时间发生。
- en: One of the most popular examples of the day/night cycle is Minecraft. A full
    day in Minecraft lasts 20 minutes by default, split into a 10-minute day and a
    10-minute night. And since the light level changes, enemy spawning and food and
    tree growing behave completely differently in the day and the night.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 白天/夜晚循环中最受欢迎的例子之一是 Minecraft。Minecraft 中的默认一天持续 20 分钟，分为 10 分钟的白天和 10 分钟的夜晚。由于光照水平的变化，敌人在白天和夜晚的生成、食物和树木的生长行为完全不同。
- en: '*Figure 14.16* shows the same spot in our application at noon and at night:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.16* 展示了我们的应用程序中午和夜晚的同一地点：'
- en: '![](img/figure_14_16.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.16](img/figure_14_16.png)'
- en: 'Figure 14.16: Day and night in the example code from *Chapter 14*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：示例代码中第 14 章的白天和夜晚
- en: As you can see in *Figure 14.16*, even a simple change in the overall brightness
    of the virtual world could make an enormous difference. And changing more properties
    of the world depending on the time of day will bring more immersion for the player.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *图 14.16* 中所见，虚拟世界的整体亮度的一个简单变化就能产生巨大的差异。根据一天中的时间改变世界的更多属性将为玩家带来更多的沉浸感。
- en: Allowing forward time travel
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许向前时间旅行
- en: 'When working with time, one fact should not be underestimated: the time waiting
    for an event to happen can be boring and passes slowly. Instead of keeping the
    player waiting for the entire day or night to pass, special “time travel” events
    could be added, such as sleeping through the night, or waiting at a fireplace
    to let the time pass, having the game fast-forwarding the in-game time.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理时间时，一个事实不应被低估：等待事件发生的时间可能会很无聊，而且过得很慢。与其让玩家等待一整天或整夜过去，不如添加特殊的“时间旅行”事件，例如整夜睡觉，或者在壁炉旁等待时间流逝，让游戏快进游戏时间。
- en: Playing in real time
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时游戏
- en: Thinking about the time in a game, the idea of synchronizing the time in the
    virtual world to the time of the real world can be an interesting option. Only
    a few games utilize such a feature. Also, solving tasks or quests may be more
    complicated if they are bound to a special time of the day. But being “now” in
    a game may be fun.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中思考时间，将虚拟世界中的时间与真实世界的时间同步的想法可以是一个有趣的选择。只有少数游戏利用了这样的功能。此外，如果任务或任务与一天中的特定时间绑定，解决它们可能会更加复杂。但在游戏中“现在”可能会很有趣。
- en: Worshipping the weather god
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 崇拜天气之神
- en: Not only may the time of day change the world, but weather changes can also
    greatly influence characters, animals, and the environment. During a thunderstorm,
    the best advice is to stay inside, heavy rain may be so loud that other sounds
    never reach the player’s ears, and fresh snow will also absorb noises. So, roaming
    around in various weather states can give entirely different impressions of the
    same world.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅白天的时间可以改变世界，天气的变化也可以极大地影响人物、动物和环境。在雷雨天气中，最好的建议是待在室内，大雨可能如此响亮，以至于其他声音永远不会传到玩家的耳朵里，而新鲜的白雪也会吸收噪音。因此，在不同的天气状态下漫游可以给同一个世界带来完全不同的印象。
- en: Environmental changes such as the addition of fog also change the perception
    of the virtual world.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变化，如雾的添加，也会改变虚拟世界的感知。
- en: '*Figure 14.17* shows different types of fog in our application:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14.17* 展示了我们应用程序中不同类型的雾：'
- en: '![](img/figure_14_17.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.17](img/figure_14_17.png)'
- en: 'Figure 14.17: The effect of fog in the example code from *Chapter 14*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：示例代码中第 14 章中雾的效果
- en: On the left side of *Figure 14.17*, the virtual world is completely without
    fog, showing a clear day. In the middle of *Figure 14.17*, heavy fog was added,
    causing the world to fade out after a short distance. Fog was used in several
    old games to hide the appearance and disappearance of objects due to rendering
    limitations in early game engines. Finally, on the right side of *Figure 14.17*,
    the light color was adjusted to a green tone, creating the illusion of toxic fog
    in the streets of the map.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 14.17* 的左侧，虚拟世界完全没有雾，显示了一个晴朗的白天。在 *图 14.17* 的中间，添加了浓雾，导致世界在短距离后变得模糊。在早期游戏引擎的渲染限制下，雾被用于隐藏由于渲染限制而出现的物体和消失的物体。最后，在
    *图 14.17* 的右侧，调整了光线的颜色，创造出地图街道上有毒雾的错觉。
- en: Listening to the oracle of seasons
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倾听季节的先知
- en: The next evolutionary step after a day/night cycle and weather would be the
    implementation of the four seasons. The rotation between Spring, Summer, Fall,
    and Winter is a great opportunity to bring even more reality into the virtual
    world as the actions of characters or the appearance of animals will change throughout
    the year.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在昼夜循环和天气之后，下一个进化步骤是实现四个季节。春、夏、秋、冬之间的旋转是带来更多现实感的绝佳机会，因为角色的行为或动物的外观将在一年中发生变化。
- en: Like the length of the in-game day, a virtual year should be shortened to a
    reasonable amount of real time, or a forward time travel functionality should
    be allowed if all tasks in the current season have been finished. Letting the
    player wait for no reason will kill their enthusiasm.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 就像游戏中的白天长度一样，一个虚拟年应该缩短到合理的时间量，或者如果当前季节的所有任务都已经完成，应该允许向前时间旅行功能。让玩家无理由地等待将会扼杀他们的热情。
- en: 'A good example of the changing world properties depending on the season is
    “Legend of Zelda: Oracle of Seasons” by Nintendo for the GameBoy Color. Despite
    the age of the game, the changes of the seasons have been implemented with great
    detail, allowing the player to enter some areas of the world only in specific
    seasons. For instance, rivers are only frozen in Winter and snow fields elevate
    the parts of the landscape, while only in Summer, flower tendrils enable Link
    to climb up walls.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一个根据季节变化世界属性的好例子是任天堂为GameBoy Color开发的《塞尔达传说：时之笛》。尽管游戏年代久远，但季节的变化已经以极大的细节实现，允许玩家仅在特定季节进入世界的某些区域。例如，河流在冬季会结冰，雪地会抬高景观的部分，而只有在夏季，花朵的卷须才能让林克攀爬墙壁。
- en: In “Stardew Valley” by Eric Barone, seasons are also a key element of the gameplay.
    Each of the four seasons influences different parts of the game, like crop growth.
    A season is 28 in-game days long, and by accelerating the time, an entire year
    in Stardew Valley elapses in 26 hours of in-game time.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eric Barone的《星露谷物语》中，季节也是游戏玩法的关键元素。每个季节都会影响游戏的不同部分，如作物生长。一个季节是28个游戏日，通过加速时间，星露谷的一年将在26个小时的游戏时间内流逝。
- en: For the application, we will create simple day/night light changes and fog as
    examples. Let’s start with day and night.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，我们将创建简单的昼夜光线变化和雾作为示例。让我们从昼夜变化开始。
- en: 'Hands-on: Adding day and night'
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亲身体验：添加昼夜变化
- en: Changing the light source’s color and position is easy. Most of the fragment
    shaders already contain a fixed light source definition to allow better visualizations
    of the instances and the level data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 改变光源的颜色和位置很容易。大多数片段着色器已经包含一个固定的光源定义，以便更好地可视化实例和关卡数据。
- en: Implementing light control
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现光线控制
- en: 'As the first step, we add two new variables called `lightPos` and `lightColor`
    to the `Matrices` `uniform` in all vertex and fragment shaders where `Matrices`
    exists:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们在所有存在`Matrices`的顶点和片段着色器中的`Matrices``uniform`中添加了两个新变量，分别称为`lightPos`和`lightColor`：
- en: '[PRE46]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In `lightPos`, we will hand over the current position of the light source, allowing
    us to simulate the position of the Sun or Moon in the virtual world, and in `lightColor`,
    we transport the color of the light source to the GPU, enabling us to simulate
    sunrise, noon, sunset, and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lightPos`中，我们将传递光源的当前位置，使我们能够模拟虚拟世界中太阳或月亮的位置，而在`lightColor`中，我们将光源的颜色传输到GPU，使我们能够模拟日出、正午、日落等。
- en: 'Since we defined the uniform buffer containing the view and projection matrix
    on the CPU to use `glm::mat4` as the data type, we must add the two `glm::vec4`
    vectors for the light position and color as the first two elements of a `glm::mat4`
    that will be uploaded to the GPU before drawing the frame:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在CPU上定义了包含视图和投影矩阵的统一缓冲区，并使用`glm::mat4`作为数据类型，我们必须添加两个`glm::vec4`向量作为`glm::mat4`的前两个元素，这些元素将在绘制帧之前上传到GPU：
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now all fragment shaders containing the light source definitions can be adjusted
    with a better light control for the surfaces.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有包含光源定义的片段着色器都可以通过更好的表面光线控制进行调整。
- en: 'We start the new shader code in the `main()` method by defining the ambient
    light level:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`方法中开始编写新的着色器代码，通过定义环境光级别来启动：
- en: '[PRE48]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The ambient light level is used to simulate the light scattering from other
    surfaces, enabling some sort of minimal lighting in the virtual world. By limiting
    the minimal ambient light, we also prevent the resulting picture from becoming
    pitch black.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光水平用于模拟来自其他表面的光散射，使虚拟世界中能够实现某种最小光照。通过限制最小环境光，我们还可以防止生成的图片变成漆黑一片。
- en: 'Next, we calculate the diffuse part by using the angle between the triangle
    normal and the direction of the light source:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用三角形法线与光源方向之间的角度来计算漫反射部分：
- en: '[PRE49]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The diffuse lighting of a surface changes with the angle between the surface
    and the light source. As the dot product of two normalized vectors equals the
    cosine of the angle between the two vectors, we can use the result of the `dot()`
    call directly as a multiplier of the light source color.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 表面的漫反射光照随着表面与光源之间角度的变化而变化。由于两个归一化向量的点积等于两个向量之间角度的余弦值，我们可以直接将`dot()`调用的结果用作光源颜色的乘数。
- en: 'As the last step for the fragment shader code changes, we add up ambient and
    diffuse light and multiply the resulting light value by texture data and vertex
    color:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 作为片段着色器代码更改的最后一步，我们将环境光和漫反射光照相加，并将结果光照值乘以纹理数据和顶点颜色：
- en: '[PRE50]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can now control the position and color of the light source from the application,
    and by sending a spherical position and a color, various times of the day can
    be simulated.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从应用程序中控制光源的位置和颜色，通过发送球面位置和颜色，可以模拟一天中的不同时间。
- en: Adding a UI control
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加UI控件
- en: 'To control the light values, a new UI section will be created, enabling fine-grained
    settings of all light-related values. *Figure 14.18* shows the new **Environment**
    section in the `UserInterface` class:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制光照值，将创建一个新的UI部分，允许对所有与光照相关的值进行精细设置。*图14.18*显示了`UserInterface`类中的新**环境**部分：
- en: '![](img/figure_14_18.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图14_18.png](img/figure_14_18.png)'
- en: 'Figure 14.18: UI controls for light parameters and skybox'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18：光参数和天空盒的UI控件
- en: By splitting the light angle into east/west and north/south, we can move the
    light around to any position of the virtual sky. The light intensity can be used
    to lower the overall brightness of the light without manually touching the color
    values.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将光照角度分为东西和南北，我们可以将光照移动到虚拟天空的任何位置。光照强度可以用来降低整体亮度，而无需手动调整颜色值。
- en: With the separate light color values, we can adjust the light to match the natural
    colors of the Sun or the Moon, at least within the limitations of the available
    color space, and by using a set of predefined color values, we can set the light
    color, intensity, and position immediately to a specific time of the day.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的光颜色值，我们可以调整光照以匹配太阳或月亮的自然颜色，至少在可用的颜色空间限制内，通过使用一组预定义的颜色值，我们可以立即将光照颜色、强度和位置设置为一天中的特定时间。
- en: '*Figure 14.19* shows three different light settings for the virtual world (this
    image is created using the map by Zarudko ([https://skfb.ly/6QYJw](https://skfb.ly/6QYJw))
    and the skybox image is by Jockum Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.19*显示了虚拟世界的三种不同光照设置（此图像使用Zarudko的地图创建[https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)，天空盒图像由Jockum
    Skoglund（又名hipshot）提供[https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox)）：'
- en: '![](img/figure_14_19.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图14_19.png](img/figure_14_19.png)'
- en: 'Figure 14.19: The virtual world in the morning, at noon, and in the evening'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19：早晨、中午和傍晚的虚拟世界
- en: You can see in *Figure 14.19* that just changing the color of the light source
    can create entirely different moods in the virtual world. Combined with the skybox
    from the *Enhancing visuals* section, you can already create truly immersive worlds.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*图14.19*中看到，只需改变光源的颜色，就可以在虚拟世界中创造出完全不同的氛围。结合*增强视觉效果*部分中的天空盒，您已经可以创建真正沉浸式的世界。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored ideas and tools to show how to upgrade the current
    animation editor to a small game engine with a built-in editor.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了想法和工具，展示了如何将当前的动画编辑器升级为一个具有内置编辑器的小型游戏引擎。
- en: First, we looked at a couple of audio libraries and when to play sound effects
    and music in a game. Sound effects and music are essential parts of the player’s
    experience, creating a basic form of immersion as the experience of the real world
    will be transferred to the virtual world.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们探讨了几个音频库以及何时在游戏中播放音效和音乐。音效和音乐是玩家体验的重要组成部分，它们创造了一种基本的沉浸感，因为现实世界的体验将被转移到虚拟世界中。
- en: Then, we explored visual enhancements to the graphics of the application. Extending
    the basic renderer with transparency, a skybox, dynamic lights and shadows, realistic
    water, and post-processing effects such as God rays and motion blur will bring
    the visuals to the next level. Even though it’s optional due to the limited target
    group, adding support for ray tracing and VR could become viable options as both
    features are a big step forward in terms of visual quality and immersion.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了应用程序图形的视觉增强。通过扩展基本渲染器以实现透明度、天空盒、动态光影、逼真的水面以及后处理效果，如上帝射线和运动模糊，将视觉提升到下一个水平。尽管由于目标群体有限，添加对光线追踪和VR的支持是可选的，但这两个功能在视觉质量和沉浸感方面都是一大步，因此可能成为可行的选项。
- en: As the last step, we explored a day/night cycle, weather, and seasons as elements
    to change the environment of the virtual world. Already, a simple cycle of a day
    adds a lot of interesting opportunities to the virtual world, such as only meeting
    computer-controlled characters or animals at a certain time of the day or enemies
    that only appear at night. Weather effects and seasons also multiply the options
    to change behavior depending on the current environment.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们探讨了日/夜循环、天气和季节作为改变虚拟世界环境元素。仅仅是一个简单的日循环就为虚拟世界增加了许多有趣的机会，例如在一天中的特定时间只遇到计算机控制的角色或动物，或者只在夜间出现的敌人。天气效果和季节也增加了根据当前环境改变行为的选择。
- en: So... what to do next? Well, that’s completely up to you!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 那么...接下来该做什么呢？嗯，这完全取决于你！
- en: You could start by learning how to use **Blender** to create your own animated
    characters, animals, objects, and levels. The created assets don’t have to be
    of the quality of recent games; even low-poly worlds are charming and have many
    fans. There are lots of books, tutorials, and videos available, handling many
    different art styles for virtual worlds.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从学习如何使用**Blender**来创建自己的动画角色、动物、物体和关卡开始。创建的资产不必达到最近游戏的品质；即使是低多边形世界也很迷人，并且拥有许多粉丝。有许多书籍、教程和视频可供选择，涵盖了虚拟世界中的许多不同艺术风格。
- en: What about adding more objects? Vehicles and animals would enrich the virtual
    world, and doors and buttons lead to a lot more ways to interact with the world.
    For better gravity, you might even add a physics engine to the application, enabling
    other cool features such as force distribution on collisions between objects.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 关于添加更多物体？车辆和动物将丰富虚拟世界，门和按钮将带来更多与世界互动的方式。为了更好的重力，你甚至可能需要向应用程序中添加物理引擎，使物体之间的碰撞产生力分布等酷炫功能。
- en: You might also explore the world by using a camera with orthogonal projection.
    Watching the player, other characters, and the environment in an isometric projection
    or only from the side could open new ways of expressing a story. Since both the
    isometric projection and the side view are only different views of the three-dimensional
    world, all options mentioned in this chapter also apply when using the orthogonal
    projection.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用具有正交投影的相机来探索世界。以等距投影或仅从侧面观察玩家、其他角色和环境可以开辟新的表达故事的方式。由于等距投影和侧面视图只是三维世界的不同视角，因此本章中提到的所有选项在使用正交投影时也适用。
- en: Another idea could be the creation of a storyline and quests for the player
    to handle. Forcing the player to move between various locations and interact with
    different characters to unlock more quests, items, or doors, or just to receive
    the next piece of the mental puzzle about a quest could engage the player to stay
    longer in your game.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法可能是为玩家创建故事情节和任务。强迫玩家在各个地点之间移动并与不同角色互动以解锁更多任务、物品或门，或者只是接收关于任务的心理谜题的下一部分，这可以让玩家在你的游戏中停留更长时间。
- en: Or you could dive into the networking part of SDL and create a small network
    server, allowing you to explore the virtual worlds with your friends. Roaming
    around the levels and solving quests as a team is satisfying and brings new complexity
    to the quest system since you may or may not allow the players to use their shared
    knowledge of a quest over a long distance.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以深入研究SDL的网络部分，创建一个小的网络服务器，让你能够与朋友一起探索虚拟世界。作为团队在各个关卡中漫游和解决任务既令人满意，也为任务系统带来了新的复杂性，因为你可以选择是否允许玩家在长距离内使用他们对任务的共同知识。
- en: 'But this is the most important next step: stay curious and experiment with
    the code.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是最重要的下一步：保持好奇心并尝试实验代码。
- en: Practical sessions
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'Here are some additions you could make to the code:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以添加到代码中的改进：
- en: Add a button to reload the music tracks from the asset folder.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个按钮从资源文件夹重新加载音乐音轨。
- en: A nice-to-have feature to dynamically add or remove tracks.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很棒的功能是动态添加或删除音轨。
- en: Add more sound effects for the instances.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为实例添加更多声音效果。
- en: You could map a sound clip to every action of the instances, creating more realistic
    effects when controlling the selected instance.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将声音剪辑映射到实例的每个动作，在控制所选实例时创建更逼真的效果。
- en: Play the step sound depending on the floor material.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据地板材质播放脚步声。
- en: Here, you need to load more than one pair of footstep sounds for walking and
    running. The appropriate sound effect could be chosen by using the mesh type of
    the ground triangle as the index into the footstep sounds.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要为行走和跑步加载多对脚步声。可以通过使用地面三角形的网格类型作为索引来选择合适的音效。
- en: Add sounds for nearby instances.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为附近的实例添加声音。
- en: The `SDL_mixer` library allows us to set the volume and balance per channel.
    Using the distance and angle of the surrounding instances can be used to calculate
    the effective volume and direction of the sounds.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_mixer`库允许我们为每个通道设置音量和平衡。可以使用周围实例的距离和角度来计算声音的有效音量和方向。'
- en: Play ambient sound at special places on the map.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图的特殊位置播放环境声音。
- en: Similar to the waypoint models, you could use small models as markers to play
    an ambient sound. And like the sounds for nearby instances, the volume and balance
    of the ambient sound can be adjusted to match the expectation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 与航点模型类似，你可以使用小型模型作为标记来播放环境声音。并且像附近实例的声音一样，环境声音的音量和平衡可以根据预期进行调整。
- en: Add markers for music changes.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为音乐变化添加标记。
- en: This task is closely related to the ambient sound. You could use models and/or
    nodes to switch the music when your controlled instance enters a specific area
    of the map or interacts with other instances.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务与环境声音密切相关。你可以使用模型和/或节点在控制实例进入地图的特定区域或与其他实例交互时切换音乐。
- en: Adjust level color and fog depending on the level location.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据关卡位置调整关卡颜色和雾气。
- en: Not only can the music be changed when roaming through the level; also, the
    light and fog settings can be adjusted. For instance, when entering a cave, the
    ambient light can be lowered and the fog density can be raised.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅在漫游关卡时可以更改音乐；还可以调整光线和雾气设置。例如，进入洞穴时，环境光线可以降低，雾密度可以增加。
- en: Additional resources
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'SDL: [https://www.libsdl.org](https://www.libsdl.org%0D%0A)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDL：[https://www.libsdl.org](https://www.libsdl.org%0D%0A)
- en: 'OpenAL Soft: [https://github.com/kcat/openal-soft](https://github.com/kcat/openal-soft%0D%0A)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAL Soft：[https://github.com/kcat/openal-soft](https://github.com/kcat/openal-soft%0D%0A)
- en: 'PortAudio: [https://www.portaudio.com](https://www.portaudio.com%0D%0A)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PortAudio：[https://www.portaudio.com](https://www.portaudio.com%0D%0A)
- en: 'FMOD: [https://www.fmod.com](https://www.fmod.com%0D%0A)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FMOD：[https://www.fmod.com](https://www.fmod.com%0D%0A)
- en: '*Game Physics Engine Development* by *Ian Millington*, published by *CRC Press*:
    ISBN 978-0123819765'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Ian Millington所著，CRC Press出版的《*游戏物理引擎开发*》：ISBN 978-0123819765
- en: '*Game Physics by David H. Eberly*, published by *Morgan Kaufmann*: ISBN 978-0123749031'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Morgan Kaufmann出版的David H. Eberly所著的《*游戏物理*》：ISBN 978-0123749031
- en: 'Open-source physics engine: [https://www.tapirgames.com/blog/open-source-physics-engines](https://www.tapirgames.com/blog/open-source-physics-engines%0D%0A)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源物理引擎：[https://www.tapirgames.com/blog/open-source-physics-engines](https://www.tapirgames.com/blog/open-source-physics_engines%0D%0A)
- en: 'Vulkan examples by Sascha Willems: [https://github.com/SaschaWillems/Vulkan](https://github.com/SaschaWillems/Vulkan%0D%0A)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sascha Willems的Vulkan示例：[https://github.com/SaschaWillems/Vulkan](https://github.com/SaschaWillems/Vulkan%0D%0A)
- en: 'Ordered transparency: [https://learnopengl.com/Advanced-OpenGL/Blending](https://learnopengl.com/Advanced-OpenGL/Blending%0D%0A)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序透明度：[https://learnopengl.com/Advanced-OpenGL/Blending](https://learnopengl.com/Advanced-OpenGL/Blending%0D%0A)
- en: 'Order-independent transparency: [https://github.com/nvpro-samples/vk_order_independent_transparency](https://github.com/nvpro-samples/vk_order_independent_transparency%0D%0A)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序透明度：[https://github.com/nvpro-samples/vk_order_independent_transparency](https://github.com/nvpro-samples/vk_order_independent_transparency%0D%0A)
- en: 'OpenGL skybox: [https://learnopengl.com/Advanced-OpenGL/Cubemaps](https://learnopengl.com/Advanced-OpenGL/Cubemaps%0D%0A)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL天空盒：[https://learnopengl.com/Advanced-OpenGL/Cubemaps](https://learnopengl.com/Advanced-OpenGL/Cubemaps%0D%0A)
- en: 'How to create cubemaps: [https://paulbourke.net/panorama/cubemaps/](https://paulbourke.net/panorama/cubemaps/%0D%0A)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建立方体贴图：[https://paulbourke.net/panorama/cubemaps/](https://paulbourke.net/panorama/cubemaps/%0D%0A)
- en: 'OpenGL multiple lights: [https://learnopengl.com/Lighting/Multiple-lights](https://learnopengl.com/Lighting/Multiple-lights%0D%0A)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL多光源：[https://learnopengl.com/Lighting/Multiple-lights](https://learnopengl.com/Lighting/Multiple-lights%0D%0A)
- en: 'Multiple lights demo by Hannes Nevalainen: [https://www.youtube.com/watch?v=vooznqE-XMM](https://www.youtube.com/watch?v=vooznqE-XMM%0D%0A)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汉斯·内瓦莱宁的多光源演示：[https://www.youtube.com/watch?v=vooznqE-XMM](https://www.youtube.com/watch?v=vooznqE-XMM%0D%0A)
- en: 'OpenGL shadow maps: [https://learnopengl.com/Guest-Articles/2021/CSM](https://learnopengl.com/Guest-Articles/2021/CSM)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL阴影贴图：[https://learnopengl.com/Guest-Articles/2021/CSM](https://learnopengl.com/Guest-Articles/2021/CSM)
- en: 'WebGL water simulation: [https://madebyevan.com/webgl-water/](https://madebyevan.com/webgl-water/%0D%0A)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL水模拟：[https://madebyevan.com/webgl-water/](https://madebyevan.com/webgl-water/%0D%0A)
- en: 'OpenGL realistic water: [https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe](https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe%0D%0A)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL真实水渲染：[https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe](https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe%0D%0A)
- en: 'OpenGL water caustics: [https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa](https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa%0D%0A)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL水衍射：[https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa](https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa%0D%0A)
- en: 'OpenGL lens flares: [https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html](https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html%0D%0A)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL镜头光晕：[https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html](https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html%0D%0A)
- en: 'OpenGL God rays: [https://github.com/math-araujo/screen-space-godrays](https://github.com/math-araujo/screen-space-godrays%0D%0A)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL上帝射线：[https://github.com/math-araujo/screen-space-godrays](https://github.com/math-araujo/screen-space-godrays%0D%0A)
- en: 'OpenGL bloom effect: [https://learnopengl.com/Advanced-Lighting/Bloom](https://learnopengl.com/Advanced-Lighting/Bloom%0D%0A)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL光晕效果：[https://learnopengl.com/Advanced-Lighting/Bloom](https://learnopengl.com/Advanced-Lighting/Bloom%0D%0A)
- en: 'OpenGL motion blur: [https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf](https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf%0D%0A)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL运动模糊：[https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf](https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf%0D%0A)
- en: 'OpenGL depth of field: [https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html](https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html%0D%0A)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL景深：[https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html](https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html%0D%0A)
- en: 'OpenGL SSAO: [https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html](https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html%0D%0A)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL SSAO：[https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html](https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html%0D%0A)
- en: 'OpenGL SSR: [https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html%0D%0A)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL SSR：[https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html%0D%0A)
- en: 'Vulkan raytracing: [https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/](https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/%0D%0A)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan光线追踪：[https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/](https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/%0D%0A)
- en: 'OpenXR: [https://www.khronos.org/openxr/](https://www.khronos.org/openxr/%0D%0A)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenXR：[https://www.khronos.org/openxr/](https://www.khronos.org/openxr/%0D%0A)
- en: 'Godot XR Demo template: [https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template%0D%0A)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Godot XR 演示模板：[https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template%0D%0A)
- en: 'Blender: [https://www.blender.org](https://www.blender.org%0D%0A)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender：[https://www.blender.org](https://www.blender.org%0D%0A)
- en: 'Open Game Art for assets: [https://opengameart.org/](https://opengameart.org/%0D%0A)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放游戏艺术资源：[https://opengameart.org/](https://opengameart.org/%0D%0A)
- en: Join our community on Discord
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation%0D%0A)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation%0D%0A)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码，AI生成的内容可能不正确。](img/QR_code_Discord.png)'
