- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Immersive Interactive Worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 14*! In the previous chapter, we added pathfinding and navigation
    to the instances. We started with a brief overview of navigation methods in computer
    games. Then we explored and implemented the A* algorithm to find a path between
    the instance position and a point in the virtual world. Next, we enhanced the
    models to serve as navigation targets and extended the instances to find a path
    to one of the targets. At the end of the chapter, we added the ability for an
    instance to follow the path and reach the desired target.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore different ideas to enhance the example code
    for more immersion and visual quality. We will look at the audible side for tools
    and methods to add sound effects and music to the application. Also, we will implement
    a simple audio manager class to play sounds and background music. To please not
    just the ears but also the eyes, we will collect some ideas about how to enhance
    the visual appearance next and implement two of the graphical enhancements to
    the application. We will end the book with this chapter by looking at the effects
    of daytime and weather changes on the virtual world and add a basic day/night
    cycle to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects and background music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing visuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending immersion with daytime and weather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter is available in the `chapter14` folder: the
    `01_opengl_ideas` subfolder for OpenGL and the `02_vulkan_ideas` subfolder for
    Vulkan.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects and background music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the example code from [*Chapter 13*](Chapter_13.xhtml) provides a lot
    of features, such as face animations, level loading, collision detection, and
    pathfinding and navigation. But sadly, all the animations on the screen are running
    in dead silence. No bleeping or beeping, no sound, and no music. Just silence.
  prefs: []
  type: TYPE_NORMAL
- en: But sound and music are an important part of games for very good reasons. Whether
    you are enjoying the calm meadows or deep caves of Minecraft, grooving to the
    happy music of one of the Super Mario titles and hearing the sound effects as
    acoustic feedback of our actions, prefer roaming through the haunting worlds of
    the Dead Space or Silent Hill series while listening carefully to the environment
    sounds to be aware of your surroundings, or driving cars to the pumping music
    and fat sounds of racing games such as the Need for Speed series – without music
    and sound, games wouldn’t deliver the same experience for the player.
  prefs: []
  type: TYPE_NORMAL
- en: To add sound output, we can include a freely available sound library, allowing
    us to easily play sound effects or music. Let’s look at some of the libraries
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Using an audio library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most audio libraries are written in C, but bindings for C++ can be found, encapsulating
    the operating-system-specific low-level function calls in an object-oriented manner.
    Just using the C functions and building a custom abstraction is also possible,
    similar to GLFW, OpenGL, and Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Simple DirectMedia Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simple DirectMedia Layer** (**SDL**) is a cross-platform library for multimedia
    hardware components of a computer. SDL manages audio and can serve as a framework
    for window functions, graphics context, and input handling, like GLFW. In addition,
    there are several official libraries that provide support for importing and exporting
    images, custom networking, and font rendering to display text on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenAL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**OpenAL** is a cross-platform library that focuses on multi-channel, three-dimensional
    audio. By using 3D audio, the sound can be modeled to be in front of or behind
    the player, not just to the left or right, deepening the immersion.'
  prefs: []
  type: TYPE_NORMAL
- en: PortAudio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PortAudio** is another cross-platform audio library. It targets real-time
    audio playback and recording. PortAudio can be used if the scope of SDL and OpenAL
    is too large for the project, and the goal is to just have some audio playing.'
  prefs: []
  type: TYPE_NORMAL
- en: FMOD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although **FMOD** is a proprietary sound engine, it can be included in the list
    of freely available libraries as a non-commercial license exists, allowing us
    to use FMOD for free. A paid FMOD license is only needed if the final application
    or game will be distributed commercially. FMOD supports 3D engines such as Unreal
    and Unity, so you might even get in touch with FMOD if you are working on a game
    at some point in time.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring *which software* for sound and music replay could be included,
    let’s check out *what* could and should be played.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since sound plays a key role in our lives, we will have some expectations of
    what we should hear in a game or a simulation. Failing to meet these expectations
    may harm immersion.
  prefs: []
  type: TYPE_NORMAL
- en: The game character’s footsteps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably the most important sound effects a player wants to hear are the footsteps
    of the character on the ground. By adjusting the sound in relation to the ground
    material and the speed of the character, instant feedback about the environment
    is delivered to the player. There is a significant difference between silently
    sneaking through grass or running on metal ground, and the player should be made
    aware of the “loudness” of the character’s actions, and by using collision detection
    and ground triangle discovery, as described in the *Finding ground triangles in
    level data* section of [*Chapter 12*](Chapter_12.xhtml)*,* the material type of
    the ground triangle can be found easily.
  prefs: []
  type: TYPE_NORMAL
- en: Other character sounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The character makes a lot more sounds, not just footsteps. Jumping and landing,
    climbing a ladder, swimming, or being hurt by an enemy character should also give
    audible feedback to the player for additional information about what happens with
    the character in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Local sound sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not only does the player-controlled character need sound effects, but also for
    the computer-controlled characters and inanimate objects in the virtual worlds
    audio effects should be played. Hearing doors opening and closing, the hammering
    of a blacksmith, or the call of a bird, and listening to the crackles of fireplaces,
    the sound of a waterfall, or wind in a high place in the world will intensify
    immersion greatly.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient sounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ambient sounds are a mix of different sounds and frequencies coming from locations
    far away, losing some of their information on the way to the listener. A large
    group of people, the wind in a forest, or a street some meters away all produce
    well-known sounds for us that should be added to corresponding places of the virtual
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Weather effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the world includes some kind of weather system, the sounds and effects should
    be added too. A distant thunderstorm or the silence of the ground after a snowfall
    can change the perception of the virtual world by the player.
  prefs: []
  type: TYPE_NORMAL
- en: But not only can sound effects be useful for immersion; playing music can also
    help to keep a player’s attention.
  prefs: []
  type: TYPE_NORMAL
- en: Playing music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the early days of computer games, music has been added to games to keep
    players interested. As a result, we may still remember the music of a game when
    we see the title but not details of the gameplay or the game’s characters.
  prefs: []
  type: TYPE_NORMAL
- en: Menu music
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first screen a player will see when starting the application is most probably
    some kind of main menu. Throwing a player directly into the action, without being
    able to configure the controls for the virtual character, the visual quality,
    or the sound volume first, may not be the best idea. While the player explores
    the options in the menu, music can help to prevent the player from getting lost
    or bored straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient music
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to ambient sounds, ambient music helps to prevent dead silence in a
    game. Playing no sounds at all may be intended to build up tension, but running
    for hours and hours in silence through a game can become boring. Adding a music
    track with a style and tempo that fits the gameplay helps the player to enjoy
    even slow passages of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive music play
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the player moves into a different area in an open world or enters an environment
    with a different style, or another room, changing the music to match the new place
    is a good idea. The famous “hearing boss music” moment when entering a room, combined
    with the sound of doors locking, will create unforgettable moments for a player.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing custom music
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting option for music selection is to let the player add local music
    to the list of tracks played in the game or even replace the music entirely. Seeing
    the game’s character exploring a virtual world while listening to some favorite
    music tracks may be a plus for players.
  prefs: []
  type: TYPE_NORMAL
- en: To experience the difference audio replay can make, we will add a C++ class
    to manage sound effects and music replay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hands-on: Implementing an audio manager'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The audio manager class consists of two distinct parts. On one hand, we need
    a high-level interface between the audio manager and the renderer and other classes.
    On the other hand, the encapsulated low-level interface linking the audio manager
    functionality to the audio library of the operating system would allow us to replace
    the audio library with another variant.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a brief overview of the high-level interface and dive into
    the low-level implementation afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the high-level interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new `AudioManager` class, consisting of the `AudioManager.h` header file
    and the `AudioManager.cpp` implementation file will be added to the `tools` folder.
    We will add the basic functions a usual music/sound player should have:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and cleaning up the audio library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading music tracks from files on the file system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading sound effects from files on the file system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing and stopping music and sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing, resuming, and skipping the music tracks to the next and previous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving, shuffling, and clearing the current playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the volume of music and sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, the `public` `setMusicVolume()` and `getMusicVolume()` methods
    are added to the `AudioManager` class to control the music volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the `private` member variable named `mMusicVolume` is used to
    store the current volume of the music:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the remaining functionalities in the list of functions, `public` methods
    and `private` member variables are created. Check the `AudioManager.h` file to
    see the full number of methods and member variables that are available in the
    `AudioManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now we must add a member variable for an object of the `AudioManager` class
    along with the initialization and cleanup calls of the audio functionality to
    the application code. To keep the renderer for the video part only, the `AudioManager`
    member variable and methods will be added to the `Window` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the AudioManager class to the Window class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The two primary steps to add the audio functions to the `Window` class are
    the same as for all other classes: including the `AudioManager.h` header file
    at the top of the `Window.h` header file and declaring the `private` member variable
    named `mAudioManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `init()` method of the `Window` class in the `Window.cpp` file,
    we try to initialize the `AudioManager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `Logger` class to print an error message, but we *do not*
    end the window initialization if the `AudioManager` initialization fails. Audio
    replay should be kept optional, and we continue without music and sound replay
    instead of failing the application startup process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the music tracks into the `AudioManager` can be done right after the
    initialization call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are trying to load all MP3 files in the `assets/music` folder into
    the `AudioManager` if the initialization is successful. Again, we don’t fail if
    no music files are found in the asset folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding music tracks to the playlist
  prefs: []
  type: TYPE_NORMAL
- en: In the `AudioManager` class, support for loading MP3 and OGG files from the
    local folder `assets/music` into a playlist has been implemented. You can add
    your own music to the `assets/music` folder as the playlist will be populated
    when the application is started. In the *Practical sessions* section, a task is
    available to add a **Refresh** button to the UI, allowing you to add or remove
    music tracks at application runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to clean up the `AudioManager` when shutting down the application.
    So, we add a call to the `cleanup()` method of `AudioManager` to the `cleanup()`
    method of the `Window` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since we created the `AudioManager` in the `Window` class, we need to create
    callback functions to access the music and sound-effect functions from the renderer
    or the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks to make the AudioManager class available everywhere
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By using these callback functions, changing the music track or playing footstep
    sounds can be done from anywhere in the code. As an example, we will use the functionality
    to play a specific music track here, given the track name as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the function signature for the callback named `playMusicTitleCallback`
    to the `Callbacks.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a variable named `micPlayMusicTitleCallbackFunction` to the
    `ModelInstanceCamData` `struct` in the `ModelInstanceCamData.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use the `ModelInstanceCamData` `struct` to avoid spreading the callback functions
    all over the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the callback variable will be bound to the corresponding `AudioManager`
    function in the `init()` method of the `Window` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get a reference to the variable containing the `ModelInstanceCamData`
    `struct` of the renderer class and assign the `playTitle()` method of the `AudioManager`
    class by using a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: The same three steps of creating the callback function signature, adding a variable
    to the `ModelInstanceCamData` `struct`, and binding the callback function to the
    method of the `AudioManger` class must be repeated for every audio method that
    should be available in the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the implementation of the low-level part of the audio manager.
    We will use SDL as the audio functions are easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using SDL for the low-level layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although SDL can handle more features than audio, it is possible to use only
    a subset of the functions provided by the SDL library. So, instead of using SDL
    for window and keyboard handling, which is done by GLFW in the application, we
    will only use the sound replay and mix functionality of SDL.
  prefs: []
  type: TYPE_NORMAL
- en: To use audio replay with SDL, we need the core SDL library plus the separate
    mixer library named `SDL_mixer`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL and SDL_mixer on Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For Windows, precompiled versions of SDL and `SDL_mixer` are available on GitHub.
    Go to the releases page at the following two URLs and download the latest stable
    development zip files for Visual Studio, containing both `devel` and `VC` in their
    names. As an example, the current development package of the main SDL library
    for Visual Studio is named `SDL2-devel-2.30.9-VC.zip`. Here are the URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SDL: [https://github.com/libsdl-org/SDL/releases](https://github.com/libsdl-org/SDL/releases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL_mixer`: [https://github.com/libsdl-org/SDL_mixer/releases](https://github.com/libsdl-org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, unpack the two zip files to your computer, but take care to avoid spaces
    and special characters like German umlauts in the path names to avoid problems
    since even in 2024 many tools have still problems with special characters in the
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add two **environment variables** to help the CMake search scripts find
    the headers and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: The first variable is named `SDL2DIR` and must point to the folder where the
    main SDL library was unpacked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second variable is named `SDL2MIXERDIR` and must point to the folder of
    the `SDL_mixer` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 14.1* shows an example of the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Example environment variables for SDL'
  prefs: []
  type: TYPE_NORMAL
- en: After installing the two libraries and adding the environment variables, the
    code for this chapter can be compiled. The CMake build script takes care of placing
    the two DLL files next to the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL and SDL_mixer on Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, the SDL libraries can be added by using the integrated package management.
    On Ubuntu or Debian, you can use the `apt` package manager to install the main
    SDL library, the `SDL_mixer` library, and all development headers and libraries
    by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For an Arch-based distribution, use the `pacman` package manager to add the
    two libraries to the system with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To add SDL and `SDL_mixer` to the `AudioManager` class in order to use the
    SDL functions, we must include the two SDL headers after the existing `#include`
    directives in the `AudioManager.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since SDL is a C library, all structures only use raw pointers. The audio manager
    is one of the places where you will find variables with raw pointers in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `mMusicTitles` variable is a map containing several SDL music objects, which
    are accessible by the name of the track as the key for the map. Every track is
    saved in a variable named `Mix_Music`, where the prefix Mix states that this is
    a variable used by the `SDL_mixer` library.
  prefs: []
  type: TYPE_NORMAL
- en: In the `mWalkFootsteps` variable, a so-called chunk of audio (using the terms
    of SDL) is stored. An `SDL_mixer` chunk can be played by calling the respective
    sound effect’s replay function.
  prefs: []
  type: TYPE_NORMAL
- en: Before sound effects or music can be played, the audio part of SDL must be initialized
    properly, and at the end of the application, the audio functions must be ended
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and shutting down SDL and the SDL_mixer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the first step in the `init()` method of the `AudioManager` class, we try
    to initialize the audio part of SDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `SDL` prefix of both `SDL_Init()` and the `SDL_INIT_AUDIO` flag denotes
    that we are using the core functionality of SDL. If we cannot initialize the audio
    part of SDL, we stop the initialization of the `AudioManager` right here. Beware
    that the initialization of the audio device can fail for various reasons, for
    instance, if the audio device is in use by another application that forbids sharing
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we try to set the parameters for the audio device by calling `Mix_OpenAudio()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are in the realm of `SDL_mixer`, which is visible on the `Mix` prefix
    of `Mix_OpenAudio`. The first parameter of `Mix_OpenAudio` is the replay frequency
    in Hz. We are using the well-known value of 44.1 kHz, introduced by Sony’s **compact
    disc** specifications. As the second parameter, the internal audio format is configured.
    `MIX_DEFAULT_FORMAT` stands for 16-bit signed integer values, which is also a
    common value in the audio world.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is the number of output channels to use. One output channel
    uses mono replay, and the two channels from the initialization call are for stereo
    output. Depending on the audio hardware and driver support, up to eight output
    channels for a 7.1 system are possible.
  prefs: []
  type: TYPE_NORMAL
- en: With the fourth and last parameter, an internal audio buffer in the `SDL_mixer`
    library is configured. A small buffer value may cause audio dropouts if the CPU
    load gets too high while filling the buffer, and a large buffer leads to delays
    since the buffer needs to be filled before the samples can be played. The unit
    of the buffer parameter is “sample frames,” so we configure `SDL_mixer` to reserve
    space for 2,048 frames, every frame contains two 16-bit signed integers, one for
    every output channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the termination time of the application, the `cleanup()` method of the `AudioManager`
    is called by the `cleanup()` method of the `Window` class. Inside the `cleanup()`
    method of the `AudioManager` class, we close the audio device and signal both
    `SDL_mixer` and SDL to run their respective cleanup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that we did not call `Mix_Init()` in the `init()` method, but we have to
    call `Mix_Quit()` here. SDL manages the mixer initialization for us without an
    explicit call to `Mix_Init()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to play music and sound effects. Let’s start with a look at
    the music replay code.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling music replay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loading a music track is done by calling `Mix_LoadMUS()` with the C-style character
    array as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`SDL_mixer` supports several music formats, such as WAV, MP3, and OGG. The
    return value of `Mix_LoadMUS()` is a pointer to the `Mix_Music` `struct`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean up a loaded music track, `Mix_FreeMusic()` must be called with the
    pointer to the above `Mix_Music` `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A music track can be played by calling `Mix_PlayMusic()` with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is a pointer to a valid `Mix_Music` `struct`, while the
    second parameter tells `SDL_mixer` the number of loops to play. A loop value of
    `0` disables looping and a value of `-1` will loop the music infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stopping the music is done by calling `Mix_HaltMusic()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is only one music track playing at a time, no parameters are needed,
    and in case the current track should be paused or resumed, the two `Mix_PauseMusic()`
    and `Mix_ResumeMusic()` calls are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the music volume is controlled by `Mix_VolumeMusic()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The parameter for `Mix_VolumeMusic()` is an `int` value between `0` and `128`
    to set the new volume, or a value of `-1` to query the current volume of the music.
  prefs: []
  type: TYPE_NORMAL
- en: By using the default `SDL_mixer` calls, we can only play one music track once
    or with an infinite number of loops. If a dynamic music system is required, a
    manual implementation is needed, or even a different sound replay API should be
    considered. For the simple ability to advance to the next track in a playlist
    at the end of a track, we just need to implement a callback.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a callback for continuous music playback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SDL_mixer` supports a callback to inform the application that the current
    music track has finished the number of loops. In this callback, we can simply
    forward to the next track in the playlist.'
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, `SDL_mixer` is a C audio library, and the callback must fulfill the C-style
    calling convention. The C++ calling convention is not compatible with the C calling
    convention and allows only calling static member functions of the `AudioManager`
    class. We need to add a small hack to be able to call a non-static method of the
    `AudioManager` class that has access to the playlist and the current position
    in the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare a raw pointer named `mCurrentManager` as `private` member
    variable, plus the `private` static `staticMuscFinishedCallback()` member method
    for the C-style callback and a `private` non-static member `musicFinishedCallback()`
    for the translated callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init()` method of the `AudioManager` class, we set the `mCurrentManager`
    pointer to the current instance and call the callback hook setup method `Mix_HookMusicFinished()`
    with the static callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a music track ends now, `staticMusicFinishedCallback()` is called
    by `SDL_mixer`. To translate the callback to C++, we use the pointer to the current
    `AudioManager` instance stored in `mCurrentManager` to call the non-static callback
    `musicFinishedCallback()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `musicFinishedCallback()`, we can now add code to advance one track
    in the playlist, enabling a continuous replay of all tracks in the playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After the music replay is implemented, let’s go to the sound effect replay code.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sound effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `SDL_mixer` to play sound effects has some subtle differences compared
    to playing music. The main difference is that by default eight sound effects can
    be played at the same time since `SDL_mixer` allocates eight internal sound channels
    for the sound effect output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these internal sound channels are not the same as the two output sound
    channels configured when we initialized the audio device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allocating more or even less than these eight sound channels can be done by
    calling `Mix_AllocateChannels()` with the number of desired channels as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will use only one channel in the `AudioManager` for now to allow a simple
    implementation of the footstep sound replay.
  prefs: []
  type: TYPE_NORMAL
- en: As `SDL_mixer` has only one channel available now, a second sound effect cannot
    be played if another sound effect is still playing. So, by limiting the number
    of channels to only one, we can avoid creating a complex system to switch between
    walking and running footstep sounds for the example implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a sound file from the file system is similar to the music loading process.
    We call `Mix_LoadWav()` with the C-style character array of the file name and
    store the returned result in a `Mix_Chunk` `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Cleaning up the sound effect is done by calling `Mix_FreeChunk()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Playing and stopping the replay of a sound effect is also like playing or stopping
    the music. A sound effect will be played by using `Mix_PlayChannel()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of `Mix_PlayChannel()` is the sound channel to use. The
    special value of `-1` just uses the next available sound channel for the sound
    effect replay. The second parameter is a pointer to the `Mix_Chunk` `struct` to
    play, and the third parameter is again the number of loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the return parameter of `Mix_PlayChannel()`, we get the sound channel number,
    on which this sound effect is played. We save the channel number in the `mSoundChannel`
    member variable to be able to stop the replay with `Mix_HaltChannel()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Like for the music, we can control the volume of the sound channel by calling
    `Mix_Volume()` with the channel number and desired volume as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After we know how to play sound effects, we need to add a bit of code to the
    renderer to play a footstep sound whenever our instance is walking or running.
  prefs: []
  type: TYPE_NORMAL
- en: Using the footstep sound effects in the renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of the footstep replay will be just the bare minimum to show
    how and where the callbacks for the sound effects could be added. A full-featured
    sound effects replay system requires much more work and is out of the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: To add the footstep sounds, the following piece of code needs to be added to
    the `handleMovementKeys()` method of the renderer, right after we set the next
    state of the instance by calling `setNextInstanceState()`. At this point, we have
    all data about the current movement state of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we retrieve the current animation state of the current instance and
    check if the instance is in the idle/walk/run cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We only want to add sound effects at the same time as the walking and running
    animations replay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we check for the movement state of the instance and call the proper callback
    for the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the instance is in the running state, we play the sound effect for running
    footsteps. And if the instance is in the walking state, we play the walking footsteps.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the instance is neither running nor walking, we stop the footstep sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And if the instance is not in the idle/walk/run cycle, we also stop any sounds.
    This way, we catch all the actions like jumping or punching where no sound effect
    is available yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To hear the footsteps sounds, the following steps are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the application and load a configuration with animation mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select (or create) a first-person or third-person camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an instance and set the instance by clicking on **Use Selected Instance**
    in the **Camera** section of the **Control** window of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `F10` to switch to view mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you move around the controlled instance now by using the mouse and the *W*/*A*/*S*/*D*
    keys, you should hear two different footstep sounds, depending on the instance
    walking or running around in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the audio manager class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To outline a possible expansion of the `AudioManager` class to support more
    channels to achieve a more game-like sound management, we would need to keep track
    of the channel playing the footstep sound returned by the `Mix_PlayChannel()`
    call. By reserving one channel exclusively for the local footstep sounds, we can
    achieve the same behavior, but we would be able to play more sound effects at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple sound effects can be achieved by adding a creating a pool
    of sound channels and adding a callback to the `Mix_ChannelFinished()` SDL function,
    similar to `Mix_HookMusicFinished()`. SDL triggers the `Mix_ChannelFinished()`
    callback whenever a channel has finished the current sound clip, or when `Mix_HaltChannel()`
    is called and delivers the number of the finished sound channel in the callback.
  prefs: []
  type: TYPE_NORMAL
- en: The sound channel pool can be updated when a sound effect is played and when
    the effect replay has finished. By using the distance to the object creating the
    sound effect and scaling down the volume of the channel with `Mix_Volume()` or
    by using `Mix_SetDistance()`, the different distances of the source can be modeled.
    In addition, `Mix_SetPanning()` can be used to adjust the position of the sound
    source to the left and right.
  prefs: []
  type: TYPE_NORMAL
- en: Several tasks in the *Practical sessions* section are available to evolve the
    sound replay from the current state.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how to use the `AudioManager` callbacks from the `UserInterface`
    class, a simple music replay control has been added to the user interface. In
    the **Music & Sound** section of the **Control** window, you will find a combo
    box and some buttons to play the music from the playlist created from the `assets/music`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Using the music player in the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding music replay functionality to the `UserInterface` class is a quick and
    simple task. By using the callbacks to the `AudioManager` class, a basic music
    player is implemented with only a few code blocks to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 14.2*, the ImGui section with a basic music player using the `AudioManager`
    class is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: A music player based on the AudioManager added to the user interface'
  prefs: []
  type: TYPE_NORMAL
- en: The desired music track to play can be chosen by using the **Tracks** combo
    box, the current track can be played by pressing the **Play** button, or a random
    track from the playlist will be chosen from the shuffled playlist by pressing
    **Play Random**. The other four buttons, **Prev**, **Pause**, **Stop**, and **Next**,
    do exactly what the label states, and by using the sliders, the volume of music
    and sound effects can be set to a value between `0` (for silence) and `128`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative sound manager implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AudioManager` class used for the application uses a straightforward implementation
    with direct control through C++ callback functions. For an advanced sound system,
    an event- or message-based implementation could be used. Such an implementation
    can use event managing code already in the game, and events or messages also decouple
    the sound effects replay from the code that is requesting to replay a sound effect
    or a music change.
  prefs: []
  type: TYPE_NORMAL
- en: After having sound and music available in the virtual world, an update to the
    graphics of the application may appear also on the to-do list. Let’s explore some
    visual enhancements now.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing visuals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenGL and Vulkan renderers in the example code support only a minimal
    set of features to bring an image to the screen: Both renderers can only draw
    textures triangles and colored lines. Adding one or more of the following enhancements
    will be a fantastic extension to the quality of the images.'
  prefs: []
  type: TYPE_NORMAL
- en: Bringing colors to the world by using physically based rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, we are using only the textures of the Assimp objects to render the
    model instances and level geometry to the screen. By using **physically based
    rendering**, short **PBR**, we could also model surface properties in the form
    of materials. With such PBR materials, it is easy to create surfaces that have
    a shininess and reflectivity of metal or make surfaces like concrete or bricks
    look more natural.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.3* shows spheres drawn by the Vulkan PBR example code from Sascha
    Willems (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Different PBR materials'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.3*, the reflectiveness of the environment is
    set to a high value, resulting in a golden sphere. Between the spheres, the reflection
    settings change gradually, and on the right side, no reflectiveness at all is
    set.
  prefs: []
  type: TYPE_NORMAL
- en: A link to the source code of the PBR rendering and other examples is available
    in the *Additional resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A virtual world without windows and objects made of transparent materials may
    feel a bit strange since we are surrounded by transparent objects in the real
    world. However, rendering transparency is tricky due to the physics behind the
    color changes of the light on the path through more than one transparent object,
    requiring multiple transparent pixels on the same screen position to be drawn
    from back to front to calculate the correct final color for a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Two different approaches exist, called ordered and order-independent transparency.
    While ordered transparency requires all transparent objects to be sorted from
    back to front, order-independent transparency rearranges the pixels to be drawn
    by itself into the correct order. Both methods have advantages and disadvantages,
    so the best way to choose is to test both versions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.4* shows two transparency examples from LearnOpenGL ([https://learnopengl.com/](https://learnopengl.com/))
    by Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Transparent plants (left) and translucent red glass (right)'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.4*, partially transparent plants are rendered.
    By discarding pixels in the empty areas of the texture, a realistic effect of
    a plant can be achieved. On the right side of *Figure 14.4*, colored glass is
    rendered. Imitating glass for windows and other translucent objects by using transparent
    textures helps to create a better copy of the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up at a beautiful sky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you start the virtual world created with the example code of the book and
    load a level that is partially made to be outside of a building, you will not
    see some sort of sky but just the default background color. Adding a beautiful
    sky to the scene requires not just a simple sky texture, but also a so-called
    cubemap and a distorted sky texture.
  prefs: []
  type: TYPE_NORMAL
- en: A cubemap is a special kind of rendering object that represents the six sides
    of a cube, and the sky texture is projected onto the cubemap. The resulting skybox
    will create a seamless background that follows the view of the virtual camera,
    placing the level geometry and the instances into a realistic environment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.5* shows a skybox as environment around a wooden box, created with
    code from LearnOpenGL ([https://learnopengl.com/](https://learnopengl.com/)) by
    Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: A wooden box with a skybox as the background'
  prefs: []
  type: TYPE_NORMAL
- en: The effect of using a skybox can be seen best when moving the view around. In
    a static picture like in *Figure 14.5*, the difference between the wooden box
    and the skybox can be seen.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a skybox to our virtual world at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with light and shadows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current vertex shaders are using a hard-coded light source as virtual sun,
    emitting white light from a fixed position into the world. This basic lighting
    helps to identify the dimensions of the level geometry and the instances, even
    by using only flat shading. By adding more lights to the virtual world, other
    light-emitting objects can be modeled in a more realistic way, such as lamps,
    lanterns, fire, or torches. The flickering light of a fire in a dark place can
    be used to create various kinds of tension since it could mean a safe place to
    stay the night or an enemy position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene in *Figure 14.6* is illuminated by several thousand different colored
    light sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Multiple lights in a virtual world (image courtesy of Hannes Nevalainen)'
  prefs: []
  type: TYPE_NORMAL
- en: The image in *Figure 14.6* is a tech demo for the jMonkeyEngine made by Hannes
    Nevalainen, and the effect of many individual lights can be seen. The full video
    is available in the *Additional resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: When lights are added, shadows should be implemented too. For a simple start,
    the shadows of the objects cast by the virtual sun could be projected to the ground
    by using the so-called shadow mapping, creating the impression of lights and shadows
    taken from the real world. Shadows for the other lights can be added too, although
    the implementation is more complex. But the visual results will compensate for
    the effort as a lamp casting only the lit part of a window to the ground will
    bring a big smile to the programmer’s face.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.7* was created from the Vulkan example code made by Sascha Willens
    (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)),
    showing the shadows of trees created by using cascaded shadow maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Cascaded shadow maps of trees'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the skybox, the effect of using shadow maps can be seen much better
    when light, objects, and/or cameras are moving. Shadows like in *Figure 14.7*
    are a great addition to the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Swimming in realistic water
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If water was added as part of the extended level environment, the visual appearance
    should also be checked and enhanced. While using a simple, static transparent
    water texture may be fine for the first implementation, the urge to create better
    water may come up at some point.
  prefs: []
  type: TYPE_NORMAL
- en: By using a combination of reflection, refraction, and distortion of the light
    hitting the virtual water surface, realistic water can be created, and if the
    player should be able to dive into the water, a different kind of distortion could
    be utilized to create the illusion of being underwater.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.8* shows a water simulation made in WebGL by Evan Wallace (the code
    is available at [https://github.com/evanw/webgl-water/blob/master/index.html](https://github.com/evanw/webgl-water/blob/master/index.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Realistic water with waves and underwater caustics (courtesy of
    Evan Wallace)'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 14.8*, the waves of the sphere falling into the water can be seen.
    Also, the refraction of the walls created by the water and the refraction of the
    light on the bottom of the pool are clearly visible.
  prefs: []
  type: TYPE_NORMAL
- en: Adding stunning post-processing effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For even more realism in the virtual world, post-processing effects can be
    added to the renderers. The list of possible effects is long, so here is just
    a brief list of ideas that can be implemented quite quickly while creating great
    visuals:'
  prefs: []
  type: TYPE_NORMAL
- en: Lens flares for the illusion of looking through a camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'God rays: visible rays in haze when the direct view into the sun is blocked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bloom effect simulating glowing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion blur blurring the image when the view is moved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth of field blurring the world around a sharp center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen Space Ambient Occlusion darkening gaps and edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen Space Reflection, a cheap way to create reflective surfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these effects are created by using shaders and have different performance
    impacts. Nevertheless, even a bunch of the effects listed here will give the visual
    appearance a huge boost.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.9* shows two post-processing effects, Bloom and **Screen Space Ambient
    Occlusion** (**SSAO**). The Bloom effect was created with code from LearnOpenGL
    ([https://learnopengl.com/](https://learnopengl.com/)) by Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez))
    and the SSAO picture is made with code from Sascha Willems’ Vulkan examples (the
    code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Bloom (left) and SSAO (right)'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.9*, the Bloom effect is shown. The characteristic
    part of the Bloom effect is the halo effect around the light sources. For the
    green light source, the light even overlaps the top left edge of the wooden crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right side of *Figure 14.9*, SSAO is shown. The SSAO effect may be subtle,
    but it is visible: look at the floor below the curtains on the right side of the
    white line. The shadow creates the illusion of a darker room behind the curtains.'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading to ray tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the next step to realism, ray tracing can be added as an optional enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing uses virtual light rays emitted from the camera to compute the resulting
    pixel color by following the ray through the collisions with objects in the virtual
    world. Instead of just using the object color, the virtual ray is reflected by
    the physical rules and followed until the amount of light added falls below a
    threshold.
  prefs: []
  type: TYPE_NORMAL
- en: With ray tracing, effects like a global illumination of the world, causing dark
    areas to be lit by light being reflected from the objects, or realistic reflections
    could be achieved. Imagine running through a room full of mirrors and seeing your
    character multiple times, drawn in a correct physical way.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.10* shows a scene created by a ray tracing example from Sascha Willems
    Vulkan code (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Real-time ray tracing scene'
  prefs: []
  type: TYPE_NORMAL
- en: The reflections on the floor, the spheres, and the teapot in *Figure 14.10*
    are calculated in real time by using ray tracing with the Vulkan API on an Nvidia
    RTX 4000 series GPU.
  prefs: []
  type: TYPE_NORMAL
- en: The FPS counter was included to show how fast the current GPU generation is
    able to create ray tracing images. Only a few decades ago, a single frame of the
    same picture required several days to render.
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing should be optional
  prefs: []
  type: TYPE_NORMAL
- en: Note that the calculations for ray tracing require lots of computing power and
    creating complex scenes in real time needs both a GPU and a graphics API that
    support ray tracing. Right now, only Vulkan and DirectX 12 are able to use the
    ray tracing capabilities of modern GPUs. You need to check the availability of
    hardware and software support before switching to a graphics pipeline with ray
    tracing enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into virtual reality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though virtual reality (VR) is still a small niche, implementing VR support
    can be a great step ahead for immersion. Being able not just to see the virtual
    world on a flat screen but to stand right in the middle of the world can become
    a memorable moment for a player. Using head tracking to move the virtual camera
    simultaneously to the head of the player and adding virtual hands for the VR controllers
    creates a lot of new opportunities for interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.11* shows a scene from the Godot XR Tool Demo (the code is available
    at [https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Godot XR Tools Demo'
  prefs: []
  type: TYPE_NORMAL
- en: The most notable detail of *Figure 14.11* is the two virtual hands. By using
    the integrated sensors of the Valve Index® controllers, not only the position
    of the controllers can be deduced in all 6 degrees of freedom, but also the individual
    fingers can be tracked to allow gestures or actions depending on the position
    of a finger.
  prefs: []
  type: TYPE_NORMAL
- en: After the theoretical part of this section, we will now add a skybox to the
    application, acting as the global background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hands-on: Adding a skybox to the virtual world'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A virtual sky is a great addition to a virtual world, especially above any open
    areas, as shown in *Figure 14.5*.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the technical details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the technical side, a skybox is drawn from a texture applied on the inside
    of a unit cube. *Figure 14.12* shows the cube and the coordinates around the virtual
    camera placed in the center of the cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: The sampled area from the inside of a cubemap'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 14.1*2, the red area of the cube will be sampled to create the background
    of the current frame. Note that the area is wrapping around the corner of the
    cube, but that is nothing to worry about. Both graphics libraries take care of
    such edge cases (pun intended) and will sample the respective areas of the two
    affected cube sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cubemap texture is usually stored as a set of six separate images or as
    a single image with the sides of the cube at specific locations in the image.
    *Figure 14.13* shows a skybox texture made by Jockum Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))
    in a commonly used format plus the cube faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: A cubemap texture and the cube face of each picture'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.13*, an example cubemap texture for a skymap
    is shown. You will find many cubemap textures as this kind of cross. On the right
    side of *Figure 14.13*, the cube faces for each of the smaller sub-images of the
    cubemap texture are listed. Remember that OpenGL and Vulkan with an inverted viewport
    have the negative Z-axis pointing into the virtual world, hence `–Z` for the front
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another noteworthy detail is the distortion of a cubemap image. Since the cubemap
    texture is applied to a cube but the virtual sky around us can be seen as a sphere,
    the pixels of a cubemap texture must be adjusted to appear as if the image was
    taken with a camera from inside a sphere. In *Figure 14.14*, the discrepancy between
    the projection inside a cube and inside a sphere is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Sampled point of a cube vs. the corrected projection of a sphere'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see on the left side of *Figure 14.14*, the difference between a
    sample point taken from the cubemap and the position on the surface of the sphere
    gets larger the more we get near the edge of one side of the cubemap. On the right
    side of *Figure 14.14*, an area sampled from the cubemap and the required projection
    onto the surface of a sphere are highlighted as black bars. You can see that both
    the size and the angle of the areas differ. When building a cubemap texture for
    a skybox, a spherical distortion of the images for each of the cube faces must
    be applied to create a plausible sky.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the skybox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding the skybox to the code needs only a few components:'
  prefs: []
  type: TYPE_NORMAL
- en: New vertex and mesh types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new vertex buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit cube model containing the coordinates of the faces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a cubemap texture from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start with creating a new vertex type called `OGLSkyboxVertex` and a new
    mesh type called `OGLSkyboxMesh` in the `OGLRenderData.h` file in the `opengl`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As always, for Vulkan, the two new `struct` elements must be added to the `VkRenderData.h`
    file in the `vulkan` folder. For all the details of the Vulkan implementation,
    check the renderer class file, `VkRenderer.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we could reuse the vertex buffer of the models, doing so would waste
    a lot of resources since the cube only needs the position data for the vertices.
    The new vertex buffer class called `SkyboxBuffer` uses only the `position` element
    of the new vertex, `struct` `OGLSkyboxVertex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For the cube model, we create a class called `SkyboxModel` returning an `OGLSkyboxMesh`
    consisting of 36 vertices, using two triangles for each side. In all three axes,
    the model coordinates are either `1.0` or `-1.0`, defining a unit cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new vertex shader named `skybox.vert` outputs a `vec3` with 3-dimensional
    texture coordinates. We need 3-dimensional coordinates here since we are inside
    a cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` method of the vertex shader, we invert the projection matrix
    and transpose the view matrix first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For the view matrix, we can use a cheaper transpose operation instead of taking
    the inverse matrix since we need to get rid of the translational part to stop
    the cube moving around with the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'By multiplying the inverse matrices with the incoming point positions of the
    cube, we calculate the texture coordinates in world space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, the texture coordinates to sample are from the inside of the cube, as shown
    in Figure *14.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step for the vertex shader, we set the GLSL-internal variable `gl_Position`
    to the incoming vertex position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `z` component of `gl_Position` to the value of the `w` component,
    we make sure to draw the pixels of the cubemap on the far-Z plane, creating a
    background that will not be overwritten by other pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new fragment shader, `skybox.frag`, uses the incoming texture coordinates
    to look up the texture data in the cubemap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the type of the texture `tex` is a `samplerCube` and not a
    `sampler2D` like on the other fragment shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the cubemap texture is done in the `Texture` class. In the new `loadCubemapTexture()`
    method, we load an image shown in *Figure 14.1*3 and extract the six images. And
    since the values of the values of the texture map side definitions are in ascending
    order, we can just use the first side definition `GL_TEXTURE_CUBE_MAP_POSITIVE_X`
    and add an integer value for the remaining sides to upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For the full implementation of the cubemap texture loading, please check the
    details in the `Texture` class.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the skybox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bringing the skybox to the screen is now done in two steps. First, we upload
    the unit cube model data to the vertex buffer in the `init()` method of the `OGLRenderer.cpp`
    renderer class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, before drawing the level data, we draw the skybox by using the new shader,
    binding the texture and drawing the cube from the vertex buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For Vulkan, we also upload the skybox model and the texture in the `init()`
    method of the `VkRenderData.cpp` file, bind the skybox pipeline, and draw the
    skybox model before the level data in the `draw()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For both OpenGL and Vulkan renderers, a simple change should be made when drawing
    the skybox as the first object: disabling the depth test function. Without the
    depth test, the skybox texture overwrites all values of the previous color buffer,
    acting as the global background for the remaining objects, such as level data
    and instances. And that’s all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything was added correctly, the new and glorious sky above the level
    can be seen in *Figure 14.15* (the image is made from glTF level created by Zarudko
    ([https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)) using a texture created by Jockum
    Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))
    as the skybox):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: Example level with an activated skybox'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 14.15*, the skybox brings a real-world feel to levels
    with open areas. And since the cube does not move when the view changes like the
    level data, the illusion of an infinitely distant sky is created.
  prefs: []
  type: TYPE_NORMAL
- en: But even with great graphics and cool sound effects and music, there’s room
    for improvement. The environment of the virtual world is still somehow static,
    so let’s add changes to the world itself.
  prefs: []
  type: TYPE_NORMAL
- en: Extending immersion with daytime and weather
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although they are natural phenomena in our lives, the cycle between day and
    night, weather effects, and different seasons are rarely used in computer games.
    But all these aspects can be a great boost for immersion in a game. Slight changes
    to the virtual world depending on an internal clock may help to create an environment
    that a player wants to stay in for a much longer time to experience the full cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a day/night cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A day/night cycle adds some sort of familiarity to a game. Seeing the sun rise
    or enjoying a colorful sunset, watching the changes when running through the world
    around noon or late at night… every aspect will remind the player of being in
    a more realistic world. And if not only the light changes, but also other characters
    and animals react to the time of day, the immersion will become better and better.
    For instance, it may be good to see some animals only at night, and kids only
    in the morning, characters appearing at work at some time and leaving for a pub
    in the afternoon.
  prefs: []
  type: TYPE_NORMAL
- en: The in-game time could be running much faster than real time, reducing an entire
    day to a couple of minutes. Such a speedup can help if events that are frequently
    needed only occur at a specific time of the day.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular examples of the day/night cycle is Minecraft. A full
    day in Minecraft lasts 20 minutes by default, split into a 10-minute day and a
    10-minute night. And since the light level changes, enemy spawning and food and
    tree growing behave completely differently in the day and the night.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.16* shows the same spot in our application at noon and at night:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: Day and night in the example code from *Chapter 14*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 14.16*, even a simple change in the overall brightness
    of the virtual world could make an enormous difference. And changing more properties
    of the world depending on the time of day will bring more immersion for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing forward time travel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with time, one fact should not be underestimated: the time waiting
    for an event to happen can be boring and passes slowly. Instead of keeping the
    player waiting for the entire day or night to pass, special “time travel” events
    could be added, such as sleeping through the night, or waiting at a fireplace
    to let the time pass, having the game fast-forwarding the in-game time.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing in real time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thinking about the time in a game, the idea of synchronizing the time in the
    virtual world to the time of the real world can be an interesting option. Only
    a few games utilize such a feature. Also, solving tasks or quests may be more
    complicated if they are bound to a special time of the day. But being “now” in
    a game may be fun.
  prefs: []
  type: TYPE_NORMAL
- en: Worshipping the weather god
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not only may the time of day change the world, but weather changes can also
    greatly influence characters, animals, and the environment. During a thunderstorm,
    the best advice is to stay inside, heavy rain may be so loud that other sounds
    never reach the player’s ears, and fresh snow will also absorb noises. So, roaming
    around in various weather states can give entirely different impressions of the
    same world.
  prefs: []
  type: TYPE_NORMAL
- en: Environmental changes such as the addition of fog also change the perception
    of the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.17* shows different types of fog in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: The effect of fog in the example code from *Chapter 14*'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.17*, the virtual world is completely without
    fog, showing a clear day. In the middle of *Figure 14.17*, heavy fog was added,
    causing the world to fade out after a short distance. Fog was used in several
    old games to hide the appearance and disappearance of objects due to rendering
    limitations in early game engines. Finally, on the right side of *Figure 14.17*,
    the light color was adjusted to a green tone, creating the illusion of toxic fog
    in the streets of the map.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the oracle of seasons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next evolutionary step after a day/night cycle and weather would be the
    implementation of the four seasons. The rotation between Spring, Summer, Fall,
    and Winter is a great opportunity to bring even more reality into the virtual
    world as the actions of characters or the appearance of animals will change throughout
    the year.
  prefs: []
  type: TYPE_NORMAL
- en: Like the length of the in-game day, a virtual year should be shortened to a
    reasonable amount of real time, or a forward time travel functionality should
    be allowed if all tasks in the current season have been finished. Letting the
    player wait for no reason will kill their enthusiasm.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of the changing world properties depending on the season is
    “Legend of Zelda: Oracle of Seasons” by Nintendo for the GameBoy Color. Despite
    the age of the game, the changes of the seasons have been implemented with great
    detail, allowing the player to enter some areas of the world only in specific
    seasons. For instance, rivers are only frozen in Winter and snow fields elevate
    the parts of the landscape, while only in Summer, flower tendrils enable Link
    to climb up walls.'
  prefs: []
  type: TYPE_NORMAL
- en: In “Stardew Valley” by Eric Barone, seasons are also a key element of the gameplay.
    Each of the four seasons influences different parts of the game, like crop growth.
    A season is 28 in-game days long, and by accelerating the time, an entire year
    in Stardew Valley elapses in 26 hours of in-game time.
  prefs: []
  type: TYPE_NORMAL
- en: For the application, we will create simple day/night light changes and fog as
    examples. Let’s start with day and night.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hands-on: Adding day and night'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing the light source’s color and position is easy. Most of the fragment
    shaders already contain a fixed light source definition to allow better visualizations
    of the instances and the level data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing light control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the first step, we add two new variables called `lightPos` and `lightColor`
    to the `Matrices` `uniform` in all vertex and fragment shaders where `Matrices`
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In `lightPos`, we will hand over the current position of the light source, allowing
    us to simulate the position of the Sun or Moon in the virtual world, and in `lightColor`,
    we transport the color of the light source to the GPU, enabling us to simulate
    sunrise, noon, sunset, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we defined the uniform buffer containing the view and projection matrix
    on the CPU to use `glm::mat4` as the data type, we must add the two `glm::vec4`
    vectors for the light position and color as the first two elements of a `glm::mat4`
    that will be uploaded to the GPU before drawing the frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now all fragment shaders containing the light source definitions can be adjusted
    with a better light control for the surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the new shader code in the `main()` method by defining the ambient
    light level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The ambient light level is used to simulate the light scattering from other
    surfaces, enabling some sort of minimal lighting in the virtual world. By limiting
    the minimal ambient light, we also prevent the resulting picture from becoming
    pitch black.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we calculate the diffuse part by using the angle between the triangle
    normal and the direction of the light source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The diffuse lighting of a surface changes with the angle between the surface
    and the light source. As the dot product of two normalized vectors equals the
    cosine of the angle between the two vectors, we can use the result of the `dot()`
    call directly as a multiplier of the light source color.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step for the fragment shader code changes, we add up ambient and
    diffuse light and multiply the resulting light value by texture data and vertex
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We can now control the position and color of the light source from the application,
    and by sending a spherical position and a color, various times of the day can
    be simulated.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To control the light values, a new UI section will be created, enabling fine-grained
    settings of all light-related values. *Figure 14.18* shows the new **Environment**
    section in the `UserInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: UI controls for light parameters and skybox'
  prefs: []
  type: TYPE_NORMAL
- en: By splitting the light angle into east/west and north/south, we can move the
    light around to any position of the virtual sky. The light intensity can be used
    to lower the overall brightness of the light without manually touching the color
    values.
  prefs: []
  type: TYPE_NORMAL
- en: With the separate light color values, we can adjust the light to match the natural
    colors of the Sun or the Moon, at least within the limitations of the available
    color space, and by using a set of predefined color values, we can set the light
    color, intensity, and position immediately to a specific time of the day.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.19* shows three different light settings for the virtual world (this
    image is created using the map by Zarudko ([https://skfb.ly/6QYJw](https://skfb.ly/6QYJw))
    and the skybox image is by Jockum Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.19: The virtual world in the morning, at noon, and in the evening'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in *Figure 14.19* that just changing the color of the light source
    can create entirely different moods in the virtual world. Combined with the skybox
    from the *Enhancing visuals* section, you can already create truly immersive worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored ideas and tools to show how to upgrade the current
    animation editor to a small game engine with a built-in editor.
  prefs: []
  type: TYPE_NORMAL
- en: First, we looked at a couple of audio libraries and when to play sound effects
    and music in a game. Sound effects and music are essential parts of the player’s
    experience, creating a basic form of immersion as the experience of the real world
    will be transferred to the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored visual enhancements to the graphics of the application. Extending
    the basic renderer with transparency, a skybox, dynamic lights and shadows, realistic
    water, and post-processing effects such as God rays and motion blur will bring
    the visuals to the next level. Even though it’s optional due to the limited target
    group, adding support for ray tracing and VR could become viable options as both
    features are a big step forward in terms of visual quality and immersion.
  prefs: []
  type: TYPE_NORMAL
- en: As the last step, we explored a day/night cycle, weather, and seasons as elements
    to change the environment of the virtual world. Already, a simple cycle of a day
    adds a lot of interesting opportunities to the virtual world, such as only meeting
    computer-controlled characters or animals at a certain time of the day or enemies
    that only appear at night. Weather effects and seasons also multiply the options
    to change behavior depending on the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: So... what to do next? Well, that’s completely up to you!
  prefs: []
  type: TYPE_NORMAL
- en: You could start by learning how to use **Blender** to create your own animated
    characters, animals, objects, and levels. The created assets don’t have to be
    of the quality of recent games; even low-poly worlds are charming and have many
    fans. There are lots of books, tutorials, and videos available, handling many
    different art styles for virtual worlds.
  prefs: []
  type: TYPE_NORMAL
- en: What about adding more objects? Vehicles and animals would enrich the virtual
    world, and doors and buttons lead to a lot more ways to interact with the world.
    For better gravity, you might even add a physics engine to the application, enabling
    other cool features such as force distribution on collisions between objects.
  prefs: []
  type: TYPE_NORMAL
- en: You might also explore the world by using a camera with orthogonal projection.
    Watching the player, other characters, and the environment in an isometric projection
    or only from the side could open new ways of expressing a story. Since both the
    isometric projection and the side view are only different views of the three-dimensional
    world, all options mentioned in this chapter also apply when using the orthogonal
    projection.
  prefs: []
  type: TYPE_NORMAL
- en: Another idea could be the creation of a storyline and quests for the player
    to handle. Forcing the player to move between various locations and interact with
    different characters to unlock more quests, items, or doors, or just to receive
    the next piece of the mental puzzle about a quest could engage the player to stay
    longer in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Or you could dive into the networking part of SDL and create a small network
    server, allowing you to explore the virtual worlds with your friends. Roaming
    around the levels and solving quests as a team is satisfying and brings new complexity
    to the quest system since you may or may not allow the players to use their shared
    knowledge of a quest over a long distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is the most important next step: stay curious and experiment with
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button to reload the music tracks from the asset folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nice-to-have feature to dynamically add or remove tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Add more sound effects for the instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could map a sound clip to every action of the instances, creating more realistic
    effects when controlling the selected instance.
  prefs: []
  type: TYPE_NORMAL
- en: Play the step sound depending on the floor material.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, you need to load more than one pair of footstep sounds for walking and
    running. The appropriate sound effect could be chosen by using the mesh type of
    the ground triangle as the index into the footstep sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Add sounds for nearby instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SDL_mixer` library allows us to set the volume and balance per channel.
    Using the distance and angle of the surrounding instances can be used to calculate
    the effective volume and direction of the sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Play ambient sound at special places on the map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the waypoint models, you could use small models as markers to play
    an ambient sound. And like the sounds for nearby instances, the volume and balance
    of the ambient sound can be adjusted to match the expectation.
  prefs: []
  type: TYPE_NORMAL
- en: Add markers for music changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This task is closely related to the ambient sound. You could use models and/or
    nodes to switch the music when your controlled instance enters a specific area
    of the map or interacts with other instances.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust level color and fog depending on the level location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only can the music be changed when roaming through the level; also, the
    light and fog settings can be adjusted. For instance, when entering a cave, the
    ambient light can be lowered and the fog density can be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SDL: [https://www.libsdl.org](https://www.libsdl.org%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenAL Soft: [https://github.com/kcat/openal-soft](https://github.com/kcat/openal-soft%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PortAudio: [https://www.portaudio.com](https://www.portaudio.com%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FMOD: [https://www.fmod.com](https://www.fmod.com%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Game Physics Engine Development* by *Ian Millington*, published by *CRC Press*:
    ISBN 978-0123819765'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Game Physics by David H. Eberly*, published by *Morgan Kaufmann*: ISBN 978-0123749031'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open-source physics engine: [https://www.tapirgames.com/blog/open-source-physics-engines](https://www.tapirgames.com/blog/open-source-physics-engines%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vulkan examples by Sascha Willems: [https://github.com/SaschaWillems/Vulkan](https://github.com/SaschaWillems/Vulkan%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordered transparency: [https://learnopengl.com/Advanced-OpenGL/Blending](https://learnopengl.com/Advanced-OpenGL/Blending%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order-independent transparency: [https://github.com/nvpro-samples/vk_order_independent_transparency](https://github.com/nvpro-samples/vk_order_independent_transparency%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL skybox: [https://learnopengl.com/Advanced-OpenGL/Cubemaps](https://learnopengl.com/Advanced-OpenGL/Cubemaps%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to create cubemaps: [https://paulbourke.net/panorama/cubemaps/](https://paulbourke.net/panorama/cubemaps/%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL multiple lights: [https://learnopengl.com/Lighting/Multiple-lights](https://learnopengl.com/Lighting/Multiple-lights%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple lights demo by Hannes Nevalainen: [https://www.youtube.com/watch?v=vooznqE-XMM](https://www.youtube.com/watch?v=vooznqE-XMM%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL shadow maps: [https://learnopengl.com/Guest-Articles/2021/CSM](https://learnopengl.com/Guest-Articles/2021/CSM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WebGL water simulation: [https://madebyevan.com/webgl-water/](https://madebyevan.com/webgl-water/%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL realistic water: [https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe](https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL water caustics: [https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa](https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL lens flares: [https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html](https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL God rays: [https://github.com/math-araujo/screen-space-godrays](https://github.com/math-araujo/screen-space-godrays%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL bloom effect: [https://learnopengl.com/Advanced-Lighting/Bloom](https://learnopengl.com/Advanced-Lighting/Bloom%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL motion blur: [https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf](https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL depth of field: [https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html](https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL SSAO: [https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html](https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL SSR: [https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vulkan raytracing: [https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/](https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenXR: [https://www.khronos.org/openxr/](https://www.khronos.org/openxr/%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Godot XR Demo template: [https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender: [https://www.blender.org](https://www.blender.org%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open Game Art for assets: [https://opengameart.org/](https://opengameart.org/%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation%0D%0A)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
