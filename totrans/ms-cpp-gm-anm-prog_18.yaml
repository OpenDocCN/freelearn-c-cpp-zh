- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Immersive Interactive Worlds
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 14*! In the previous chapter, we added pathfinding and navigation
    to the instances. We started with a brief overview of navigation methods in computer
    games. Then we explored and implemented the A* algorithm to find a path between
    the instance position and a point in the virtual world. Next, we enhanced the
    models to serve as navigation targets and extended the instances to find a path
    to one of the targets. At the end of the chapter, we added the ability for an
    instance to follow the path and reach the desired target.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore different ideas to enhance the example code
    for more immersion and visual quality. We will look at the audible side for tools
    and methods to add sound effects and music to the application. Also, we will implement
    a simple audio manager class to play sounds and background music. To please not
    just the ears but also the eyes, we will collect some ideas about how to enhance
    the visual appearance next and implement two of the graphical enhancements to
    the application. We will end the book with this chapter by looking at the effects
    of daytime and weather changes on the virtual world and add a basic day/night
    cycle to the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects and background music
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing visuals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending immersion with daytime and weather
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter is available in the `chapter14` folder: the
    `01_opengl_ideas` subfolder for OpenGL and the `02_vulkan_ideas` subfolder for
    Vulkan.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects and background music
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the example code from [*Chapter 13*](Chapter_13.xhtml) provides a lot
    of features, such as face animations, level loading, collision detection, and
    pathfinding and navigation. But sadly, all the animations on the screen are running
    in dead silence. No bleeping or beeping, no sound, and no music. Just silence.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: But sound and music are an important part of games for very good reasons. Whether
    you are enjoying the calm meadows or deep caves of Minecraft, grooving to the
    happy music of one of the Super Mario titles and hearing the sound effects as
    acoustic feedback of our actions, prefer roaming through the haunting worlds of
    the Dead Space or Silent Hill series while listening carefully to the environment
    sounds to be aware of your surroundings, or driving cars to the pumping music
    and fat sounds of racing games such as the Need for Speed series – without music
    and sound, games wouldn’t deliver the same experience for the player.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: To add sound output, we can include a freely available sound library, allowing
    us to easily play sound effects or music. Let’s look at some of the libraries
    first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Using an audio library
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most audio libraries are written in C, but bindings for C++ can be found, encapsulating
    the operating-system-specific low-level function calls in an object-oriented manner.
    Just using the C functions and building a custom abstraction is also possible,
    similar to GLFW, OpenGL, and Vulkan.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数音频库是用 C 编写的，但可以找到 C++ 的绑定，以面向对象的方式封装操作系统特定的低级函数调用。仅使用 C 函数并构建自定义抽象也是可能的，类似于
    GLFW、OpenGL 和 Vulkan。
- en: Simple DirectMedia Layer
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Simple DirectMedia Layer
- en: '**Simple DirectMedia Layer** (**SDL**) is a cross-platform library for multimedia
    hardware components of a computer. SDL manages audio and can serve as a framework
    for window functions, graphics context, and input handling, like GLFW. In addition,
    there are several official libraries that provide support for importing and exporting
    images, custom networking, and font rendering to display text on the screen.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Simple DirectMedia Layer** (**SDL**) 是一个跨平台库，用于计算机的多媒体硬件组件。SDL 管理音频，可以作为窗口功能、图形上下文和输入处理的框架，如
    GLFW。此外，还有几个官方库提供对导入和导出图像、自定义网络和字体渲染以在屏幕上显示文本的支持。'
- en: OpenAL
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAL
- en: '**OpenAL** is a cross-platform library that focuses on multi-channel, three-dimensional
    audio. By using 3D audio, the sound can be modeled to be in front of or behind
    the player, not just to the left or right, deepening the immersion.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenAL** 是一个专注于多通道、三维音频的跨平台库。通过使用三维音频，可以将声音建模为在玩家前方或后方，而不仅仅是左右，从而加深沉浸感。'
- en: PortAudio
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PortAudio
- en: '**PortAudio** is another cross-platform audio library. It targets real-time
    audio playback and recording. PortAudio can be used if the scope of SDL and OpenAL
    is too large for the project, and the goal is to just have some audio playing.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**PortAudio** 是另一个跨平台音频库。它针对实时音频播放和录制。如果 SDL 和 OpenAL 的范围对于项目来说太大，可以使用 PortAudio，目标是仅仅播放一些音频。'
- en: FMOD
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FMOD
- en: Although **FMOD** is a proprietary sound engine, it can be included in the list
    of freely available libraries as a non-commercial license exists, allowing us
    to use FMOD for free. A paid FMOD license is only needed if the final application
    or game will be distributed commercially. FMOD supports 3D engines such as Unreal
    and Unity, so you might even get in touch with FMOD if you are working on a game
    at some point in time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **FMOD** 是一个专有音效引擎，但由于存在非商业许可，它可以被列入免费可用的库列表，允许我们免费使用 FMOD。只有当最终的应用程序或游戏将商业分发时，才需要付费的
    FMOD 许可证。FMOD 支持如 Unreal 和 Unity 这样的 3D 引擎，所以如果你在某个时间点正在制作游戏，甚至可能会接触到 FMOD。
- en: After exploring *which software* for sound and music replay could be included,
    let’s check out *what* could and should be played.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了可以包含哪些软件用于声音和音乐回放之后，让我们来看看可以播放以及应该播放的内容。
- en: Playing sound effects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音效
- en: Since sound plays a key role in our lives, we will have some expectations of
    what we should hear in a game or a simulation. Failing to meet these expectations
    may harm immersion.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音在我们的生活中扮演着关键角色，我们会对在游戏或模拟中应该听到的内容有所期望。未能满足这些期望可能会损害沉浸感。
- en: The game character’s footsteps
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏角色的脚步声
- en: Probably the most important sound effects a player wants to hear are the footsteps
    of the character on the ground. By adjusting the sound in relation to the ground
    material and the speed of the character, instant feedback about the environment
    is delivered to the player. There is a significant difference between silently
    sneaking through grass or running on metal ground, and the player should be made
    aware of the “loudness” of the character’s actions, and by using collision detection
    and ground triangle discovery, as described in the *Finding ground triangles in
    level data* section of [*Chapter 12*](Chapter_12.xhtml)*,* the material type of
    the ground triangle can be found easily.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可能玩家最想听到的最重要的音效是角色在地面上行走的声音。通过调整与地面材料和角色速度相关的声音，向玩家提供关于环境的即时反馈。在无声地穿过草地或在地面上奔跑之间有显著的区别，玩家应该意识到角色的“响度”，并且通过使用碰撞检测和地面三角形发现，如[*第
    12 章*](Chapter_12.xhtml)中的*在关卡数据中查找地面三角形*部分所述，可以轻松找到地面三角形的材质类型。
- en: Other character sounds
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他角色声音
- en: The character makes a lot more sounds, not just footsteps. Jumping and landing,
    climbing a ladder, swimming, or being hurt by an enemy character should also give
    audible feedback to the player for additional information about what happens with
    the character in the virtual world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 角色会发出更多的声音，不仅仅是脚步声。跳跃和着陆、爬梯子、游泳或被敌人角色伤害也应该给玩家提供可听见的反馈，以提供关于虚拟世界中角色发生情况的额外信息。
- en: Local sound sources
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地声音源
- en: Not only does the player-controlled character need sound effects, but also for
    the computer-controlled characters and inanimate objects in the virtual worlds
    audio effects should be played. Hearing doors opening and closing, the hammering
    of a blacksmith, or the call of a bird, and listening to the crackles of fireplaces,
    the sound of a waterfall, or wind in a high place in the world will intensify
    immersion greatly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玩家控制的角色需要声音效果，虚拟世界中的计算机控制的角色和静止物体也应该播放音频效果。听到门开关的声音、铁匠的锤击声，或鸟儿的鸣叫，以及听到壁炉的噼啪声、瀑布声或世界高处风的声音，将极大地增强沉浸感。
- en: Ambient sounds
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境声音
- en: Ambient sounds are a mix of different sounds and frequencies coming from locations
    far away, losing some of their information on the way to the listener. A large
    group of people, the wind in a forest, or a street some meters away all produce
    well-known sounds for us that should be added to corresponding places of the virtual
    world.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 环境声音是由来自遥远地点的不同声音和频率混合而成，在传递到听者过程中会丢失一些信息。一大群人、森林中的风，或者几米外的街道都会产生我们熟知的声响，这些声响应该被添加到虚拟世界的相应位置。
- en: Weather effects
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 天气效果
- en: If the world includes some kind of weather system, the sounds and effects should
    be added too. A distant thunderstorm or the silence of the ground after a snowfall
    can change the perception of the virtual world by the player.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果世界上存在某种天气系统，那么相应的声音和效果也应该被添加。远处的雷暴或雪后地面的寂静都可以改变玩家对虚拟世界的感知。
- en: But not only can sound effects be useful for immersion; playing music can also
    help to keep a player’s attention.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但声音效果不仅有助于沉浸感；播放音乐也有助于保持玩家的注意力。
- en: Playing music
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放音乐
- en: Since the early days of computer games, music has been added to games to keep
    players interested. As a result, we may still remember the music of a game when
    we see the title but not details of the gameplay or the game’s characters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自从计算机游戏早期开始，音乐就被添加到游戏中以保持玩家的兴趣。因此，当我们看到游戏标题时，我们可能仍然记得游戏的音乐，而不是游戏玩法或游戏角色的细节。
- en: Menu music
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单音乐
- en: The first screen a player will see when starting the application is most probably
    some kind of main menu. Throwing a player directly into the action, without being
    able to configure the controls for the virtual character, the visual quality,
    or the sound volume first, may not be the best idea. While the player explores
    the options in the menu, music can help to prevent the player from getting lost
    or bored straight away.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家启动应用程序后看到的第一个屏幕很可能是某种主菜单。直接将玩家投入战斗，而无法首先配置虚拟角色的控制、视觉效果或音量，可能不是最好的选择。当玩家在菜单中探索选项时，音乐可以帮助防止玩家立即感到迷茫或无聊。
- en: Ambient music
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境音乐
- en: Similar to ambient sounds, ambient music helps to prevent dead silence in a
    game. Playing no sounds at all may be intended to build up tension, but running
    for hours and hours in silence through a game can become boring. Adding a music
    track with a style and tempo that fits the gameplay helps the player to enjoy
    even slow passages of the game.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与环境声音类似，环境音乐有助于防止游戏中的死寂。完全不播放声音可能是为了建立紧张感，但长时间在寂静中玩游戏可能会变得无聊。添加一个风格和节奏适合游戏玩法的音乐曲目，可以帮助玩家享受游戏的缓慢段落。
- en: Adaptive music play
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自适应音乐播放
- en: When the player moves into a different area in an open world or enters an environment
    with a different style, or another room, changing the music to match the new place
    is a good idea. The famous “hearing boss music” moment when entering a room, combined
    with the sound of doors locking, will create unforgettable moments for a player.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入开放世界中的不同区域，或进入具有不同风格的场景，或另一个房间时，改变音乐以匹配新地方是一个好主意。进入房间时著名的“听到Boss音乐”的时刻，结合门锁的声音，将为玩家创造难忘的体验。
- en: Allowing custom music
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许自定义音乐
- en: An interesting option for music selection is to let the player add local music
    to the list of tracks played in the game or even replace the music entirely. Seeing
    the game’s character exploring a virtual world while listening to some favorite
    music tracks may be a plus for players.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐选择的一个有趣选项是让玩家将本地音乐添加到游戏中播放的曲目列表中，甚至完全替换音乐。看到游戏角色在听一些喜欢的音乐曲目时探索虚拟世界，可能会为玩家增添乐趣。
- en: To experience the difference audio replay can make, we will add a C++ class
    to manage sound effects and music replay.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了体验音频回放可以带来的差异，我们将添加一个C++类来管理声音效果和音乐回放。
- en: 'Hands-on: Implementing an audio manager'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The audio manager class consists of two distinct parts. On one hand, we need
    a high-level interface between the audio manager and the renderer and other classes.
    On the other hand, the encapsulated low-level interface linking the audio manager
    functionality to the audio library of the operating system would allow us to replace
    the audio library with another variant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a brief overview of the high-level interface and dive into
    the low-level implementation afterward.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Defining the high-level interface
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new `AudioManager` class, consisting of the `AudioManager.h` header file
    and the `AudioManager.cpp` implementation file will be added to the `tools` folder.
    We will add the basic functions a usual music/sound player should have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and cleaning up the audio library
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading music tracks from files on the file system
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading sound effects from files on the file system
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing and stopping music and sound effects
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing, resuming, and skipping the music tracks to the next and previous
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving, shuffling, and clearing the current playlist
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the volume of music and sound effects
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, the `public` `setMusicVolume()` and `getMusicVolume()` methods
    are added to the `AudioManager` class to control the music volume:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition, the `private` member variable named `mMusicVolume` is used to
    store the current volume of the music:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the remaining functionalities in the list of functions, `public` methods
    and `private` member variables are created. Check the `AudioManager.h` file to
    see the full number of methods and member variables that are available in the
    `AudioManager` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now we must add a member variable for an object of the `AudioManager` class
    along with the initialization and cleanup calls of the audio functionality to
    the application code. To keep the renderer for the video part only, the `AudioManager`
    member variable and methods will be added to the `Window` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Adding the AudioManager class to the Window class
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The two primary steps to add the audio functions to the `Window` class are
    the same as for all other classes: including the `AudioManager.h` header file
    at the top of the `Window.h` header file and declaring the `private` member variable
    named `mAudioManager`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in the `init()` method of the `Window` class in the `Window.cpp` file,
    we try to initialize the `AudioManager` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we use the `Logger` class to print an error message, but we *do not*
    end the window initialization if the `AudioManager` initialization fails. Audio
    replay should be kept optional, and we continue without music and sound replay
    instead of failing the application startup process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the music tracks into the `AudioManager` can be done right after the
    initialization call:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are trying to load all MP3 files in the `assets/music` folder into
    the `AudioManager` if the initialization is successful. Again, we don’t fail if
    no music files are found in the asset folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Adding music tracks to the playlist
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In the `AudioManager` class, support for loading MP3 and OGG files from the
    local folder `assets/music` into a playlist has been implemented. You can add
    your own music to the `assets/music` folder as the playlist will be populated
    when the application is started. In the *Practical sessions* section, a task is
    available to add a **Refresh** button to the UI, allowing you to add or remove
    music tracks at application runtime.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to clean up the `AudioManager` when shutting down the application.
    So, we add a call to the `cleanup()` method of `AudioManager` to the `cleanup()`
    method of the `Window` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since we created the `AudioManager` in the `Window` class, we need to create
    callback functions to access the music and sound-effect functions from the renderer
    or the user interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks to make the AudioManager class available everywhere
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By using these callback functions, changing the music track or playing footstep
    sounds can be done from anywhere in the code. As an example, we will use the functionality
    to play a specific music track here, given the track name as a parameter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the function signature for the callback named `playMusicTitleCallback`
    to the `Callbacks.h` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we create a variable named `micPlayMusicTitleCallbackFunction` to the
    `ModelInstanceCamData` `struct` in the `ModelInstanceCamData.h` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use the `ModelInstanceCamData` `struct` to avoid spreading the callback functions
    all over the code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the callback variable will be bound to the corresponding `AudioManager`
    function in the `init()` method of the `Window` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we get a reference to the variable containing the `ModelInstanceCamData`
    `struct` of the renderer class and assign the `playTitle()` method of the `AudioManager`
    class by using a lambda function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The same three steps of creating the callback function signature, adding a variable
    to the `ModelInstanceCamData` `struct`, and binding the callback function to the
    method of the `AudioManger` class must be repeated for every audio method that
    should be available in the renderer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the implementation of the low-level part of the audio manager.
    We will use SDL as the audio functions are easy to use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Using SDL for the low-level layer
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although SDL can handle more features than audio, it is possible to use only
    a subset of the functions provided by the SDL library. So, instead of using SDL
    for window and keyboard handling, which is done by GLFW in the application, we
    will only use the sound replay and mix functionality of SDL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: To use audio replay with SDL, we need the core SDL library plus the separate
    mixer library named `SDL_mixer`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL and SDL_mixer on Windows
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For Windows, precompiled versions of SDL and `SDL_mixer` are available on GitHub.
    Go to the releases page at the following two URLs and download the latest stable
    development zip files for Visual Studio, containing both `devel` and `VC` in their
    names. As an example, the current development package of the main SDL library
    for Visual Studio is named `SDL2-devel-2.30.9-VC.zip`. Here are the URLs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'SDL: [https://github.com/libsdl-org/SDL/releases](https://github.com/libsdl-org/SDL/releases)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL_mixer`: [https://github.com/libsdl-org/SDL_mixer/releases](https://github.com/libsdl-org/)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, unpack the two zip files to your computer, but take care to avoid spaces
    and special characters like German umlauts in the path names to avoid problems
    since even in 2024 many tools have still problems with special characters in the
    paths.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add two **environment variables** to help the CMake search scripts find
    the headers and libraries:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The first variable is named `SDL2DIR` and must point to the folder where the
    main SDL library was unpacked.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second variable is named `SDL2MIXERDIR` and must point to the folder of
    the `SDL_mixer` library.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 14.1* shows an example of the environment variables:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Example environment variables for SDL'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: After installing the two libraries and adding the environment variables, the
    code for this chapter can be compiled. The CMake build script takes care of placing
    the two DLL files next to the executable file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL and SDL_mixer on Linux
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, the SDL libraries can be added by using the integrated package management.
    On Ubuntu or Debian, you can use the `apt` package manager to install the main
    SDL library, the `SDL_mixer` library, and all development headers and libraries
    by issuing the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For an Arch-based distribution, use the `pacman` package manager to add the
    two libraries to the system with the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To add SDL and `SDL_mixer` to the `AudioManager` class in order to use the
    SDL functions, we must include the two SDL headers after the existing `#include`
    directives in the `AudioManager.h` header file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since SDL is a C library, all structures only use raw pointers. The audio manager
    is one of the places where you will find variables with raw pointers in the code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `mMusicTitles` variable is a map containing several SDL music objects, which
    are accessible by the name of the track as the key for the map. Every track is
    saved in a variable named `Mix_Music`, where the prefix Mix states that this is
    a variable used by the `SDL_mixer` library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In the `mWalkFootsteps` variable, a so-called chunk of audio (using the terms
    of SDL) is stored. An `SDL_mixer` chunk can be played by calling the respective
    sound effect’s replay function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Before sound effects or music can be played, the audio part of SDL must be initialized
    properly, and at the end of the application, the audio functions must be ended
    too.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and shutting down SDL and the SDL_mixer
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the first step in the `init()` method of the `AudioManager` class, we try
    to initialize the audio part of SDL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `SDL` prefix of both `SDL_Init()` and the `SDL_INIT_AUDIO` flag denotes
    that we are using the core functionality of SDL. If we cannot initialize the audio
    part of SDL, we stop the initialization of the `AudioManager` right here. Beware
    that the initialization of the audio device can fail for various reasons, for
    instance, if the audio device is in use by another application that forbids sharing
    the device.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we try to set the parameters for the audio device by calling `Mix_OpenAudio()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we are in the realm of `SDL_mixer`, which is visible on the `Mix` prefix
    of `Mix_OpenAudio`. The first parameter of `Mix_OpenAudio` is the replay frequency
    in Hz. We are using the well-known value of 44.1 kHz, introduced by Sony’s **compact
    disc** specifications. As the second parameter, the internal audio format is configured.
    `MIX_DEFAULT_FORMAT` stands for 16-bit signed integer values, which is also a
    common value in the audio world.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is the number of output channels to use. One output channel
    uses mono replay, and the two channels from the initialization call are for stereo
    output. Depending on the audio hardware and driver support, up to eight output
    channels for a 7.1 system are possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: With the fourth and last parameter, an internal audio buffer in the `SDL_mixer`
    library is configured. A small buffer value may cause audio dropouts if the CPU
    load gets too high while filling the buffer, and a large buffer leads to delays
    since the buffer needs to be filled before the samples can be played. The unit
    of the buffer parameter is “sample frames,” so we configure `SDL_mixer` to reserve
    space for 2,048 frames, every frame contains two 16-bit signed integers, one for
    every output channel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'At the termination time of the application, the `cleanup()` method of the `AudioManager`
    is called by the `cleanup()` method of the `Window` class. Inside the `cleanup()`
    method of the `AudioManager` class, we close the audio device and signal both
    `SDL_mixer` and SDL to run their respective cleanup code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we did not call `Mix_Init()` in the `init()` method, but we have to
    call `Mix_Quit()` here. SDL manages the mixer initialization for us without an
    explicit call to `Mix_Init()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to play music and sound effects. Let’s start with a look at
    the music replay code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Controlling music replay
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loading a music track is done by calling `Mix_LoadMUS()` with the C-style character
    array as a parameter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`SDL_mixer` supports several music formats, such as WAV, MP3, and OGG. The
    return value of `Mix_LoadMUS()` is a pointer to the `Mix_Music` `struct`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean up a loaded music track, `Mix_FreeMusic()` must be called with the
    pointer to the above `Mix_Music` `struct`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A music track can be played by calling `Mix_PlayMusic()` with two parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first parameter is a pointer to a valid `Mix_Music` `struct`, while the
    second parameter tells `SDL_mixer` the number of loops to play. A loop value of
    `0` disables looping and a value of `-1` will loop the music infinitely.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Stopping the music is done by calling `Mix_HaltMusic()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since there is only one music track playing at a time, no parameters are needed,
    and in case the current track should be paused or resumed, the two `Mix_PauseMusic()`
    and `Mix_ResumeMusic()` calls are available:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the music volume is controlled by `Mix_VolumeMusic()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The parameter for `Mix_VolumeMusic()` is an `int` value between `0` and `128`
    to set the new volume, or a value of `-1` to query the current volume of the music.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: By using the default `SDL_mixer` calls, we can only play one music track once
    or with an infinite number of loops. If a dynamic music system is required, a
    manual implementation is needed, or even a different sound replay API should be
    considered. For the simple ability to advance to the next track in a playlist
    at the end of a track, we just need to implement a callback.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Adding a callback for continuous music playback
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SDL_mixer` supports a callback to inform the application that the current
    music track has finished the number of loops. In this callback, we can simply
    forward to the next track in the playlist.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, `SDL_mixer` is a C audio library, and the callback must fulfill the C-style
    calling convention. The C++ calling convention is not compatible with the C calling
    convention and allows only calling static member functions of the `AudioManager`
    class. We need to add a small hack to be able to call a non-static method of the
    `AudioManager` class that has access to the playlist and the current position
    in the playlist.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare a raw pointer named `mCurrentManager` as `private` member
    variable, plus the `private` static `staticMuscFinishedCallback()` member method
    for the C-style callback and a `private` non-static member `musicFinishedCallback()`
    for the translated callback:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `init()` method of the `AudioManager` class, we set the `mCurrentManager`
    pointer to the current instance and call the callback hook setup method `Mix_HookMusicFinished()`
    with the static callback method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Whenever a music track ends now, `staticMusicFinishedCallback()` is called
    by `SDL_mixer`. To translate the callback to C++, we use the pointer to the current
    `AudioManager` instance stored in `mCurrentManager` to call the non-static callback
    `musicFinishedCallback()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside `musicFinishedCallback()`, we can now add code to advance one track
    in the playlist, enabling a continuous replay of all tracks in the playlist:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the music replay is implemented, let’s go to the sound effect replay code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Playing sound effects
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `SDL_mixer` to play sound effects has some subtle differences compared
    to playing music. The main difference is that by default eight sound effects can
    be played at the same time since `SDL_mixer` allocates eight internal sound channels
    for the sound effect output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note that these internal sound channels are not the same as the two output sound
    channels configured when we initialized the audio device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Allocating more or even less than these eight sound channels can be done by
    calling `Mix_AllocateChannels()` with the number of desired channels as a parameter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will use only one channel in the `AudioManager` for now to allow a simple
    implementation of the footstep sound replay.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As `SDL_mixer` has only one channel available now, a second sound effect cannot
    be played if another sound effect is still playing. So, by limiting the number
    of channels to only one, we can avoid creating a complex system to switch between
    walking and running footstep sounds for the example implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a sound file from the file system is similar to the music loading process.
    We call `Mix_LoadWav()` with the C-style character array of the file name and
    store the returned result in a `Mix_Chunk` `struct`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Cleaning up the sound effect is done by calling `Mix_FreeChunk()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Playing and stopping the replay of a sound effect is also like playing or stopping
    the music. A sound effect will be played by using `Mix_PlayChannel()`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first parameter of `Mix_PlayChannel()` is the sound channel to use. The
    special value of `-1` just uses the next available sound channel for the sound
    effect replay. The second parameter is a pointer to the `Mix_Chunk` `struct` to
    play, and the third parameter is again the number of loops.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'As the return parameter of `Mix_PlayChannel()`, we get the sound channel number,
    on which this sound effect is played. We save the channel number in the `mSoundChannel`
    member variable to be able to stop the replay with `Mix_HaltChannel()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Like for the music, we can control the volume of the sound channel by calling
    `Mix_Volume()` with the channel number and desired volume as parameters:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After we know how to play sound effects, we need to add a bit of code to the
    renderer to play a footstep sound whenever our instance is walking or running.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Using the footstep sound effects in the renderer
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of the footstep replay will be just the bare minimum to show
    how and where the callbacks for the sound effects could be added. A full-featured
    sound effects replay system requires much more work and is out of the scope of
    this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To add the footstep sounds, the following piece of code needs to be added to
    the `handleMovementKeys()` method of the renderer, right after we set the next
    state of the instance by calling `setNextInstanceState()`. At this point, we have
    all data about the current movement state of the instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we retrieve the current animation state of the current instance and
    check if the instance is in the idle/walk/run cycle:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索当前实例的当前动画状态，并检查实例是否处于空闲/行走/跑步循环：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We only want to add sound effects at the same time as the walking and running
    animations replay.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在行走和跑步动画回放的同时添加音效。
- en: 'Then we check for the movement state of the instance and call the proper callback
    for the state:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查实例的运动状态，并调用适当的状态回调：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the instance is in the running state, we play the sound effect for running
    footsteps. And if the instance is in the walking state, we play the walking footsteps.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例处于运行状态时，我们播放跑步脚步声音效。如果实例处于行走状态，则播放行走脚步声。
- en: 'If the instance is neither running nor walking, we stop the footstep sounds:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例既不运行也不行走，我们停止脚步声音效：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And if the instance is not in the idle/walk/run cycle, we also stop any sounds.
    This way, we catch all the actions like jumping or punching where no sound effect
    is available yet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例不在空闲/行走/跑步循环中，我们也会停止任何声音。这样，我们可以捕捉到所有尚未提供音效的动作，如跳跃或出拳：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To hear the footsteps sounds, the following steps are required:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要听到脚步声，需要执行以下步骤：
- en: Start the application and load a configuration with animation mapping.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并加载具有动画映射的配置。
- en: Select (or create) a first-person or third-person camera.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择（或创建）一个第一人称或第三人称相机。
- en: Select an instance and set the instance by clicking on **Use Selected Instance**
    in the **Camera** section of the **Control** window of the UI.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI的**控制**窗口的**相机**部分中，选择实例并通过点击**使用所选实例**来设置实例。
- en: Press `F10` to switch to view mode.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`F10`键切换到查看模式。
- en: If you move around the controlled instance now by using the mouse and the *W*/*A*/*S*/*D*
    keys, you should hear two different footstep sounds, depending on the instance
    walking or running around in the virtual world.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在通过使用鼠标和*W*/*A*/*S*/*D*键移动受控实例，你应该听到两种不同的脚步声，这取决于实例在虚拟世界中行走或跑步。
- en: Extending the audio manager class
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展音频管理器类
- en: To outline a possible expansion of the `AudioManager` class to support more
    channels to achieve a more game-like sound management, we would need to keep track
    of the channel playing the footstep sound returned by the `Mix_PlayChannel()`
    call. By reserving one channel exclusively for the local footstep sounds, we can
    achieve the same behavior, but we would be able to play more sound effects at
    the same time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概述`AudioManager`类可能的扩展，以支持更多通道以实现更类似游戏的声音管理，我们需要跟踪`Mix_PlayChannel()`调用返回的播放脚步声音通道。通过为本地脚步声保留一个专用通道，我们可以实现相同的行为，但我们将能够同时播放更多音效。
- en: Handling multiple sound effects can be achieved by adding a creating a pool
    of sound channels and adding a callback to the `Mix_ChannelFinished()` SDL function,
    similar to `Mix_HookMusicFinished()`. SDL triggers the `Mix_ChannelFinished()`
    callback whenever a channel has finished the current sound clip, or when `Mix_HaltChannel()`
    is called and delivers the number of the finished sound channel in the callback.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个声音通道池并向`Mix_ChannelFinished()` SDL函数添加回调，可以实现对多个音效的处理，类似于`Mix_HookMusicFinished()`。SDL在通道完成当前音剪辑或调用`Mix_HaltChannel()`时触发`Mix_ChannelFinished()`回调，并在回调中传递完成的声音通道编号。
- en: The sound channel pool can be updated when a sound effect is played and when
    the effect replay has finished. By using the distance to the object creating the
    sound effect and scaling down the volume of the channel with `Mix_Volume()` or
    by using `Mix_SetDistance()`, the different distances of the source can be modeled.
    In addition, `Mix_SetPanning()` can be used to adjust the position of the sound
    source to the left and right.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当播放音效和音效回放完成后，可以更新声音通道池。通过使用产生音效的对象的距离并使用`Mix_Volume()`或`Mix_SetDistance()`缩小通道音量，可以模拟不同源的距离。此外，可以使用`Mix_SetPanning()`调整声音源的位置到左右。
- en: Several tasks in the *Practical sessions* section are available to evolve the
    sound replay from the current state.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在“实际操作”部分中，有几个任务可用于从当前状态演变声音回放。
- en: As an example of how to use the `AudioManager` callbacks from the `UserInterface`
    class, a simple music replay control has been added to the user interface. In
    the **Music & Sound** section of the **Control** window, you will find a combo
    box and some buttons to play the music from the playlist created from the `assets/music`
    folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Using the music player in the UI
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding music replay functionality to the `UserInterface` class is a quick and
    simple task. By using the callbacks to the `AudioManager` class, a basic music
    player is implemented with only a few code blocks to the UI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 14.2*, the ImGui section with a basic music player using the `AudioManager`
    class is shown:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_02.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: A music player based on the AudioManager added to the user interface'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The desired music track to play can be chosen by using the **Tracks** combo
    box, the current track can be played by pressing the **Play** button, or a random
    track from the playlist will be chosen from the shuffled playlist by pressing
    **Play Random**. The other four buttons, **Prev**, **Pause**, **Stop**, and **Next**,
    do exactly what the label states, and by using the sliders, the volume of music
    and sound effects can be set to a value between `0` (for silence) and `128`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Alternative sound manager implementations
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AudioManager` class used for the application uses a straightforward implementation
    with direct control through C++ callback functions. For an advanced sound system,
    an event- or message-based implementation could be used. Such an implementation
    can use event managing code already in the game, and events or messages also decouple
    the sound effects replay from the code that is requesting to replay a sound effect
    or a music change.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: After having sound and music available in the virtual world, an update to the
    graphics of the application may appear also on the to-do list. Let’s explore some
    visual enhancements now.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing visuals
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenGL and Vulkan renderers in the example code support only a minimal
    set of features to bring an image to the screen: Both renderers can only draw
    textures triangles and colored lines. Adding one or more of the following enhancements
    will be a fantastic extension to the quality of the images.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Bringing colors to the world by using physically based rendering
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, we are using only the textures of the Assimp objects to render the
    model instances and level geometry to the screen. By using **physically based
    rendering**, short **PBR**, we could also model surface properties in the form
    of materials. With such PBR materials, it is easy to create surfaces that have
    a shininess and reflectivity of metal or make surfaces like concrete or bricks
    look more natural.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.3* shows spheres drawn by the Vulkan PBR example code from Sascha
    Willems (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_03.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Different PBR materials'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.3*, the reflectiveness of the environment is
    set to a high value, resulting in a golden sphere. Between the spheres, the reflection
    settings change gradually, and on the right side, no reflectiveness at all is
    set.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: A link to the source code of the PBR rendering and other examples is available
    in the *Additional resources* section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Adding transparency
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A virtual world without windows and objects made of transparent materials may
    feel a bit strange since we are surrounded by transparent objects in the real
    world. However, rendering transparency is tricky due to the physics behind the
    color changes of the light on the path through more than one transparent object,
    requiring multiple transparent pixels on the same screen position to be drawn
    from back to front to calculate the correct final color for a pixel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Two different approaches exist, called ordered and order-independent transparency.
    While ordered transparency requires all transparent objects to be sorted from
    back to front, order-independent transparency rearranges the pixels to be drawn
    by itself into the correct order. Both methods have advantages and disadvantages,
    so the best way to choose is to test both versions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.4* shows two transparency examples from LearnOpenGL ([https://learnopengl.com/](https://learnopengl.com/))
    by Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_04.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Transparent plants (left) and translucent red glass (right)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.4*, partially transparent plants are rendered.
    By discarding pixels in the empty areas of the texture, a realistic effect of
    a plant can be achieved. On the right side of *Figure 14.4*, colored glass is
    rendered. Imitating glass for windows and other translucent objects by using transparent
    textures helps to create a better copy of the real world.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Looking up at a beautiful sky
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you start the virtual world created with the example code of the book and
    load a level that is partially made to be outside of a building, you will not
    see some sort of sky but just the default background color. Adding a beautiful
    sky to the scene requires not just a simple sky texture, but also a so-called
    cubemap and a distorted sky texture.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: A cubemap is a special kind of rendering object that represents the six sides
    of a cube, and the sky texture is projected onto the cubemap. The resulting skybox
    will create a seamless background that follows the view of the virtual camera,
    placing the level geometry and the instances into a realistic environment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.5* shows a skybox as environment around a wooden box, created with
    code from LearnOpenGL ([https://learnopengl.com/](https://learnopengl.com/)) by
    Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez)):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_05.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: A wooden box with a skybox as the background'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The effect of using a skybox can be seen best when moving the view around. In
    a static picture like in *Figure 14.5*, the difference between the wooden box
    and the skybox can be seen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动视图时，可以看到使用天空盒的效果。在静态图片如*图14.5*中，可以看到木质盒子与天空盒之间的区别。
- en: We will implement a skybox to our virtual world at the end of this section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节结束时在我们的虚拟世界中实现一个天空盒。
- en: Playing with light and shadows
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转光与阴影
- en: The current vertex shaders are using a hard-coded light source as virtual sun,
    emitting white light from a fixed position into the world. This basic lighting
    helps to identify the dimensions of the level geometry and the instances, even
    by using only flat shading. By adding more lights to the virtual world, other
    light-emitting objects can be modeled in a more realistic way, such as lamps,
    lanterns, fire, or torches. The flickering light of a fire in a dark place can
    be used to create various kinds of tension since it could mean a safe place to
    stay the night or an enemy position.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的顶点着色器正在使用一个硬编码的光源作为虚拟太阳，从固定位置向世界发射白光。这种基本照明有助于识别关卡几何形状和实例的尺寸，即使只使用平面着色也能做到。通过向虚拟世界添加更多灯光，可以以更逼真的方式模拟其他发光物体，例如灯具、灯笼、火焰或火炬。在黑暗的地方，火焰的闪烁灯光可以用来创造各种类型的紧张感，因为它可能意味着一个可以过夜的安心地方或敌人的位置。
- en: 'The scene in *Figure 14.6* is illuminated by several thousand different colored
    light sources:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.6*中的场景由几千种不同颜色的光源照亮：'
- en: '![](img/figure_14_06.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_14_06.png)'
- en: 'Figure 14.6: Multiple lights in a virtual world (image courtesy of Hannes Nevalainen)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：虚拟世界中的多光源（图片由汉内斯·内瓦莱宁提供）
- en: The image in *Figure 14.6* is a tech demo for the jMonkeyEngine made by Hannes
    Nevalainen, and the effect of many individual lights can be seen. The full video
    is available in the *Additional resources* section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.6*中的图像是由汉内斯·内瓦莱宁制作的jMonkeyEngine技术演示，可以看到许多单独灯光的效果。完整的视频可在*附加资源*部分查看。'
- en: When lights are added, shadows should be implemented too. For a simple start,
    the shadows of the objects cast by the virtual sun could be projected to the ground
    by using the so-called shadow mapping, creating the impression of lights and shadows
    taken from the real world. Shadows for the other lights can be added too, although
    the implementation is more complex. But the visual results will compensate for
    the effort as a lamp casting only the lit part of a window to the ground will
    bring a big smile to the programmer’s face.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加灯光时，也应该实现阴影。作为一个简单的开始，可以通过所谓的阴影映射将虚拟太阳投射出的物体阴影投影到地面上，从而产生从现实世界获取的光影效果。也可以为其他灯光添加阴影，尽管实现起来更复杂。但视觉效果将弥补这种努力，因为只有将窗户的亮部投射到地面的灯会为程序员带来大大的微笑。
- en: '*Figure 14.7* was created from the Vulkan example code made by Sascha Willens
    (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)),
    showing the shadows of trees created by using cascaded shadow maps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.7*是由萨沙·威尔伦斯制作的Vulkan示例代码创建的，代码可在[https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)找到)，展示了使用级联阴影映射创建的树木阴影：'
- en: '![](img/figure_14_07.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_14_07.png)'
- en: 'Figure 14.7: Cascaded shadow maps of trees'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：树木的级联阴影映射
- en: Similar to the skybox, the effect of using shadow maps can be seen much better
    when light, objects, and/or cameras are moving. Shadows like in *Figure 14.7*
    are a great addition to the virtual world.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与天空盒类似，当光、物体和/或相机移动时，使用阴影映射的效果可以看得更清楚。如图14.7所示的阴影是虚拟世界的一个很好的补充。
- en: Swimming in realistic water
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在逼真的水中游泳
- en: If water was added as part of the extended level environment, the visual appearance
    should also be checked and enhanced. While using a simple, static transparent
    water texture may be fine for the first implementation, the urge to create better
    water may come up at some point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将水作为扩展关卡环境的一部分添加，也应该检查并增强其视觉外观。虽然使用简单的静态透明水纹理可能对第一次实现来说足够好，但最终可能会产生创建更好水的需求。
- en: By using a combination of reflection, refraction, and distortion of the light
    hitting the virtual water surface, realistic water can be created, and if the
    player should be able to dive into the water, a different kind of distortion could
    be utilized to create the illusion of being underwater.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.8* shows a water simulation made in WebGL by Evan Wallace (the code
    is available at [https://github.com/evanw/webgl-water/blob/master/index.html](https://github.com/evanw/webgl-water/blob/master/index.html)):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_08.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Realistic water with waves and underwater caustics (courtesy of
    Evan Wallace)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 14.8*, the waves of the sphere falling into the water can be seen.
    Also, the refraction of the walls created by the water and the refraction of the
    light on the bottom of the pool are clearly visible.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Adding stunning post-processing effects
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For even more realism in the virtual world, post-processing effects can be
    added to the renderers. The list of possible effects is long, so here is just
    a brief list of ideas that can be implemented quite quickly while creating great
    visuals:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Lens flares for the illusion of looking through a camera
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'God rays: visible rays in haze when the direct view into the sun is blocked'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bloom effect simulating glowing objects
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion blur blurring the image when the view is moved
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth of field blurring the world around a sharp center
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen Space Ambient Occlusion darkening gaps and edges
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen Space Reflection, a cheap way to create reflective surfaces
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these effects are created by using shaders and have different performance
    impacts. Nevertheless, even a bunch of the effects listed here will give the visual
    appearance a huge boost.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.9* shows two post-processing effects, Bloom and **Screen Space Ambient
    Occlusion** (**SSAO**). The Bloom effect was created with code from LearnOpenGL
    ([https://learnopengl.com/](https://learnopengl.com/)) by Joey de Vries ([https://x.com/JoeyDeVriez](https://x.com/JoeyDeVriez))
    and the SSAO picture is made with code from Sascha Willems’ Vulkan examples (the
    code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_09.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Bloom (left) and SSAO (right)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.9*, the Bloom effect is shown. The characteristic
    part of the Bloom effect is the halo effect around the light sources. For the
    green light source, the light even overlaps the top left edge of the wooden crate.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right side of *Figure 14.9*, SSAO is shown. The SSAO effect may be subtle,
    but it is visible: look at the floor below the curtains on the right side of the
    white line. The shadow creates the illusion of a darker room behind the curtains.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading to ray tracing
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the next step to realism, ray tracing can be added as an optional enhancement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing uses virtual light rays emitted from the camera to compute the resulting
    pixel color by following the ray through the collisions with objects in the virtual
    world. Instead of just using the object color, the virtual ray is reflected by
    the physical rules and followed until the amount of light added falls below a
    threshold.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: With ray tracing, effects like a global illumination of the world, causing dark
    areas to be lit by light being reflected from the objects, or realistic reflections
    could be achieved. Imagine running through a room full of mirrors and seeing your
    character multiple times, drawn in a correct physical way.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.10* shows a scene created by a ray tracing example from Sascha Willems
    Vulkan code (the code is available at [https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl](https://github.com/SaschaWillems/Vulkan/tree/master/examples/pbribl)):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_10.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Real-time ray tracing scene'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The reflections on the floor, the spheres, and the teapot in *Figure 14.10*
    are calculated in real time by using ray tracing with the Vulkan API on an Nvidia
    RTX 4000 series GPU.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The FPS counter was included to show how fast the current GPU generation is
    able to create ray tracing images. Only a few decades ago, a single frame of the
    same picture required several days to render.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing should be optional
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Note that the calculations for ray tracing require lots of computing power and
    creating complex scenes in real time needs both a GPU and a graphics API that
    support ray tracing. Right now, only Vulkan and DirectX 12 are able to use the
    ray tracing capabilities of modern GPUs. You need to check the availability of
    hardware and software support before switching to a graphics pipeline with ray
    tracing enabled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Diving into virtual reality
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though virtual reality (VR) is still a small niche, implementing VR support
    can be a great step ahead for immersion. Being able not just to see the virtual
    world on a flat screen but to stand right in the middle of the world can become
    a memorable moment for a player. Using head tracking to move the virtual camera
    simultaneously to the head of the player and adding virtual hands for the VR controllers
    creates a lot of new opportunities for interaction.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.11* shows a scene from the Godot XR Tool Demo (the code is available
    at [https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template)):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_11.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Godot XR Tools Demo'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The most notable detail of *Figure 14.11* is the two virtual hands. By using
    the integrated sensors of the Valve Index® controllers, not only the position
    of the controllers can be deduced in all 6 degrees of freedom, but also the individual
    fingers can be tracked to allow gestures or actions depending on the position
    of a finger.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: After the theoretical part of this section, we will now add a skybox to the
    application, acting as the global background.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Hands-on: Adding a skybox to the virtual world'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A virtual sky is a great addition to a virtual world, especially above any open
    areas, as shown in *Figure 14.5*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the technical details
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the technical side, a skybox is drawn from a texture applied on the inside
    of a unit cube. *Figure 14.12* shows the cube and the coordinates around the virtual
    camera placed in the center of the cube:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_12.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: The sampled area from the inside of a cubemap'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 14.1*2, the red area of the cube will be sampled to create the background
    of the current frame. Note that the area is wrapping around the corner of the
    cube, but that is nothing to worry about. Both graphics libraries take care of
    such edge cases (pun intended) and will sample the respective areas of the two
    affected cube sides.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'The cubemap texture is usually stored as a set of six separate images or as
    a single image with the sides of the cube at specific locations in the image.
    *Figure 14.13* shows a skybox texture made by Jockum Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))
    in a commonly used format plus the cube faces:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_13.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: A cubemap texture and the cube face of each picture'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.13*, an example cubemap texture for a skymap
    is shown. You will find many cubemap textures as this kind of cross. On the right
    side of *Figure 14.13*, the cube faces for each of the smaller sub-images of the
    cubemap texture are listed. Remember that OpenGL and Vulkan with an inverted viewport
    have the negative Z-axis pointing into the virtual world, hence `–Z` for the front
    image.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Another noteworthy detail is the distortion of a cubemap image. Since the cubemap
    texture is applied to a cube but the virtual sky around us can be seen as a sphere,
    the pixels of a cubemap texture must be adjusted to appear as if the image was
    taken with a camera from inside a sphere. In *Figure 14.14*, the discrepancy between
    the projection inside a cube and inside a sphere is shown:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_14.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Sampled point of a cube vs. the corrected projection of a sphere'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: As you can see on the left side of *Figure 14.14*, the difference between a
    sample point taken from the cubemap and the position on the surface of the sphere
    gets larger the more we get near the edge of one side of the cubemap. On the right
    side of *Figure 14.14*, an area sampled from the cubemap and the required projection
    onto the surface of a sphere are highlighted as black bars. You can see that both
    the size and the angle of the areas differ. When building a cubemap texture for
    a skybox, a spherical distortion of the images for each of the cube faces must
    be applied to create a plausible sky.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the skybox
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding the skybox to the code needs only a few components:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: New vertex and mesh types
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new vertex buffer
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit cube model containing the coordinates of the faces.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含面坐标的单位立方体模型。
- en: A new shader
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的着色器
- en: Loading a cubemap texture from a file
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中加载立方体贴图纹理
- en: 'We start with creating a new vertex type called `OGLSkyboxVertex` and a new
    mesh type called `OGLSkyboxMesh` in the `OGLRenderData.h` file in the `opengl`
    folder:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`opengl`文件夹中的`OGLRenderData.h`文件中创建一个新的顶点类型`OGLSkyboxVertex`和一个新的网格类型`OGLSkyboxMesh`：
- en: '[PRE36]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As always, for Vulkan, the two new `struct` elements must be added to the `VkRenderData.h`
    file in the `vulkan` folder. For all the details of the Vulkan implementation,
    check the renderer class file, `VkRenderer.cpp`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，必须将两个新的`struct`元素添加到`vulkan`文件夹中的`VkRenderData.h`文件中。有关Vulkan实现的详细信息，请查看渲染器类文件`VkRenderer.cpp`。
- en: 'While we could reuse the vertex buffer of the models, doing so would waste
    a lot of resources since the cube only needs the position data for the vertices.
    The new vertex buffer class called `SkyboxBuffer` uses only the `position` element
    of the new vertex, `struct` `OGLSkyboxVertex`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以重用模型的顶点缓冲区，但这样做会浪费大量资源，因为立方体只需要顶点的位置数据。新的顶点缓冲区类`SkyboxBuffer`仅使用新顶点的`position`元素，`struct`
    `OGLSkyboxVertex`：
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For the cube model, we create a class called `SkyboxModel` returning an `OGLSkyboxMesh`
    consisting of 36 vertices, using two triangles for each side. In all three axes,
    the model coordinates are either `1.0` or `-1.0`, defining a unit cube.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体模型，我们创建一个名为`SkyboxModel`的类，返回一个由36个顶点组成的`OGLSkyboxMesh`，每个侧面使用两个三角形。在所有三个轴上，模型坐标要么是`1.0`要么是`-1.0`，定义了一个单位立方体。
- en: 'The new vertex shader named `skybox.vert` outputs a `vec3` with 3-dimensional
    texture coordinates. We need 3-dimensional coordinates here since we are inside
    a cube:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 新的顶点着色器`skybox.vert`输出一个包含三维纹理坐标的`vec3`。在这里我们需要三维坐标，因为我们处于一个立方体内部：
- en: '[PRE38]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `main()` method of the vertex shader, we invert the projection matrix
    and transpose the view matrix first:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器的`main()`方法中，我们首先反转投影矩阵并转置视图矩阵：
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For the view matrix, we can use a cheaper transpose operation instead of taking
    the inverse matrix since we need to get rid of the translational part to stop
    the cube moving around with the camera.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图矩阵，我们可以使用更便宜的转置操作而不是取逆矩阵，因为我们需要去除平移部分以停止立方体随摄像机移动。
- en: 'By multiplying the inverse matrices with the incoming point positions of the
    cube, we calculate the texture coordinates in world space:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将逆矩阵与立方体的传入点位置相乘，我们计算世界空间中的纹理坐标：
- en: '[PRE40]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the texture coordinates to sample are from the inside of the cube, as shown
    in Figure *14.12*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要采样的纹理坐标来自立方体的内部，如图*14.12*所示。
- en: 'As the last step for the vertex shader, we set the GLSL-internal variable `gl_Position`
    to the incoming vertex position:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为顶点着色器的最后一步，我们将GLSL内部变量`gl_Position`设置为传入的顶点位置：
- en: '[PRE41]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By setting the `z` component of `gl_Position` to the value of the `w` component,
    we make sure to draw the pixels of the cubemap on the far-Z plane, creating a
    background that will not be overwritten by other pixels.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`gl_Position`的`z`分量设置为`w`分量的值，我们确保在远-Z平面上绘制立方体贴图的像素，从而创建一个不会被其他像素覆盖的背景。
- en: 'The new fragment shader, `skybox.frag`, uses the incoming texture coordinates
    to look up the texture data in the cubemap:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 新的片段着色器`skybox.frag`使用传入的纹理坐标在立方体贴图中查找纹理数据：
- en: '[PRE42]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please note that the type of the texture `tex` is a `samplerCube` and not a
    `sampler2D` like on the other fragment shaders.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，纹理`tex`的类型是`samplerCube`而不是其他片段着色器中的`sampler2D`。
- en: 'Loading the cubemap texture is done in the `Texture` class. In the new `loadCubemapTexture()`
    method, we load an image shown in *Figure 14.1*3 and extract the six images. And
    since the values of the values of the texture map side definitions are in ascending
    order, we can just use the first side definition `GL_TEXTURE_CUBE_MAP_POSITIVE_X`
    and add an integer value for the remaining sides to upload:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图纹理的加载在`Texture`类中完成。在新的`loadCubemapTexture()`方法中，我们加载如图*14.1*3所示的图像并提取六个图像。由于纹理映射侧面定义的值是按升序排列的，我们可以直接使用第一个侧面定义`GL_TEXTURE_CUBE_MAP_POSITIVE_X`并为剩余的侧面添加整数值以上传：
- en: '[PRE43]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For the full implementation of the cubemap texture loading, please check the
    details in the `Texture` class.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体贴图纹理加载的完整实现，请查看`Texture`类的详细信息。
- en: Drawing the skybox
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制天空盒
- en: 'Bringing the skybox to the screen is now done in two steps. First, we upload
    the unit cube model data to the vertex buffer in the `init()` method of the `OGLRenderer.cpp`
    renderer class file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, before drawing the level data, we draw the skybox by using the new shader,
    binding the texture and drawing the cube from the vertex buffer:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For Vulkan, we also upload the skybox model and the texture in the `init()`
    method of the `VkRenderData.cpp` file, bind the skybox pipeline, and draw the
    skybox model before the level data in the `draw()` method.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'For both OpenGL and Vulkan renderers, a simple change should be made when drawing
    the skybox as the first object: disabling the depth test function. Without the
    depth test, the skybox texture overwrites all values of the previous color buffer,
    acting as the global background for the remaining objects, such as level data
    and instances. And that’s all.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything was added correctly, the new and glorious sky above the level
    can be seen in *Figure 14.15* (the image is made from glTF level created by Zarudko
    ([https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)) using a texture created by Jockum
    Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))
    as the skybox):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_15.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: Example level with an activated skybox'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 14.15*, the skybox brings a real-world feel to levels
    with open areas. And since the cube does not move when the view changes like the
    level data, the illusion of an infinitely distant sky is created.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: But even with great graphics and cool sound effects and music, there’s room
    for improvement. The environment of the virtual world is still somehow static,
    so let’s add changes to the world itself.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Extending immersion with daytime and weather
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although they are natural phenomena in our lives, the cycle between day and
    night, weather effects, and different seasons are rarely used in computer games.
    But all these aspects can be a great boost for immersion in a game. Slight changes
    to the virtual world depending on an internal clock may help to create an environment
    that a player wants to stay in for a much longer time to experience the full cycle.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Adding a day/night cycle
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A day/night cycle adds some sort of familiarity to a game. Seeing the sun rise
    or enjoying a colorful sunset, watching the changes when running through the world
    around noon or late at night… every aspect will remind the player of being in
    a more realistic world. And if not only the light changes, but also other characters
    and animals react to the time of day, the immersion will become better and better.
    For instance, it may be good to see some animals only at night, and kids only
    in the morning, characters appearing at work at some time and leaving for a pub
    in the afternoon.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The in-game time could be running much faster than real time, reducing an entire
    day to a couple of minutes. Such a speedup can help if events that are frequently
    needed only occur at a specific time of the day.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular examples of the day/night cycle is Minecraft. A full
    day in Minecraft lasts 20 minutes by default, split into a 10-minute day and a
    10-minute night. And since the light level changes, enemy spawning and food and
    tree growing behave completely differently in the day and the night.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.16* shows the same spot in our application at noon and at night:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_16.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: Day and night in the example code from *Chapter 14*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 14.16*, even a simple change in the overall brightness
    of the virtual world could make an enormous difference. And changing more properties
    of the world depending on the time of day will bring more immersion for the player.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Allowing forward time travel
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with time, one fact should not be underestimated: the time waiting
    for an event to happen can be boring and passes slowly. Instead of keeping the
    player waiting for the entire day or night to pass, special “time travel” events
    could be added, such as sleeping through the night, or waiting at a fireplace
    to let the time pass, having the game fast-forwarding the in-game time.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Playing in real time
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thinking about the time in a game, the idea of synchronizing the time in the
    virtual world to the time of the real world can be an interesting option. Only
    a few games utilize such a feature. Also, solving tasks or quests may be more
    complicated if they are bound to a special time of the day. But being “now” in
    a game may be fun.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Worshipping the weather god
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not only may the time of day change the world, but weather changes can also
    greatly influence characters, animals, and the environment. During a thunderstorm,
    the best advice is to stay inside, heavy rain may be so loud that other sounds
    never reach the player’s ears, and fresh snow will also absorb noises. So, roaming
    around in various weather states can give entirely different impressions of the
    same world.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Environmental changes such as the addition of fog also change the perception
    of the virtual world.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.17* shows different types of fog in our application:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_17.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: The effect of fog in the example code from *Chapter 14*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of *Figure 14.17*, the virtual world is completely without
    fog, showing a clear day. In the middle of *Figure 14.17*, heavy fog was added,
    causing the world to fade out after a short distance. Fog was used in several
    old games to hide the appearance and disappearance of objects due to rendering
    limitations in early game engines. Finally, on the right side of *Figure 14.17*,
    the light color was adjusted to a green tone, creating the illusion of toxic fog
    in the streets of the map.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the oracle of seasons
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next evolutionary step after a day/night cycle and weather would be the
    implementation of the four seasons. The rotation between Spring, Summer, Fall,
    and Winter is a great opportunity to bring even more reality into the virtual
    world as the actions of characters or the appearance of animals will change throughout
    the year.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在昼夜循环和天气之后，下一个进化步骤是实现四个季节。春、夏、秋、冬之间的旋转是带来更多现实感的绝佳机会，因为角色的行为或动物的外观将在一年中发生变化。
- en: Like the length of the in-game day, a virtual year should be shortened to a
    reasonable amount of real time, or a forward time travel functionality should
    be allowed if all tasks in the current season have been finished. Letting the
    player wait for no reason will kill their enthusiasm.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 就像游戏中的白天长度一样，一个虚拟年应该缩短到合理的时间量，或者如果当前季节的所有任务都已经完成，应该允许向前时间旅行功能。让玩家无理由地等待将会扼杀他们的热情。
- en: 'A good example of the changing world properties depending on the season is
    “Legend of Zelda: Oracle of Seasons” by Nintendo for the GameBoy Color. Despite
    the age of the game, the changes of the seasons have been implemented with great
    detail, allowing the player to enter some areas of the world only in specific
    seasons. For instance, rivers are only frozen in Winter and snow fields elevate
    the parts of the landscape, while only in Summer, flower tendrils enable Link
    to climb up walls.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一个根据季节变化世界属性的好例子是任天堂为GameBoy Color开发的《塞尔达传说：时之笛》。尽管游戏年代久远，但季节的变化已经以极大的细节实现，允许玩家仅在特定季节进入世界的某些区域。例如，河流在冬季会结冰，雪地会抬高景观的部分，而只有在夏季，花朵的卷须才能让林克攀爬墙壁。
- en: In “Stardew Valley” by Eric Barone, seasons are also a key element of the gameplay.
    Each of the four seasons influences different parts of the game, like crop growth.
    A season is 28 in-game days long, and by accelerating the time, an entire year
    in Stardew Valley elapses in 26 hours of in-game time.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eric Barone的《星露谷物语》中，季节也是游戏玩法的关键元素。每个季节都会影响游戏的不同部分，如作物生长。一个季节是28个游戏日，通过加速时间，星露谷的一年将在26个小时的游戏时间内流逝。
- en: For the application, we will create simple day/night light changes and fog as
    examples. Let’s start with day and night.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，我们将创建简单的昼夜光线变化和雾作为示例。让我们从昼夜变化开始。
- en: 'Hands-on: Adding day and night'
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亲身体验：添加昼夜变化
- en: Changing the light source’s color and position is easy. Most of the fragment
    shaders already contain a fixed light source definition to allow better visualizations
    of the instances and the level data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 改变光源的颜色和位置很容易。大多数片段着色器已经包含一个固定的光源定义，以便更好地可视化实例和关卡数据。
- en: Implementing light control
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现光线控制
- en: 'As the first step, we add two new variables called `lightPos` and `lightColor`
    to the `Matrices` `uniform` in all vertex and fragment shaders where `Matrices`
    exists:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们在所有存在`Matrices`的顶点和片段着色器中的`Matrices``uniform`中添加了两个新变量，分别称为`lightPos`和`lightColor`：
- en: '[PRE46]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In `lightPos`, we will hand over the current position of the light source, allowing
    us to simulate the position of the Sun or Moon in the virtual world, and in `lightColor`,
    we transport the color of the light source to the GPU, enabling us to simulate
    sunrise, noon, sunset, and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lightPos`中，我们将传递光源的当前位置，使我们能够模拟虚拟世界中太阳或月亮的位置，而在`lightColor`中，我们将光源的颜色传输到GPU，使我们能够模拟日出、正午、日落等。
- en: 'Since we defined the uniform buffer containing the view and projection matrix
    on the CPU to use `glm::mat4` as the data type, we must add the two `glm::vec4`
    vectors for the light position and color as the first two elements of a `glm::mat4`
    that will be uploaded to the GPU before drawing the frame:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在CPU上定义了包含视图和投影矩阵的统一缓冲区，并使用`glm::mat4`作为数据类型，我们必须添加两个`glm::vec4`向量作为`glm::mat4`的前两个元素，这些元素将在绘制帧之前上传到GPU：
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now all fragment shaders containing the light source definitions can be adjusted
    with a better light control for the surfaces.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有包含光源定义的片段着色器都可以通过更好的表面光线控制进行调整。
- en: 'We start the new shader code in the `main()` method by defining the ambient
    light level:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`方法中开始编写新的着色器代码，通过定义环境光级别来启动：
- en: '[PRE48]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The ambient light level is used to simulate the light scattering from other
    surfaces, enabling some sort of minimal lighting in the virtual world. By limiting
    the minimal ambient light, we also prevent the resulting picture from becoming
    pitch black.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we calculate the diffuse part by using the angle between the triangle
    normal and the direction of the light source:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The diffuse lighting of a surface changes with the angle between the surface
    and the light source. As the dot product of two normalized vectors equals the
    cosine of the angle between the two vectors, we can use the result of the `dot()`
    call directly as a multiplier of the light source color.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step for the fragment shader code changes, we add up ambient and
    diffuse light and multiply the resulting light value by texture data and vertex
    color:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can now control the position and color of the light source from the application,
    and by sending a spherical position and a color, various times of the day can
    be simulated.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI control
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To control the light values, a new UI section will be created, enabling fine-grained
    settings of all light-related values. *Figure 14.18* shows the new **Environment**
    section in the `UserInterface` class:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_18.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: UI controls for light parameters and skybox'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: By splitting the light angle into east/west and north/south, we can move the
    light around to any position of the virtual sky. The light intensity can be used
    to lower the overall brightness of the light without manually touching the color
    values.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: With the separate light color values, we can adjust the light to match the natural
    colors of the Sun or the Moon, at least within the limitations of the available
    color space, and by using a set of predefined color values, we can set the light
    color, intensity, and position immediately to a specific time of the day.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14.19* shows three different light settings for the virtual world (this
    image is created using the map by Zarudko ([https://skfb.ly/6QYJw](https://skfb.ly/6QYJw))
    and the skybox image is by Jockum Skoglund (aka hipshot – [https://opengameart.org/content/stormy-days-skybox](https://opengameart.org/content/stormy-days-skybox))):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_14_19.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.19: The virtual world in the morning, at noon, and in the evening'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: You can see in *Figure 14.19* that just changing the color of the light source
    can create entirely different moods in the virtual world. Combined with the skybox
    from the *Enhancing visuals* section, you can already create truly immersive worlds.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored ideas and tools to show how to upgrade the current
    animation editor to a small game engine with a built-in editor.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: First, we looked at a couple of audio libraries and when to play sound effects
    and music in a game. Sound effects and music are essential parts of the player’s
    experience, creating a basic form of immersion as the experience of the real world
    will be transferred to the virtual world.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们探讨了几个音频库以及何时在游戏中播放音效和音乐。音效和音乐是玩家体验的重要组成部分，它们创造了一种基本的沉浸感，因为现实世界的体验将被转移到虚拟世界中。
- en: Then, we explored visual enhancements to the graphics of the application. Extending
    the basic renderer with transparency, a skybox, dynamic lights and shadows, realistic
    water, and post-processing effects such as God rays and motion blur will bring
    the visuals to the next level. Even though it’s optional due to the limited target
    group, adding support for ray tracing and VR could become viable options as both
    features are a big step forward in terms of visual quality and immersion.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了应用程序图形的视觉增强。通过扩展基本渲染器以实现透明度、天空盒、动态光影、逼真的水面以及后处理效果，如上帝射线和运动模糊，将视觉提升到下一个水平。尽管由于目标群体有限，添加对光线追踪和VR的支持是可选的，但这两个功能在视觉质量和沉浸感方面都是一大步，因此可能成为可行的选项。
- en: As the last step, we explored a day/night cycle, weather, and seasons as elements
    to change the environment of the virtual world. Already, a simple cycle of a day
    adds a lot of interesting opportunities to the virtual world, such as only meeting
    computer-controlled characters or animals at a certain time of the day or enemies
    that only appear at night. Weather effects and seasons also multiply the options
    to change behavior depending on the current environment.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们探讨了日/夜循环、天气和季节作为改变虚拟世界环境元素。仅仅是一个简单的日循环就为虚拟世界增加了许多有趣的机会，例如在一天中的特定时间只遇到计算机控制的角色或动物，或者只在夜间出现的敌人。天气效果和季节也增加了根据当前环境改变行为的选择。
- en: So... what to do next? Well, that’s completely up to you!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 那么...接下来该做什么呢？嗯，这完全取决于你！
- en: You could start by learning how to use **Blender** to create your own animated
    characters, animals, objects, and levels. The created assets don’t have to be
    of the quality of recent games; even low-poly worlds are charming and have many
    fans. There are lots of books, tutorials, and videos available, handling many
    different art styles for virtual worlds.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从学习如何使用**Blender**来创建自己的动画角色、动物、物体和关卡开始。创建的资产不必达到最近游戏的品质；即使是低多边形世界也很迷人，并且拥有许多粉丝。有许多书籍、教程和视频可供选择，涵盖了虚拟世界中的许多不同艺术风格。
- en: What about adding more objects? Vehicles and animals would enrich the virtual
    world, and doors and buttons lead to a lot more ways to interact with the world.
    For better gravity, you might even add a physics engine to the application, enabling
    other cool features such as force distribution on collisions between objects.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 关于添加更多物体？车辆和动物将丰富虚拟世界，门和按钮将带来更多与世界互动的方式。为了更好的重力，你甚至可能需要向应用程序中添加物理引擎，使物体之间的碰撞产生力分布等酷炫功能。
- en: You might also explore the world by using a camera with orthogonal projection.
    Watching the player, other characters, and the environment in an isometric projection
    or only from the side could open new ways of expressing a story. Since both the
    isometric projection and the side view are only different views of the three-dimensional
    world, all options mentioned in this chapter also apply when using the orthogonal
    projection.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用具有正交投影的相机来探索世界。以等距投影或仅从侧面观察玩家、其他角色和环境可以开辟新的表达故事的方式。由于等距投影和侧面视图只是三维世界的不同视角，因此本章中提到的所有选项在使用正交投影时也适用。
- en: Another idea could be the creation of a storyline and quests for the player
    to handle. Forcing the player to move between various locations and interact with
    different characters to unlock more quests, items, or doors, or just to receive
    the next piece of the mental puzzle about a quest could engage the player to stay
    longer in your game.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法可能是为玩家创建故事情节和任务。强迫玩家在各个地点之间移动并与不同角色互动以解锁更多任务、物品或门，或者只是接收关于任务的心理谜题的下一部分，这可以让玩家在你的游戏中停留更长时间。
- en: Or you could dive into the networking part of SDL and create a small network
    server, allowing you to explore the virtual worlds with your friends. Roaming
    around the levels and solving quests as a team is satisfying and brings new complexity
    to the quest system since you may or may not allow the players to use their shared
    knowledge of a quest over a long distance.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is the most important next step: stay curious and experiment with
    the code.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additions you could make to the code:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Add a button to reload the music tracks from the asset folder.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nice-to-have feature to dynamically add or remove tracks.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Add more sound effects for the instances.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could map a sound clip to every action of the instances, creating more realistic
    effects when controlling the selected instance.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Play the step sound depending on the floor material.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, you need to load more than one pair of footstep sounds for walking and
    running. The appropriate sound effect could be chosen by using the mesh type of
    the ground triangle as the index into the footstep sounds.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Add sounds for nearby instances.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SDL_mixer` library allows us to set the volume and balance per channel.
    Using the distance and angle of the surrounding instances can be used to calculate
    the effective volume and direction of the sounds.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Play ambient sound at special places on the map.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the waypoint models, you could use small models as markers to play
    an ambient sound. And like the sounds for nearby instances, the volume and balance
    of the ambient sound can be adjusted to match the expectation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Add markers for music changes.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This task is closely related to the ambient sound. You could use models and/or
    nodes to switch the music when your controlled instance enters a specific area
    of the map or interacts with other instances.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Adjust level color and fog depending on the level location.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only can the music be changed when roaming through the level; also, the
    light and fog settings can be adjusted. For instance, when entering a cave, the
    ambient light can be lowered and the fog density can be raised.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SDL: [https://www.libsdl.org](https://www.libsdl.org%0D%0A)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenAL Soft: [https://github.com/kcat/openal-soft](https://github.com/kcat/openal-soft%0D%0A)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PortAudio: [https://www.portaudio.com](https://www.portaudio.com%0D%0A)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FMOD: [https://www.fmod.com](https://www.fmod.com%0D%0A)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Game Physics Engine Development* by *Ian Millington*, published by *CRC Press*:
    ISBN 978-0123819765'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Game Physics by David H. Eberly*, published by *Morgan Kaufmann*: ISBN 978-0123749031'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open-source physics engine: [https://www.tapirgames.com/blog/open-source-physics-engines](https://www.tapirgames.com/blog/open-source-physics-engines%0D%0A)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vulkan examples by Sascha Willems: [https://github.com/SaschaWillems/Vulkan](https://github.com/SaschaWillems/Vulkan%0D%0A)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordered transparency: [https://learnopengl.com/Advanced-OpenGL/Blending](https://learnopengl.com/Advanced-OpenGL/Blending%0D%0A)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Order-independent transparency: [https://github.com/nvpro-samples/vk_order_independent_transparency](https://github.com/nvpro-samples/vk_order_independent_transparency%0D%0A)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL skybox: [https://learnopengl.com/Advanced-OpenGL/Cubemaps](https://learnopengl.com/Advanced-OpenGL/Cubemaps%0D%0A)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to create cubemaps: [https://paulbourke.net/panorama/cubemaps/](https://paulbourke.net/panorama/cubemaps/%0D%0A)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL multiple lights: [https://learnopengl.com/Lighting/Multiple-lights](https://learnopengl.com/Lighting/Multiple-lights%0D%0A)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple lights demo by Hannes Nevalainen: [https://www.youtube.com/watch?v=vooznqE-XMM](https://www.youtube.com/watch?v=vooznqE-XMM%0D%0A)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL shadow maps: [https://learnopengl.com/Guest-Articles/2021/CSM](https://learnopengl.com/Guest-Articles/2021/CSM)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WebGL water simulation: [https://madebyevan.com/webgl-water/](https://madebyevan.com/webgl-water/%0D%0A)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL realistic water: [https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe](https://medium.com/@vincehnguyen/simplest-way-to-render-pretty-water-in-opengl-7bce40cbefbe%0D%0A)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL water caustics: [https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa](https://medium.com/@martinRenou/real-time-rendering-of-water-caustics-59cda1d74aa%0D%0A)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL lens flares: [https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html](https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html%0D%0A)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL God rays: [https://github.com/math-araujo/screen-space-godrays](https://github.com/math-araujo/screen-space-godrays%0D%0A)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL bloom effect: [https://learnopengl.com/Advanced-Lighting/Bloom](https://learnopengl.com/Advanced-Lighting/Bloom%0D%0A)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL motion blur: [https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf](https://www.nvidia.com/docs/io/8230/gdc2003_openglshadertricks.pdf%0D%0A)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL depth of field: [https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html](https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html%0D%0A)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL SSAO: [https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html](https://lettier.github.io/3d-game-shaders-for-beginners/ssao.html%0D%0A)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL SSR: [https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html%0D%0A)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vulkan raytracing: [https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/](https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/%0D%0A)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenXR: [https://www.khronos.org/openxr/](https://www.khronos.org/openxr/%0D%0A)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Godot XR Demo template: [https://github.com/GodotVR/godot-xr-template](https://github.com/GodotVR/godot-xr-template%0D%0A)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender: [https://www.blender.org](https://www.blender.org%0D%0A)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open Game Art for assets: [https://opengameart.org/](https://opengameart.org/%0D%0A)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放游戏艺术资源：[https://opengameart.org/](https://opengameart.org/%0D%0A)
- en: Join our community on Discord
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation%0D%0A)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation%0D%0A)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码，AI生成的内容可能不正确。](img/QR_code_Discord.png)'
