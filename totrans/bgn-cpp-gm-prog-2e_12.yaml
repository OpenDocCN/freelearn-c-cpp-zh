- en: '*Chapter 11*: Collision Detection, Pickups, and Bullets'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have implemented the main visual aspects of our game. We have a controllable
    character running around in an arena full of zombies that chase them. The problem
    is that they don't interact with each other. A zombie can wander right through
    the player without leaving a scratch. We need to detect collisions between the
    zombies and the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: If the zombies are going to be able to injure and eventually kill the player,
    it is only fair that we give the player some bullets for their gun. We will then
    need to make sure that the bullets can hit and kill the zombies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, if we are writing collision detection code for bullets, zombies,
    and the player, it would be a good time to add a class for health and ammo pickups
    as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will do and the order in which we will cover things in this
    chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Shooting Bullets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a crosshair and hiding the mouse pointer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning pickups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the `Bullet` class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Bullet class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the SFML `RectangleShape` class to visually represent a bullet.
    We will code a `Bullet` class that has a `RectangleShape` member, as well as other
    member data and functions. Then, we will add bullets to our game in a few steps,
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: First, we will code the `Bullet.h` file. This will reveal all the details of
    the member data and the prototypes for the functions.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will code the `Bullet.cpp` file, which, of course, will contain the
    definitions for all the functions of the `Bullet` class. As we step through this,
    I will explain exactly how an object of the `Bullet` type will work and be controlled.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will declare a whole array full of bullets in the `main` function.
    We will also implement a control scheme for shooting, managing the player's remaining
    ammo, and reloading.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started with step 1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Bullet header file
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the new header file, right-click `Bullet.h`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following private member variables, along with the `Bullet` class declaration,
    to the `Bullet.h` file. We can then run through them and explain what they are
    for:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, the first member is a `Vector2f` called `m_Position`,
    which will hold the bullet's location in the game world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `RectangleShape` called `m_BulletShape` as we are using a
    simple non-texture graphic for each bullet, a bit like we did for the time-bar
    in Timber!!!.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The code then declares a `Boolean`, `m_InFlight`, which will keep track of whether
    the bullet is currently whizzing through the air or not. This will allow us to
    decide whether we need to call its `update` function each frame and whether we
    need to run collision detection checks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The `float` variable, `m_BulletSpeed`, will (you can probably guess) hold the
    speed in pixels per second that the bullet will travel at. It is initialized to
    the value of `1000`, which is a little arbitrary, but it works well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two more `float` variables, `m_BulletDistanceX` and `m_BulletDistanceY`.
    As the calculations to move a bullet are a little more complex than those used
    to move a zombie or the player, we will benefit from having these two variables,
    which we will perform calculations on. They will be used to decide the horizontal
    and vertical changes in the bullet's position in each frame.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还有两个更多的 `float` 变量，`m_BulletDistanceX` 和 `m_BulletDistanceY`。由于移动子弹的计算比移动僵尸或玩家要复杂一些，我们将从这两个变量中受益，我们将对它们进行计算。它们将用于决定子弹在每个帧中的水平和垂直位置变化。
- en: Finally, we have four more `float` variables (`m_MaxX`, `m_MinX`, `m_MaxY`,
    and `m_MinY`), which will later be initialized to hold the maximum and minimum
    and horizontal and vertical positions for the bullet.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有四个 `float` 变量（`m_MaxX`、`m_MinX`、`m_MaxY` 和 `m_MinY`），稍后它们将被初始化以保存子弹的最大和最小水平以及垂直位置。
- en: It is likely that the need for some of these variables is not immediately apparent,
    but it will become clearer when we see each of them in action in the `Bullet.cpp`
    file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，这些变量中的一些需求并不立即明显，但当我们看到它们在 `Bullet.cpp` 文件中的实际应用时，一切将变得清晰起来。
- en: 'Now, add all the public function prototypes to the `Bullet.h` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有公共函数原型添加到 `Bullet.h` 文件中：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's run through each of the functions in turn, and then we can move on to
    coding their definitions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次运行每个函数，然后我们可以继续编写它们的定义。
- en: First, we have the `Bullet` function, which is, of course, the constructor.
    In this function, we will set up each `Bullet` instance, ready for action.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `Bullet` 函数，当然是构造函数。在这个函数中，我们将设置每个 `Bullet` 实例，使其准备就绪。
- en: The `stop` function will be called when the bullet has been in action but needs
    to stop.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当子弹已经执行但需要停止时，将调用 `stop` 函数。
- en: The `isInFlight` function returns a Boolean and will be used to test whether
    a bullet is currently in flight or not.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInFlight` 函数返回一个布尔值，将用于测试子弹是否当前正在飞行。'
- en: The `shoot` function's use is given away by its name, but how it will work deserves
    some discussion. For now, just note that it has four `float` parameters that will
    be passed in. The four values represent the starting (where the player is) horizontal
    and vertical position of the bullet, as well as the vertical and horizontal target
    position (where the crosshair is).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`shoot` 函数的功能从其名称中可以看出，但其工作原理值得讨论。现在，只需注意它有四个 `float` 参数将被传入。这四个值代表子弹的起始（玩家所在位置）水平和垂直位置，以及垂直和水平目标位置（准星所在位置）。'
- en: The `getPosition` function returns a `FloatRect` that represents the location
    of the bullet. This function will be used to detect collisions with zombies. You
    might remember from [*Chapter 10*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214),
    *Pointers, the Standard Template Library, and Texture Management*, that zombies
    also had a `getPosition` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosition` 函数返回一个表示子弹位置的 `FloatRect`。此函数将用于检测与僵尸的碰撞。你可能还记得在 [*第10章*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)，*指针、标准模板库和纹理管理*
    中，僵尸也有一个 `getPosition` 函数。'
- en: Following on, we have the `getShape` function, which returns an object of the
    `RectangleShape` type. As we have discussed, each bullet is represented visually
    by a `RectangleShape` object. The `getShape` function, therefore, will be used
    to grab a copy of the current state of `RectangleShape` in order to draw it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `getShape` 函数，它返回一个 `RectangleShape` 类型的对象。正如我们讨论过的，每个子弹都通过一个 `RectangleShape`
    对象来表示。因此，`getShape` 函数将用于获取 `RectangleShape` 当前状态的副本以便绘制。
- en: Finally, and hopefully as expected, there is the `update` function, which has
    a `float` parameter that represents the fraction of a second that has passed since
    the last time `update` was called. The `update` method will change the position
    of the bullet each frame.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并且希望如预期的那样，是 `update` 函数，它有一个 `float` 参数，表示自上次调用 `update` 以来经过的秒数的一部分。`update`
    方法将改变子弹在每个帧中的位置。
- en: Let's look at and code the function definitions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看并编写函数定义。
- en: Coding the Bullet source file
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Bullet 源文件
- en: Now, we can create a new `.cpp` file that will contain the function definitions.
    Right-click `Bullet.cpp`. Finally, click the **Add** button. We are now ready
    to code the class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的 `.cpp` 文件，该文件将包含函数定义。右键点击 `Bullet.cpp`。最后，点击 **添加** 按钮。我们现在可以开始编写类的代码了。
- en: 'Add the following code, which is for the include directives and the constructor.
    We know it is a constructor because the function has the same name as the class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，这是用于包含指令和构造函数的。我们知道它是一个构造函数，因为函数的名称与类相同：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only thing that the `Bullet` constructor needs to do is set the size of
    `m_BulletShape`, which is the `RectangleShape` object. The code sets the size
    to two pixels by two pixels.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet` 构造函数需要做的唯一事情是设置 `m_BulletShape` 的大小，这是一个 `RectangleShape` 对象。代码将大小设置为两个像素乘以两个像素。'
- en: 'Next, we will code the more substantial `shoot` function. Add the following
    code to the `Bullet.cpp` file and study it, and then we can talk about it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写更复杂的 `shoot` 函数。将以下代码添加到 `Bullet.cpp` 文件中，并研究它，然后我们可以讨论它：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to demystify the `shoot` function, we will split it up and talk about
    the code we have just added in chunks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了揭开 `shoot` 函数的神秘面纱，我们将将其拆分，并分块讨论我们刚刚添加的代码。
- en: 'First, let''s remind ourselves about the signature. The `shoot` function receives
    the starting and target horizontal and vertical positions of a bullet. The calling
    code will supply these based on the position of the player sprite and the position
    of the crosshair. Here it is again:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下签名。`shoot` 函数接收子弹的起始和目标水平及垂直位置。调用代码将根据玩家精灵的位置和准星的位置提供这些信息。这里再次说明：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the `shoot` function, we set `m_InFlight` to `true` and position the
    bullet using the `startX` and `startY` parameters. Here is that piece of code
    again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `shoot` 函数内部，我们将 `m_InFlight` 设置为 `true`，并使用 `startX` 和 `startY` 参数定位子弹。这是那段代码的再次说明：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we use a bit of trigonometry to determine the gradient of travel for a
    bullet. The progression of the bullet, both horizontally and vertically, must
    vary based on the slope of the line that's created by drawing between the start
    and target of a bullet. The rate of change cannot be the same or very steep shots
    will arrive at the horizontal location before the vertical location, and vice
    versa for shallow shots.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用一点三角学来确定子弹的移动斜率。子弹在水平和垂直方向上的进度必须根据从子弹的起始和目标之间绘制的线的斜率而变化。变化率不能相同或非常陡峭，否则斜射会先到达水平位置，然后是垂直位置，反之亦然。
- en: The code that follows derives the gradient based on the equation of a line.
    Then, it checks whether the gradient is less than zero and if it is, multiplies
    it by -1\. This is because the start and target coordinates that are passed in
    can be negative or positive, and we always want the amount of progression each
    frame to be positive. Multiplying by -1 simply makes the negative number into
    its positive equivalent because a minus multiplied by a minus gives a positive.
    The actual direction of travel will be handled in the `update` function by adding
    or subtracting the positive values we arrive at in this function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码根据直线的方程推导出斜率。然后，它检查斜率是否小于零，如果是，则将其乘以 -1。这是因为传入的起始和目标坐标可以是负数或正数，而我们总是希望每一帧的进度量是正数。乘以
    -1 简单地将负数转换为它的正数等价物，因为负数乘以负数得到正数。实际的运动方向将在 `update` 函数中通过添加或减去在这个函数中得到的正数值来处理。
- en: Next, we calculate a ratio of horizontal to vertical distance by dividing our
    bullet's speed (`m_BulletSpeed`) by one, plus the gradient. This will allow us
    to change the bullet's horizontal and vertical position by the correct amount
    each frame, based on the target the bullet is heading toward.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将子弹的速度 (`m_BulletSpeed`) 除以 1 加上斜率来计算水平到垂直距离的比率。这将允许我们根据子弹所朝向的目标，在每一帧正确地改变子弹的水平位置和垂直位置。
- en: 'Finally, in this part of the code, we assign the values to `m_BulletDistanceY`
    and `m_BulletDistanceX`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这段代码中，我们将值分配给 `m_BulletDistanceY` 和 `m_BulletDistanceX`：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code is much more straightforward. We simply set a maximum horizontal
    and vertical location that the bullet can reach. We don''t want a bullet carrying
    on forever. In the update function, we will see whether a bullet has passed its
    maximum or minimum locations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码更加直接。我们只是设置子弹可以达到的最大水平和垂直位置。我们不想让子弹永远飞行。在更新函数中，我们将看到子弹是否已经通过了其最大或最小位置：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code moves the sprite that represents the bullet to its starting
    location. We use the `setPosition` function of `Sprite`, as we have often done
    before:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将代表子弹的精灵移动到其起始位置。我们使用 `Sprite` 的 `setPosition` 函数，就像我们之前经常做的那样：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we have four straightforward functions. Let''s add the `stop`, `isInFlight`,
    `getPosition`, and `getShape` functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有四个简单的函数。让我们添加 `stop`、`isInFlight`、`getPosition` 和 `getShape` 函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `stop` function simply sets the `m_InFlight` variable to `false`. The `isInFlight`
    function returns whatever the value of this same variable currently is. So, we
    can see that `shoot` sets the bullet going, `stop` makes it stop, and `isInFlight`
    informs us what the current state is.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop` 函数只是将 `m_InFlight` 变量设置为 `false`。`isInFlight` 函数返回该变量当前值。因此，我们可以看到 `shoot`
    使子弹开始移动，`stop` 使其停止，而 `isInFlight` 通知我们当前状态。'
- en: The `getPosition` function returns a `FloatRect`. We will see how we can use
    the `FloatRect` from each game object to detect collisions soon.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosition` 函数返回一个 `FloatRect`。我们很快就会看到如何使用每个游戏对象的 `FloatRect` 来检测碰撞。'
- en: Finally, for the previous code, `getShape` returns a `RectangleShape` so that
    we can draw the bullet once each frame.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于之前的代码，`getShape` 返回一个 `RectangleShape`，这样我们就可以在每一帧中绘制子弹。
- en: 'The last function we need to implement before we can start using `Bullet` objects
    is `update`. Add the following code, study it, and then we can talk about it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始使用 `Bullet` 对象之前，我们需要实现最后一个函数 `update`。添加以下代码，研究它，然后我们可以讨论它：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `update` function, we use `m_BulletDistanceX` and `m_BulletDistanceY`,
    multiplied by the time since the last frame to move the bullet. Remember that
    the values of the two variables were calculated in the `shoot` function and represent
    the gradient (ratio to each other) that's required to move the bullet at just
    the right angle. Then, we use the `setPosition` function to actually move `RectangleShape`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `update` 函数中，我们使用 `m_BulletDistanceX` 和 `m_BulletDistanceY`，乘以上一帧以来的时间来移动子弹。记住，这两个变量的值是在
    `shoot` 函数中计算的，代表移动子弹所需的角度的梯度（彼此之间的比率）。然后，我们使用 `setPosition` 函数实际移动 `RectangleShape`。
- en: The last thing we do in `update` is a test to see whether the bullet has moved
    beyond its maximum range. The slightly convoluted `if` statement checks `m_Position.x`
    and `m_Position.y` against the maximum and minimum values that were calculated
    in the `shoot` function. These maximum and minimum values are stored in `m_MinX`,
    `m_MaxX`, `m_MinY`, and `m_MaxY`. If the test is true, then `m_InFlight` is set
    to `false`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `update` 函数中我们做的最后一件事是测试子弹是否已经移动到其最大射程之外。稍微复杂的 `if` 语句检查 `m_Position.x` 和
    `m_Position.y` 是否与在 `shoot` 函数中计算出的最大和最小值相符。这些最大和最小值存储在 `m_MinX`、`m_MaxX`、`m_MinY`
    和 `m_MaxY` 中。如果测试结果为真，则将 `m_InFlight` 设置为 `false`。
- en: The `Bullet` class is done. Now, we will look at how we can shoot some in the
    `main` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet` 类已完成。现在，我们将看看如何在 `main` 函数中射击一些子弹。'
- en: Making the bullets fly
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使子弹飞行
- en: 'We will make the bullets usable by following these six steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下六个步骤使子弹可用：
- en: Add the necessary include directive for the `Bullet` class.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Bullet` 类添加必要的包含指令。
- en: Add some control variables and an array to hold some `Bullet` instances.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些控制变量和一个数组来存储一些 `Bullet` 实例。
- en: Handle the player pressing *R* to reload.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理玩家按下 *R* 键来重新装填。
- en: Handle the player pressing the left mouse button to fire a bullet.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理玩家按下左鼠标按钮来发射子弹。
- en: Update all bullets that are in flight in each frame.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一帧中更新所有正在飞行的子弹。
- en: Draw the bullets that are in flight in each frame.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一帧中绘制正在飞行的子弹。
- en: Including the Bullet class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含 Bullet 类
- en: 'Add the include directive to make the Bullet class available:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加包含指令以使 Bullet 类可用：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's move on to the next step.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一步。
- en: Control variables and the bullet array
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制变量和子弹数组
- en: Here are some variables to keep track of clip sizes, spare bullets, bullets,
    the remaining bullets in the clip, the current rate of fire (starting at one per
    second), and the time when the last bullet was fired.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些变量用于跟踪弹夹大小、备用子弹、子弹、弹夹中剩余的子弹、当前射速（从每秒一发开始）以及上次发射子弹的时间。
- en: 'Add the following highlighted code. Then, we can move on and see all these
    variables in action throughout the rest of this section:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码。然后，我们可以继续前进，并看到本节其余部分的所有这些变量在行动中的表现：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let's handle what happens when the player presses the *R* keyboard key,
    which is used for reloading a clip.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理玩家按下 *R* 键时发生的情况，该键用于重新装填弹夹。
- en: Reloading the gun
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新装填枪支
- en: Now, we will handle the player input related to shooting bullets. First, we
    will handle pressing the *R* key to reload the gun. We will do so with an SFML
    event.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理与射击子弹相关的玩家输入。首先，我们将处理按下 *R* 键来重新装填枪支。我们将使用 SFML 事件来完成此操作。
- en: 'Add the following highlighted code. It is shown with lots of context to make
    sure the code goes in the right place. Study the code and then we can talk about
    it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮显示的代码。它展示了大量的上下文，以确保代码放在正确的位置。研究完代码后，我们再讨论它：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code is nested within the event handling part of the game loop
    (`while(window.pollEvent)`), within the block that only executes when the game
    is actually being played (`if(state == State::Playing)`). It is obvious that we
    don't want the player reloading when the game has finished or is paused, and wrapping
    the new code as we've described achieves this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码嵌套在游戏循环的事件处理部分（`while(window.pollEvent)`）中，在仅当游戏实际正在播放时执行的代码块内（`if(state
    == State::Playing)`）。很明显，我们不希望玩家在游戏结束时或暂停时重新装弹，所以我们按照描述的方式包裹新代码，以此实现这一目的。
- en: 'In the new code itself, the first thing we do is test for the *R* key being
    pressed with `if (event.key.code == Keyboard::R)`. Once we have detected that
    the *R* key was pressed, the remaining code is executed. Here is the structure
    of the `if`, `else if`, and `else` blocks:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码本身中，我们首先使用 `if (event.key.code == Keyboard::R)` 测试是否按下了 *R* 键。一旦我们检测到按下了
    *R* 键，剩余的代码就会被执行。以下是 `if`、`else if` 和 `else` 块的结构：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous structure allows us to handle three possible scenarios, as shown
    here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的结构允许我们处理三种可能的场景，如下所示：
- en: The player has pressed `R` and they have more bullets spare than the clip can
    take. In this scenario, the clip is refilled, and the number of spare bullets
    is reduced.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家按下了 `R` 键，并且他们还有比弹夹能装的更多的备用子弹。在这种情况下，弹夹被重新装填，备用子弹的数量减少。
- en: The player has some spare bullets but not enough to fill the clip completely.
    In this scenario, the clip is filled with as many spare bullets as the player
    has and the number of spare bullets is set to zero.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家有一些备用子弹，但不足以完全填满弹夹。在这种情况下，弹夹被填满至玩家拥有的备用子弹数量，备用子弹的数量被设置为零。
- en: The player has pressed *R* but they have no spare bullets at all. For this scenario,
    we don't actually need to alter the variables. However, we will play a sound effect
    here when we implement the sound in [*Chapter 13*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279),
    *Sound Effects, File I/O, and Finishing the Game*, so we will leave the empty
    `else` block ready.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家按下了 *R* 键，但他们完全没有备用子弹。对于这种情况，我们实际上不需要改变变量。然而，当我们在 [*第13章*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279)
    中实现声音效果时，*声音效果、文件输入/输出和完成游戏*，我们将在那里播放一个声音效果，所以我们将保留空的 `else` 块以备后用。
- en: Now, let's shoot a bullet.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们射击一颗子弹。
- en: Shooting a bullet
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击子弹
- en: 'Here, we will handle the left mouse button being clicked to fire a bullet.
    Add the following highlighted code and study it carefully:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将处理左鼠标按钮被点击以发射子弹的情况。添加以下高亮显示的代码并仔细研究它：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the previous code is wrapped in an `if` statement that executes whenever
    the left mouse button is pressed, that is, `if (Mouse::isButtonPressed(sf::Mouse::Left))`.
    Note that the code will execute repeatedly, even if the player just holds down
    the button. The code we will go through now controls the rate of fire.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的代码都被包裹在一个 `if` 语句中，该语句在左鼠标按钮被按下时执行，即 `if (Mouse::isButtonPressed(sf::Mouse::Left))`。请注意，即使玩家只是按住按钮，代码也会重复执行。我们现在要讲解的代码控制了射击速率。
- en: In the preceding code, we then check whether the total time elapsed in the game
    (`gameTimeTotal`) minus the time the player last shot a bullet (`lastPressed`)
    is greater than 1,000, divided by the current rate of fire and that the player
    has at least one bullet in the clip. We use 1,000 because this is the number of
    milliseconds in a second.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检查游戏已过去的时间（`gameTimeTotal`）减去玩家上次射击子弹的时间（`lastPressed`）是否大于 1,000，除以当前射击速率，并且玩家至少有一个子弹在弹夹中。我们使用
    1,000 因为这是秒中的毫秒数。
- en: If this test is successful, the code that actually fires a bullet is executed.
    Shooting a bullet is easy because we did all the hard work in the `Bullet` class.
    We simply call `shoot` on the current bullet from the `bullets` array. We pass
    in the player's and the cross-hair's current horizontal and vertical locations.
    The bullet will be configured and set in flight by the code in the `shoot` function
    of the `Bullet` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个测试成功，将执行实际发射子弹的代码。射击子弹很简单，因为我们已经在 `Bullet` 类中完成了所有艰苦的工作。我们只需在 `bullets`
    数组中的当前子弹上调用 `shoot`。我们传入玩家和准星当前的水平位置和垂直位置。子弹将通过 `Bullet` 类的 `shoot` 函数中的代码进行配置并设置为飞行状态。
- en: All we must do is keep track of the array of bullets. We incremented the `currentBullet`
    variable. Then, we need to check to see whether we fired the last bullet (99)
    with the `if (currentBullet > 99)` statement. If it was the last bullet, we set
    `currentBullet` to zero. If it wasn't the last bullet, then the next bullet is
    ready to go whenever the rate of fire permits it and the player presses the left
    mouse button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的只是跟踪子弹数组。我们递增了`currentBullet`变量。然后，我们需要检查是否用`if (currentBullet > 99)`语句发射了最后一个子弹（99号）。如果是最后一个子弹，我们将`currentBullet`设置为零。如果不是最后一个子弹，那么在射击速率允许且玩家按下左鼠标按钮时，下一发子弹就可以发射。
- en: Finally, in the preceding code, we store the time that the bullet was fired
    into `lastPressed` and decrement `bulletsInClip`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在先前的代码中，我们将子弹发射的时间存储到`lastPressed`中，并将`bulletsInClip`递减。
- en: Now, we can update every bullet, each frame.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以每帧更新每个子弹。
- en: Updating the bullets each frame
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每帧更新子弹
- en: 'Add the following highlighted code to loop through the bullets array, check
    whether the bullet is in flight, and if it is, call its update function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码以遍历子弹数组，检查子弹是否在飞行中，如果是，则调用其更新函数：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we will draw all the bullets.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将绘制所有子弹。
- en: Drawing the bullets each frame
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每帧绘制子弹
- en: 'Add the following highlighted code to loop through the `bullets` array, check
    whether the bullet is in flight, and if it is, draw it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码以遍历`bullets`数组，检查子弹是否在飞行中，如果是，则绘制它：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the game to try out the bullets. Notice that you can fire six shots before
    you need to press *R* to reload. The obvious things that are missing is some visual
    indicator of the number of bullets in the clip and the number of spare bullets.
    Another problem is that the player can very quickly run out of bullets, especially
    since the bullets have no stopping power whatsoever. They fly straight through
    the zombies. Add to this that the player is expected to aim at a mouse pointer
    instead of a precision crosshair and it is clear that we have work to do.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏以测试子弹。注意，在你需要按*R*键重新装填之前，你可以发射六发子弹。显然缺少的是一些视觉指示器，显示弹夹中的子弹数量和备用子弹数量。另一个问题是玩家可能会非常快地用完子弹，尤其是由于子弹完全没有停止力，它们会直接穿过僵尸。再加上玩家被期望瞄准鼠标指针而不是精确的准星，很明显我们还有很多工作要做。
- en: In the next chapter, we will give visual feedback through a HUD. We will replace
    the mouse cursor with a crosshair next and then spawn some pickups to replenish
    bullets and health after that. Finally, in this chapter, we will handle collision
    detection to make the bullets and the zombies do damage and make the player able
    to actually get the pickups.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过HUD提供视觉反馈。我们将用准星替换鼠标光标，然后在那之后生成一些拾取物来补充子弹和生命值。最后，在这一章中，我们将处理碰撞检测，使子弹和僵尸造成伤害，并使玩家能够真正地拾取物品。
- en: Giving the player a crosshair
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给玩家一个准星
- en: 'Adding a crosshair is easy and only requires one new concept. Add the following
    highlighted code, and then we can run through it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加准星很简单，只需要一个新概念。添加以下高亮代码，然后我们可以运行它：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we call the `setMouseCursorVisible` function on our `window` object.
    We then load a `Texture` and declare a `Sprite` instance and initialize it in
    the usual way. Furthermore, we set the sprite's origin to its center to make it
    convenient and simpler to make the bullets fly to the middle, as you would expect
    to happen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`window`对象上调用`setMouseCursorVisible`函数。然后我们加载一个`Texture`并声明一个`Sprite`实例，并以通常的方式初始化它。此外，我们将精灵的原点设置为它的中心，使其更方便，也更简单地将子弹飞向中间，正如你所期望的那样。
- en: 'Now, we need to update the crosshair each frame with the world coordinates
    of the mouse. Add the following highlighted line of code, which uses the `mouseWorldPosition`
    vector to set the crosshair''s position each frame:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要每帧更新准星，使用鼠标的全球坐标。添加以下高亮代码行，它使用`mouseWorldPosition`向量设置准星的每帧位置：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, as you have probably come to expect, we can draw the crosshair each frame.
    Add the following highlighted line of code in the position shown. This line of
    code needs no explanation, but its position after all the other game objects is
    important, so it is drawn on top:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如你可能已经预料到的，我们可以在每一帧绘制准星。在所示位置添加以下高亮代码行。这一行代码无需解释，但它在所有其他游戏对象之后的定位很重要，因此它被绘制在最上面：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you can run the game and will see a cool crosshair instead of a mouse
    cursor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏，将看到一个酷炫的准星而不是鼠标光标：
- en: '![](img/B14278_11_01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_11_01.jpg)'
- en: Notice how the bullet fires neatly through the center of the crosshair. The
    way the shooting mechanism works is analogous to allowing the player to choose
    to shoot from the hip or aim down the sights. If the player keeps the crosshair
    close to the center, they can fire and turn rapidly, yet must carefully judge
    the position of distant zombies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the player can hover their crosshair directly over the head of
    a distant zombie and score a precise hit; however, they then have much further
    to move the crosshair back if a zombie attacks from another direction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: An interesting improvement to the game would be to add a small random amount
    of inaccuracy to each shot. This inaccuracy could perhaps be mitigated with an
    upgrade between waves.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Coding a class for pickups
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will code a `Pickup` class that has a `Sprite` member,
    as well as other member data and functions. We will add pickups to our game in
    just a few steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: First, we will code the `Pickup.h` file. This will reveal all the details of
    the member data and the prototypes for the functions.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will code the `Pickup.cpp` file which, of course, will contain the
    definitions for all the functions of the `Pickup` class. As we step through this,
    I will explain exactly how an object of the `Pickup` type will work and be controlled.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use the `Pickup` class in the `main` function to spawn them,
    update them, and draw them.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started with step 1.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Pickup header file
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the new header file, right-click `Pickup.h`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and study the following code to the `Pickup.h` file and then we can go
    through it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code declares all the private variables of the `Pickup` class.
    Although the names should be quite intuitive, it might not be obvious why many
    of them are needed at all. Let''s go through them, starting from the top:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`const int HEALTH_START_VALUE = 50`: This constant variable is used to set
    the starting value of all health pickups. The value will be used to initialize
    the `m_Value` variable, which will need to be manipulated throughout the course
    of a game.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int AMMO_START_VALUE = 12`: This constant variable is used to set the
    starting value of all ammo pickups. The value will be used to initialize the `m_Value`
    variable, which will need to be manipulated throughout the course of a game.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int START_WAIT_TIME = 10`: This variable determines how long a pickup
    will wait before it respawns after disappearing. It will be used to initialize
    the `m_SecondsToWait` variable, which can be manipulated throughout the game.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int START_SECONDS_TO_LIVE = 5`: This variable determines how long a
    pickup will last between spawning and being de-spawned. Like the previous three
    constants, it has a non-constant associated with it that can be manipulated throughout
    the course of the game. The non-constant it''s used to initialize is `m_SecondsToLive`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite m_Sprite`: This is the sprite to visually represent the object.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntRect m_Arena`: This will hold the size of the current arena to help the
    pickup to spawn in a sensible position.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntRect m_Arena`：这将保存当前竞技场的尺寸，以帮助拾取在合理的位置生成。'
- en: '`int m_Value`: How much health or ammo is this pickup worth? This value is
    used when the player levels up the value of the health or ammo pickup.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int m_Value`：这个拾取值代表多少生命值或弹药？当玩家升级生命值或弹药拾取的值时，将使用此值。'
- en: '`int m_Type`: This will be either 1 or 2 for health or ammo, respectively.
    We could have used an enumeration class, but that seemed like overkill for just
    two options.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int m_Type`：这将分别为生命值或弹药是1或2。我们本可以使用枚举类，但似乎对于只有两个选项来说有点过度了。'
- en: '`bool m_Spawned`: Is the pickup currently spawned?'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool m_Spawned`：拾取当前是否已生成？'
- en: '`float m_SecondsSinceSpawn`: How long is it since the pickup was spawned?'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsSinceSpawn`：拾取被生成以来有多长时间了？'
- en: '`float m_SecondsSinceDeSpawn`: How long is it since the pickup was de-spawned
    (disappeared)?'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsSinceDeSpawn`：拾取被销毁（消失）以来有多长时间了？'
- en: '`float m_SecondsToLive`: How long should this pickup stay spawned before de-spawning?'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsToLive`：这个拾取在销毁前应该保持生成多久？'
- en: '`float m_SecondsToWait`: How long should this pickup stay de-spawned before
    respawning?'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float m_SecondsToWait`：这个拾取在重新生成前应该保持销毁多久？'
- en: Tip
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that most of the complexity of this class is due to the variable spawn
    time and its upgradeable nature. If the pickups just respawned when collected
    and had a fixed value, this would be a very simple class. We need our pickups
    to be upgradeable so that the player is forced to develop a strategy to progress
    through the waves.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个类的复杂性的大部分是由于变量生成时间和其可升级的特性。如果拾取在收集后重新生成并且具有固定值，这将是一个非常简单的类。我们需要我们的拾取是可升级的，这样玩家就必须制定策略才能通过波次。
- en: 'Next, add the following public function prototypes to the `Pickup.h` file.
    Be sure to familiarize yourself with the new code so that we can go through it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下公共函数原型添加到`Pickup.h`文件中。请确保您熟悉新代码，这样我们才能一起审查：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's talk briefly about each of the function definitions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地讨论一下每个函数定义。
- en: The first function is the constructor and is named after the class. Note that
    it takes a single `int` parameter. This will be used to initialize the type of
    pickup it will be (health or ammo).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数是构造函数，其名称与类名相同。请注意，它接受一个单个的`int`参数。这将用于初始化它将是什么类型的拾取（生命值或弹药）。
- en: The `setArena` function receives an `IntRect`. This function will be called
    for each `Pickup` instance at the start of each wave. The `Pickup` objects will
    then "know" the areas into which they can spawn.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setArena`函数接收一个`IntRect`。这个函数将在每一波的开始时为每个`Pickup`实例调用。然后，`Pickup`对象将“知道”它们可以生成的区域。'
- en: The `spawn` function will, of course, handle spawning the pickup.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，`spawn`函数将处理拾取的生成。
- en: The `getPosition` function, just like in the `Player`, `Zombie`, and `Bullet`
    classes, will return a `FloatRect` instance that represents the current location
    of the object in the game world.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPosition`函数，就像在`Player`、`Zombie`和`Bullet`类中一样，将返回一个`FloatRect`实例，表示对象在游戏世界中的当前位置。'
- en: The `getSprite` function returns a `Sprite` object that allows the pickup to
    be drawn once each frame.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSprite`函数返回一个`Sprite`对象，允许拾取在每一帧被绘制。'
- en: The `update` function receives the time the previous frame took. It uses this
    value to update its private variables and make decisions about when to spawn and
    de-spawn.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`函数接收上一帧所花费的时间。它使用这个值来更新其私有变量，并做出何时生成和销毁的决定。'
- en: The `isSpawned` function returns a Boolean that will let the calling code know
    whether or not the pickup is currently spawned.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSpawned`函数返回一个布尔值，这将让调用代码知道拾取是否当前已生成。'
- en: The `gotIt` function will be called when a collision is detected with the player.
    The code of the `Pickup` class can then prepare itself for respawning at the appropriate
    time. Note that it returns an `int` value so that the calling code knows how much
    the pickup is "worth" in either health or ammo.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检测到与玩家的碰撞时，将调用`gotIt`函数。然后，`Pickup`类的代码可以准备在适当的时间重新生成。请注意，它返回一个`int`值，以便调用代码知道拾取在生命值或弹药中的“价值”。
- en: The `upgrade` function will be called when the player chooses to level up the
    properties of a pickup during the leveling up phase of the game.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家在游戏的升级阶段选择升级拾取属性时，将调用`upgrade`函数。
- en: Now that we have gone through the member variables and function prototypes,
    it should be quite easy to follow along as we code the function definitions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Pickup class function definitions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can create a new `.cpp` file that will contain the function definitions.
    Right-click `Pickup.cpp`. Finally, click the **Add** button. We are now ready
    to code the class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Pickup.cpp` file. Be sure to review the code
    so that we can discuss it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous code, we added the familiar include directives. Then, we added
    the `Pickup` constructor. We know it is the constructor because it has the same
    name as the class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The constructor receives an `int` called `type` and the first thing the code
    does is assign the value that's received from `type` to `m_Type`. After this,
    there is an `if else` block that checks whether `m_Type` is equal to 1\. If it
    is, `m_Sprite` is associated with the health pickup texture and `m_Value` is set
    to `HEALTH_START_VALUE`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If `m_Type` is not equal to 1, the `else` block associates the ammo pickup texture
    with `m_Sprite` and assigns the value of `AMMO_START_VALUE` to `m_Value`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: After the `if` `else` block, the code sets the origin of `m_Sprite` to the center
    using the `setOrigin` function and assigns `START_SECONDS_TO_LIVE` and `START_WAIT_TIME`
    to `m_SecondsToLive` and `m_SecondsToWait`, respectively.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The constructor has successfully prepared a `Pickup` object that is ready for
    use.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add the `setArena` function. Examine the code as you add it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `setArena` function that we just coded simply copies the values from the
    passed in `arena` object but varies the values by `+ 50` on the left and top and
    `- 50` on the right and bottom. The `Pickup` object is now aware of the area in
    which it can spawn. The `setArena` function then calls its own `spawn` function
    to make the final preparations for being drawn and updated each frame.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spawn` function is next. Add the following code after the `setArena` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `spawn` function does everything necessary to prepare the pickup. First,
    it seeds the random number generator and gets a random number for both the horizontal
    and vertical position of the object. Notice that it uses the `m_Arena.width` and
    `m_Arena.height` variables as the ranges for the possible horizontal and vertical
    positions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The `m_SecondsSinceSpawn` variable is set to zero so that the length of time
    that's allowed before it is de-spawned is reset. The `m_Spawned` variable is set
    to `true` so that, when we call `isSpawned`, from `main`, we will get a positive
    response. Finally, `m_Sprite` is moved into position with `setPosition`, ready
    for being drawn to the screen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the following block of code, we have three simple getter functions. The `getPosition`
    function returns a `FloatRect` of the current position of `m_Sprite`, `getSprite`
    returns a copy of `m_Sprite` itself, and `isSpawned` returns `true` or `false`,
    depending on whether the object is currently spawned.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有三个简单的获取函数。`getPosition` 函数返回 `m_Sprite` 当前位置的 `FloatRect`，`getSprite`
    返回 `m_Sprite` 本身的副本，而 `isSpawned` 根据对象当前是否生成返回 `true` 或 `false`。
- en: 'Add and examine the code we have just discussed:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 添加并检查我们刚刚讨论的代码：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will code the `gotIt` function. This function will be called from
    `main` when the player touches/collides (gets) with the pickup. Add the `gotIt`
    function after the `isSpawned` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 `gotIt` 函数。当玩家触摸/碰撞（获取）拾取物品时，将从 `main` 中调用此函数。在 `isSpawned` 函数之后添加
    `gotIt` 函数：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `gotIt` function sets `m_Spawned` to `false` so that we know not to draw
    and check for collisions anymore. `m_SecondsSinceDespawn` is set to zero so that
    the countdown to spawning begins again from the start. `m_Value` is then returned
    to the calling code so that the calling code can handle adding extra ammunition
    or health, as appropriate.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`gotIt` 函数将 `m_Spawned` 设置为 `false`，这样我们就知道不再绘制和检查碰撞。`m_SecondsSinceDespawn`
    被设置为零，以便从零开始重新开始生成倒计时。然后，`m_Value` 返回到调用代码，以便调用代码可以处理添加额外的弹药或健康，根据情况而定。'
- en: 'Following this, we need to code the `update` function, which ties together
    many of the variables and functions we have seen so far. Add and familiarize yourself
    with the `update` function, and then we can talk about it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写 `update` 函数，该函数将我们迄今为止看到的许多变量和函数结合起来。添加并熟悉 `update` 函数，然后我们可以讨论它：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `update` function is divided into four blocks that are considered for execution
    each frame:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数被分为四个块，每个块在每个帧都会考虑执行：'
- en: 'An `if` block that executes if `m_Spawned` is true: `if (m_Spawned)`. This
    block of code adds the time this frame to `m_SecondsSinceSpawned`, which keeps
    track of how long the pickup has been spawned.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `m_Spawned` 为真，则执行 `if` 块：`if (m_Spawned)`. 这段代码将当前帧的时间添加到 `m_SecondsSinceSpawned`
    中，该变量用于跟踪拾取物品被生成的时间。
- en: A corresponding `else` block that executes if `m_Spawned` is false. This block
    adds the time this frame took to `m_SecondsSinceDeSpawn`, which keeps track of
    how long the pickup has waited since it was last de-spawned (hidden).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `m_Spawned` 为假，则执行相应的 `else` 块。此块将当前帧所花费的时间添加到 `m_SecondsSinceDeSpawn` 中，该变量用于跟踪拾取物品上次被销毁（隐藏）后等待了多长时间。
- en: 'Another `if` block that executes when the pickup has been spawned for longer
    than it should have been: `if (m_SecondsSinceSpawn > m_SecondsToLive && m_Spawned)`.
    This block sets `m_Spawned` to `false` and resets `m_SecondsSinceDeSpawn` to zero.
    Now, block 2 will execute until it is time to spawn it again.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个 `if` 块在拾取物品生成时间超过预期时执行：`if (m_SecondsSinceSpawn > m_SecondsToLive && m_Spawned)`。此块将
    `m_Spawned` 设置为 `false` 并将 `m_SecondsSinceDeSpawn` 重置为零。现在，块 2 将执行，直到再次生成它。
- en: 'A final `if` block that executes when the time to wait since de-spawning has
    exceeded the necessary wait time, and the pickup is not currently spawned: `if
    (m_SecondsSinceDeSpawn > m_SecondsToWait && !m_Spawned)`. When this block is executed,
    it is time to spawn the pick up again, and the `spawn` function is called.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从生成到销毁的等待时间超过必要的等待时间，并且拾取物品当前未生成时，执行一个最终的 `if` 块：`if (m_SecondsSinceDeSpawn
    > m_SecondsToWait && !m_Spawned)`. 当此块执行时，是时候再次生成拾取物品了，并调用 `spawn` 函数。
- en: These four tests are what control the hiding and showing of a pickup.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个测试控制着拾取物品的隐藏和显示。
- en: 'Finally, add the definition for the `upgrade` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `upgrade` 函数的定义：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `upgrade` function tests for the type of pickup, either health or ammo,
    and then adds 50% of the (appropriate) starting value on to `m_Value`. The next
    two lines after the `if` `else` blocks increase the amount of time the pickup
    will remain spawned and decreases the amount of time the player must wait between
    spawns.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`upgrade` 函数检查拾取物品的类型，无论是健康还是弹药，然后将（适当的）起始值的 50% 添加到 `m_Value`。在 `if` `else`
    块之后的下两行增加了拾取物品将保持生成的时长，并减少了玩家在生成之间必须等待的时间。'
- en: This function is called when the player chooses to level up the pickups during
    the `LEVELING_UP` state.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在 `LEVELING_UP` 状态下选择提升拾取物品时，会调用此函数。
- en: Our `Pickup` class is ready for use.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Pickup` 类已准备好使用。
- en: Using the Pickup class
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拾取类
- en: After all that hard work implementing the `Pickup` class, we can now go ahead
    and write code in the game engine to put some pickups into the game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `Pickup` 类的所有艰苦工作之后，我们现在可以继续在游戏引擎中编写代码，将一些拾取物放入游戏中。
- en: 'The first thing we will do is add an include directive to the `ZombieArena.cpp`
    file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要在 `ZombieArena.cpp` 文件中添加一个包含指令：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this following code, we are adding two `Pickup` instances: one called `healthPickup`
    and another called `ammoPickup`. We pass the values 1 and 2, respectively, into
    the constructor so that they are initialized to the correct type of pickup. Add
    the following highlighted code, which we have just discussed:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们添加了两个 `Pickup` 实例：一个称为 `healthPickup`，另一个称为 `ammoPickup`。我们分别将值 1 和
    2 传递给构造函数，以便它们初始化为正确的拾取物类型。添加我们刚刚讨论的突出显示的代码：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `LEVELING_UP` state of the keyboard handling, add the following highlighted
    lines within the nested `PLAYING` code block:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在键盘处理的 `LEVELING_UP` 状态中，在嵌套的 `PLAYING` 代码块内添加以下突出显示的行：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code simply passes `arena` into the `setArena` function of each
    pickup. The pickups now know where they can spawn. This code executes for each
    new wave, so, as the arena's size grows, the `Pickup` objects will get updated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是将 `arena` 传递给每个拾取物的 `setArena` 函数。现在拾取物知道它们可以在哪里生成。此代码在每一波新出现时执行，因此，随着竞技场大小的增长，`Pickup`
    对象将得到更新。
- en: 'The following code simply calls the `update` function for each `Pickup` object
    on each frame:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码简单地调用每个帧上每个 `Pickup` 对象的 `update` 函数：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following code in the draw part of the game loop checks whether the pickup
    is currently spawned and if it is, draws it. Let''s add it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在游戏循环的绘制部分检查拾取物是否当前已生成，如果是，则绘制它。让我们添加它：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, you can run the game and see the pickups spawn and de-spawn. You can''t,
    however, actually pick them up yet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏并看到拾取物生成和消失。然而，你实际上还不能捡起它们：
- en: '![](img/B14278_11_02.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_11_02.jpg)'
- en: Now that we have all the objects in our game, it is a good time to make them
    interact (collide) with each other.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了游戏中的所有对象，现在是时候让它们相互交互（碰撞）了。
- en: Detecting collisions
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'We just need to know when certain objects from our game touch certain other
    objects. We can then respond to that event in an appropriate manner. In our classes,
    we have already added functions that will be called when our objects collide.
    They are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要知道游戏中的某些对象何时触摸到其他对象。然后我们可以适当地响应该事件。在我们的类中，我们已经添加了当我们的对象碰撞时将被调用的函数。它们如下所示：
- en: The `Player` class has a `hit` function. We will call it when a zombie collides
    with the player.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player` 类有一个 `hit` 函数。当僵尸与玩家碰撞时，我们将调用它。'
- en: The `Zombie` class has a `hit` function. We will call it when a bullet collides
    with a zombie.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zombie` 类有一个 `hit` 函数。当子弹与僵尸碰撞时，我们将调用它。'
- en: The `Pickup` class has a `gotIt` function. We will call it when the player collides
    with a pickup.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pickup` 类有一个 `gotIt` 函数。当玩家与拾取物碰撞时，我们将调用它。'
- en: If necessary, look back to refresh your memory regarding how each of those functions
    works. All we need to do now is detect the collisions and call the appropriate
    functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，回顾一下每个函数是如何工作的，以刷新你的记忆。我们现在需要做的是检测碰撞并调用适当的函数。
- en: 'We will use **rectangle intersection** to detect collisions. This type of collision
    detection is straightforward (especially with SFML). We will use the same technique
    that we used in the Pong game. The following image shows how a rectangle can reasonably
    accurately represent the zombies and the player:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **矩形交集** 来检测碰撞。这种碰撞检测方法简单（特别是在 SFML 中）。我们将使用我们在 Pong 游戏中使用的相同技术。以下图像显示了矩形如何合理准确地表示僵尸和玩家：
- en: '![](img/B14278_11_03.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_11_03.jpg)'
- en: We will deal with this in three sections of code that will all follow on from
    one another. They will all go at the end of the update part of our game engine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个代码部分中处理这个问题，这些部分将依次进行。它们都将放在我们游戏引擎的更新部分的末尾。
- en: 'We need to know the answers to the following three questions for each frame:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一帧，我们需要知道以下三个问题的答案：
- en: Has a Zombie been shot?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 僵尸是否被射击？
- en: Has the player been touched by a Zombie?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家是否被僵尸触碰过？
- en: Has the player touched a pickup?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家是否触碰了拾取物？
- en: 'First, let''s add a couple more variables for `score` and `hiscore`. We can
    then change them when a zombie is killed. Add the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为 `score` 和 `hiscore` 添加一些额外的变量。然后，当僵尸被杀死时，我们可以更改它们。添加以下代码：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let's start by detecting whether a zombie is colliding with a bullet.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们首先检测僵尸是否与子弹发生碰撞。
- en: Has a zombie been shot?
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 僵尸是否被射击了？
- en: 'The following code might look complicated but, when we step through it, we
    will see it is nothing we haven''t seen before. Add the following code just after
    the call to update the pickups each frame. Then, we can go through it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可能看起来很复杂，但当我们逐步执行它时，我们会看到它并没有什么我们没有见过的。在调用更新拾取物后的代码中添加以下代码：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the next section, we will see all the zombie and bullet collision detection
    code again. We will do so a bit at a time so that we can discuss it. First of
    all, notice the structure of the nested `for` loops in the preceding code (with
    some code stripped out), as shown again here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将再次看到所有僵尸和子弹碰撞检测的代码。我们将分步骤进行，以便进行讨论。首先，注意前面代码中嵌套的`for`循环的结构（部分代码已被删除），如下所示：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code loops through every bullet (0 to 99) for each and every zombie (0 to
    less than `numZombies`.).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 代码对每个僵尸（从0到`numZombies`）的每个子弹（从0到99）进行循环。
- en: Within the nested `for` loops, we do the following.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的`for`循环中，我们执行以下操作。
- en: 'We check whether the current bullet is in flight and the current zombie is
    still alive with the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码检查当前子弹是否在飞行，以及当前僵尸是否仍然存活：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Provided the zombie is alive and the bullet is in flight, we test for a rectangle
    intersection with the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设僵尸存活且子弹在飞行，我们使用以下代码测试矩形交集：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the current bullet and zombie have collided, then we take a number of steps,
    as detailed next.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前子弹和僵尸发生碰撞，那么我们将采取一系列步骤，具体如下。
- en: 'Stop the bullet with the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码停止子弹：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Register a hit with the current zombie by calling its `hit` function. Note
    that the `hit` function returns a Boolean that lets the calling code know whether
    the zombie is dead yet. This is shown in the following line of code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用当前僵尸的`hit`函数来记录与当前僵尸的碰撞。请注意，`hit`函数返回一个布尔值，让调用代码知道僵尸是否已经死亡。这在上面的代码行中显示：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside this `if` block, which detects when the zombie is dead and hasn''t just
    wounded us, do the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测僵尸死亡且未刚刚伤害我们的`if`块内部，执行以下操作：
- en: Add ten to `score`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`score`加十。
- en: Change `hiScore` if the score the player has achieved has exceeded (beaten)
    `score`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家获得的分数超过了（击败了）`score`，则需要更改`hiScore`。
- en: Reduce `numZombiesAlive` by one.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`numZombiesAlive`减一。
- en: Check whether all the zombies are dead with `(numZombiesAlive == 0)` and if
    so, change `state` to `LEVELING_UP`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`(numZombiesAlive == 0)`检查所有僵尸是否都已死亡，如果是，则将`state`更改为`LEVELING_UP`。
- en: 'Here is the block of code inside `if(zombies[j].hit())` that we have just discussed:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`if(zombies[j].hit())`中讨论的代码块：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That's the zombies and the bullets taken care of. You can now run the game and
    see the blood. Of course, you won't see the score until we implement the HUD in
    the next chapter.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，僵尸和子弹的问题就解决了。你现在可以运行游戏并看到血液。当然，除非我们在下一章实现HUD，否则你不会看到分数。
- en: Has the player been touched by a zombie?
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家是否被僵尸触碰了？
- en: 'This code is much shorter and simpler than the zombie and bullet collision
    detection code. Add the following highlighted code just after the previous code
    we wrote:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比僵尸和子弹碰撞检测代码要短得多，简单得多。在之前编写的代码之后添加以下突出显示的代码：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we detect whether a zombie has collided with the player by using a `for`
    loop to go through all the zombies. For each zombie that is alive, the code uses
    the `intersects` function to test for a collision with the player. When a collision
    has occurred, we call `player.hit`. Then, we check whether the player is dead
    by calling `player.getHealth`. If the player's health is equal to or less than
    zero, then we change `state` to `GAME_OVER`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个`for`循环遍历所有僵尸来检测僵尸是否与玩家发生碰撞。对于每个存活的僵尸，代码使用`intersects`函数来测试与玩家的碰撞。当发生碰撞时，我们调用`player.hit`。然后，我们通过调用`player.getHealth`来检查玩家是否死亡。如果玩家的健康值等于或小于零，则将`state`更改为`GAME_OVER`。
- en: You can run the game and collisions will be detected. However, as there is no
    HUD or sound effects yet, it is not clear that this is happening. In addition,
    we need to do some more work resetting the game when the player had died, and
    a new game is starting. So, although the game runs, the results are not especially
    satisfying right now. We will improve this over the next two chapters.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行游戏，并且会检测到碰撞。然而，由于目前还没有HUD或音效，不清楚这是否正在发生。此外，我们需要做一些额外的工作来重置玩家死亡时的游戏，并开始新游戏。所以，尽管游戏可以运行，但现在的结果并不特别令人满意。我们将在接下来的两章中改进这一点。
- en: Has the player touched a pickup?
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家是否触摸了拾取物？
- en: 'The collision detection code between the player and each of the two pickups
    is shown here. Add the following highlighted code just after the previous code
    that we added:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家和每个拾取物之间的碰撞检测代码如下。在之前添加的代码之后添加以下突出显示的代码：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding code uses two simple `if` statements to see whether either `healthPickup`
    or `ammoPickup` have been touched by the player.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用了两个简单的`if`语句来检查玩家是否触摸了`healthPickup`或`ammoPickup`。
- en: If a health pickup has been collected, then the `player.increaseHealthLevel`
    function uses the value returned from the `healthPickup.gotIt` function to increase
    the player's health.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收集了生命拾取物，则`player.increaseHealthLevel`函数使用`healthPickup.gotIt`函数返回的值来增加玩家的生命值。
- en: If an ammo pickup has been collected, then `bulletsSpare` is increased by the
    value that's returned from `ammoPickup.gotIt`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经收集了弹药拾取物，则`bulletsSpare`会增加`ammoPickup.gotIt`返回的值。
- en: Important note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can now run the game, kill zombies, and collect pickups! Note that, when
    your health equals zero, the game will enter the `GAME_OVER` state and pause.
    To restart it, you will need to press `Enter`, followed by a number between 1
    and 6\. When we implement the HUD, the home screen, and the leveling up screen,
    these steps will be intuitive and straightforward for the player. We will do so
    in the next chapter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，杀死僵尸，并收集拾取物！注意，当你的生命值等于零时，游戏将进入`GAME_OVER`状态并暂停。要重新开始，你需要按下`Enter`键，然后输入一个介于1到6之间的数字。当我们实现HUD、主屏幕和升级屏幕时，这些步骤对玩家来说将直观且简单。我们将在下一章中这样做。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a busy chapter, but we achieved a lot. Not only did we add bullets
    and pickups to the game through two new classes, but we also made all the objects
    interact as they should by detecting when they collide with each other.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章忙碌的章节，但我们取得了很大的成就。我们不仅通过两个新类添加了子弹和拾取物到游戏中，而且还通过检测它们相互碰撞时，使所有对象都按预期进行交互。
- en: Despite these achievements, we need to do more work to set up each new game
    and to give the player feedback through a HUD. In the next chapter, we will build
    the HUD.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管取得了这些成就，我们还需要做更多的工作来设置每场新游戏，并通过HUD给玩家提供反馈。在下一章中，我们将构建HUD。
- en: FAQ
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'Here are some questions that might be on your mind:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能出现在你脑海中的问题：
- en: Q) Are there any better ways of doing collision detection?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 有没有更好的碰撞检测方法？
- en: A) Yes. There are lots more ways to do collision detection, including but not
    limited to the following.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: A) 是的。有更多方法可以进行碰撞检测，包括但不限于以下方法。
- en: You can divide objects up into multiple rectangles that fit the shape of the
    sprite better. It is perfectly manageable for C++ to check on thousands of rectangles
    each frame. This is especially the case when you use techniques such as neighbor
    checking to reduce the number of tests that are necessary each frame.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将对象分成多个矩形，这些矩形更适合精灵的形状。对于C++来说，每帧检查数千个矩形是完全可行的。这尤其适用于你使用邻居检查等技术来减少每帧必要的测试数量时。
- en: For circular objects, you can use the radius overlap method.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于圆形对象，你可以使用半径重叠方法。
- en: For irregular polygons, you can use the passing number algorithm.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不规则多边形，你可以使用通过数算法。
- en: 'You can review all of these techniques, if you wish, by taking a look at the
    following links:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以通过查看以下链接来回顾所有这些技术：
- en: 'Neighbor checking: [http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/](http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻居检查：[http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/](http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/)
- en: 'Radius overlap method: [http://gamecodeschool.com/essentials/collision-detection-radius-overlap/](http://gamecodeschool.com/essentials/collision-detection-radius-overlap/)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半径重叠方法：[http://gamecodeschool.com/essentials/collision-detection-radius-overlap/](http://gamecodeschool.com/essentials/collision-detection-radius-overlap/)
- en: 'Crossing number algorithm: [http://gamecodeschool.com/essentials/collision-detection-crossing-number/](http://gamecodeschool.com/essentials/collision-detection-crossing-number/)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨越数算法：[http://gamecodeschool.com/essentials/collision-detection-crossing-number/](http://gamecodeschool.com/essentials/collision-detection-crossing-number/)
