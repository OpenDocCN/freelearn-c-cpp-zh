- en: '*Chapter 10*: Pointers, the Standard Template Library, and Texture Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn a lot as well as get plenty done in terms of the game in this
    chapter. We will first learn about the fundamental C++ topic of **pointers**.
    Pointers are variables that hold a memory address. Typically, a pointer will hold
    the memory address of another variable. This sounds a bit like a reference, but
    we will see how they are much more powerful and use a pointer to handle an ever-expanding
    horde of zombies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn about the **Standard Template Library** (**STL**), which
    is a collection of classes that allow us to quickly and easily implement common
    data management techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand the basics of the STL, we will be able to use that new knowledge
    to manage all the textures from the game because, if we have 1,000 zombies, we
    don't really want to load a copy of a zombie graphic into the GPU for each and
    every one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We will also dig a little deeper into OOP and use a **static** function, which
    is a function of a class that can be called without an instance of the class.
    At the same time, we will see how we can design a class to ensure that only one
    instance can ever exist. This is ideal when we need to guarantee that different
    parts of our code will use the same data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Learning about pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the STL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `TextureHolder` class using static functions and a **singleton**
    class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a pointer to a horde of zombies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing some existing code to use the `TextureHolder` class for the player and
    background
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Pointers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers can be the cause of frustration while learning to code C++. However,
    the concept is simple.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A **pointer** is a variable that holds a memory address.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: That's it! There's nothing to be concerned about. What probably causes the frustration
    to beginners is the syntax—the code we use to handle pointers. We will step through
    each part of the code for using pointers. You can then begin the ongoing process
    of mastering them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will actually learn more about pointers than we need to
    for this project. In the next project, we will make greater use of pointers. Despite
    this, we will only scratch the surface of this topic. Further study is definitely
    recommended, and we will talk more about that in the final chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Rarely do I suggest that memorizing facts, figures, or syntax is the best way
    to learn. However, memorizing the brief but crucial syntax related to pointers
    might be worthwhile. This will ensure that the information sinks so deep into
    our brains that we can never forget it. We can then talk about why we would need
    pointers at all and examine their relationship to references. A pointer analogy
    might help:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: If a variable is a house and its contents are the value it holds, then a pointer
    is the address of the house.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, while discussing references, we learned that when we
    pass values to, or return values from, a function, we are actually making a completely
    new house, but it's exactly the same as the previous one. We are making a copy
    of the value that's passed to or from a function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: At this point, pointers are probably starting to sound a bit like references.
    That's because they are a bit like references. Pointers, however, are much more
    flexible, powerful, and have their own special and unique uses. These special
    and unique uses require a special and unique syntax.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Pointer syntax
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main operators associated with pointers. The first is the **address
    of** operator:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second is the **dereference** operator:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will now look at the different ways in which we can use these operators with
    pointers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will notice is that the address of the operator is the
    same as the reference operator. To add to the woes of an aspiring C++ game programmer,
    the operators do different things in different contexts. Knowing this from the
    outset is valuable. If you are staring at some code involving pointers and it
    seems like you are going mad, know this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: You are perfectly sane! You just need to look at the detail of the context.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know that if something isn't clear and immediately obvious, it is not
    your fault. Pointers are not clear and immediately obvious but looking carefully
    at the context will reveal what is going on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge that you need to pay more attention to pointers than
    to previous syntax, as well as what the two operators are (**address of** and
    **dereference**), we can now start to look at some real pointer code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have memorized the two operators before proceeding.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a pointer
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To declare a new pointer, we use the dereference operator, along with the type
    of variable the pointer will be holding the address of. Take a look at the following
    code before we talk about pointers some more:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code declares a new pointer called `pHealth` that can hold the
    address of a variable of the `int` type. Notice I said *can* hold a variable of
    the `int` type. Like other variables, a pointer also needs to be initialized with
    a value to make proper use of it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The name `pHealth`, just like other variables, is arbitrary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: It is common practice to prefix the names of variables that are pointers with
    a `p`. It is then much easier to remember when we are dealing with a pointer and
    can then distinguish them from regular variables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The white space that's used around the dereference operator is optional because
    C++ rarely cares about spaces in syntax. However, it's recommended because it
    aids readability. Look at the following three lines of code that all do the same
    thing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just seen the following format in the previous example, with the dereference
    operator next to the type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code shows white space either side of the dereference operator:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code shows the dereference operator next to the name of the pointer:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth being aware of these possibilities so that when you read code, perhaps
    on the web, you will understand they are all the same. In this book, we will always
    use the first option with the dereference operator next to the type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Just like a regular variable can only successfully contain data of the appropriate
    type, a pointer should only hold the address of a variable of the appropriate
    type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the `int` type should not hold the address of a `String`, `Zombie`,
    `Player`, `Sprite`, `float`, or any other type, except `int`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can initialize our pointers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a pointer
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will see how we can get the address of a variable into a pointer.
    Take a look at the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code, we declare an `int` variable called `health` and initialize
    it to `5`. It makes sense, although we have never discussed it before, that this
    variable must be somewhere in our computer's memory. It must have a memory address.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access this address using the `pHealth` with the address of `health`,
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `pHealth` pointer now holds the address of the regular `int`, `health`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In C++ terminology, we say that `pHealth` points to `health`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: We can use `pHealth` by passing it to a function so that the function can work
    on `health`, just like we did with references.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: There would be no reason for pointers if that was all we were going to do with
    them, so let's take a look at reinitializing them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Reinitializing pointers
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pointer, unlike a reference, can be reinitialized to point to a different
    address. Look at this following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, `pHealth` points to the `int` variable, `score`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the name of our pointer, `pHealth`, is now ambiguous and should perhaps
    have been called `pIntPointer`. The key thing to understand here is that we *can*
    do this reassignment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we haven't actually used a pointer for anything other than simply
    pointing (holding a memory address). Let's see how we can access the value stored
    at the address that's pointed to by a pointer. This will make them genuinely useful.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing a pointer
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that a pointer holds an address in memory. If we were to output this
    address in our game, perhaps in our HUD, after it has been declared and initialized,
    it might look something like this: **9876**.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: It is just a value – a value that represents an address in memory. On different
    operating systems and hardware types, the range of these values will vary. In
    the context of this book, we never need to manipulate an address directly. We
    only care about what the value stored at the address that is pointed to is.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The actual addresses used by variables are determined when the game is executed
    (at runtime) and so there is no way of knowing the address of a variable and hence
    the value stored in a pointer while we are coding the game.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the value stored at the address that''s pointed to by a pointer
    by using the **dereference** operator:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code manipulates some variables directly and by using a pointer.
    Try and follow along and then we will go through it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Warning! The code that follows is pointless (pun intended). It just demonstrates
    using pointers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code, we declare two `int` variables, `score` and `hiScore`.
    We then initialize them with the values 0 and 10, respectively. Next, we declare
    two pointers to `int`. These are `pIntPointer1` and `pIntPointer2`. We initialize
    them in the same step as declaring them to hold the addresses of (point to) the
    `score` and `hiScore` variables, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Following on, we add 10 to `score` in the usual way, `score += 10`. Then, we
    can see that by using the dereference operator on a pointer, we can access the
    value stored at the address they point to. The following code changed the value
    stored by the variable that''s pointed to by `pIntPointer1`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last part of the preceding code dereferences both pointers to assign the
    value that''s pointed to by `pIntPointer1` as the value that''s pointed to by
    `pIntPointer2`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both `score` and `hiScore` are now equal to 20.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are versatile and powerful
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do so much more with pointers. Here are just a few useful things we can
    do.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocated memory
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the pointers we have seen so far point to memory addresses that have a scope
    limited only to the function they are created in. So, if we declare and initialize
    a pointer to a local variable, when the function returns, the pointer, the local
    variable, and the memory address will be gone. They are out of scope.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have been using a fixed amount of memory that is decided in
    advance of the game being executed. Furthermore, the memory we have been using
    is controlled by the operating system, and variables are lost and created as we
    call and return from functions. What we need is a way to use memory that is always
    in scope until we are finished with it. We want to have access to memory we can
    call our own and take responsibility for.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: When we declare variables (including pointers), they are in an area of memory
    known as **the stack**. There is another area of memory which, although allocated
    and controlled by the operating system, can be allocated at runtime. This other
    area of memory is called the **free store**, or sometimes, the **heap**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Memory on the heap does not have scope to a specific function. Returning from
    a function does not delete the memory on the heap.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This gives us great power. With access to memory that is only limited by the
    resources of the computer our game is running on, we can plan games with huge
    amounts of objects. In our case, we want a vast horde of zombies. As Spiderman's
    uncle wouldn't hesitate to remind us, however, "with great power comes great responsibility."
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can use pointers to take advantage of the memory on the
    free store and how we can release that memory back to the operating system when
    we are finished with it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用指针利用空闲存储中的内存，以及我们如何在完成使用后将其释放回操作系统。
- en: 'To create a pointer that points to a value on the heap, we need a pointer:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个指向堆上值的指针，我们需要一个指针：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous line of code, we declare a pointer in the same way we have seen
    before, but since we are not initializing it to point to a variable, we initialize
    it to `nullptr`. We do this because it is good practice. Consider dereferencing
    a pointer (changing a value at the address it points to) when you don't even know
    what it is pointing to. It would be the programming equivalent of going to the
    shooting range, blindfolding someone, spinning them around, and telling them to
    shoot. By pointing a pointer to nothing (`nullptr`), we can't do any harm with
    it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们以我们之前看到的方式声明了一个指针，但由于我们没有初始化它指向一个变量，我们将其初始化为 `nullptr`。我们这样做是因为这是一个好的实践。考虑当你甚至不知道它指向什么时解引用一个指针（改变它指向的地址中的值）。这将编程上的射击场，蒙上眼睛，让人转圈，然后告诉他们射击。通过将指针指向空（`nullptr`），我们无法对它造成任何伤害。
- en: 'When we are ready to request memory on the free store, we use the `new` keyword,
    as shown in the following line of code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备在空闲存储中请求内存时，我们使用 `new` 关键字，如下面的代码行所示：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`pToInt` now holds the memory address of space on the free store that is just
    the right size to hold an `int` value.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`pToInt` 现在持有空闲存储上空间的内存地址，这个空间正好可以存放一个 `int` 值。'
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Any allocated memory is returned when the program ends. It is, however, important
    to realize that this memory will never be freed (within the execution of our game)
    unless we free it. If we continue to take memory from the free store without giving
    it back, eventually it will run out and the game will crash.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序结束时，任何分配的内存都会被返回。然而，重要的是要意识到，除非我们手动释放，否则这块内存（在我们的游戏执行过程中）永远不会被释放。如果我们继续从空闲存储中获取内存而不归还，最终内存会用尽，游戏将会崩溃。
- en: It is unlikely that we would ever run out of memory by occasionally taking `int`
    sized chunks of the free store. But if our program has a function or loop that
    requests memory and this function or loop is executed regularly throughout the
    game, eventually the game will slow and then crash. Furthermore, if we allocate
    lots of objects on the free store and don't manage them correctly, then this situation
    can happen quite quickly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们偶尔从空闲存储中取 `int` 大小的块，不太可能耗尽内存。但如果我们的程序中有一个或多个函数或循环请求内存，并且这个函数或循环在整个游戏过程中定期执行，最终游戏会变慢，然后崩溃。此外，如果我们错误地分配了大量对象到空闲存储，那么这种情况可能会很快发生。
- en: 'The following line of code hands back (deletes) the memory on the free store
    that was previously pointed to by `pToInt`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将 `pToInt` 之前指向的空闲存储中的内存归还（删除）：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, the memory that was previously pointed to by `pToInt` is no longer ours
    to do what we like with; we must take precautions. Although the memory has been
    handed back to the operating system, `pToInt` still holds the address of this
    memory, which no longer belongs to us.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，之前由 `pToInt` 指向的内存不再属于我们可以随意操作的范围；我们必须采取预防措施。尽管内存已经被归还给操作系统，但 `pToInt` 仍然持有这块内存的地址，而这块内存已经不再属于我们。
- en: 'The following line of code ensures that `pToInt` can''t be used to attempt
    to manipulate or access this memory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行确保 `pToInt` 不能被用来尝试操作或访问这块内存：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If a pointer points to an address that is invalid, it is called a **wild** or
    **dangling** pointer. If you attempt to dereference a dangling pointer and if
    you are lucky, the game will crash, and you will get a memory access violation
    error. If you are unlucky, you will create a bug that will be incredibly difficult
    to find. Furthermore, if we use memory on the free store that will persist beyond
    the life of a function, we must make sure to keep a pointer to it or we will have
    leaked memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个指针指向一个无效的地址，它被称为 **野指针** 或 **悬垂指针**。如果你尝试解引用一个悬垂指针，如果你幸运，游戏会崩溃，你会得到一个内存访问违规错误。如果你不幸，你将创建一个难以发现的bug。此外，如果我们使用在函数生命周期之后仍然存在的空闲存储上的内存，我们必须确保保留一个指向它的指针，否则我们将泄漏内存。
- en: Now, we can declare pointers and point them to newly allocated memory on the
    free store. We can manipulate and access the memory they point to by dereferencing
    them. We can also return memory to the free store when we are done with it, and
    we know how to avoid having a dangling pointer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some more advantages of pointers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Passing a pointer to a function
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to pass a pointer to a function, we need to write a function that
    has a pointer in the prototype, like in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding function simply dereferences the pointer and adds 1 to the value
    stored at the pointed to address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use that function and pass the address of a variable or another
    pointer to a variable explicitly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As shown in the previous code, within the function, we are manipulating the
    variable from the calling code and can do so using the address of a variable or
    a pointer to that variable, since both actions amount to the same thing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Pointers can also point to instances of a class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and using a pointer to an object
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pointers are not just for regular variables. We can also declare pointers to
    user-defined types such as our classes. This is how we would declare a pointer
    to an object of the `Player` type:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can even access the member functions of a `Player` object directly from
    the pointer, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the subtle but vital difference: accessing a function with a pointer
    to an object rather than an object directly uses the -> operator. We won''t need
    to use pointers to objects in this project, but we will explore them more carefully
    before we do, which will be in the next project.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over one more new pointer topic before we talk about something completely
    new.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and arrays
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and pointers have something in common. An array's name is a memory address.
    More specifically, the name of an array is the memory address of the first element
    in that array. To put this yet another away, an array name points to the first
    element of an array. The best way to understand this is to read on and look at
    the following example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a pointer to the type that an array holds and then use the pointer
    in the same way using exactly the same syntax that we would use for the array:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This also means that a function that has a prototype that accepts a pointer
    also accepts arrays of the type the pointer is pointing to. We will use this fact
    when we build our ever-increasing horde of zombies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the relationship between pointers and references, the compiler actually
    uses pointers when implementing our references. This means that references are
    just a handy tool (that uses pointers "under the hood"). You could think of a
    reference as an automatic gearbox that is fine and convenient for driving around
    town, whereas pointers are a manual gearbox – more complicated, but with the correct
    use, they can provide better results/performance/flexibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Summary of pointers
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointers are a bit fiddly at times. In fact, our discussion of pointers was
    only an introduction to the subject. The only way to get comfortable with them
    is to use them as much as possible. All you need to understand about pointers
    in order to complete this project is the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are variables that store a memory address.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can pass pointers to functions to directly manipulate values from the calling
    function's scope, within the called function.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array names hold the memory address of the first element. We can pass this address
    as a pointer because that is exactly what it is.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use pointers to point to memory on the free store. This means we can
    dynamically allocate large amounts of memory while the game is running.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are yet more ways to use pointers. We will learn about **smart pointers**
    in the final project, once we have got used to using regular pointers.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is just one more topic to cover before we can start coding the Zombie
    Arena project again.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Template Library
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Standard Template Library (STL)** is a collection of data containers and
    ways to manipulate the data we put in those containers. If we want to be more
    specific, it is a way to store and manipulate different types of C++ variables
    and classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the different containers as customized and more advanced arrays.
    The STL is part of C++. It is not an optional thing that needs to be set up like
    SFML.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The STL is part of C++ because its containers and the code that manipulates
    them are fundamental to many types of code that many apps will need to use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In short, the STL implements code that we and just about every C++ programmer
    is almost bound to need, at least at some point, and probably quite regularly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If we were to write our own code to contain and manage our data, then it is
    unlikely we would write it as efficiently as the people who wrote the STL.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: So, by using the STL, we guarantee that we are using the best written code possible
    to manage our data. Even SFML uses the STL. For example, under the hood, the `VertexArray`
    class uses the STL.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is choose the right type of container from those that are
    available. The types of container that are available through the STL include the
    following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector**: This is like an array with boosters. It handles dynamic resizing,
    sorting, and searching. This is probably the most useful container.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: A container that allows for the ordering of the data.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**: An associative container that allows the user to store data as key/value
    pairs. This is where one piece of data is the "key" to finding the other piece.
    A map can also grow and shrink, as well as be searched.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**: A container that guarantees that every element is unique.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a full list of STL container types, their different uses, and explanations,
    take a look at the following link: [http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm](http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm).'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the Zombie Arena game, we will use a map.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a glimpse into the kind of complexity that the STL is sparing us,
    then take a look at this tutorial, which implements the kind of thing that a list
    would do. Note that the tutorial implements only the very simplest bare-bones
    implementation of a list: [http://www.sanfoundry.com/cpp-program-implement-single-linked-list/](http://www.sanfoundry.com/cpp-program-implement-single-linked-list/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We can easily see that we will save a lot of time and end up with a better game
    if we explore the STL. Let's take a closer look at how to use a `Map` instance,
    and then we will see how it will be useful to us in the Zombie Arena game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: What is a map?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `map` class special compared to the other containers in the STL is the way
    that we access the data within it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The data in a `map` instance is stored in pairs. Consider a situation where
    you log in to an account, perhaps with a username and password. A map would be
    perfect for looking up the username and then checking the value of the associated
    password.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: A map would also be just right for things such as account names and numbers,
    or perhaps company names and share prices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we use `map` from the STL, we decide the type of values that
    form the key-value pairs. The values could be `string` instances and `int` instances,
    such as account numbers; `string` instances and other `string` instances such
    as usernames and passwords; or user-defined types such as objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: What follows is some real code to make us familiar with `map`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a map
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how we could declare a `map`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous line of code declares a new `map` called `accounts` that has a
    key of `string` objects, each of which will refer to a value that is an `int`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We can now store key-value pairs of the `string` type that refer to values of
    the `int` type. We will see how we can do this next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to a Map
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add a key-value pair to accounts:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, there is an entry in the map that can be accessed using the key of John.
    The following code adds two more entries to the accounts map:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our map has three entries in it. Let's see how we can access the account numbers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Finding data in a map
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We would access the data in the same way that we added it: by using the key.
    As an example, we could assign the value stored by the `Smit` key to a new `int`,
    `accountNumber`, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `int` variable, `accountNumber`, now stores the value `7654321`. We can
    do anything to a value stored in a `map` instance that we can do to that type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Removing data from a map
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Taking values out of our map is also straightforward. The following line of
    code removes the key, `John`, and its associated value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's look at a few more things we can do with a `map`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Checking the size of a map
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might like to know how many key-value pairs we have in our map. The following
    line of code does just that:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `int` variable, `size`, now holds the value of `2`. This is because `accounts`
    holds values for Smit and Larissa, because we deleted John.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Checking for keys in a map
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most relevant feature of `map` is its ability to find a value using a key.
    We can test for the presence or otherwise of a specific key like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, the `!= accounts.end` value is used to determine when
    a key does or doesn't exist. If the searched for key is not present in the `map`,
    then `accounts.end` will be the result of the `if` statement.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can test or use all the values in a map by looping through
    a map.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Looping/iterating through the key-value pairs of a map
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how we can use a `for` loop to loop/iterate through all the values
    of an array. But, what if we want to do something like this to a map?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we could loop through each key-value pair of the
    account''s `map` and add one to each of the account numbers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The condition of the `for` loop is probably the most interesting part of the
    previous code. The first part of the condition is the longest part. `map<string,int>::iterator
    it = accounts.begin()` is more understandable if we break it down.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`map<string,int>::iterator` is a type. We are declaring an `iterator` that''s
    suitable for a `map` with key-value pairs of `string` and `int`. The iterator''s
    name is `it`. We assign the value that''s returned by `accounts.begin()` to `it`.
    The iterator, `it`, now holds the first key-value pair from the `accounts` map.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the condition of the `for` loop works as follows. `it != accounts.end()`
    means the loop will continue until the end of the map is reached, and `++it` simply
    steps to the next key-value pair in the map, each pass through the loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop, `it->second` accesses the value of the key-value pair
    and `+= 1` adds one to the value. Note that we can access the key (which is the
    first part of the key-value pair) with `it->first`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the syntax for setting up a loop through a map is
    quite verbose. C++ has a way to cut down on this verbosity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The auto keyword
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in the condition of the `for` loop was quite verbose – especially
    in terms of `map<string,int>::iterator`. C++ supplies a neat way to reduce verbosity
    with the `auto` keyword. Using the `auto` keyword, we can improve the previous
    code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `auto` keyword instructs the compiler to automatically deduce the type for
    us. This will be especially useful with the next class that we write.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: STL summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with almost every C++ concept that we have covered in this book, the STL
    is a massive topic. Whole books have been written covering just the STL. At this
    point, however, we know enough to build a class that uses the STL `map` to store
    SFML `Texture` objects. We can then have textures that can be retrieved/loaded
    by using the filename as the key of the key-value pair.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we would go to this extra level of complexity and not just carry
    on using the `Texture` class the same way as we have been so far will become apparent
    as we proceed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The TextureHolder class
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thousands of zombies represent a new challenge. Not only would loading, storing,
    and manipulating thousands of copies of three different zombie textures take up
    a lot of memory, but also a lot of processing power. We will create a new type
    of class that overcomes this problem and allows us to store just one of each texture.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We will also code the class in such a way that there can only ever be one instance
    of it. This type of class is called a **singleton**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: A singleton is a design pattern. A design pattern is a way to structure our
    code that is proven to work.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will also code the class so that it can be used anywhere in
    our game code directly through the class name, without access to an instance.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Coding the TextureHolder header file
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make a new header file. Right-click `TextureHolder.h`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code that follows into the `TextureHolder.h` file, and then we can
    discuss it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous code, notice that we have an `include` directive for `map` from
    the STL. We declare a `map` instance that holds the `string` type and the SFML
    `Texture` type, as well as the key-value pairs. The `map` is called `m_Textures`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, this line follows on:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The previous line of code is quite interesting. We are declaring a static pointer
    to an object of the `TextureHolder` type called `m_s_Instance`. This means that
    the `TextureHolder` class has an object that is the same type as itself. Not only
    that, but because it is static, it can be used through the class itself, without
    an instance of the class. When we code the related `.cpp` file, we will see how
    we can use this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the `public` part of the class, we have the prototype for the constructor
    function, `TextureHolder`. The constructor takes no arguments and, as usual, has
    no return type. This is the same as the default constructor. We are going to override
    the default constructor with a definition that makes our singleton work how we
    want it to.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another function called `GetTexture`. Let''s look at the signature
    again and analyze exactly what is happening:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, notice that the function returns a reference to a `Texture`. This means
    that `GetTexture` will return a reference, which is efficient because it avoids
    making a copy of what could be a large graphic. Also, notice that the function
    is declared as `static`. This means that the function can be used without an instance
    of the class. The function takes a `string` as a constant reference, as a parameter.
    The effect of this is two-fold. Firstly, the operation is efficient and secondly,
    because the reference is constant, it can't be changed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Coding the TextureHolder function definitions
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can create a new `.cpp` file that will contain the function definition.
    This will allow us to see the reasons behind our new types of functions and variables.
    Right-click `TextureHolder.cpp`. Finally, click the **Add** button. We are now
    ready to code the class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code, and then we can discuss it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the previous code, we initialize our pointer of the `TextureHolder` type
    to `nullptr`. In the constructor, `assert(m_s_Instance == nullptr)` ensures that
    `m_s_Instance` equals `nullptr`. If it doesn't the game will exit execution. Then,
    `m_s_Instance = this` assigns the pointer to `this` instance. Now, consider where
    this code is taking place. The code is in the constructor. The constructor is
    the way that we create instances of objects from classes. So, effectively, we
    now have a pointer to a `TextureHolder` that points to the one and only instance
    of itself.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the final part of the code to the `TextureHolder.cpp` file. There are more
    comments than code here. Examine the following code and read the comments as you
    add the code, and then we can go through it:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first thing you will probably notice about the previous code is the `auto`
    keyword. The `auto` keyword was explained in the previous section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know what the actual types that have been replaced by `auto`
    are, then look at the comments immediately after each use of `auto` in the previous
    code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the code, we get a reference to `m_textures`. Then, we attempt
    to get an iterator to the key-value pair represented by the passed-in filename
    (`filename`). If we find a matching key, we return the texture with `return keyValuePair->second`.
    Otherwise, we add the texture to the map and then return it to the calling code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, the `TextureHolder` class introduced lots of new concepts (singletons,
    `static` functions, constant references, `this`, and the `auto` keyword,) and
    syntax. Add to this the fact that we have only just learned about pointers and
    the STL, and this section's code might have been a little daunting.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: So, was it all worth it?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: What have we achieved with TextureHolder?
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The point is that now that we have this class, we can go wild using textures
    from wherever we like in our code and not worry about running out of memory or
    having access to any texture in a particular function or class. We will see how
    to use `TextureHolder` soon.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Building a horde of zombies
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are armed with the `TextureHolder` class to make sure that our zombie
    textures are easily available as well as only loaded into the GPU once. Then,
    we can investigate creating a whole horde of them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We will store zombies in an array. Since the process of building and spawning
    a horde of zombies involves quite a few lines of code, it is a good candidate
    for abstracting to a separate function. Soon, we will code the `CreateHorde` function
    but first, of course, we need a `Zombie` class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Zombie.h file
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to building a class to represent a zombie is to code the member
    variables and function prototypes in a header file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `Zombie.h`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Zombie.h` file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The previous code declares all the private member variables of the `Zombie`
    class. At the top of the previous code, we have three constant variables to hold
    the speed of each type of zombie: a very slow Crawler, a slightly faster Bloater,
    and a somewhat speedy Chaser. We can experiment with the value of these three
    constants to help balance the difficulty level of the game. It''s also worth mentioning
    here that these three values are only used as a starting value for the speed of
    each zombie type. As we will see later in this chapter, we will vary the speed
    of every zombie by a small percentage from these values. This stops zombies of
    the same type from bunching up together as they pursue the player.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The next three constants determine the health level for each zombie type. Note
    that Bloaters are the toughest, followed by Crawlers. As a matter of balance,
    the Chaser zombies will be the easiest to kill.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two more constants, `MAX_VARRIANCE` and `OFFSET`. These will help
    us determine the individual speed of each zombie. We will see exactly how when
    we code the `Zombie.cpp` file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'After these constants, we declare a bunch of variables that should look familiar
    because we had very similar variables in our `Player` class. The `m_Position`,
    `m_Sprite`, `m_Speed`, and `m_Health` variables are for what their names imply:
    the position, sprite, speed, and health of the zombie object.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the preceding code, we declare a Boolean called `m_Alive`, which
    will be true when the zombie is alive and hunting, but false when its health gets
    to zero and it is just a splurge of blood on our otherwise pretty background.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can complete the `Zombie.h` file. Add the function prototypes highlighted
    in the following code, and then we will talk about them:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the previous code, there is a `hit` function, which we can call every time
    the zombie is hit by a bullet. The function can then take the necessary steps,
    such as taking health from the zombie (reducing the value of `m_Health`) or killing
    it dead (setting `m_Alive` to false).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `isAlive` function returns a Boolean that lets the calling code know whether
    the zombie is alive or dead. We don't want to perform collision detection or remove
    health from the player for walking over a blood splat.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The `spawn` function takes a starting position, a type (Crawler, Bloater, or
    Chaser, represented by an `int`), as well as a seed to use in some random number
    generation that we will see in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Just like we have in the `Player` class, the `Zombie` class has `getPosition`
    and `getSprite` functions to get a rectangle that represents the space occupied
    by the zombie and the sprite that can be drawn each frame.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The last prototype in the previous code is the `update` function. We could have
    probably guessed that it would receive the elapsed time since the last frame,
    but also notice that it receives a `Vector2f` vector called `playerLocation`.
    This vector will indeed be the exact coordinates of the center of the player.
    We will soon see how we can use this vector to chase after the player.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can code the function definitions in the `.cpp` file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Zombie.cpp file
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will code the functionality of the `Zombie` class— the function definitions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `.cpp` file that will contain the function definitions. Right-click
    `Zombie.cpp`. Finally, click the **Add** button. We are now ready to code the
    class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Zombie.cpp` file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we add the necessary include directives and then `using namespace std`.
    You might remember a few instances when we prefixed our object declarations with
    `std::`. This `using` directive means we don't need to do that for the code in
    this file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code, which is the definition of the `spawn` function.
    Study the code once you have added it, and then we will discuss it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first thing the function does is `switch` paths of execution based on the
    `int` value, which is passed in as a parameter. Within the `switch` block, there
    is a `case` for each type of zombie. Depending on the type of zombie, the appropriate
    texture, speed, and health is initialized to the relevant member variables.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: We could have used an enumeration for the different types of zombie. Feel free
    to upgrade your code when the project is finished.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Of interest here is that we use the static `TextureHolder::GetTexture` function
    to assign the texture. This means that no matter how many zombies we spawn, there
    will be a maximum of three textures in the memory of the GPU.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three lines of code (excluding comments) do the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Seed the random number generator with the `seed` variable that was passed in
    as a parameter.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare and initialize the `modifier` variable using the `rand` function and
    the `MAX_VARRIANCE` and `OFFSET` constants. The result is a fraction between zero
    and one, which can be used to make each zombie's speed unique. The reason we want
    to do this is so that the zombies don't bunch up together on top of each other
    too much.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now multiply `m_Speed` by `modifier` and we will have a zombie whose
    speed is within the `MAX_VARRIANCE` percent of the constant defined for this type
    of zombie's speed.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we have resolved the speed, we assign the passed-in position held in `startX`
    and `startY` to `m_Position.x` and `m_Position.y`, respectively.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines of code in the previous listing set the origin of the sprite
    to the center and use the `m_Position` vector to set the position of the sprite.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code for the `hit` function to the `Zombie.cpp` file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `hit` function is nice and simple: reduce `m_Health` by one and then check
    whether `m_Health` is below zero.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: If it is below zero, then it sets `m_Alive` to false, swaps the zombie's texture
    for a blood splat, and returns `true` to the calling code so that it knows the
    zombie is now dead. If the zombie has survived, the hit returns `false`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following three getter functions, which just return a value to the
    calling code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The previous three functions are quite self-explanatory, perhaps with the exception
    of the `getPosition` function, which uses the `m_Sprite.getLocalBounds` function
    to get the `FloatRect` instance, which is then returned to the calling code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for the `Zombie` class, we need to add the code for the `update` function.
    Look closely at the following code, and then we will go through it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we copy `playerLocation.x` and `playerLocation.y` into
    the local variables called `playerX` and `playerY`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Next, there are four `if` statements. They test to see whether the zombie is
    to the left, right, above, or below the current player's position. These four
    `if` statements, when they evaluate to true, adjust the zombie's `m_Position.x`
    and `m_Position.y` values appropriately using the usual formula, that is, speed
    multiplied by time since last frame. More specifically, the code is `m_Speed *
    elapsedTime`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: After the four `if` statements, `m_Sprite` is moved to its new location.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We then use the same calculation we previously used with the player and the
    mouse pointer, but this time, we do so for the zombie and the player. This calculation
    finds the angle that's needed to face the zombie toward the player.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for this function and the class, we call `m_Sprite.setRotation` to
    actually rotate the zombie sprite. Remember that this function will be called
    for every zombie (that is alive) on every frame of the game.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: But, we want a whole horde of zombies.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Using the Zombie class to create a horde
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a class to create a living, attacking, and killable zombie,
    we want to spawn a whole horde of them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will write a separate function and we will use a pointer
    so that we can refer to our horde that will be declared in `main` but configured
    in a different scope.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ZombieArena.h` file in Visual Studio and add the following highlighted
    lines of code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we have a prototype, we can code the function definition.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `.cpp` file that will contain the function definition. Right-click
    `CreateHorde.cpp`. Finally, click the **Add** button.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Add in the following code to the `CreateHorde.cpp` file and study it. Afterward,
    we will break it down into chunks and discuss it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s look at all the previous code again, in bite-size pieces. First, we
    added the now familiar `include` directives:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next comes the function signature. Notice that the function must return a pointer
    to a `Zombie` object. We will be creating an array of `Zombie` objects. Once we
    are done creating the horde, we will return the array. When we return the array,
    we are actually returning the address of the first element of the array. This,
    as we learned in the section on pointers earlier in this chapter, is the same
    thing as a pointer. The signature also shows that we have two parameters. The
    first, `numZombies`, will be the number of zombies this current horde requires
    and the second, `arena`, is an `IntRect` that holds the size of the current arena
    in which to create this horde.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'After the function signature, we declare a pointer to the `Zombie` type called
    `zombies` and initialize it with the memory address of the first element of an
    array, which we dynamically allocate on the heap:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next part of the code simply copies the extremities of the arena into `maxY`,
    `minY`, `maxX`, and `minX`. We subtract twenty pixels from the right and bottom
    while adding twenty pixels to the top and left. We use these four local variables
    to help position each of the zombies. We made the twenty-pixel adjustments to
    stop the zombies appearing on top of the walls:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we enter a `for` loop that will loop through each of the `Zombie` objects
    in the `zombies` array from zero through to `numZombies`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `for` loop, the first thing the code does is seed the random number
    generator and then generate a random number between zero and three. This number
    is stored in the `side` variable. We will use the `side` variable to decide whether
    the zombie spawns at the left, top, right, or bottom of the arena. We also declare
    two `int` variables, `x` and `y`. These two variables will temporarily hold the
    actual horizontal and vertical coordinates of the current zombie:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Still inside the `for` loop, we have a `switch` block with four `case` statements.
    Note that the `case` statements are for `0`, `1`, `2`, and `3`, and that the argument
    in the `switch` statement is `side`. Inside each of the `case` blocks, we initialize
    `x` and `y` with one predetermined value, either `minX`, `maxX`, `minY`, or `maxY`,
    and one randomly generated value. Look closely at the combinations of each predetermined
    and random value. You will see that they are appropriate for positioning the current
    zombie randomly across either the left side, top side, right side, or bottom side.
    The effect of this will be that each zombie can spawn randomly, anywhere on the
    outside edge of the arena:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Still inside the `for` loop, we seed the random number generator again and generate
    a random number between 0 and 2\. We store this number in the `type` variable.
    The `type` variable will determine whether the current zombie will be a Chaser,
    Bloater, or Crawler.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'After the type is determined, we call the `spawn` function on the current `Zombie`
    object in the `zombies` array. As a reminder, the arguments that are sent into
    the `spawn` function determine the starting location of the zombie and the type
    of zombie it will be. The apparently arbitrary `i` is passed in as it is used
    as a unique seed that randomly varies the speed of a zombie within an appropriate
    range. This stops our zombies "bunching up" and becoming a blob rather than a
    horde:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `for` loop repeats itself once for each zombie, controlled by the value
    contained in `numZombies`, and then we return the array. The array, as another
    reminder, is simply an address of the first element of itself. The array is dynamically
    allocated on the heap, so it persists after the function returns:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we can bring our zombies to life.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the horde to life (back to life)
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a `Zombie` class and a function to make a randomly spawning horde of
    them. We have the `TextureHolder` singleton as a neat way to hold just three textures
    that can be used for dozens or even thousands of zombies. Now, we can add the
    horde to our game engine in `main`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to include the `TextureHolder` class. Then,
    just inside `main`, we will initialize the one and only instance of `TextureHolder`,
    which can be used from anywhere within our game:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following few lines of highlighted code declare some control variables
    for the number of zombies at the start of the wave, the number of zombies still
    to be killed, and, of course, a pointer to `Zombie` called `zombies` that we initialize
    to `nullptr`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, in the `PLAYING` section, nested inside the `LEVELING_UP` section, we
    add code that does the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Initializes `numZombies` to `10`. As the project progresses, this will eventually
    be dynamic and based on the current wave number.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete any preexisting allocated memory. Otherwise, each new call to `createHorde`
    would take up progressively more memory but without freeing up the previous horde's
    memory.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we call `createHorde` and assign the returned memory address to `zombies`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also initialize `zombiesAlive` with `numZombies` because we haven't killed
    any at this point.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following highlighted code, which we have just discussed:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, add the following highlighted code to the `ZombieArena.cpp` file:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: All the new preceding code does is loop through the array of zombies, check
    whether the current zombie is alive and, if it is, calls its `update` function
    with the necessary arguments.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to draw all the zombies:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding code loops through all the zombies and calls the `getSprite` function
    to allow the `draw` function to do its work. We don't check whether the zombie
    is alive because even if the zombie is dead, we want to draw the blood splatter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the main function, we need to make sure to delete our pointer
    because it is a good practice as well as often being essential. However, technically,
    this isn''t essential because the game is about to exit, and the operating system
    will reclaim all the memory that''s used after the `return 0` statement:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can run the game and see the zombies spawn around the edge of the arena.
    They will immediately head straight toward the player at their various speeds.
    Just for fun, I increased the size of the arena and increased the number of zombies
    to 1,000 as you can see in the following screenshot:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_10_01.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: This is going to end badly!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also pause and resume the onslaught of the horde using the
    *Enter* key because of the code we wrote in [*Chapter 8*](B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183),
    *SFML Views – Starting the Zombie Shooter Game*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Let's fix the fact that some classes still use a `Texture` instance directly
    and modify it to use the new `TextureHolder` class.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Using the TextureHolder class for all textures
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have our `TextureHolder` class, we might as well be consistent and
    use it to load all our textures. Let's make some very small alterations to the
    existing code that loads textures for the background sprite sheet and the player.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Changing the way the background gets its textures
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `ZombieArena.cpp` file, find the following code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Delete the code highlighted previously and replace it with the following highlighted
    code, which uses our new `TextureHolder` class:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Let's update the way the `Player` class gets a texture.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Changing the way the Player gets its texture
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Player.cpp` file, inside the constructor, find this code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Delete the code highlighted previously and replace it with the following highlighted
    code, which uses our new `TextureHolder` class. In addition, add the `include`
    directive to add the `TextureHolder` header to the file. The new code is shown
    highlighted, in context, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Tip
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we will use the `TextureHolder` class for loading all textures.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered pointers and discussed that they are variables
    that hold a memory address to a specific type of object. The full significance
    of this will begin to reveal itself as this book progresses and the power of pointers
    is revealed. We also used pointers in order to create a huge horde of zombies
    that can be accessed using a pointer, which it turns out is also the same thing
    as the first element of an array.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the STL, and in particular the `map` class. We implemented
    a class that will store all our textures, as well as provide access to them.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the zombies don't appear to be very dangerous. They
    just drift through the player without leaving a scratch. Currently, this is a
    good thing because the player has no way to defend themselves.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到僵尸看起来并不危险。它们只是穿过玩家而不会留下任何痕迹。目前，这是好事，因为玩家没有防御自己的方法。
- en: 'In the next chapter, we will make two more classes: one for ammo and health
    pickups and one for bullets that the player can shoot. After we have done that,
    we will learn how to detect collisions so that the bullets and zombies do some
    damage and the pickups can be collected by the player.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建两个更多的类：一个用于弹药和健康拾取，另一个用于玩家可以射击的子弹。在完成这些之后，我们将学习如何检测碰撞，以便子弹和僵尸造成伤害，玩家可以收集拾取物。
- en: FAQ
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ
- en: 'Here are some questions that might be on your mind:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能出现在你脑海中的问题：
- en: Q) What's the difference between pointers and references?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 指针和引用有什么区别？
- en: A) Pointers are like references with boosters. Pointers can be changed to point
    to different variables (memory addresses), as well as point to dynamically allocated
    memory on the free store.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: A) 指针就像带有助推器的引用。指针可以被改变以指向不同的变量（内存地址），以及指向自由存储上的动态分配内存。
- en: Q) What's the deal with arrays and pointers?
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 数组和指针之间有什么关系？
- en: A) Arrays are really constant pointers to their first element.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: A) 数组实际上是它们第一个元素的常量指针。
- en: Q) Can you remind me about the `new` keyword and memory leaks?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 你能提醒我一下`new`关键字和内存泄漏吗？
- en: A) When we use memory on the free store using the `new` keyword, it persists
    even when the function it was created in has returned and all the local variables
    are gone. When we are done with using memory on the free store, we must release
    it. So, if we use memory on the free store that we want to persist beyond the
    life of a function, we must make sure to keep a pointer to it or we will have
    leaked memory. It would be like putting all our belongings in our house and then
    forgetting where we live! When we return the `zombies` array from `createHorde`,
    it is like passing the relay baton (memory address) from `createHorde` to `main`.
    It's like saying, *OK, here is your horde of zombies— they are your responsibility
    now*. And, we wouldn't want any leaked zombies running around in our RAM! So,
    we must remember to call `delete` on pointers to dynamically allocated memory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: A) 当我们使用`new`关键字在自由存储上分配内存时，即使创建它的函数已经返回并且所有局部变量都已消失，内存仍然存在。当我们完成在自由存储上使用内存后，我们必须释放它。因此，如果我们想在函数的生命周期之外持久化使用自由存储上的内存，我们必须确保保留对其的指针，否则我们将会有内存泄漏。这就像把所有的东西都放在我们的房子里，然后忘记我们住在哪里！当我们从`createHorde`返回`zombies`数组时，就像从`createHorde`传递接力棒（内存地址）到`main`。这就像说：“好吧，这是你的僵尸群——现在它们是你的责任了。”而且，我们不想有任何泄漏的僵尸在我们的RAM中四处游荡！所以，我们必须记得调用`delete`来删除动态分配内存的指针。
