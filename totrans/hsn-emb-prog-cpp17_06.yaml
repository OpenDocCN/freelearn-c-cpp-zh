- en: Example - Soil Humidity Monitor with Wi-Fi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 带 Wi-Fi 的土壤湿度监测器
- en: Keeping indoor plants alive is no small feat. The example project in this chapter
    will show you how to create a Wi-Fi-enabled soil humidity monitor with actuator
    options for a pump or similar, like a valve and gravity-fed water tank. Using
    the built-in web server, we will be able to use its browser-based UI for monitoring
    the plant health and control system features, or integrate it into a larger system
    using its HTTP-based REST API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 保持室内植物存活并非易事。本章中的示例项目将向您展示如何创建一个带有泵或类似执行器的 Wi-Fi 土壤湿度监测器，例如阀门和重力供水水箱。使用内置的 Web
    服务器，我们将能够使用基于浏览器的用户界面来监控植物健康和控制系统功能，或者使用其基于 HTTP 的 REST API 将其集成到更大的系统中。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Programming an ESP8266 microcontroller
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程 ESP8266 微控制器
- en: Connecting sensors and actuators to an ESP8266
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传感器和执行器连接到 ESP8266
- en: Implementing an HTTP server on this platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此平台上实现 HTTP 服务器
- en: Developing a web-based UI for monitoring and control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于网页的用户界面以进行监控和控制
- en: Integrating the project into a larger network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目集成到更大的网络中
- en: Keeping plants happy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让植物快乐
- en: 'To keep plants alive, you need a number of things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让植物存活，你需要许多东西：
- en: Nutrients
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营养
- en: Light
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光
- en: Water
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水
- en: Of these, the first two are usually handled by nutrient-rich soil and putting
    the plant in a well-lit place, respectively. The main issue with keeping plants
    alive after satisfying those two points is usually the third point, as this has
    to be handled on a daily basis.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，前两种通常通过富含营养的土壤和将植物放置在光照充足的地方来处理。在满足这两个条件后，保持植物存活的主要问题通常是第三个问题，因为这需要每天处理。
- en: Here, it's not just a simple matter of keeping the water topped up, but instead
    of staying within the range where the soil has enough but not too much water.
    The presence of too much water in the soil affects how much oxygen the plant can
    absorb via its roots. As a result, with too much water in the soil, the plant
    will wither and die.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不仅仅是简单地保持水分充足的问题，而是要保持在土壤中有足够但不过多的水分范围内。土壤中水分过多会影响植物通过根部吸收的氧气量。因此，当土壤中水分过多时，植物会枯萎死亡。
- en: On the other hand, too little water means that the plant cannot take up enough
    water to compensate for the water that is being evaporated through its leaves,
    nor can it get the nutrients into its roots. In this case, the plant will also
    wither and die.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，水分过少意味着植物无法吸收足够的水来补偿通过其叶子蒸发的水分，也无法将养分输送到根部。在这种情况下，植物也会枯萎死亡。
- en: When manually watering plants, we tend to use rough estimates of when the plant
    will likely need more water, along with a superficial testing of the humidity
    of the top soil, using our fingers. This tells us little about how much water
    is actually present around the roots of the plant, far below the upper layer of
    soil.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动给植物浇水时，我们倾向于使用对植物可能需要更多水的粗略估计，以及用手指对表层土壤湿度的表面测试。这告诉我们很少关于实际上在植物根部周围有多少水分，远在土壤上层之下。
- en: 'To measure the humidity of the soil with more precision, we can use a number
    of methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确地测量土壤湿度，我们可以使用多种方法：
- en: '| **Type** | **Principle** | **Notes** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **原理** | **注意事项** |'
- en: '| Gypsum block | Resistance—– | Water is absorbed by the gypsum, dissolving
    some of it, which allows a current to flow between two electrodes. The resistance
    value indicates soil moisture tension. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 硫酸钙块 | 电阻—— | 水被硫酸钙吸收，部分溶解，这允许电流在两个电极之间流动。电阻值指示土壤水分张力。 |'
- en: '| Tensiometer | Vacuum | A hollow tube has a vacuum meter on one end and a
    porous tip at the other, allowing water to enter and leave freely. Water getting
    sucked out of the tube by the soil increases the vacuum sensor readings, indicating
    that it''s harder to extract moisture from the soil for plants (moisture tension).
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 张力计 | 真空 | 一根空心管的一端有一个真空计，另一端有一个多孔尖端，允许水自由进出。土壤通过管子吸水会增加真空传感器的读数，表明从土壤中提取水分对植物来说更困难（水分张力）。
    |'
- en: '| Capacitance probe | **Frequency Domain Reflectometry** (**FDR**) | Uses the
    dielectric constant between two metal electrodes (in the soil) in an oscillator
    circuit to measure changes to this constant due to changing moisture levels. Indicates
    moisture content. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 电容探头 | **频域反射测量法** (**FDR**) | 利用振荡电路中两个金属电极（在土壤中）之间的介电常数来测量由于水分含量变化而引起的该常数的改变。指示水分含量。
    |'
- en: '| Microwave sensor | **Time Domain Reflectometry** (**TDR**) | Measures the
    time required for a microwave signal to travel to the end of the parallel probes
    and back, which differs depending on the dielectric constant of the soil. Measures
    moisture content. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 微波传感器 | **时域反射计**（TDR） | 测量微波信号从平行探头的一端传播到另一端所需的时间，这取决于土壤的介电常数。测量水分含量。|'
- en: '| ThetaProbe | RF amplitude impedance | A 100 MHz sine wave radio signal is
    sent among four probes enclosing a soil cylinder. The change in the impedance
    of the sine wave is used to calculate the water in the soil. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| ThetaProbe | RF幅度阻抗 | 通过四个包围土壤圆柱体的探头发送一个100 MHz的正弦波无线电信号。使用正弦波阻抗的变化来计算土壤中的水分。|'
- en: '| Resistance probe | Resistance | This is similar to the gypsum block, except
    with just the electrodes. Thus, this only measures water presence (and its conductivity)
    instead of soil moisture tension. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 电阻探头 | 电阻 | 这与石膏块类似，只是有电极。因此，这仅测量水的存在（及其导电性），而不是土壤水分张力。|'
- en: All of these sensor types come with their own sets of advantages of disadvantages.
    In the case of the gypsum block and tensiometer, there is a significant amount
    of maintenance, as the former relies on there being enough of the gypsum remaining
    to dissolve and not throw off the calibration, whereas in the latter case, it
    is imperative that the airtight seal remains so as not to let air into the tube.
    Any gap in this seal would immediately render the vacuum sensor useless.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些传感器类型都带有它们自己的优缺点。在石膏块和张力计的情况下，维护量很大，因为前者依赖于足够的石膏残留物来溶解，而不会破坏校准，而在后者的情况下，必须确保气密密封保持完好，以防止空气进入管中。任何密封的缝隙都会立即使真空传感器失效。
- en: 'Another big point is that of cost. While FDR- and TDR-based probes may be quite
    accurate, they also tend to be very expensive. This usually leads people who just
    want to experiment with soil moisture sensors to pick either the resistance or
    capacitance-based sensors. Here, the main disadvantage of the former sensor type
    becomes obvious in a month or less of usage: corrosion.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是成本。虽然基于FDR和TDR的探测器可能非常准确，但它们也往往非常昂贵。这通常导致只想尝试土壤湿度传感器的用户选择基于电阻或电容的传感器。在这里，前一种传感器类型的主要缺点在一个月或更短的时间内变得明显：腐蚀。
- en: With two electrodes suspended in a solution containing ions and a current being
    applied to one of the electrodes, simple chemistry results in one of the electrodes
    rapidly corroding (losing material), until it is no longer functional. This also
    pollutes the soil with metal molecules. The use of an **alternating current**
    (**AC**) instead of a direct current on a single electrode can reduce the corrosive
    effect somewhat, but it remains an issue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在含有离子的溶液中悬挂两个电极，并给其中一个电极施加电流时，简单的化学反应会导致其中一个电极迅速腐蚀（材料损失），直到它不再功能。这也会使土壤受到金属分子的污染。在单个电极上使用交流电（AC）而不是直流电可以稍微减少腐蚀作用，但这仍然是一个问题。
- en: Among cheap and still accurate soil moisture sensors, only the capacitance probe
    ticks all of the boxes. Its accuracy is decent enough for sensible measurements
    and comparisons (after calibration), it is unaffected by the moisture in the soil,
    and it does not affect the soil in any manner either.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在价格低廉且仍然准确的土壤湿度传感器中，只有电容探头符合所有要求。它的精度足够进行合理的测量和比较（校准后），它不受土壤中水分的影响，也不会以任何方式影响土壤。
- en: To actually get water to the plant, we need to have a way to get just the right
    amount to it. Here, it's mostly the scale of the system that determines the choice
    of water delivery. For watering an entire field, we could use an impeller-based
    pump, capable of delivering many liters of water per minute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际上将水输送到植物，我们需要有一种方法来提供恰好适量的水。在这里，系统的规模主要决定了水输送的选择。对于灌溉整个田地，我们可以使用基于叶轮的泵，每分钟可以输送许多升的水。
- en: For a single plant, we would need to be able to deliver in the order of a few
    hundred milliliters per minute at most. Here, something such as a peristaltic
    pump would be pretty much ideal. This is the kind of pump you would also use in
    laboratories and medical applications where you have to provide a small amount
    of fluid with high accuracy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单株植物，我们最多需要每分钟提供几百毫升的水。在这里，某种像蠕动泵这样的设备几乎是理想的。这种泵也用于实验室和医疗应用中，在这些应用中，你必须提供少量液体，并且需要高精度。
- en: Our solution
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的解决方案
- en: To keep things simple, we will just be building something that can take care
    of a single plant. This will provide us with the most flexibility in terms of
    placement, as we would just have a single system next to each plant, no matter
    whether it's on a windowsill, table, or terrace somewhere.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们只需构建一个能够照顾单一植物的系统。这将为我们提供最大的灵活性，因为我们只需在每个植物旁边放置一个系统，无论它是在窗台上、桌子上还是某个地方的露台上。
- en: In addition to measuring the soil moisture level, we would also want to be able
    to have the system automatically water the plant at set trigger levels and for
    us to be able to monitor this process. This requires some kind of network access,
    preferably wireless so that we don't have to run any more cables than the power
    connector.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测量土壤湿度水平外，我们还想能够让系统在设定的触发水平下自动给植物浇水，并能够监控这个过程。这需要某种形式的网络访问，最好是无线访问，这样我们就不需要再铺设任何电缆，除了电源连接器。
- en: This makes the ESP8266 MCU very attractive, with the NodeMCU development board
    an attractive target for developing and debugging the system. We'd hook up a soil
    moisture sensor to it, along with a peristaltic pump.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得ESP8266 MCU非常吸引人，NodeMCU开发板是开发和调试系统的理想目标。我们将连接一个土壤湿度传感器和一个蠕动泵。
- en: By connecting to the ESP8266 system's IP address using a web browser, we would
    see the current status of the system, with the soil humidity level and optionally
    much more. Configuring the system and more would be done over the commonly used,
    compact binary MQTT protocol, with the system also publishing the current system
    status so that we can read it into a database for display and analysis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用网络浏览器连接到ESP8266系统的IP地址，我们可以看到系统的当前状态，包括土壤湿度水平以及可选的更多信息。配置系统和更多操作将通过常用的紧凑型二进制MQTT协议完成，系统也会发布当前系统状态，以便我们可以将其读入数据库进行显示和分析。
- en: This way, we can also write a backend service later on that combines many of
    such nodes into a coherent system with central control and management. This is
    something that we will actually look at in great detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Monitoring and Control*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们还可以在以后编写后端服务，将许多这样的节点组合成一个具有集中控制和管理的完整系统。这是我们将在第9章（[示例 - 构建监控和控制](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)）中详细探讨的内容。
- en: The hardware
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: 'Our ideal solution would have the most accurate sensor, without breaking the
    bank. This means that we pretty much have to use a capacitance sensor, as we saw
    earlier in this chapter. These sensors can be obtained as capacitive soil moisture
    sensors for little more than a few euros or dollars for a simple 555 timer IC-based
    design such as these:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理想的解决方案是拥有最精确的传感器，同时不花费太多。这意味着我们基本上必须使用电容式传感器，正如我们在本章前面所看到的。这些传感器可以作为电容式土壤湿度传感器以几欧元或美元的价格获得，例如这些基于简单555定时器IC的设计：
- en: '![](img/9473a55a-2149-4762-9a3d-1580277a0462.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9473a55a-2149-4762-9a3d-1580277a0462.png)'
- en: You would simply stick these into the soil up to the point where the circuitry
    begins, then connect it with a power source as well as the connection to the analog
    to digital converter of the MCU.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需将这些设备插入土壤中，直到电路开始的地方，然后连接电源以及连接到MCU的模拟到数字转换器。
- en: Most peristaltic pumps one can purchase require 12V. This means that we need
    to either have a power supply that can provide both 5V and 12V, or use a so-called
    boost converter to convert the 5V to 12V. Either way, we would also need to have
    some method to turn the pump on or off. With the boost converter, we can use its
    *enable* pin to turn its output on or off using a GPIO pin on our MCU.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可购买的蠕动泵都需要12V。这意味着我们需要有一个能够提供5V和12V的电源，或者使用所谓的升压转换器将5V转换为12V。无论如何，我们还需要有一种方法来打开或关闭泵。使用升压转换器，我们可以使用其*使能*引脚通过我们的MCU上的GPIO引脚来打开或关闭其输出。
- en: 'For prototyping, we can use one of these common 5V to 12V boost converter modules
    that use an ME2149 step-up switching regulator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原型设计，我们可以使用这些常见的5V到12V升压转换模块，这些模块使用ME2149升压开关稳压器：
- en: '![](img/97a91881-f1ca-4bbf-a786-fd122d1bba40.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97a91881-f1ca-4bbf-a786-fd122d1bba40.png)'
- en: 'These do not have the enable pin broken out in any way, but we can easily solder
    on a wire to the pin in question:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块没有以任何方式引出使能引脚，但我们可以轻松地焊接一根线到相应的引脚上：
- en: '![](img/d992fb6a-fb74-480f-9d5c-4cec48efd14b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d992fb6a-fb74-480f-9d5c-4cec48efd14b.png)'
- en: 'This boost-converter module''s outputs are then connected to the peristaltic
    pump:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个升压转换模块的输出然后连接到蠕动泵：
- en: '![](img/9e0cb710-095e-4f43-b2ba-b9c0145085ea.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e0cb710-095e-4f43-b2ba-b9c0145085ea.png)'
- en: Here, we need to get some tubing of the right diameter to connect it to the
    water reservoir and the plant. The pump itself will rotate either direction. As
    it consists of essentially a set of rollers on the section of internal tubing,
    which push the liquid inside one way, either side of the pump can be the input
    or output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要获取一些正确直径的软管，将其连接到水储罐和植物。泵本身可以朝任意方向旋转。由于它本质上是一组位于内部管道段的滚轮，这些滚轮推动液体向一个方向流动，因此泵的任意一侧都可以是输入或输出。
- en: Be sure to test the flow direction beforehand with two containers and some water,
    and mark the direction on the pump casing, along with the positive and negative
    terminal connections used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之前，务必使用两个容器和一些水测试流向，并在泵外壳上标记方向，以及正负终端连接。
- en: 'In addition to these components, we also want to have an RGB LED connected
    for some signaling and just for looks. For this, we will use the **APA102** RGB
    LED module, which connects to the ESP8266 over the SPI bus:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些组件之外，我们还想连接一个RGB LED，用于一些信号指示以及外观。为此，我们将使用**APA102** RGB LED模块，该模块通过SPI总线连接到ESP8266：
- en: '![](img/080f68db-2083-4eff-b67e-536e6aee587c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/080f68db-2083-4eff-b67e-536e6aee587c.png)'
- en: We can use a single power supply that can be provide 5V with 1A or more, as
    well as cope with the sudden power draw from the boost converter every time that
    the pump is activated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个可以提供5V电压和1A或更多电流的单电源，同时还能应对每次泵被激活时从升压转换器中突然抽取的电力。
- en: 'The whole system would look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统看起来会是这样：
- en: '![](img/541c3d8a-ca18-49c7-96cc-1e863fb62a79.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/541c3d8a-ca18-49c7-96cc-1e863fb62a79.png)'
- en: The firmware
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固件
- en: For this project, we will be implementing a module for the same firmware that
    we will be using in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example
    - Building Monitoring and Control*. Therefore, this chapter will only cover the
    parts that are unique to this plant-watering module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将实现一个模块，该模块将用于我们在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)，“示例
    - 构建监控和控制”中将要使用的相同固件。因此，本章将仅涵盖这个植物灌溉模块的独特部分。
- en: Before we can start with the firmware itself, we first have to set up the development
    environment. This involves the installation of the ESP8266 SDK and the Sming framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始固件本身之前，我们首先必须设置开发环境。这包括安装ESP8266 SDK和Sming框架。
- en: Setting up Sming
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Sming
- en: The Sming-based ESP8266 development environment can be used on Linux, Windows,
    and macOS. You want to preferably use the development branch of Sming, however,
    which is where using it on Linux (or in a Linux VM, or Windows 10's **Windows
    Subsystem for Linux** (**WSL**)) is the easiest way, and definitely recommended.
    On Linux installing in the `/opt` folder is recommended for consistency with the
    Sming quick start guide.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Sming的ESP8266开发环境可以在Linux、Windows和macOS上使用。你最好使用Sming的开发分支，因为在Linux（或在Linux虚拟机中，或在Windows
    10的**Windows Subsystem for Linux**（**WSL**）中）使用它是最简单的方式，并且强烈推荐。在Linux中，建议在`/opt`文件夹中安装，以确保与Sming快速入门指南的一致性。
- en: This quick start guide for Linux can be found at [https://github.com/SmingHub/Sming/wiki/Linux-Quickstart](https://github.com/SmingHub/Sming/wiki/Linux-Quickstart).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的快速入门指南可以在[https://github.com/SmingHub/Sming/wiki/Linux-Quickstart](https://github.com/SmingHub/Sming/wiki/Linux-Quickstart)找到。
- en: 'On Linux, we can use the Open SDK for ESP8266, which takes the official Espressif
    (non-RTOS) SDK, and replaces all the non-open components it can with open source
    alternatives. This can be installed using this code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们可以使用ESP8266的Open SDK，它采用官方的Espressif（非RTOS）SDK，并用开源替代品替换了它所能替换的所有非开放组件。可以使用以下代码进行安装：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will get the current source for the Open SDK and compile it, targeting
    version 1.5.4 of the official SDK. While a 2.0 version of the SDK already exists,
    some compatibility issues within the Sming framework can remain. Using the 1.5.4
    version offers pretty much the same experience while using well-tested code. This
    will of course change over time, so be sure to check the official Sming documentation
    for updated instructions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取Open SDK的当前源代码并编译它，目标是官方SDK的1.5.4版本。虽然SDK的2.0版本已经存在，但Sming框架中可能仍然存在一些兼容性问题。使用1.5.4版本提供了几乎相同的体验，同时使用了经过良好测试的代码。当然，随着时间的推移，这将会发生变化，所以请务必查看官方Sming文档以获取更新的说明。
- en: The `STANDALONE` option means that the SDK will be built as a standalone installation
    of the SDK and the toolchain, without further dependencies. This is the desired
    option for use with Sming.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`STANDALONE` 选项意味着 SDK 将作为一个独立的 SDK 和工具链安装，没有其他依赖。这是与 Sming 一起使用的理想选项。'
- en: 'Installing `Sming` is as easy as this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `Sming` 就像这样简单：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will build the Sming framework. If we are adding new libraries to Sming
    in its `Libraries` folder, we have to execute the last step again to have a new
    Sming shared library instance to be built and installed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建 Sming 框架。如果我们正在向 Sming 的 `Libraries` 文件夹中添加新库，我们必须再次执行最后一步，以便构建和安装新的 Sming
    共享库实例。
- en: For this project, copy the folders in the `libs` folder of the software project
    for this chapter to the `Sming/Sming/Libraries` folder prior to compiling Sming,
    or the project code will not compile.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本项目，在编译 Sming 之前，将本章软件项目的 `libs` 文件夹中的文件夹复制到 `Sming/Sming/Libraries` 文件夹中，否则项目代码将无法编译。
- en: We can also compile Sming with SSL support. This requires us to compile it with
    the `ENABLE_SSL=1` parameter to Make. This will enable the axTLS-based encryption
    support throughout the Sming library as it is compiled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编译带有 SSL 支持的 Sming。这需要我们使用 `ENABLE_SSL=1` 参数编译 Make。这将使 axTLS 基于加密支持在编译
    Sming 库时启用。
- en: 'With these steps complete, we just have to install `esptool.py` and `esptool2`.
    While in the `/opt` folder, execute these commands to obtain esptool:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们只需安装 `esptool.py` 和 `esptool2`。在 `/opt` 文件夹中，执行以下命令以获取 esptool：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Esptool.py` is a Python script that allows us to communicate with the SPI
    ROM that is part of each ESP8266 module. It is the way we will flash the MCU''s
    ROM with our code. This tool is automatically used by Sming:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Esptool.py` 是一个 Python 脚本，它允许我们与每个 ESP8266 模块中作为其一部分的 SPI ROM 进行通信。这是我们用我们的代码闪存
    MCU ROM 的方式。此工具由 Sming 自动使用：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `esptool2` utility is an alternative to the set of scripts in the official
    SDK that turn the linker output into a ROM format that we can write to the ESP8266\.
    It is called by Sming when we are compiling our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`esptool2` 工具是官方 SDK 中将链接器输出转换为我们可以写入 ESP8266 的 ROM 格式的脚本集的替代品。当我们在编译我们的应用程序时，Sming
    会调用它。'
- en: 'Finally, assuming that we installed the SDK and Sming under `/opt`, we can
    add the following global variables and addition to the system `PATH` variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们已经将 SDK 和 Sming 安装在 `/opt` 下，我们可以添加以下全局变量和将以下内容添加到系统 `PATH` 变量中：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last line adds the toolchain's binaries to the path, which we will need
    when debugging ESP8266 applications, as will see in [Chapter 7](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml),
    *Testing Resource-Restricted Platforms*. At this point, we can develop with Sming
    and create ROM images that we can write to the MCU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将工具链的二进制文件添加到路径中，当我们调试 ESP8266 应用程序时，我们将需要它，正如我们在第 7 章[测试资源受限平台](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml)中看到的。在此阶段，我们可以使用
    Sming 进行开发并创建可以写入 MCU 的 ROM 映像。
- en: Plant module code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 植物模块代码
- en: In this section, we will look at the basic source code for this project, starting
    with the core module, `OtaCore`, and continuing with the `BaseModule` class, which
    all firmware modules register with. Finally, we look at the `PlantModule` class
    itself, which contains the business logic for the project requirements that we
    discussed in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看本项目的源代码基础，从核心模块 `OtaCore` 开始，接着是 `BaseModule` 类，所有固件模块都会注册该类。最后，我们来看
    `PlantModule` 类本身，它包含了本章讨论的项目需求中的业务逻辑。
- en: Also of note is that for this project we enabled both the rBoot bootmanager
    and the rBoot Big Flash options in the project Makefile. What this does is create
    four 1 MB blocks in the 4 MB of ROM that we have available on our ESP8266 module
    (which is all ESP-12E/F modules), of which two are used for firmware images and
    the remaining two for file storage (using the SPIFFS filesystem).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，对于本项目，我们在项目的 Makefile 中启用了 rBoot bootmanager 和 rBoot Big Flash 选项。这样做会在我们的
    ESP8266 模块（即所有 ESP-12E/F 模块）的 4 MB ROM 中创建四个 1 MB 的块，其中两个用于固件映像，其余两个用于文件存储（使用
    SPIFFS 文件系统）。
- en: The rBoot bootloader is then written to the beginning of the ROM, so that it
    will be loaded first on each boot. Of the firmware slots, only one is active at
    any given time. A handy feature of this setup is that it allows us to easily perform
    **over-the-air** (**OTA**) updates, by writing the new firmware image to the inactive
    firmware slot, changing the active slot, and restarting the MCU. If rBoot fails
    to boot from the new firmware image, it will fall back on the other firmware slot,
    which is our known working firmware that we performed the OTA update from.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 rBoot 引导加载程序写入 ROM 的开始处，以便在每次引导时首先加载。在固件槽位中，任何给定时间只有一个槽位是活动的。此设置的便利功能是它允许我们轻松执行**空中**（**OTA**）更新，通过将新的固件映像写入非活动固件槽位，更改活动槽位，并重新启动
    MCU。如果 rBoot 无法从新的固件映像引导，它将回退到另一个固件槽位，这是我们已知的工作固件，我们从中执行了 OTA 更新。|
- en: Makefile-user.mk
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile-user.mk
- en: 'In the root of the `project` folder, we find this Makefile. It contains a number
    of settings that we may want to set to suit our purposes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `project` 文件夹的根目录中，我们找到了此 Makefile。它包含了一些我们可能想要设置以适应我们目的的设置：
- en: '| **Name** | **Description** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `COM_PORT` | If we always connect the board to the same serial port, we can
    hardcode it here to save ourselves some typing. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `COM_PORT` | 如果我们总是将板连接到相同的串行端口，我们可以在此处将其硬编码以节省一些输入。|'
- en: '| `SPI_MODE` | This sets the SPI mode used while flashing the firmware images
    to the SPI ROM. With `dio` only two data lines (`SD_D0`, `D1`) or four (`SD_D0-3`).
    Not all SPI ROMs have all four data lines connected. The `qio` mode is faster,
    but `dio` should always work. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `SPI_MODE` | 这设置了在将固件映像闪存到 SPI ROM 时使用的 SPI 模式。使用 `dio` 仅有两个数据线（`SD_D0`、`D1`）或四个（`SD_D0-3`）。并非所有
    SPI ROM 都连接了所有四个数据线。`qio` 模式更快，但 `dio` 应始终工作。|'
- en: '| `RBOOT_ENABLED` | When set to 1, this enables rBoot bootloader support. We
    want this enabled. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `RBOOT_ENABLED` | 当设置为 1 时，此选项启用 rBoot 引导加载程序支持。我们希望启用此功能。|'
- en: '| `RBOOT_BIG_FLASH` | With 4 MB of ROM available, we wish to use all of this.
    Enable this as well. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `RBOOT_BIG_FLASH` | 有 4 MB 的 ROM 可用，我们希望使用所有这些。请启用此选项。|'
- en: '| `RBOOT_TWO_ROMS` | This option can be used if we wish to place two firmware
    images in a single 1 MB ROM chip instead. This applies to some ESP8266 modules
    and derivatives. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `RBOOT_TWO_ROMS` | 如果我们希望将两个固件映像放置在单个 1 MB ROM 芯片中，可以使用此选项。这适用于一些 ESP8266
    模块及其衍生产品。|'
- en: '| `SPI_SIZE` | Here, we set the size of the SPI ROM chip, which should be 4M
    for this project. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `SPI_SIZE` | 在这里，我们设置 SPI ROM 芯片的大小，对于此项目应该是 4M。|'
- en: '| `SPIFF_FILES` | The location of the folder containing the files that will
    be put on the SPIFFS ROM image that will be written to the MCU. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `SPIFF_FILES` | 包含将放置在写入 MCU 的 SPIFFS ROM 映像中的文件的文件夹的位置。|'
- en: '| `SPIFFS_SIZE` | The size of the SPIFFS ROM image to create. Here, 64 KB is
    standard, but we could use up to 1 MB if we needed to when using a 4 MB ROM with
    the `RBOOT_BIG_FLASH` option enabled. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `SPIFFS_SIZE` | 要创建的 SPIFFS ROM 映像的大小。在这里，64 KB 是标准，但如果我们需要使用启用了 `RBOOT_BIG_FLASH`
    选项的 4 MB ROM，我们可以使用高达 1 MB。|'
- en: '| `WIFI_SSID` | The SSID of the Wi-Fi network that we wish to connect to. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `WIFI_SSID` | 我们希望连接的 Wi-Fi 网络的 SSID。|'
- en: '| `WIFI_PWD` | The password for the Wi-Fi network. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `WIFI_PWD` | Wi-Fi 网络的密码。|'
- en: '| `MQTT_HOST` | The URL or IP address of the MQTT server (broker) to use. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_HOST` | 要使用的 MQTT 服务器（代理）的 URL 或 IP 地址。|'
- en: '| `ENABLE_SSL` | Enable this with SSL support compiled into Sming to make the
    firmware use TLS-encrypted connections with the MQTT broker. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `ENABLE_SSL` | 启用此选项以在 Sming 中编译 SSL 支持，使固件使用 TLS 加密连接与 MQTT 代理通信。|'
- en: '| `MQTT_PORT` | The port of the MQTT broker. This depends on whether SSL is
    enabled. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_PORT` | MQTT 代理的端口。这取决于是否启用了 SSL。|'
- en: '| `USE_MQTT_PASSWORD` | Set to true if you wish to connect to the MQTT broker
    with a username and password. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `USE_MQTT_PASSWORD` | 如果您希望使用用户名和密码连接到 MQTT 代理，请设置为 true。|'
- en: '| `MQTT_USERNAME` | The MQTT broker username, if required. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_USERNAME` | 如果需要，MQTT 代理的用户名。|'
- en: '| `MQTT_PWD` | The MQTT broker password, if required. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_PWD` | 如果需要，MQTT 代理的密码。|'
- en: '| `MQTT_PREFIX` | A prefix you can optionally add in front of each MQTT topic
    used by the firmware, if necessary. It has to end with a slash if not left empty.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_PREFIX` | 如果需要，您可以在固件使用的每个 MQTT 主题之前可选地添加一个前缀。如果为空，它必须以斜杠结尾。|'
- en: '| `OTA_URL` | The hardcoded URL that will be used by the firmware whenever
    an OTA update is requested. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `OTA_URL` | 当请求 OTA 更新时，固件将使用的硬编码 URL。|'
- en: Of these, the Wi-Fi, MQTT, and OTA settings are essential, as they will allow
    the application to connect to the network and MQTT broker, as well as receive
    firmware updates without having to flash the MCU over its serial interface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些设置中，Wi-Fi、MQTT 和 OTA 设置是必不可少的，因为它们将允许应用程序连接到网络和 MQTT 代理，以及接收固件更新，而无需通过串行接口对
    MCU 进行烧录。
- en: Main
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Main
- en: 'The main source file and with it the application entry point is pretty uneventful:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 主要源文件以及与之相关的应用程序入口点相当无趣：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the `OtaCore` class containing the main application logic, we merely call
    its static initialization function while providing a callback function if we wish
    to execute any further logic after the core class has finished setting up the
    network, MQTT, and other functionality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含主要应用程序逻辑的 `OtaCore` 类中，我们只需调用其静态初始化函数，如果我们希望在核心类完成设置网络、MQTT 和其他功能之后执行任何进一步逻辑，我们可以提供一个回调函数。
- en: OtaCore
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OtaCore
- en: 'In this class, we set up all of the basic network functionality for the specific
    feature modules, in addition to providing utility functions for logging and MQTT
    functionality. This class also contains the main command processor for commands
    received over MQTT:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们为特定功能模块设置了所有基本网络功能，并提供用于日志记录和 MQTT 功能的实用函数。此类还包含通过 MQTT 接收的命令的主要命令处理器：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These two includes are required to make use of the Sming framework. With them,
    we include the main headers of the SDK (`user_config.h`) and those of Sming (`SmingCore.h`).
    This also defines a number of preprocessor statements, such as to use the open
    source **Light-Weight IP stack** (**LWIP**) and to deal with some issues in the
    official SDK.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个包含是使用 Sming 框架所必需的。通过它们，我们包含了 SDK 的主要头文件（`user_config.h`）和 Sming 的头文件（`SmingCore.h`）。这也定义了多个预处理器语句，例如使用开源
    **轻量级 IP 堆栈**（**LWIP**）以及处理官方 SDK 中的某些问题。
- en: 'Also of note is the `esp_cplusplus.h` header, which is indirectly included
    this way. Its source file implements the `new` and `delete` functions, as well
    as a few handlers for class-related functionality, such as `vtables` when using
    virtual classes. This enables compatibility with the STL:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是 `esp_cplusplus.h` 头文件，它以这种方式间接包含。其源文件实现了 `new` 和 `delete` 函数，以及一些与类相关功能的处理程序，例如使用虚拟类时的
    `vtables`。这使它与 STL 兼容：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These two enumerations define the logging levels, and the individual GPIO and
    other pins of the ESP8266 that we may want to use. The values for the ESP8266
    pin enumeration correspond to positions in a bitmask:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个枚举定义了日志级别，以及我们可能想要使用的 ESP8266 的单个 GPIO 和其他引脚。ESP8266 引脚枚举的值对应于位掩码中的位置：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we define the fixed pins for the I2C bus. These correspond to GPIO 4 and
    5, also known as **D1** and **D2** on NodeMCU boards. The main reason for having
    these pins predefined is that they are two of the few *safe* pins on the ESP8266.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 I2C 总线的固定引脚。这些对应于 GPIO 4 和 5，也称为 NodeMCU 板上的 **D1** 和 **D2**。这些引脚预定义的主要原因是因为它们是
    ESP8266 上为数不多的 **安全** 引脚之一。
- en: Many pins of the ESP8266 will change levels during startup before settling,
    which can cause unwanted behavior with any connected peripherals.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ESP8266 的许多引脚在启动过程中会改变电平，然后在稳定之前，这可能会对任何连接的外设造成不希望的行为。
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We define two function pointers, one to be used by feature modules when they
    wish to register an MQTT topic, along with a callback function. The other is the
    callback we saw in the main function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数指针，一个用于功能模块在它们希望注册 MQTT 主题及其回调函数时使用。另一个是我们看到的主函数中的回调函数。
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The class declaration itself gives a good overview of the functionality provided
    by this class. The first thing we notice is that it is completely static. This
    ensures that this class's functionality is immediately initialized when the firmware
    starts, and that it can be accessed globally without having to worry about specific
    instances.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明本身提供了对这个类提供的功能的好概述。我们首先注意到的是，它是完全静态的。这确保了当固件启动时，这个类的功能立即初始化，并且可以全局访问，而无需担心特定实例。
- en: We can also see the first use of the `uint32` type, which along with other integer
    types is defined similar to those in the `cstdint` header.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到 `uint32` 类型的首次使用，它与其他整数类型一样，在 `cstdint` 头文件中定义。
- en: 'Moving on, here is the implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这里是实现方式：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We include the `BaseModule` class's header here, so that we can call its own
    initialization function later on after we have finished setting up the basic functionality.
    The static class members are also initialized here, with a number of default values
    assigned where relevant.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含 `BaseModule` 类的头部，这样我们就可以在我们完成基本功能设置之后调用其自己的初始化函数。静态类成员也在这里初始化，在相关位置分配了多个默认值。
- en: Of note here is the initializing of a second serial interface object in addition
    to the default Serial object instance. These correspond to the first (UART0, Serial)
    and second (UART1, Serial1) UART on the ESP8266.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，除了默认的 Serial 对象实例之外，还初始化了一个第二个串行接口对象。这些对应于 ESP8266 上的第一个（UART0，Serial）和第二个（UART1，Serial1）UART。
- en: With older versions of Sming, the SPIFFS-related file functions had trouble
    with binary data (due to internally assuming null-terminated strings), which is
    why the following alternative functions were added. Their naming is a slightly
    inverted version from the original function name to prevent naming collisions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sming 的较旧版本中，与 SPIFFS 相关的文件函数在处理二进制数据时存在问题（由于内部假设字符串以空字符终止），这就是为什么添加了以下替代函数的原因。它们的命名是原始函数名的轻微倒置版本，以防止命名冲突。
- en: Since TLS certificates and other binary data files stored on SPIFFS have to
    be able to be written and read for the firmware to function correctly, this was
    a necessary compromise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TLS 证书和其他存储在 SPIFFS 上的二进制数据文件必须能够被写入和读取，以便固件能够正确运行，因此这是一个必要的折衷方案。
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function reads the entire contents of the specified file into a `String`
    instance that is returned.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将指定文件的全部内容读取到一个返回的 `String` 实例中。
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function replaces the existing content in a file with the new data in the
    provided `String` instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用提供的 `String` 实例中的新数据替换文件中的现有内容。
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is similar to `getFileContent()`, but returns a simple character
    buffer instead of a `String` instance. It's mostly used for reading in the certificate
    data, which is passed into a C-based TLS library (called axTLS), where converting
    to a `String` instance would be wasteful with the copying involved, especially
    where certificates can be a few KB in size.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与 `getFileContent()` 类似，但返回一个简单的字符缓冲区而不是 `String` 实例。它主要用于读取证书数据，这些数据被传递到一个基于
    C 的 TLS 库（称为 axTLS）中，在那里将转换为 `String` 实例会因涉及复制而造成浪费，尤其是当证书大小可能达到几个 KB 时。
- en: 'Next is the initialization function for this class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是这个类的初始化函数：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first initialize the two UARTs (serial interfaces) in the NodeMCU. Although
    officially there are two UARTs in the ESP8266, the second one consists only out
    of a TX output line (GPIO 2, by default). Because of this, we want to keep the
    first UART free for applications requiring a full serial line, such as some sensors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 NodeMCU 中初始化两个 UART（串行接口）。尽管官方 ESP8266 中有两个 UART，但第二个 UART 只包含一个 TX 输出线（默认为
    GPIO 2）。因此，我们希望保留第一个 UART 以供需要完整串行线的应用程序使用，例如一些传感器。
- en: The first UART (`Serial`) is thus initialized so that we can later use it with
    feature modules, while the second UART (`Serial1`) is initialized to the default
    baud rate of 115,200, along with the system's debug output (WiFi/IP stack, and
    so on) being directed to this serial output as well. This second serial interface
    will thus be used solely for logging output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个 UART（`Serial`）被初始化，以便我们可以在以后使用它与功能模块一起使用，而第二个 UART（`Serial1`）被初始化为默认波特率
    115,200，同时将系统的调试输出（WiFi/IP 堆栈等）也导向这个串行输出。因此，这个第二个串行接口将仅用于日志输出。
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, the `BaseModule` static class is initialized as well. This causes all
    feature modules active in this firmware to be registered, allowing them to be
    activated later on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化了 `BaseModule` 静态类。这会导致在此固件中激活的所有功能模块被注册，允许它们稍后激活。
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Automatically mounting the SPIFFS filesystem while using the rBoot bootloader
    did not work with older releases of Sming, which is why we are doing it manually
    here. To do this, we get the current firmware slot from rBoot, using which we
    can pick the proper offset, either at the start of the second megabyte in the
    ROM, or of the fourth megabyte.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 rBoot 启动加载程序的同时自动挂载 SPIFFS 文件系统在 Sming 的较旧版本中不起作用，这就是为什么我们在这里手动进行此操作的原因。为此，我们获取
    rBoot 的当前固件槽，使用它可以选择适当的偏移量，要么在 ROM 的第二个兆字节的开始处，要么在第四个兆字节处。
- en: With the offset determined, we use the SPIFFS manual-mounting function with
    our offset and the size of the SPIFFS section. We are now able to read and write
    to our storage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 确定偏移量后，我们使用带有我们的偏移量和SPIFFS部分大小的SPIFFS手动挂载功能。我们现在能够读取和写入我们的存储。
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we print out a few system details to the serial debug output. This includes
    the ESP8266 SDK version we compiled against, the current free heap size, CPU frequency,
    the MCU ID (32-bit ID), and the ID of the SPI ROM chip.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将一些系统详细信息打印到串行调试输出中。这包括我们针对编译的ESP8266 SDK版本、当前空闲堆大小、CPU频率、MCU ID（32位ID）以及SPI
    ROM芯片的ID。
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create a new MQTT client on the heap, providing the callback that will be
    called when we receive a new message. The MQTT broker host and port are filled
    in by the preprocessor from the details we added in the user Makefile for the
    project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在堆上创建一个新的MQTT客户端，提供当接收到新消息时将被调用的回调函数。MQTT代理的主机和端口由预处理器根据我们在用户Makefile中为项目添加的详细信息填充。
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As the final steps in the initialization, we output the current firmware slot
    that we are running from, then enable the Wi-Fi client while disabling the **wireless
    access point** (**WAP**) functionality. The WiFi client is told to connect to
    the WiFi SSID with the credentials that we specified previously in the Makefile.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化的最后几个步骤中，我们输出当前正在运行的固件槽，然后启用Wi-Fi客户端，同时禁用**无线接入点**（**WAP**）功能。Wi-Fi客户端被告知连接到我们在Makefile中之前指定的Wi-Fi
    SSID。
- en: Finally, we define the handlers for a successful WiFi connection and for a failed
    connection attempt, before calling the callback function we were provided with
    as a parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在调用作为参数提供的回调函数之前，定义了成功Wi-Fi连接和失败连接尝试的处理程序。
- en: 'After an OTA update of the firmware, the following callback function will be
    called:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在固件OTA更新后，以下回调函数将被调用：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this callback, we change the active ROM slot if the OTA update was successful,
    followed by a reboot of the system. Otherwise, we simply log an error and do not
    restart.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此回调中，如果OTA更新成功，我们更改活动ROM槽，然后重启系统。否则，我们简单地记录错误，并不重启。
- en: 'Next are a few MQTT-related functions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些与MQTT相关的函数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These two functions allow feature modules to respectively register and deregister
    an MQTT topic along with a callback. The MQTT broker is called with a subscription
    or unsubscribe request and the `HashMap` instance is updated accordingly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数允许功能模块分别注册和注销一个MQTT主题及其回调。MQTT代理使用订阅或取消订阅请求进行调用，并相应地更新`HashMap`实例：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Any feature modules can publish an MQTT message on any topic using this function.
    The **Quality of Service** (**QoS**) parameter determines the publish mode. By
    default, messages are published in *retain* mode, meaning that the broker will
    retain the last published message for a particular topic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 任何功能模块都可以使用此函数在任何主题上发布MQTT消息。**服务质量**（**QoS**）参数确定发布模式。默认情况下，消息以*保留*模式发布，这意味着代理将保留特定主题的最后一个发布消息。
- en: 'The entry point for the OTA update functionality is found in the following
    function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: OTA更新功能的入口点位于以下函数中：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For an OTA update, we need to create a clean `rBootHttpUpdate` instance. We
    then need to configure this instance with the details of the current firmware
    slot, for which we obtain the configuration from rBoot and with it the current
    firmware slot number. This we use to give the number of the other firmware slot
    to the OTA updater.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OTA更新，我们需要创建一个干净的`rBootHttpUpdate`实例。然后我们需要使用从rBoot获得的配置以及当前的固件槽号来配置此实例，这个槽号用于将其他固件槽的编号提供给OTA更新器。
- en: Here, we only configure it to update the firmware slot, but we could also update
    the SPIFFS section for the other firmware slot as well this way. The firmware
    will be fetched over HTTP from the fixed URL we set before. The ESP8266's MAC
    address is affixed to the end of it as a unique query string parameter so that
    the update server knows which firmware image fits this system.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只配置它更新固件槽，但也可以通过这种方式更新其他固件槽的SPIFFS部分。固件将通过我们之前设置的固定URL通过HTTP获取。ESP8266的MAC地址附加到末尾作为唯一的查询字符串参数，以便更新服务器知道哪个固件映像适合此系统。
- en: 'After setting the `callback` function that we looked at earlier, we start the
    update:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们之前查看的`callback`函数之后，我们开始更新：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we define the MQTT disconnection handler. It is called whenever the connection
    with the MQTT broker fails so that we can try reconnecting after a two-second
    delay.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义 MQTT 断开连接处理程序。每当与 MQTT 代理的连接失败时，它都会被调用，这样我们就可以在两秒延迟后尝试重新连接。
- en: The flag parameter is set to true if we previously were connected, and false
    if the initial MQTT broker connection failed (no network access, wrong address,
    and so on).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们之前已经连接，则将标志参数设置为 true，如果初始 MQTT 代理连接失败（无网络访问、地址错误等），则设置为 false。
- en: 'Next is the function to configure and start the MQTT client:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是配置和启动 MQTT 客户端的函数：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We stop the procTimer timer if it's running in case we were being called from
    a reconnect timer. Next, we set the **last will and testament** (**LWT**) for
    this device, which allows us to set a message that the MQTT broker will publish
    when it loses the connection with the client (us).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是从重连计时器中被调用，我们将停止 procTimer 计时器。接下来，我们为该设备设置**遗嘱和遗言**（**LWT**），这样我们就可以设置一个消息，当
    MQTT 代理与客户端（我们）断开连接时，MQTT 代理将发布该消息。
- en: 'Next, we define three different execution paths, only one of which will be
    compiled, depending on whether we are using TLS (SSL), a username/password login,
    or anonymous access:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了三条不同的执行路径，其中只有一条会被编译，具体取决于我们是否使用 TLS（SSL）、用户名/密码登录或匿名访问：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we are using TLS certificates, we establish a connection with the MQTT broker,
    using our `MAC` as client identifier, then enable the SSL option for the connection.
    The available heap space is printed to the serial logging output for debugging
    purposes. Usually, at this point, we should have around 25 KB of RAM left, which
    is sufficient for holding the certificate and key in memory, along with the RX
    and TX buffers for the TLS handshake if the latter are configured on the SSL endpoint
    to be an acceptable size using the SSL fragment size option. We will look at this
    in more detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example
    - Building Management and Control*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 TLS 证书，我们使用我们的 `MAC` 作为客户端标识符与 MQTT 代理建立连接，然后启用连接的 SSL 选项。为了调试目的，将可用的堆空间打印到串行日志输出。通常，在这个时候，我们应该剩下大约
    25 KB 的 RAM，这对于在内存中存储证书和密钥以及 TLS 握手的 RX 和 TX 缓冲区（如果 SSL 端点配置为使用 SSL 片段大小选项的可接受大小）是足够的。我们将在第
    9 章[示例 - 建筑管理和控制](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中更详细地探讨这一点。
- en: Next, we read the DER-encoded (binary) certificate and key files from SPIFFS.
    These files have a fixed name. For each file, we print out the file size, along
    with the current free heap size. If either file size is zero bytes, we consider
    the read attempt to have failed and we abort the connection attempt.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从 SPIFFS 读取 DER 编码（二进制）的证书和密钥文件。这些文件具有固定的名称。对于每个文件，我们打印出文件大小，以及当前的空闲堆大小。如果任一文件大小为零字节，我们认为读取尝试失败，并终止连接尝试。
- en: Otherwise, we use the key and certificate data with the MQTT connection, which
    should lead to a successful handshake and establishing an encrypted connection
    with the MQTT broker.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们使用密钥和证书数据与 MQTT 连接，这应该会导致成功的握手并建立与 MQTT 代理的加密连接。
- en: 'After deleting the key and certificate file data, we print out the free heap
    size to allow us to check that the cleanup was successful:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除密钥和证书文件数据后，我们打印出空闲堆大小，以便我们可以检查清理是否成功：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When using an MQTT username and password to log in to the broker, we just need
    to call the previous function on the MQTT client instance, providing our MAC as
    client identifier along with the username and password:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 MQTT 用户名和密码登录到代理时，我们只需在 MQTT 客户端实例上调用前面的函数，提供我们的 MAC 作为客户端标识符，以及用户名和密码：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To connect anonymously, we set up a connection with the broker and pass our
    `MAC` as the client identifier:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要匿名连接，我们设置与代理的连接，并将我们的 `MAC` 作为客户端标识符传递：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we first set the MQTT disconnect handler. Then, we subscribe to a number
    of topics that we wish to respond to. These all relate to management functionality
    for this firmware, allowing the system to be queried and configured over MQTT.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先设置 MQTT 断开连接处理程序。然后，我们订阅我们希望响应的一些主题。这些都与该固件的管理系统功能相关，允许通过 MQTT 查询和配置系统。
- en: After subscribing, we briefly (100 ms) wait to give the broker some time to
    process these subscriptions before we publish on the central notification topic,
    using our `MAC` to let any interested clients and servers know that this system
    just came online.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在订阅后，我们短暂地（100 毫秒）等待，给代理一些时间处理这些订阅，然后在我们发布到中心通知主题之前，使用我们的 `MAC` 让任何感兴趣的客户端和服务器知道该系统刚刚上线。
- en: 'Next are the WiFi connection handlers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是WiFi连接处理程序：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This handler is called when we have successfully connected to the configured
    WiFi network using the provided credentials. After connecting, we keep a copy
    of our `MAC` in memory as our unique ID.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用提供的凭据成功连接到配置的WiFi网络时，将调用此处理程序。连接后，我们在内存中保留我们的`MAC`副本作为我们的唯一ID。
- en: This firmware also supports specifying a user-defined string as our location
    or similar identifier. If one has been defined before, we load it from SPIFFS
    and use it; otherwise, our location string is simply the `MAC`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此固件还支持指定一个用户定义的字符串作为我们的位置或类似标识符。如果之前已经定义了一个，我们就从SPIFFS加载它并使用它；否则，我们的位置字符串简单地是`MAC`。
- en: 'Similarly, we load the 32-bit bitmask that defines the feature module configuration
    from SPIFFS if it exists. If not, all feature modules are initially left deactivated.
    Otherwise, we read the bitmask and pass it to the `updateModules()` function so
    that the relevant modules will be activated:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果存在，我们从SPIFFS加载定义功能模块配置的32位位掩码。如果没有，所有功能模块最初都保持未激活状态。否则，我们读取位掩码并将其传递给`updateModules()`函数，以便相关的模块被激活：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If connecting to the Wi-Fi network fails, we log this fact, then tell the MCU's
    watchdog timer that we are still alive to prevent a soft restart before we attempt
    to connect again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接到Wi-Fi网络失败，我们将记录这一事实，然后告诉MCU的看门狗定时器我们仍然存活，以防止在我们再次尝试连接之前发生软重启。
- en: 'This finishes all of the initialization functions. Next up are the functions
    used during normal activity, starting with the MQTT message handler:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了所有初始化函数。接下来是正常活动期间使用的函数，首先是MQTT消息处理程序：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We registered this callback when we initially created the MQTT client instance.
    Every time a topic that we subscribed to receives a new message on the broker,
    we are notified and this callback receives a string containing the topic and another
    string containing the actual message (payload).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最初创建MQTT客户端实例时注册了这个回调。每次我们订阅的主题在代理上收到新消息时，我们都会收到通知，并且这个回调将接收到一个包含主题的字符串和另一个包含实际消息（有效载荷）的字符串。
- en: We can compare the topic with the topics we registered for, and perform the
    required operation, whether it is to perform an OTA update (if it specifies our
    `MAC`), respond to a ping request by returning a pong response with our `MAC`,
    or to restart the system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该主题与已注册的主题进行比较，并执行所需的操作，无论是执行OTA更新（如果指定了我们的`MAC`），通过返回包含我们的`MAC`的pong响应来响应ping请求，还是重启系统。
- en: 'The next topic is a more generic maintenance one, allowing one to configure
    active feature modules, set the location string, and request the current status
    of the system. The payload format consists out of the command string followed
    by a semicolon, and then the payload string:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题是一个更通用的维护主题，允许配置活动功能模块，设置位置字符串，并请求系统的当前状态。有效载荷格式由命令字符串后跟一个分号组成，然后是有效载荷字符串：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We start by extracting the command from the payload string using a simple find
    and substring approach. We then read in the remaining payload string, taking care
    to read it in as a binary string. For this, we use the remaining string's length
    and as starting position, the character right after the semicolon.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用简单的查找和子字符串方法从有效载荷字符串中提取命令。然后我们读取剩余的有效载荷字符串，注意将其作为二进制字符串读取。为此，我们使用剩余字符串的长度作为起始位置，分号后的字符作为起始位置。
- en: 'At this point, we have extracted the command and payload and can see what we
    have to do:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提取了命令和有效载荷，可以看到我们必须做什么：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This command sets which feature modules should be active. Its payload should
    be an unsigned 32-bit integer forming a bitmask, which we check to make sure that
    we have received exactly four bytes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令设置哪些功能模块应该处于活动状态。其有效载荷应该是一个无符号32位整数，形成一个位掩码，我们检查以确保我们收到了正好四个字节。
- en: 'In the bitmask, the bits each match up with a module, which at this point are
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在位掩码中，每个位都与一个模块相对应，此时这些模块如下：
- en: '| **Bit position** | **Value** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **位位置** | **值** |'
- en: '| 0x01 | THPModule |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | THPModule |'
- en: '| 0x02 | CO2Module |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | CO2Module |'
- en: '| 0x04 | JuraModule |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | JuraModule |'
- en: '| 0x08 | JuraTermModule |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 0x08 | JuraTermModule |'
- en: '| 0x10 | MotionModule |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 0x10 | MotionModule |'
- en: '| 0x20 | PwmModule |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 0x20 | PwmModule |'
- en: '| 0x40 | IOModule |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 0x40 | IOModule |'
- en: '| 0x80 | SwitchModule |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 0x80 | SwitchModule |'
- en: '| 0x100 | PlantModule |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 0x100 | PlantModule |'
- en: Of these, the CO2, Jura, and JuraTerm modules are mutually exclusive, since
    they all use the first UART (`Serial`). If two or more of these are still specified
    in the bitmask, only the first module will be enabled and the others ignored.
    We will look at these other feature modules in more detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Management and Control*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，CO2、Jura和JuraTerm模块是互斥的，因为它们都使用第一个UART（`Serial`）。如果在位掩码中仍然指定了两个或更多这些模块，则只有第一个模块将被启用，其他模块将被忽略。我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中更详细地查看这些其他功能模块，*示例
    - 建筑管理与控制*。
- en: 'After we obtain the new configuration bitmask, we send it to the `updateModules()`
    function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得新的配置位掩码后，我们将其发送到`updateModules()`函数：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this command, we set the new location string, if it is different then
    the current one, also saving it to the location file in SPIFFS to persist it across
    a reboot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们设置新的位置字符串，如果它与当前的不同，也会将其保存到SPIFFS中的位置文件中，以便在重启后持久化：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last three commands in this section return the current bitmask for the
    active feature modules, the firmware version, and trigger an OTA upgrade:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后三个命令返回活动功能模块的当前位掩码、固件版本，并触发OTA升级：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last entry in the `if...else` block looks at whether the topic is perhaps
    found in our list of callbacks for the feature modules. If found, the callback
    is called with the MQTT message string.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else`块中的最后一个条目检查主题是否在我们的功能模块回调列表中。如果找到，则使用MQTT消息字符串调用回调。'
- en: 'Naturally, this means that only one feature module can register itself to a
    specific topic. Since each module tends to operate under its own MQTT sub-topic
    to segregate the message flow, this is generally not a problem:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这意味着只有一个功能模块可以注册到特定的主题。由于每个模块通常在自己的MQTT子主题下运行以隔离消息流，这通常不是问题：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function is pretty simple. It mostly serves as a pass-through for the `BaseModule`
    class, but it also ensures that we keep the configuration file in SPIFFS up to
    date, writing the new bitmask to it when it has changed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数相当简单。它主要作为`BaseModule`类的中继，但它还确保我们保持SPIFFS中的配置文件是最新的，当它发生变化时，将其写入新位掩码。
- en: 'We absolutely must prevent unnecessary writes to SPIFFs, as the underlying
    Flash storage has finite write cycles. Limiting write cycles can significantly
    extend the lifespan of the hardware, as well as reduce overall system load:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对必须防止对SPIFFs进行不必要的写入，因为底层Flash存储器具有有限的写入周期。限制写入周期可以显著延长硬件的使用寿命，同时减少整体系统负载：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function maps the given GPIO pin number to its position in the internal
    bitmask. It uses the enumeration we looked at for the header file for this class.
    With this mapping, we can set the used/unused state of GPIO pins of the ESP8266
    module using just a single uint32 value:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将给定的GPIO引脚号映射到内部位掩码中的位置。它使用我们查看的该类头文件的枚举。通过这种映射，我们可以使用单个uint32值设置ESP8266模块的GPIO引脚的已用/未用状态：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the logging method, we append the log level to the message string before
    writing it to the serial output, as well as publishing it on MQTT. Here, we publish
    on a single topic, but as a refinement you could log on a different topic depending
    on the specified level.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录方法中，我们在将消息写入串行输出之前，将日志级别追加到消息字符串中，以及将其发布在MQTT上。在这里，我们发布在一个单一的主题上，但作为一个改进，你可以根据指定的级别在不同的主题上记录日志。
- en: 'What makes sense here depends a great deal on what kind of backend you have
    set up to listen for and process logging output from the ESP8266 systems running
    this firmware:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有什么意义在很大程度上取决于你为监听和处理运行此固件的ESP8266系统日志输出而设置的后端类型：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function starts the I2C bus if it hasn't been started already. It tries
    to register the pins it wishes to use for the I2C bus. If these are available,
    it will set the clock line (SCL) to output mode and first pulse it eight times
    to unfreeze any I2C devices on the bus.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数如果尚未启动，则启动I2C总线。它尝试注册它希望用于I2C总线的引脚。如果这些引脚可用，它将时钟线（SCL）设置为输出模式，并首先脉冲它八次以解冻总线上的任何I2C设备。
- en: After pulsing the clock line like his, we start the I2C bus on the pins and
    make a note of the active state of this bus.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在像他那样脉冲时钟线之后，我们在引脚上启动I2C总线，并记录下该总线的激活状态。
- en: 'Frozen I2C devices can occur if the MCU power cycles when the I2C devices do
    not, and remain in an indeterminate state. With this pulsing, we make sure that
    the system won''t end up in a non-functional state, requiring manual intervention:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MCU在I2C设备没有时循环电源，并且保持不确定状态，则可能会出现冻结的I2C设备。通过这种脉冲，我们确保系统不会最终处于非功能状态，需要手动干预：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Starting the SPI bus is similar to staring the I2C bus, except without a similar
    recovery mechanism:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 启动SPI总线与启动I2C总线类似，只是没有类似的恢复机制：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This overloaded function is used to register a GPIO pin by a feature module
    before it starts, to ensure that no two modules attempt to use the same pins at
    the same time. One version accepts a pin number (GPIO) and uses the mapping function
    we looked at earlier to get the bit address in the `esp8266_pins` bitmask before
    passing it on to the other version of the function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重载函数用于在功能模块启动之前通过功能模块注册GPIO引脚，以确保没有两个模块尝试同时使用相同的引脚。一个版本接受一个引脚号（GPIO），并使用我们之前查看的映射函数在`esp8266_pins`位掩码中获取位地址，然后再将其传递给函数的另一个版本。
- en: 'In that function, the pin enumeration is used to do a bitwise `AND` comparison.
    If the bit has not been set yet, it is toggled and true is returned. Otherwise,
    the function returns false and the calling module knows that it cannot proceed
    with its initialization:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数中，使用引脚枚举进行位运算的`AND`比较。如果位尚未设置，则将其切换并返回true。否则，函数返回false，调用模块知道它不能继续其初始化：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This overloaded function, to release a pin when a feature module is shutting
    down, works in a similar manner. One uses the mapping function to get the bit
    address, the other performs a bitwise `AND` operation to check that the pin has
    in fact been set, and toggles it to an off position with the bitwise `OR` assignment
    operator if it was set.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重载函数，在功能模块关闭时释放引脚，以类似的方式工作。一个使用映射函数获取位地址，另一个执行位运算的`AND`操作以检查引脚是否确实已设置，如果已设置，则使用位运算的`OR`赋值运算符将其切换到关闭位置。
- en: BaseModule
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseModule
- en: 'This class contains the logic for registering and keeping track of which feature
    modules are currently active or inactive. Its header file looks as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含注册和跟踪当前哪些功能模块是活动或非活动的逻辑。其头文件如下所示：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The inclusion of the `OtaCore` header is to allow us to use the logging feature.
    Beyond this, we create another enumeration, which maps a specific feature module
    to a particular bit in the feature module bitmask (`active_mods`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`OtaCore`头文件是为了让我们能够使用日志功能。除此之外，我们创建另一个枚举，它将特定的功能模块映射到功能模块位掩码（`active_mods`）中的特定位。
- en: 'Finally, function pointers are defined, which are used for respectively starting
    and shutting down a feature module. These will be defined by the feature modules
    as they register themselves:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了函数指针，它们分别用于启动和关闭功能模块。这些将由功能模块在它们注册时定义：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the feature modules that currently exist for this firmware as of writing.
    Since we only need the plant module for this project, we could comment out all
    header files for the other modules, along with their initialization in the initialization
    function of this class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是目前为这个固件存在的功能模块。由于我们只需要这个项目中的植物模块，我们可以注释掉其他模块的所有头文件，以及这个类初始化函数中的它们的初始化。
- en: This would not affect the resulting firmware image in any way other than that
    we cannot enable those modules since they do not exist.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不会以任何方式影响最终生成的固件镜像，除了我们无法启用那些模块，因为它们不存在。
- en: 'Finally, here is the class declaration itself:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是类声明本身：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Each feature module is represented internally by a `SubModule` instance, the
    details of which we can see in a moment in the class definition:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能模块在内部都由一个`SubModule`实例表示，其细节我们可以在类定义中稍后看到：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since this is a static class, we first initialize its class variables. We have
    an array with space for 32 `SubModule` instances, to fit the full bitmask. Beyond
    this, no modules are active, so everything is initialized to zero and false:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个静态类，我们首先初始化其类变量。我们有一个可以容纳32个`SubModule`实例的数组，以适应完整的位掩码。在此之外，没有模块是活动的，所以一切都被初始化为零和false：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When we called this function in `OtaCore`, we also triggered the registration
    of the feature modules defined here. By selectively removing or commenting out
    modules in this function, we can remove them from the final firmware image. Those
    modules that are called here will call the following function to register themselves:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`OtaCore`中调用此函数时，我们还触发了在此定义的功能模块的注册。通过在此函数中选择性删除或注释模块，我们可以从最终的固件映像中移除它们。这里调用的模块将调用以下函数来注册自己：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first feature module that calls this function will trigger the initialization
    of the `SubModule` array, setting all of its values to a neutral setting, while
    also creating the bitmask for this position in the array, which allows us to update
    the `active_mods` bitmask, as we will see in a moment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数的第一个功能模块将触发`SubModule`数组的初始化，将所有值设置为中性设置，同时为数组中的此位置创建位掩码，这允许我们更新`active_mods`位掩码，正如我们稍后将看到的。
- en: 'After initializing the array, we check whether this position in the array already
    has a module registered for it. If it has, we return false. Otherwise, we register
    the module''s function pointers for starting and shutting down, and increase the
    active module count before returning true:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化数组后，我们检查数组中此位置是否已注册了模块。如果有，我们返回false。否则，我们注册模块的启动和关闭函数指针，并在返回true之前增加活动模块计数：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The input parameter to this function is the bitmask we extracted from the MQTT
    payload in `OtaCore`. Here, we use a bitwise XOR comparison with the active modules
    bitmask to obtain a new bitmask indicating any changes to be made. If the result
    is zero, we know that they're identical and we can return without further action
    being required.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的输入参数是从`OtaCore`中的MQTT有效负载中提取的位掩码。在这里，我们使用位异或比较与活动模块位掩码，以获得表示要进行的更改的新位掩码。如果结果是零，我们知道它们是相同的，我们可以返回而不需要进一步的操作。
- en: The `uint32` bitmask we have thus obtained indicates which modules should be
    toggled on or off. For this, we check each bit of the mask. If it is a `1` (AND
    operator returns a value that's not zero), we check whether the module at that
    position in the array exists and has been started yet.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们因此获得的`uint32`位掩码指示了哪些模块应该开启或关闭。为此，我们检查掩码中的每个位。如果它是`1`（AND运算符返回非零值），我们检查数组中该位置的模块是否存在并且已经启动。
- en: If the module has been started, we attempt to shut it down. If the module's
    shutdown() function succeeds (returns true), we toggle the bit in the `active_mods`
    bitmask to update its status. Similarly, if the module has not been started yet,
    a module has been registered at that location, we attempt to start it, updating
    the active modules if this succeeds.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块已经启动，我们尝试将其关闭。如果模块的`shutdown()`函数成功（返回true），我们在`active_mods`位掩码中切换位以更新其状态。同样，如果模块尚未启动，该位置已注册了模块，我们尝试启动它，如果成功则更新活动模块。
- en: We check that a start function callback has been registered to ensure that we
    do not accidentally call an improperly registered module and crash the system.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查是否已注册启动函数回调，以确保我们不会意外调用未正确注册的模块并导致系统崩溃。
- en: PlantModule
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PlantModule
- en: At this point, we have had a detailed look at the underlying, supporting code
    that makes life easy when writing a new module because we don't have to do all
    of the housekeeping ourselves. The only thing we haven't seen yet is an actual
    module, or code directly pertaining to this chapter's project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细查看了解决方案背后的支持代码，这使得编写新模块变得容易，因为我们不需要自己完成所有维护工作。我们还没有看到的是实际的模块或与本章项目直接相关的代码。
- en: 'In this section, we will look at the last part of the puzzle, the `PlantModule`
    itself:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看拼图的最后部分，即`PlantModule`本身：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Of note in this class declaration is the inclusion of the APA102 library header.
    This is a simple library that allows us to write color and brightness data to
    APA102 RGB (full-spectrum) LEDs, over the SPI bus.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类声明中值得注意的是APA102库头文件的包含。这是一个简单的库，允许我们将颜色和亮度数据写入APA102 RGB（全光谱）LED，通过SPI总线。
- en: We also define the pin that we wish to use to trigger the peristaltic pump (GPIO
    5) and the number of connected APA102 LED modules (1). You can add multiple APA102
    LEDs in series if you want, simply updating the definition to match the count.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了我们希望用于触发蠕动泵（GPIO 5）的引脚以及连接的APA102 LED模块的数量（1）。如果您想串联多个APA102 LED，只需更新定义以匹配数量即可。
- en: 'Next is the class implementation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是类实现：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this section, we initialize the static class members, setting the GPIO pin
    and defining the initial sensor value at which the pump should be triggered. This
    trigger value should be updated to match your own sensor calibration results.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们初始化静态类成员，设置 GPIO 引脚，并定义泵应触发的初始传感器值。此触发值应更新以匹配您自己的传感器校准结果。
- en: 'Finally, we define an enumeration containing the possible commands for this
    module that can be sent to it over MQTT:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个枚举，包含此模块可以通过 MQTT 发送的可能的命令：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is the initialization function the `BaseModule` calls on startup. As we
    can see, it causes this module to register itself with preset values, including
    its start and shutdown callbacks:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `BaseModule` 在启动时调用的初始化函数。正如我们所见，它使此模块以预设值注册自己，包括其启动和关闭回调：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When this module starts, we attempt to claim the pin we wish to use for triggering
    the pump, as well as register a callback for an MQTT topic so that we can accept
    commands using the command handler callback. The topic on which we will responses
    after processing a command is also defined here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当此模块启动时，我们尝试声明用于触发泵的引脚，以及注册一个 MQTT 主题的回调，以便我们可以使用命令处理程序回调接受命令。我们将在处理命令后响应的主题也在此定义。
- en: The output pin mode is set, followed by the starting of the HTTP server on port
    80, registering a basic handler for client requests. Next, we create a new `APA102`
    class instance and use it to get the connected LED to display green at about half
    of full brightness.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 设置输出引脚模式，然后启动端口 80 上的 HTTP 服务器，注册一个基本的客户端请求处理程序。接下来，我们创建一个新的 `APA102` 类实例，并使用它来获取连接的
    LED，以大约一半的全亮度显示绿色。
- en: 'Finally, we start a timer that will trigger the reading out of the connected
    soil sensor every minute:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动一个定时器，该定时器将每分钟触发读取连接的土壤传感器：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When shutting down this module, we release the pin we registered previously,
    stop the web server, delete the RGB LED class instance (with a check to see that
    deleting it is necessary), deregister our MQTT topic, and finally stop the sensor
    timer.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当关闭此模块时，我们释放之前注册的引脚，停止网络服务器，删除 RGB LED 类实例（并检查删除是否必要），注销我们的 MQTT 主题，并最终停止传感器定时器。
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This callback is called whenever a message is published on the MQTT topic we
    registered. In our messages, we expect to find a single byte (uint8) value that
    defines the command, up to eight distinct commands. For this module, we earlier
    defined three commands.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调会在我们注册的 MQTT 主题上发布消息时被调用。在我们的消息中，我们期望找到一个单字节（uint8）值，该值定义了命令，最多八个不同的命令。对于此模块，我们之前定义了三个命令。
- en: 'These commands are defined as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令如下定义：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **含义** | **负载** | **返回值** |'
- en: '| 0x01 | Get soil moisture | - | 0xXXXX |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 获取土壤湿度 | - | 0xXXXX |'
- en: '| 0x02 | Set trigger level | uint16 (new trigger level) | - |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | 设置触发级别 | uint16（新触发级别） | - |'
- en: '| 0x04 | Get trigger level | - | 0xXXXX |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | 获取触发级别 | - | 0xXXXX |'
- en: Here, every command returns the requested value, if applicable.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个命令都会返回请求的值（如果适用）。
- en: After checking that the message string we got has at least one byte in it, we
    extract the first byte and try to interpret it as a command. If we are setting
    a new trigger point, we also extract the new value as a uint16 from the message
    after making sure that we have a properly formed message.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认我们收到的消息字符串中至少有一个字节后，我们提取第一个字节，并尝试将其解释为命令。如果我们正在设置新的触发点，我们也会从消息中提取新的值作为 uint16，前提是我们有一个格式正确的消息。
- en: 'Finally, here is the function in which all of the magic happens that we have
    been working toward in this project:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是我们一直在本项目中努力实现的所有魔法发生的函数：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As the first step, we read out the current sensor value from the analog input
    of the ESP8266 and publish it on the MQTT topic for this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们从 ESP8266 的模拟输入读取当前传感器值，并将其发布到以下 MQTT 主题：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: During calibration of one prototype with a soil moisture sensor, it was found
    that the value for a completely dry sensor (held in the air) was approximately
    766, whereas having the same sensor submerged in water got 379 as a value. From
    this, we can deduce that 60% moisture content should be roughly around a reading
    of 533, which matches the initial value we set during the static initialization
    step. The ideal trigger point and target soil moisture level of course depends
    on the soil type and specific plant.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用土壤湿度传感器校准一个原型时，发现一个完全干燥的传感器（悬在空中）的值大约为 766，而将相同的传感器浸入水中得到的值为 379。由此我们可以推断，60%
    的湿度含量大约在 533 的读数左右，这与我们在静态初始化步骤中设置的初始值相匹配。当然，理想的触发点和目标土壤湿度水平取决于土壤类型和特定植物。
- en: With this trigger level reached, we set the output pin that is connected to
    the enable pin of the boost converter to high, causing it to turn on its output,
    which in turn starts the pump. We wish to let it pump for about ten seconds.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到这个触发水平时，我们将连接到升压转换器使能引脚的输出引脚设置为高，使其开启输出，这反过来又启动了泵。我们希望让它泵大约十秒钟。
- en: During this time we set the LED color to blue, then during each second we drop
    its brightness from 100% to nearly off and then back to full brightness again,
    creating a pulsating effect.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段时间内，我们将 LED 颜色设置为蓝色，然后在每一秒内将其亮度从 100% 降低到几乎关闭，然后再回到全亮度，从而产生脉冲效果。
- en: 'After this, we set the output pin back to low, which disables the pump, and
    we await the next soil moisture sensor reading:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将输出引脚设置回低，这会禁用泵，并等待下一次土壤湿度传感器的读数：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, we see here the request handler for our web server. What it does is
    read in a template file from SPIFFS (detailed in the next section), gets the list
    of variables in this template file, and then proceeds to read out the current
    sensor value.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在这里看到我们网络服务器的请求处理器。它所做的是从 SPIFFS 中读取一个模板文件（下一节将详细介绍），获取该模板文件中的变量列表，然后继续读取当前的传感器值。
- en: Using this value, it calculates the current soil moisture percentage and uses
    both the raw and calculated numbers to fill in the two variables in the template
    before returning it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个值，它计算当前的土壤湿度百分比，并使用原始和计算出的数字在返回之前填充模板中的两个变量。
- en: Index.html
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Index.html
- en: 'For use with the PlantModule''s web server, we have to add the following template
    file to SPIFFS:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 PlantModule 的网络服务器一起使用，我们必须将以下模板文件添加到 SPIFFS 中：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Compiling and flashing
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和烧录
- en: 'After finishing the code for our application, we can compile it with a single
    command in the project''s root folder:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成我们应用程序的代码后，我们可以在项目的根目录下使用单个命令编译它：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After this completes, we can find the binaries including the ROM images in the
    `out` folder. Since we are using both the rBoot bootloader and SPIFFs, we get
    three ROM images in total in the `firmware` folder.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以在 `out` 文件夹中找到包括 ROM 镜像在内的二进制文件。由于我们同时使用 rBoot 引导加载程序和 SPIFFs，`firmware`
    文件夹中总共有三个 ROM 镜像。
- en: At this point, we can connect an ESP8266 module, either in the form of a NodeMCU
    board or one of the many alternatives, and note the serial port that it will be
    connected to. On Windows, this will be something like `COM3`; on Linux, USB-to-serial
    adapters usually are registered as `/dev/ttyUSB0` or similar.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以连接一个 ESP8266 模块，无论是 NodeMCU 板的形式还是许多替代品之一，并注意它将连接到的串行端口。在 Windows
    上，这可能是 `COM3`；在 Linux 上，USB 到串行适配器通常注册为 `/dev/ttyUSB0` 或类似。
- en: 'Unless we have specified the serial port (`COM_PORT`) in the user Makefile,
    we have to specify it explicitly when we flash to the ESP8266 module:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在用户 Makefile 中指定串行端口 (`COM_PORT`)，那么在向 ESP8266 模块烧录时，我们必须明确指定它：
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After executing this command, we should see the output from the `esptool.py`
    utility, as it connects to the ESP8266's ROM and starts writing the ROM images
    to it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该看到 `esptool.py` 工具的输出，因为它连接到 ESP8266 的 ROM 并开始将其写入 ROM 镜像。
- en: Once this is complete, the MCU will restart and it should boot straight into
    the new firmware image, where it will await our commands to configure it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，MCU 将重新启动，并且应该直接进入新的固件镜像，在那里它将等待我们的命令来配置它。
- en: First-time configuration
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次配置
- en: As noted earlier in this chapter, this firmware is designed to be configured
    and maintained over MQTT. This requires that an MQTT broker is available. An MQTT
    broker such as Mosquitto ([http://mosquitto.org/](http://mosquitto.org/)) is popular.
    Since it's a lightweight server, it can be installed on a desktop system, a small
    SBC, inside a virtual machine, and so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，此固件设计为可以通过 MQTT 进行配置和维护。这需要有一个 MQTT 代理可用。Mosquitto（[http://mosquitto.org/](http://mosquitto.org/））是一个流行的
    MQTT 代理。由于它是一个轻量级服务器，它可以安装在桌面系统、小型 SBC、虚拟机等上。
- en: In addition the broker and the ESP8266 running the firmware, we also need our
    own client
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理和运行固件的 ESP8266，我们还需要我们自己的客户端
- en: to interact with the firmware. Since we use binary protocols, our choice there
    is somewhat
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与固件交互。由于我们使用二进制协议，我们的选择相对有限，因为大多数常见的 MQTT 桌面客户端都假设基于文本的消息。一个
- en: limited, as most common MQTT desktop clients assume text-based messages. One
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有限，因为大多数常见的 MQTT 桌面客户端都假设基于文本的消息。一个
- en: approach one can use to publish binary messages is to use the MQTT publish client
    that
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来发布二进制消息的方法是使用 MQTT 发布客户端。
- en: comes with Mosquitto and use the **echo** command-line tool's hexadecimal input
    to send
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Mosquitto 一起提供的 **echo** 命令行工具的十六进制输入，我们可以发送
- en: binary data to it as a stream to be published by the client tool
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数据作为流发送到客户端工具
- en: 'Because of this, the author of this book has developed a new MQTT desktop client
    (based on C++ and Qt) that is designed around the use and debugging of binary
    protocols on MQTT: [https://github.com/MayaPosch/MQTTCute](https://github.com/MayaPosch/MQTTCute).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本书的作者开发了一个新的 MQTT 桌面客户端（基于 C++ 和 Qt），该客户端旨在围绕 MQTT 上的二进制协议的使用和调试进行设计：[https://github.com/MayaPosch/MQTTCute](https://github.com/MayaPosch/MQTTCute)。
- en: With all three components in place—ESP8266 running the project, the MQTT broker
    and desktop client—we can have the entire plant monitoring and watering system
    assembled and send it the command to enable the plant module.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当三个组件都到位——ESP8266 运行项目、MQTT 代理和桌面客户端——我们可以组装整个植物监控和灌溉系统，并发送命令以启用植物模块。
- en: While monitoring the cc/config topic for messages, we should see the ESP8266
    report its presence by publishing its `MAC`. We can also get this by hooking up
    a USB to TTL serial adapter to the serial logging output pin (`D4` on NodeMCU).
    By looking at the output on our serial console, we will see both the IP address
    and the `MAC` of the system.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 cc/config 主题上监控消息时，我们应该看到 ESP8266 通过发布其 `MAC` 来报告其存在。我们也可以通过将 USB 到 TTL
    串行适配器连接到串行日志输出引脚（NodeMCU 上的 `D4`）来获取这个信息。通过查看我们的串行控制台输出，我们将看到系统的 IP 地址和 `MAC`。
- en: 'When we compose a new topic of the format `cc/<MAC>`, we can then publish commands
    to the firmware, for example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个格式为 `cc/<MAC>` 的新主题时，我们可以然后向固件发布命令，例如：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This would set the location name of the system to `plant001`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置系统的位置名为 `plant001`。
- en: 'When using the MQTTCute client, we can use echo-style binary input, using hexadecimal
    input, to activate the plant module:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 MQTTCute 客户端时，我们可以使用 echo 风格的二进制输入，使用十六进制输入来激活植物模块：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This would send the `mod` command to the firmware, along with a bitmask with
    the value 0 x 100\. After this, the plant module should be activated and running.
    Since we are persisting both the location string and the configuration, we do
    not have to repeat this step any more unless we do an OTA update, at which point
    the new firmware will have an empty SPIFFS filesystem, unless we flash the same
    SPIFFS image on both SPIFFS slots on the ROM.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向固件发送 `mod` 命令，以及一个值为 0x100 的位掩码。在此之后，植物模块应该被激活并运行。由于我们正在持久化位置字符串和配置，我们不需要再次重复此步骤，除非我们进行
    OTA 更新，此时新固件将具有空的 SPIFFS 文件系统，除非我们在 ROM 的两个 SPIFFS 插槽上闪存相同的 SPIFFS 图像。
- en: Here, we could expand the OTA code to also download a SPIFFS ROM image in addition
    to the firmware one, though this might add the complication of possibly overwriting
    the existing SPIFFS files.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以扩展 OTA 代码，除了下载固件之外，还可以下载 SPIFFS ROM 图像，尽管这可能会增加覆盖现有 SPIFFS 文件的复杂性。
- en: At this point, we should have a working plant-monitoring and -watering system.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该有一个工作的植物监控和灌溉系统。
- en: Using the system
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用该系统
- en: We can use the measured values and store them in a database by subscribing to
    the `nsa/plant/moisture_raw` topic. The trigger point can be adjusted by sending
    a new command to the `plant/<location string>` topic.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过订阅 `nsa/plant/moisture_raw` 主题来使用测量值并将它们存储在数据库中。通过向 `plant/<location string>`
    主题发送新命令，我们可以调整触发点。
- en: The web server on the device can be accessed by taking the IP address, which
    we can find either by looking at the output on the serial console, as described
    in the previous section, or by looking at the active IP addresses in your router.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 设备上的Web服务器可以通过获取IP地址来访问，我们可以通过查看串行控制台输出（如前所述）或查看路由器中的活动IP地址来找到它。
- en: By opening this IP address in the browser, we should see the HTML template filled
    in with the current values.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开这个IP地址，我们应该会看到填入当前值的HTML模板。
- en: Taking it further
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: 'You also need to have the following considerations:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要考虑以下因素：
- en: At this point, you can further refine the system by implementing plant-watering
    profiles to add dry periods or to adjust for certain soil types. You can add new
    RGB LED modes to make full use of the color choices available.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，您可以通过实现植物浇水配置文件来进一步细化系统，以添加干燥期或调整特定土壤类型。您还可以添加新的RGB LED模式，充分利用可用的颜色选择。
- en: The entire hardware could be built into an enclosure, to make it blend into
    the background, or maybe to make it more visible.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个硬件可以集成到一个外壳中，使其融入背景，或者可能使其更加显眼。
- en: The web interface could be extended to allow for controlling the trigger point
    and such from the browser, instead of having to use an MQTT client.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web界面可以扩展，允许通过浏览器控制触发点等，而不是必须使用MQTT客户端。
- en: In addition to the moisture sensor, you could also add a brightness sensor,
    a temperature sensor, and so on, to measure more aspects that affect the plant's
    health.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了湿度传感器外，您还可以添加亮度传感器、温度传感器等，以测量更多影响植物健康方面的因素。
- en: For bonus points, you could automate the applying of (liquid) fertilizer to
    the plant.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了加分，您还可以自动化向植物施加（液体）肥料的操作。
- en: Complications
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性
- en: One possible complication you may encounter with the ESP8266's ADC is that on
    the NodeMCU boards, the first reserved (RSV) pin that is right next to the ADC
    pin is directly connected to the ESP8266 module's ADC input. This can potentially
    cause issues with electrostatic discharge ESD exposure. Essentially the discharging
    of a high voltage, but low current, into the MCU. Adding a small capacitor on
    this RSV pin to ground can help reduce this risk.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的一个可能的复杂性是ESP8266的ADC问题，在NodeMCU板上，紧挨着ADC引脚的第一个保留（RSV）引脚直接连接到ESP8266模块的ADC输入。这可能会因静电放电ESD暴露而引起问题。本质上是在MCU中放电高压、低电流。在这个RSV引脚上添加一个小电容器可以帮助降低这种风险。
- en: One thing that this system obviously cannot help with is to keep your plants
    pest-free. This means that though the watering may be automated, that doesn't
    mean that you can just ignore the plants. The regular checking of the plants for
    any issues, as well as the system for any issues that may be developing (disconnected
    tubing, things that have fallen over due to cats, and so on) remains an important
    task.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统显然无法帮助的是保持植物无病虫害。这意味着尽管浇水可以自动化，但这并不意味着您可以忽视植物。定期检查植物是否有任何问题，以及系统是否有任何可能发展的问题（如断开的软管、由于猫而倒下的东西等），仍然是一项重要的任务。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to take a simple ESP8266-based project from
    theory and simple requirements to a functioning design with a versatile firmware
    and a collection of input and output options, using which we can ensure that a
    connected plant gets just the right amount of water to stay healthy. We also saw
    how to set up a development environment for the ESP8266.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将一个基于ESP8266的简单项目从理论和简单需求转变为一个具有多功能固件和一系列输入输出选项的运行设计，通过这些我们可以确保连接的植物获得适量的水分以保持健康。我们还看到了如何为ESP8266设置开发环境。
- en: The reader should now be able to create projects for the ESP8266, program the
    MCU with new firmware, and have a solid grasp on both the strengths and limitations
    of this development platform.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该能够为ESP8266创建项目，用新的固件编程MCU，并且对这一开发平台的优势和局限性有一个稳固的掌握。
- en: In the next chapter, we will be looking at how to test embedded software written
    for SoCs and other large, embedded platforms.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何测试为SoC和其他大型嵌入式平台编写的嵌入式软件。
