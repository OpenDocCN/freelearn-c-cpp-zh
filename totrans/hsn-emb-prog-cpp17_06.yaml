- en: Example - Soil Humidity Monitor with Wi-Fi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping indoor plants alive is no small feat. The example project in this chapter
    will show you how to create a Wi-Fi-enabled soil humidity monitor with actuator
    options for a pump or similar, like a valve and gravity-fed water tank. Using
    the built-in web server, we will be able to use its browser-based UI for monitoring
    the plant health and control system features, or integrate it into a larger system
    using its HTTP-based REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming an ESP8266 microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting sensors and actuators to an ESP8266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an HTTP server on this platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a web-based UI for monitoring and control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the project into a larger network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping plants happy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep plants alive, you need a number of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Nutrients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Water
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these, the first two are usually handled by nutrient-rich soil and putting
    the plant in a well-lit place, respectively. The main issue with keeping plants
    alive after satisfying those two points is usually the third point, as this has
    to be handled on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it's not just a simple matter of keeping the water topped up, but instead
    of staying within the range where the soil has enough but not too much water.
    The presence of too much water in the soil affects how much oxygen the plant can
    absorb via its roots. As a result, with too much water in the soil, the plant
    will wither and die.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, too little water means that the plant cannot take up enough
    water to compensate for the water that is being evaporated through its leaves,
    nor can it get the nutrients into its roots. In this case, the plant will also
    wither and die.
  prefs: []
  type: TYPE_NORMAL
- en: When manually watering plants, we tend to use rough estimates of when the plant
    will likely need more water, along with a superficial testing of the humidity
    of the top soil, using our fingers. This tells us little about how much water
    is actually present around the roots of the plant, far below the upper layer of
    soil.
  prefs: []
  type: TYPE_NORMAL
- en: 'To measure the humidity of the soil with more precision, we can use a number
    of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Principle** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Gypsum block | Resistance—– | Water is absorbed by the gypsum, dissolving
    some of it, which allows a current to flow between two electrodes. The resistance
    value indicates soil moisture tension. |'
  prefs: []
  type: TYPE_TB
- en: '| Tensiometer | Vacuum | A hollow tube has a vacuum meter on one end and a
    porous tip at the other, allowing water to enter and leave freely. Water getting
    sucked out of the tube by the soil increases the vacuum sensor readings, indicating
    that it''s harder to extract moisture from the soil for plants (moisture tension).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Capacitance probe | **Frequency Domain Reflectometry** (**FDR**) | Uses the
    dielectric constant between two metal electrodes (in the soil) in an oscillator
    circuit to measure changes to this constant due to changing moisture levels. Indicates
    moisture content. |'
  prefs: []
  type: TYPE_TB
- en: '| Microwave sensor | **Time Domain Reflectometry** (**TDR**) | Measures the
    time required for a microwave signal to travel to the end of the parallel probes
    and back, which differs depending on the dielectric constant of the soil. Measures
    moisture content. |'
  prefs: []
  type: TYPE_TB
- en: '| ThetaProbe | RF amplitude impedance | A 100 MHz sine wave radio signal is
    sent among four probes enclosing a soil cylinder. The change in the impedance
    of the sine wave is used to calculate the water in the soil. |'
  prefs: []
  type: TYPE_TB
- en: '| Resistance probe | Resistance | This is similar to the gypsum block, except
    with just the electrodes. Thus, this only measures water presence (and its conductivity)
    instead of soil moisture tension. |'
  prefs: []
  type: TYPE_TB
- en: All of these sensor types come with their own sets of advantages of disadvantages.
    In the case of the gypsum block and tensiometer, there is a significant amount
    of maintenance, as the former relies on there being enough of the gypsum remaining
    to dissolve and not throw off the calibration, whereas in the latter case, it
    is imperative that the airtight seal remains so as not to let air into the tube.
    Any gap in this seal would immediately render the vacuum sensor useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another big point is that of cost. While FDR- and TDR-based probes may be quite
    accurate, they also tend to be very expensive. This usually leads people who just
    want to experiment with soil moisture sensors to pick either the resistance or
    capacitance-based sensors. Here, the main disadvantage of the former sensor type
    becomes obvious in a month or less of usage: corrosion.'
  prefs: []
  type: TYPE_NORMAL
- en: With two electrodes suspended in a solution containing ions and a current being
    applied to one of the electrodes, simple chemistry results in one of the electrodes
    rapidly corroding (losing material), until it is no longer functional. This also
    pollutes the soil with metal molecules. The use of an **alternating current**
    (**AC**) instead of a direct current on a single electrode can reduce the corrosive
    effect somewhat, but it remains an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Among cheap and still accurate soil moisture sensors, only the capacitance probe
    ticks all of the boxes. Its accuracy is decent enough for sensible measurements
    and comparisons (after calibration), it is unaffected by the moisture in the soil,
    and it does not affect the soil in any manner either.
  prefs: []
  type: TYPE_NORMAL
- en: To actually get water to the plant, we need to have a way to get just the right
    amount to it. Here, it's mostly the scale of the system that determines the choice
    of water delivery. For watering an entire field, we could use an impeller-based
    pump, capable of delivering many liters of water per minute.
  prefs: []
  type: TYPE_NORMAL
- en: For a single plant, we would need to be able to deliver in the order of a few
    hundred milliliters per minute at most. Here, something such as a peristaltic
    pump would be pretty much ideal. This is the kind of pump you would also use in
    laboratories and medical applications where you have to provide a small amount
    of fluid with high accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Our solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep things simple, we will just be building something that can take care
    of a single plant. This will provide us with the most flexibility in terms of
    placement, as we would just have a single system next to each plant, no matter
    whether it's on a windowsill, table, or terrace somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to measuring the soil moisture level, we would also want to be able
    to have the system automatically water the plant at set trigger levels and for
    us to be able to monitor this process. This requires some kind of network access,
    preferably wireless so that we don't have to run any more cables than the power
    connector.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the ESP8266 MCU very attractive, with the NodeMCU development board
    an attractive target for developing and debugging the system. We'd hook up a soil
    moisture sensor to it, along with a peristaltic pump.
  prefs: []
  type: TYPE_NORMAL
- en: By connecting to the ESP8266 system's IP address using a web browser, we would
    see the current status of the system, with the soil humidity level and optionally
    much more. Configuring the system and more would be done over the commonly used,
    compact binary MQTT protocol, with the system also publishing the current system
    status so that we can read it into a database for display and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can also write a backend service later on that combines many of
    such nodes into a coherent system with central control and management. This is
    something that we will actually look at in great detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Monitoring and Control*.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our ideal solution would have the most accurate sensor, without breaking the
    bank. This means that we pretty much have to use a capacitance sensor, as we saw
    earlier in this chapter. These sensors can be obtained as capacitive soil moisture
    sensors for little more than a few euros or dollars for a simple 555 timer IC-based
    design such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9473a55a-2149-4762-9a3d-1580277a0462.png)'
  prefs: []
  type: TYPE_IMG
- en: You would simply stick these into the soil up to the point where the circuitry
    begins, then connect it with a power source as well as the connection to the analog
    to digital converter of the MCU.
  prefs: []
  type: TYPE_NORMAL
- en: Most peristaltic pumps one can purchase require 12V. This means that we need
    to either have a power supply that can provide both 5V and 12V, or use a so-called
    boost converter to convert the 5V to 12V. Either way, we would also need to have
    some method to turn the pump on or off. With the boost converter, we can use its
    *enable* pin to turn its output on or off using a GPIO pin on our MCU.
  prefs: []
  type: TYPE_NORMAL
- en: 'For prototyping, we can use one of these common 5V to 12V boost converter modules
    that use an ME2149 step-up switching regulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97a91881-f1ca-4bbf-a786-fd122d1bba40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These do not have the enable pin broken out in any way, but we can easily solder
    on a wire to the pin in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d992fb6a-fb74-480f-9d5c-4cec48efd14b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This boost-converter module''s outputs are then connected to the peristaltic
    pump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e0cb710-095e-4f43-b2ba-b9c0145085ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we need to get some tubing of the right diameter to connect it to the
    water reservoir and the plant. The pump itself will rotate either direction. As
    it consists of essentially a set of rollers on the section of internal tubing,
    which push the liquid inside one way, either side of the pump can be the input
    or output.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to test the flow direction beforehand with two containers and some water,
    and mark the direction on the pump casing, along with the positive and negative
    terminal connections used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these components, we also want to have an RGB LED connected
    for some signaling and just for looks. For this, we will use the **APA102** RGB
    LED module, which connects to the ESP8266 over the SPI bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/080f68db-2083-4eff-b67e-536e6aee587c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use a single power supply that can be provide 5V with 1A or more, as
    well as cope with the sudden power draw from the boost converter every time that
    the pump is activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole system would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/541c3d8a-ca18-49c7-96cc-1e863fb62a79.png)'
  prefs: []
  type: TYPE_IMG
- en: The firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we will be implementing a module for the same firmware that
    we will be using in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example
    - Building Monitoring and Control*. Therefore, this chapter will only cover the
    parts that are unique to this plant-watering module.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start with the firmware itself, we first have to set up the development
    environment. This involves the installation of the ESP8266 SDK and the Sming framework.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Sming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sming-based ESP8266 development environment can be used on Linux, Windows,
    and macOS. You want to preferably use the development branch of Sming, however,
    which is where using it on Linux (or in a Linux VM, or Windows 10's **Windows
    Subsystem for Linux** (**WSL**)) is the easiest way, and definitely recommended.
    On Linux installing in the `/opt` folder is recommended for consistency with the
    Sming quick start guide.
  prefs: []
  type: TYPE_NORMAL
- en: This quick start guide for Linux can be found at [https://github.com/SmingHub/Sming/wiki/Linux-Quickstart](https://github.com/SmingHub/Sming/wiki/Linux-Quickstart).
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, we can use the Open SDK for ESP8266, which takes the official Espressif
    (non-RTOS) SDK, and replaces all the non-open components it can with open source
    alternatives. This can be installed using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will get the current source for the Open SDK and compile it, targeting
    version 1.5.4 of the official SDK. While a 2.0 version of the SDK already exists,
    some compatibility issues within the Sming framework can remain. Using the 1.5.4
    version offers pretty much the same experience while using well-tested code. This
    will of course change over time, so be sure to check the official Sming documentation
    for updated instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The `STANDALONE` option means that the SDK will be built as a standalone installation
    of the SDK and the toolchain, without further dependencies. This is the desired
    option for use with Sming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing `Sming` is as easy as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will build the Sming framework. If we are adding new libraries to Sming
    in its `Libraries` folder, we have to execute the last step again to have a new
    Sming shared library instance to be built and installed.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, copy the folders in the `libs` folder of the software project
    for this chapter to the `Sming/Sming/Libraries` folder prior to compiling Sming,
    or the project code will not compile.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compile Sming with SSL support. This requires us to compile it with
    the `ENABLE_SSL=1` parameter to Make. This will enable the axTLS-based encryption
    support throughout the Sming library as it is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these steps complete, we just have to install `esptool.py` and `esptool2`.
    While in the `/opt` folder, execute these commands to obtain esptool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Esptool.py` is a Python script that allows us to communicate with the SPI
    ROM that is part of each ESP8266 module. It is the way we will flash the MCU''s
    ROM with our code. This tool is automatically used by Sming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `esptool2` utility is an alternative to the set of scripts in the official
    SDK that turn the linker output into a ROM format that we can write to the ESP8266\.
    It is called by Sming when we are compiling our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, assuming that we installed the SDK and Sming under `/opt`, we can
    add the following global variables and addition to the system `PATH` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last line adds the toolchain's binaries to the path, which we will need
    when debugging ESP8266 applications, as will see in [Chapter 7](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml),
    *Testing Resource-Restricted Platforms*. At this point, we can develop with Sming
    and create ROM images that we can write to the MCU.
  prefs: []
  type: TYPE_NORMAL
- en: Plant module code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the basic source code for this project, starting
    with the core module, `OtaCore`, and continuing with the `BaseModule` class, which
    all firmware modules register with. Finally, we look at the `PlantModule` class
    itself, which contains the business logic for the project requirements that we
    discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also of note is that for this project we enabled both the rBoot bootmanager
    and the rBoot Big Flash options in the project Makefile. What this does is create
    four 1 MB blocks in the 4 MB of ROM that we have available on our ESP8266 module
    (which is all ESP-12E/F modules), of which two are used for firmware images and
    the remaining two for file storage (using the SPIFFS filesystem).
  prefs: []
  type: TYPE_NORMAL
- en: The rBoot bootloader is then written to the beginning of the ROM, so that it
    will be loaded first on each boot. Of the firmware slots, only one is active at
    any given time. A handy feature of this setup is that it allows us to easily perform
    **over-the-air** (**OTA**) updates, by writing the new firmware image to the inactive
    firmware slot, changing the active slot, and restarting the MCU. If rBoot fails
    to boot from the new firmware image, it will fall back on the other firmware slot,
    which is our known working firmware that we performed the OTA update from.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile-user.mk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the root of the `project` folder, we find this Makefile. It contains a number
    of settings that we may want to set to suit our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `COM_PORT` | If we always connect the board to the same serial port, we can
    hardcode it here to save ourselves some typing. |'
  prefs: []
  type: TYPE_TB
- en: '| `SPI_MODE` | This sets the SPI mode used while flashing the firmware images
    to the SPI ROM. With `dio` only two data lines (`SD_D0`, `D1`) or four (`SD_D0-3`).
    Not all SPI ROMs have all four data lines connected. The `qio` mode is faster,
    but `dio` should always work. |'
  prefs: []
  type: TYPE_TB
- en: '| `RBOOT_ENABLED` | When set to 1, this enables rBoot bootloader support. We
    want this enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| `RBOOT_BIG_FLASH` | With 4 MB of ROM available, we wish to use all of this.
    Enable this as well. |'
  prefs: []
  type: TYPE_TB
- en: '| `RBOOT_TWO_ROMS` | This option can be used if we wish to place two firmware
    images in a single 1 MB ROM chip instead. This applies to some ESP8266 modules
    and derivatives. |'
  prefs: []
  type: TYPE_TB
- en: '| `SPI_SIZE` | Here, we set the size of the SPI ROM chip, which should be 4M
    for this project. |'
  prefs: []
  type: TYPE_TB
- en: '| `SPIFF_FILES` | The location of the folder containing the files that will
    be put on the SPIFFS ROM image that will be written to the MCU. |'
  prefs: []
  type: TYPE_TB
- en: '| `SPIFFS_SIZE` | The size of the SPIFFS ROM image to create. Here, 64 KB is
    standard, but we could use up to 1 MB if we needed to when using a 4 MB ROM with
    the `RBOOT_BIG_FLASH` option enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| `WIFI_SSID` | The SSID of the Wi-Fi network that we wish to connect to. |'
  prefs: []
  type: TYPE_TB
- en: '| `WIFI_PWD` | The password for the Wi-Fi network. |'
  prefs: []
  type: TYPE_TB
- en: '| `MQTT_HOST` | The URL or IP address of the MQTT server (broker) to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `ENABLE_SSL` | Enable this with SSL support compiled into Sming to make the
    firmware use TLS-encrypted connections with the MQTT broker. |'
  prefs: []
  type: TYPE_TB
- en: '| `MQTT_PORT` | The port of the MQTT broker. This depends on whether SSL is
    enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| `USE_MQTT_PASSWORD` | Set to true if you wish to connect to the MQTT broker
    with a username and password. |'
  prefs: []
  type: TYPE_TB
- en: '| `MQTT_USERNAME` | The MQTT broker username, if required. |'
  prefs: []
  type: TYPE_TB
- en: '| `MQTT_PWD` | The MQTT broker password, if required. |'
  prefs: []
  type: TYPE_TB
- en: '| `MQTT_PREFIX` | A prefix you can optionally add in front of each MQTT topic
    used by the firmware, if necessary. It has to end with a slash if not left empty.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OTA_URL` | The hardcoded URL that will be used by the firmware whenever
    an OTA update is requested. |'
  prefs: []
  type: TYPE_TB
- en: Of these, the Wi-Fi, MQTT, and OTA settings are essential, as they will allow
    the application to connect to the network and MQTT broker, as well as receive
    firmware updates without having to flash the MCU over its serial interface.
  prefs: []
  type: TYPE_NORMAL
- en: Main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main source file and with it the application entry point is pretty uneventful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the `OtaCore` class containing the main application logic, we merely call
    its static initialization function while providing a callback function if we wish
    to execute any further logic after the core class has finished setting up the
    network, MQTT, and other functionality.
  prefs: []
  type: TYPE_NORMAL
- en: OtaCore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this class, we set up all of the basic network functionality for the specific
    feature modules, in addition to providing utility functions for logging and MQTT
    functionality. This class also contains the main command processor for commands
    received over MQTT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These two includes are required to make use of the Sming framework. With them,
    we include the main headers of the SDK (`user_config.h`) and those of Sming (`SmingCore.h`).
    This also defines a number of preprocessor statements, such as to use the open
    source **Light-Weight IP stack** (**LWIP**) and to deal with some issues in the
    official SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also of note is the `esp_cplusplus.h` header, which is indirectly included
    this way. Its source file implements the `new` and `delete` functions, as well
    as a few handlers for class-related functionality, such as `vtables` when using
    virtual classes. This enables compatibility with the STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These two enumerations define the logging levels, and the individual GPIO and
    other pins of the ESP8266 that we may want to use. The values for the ESP8266
    pin enumeration correspond to positions in a bitmask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the fixed pins for the I2C bus. These correspond to GPIO 4 and
    5, also known as **D1** and **D2** on NodeMCU boards. The main reason for having
    these pins predefined is that they are two of the few *safe* pins on the ESP8266.
  prefs: []
  type: TYPE_NORMAL
- en: Many pins of the ESP8266 will change levels during startup before settling,
    which can cause unwanted behavior with any connected peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We define two function pointers, one to be used by feature modules when they
    wish to register an MQTT topic, along with a callback function. The other is the
    callback we saw in the main function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The class declaration itself gives a good overview of the functionality provided
    by this class. The first thing we notice is that it is completely static. This
    ensures that this class's functionality is immediately initialized when the firmware
    starts, and that it can be accessed globally without having to worry about specific
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the first use of the `uint32` type, which along with other integer
    types is defined similar to those in the `cstdint` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We include the `BaseModule` class's header here, so that we can call its own
    initialization function later on after we have finished setting up the basic functionality.
    The static class members are also initialized here, with a number of default values
    assigned where relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Of note here is the initializing of a second serial interface object in addition
    to the default Serial object instance. These correspond to the first (UART0, Serial)
    and second (UART1, Serial1) UART on the ESP8266.
  prefs: []
  type: TYPE_NORMAL
- en: With older versions of Sming, the SPIFFS-related file functions had trouble
    with binary data (due to internally assuming null-terminated strings), which is
    why the following alternative functions were added. Their naming is a slightly
    inverted version from the original function name to prevent naming collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Since TLS certificates and other binary data files stored on SPIFFS have to
    be able to be written and read for the firmware to function correctly, this was
    a necessary compromise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function reads the entire contents of the specified file into a `String`
    instance that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function replaces the existing content in a file with the new data in the
    provided `String` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to `getFileContent()`, but returns a simple character
    buffer instead of a `String` instance. It's mostly used for reading in the certificate
    data, which is passed into a C-based TLS library (called axTLS), where converting
    to a `String` instance would be wasteful with the copying involved, especially
    where certificates can be a few KB in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the initialization function for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We first initialize the two UARTs (serial interfaces) in the NodeMCU. Although
    officially there are two UARTs in the ESP8266, the second one consists only out
    of a TX output line (GPIO 2, by default). Because of this, we want to keep the
    first UART free for applications requiring a full serial line, such as some sensors.
  prefs: []
  type: TYPE_NORMAL
- en: The first UART (`Serial`) is thus initialized so that we can later use it with
    feature modules, while the second UART (`Serial1`) is initialized to the default
    baud rate of 115,200, along with the system's debug output (WiFi/IP stack, and
    so on) being directed to this serial output as well. This second serial interface
    will thus be used solely for logging output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, the `BaseModule` static class is initialized as well. This causes all
    feature modules active in this firmware to be registered, allowing them to be
    activated later on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Automatically mounting the SPIFFS filesystem while using the rBoot bootloader
    did not work with older releases of Sming, which is why we are doing it manually
    here. To do this, we get the current firmware slot from rBoot, using which we
    can pick the proper offset, either at the start of the second megabyte in the
    ROM, or of the fourth megabyte.
  prefs: []
  type: TYPE_NORMAL
- en: With the offset determined, we use the SPIFFS manual-mounting function with
    our offset and the size of the SPIFFS section. We are now able to read and write
    to our storage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, we print out a few system details to the serial debug output. This includes
    the ESP8266 SDK version we compiled against, the current free heap size, CPU frequency,
    the MCU ID (32-bit ID), and the ID of the SPI ROM chip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We create a new MQTT client on the heap, providing the callback that will be
    called when we receive a new message. The MQTT broker host and port are filled
    in by the preprocessor from the details we added in the user Makefile for the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As the final steps in the initialization, we output the current firmware slot
    that we are running from, then enable the Wi-Fi client while disabling the **wireless
    access point** (**WAP**) functionality. The WiFi client is told to connect to
    the WiFi SSID with the credentials that we specified previously in the Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define the handlers for a successful WiFi connection and for a failed
    connection attempt, before calling the callback function we were provided with
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'After an OTA update of the firmware, the following callback function will be
    called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, we change the active ROM slot if the OTA update was successful,
    followed by a reboot of the system. Otherwise, we simply log an error and do not
    restart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are a few MQTT-related functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These two functions allow feature modules to respectively register and deregister
    an MQTT topic along with a callback. The MQTT broker is called with a subscription
    or unsubscribe request and the `HashMap` instance is updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Any feature modules can publish an MQTT message on any topic using this function.
    The **Quality of Service** (**QoS**) parameter determines the publish mode. By
    default, messages are published in *retain* mode, meaning that the broker will
    retain the last published message for a particular topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry point for the OTA update functionality is found in the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For an OTA update, we need to create a clean `rBootHttpUpdate` instance. We
    then need to configure this instance with the details of the current firmware
    slot, for which we obtain the configuration from rBoot and with it the current
    firmware slot number. This we use to give the number of the other firmware slot
    to the OTA updater.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we only configure it to update the firmware slot, but we could also update
    the SPIFFS section for the other firmware slot as well this way. The firmware
    will be fetched over HTTP from the fixed URL we set before. The ESP8266's MAC
    address is affixed to the end of it as a unique query string parameter so that
    the update server knows which firmware image fits this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the `callback` function that we looked at earlier, we start the
    update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the MQTT disconnection handler. It is called whenever the connection
    with the MQTT broker fails so that we can try reconnecting after a two-second
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: The flag parameter is set to true if we previously were connected, and false
    if the initial MQTT broker connection failed (no network access, wrong address,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the function to configure and start the MQTT client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We stop the procTimer timer if it's running in case we were being called from
    a reconnect timer. Next, we set the **last will and testament** (**LWT**) for
    this device, which allows us to set a message that the MQTT broker will publish
    when it loses the connection with the client (us).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define three different execution paths, only one of which will be
    compiled, depending on whether we are using TLS (SSL), a username/password login,
    or anonymous access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If we are using TLS certificates, we establish a connection with the MQTT broker,
    using our `MAC` as client identifier, then enable the SSL option for the connection.
    The available heap space is printed to the serial logging output for debugging
    purposes. Usually, at this point, we should have around 25 KB of RAM left, which
    is sufficient for holding the certificate and key in memory, along with the RX
    and TX buffers for the TLS handshake if the latter are configured on the SSL endpoint
    to be an acceptable size using the SSL fragment size option. We will look at this
    in more detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example
    - Building Management and Control*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we read the DER-encoded (binary) certificate and key files from SPIFFS.
    These files have a fixed name. For each file, we print out the file size, along
    with the current free heap size. If either file size is zero bytes, we consider
    the read attempt to have failed and we abort the connection attempt.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we use the key and certificate data with the MQTT connection, which
    should lead to a successful handshake and establishing an encrypted connection
    with the MQTT broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'After deleting the key and certificate file data, we print out the free heap
    size to allow us to check that the cleanup was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When using an MQTT username and password to log in to the broker, we just need
    to call the previous function on the MQTT client instance, providing our MAC as
    client identifier along with the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect anonymously, we set up a connection with the broker and pass our
    `MAC` as the client identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first set the MQTT disconnect handler. Then, we subscribe to a number
    of topics that we wish to respond to. These all relate to management functionality
    for this firmware, allowing the system to be queried and configured over MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: After subscribing, we briefly (100 ms) wait to give the broker some time to
    process these subscriptions before we publish on the central notification topic,
    using our `MAC` to let any interested clients and servers know that this system
    just came online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are the WiFi connection handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This handler is called when we have successfully connected to the configured
    WiFi network using the provided credentials. After connecting, we keep a copy
    of our `MAC` in memory as our unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: This firmware also supports specifying a user-defined string as our location
    or similar identifier. If one has been defined before, we load it from SPIFFS
    and use it; otherwise, our location string is simply the `MAC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we load the 32-bit bitmask that defines the feature module configuration
    from SPIFFS if it exists. If not, all feature modules are initially left deactivated.
    Otherwise, we read the bitmask and pass it to the `updateModules()` function so
    that the relevant modules will be activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If connecting to the Wi-Fi network fails, we log this fact, then tell the MCU's
    watchdog timer that we are still alive to prevent a soft restart before we attempt
    to connect again.
  prefs: []
  type: TYPE_NORMAL
- en: 'This finishes all of the initialization functions. Next up are the functions
    used during normal activity, starting with the MQTT message handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We registered this callback when we initially created the MQTT client instance.
    Every time a topic that we subscribed to receives a new message on the broker,
    we are notified and this callback receives a string containing the topic and another
    string containing the actual message (payload).
  prefs: []
  type: TYPE_NORMAL
- en: We can compare the topic with the topics we registered for, and perform the
    required operation, whether it is to perform an OTA update (if it specifies our
    `MAC`), respond to a ping request by returning a pong response with our `MAC`,
    or to restart the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next topic is a more generic maintenance one, allowing one to configure
    active feature modules, set the location string, and request the current status
    of the system. The payload format consists out of the command string followed
    by a semicolon, and then the payload string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We start by extracting the command from the payload string using a simple find
    and substring approach. We then read in the remaining payload string, taking care
    to read it in as a binary string. For this, we use the remaining string's length
    and as starting position, the character right after the semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have extracted the command and payload and can see what we
    have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This command sets which feature modules should be active. Its payload should
    be an unsigned 32-bit integer forming a bitmask, which we check to make sure that
    we have received exactly four bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the bitmask, the bits each match up with a module, which at this point are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit position** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01 | THPModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x02 | CO2Module |'
  prefs: []
  type: TYPE_TB
- en: '| 0x04 | JuraModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x08 | JuraTermModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10 | MotionModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x20 | PwmModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x40 | IOModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x80 | SwitchModule |'
  prefs: []
  type: TYPE_TB
- en: '| 0x100 | PlantModule |'
  prefs: []
  type: TYPE_TB
- en: Of these, the CO2, Jura, and JuraTerm modules are mutually exclusive, since
    they all use the first UART (`Serial`). If two or more of these are still specified
    in the bitmask, only the first module will be enabled and the others ignored.
    We will look at these other feature modules in more detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Management and Control*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we obtain the new configuration bitmask, we send it to the `updateModules()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, we set the new location string, if it is different then
    the current one, also saving it to the location file in SPIFFS to persist it across
    a reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last three commands in this section return the current bitmask for the
    active feature modules, the firmware version, and trigger an OTA upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last entry in the `if...else` block looks at whether the topic is perhaps
    found in our list of callbacks for the feature modules. If found, the callback
    is called with the MQTT message string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, this means that only one feature module can register itself to a
    specific topic. Since each module tends to operate under its own MQTT sub-topic
    to segregate the message flow, this is generally not a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function is pretty simple. It mostly serves as a pass-through for the `BaseModule`
    class, but it also ensures that we keep the configuration file in SPIFFS up to
    date, writing the new bitmask to it when it has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We absolutely must prevent unnecessary writes to SPIFFs, as the underlying
    Flash storage has finite write cycles. Limiting write cycles can significantly
    extend the lifespan of the hardware, as well as reduce overall system load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This function maps the given GPIO pin number to its position in the internal
    bitmask. It uses the enumeration we looked at for the header file for this class.
    With this mapping, we can set the used/unused state of GPIO pins of the ESP8266
    module using just a single uint32 value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the logging method, we append the log level to the message string before
    writing it to the serial output, as well as publishing it on MQTT. Here, we publish
    on a single topic, but as a refinement you could log on a different topic depending
    on the specified level.
  prefs: []
  type: TYPE_NORMAL
- en: 'What makes sense here depends a great deal on what kind of backend you have
    set up to listen for and process logging output from the ESP8266 systems running
    this firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This function starts the I2C bus if it hasn't been started already. It tries
    to register the pins it wishes to use for the I2C bus. If these are available,
    it will set the clock line (SCL) to output mode and first pulse it eight times
    to unfreeze any I2C devices on the bus.
  prefs: []
  type: TYPE_NORMAL
- en: After pulsing the clock line like his, we start the I2C bus on the pins and
    make a note of the active state of this bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Frozen I2C devices can occur if the MCU power cycles when the I2C devices do
    not, and remain in an indeterminate state. With this pulsing, we make sure that
    the system won''t end up in a non-functional state, requiring manual intervention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting the SPI bus is similar to staring the I2C bus, except without a similar
    recovery mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This overloaded function is used to register a GPIO pin by a feature module
    before it starts, to ensure that no two modules attempt to use the same pins at
    the same time. One version accepts a pin number (GPIO) and uses the mapping function
    we looked at earlier to get the bit address in the `esp8266_pins` bitmask before
    passing it on to the other version of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that function, the pin enumeration is used to do a bitwise `AND` comparison.
    If the bit has not been set yet, it is toggled and true is returned. Otherwise,
    the function returns false and the calling module knows that it cannot proceed
    with its initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This overloaded function, to release a pin when a feature module is shutting
    down, works in a similar manner. One uses the mapping function to get the bit
    address, the other performs a bitwise `AND` operation to check that the pin has
    in fact been set, and toggles it to an off position with the bitwise `OR` assignment
    operator if it was set.
  prefs: []
  type: TYPE_NORMAL
- en: BaseModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class contains the logic for registering and keeping track of which feature
    modules are currently active or inactive. Its header file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The inclusion of the `OtaCore` header is to allow us to use the logging feature.
    Beyond this, we create another enumeration, which maps a specific feature module
    to a particular bit in the feature module bitmask (`active_mods`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, function pointers are defined, which are used for respectively starting
    and shutting down a feature module. These will be defined by the feature modules
    as they register themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These are the feature modules that currently exist for this firmware as of writing.
    Since we only need the plant module for this project, we could comment out all
    header files for the other modules, along with their initialization in the initialization
    function of this class.
  prefs: []
  type: TYPE_NORMAL
- en: This would not affect the resulting firmware image in any way other than that
    we cannot enable those modules since they do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the class declaration itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Each feature module is represented internally by a `SubModule` instance, the
    details of which we can see in a moment in the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a static class, we first initialize its class variables. We have
    an array with space for 32 `SubModule` instances, to fit the full bitmask. Beyond
    this, no modules are active, so everything is initialized to zero and false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When we called this function in `OtaCore`, we also triggered the registration
    of the feature modules defined here. By selectively removing or commenting out
    modules in this function, we can remove them from the final firmware image. Those
    modules that are called here will call the following function to register themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first feature module that calls this function will trigger the initialization
    of the `SubModule` array, setting all of its values to a neutral setting, while
    also creating the bitmask for this position in the array, which allows us to update
    the `active_mods` bitmask, as we will see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing the array, we check whether this position in the array already
    has a module registered for it. If it has, we return false. Otherwise, we register
    the module''s function pointers for starting and shutting down, and increase the
    active module count before returning true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The input parameter to this function is the bitmask we extracted from the MQTT
    payload in `OtaCore`. Here, we use a bitwise XOR comparison with the active modules
    bitmask to obtain a new bitmask indicating any changes to be made. If the result
    is zero, we know that they're identical and we can return without further action
    being required.
  prefs: []
  type: TYPE_NORMAL
- en: The `uint32` bitmask we have thus obtained indicates which modules should be
    toggled on or off. For this, we check each bit of the mask. If it is a `1` (AND
    operator returns a value that's not zero), we check whether the module at that
    position in the array exists and has been started yet.
  prefs: []
  type: TYPE_NORMAL
- en: If the module has been started, we attempt to shut it down. If the module's
    shutdown() function succeeds (returns true), we toggle the bit in the `active_mods`
    bitmask to update its status. Similarly, if the module has not been started yet,
    a module has been registered at that location, we attempt to start it, updating
    the active modules if this succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: We check that a start function callback has been registered to ensure that we
    do not accidentally call an improperly registered module and crash the system.
  prefs: []
  type: TYPE_NORMAL
- en: PlantModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have had a detailed look at the underlying, supporting code
    that makes life easy when writing a new module because we don't have to do all
    of the housekeeping ourselves. The only thing we haven't seen yet is an actual
    module, or code directly pertaining to this chapter's project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at the last part of the puzzle, the `PlantModule`
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Of note in this class declaration is the inclusion of the APA102 library header.
    This is a simple library that allows us to write color and brightness data to
    APA102 RGB (full-spectrum) LEDs, over the SPI bus.
  prefs: []
  type: TYPE_NORMAL
- en: We also define the pin that we wish to use to trigger the peristaltic pump (GPIO
    5) and the number of connected APA102 LED modules (1). You can add multiple APA102
    LEDs in series if you want, simply updating the definition to match the count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we initialize the static class members, setting the GPIO pin
    and defining the initial sensor value at which the pump should be triggered. This
    trigger value should be updated to match your own sensor calibration results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define an enumeration containing the possible commands for this
    module that can be sent to it over MQTT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the initialization function the `BaseModule` calls on startup. As we
    can see, it causes this module to register itself with preset values, including
    its start and shutdown callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When this module starts, we attempt to claim the pin we wish to use for triggering
    the pump, as well as register a callback for an MQTT topic so that we can accept
    commands using the command handler callback. The topic on which we will responses
    after processing a command is also defined here.
  prefs: []
  type: TYPE_NORMAL
- en: The output pin mode is set, followed by the starting of the HTTP server on port
    80, registering a basic handler for client requests. Next, we create a new `APA102`
    class instance and use it to get the connected LED to display green at about half
    of full brightness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we start a timer that will trigger the reading out of the connected
    soil sensor every minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When shutting down this module, we release the pin we registered previously,
    stop the web server, delete the RGB LED class instance (with a check to see that
    deleting it is necessary), deregister our MQTT topic, and finally stop the sensor
    timer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This callback is called whenever a message is published on the MQTT topic we
    registered. In our messages, we expect to find a single byte (uint8) value that
    defines the command, up to eight distinct commands. For this module, we earlier
    defined three commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'These commands are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01 | Get soil moisture | - | 0xXXXX |'
  prefs: []
  type: TYPE_TB
- en: '| 0x02 | Set trigger level | uint16 (new trigger level) | - |'
  prefs: []
  type: TYPE_TB
- en: '| 0x04 | Get trigger level | - | 0xXXXX |'
  prefs: []
  type: TYPE_TB
- en: Here, every command returns the requested value, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: After checking that the message string we got has at least one byte in it, we
    extract the first byte and try to interpret it as a command. If we are setting
    a new trigger point, we also extract the new value as a uint16 from the message
    after making sure that we have a properly formed message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the function in which all of the magic happens that we have
    been working toward in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As the first step, we read out the current sensor value from the analog input
    of the ESP8266 and publish it on the MQTT topic for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: During calibration of one prototype with a soil moisture sensor, it was found
    that the value for a completely dry sensor (held in the air) was approximately
    766, whereas having the same sensor submerged in water got 379 as a value. From
    this, we can deduce that 60% moisture content should be roughly around a reading
    of 533, which matches the initial value we set during the static initialization
    step. The ideal trigger point and target soil moisture level of course depends
    on the soil type and specific plant.
  prefs: []
  type: TYPE_NORMAL
- en: With this trigger level reached, we set the output pin that is connected to
    the enable pin of the boost converter to high, causing it to turn on its output,
    which in turn starts the pump. We wish to let it pump for about ten seconds.
  prefs: []
  type: TYPE_NORMAL
- en: During this time we set the LED color to blue, then during each second we drop
    its brightness from 100% to nearly off and then back to full brightness again,
    creating a pulsating effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we set the output pin back to low, which disables the pump, and
    we await the next soil moisture sensor reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we see here the request handler for our web server. What it does is
    read in a template file from SPIFFS (detailed in the next section), gets the list
    of variables in this template file, and then proceeds to read out the current
    sensor value.
  prefs: []
  type: TYPE_NORMAL
- en: Using this value, it calculates the current soil moisture percentage and uses
    both the raw and calculated numbers to fill in the two variables in the template
    before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: Index.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For use with the PlantModule''s web server, we have to add the following template
    file to SPIFFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and flashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After finishing the code for our application, we can compile it with a single
    command in the project''s root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: After this completes, we can find the binaries including the ROM images in the
    `out` folder. Since we are using both the rBoot bootloader and SPIFFs, we get
    three ROM images in total in the `firmware` folder.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can connect an ESP8266 module, either in the form of a NodeMCU
    board or one of the many alternatives, and note the serial port that it will be
    connected to. On Windows, this will be something like `COM3`; on Linux, USB-to-serial
    adapters usually are registered as `/dev/ttyUSB0` or similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless we have specified the serial port (`COM_PORT`) in the user Makefile,
    we have to specify it explicitly when we flash to the ESP8266 module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After executing this command, we should see the output from the `esptool.py`
    utility, as it connects to the ESP8266's ROM and starts writing the ROM images
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is complete, the MCU will restart and it should boot straight into
    the new firmware image, where it will await our commands to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: First-time configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, this firmware is designed to be configured
    and maintained over MQTT. This requires that an MQTT broker is available. An MQTT
    broker such as Mosquitto ([http://mosquitto.org/](http://mosquitto.org/)) is popular.
    Since it's a lightweight server, it can be installed on a desktop system, a small
    SBC, inside a virtual machine, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In addition the broker and the ESP8266 running the firmware, we also need our
    own client
  prefs: []
  type: TYPE_NORMAL
- en: to interact with the firmware. Since we use binary protocols, our choice there
    is somewhat
  prefs: []
  type: TYPE_NORMAL
- en: limited, as most common MQTT desktop clients assume text-based messages. One
  prefs: []
  type: TYPE_NORMAL
- en: approach one can use to publish binary messages is to use the MQTT publish client
    that
  prefs: []
  type: TYPE_NORMAL
- en: comes with Mosquitto and use the **echo** command-line tool's hexadecimal input
    to send
  prefs: []
  type: TYPE_NORMAL
- en: binary data to it as a stream to be published by the client tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, the author of this book has developed a new MQTT desktop client
    (based on C++ and Qt) that is designed around the use and debugging of binary
    protocols on MQTT: [https://github.com/MayaPosch/MQTTCute](https://github.com/MayaPosch/MQTTCute).'
  prefs: []
  type: TYPE_NORMAL
- en: With all three components in place—ESP8266 running the project, the MQTT broker
    and desktop client—we can have the entire plant monitoring and watering system
    assembled and send it the command to enable the plant module.
  prefs: []
  type: TYPE_NORMAL
- en: While monitoring the cc/config topic for messages, we should see the ESP8266
    report its presence by publishing its `MAC`. We can also get this by hooking up
    a USB to TTL serial adapter to the serial logging output pin (`D4` on NodeMCU).
    By looking at the output on our serial console, we will see both the IP address
    and the `MAC` of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we compose a new topic of the format `cc/<MAC>`, we can then publish commands
    to the firmware, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This would set the location name of the system to `plant001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the MQTTCute client, we can use echo-style binary input, using hexadecimal
    input, to activate the plant module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This would send the `mod` command to the firmware, along with a bitmask with
    the value 0 x 100\. After this, the plant module should be activated and running.
    Since we are persisting both the location string and the configuration, we do
    not have to repeat this step any more unless we do an OTA update, at which point
    the new firmware will have an empty SPIFFS filesystem, unless we flash the same
    SPIFFS image on both SPIFFS slots on the ROM.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we could expand the OTA code to also download a SPIFFS ROM image in addition
    to the firmware one, though this might add the complication of possibly overwriting
    the existing SPIFFS files.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a working plant-monitoring and -watering system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the measured values and store them in a database by subscribing to
    the `nsa/plant/moisture_raw` topic. The trigger point can be adjusted by sending
    a new command to the `plant/<location string>` topic.
  prefs: []
  type: TYPE_NORMAL
- en: The web server on the device can be accessed by taking the IP address, which
    we can find either by looking at the output on the serial console, as described
    in the previous section, or by looking at the active IP addresses in your router.
  prefs: []
  type: TYPE_NORMAL
- en: By opening this IP address in the browser, we should see the HTML template filled
    in with the current values.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You also need to have the following considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can further refine the system by implementing plant-watering
    profiles to add dry periods or to adjust for certain soil types. You can add new
    RGB LED modes to make full use of the color choices available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire hardware could be built into an enclosure, to make it blend into
    the background, or maybe to make it more visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web interface could be extended to allow for controlling the trigger point
    and such from the browser, instead of having to use an MQTT client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the moisture sensor, you could also add a brightness sensor,
    a temperature sensor, and so on, to measure more aspects that affect the plant's
    health.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For bonus points, you could automate the applying of (liquid) fertilizer to
    the plant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One possible complication you may encounter with the ESP8266's ADC is that on
    the NodeMCU boards, the first reserved (RSV) pin that is right next to the ADC
    pin is directly connected to the ESP8266 module's ADC input. This can potentially
    cause issues with electrostatic discharge ESD exposure. Essentially the discharging
    of a high voltage, but low current, into the MCU. Adding a small capacitor on
    this RSV pin to ground can help reduce this risk.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that this system obviously cannot help with is to keep your plants
    pest-free. This means that though the watering may be automated, that doesn't
    mean that you can just ignore the plants. The regular checking of the plants for
    any issues, as well as the system for any issues that may be developing (disconnected
    tubing, things that have fallen over due to cats, and so on) remains an important
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to take a simple ESP8266-based project from
    theory and simple requirements to a functioning design with a versatile firmware
    and a collection of input and output options, using which we can ensure that a
    connected plant gets just the right amount of water to stay healthy. We also saw
    how to set up a development environment for the ESP8266.
  prefs: []
  type: TYPE_NORMAL
- en: The reader should now be able to create projects for the ESP8266, program the
    MCU with new firmware, and have a solid grasp on both the strengths and limitations
    of this development platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how to test embedded software written
    for SoCs and other large, embedded platforms.
  prefs: []
  type: TYPE_NORMAL
