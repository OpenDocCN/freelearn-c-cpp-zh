<html><head></head><body>
        

                            
                    <h1 class="header-title">Fun with Lights</h1>
                
            
            
                
<p>Most of the larger projects that we create will use one or more LEDs as indicators. These LEDs can indicate things such as power, receiving data, warnings or anything else that we may need visual feedback for. We have already seen how to use a basic, single-color LED but what if we need multiple LEDs or even multicolor LEDs? In this chapter, we will look at other ways to add LEDs to your project.</p>
<p>In this chapter, you will learn:</p>
<ul>
<li>What NeoPixels are</li>
<li>How an RGB LED works</li>
<li>How to use NeoPixels in your projects</li>
<li>How to use an RGB LED in your projects</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, we will look at how to use RGB LEDs and a <strong>WS2812 40 RGB LED Pixel Arduino shield</strong>. Let's start off by learning about the RGB LED.</p>
<p>A multicolor or RGB LED isn't really a single LED that can change color, it is actually three LEDs. An RGB LED contains three LEDs, which are red, green, and blue in color. The color that the LED produces is a combination of the colors produced by these three LEDs.</p>
<p>There are two types of RGB LEDs. These are the common anode and the common cathode LED. In a common cathode LED, the three LEDs share a common ground source, and in a common anode RGB LED, the three LEDs share a common power source.</p>
<p>The RGB LED has four pins, one for each color and the fourth one for the common cathode or anode connection. The following diagram shows the pins for both the common cathode and common anode RGB LED:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2f9d2d26-bbc0-49f9-ad94-1566ff4478b3.png" style="width:10.83em;height:15.17em;"/></p>
<p>To produce the various colors, we can adjust the intensities of the three different LEDs using the PWM pins on the Arduino. The light will then mix together, because the LEDs are so close, producing the color we want. Now let's look at what a WS2812 integrated light source, or, as they are known on Adafruit's site, the <strong>NeoPixel</strong>. For most of this chapter, we will refer to the WS2812 integrated light source as a NeoPixel because it is shorter and also sounds cool.</p>
<p>As you can imagine, if we wanted to include 10 RGB LEDs in a project, where each LED required three input pins, the project would very quickly turn into a wired mess. Not to mention we would quickly run out of pins on the Arduino as well. One of the ways that we can solve this problem is to use the NeoPixel. The NeoPixel integrates red, green and blue LEDs alongside a driver chip on a tiny surface-mounted package. This package can be controlled through a single wire and can be used individually or as a group. NeoPixel's come in many form factors including strips, rings, Arduino shields and even on jewelry.</p>
<p>One nice thing about the NeoPixel is there is no inherent limit to the number of NeoPixels that can be chained together. However, there are some practical limits based on the RAM and power constraints of the controller you are using.</p>
<p>In this chapter, we will be using a NeoPixel shield. If you use individual NeoPixels, there are a couple of things you need to keep in mind:</p>
<ul>
<li>Before connecting the NeoPixels to a power source, you will want to add a 1000 microfarad, 6.3V or higher capacitor.</li>
<li>You will also want to add a 470 ohm resistor between the Arduino data output and the input line on the first NeoPixel.</li>
<li>If at all possible, avoid connecting/disconnecting NeoPixels when the circuit is live. If you must connect them to a live circuit, always connect the ground first. If you must disconnect them from a live circuit, always disconnect the 5V power first.</li>
<li>NeoPixels should always be powered from a 5V power source.</li>
</ul>
<p>In this chapter, we will be using the <strong>Keyestudio 40 RGB LED 2812 Pixel Matrix shield</strong>. This shield already contains the capacitor and resistor, so all we need to do is to place the shield on top of the Arduino Uno and we are good to go. The Keyestudio shield attaches to the Arduino as shown in the following photograph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/37ad2196-1591-40d9-b5e6-a9298a8678d6.png" style="width:35.83em;height:22.42em;"/></p>
<p>When using other NeoPixel form factors, always read the manufacturers' data sheet prior to connecting it to the Arduino. It is really easy to damage a NeoPixels so make sure you follow the manufacturers' recommendations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components needed</h1>
                
            
            
                
<p>We will need the following components for this chapter's project:</p>
<ul>
<li>One Arduino Uno or compatible board</li>
<li>One RGB LED either a common cathode or a common anode</li>
<li>Three 330 ohm resistors</li>
<li>One Keyestudio 40 RGB LED 2812 Pixel Matrix shield</li>
<li>Jumper wires</li>
<li>One breadboard</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Circuit diagrams</h1>
                
            
            
                
<p>The following diagram shows how we would connect a common anode RGB LED to the Arduino:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/da63fa99-99f0-45ca-89ac-9c5ea6863a23.png" style="width:35.00em;height:27.58em;"/></p>
<p>In this diagram, we show how to connect a common anode RGB LED. We can see this because the common pin is connected to the power rail on the breadboard. If the RBG LED that you are using is a common cathode LED, then connect the common pin, on the LEDs, to the ground rail instead of the power rail. Each of the RGB pins is connected to the Arduino PWM pins with a 330 ohm resistor.</p>
<p>We are not showing a circuit diagram for the NeoPixel shield because we only need to attach the shield to the Arduino. Now let's look at the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code</h1>
                
            
            
                
<p>Let's start off by looking at the code for the RGB LED.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RGB LED</h1>
                
            
            
                
<p>We will start off by defining which pins on the Arduino are connected to the RGB pins on the LED:</p>
<pre>#define REDPIN 11
#define BLUEPIN 10
#define GREENPIN 9</pre>
<p>This code shows that the red pin is connected to the Arduino 11 PWM pin, the blue pin is connected to the Arduino 10 PWM pin and the green pin is connected to the Arduino 9 PWM pin. We are going to define an empty macro that will let the application code know whether we have a common anode or a common cathode RGB LED. The following code will do that:</p>
<pre>#define COMMON_ANODE</pre>
<p>If you are using a common cathode RGB LED, then comment or remove this line from your code. We will see how to use this when we look at the function that sets the colors of the LED. Now let's look at the <kbd>setup()</kbd> function.</p>
<pre>void setup() {
  pinMode(REDPIN, OUTPUT);
  pinMode(GREENPIN, OUTPUT);
  pinMode(BLUEPIN, OUTPUT);
}</pre>
<p>The <kbd>setup()</kbd> function will set the mode of the pins, that are connected to the RGB pins on the LED, to output. This will allow us to use the PWM pins to set the light intensity of the three-color LEDs that make up the RGB LED. Next, we will need to create a function that will set these colors. We will name this function <kbd>setColor()</kbd>, and it will take three parameters that will define the intensity of each RGB LED and contain the following code:</p>
<pre>void setColor(int red, int green, int blue) {
  #ifdef COMMON_ANODE
  red = 255 - red;
  green = 255 - green;
  blue = 255 - blue;
  #endif
  analogWrite(REDPIN, red);
  analogWrite(GREENPIN, green);
  analogWrite(BLUEPIN, blue);
}</pre>
<p>The code in this function starts off with a <kbd>#ifdef</kbd> statement. This statement says that if the <kbd>COMMON_ANODE</kbd> macro is defined, then execute the code between the <kbd>#ifdef</kbd> and the <kbd>#endif</kbd> statements; otherwise, skip that code. Therefore, if we define the <kbd>COMMON_ANODE</kbd> macro at the beginning of the code, then we subtract each parameter from <kbd>255</kbd> to get the correct intensity. We then use the <kbd>analogWrite()</kbd> function to write the values to the RGB pins.</p>
<p>At the beginning of this chapter, we explained that an RGB LED worked by adjusting the intensity of each of the three RGB LEDs that are inside of the RGB LED. If we write the value of <kbd>255</kbd> to a common cathode LED, then the LED will be at its brightest. For a common anode LED, we will need to write a value of 0 to make the LED its brightest. That is why we subtracted the value of each parameter by <kbd>255</kbd> if the <kbd>COMMON_ANODE</kbd> macro is defined.</p>
<p>In the <kbd>loop()</kbd> function, we loop through a couple colors to demonstrate how the LED displays different colors. The following shows the code for the <kbd>loop()</kbd> function:</p>
<pre>void loop() {
  setColor(255, 0, 0); // Red
  delay(1000);
  setColor(0, 255, 0); // Green
  delay(1000);
  setColor(0, 0, 255); // Blue
  delay(1000);
  setColor(255, 255, 255); // White
  delay(1000);
  setColor(255, 0, 255); // Purple
  delay(1000);
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the <kbd>loop()</kbd> function, we call the <kbd>setColor()</kbd> function five times to change the LED's color. The colors that we display are red, green, blue, white and purple. Each time the color changes there will be a one-second pause before the next color is displayed. The pause is from the <kbd>delay()</kbd> function.</p>
<p>How we display the colors in an RGB LED is pretty similar to how we light a normal LED except that we define the light intensity (brightness) for the three colors. Now let's look at the code for the NeoPixel shield.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NeoPixel shield</h1>
                
            
            
                
<p>Before we begin coding, we will need to install the <strong>Adafruit NeoPixel</strong> library. The following screenshot shows the library that should be installed by the library manager. If you do not remember the steps to install a library, refer back to <a href="4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml" target="_blank">Chapter 9</a>, <em>Environment Sensors</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/be910d93-d7d8-46d7-9f51-78daf098172e.png" style="width:59.25em;height:37.75em;"/></p>
<p> </p>
<p>Sensors where we install the library for the DHT11 temperature and humidity sensor.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once the library is installed, we will need to include it by putting the following line at the top of our code:</p>
<pre>#include &lt;Adafruit_NeoPixel.h&gt;</pre>
<p>When we use the Adafruit NeoPixel library, we need to tell it what pin the NeoPixels are connected to and how many NeoPixels are attached. Therefore, we will define macros that contain these values:</p>
<pre>#define SHIELD_PIN 13
#define MAX_PIXELS 40 </pre>
<p>According to the datasheet for the Keyestudio shield, the shield is connected to pin 13 on the Arduino, and the shield contains 40 NeoPixels; therefore, we define those values in the macros. We will now use these values to initiate an instance of the <kbd>Adafruit_NeoPixel</kbd> class as shown in the following code:</p>
<pre>Adafruit_NeoPixel pixels = Adafruit_NeoPixel(MAX_PIXELS, SHIELD_PIN, NEO_GRB + NEO_KHZ800);</pre>
<p>The first parameter is the number of pixels in the shield and the second parameter is the pin that the NeoPixels are connected to. The last parameter is the pixel type flag. The values shown in this example are by far the most common. The following are the possible values:</p>
<ul>
<li><kbd>NEO_KHZ800</kbd>: 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)</li>
<li><kbd>NEO_KHZ400</kbd>: 400 KHz (classic v1 (not v2) FLORA pixels, WS2811 drivers)</li>
<li><kbd>NEO_GRB</kbd>: Pixels are wired for GRB bitstream (most NeoPixel products)</li>
<li><kbd>NEO_RGB</kbd>: Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)</li>
</ul>
<p>In this example, we will be turning each pixel, one by one, to a certain color. Therefore, we will need a global variable to point to the pixel we are on and another global variable to define what color to use. We will be using two colors in this example and swap between the two. The following code defines this global variable:</p>
<pre>int num = 0;
boolean color = 0;</pre>
<p>In the <kbd>setup()</kbd> function, we will need to initiate the NeoPixels. The following code shows the <kbd>setup()</kbd> function with the code to initiate the NeoPixels:</p>
<pre>void setup() {
  pixels.begin();
  pixels.show();
  pixels.setBrightness(50);
}</pre>
<p class="mce-root"/>
<p>The <kbd>begin()</kbd> function prepares the data pin, on the Arduino, for output to the NeoPixels. The <kbd>show()</kbd> function pushes the data out to the NeoPixels and isn't absolutely necessary here; I find that it is good practice to include the function anytime we write anything to the NeoPixels for thoroughness. The third function controls the brightness of the pixels. I usually set this to 50% because the NeoPixels are very bright.</p>
<p>Now let's look at the <kbd>loop()</kbd> function that will set each pixel to a color one by one.</p>
<pre>void loop() { 
  num++; 
  if (num &gt; (MAX_PIXELS -1)) { 
    num = 0; 
    color = !color; 
  } 
  if (color) { 
    pixels.setPixelColor(num, 170, 255, 10); 
  } else { 
    pixels.setPixelColor(num, 10, 255, 170); 
  } 
  pixels.show(); 
  delay(500); 
}</pre>
<p>In the <kbd>loop()</kbd> function, we start off by increasing the <kbd>num</kbd> variable by one and then checking to see whether we have reached the last pixel. If we have reached the last pixel, we set the <kbd>num</kbd> variable back to zero and swap the <kbd>color</kbd> variable. In the line <kbd>color = !color</kbd>, the <kbd>!</kbd> operator is the NOT operator, which causes the <kbd>color</kbd> variable to switch between true and false. This works because the NOT operator returns the opposite of the current value of the <kbd>color</kbd> variable. Therefore if, as an example, the <kbd>color</kbd> variable was currently false, then the <kbd>!color</kbd> operation would return true.</p>
<p>We then use the <kbd>setPixelColor()</kbd> function to set the current pixel to one of two colors depending on whether the <kbd>color</kbd> variable is true or false. The <kbd>setPixelColor()</kbd> function comes in two versions. The version that we see here uses the first parameter as the pixel number that we are setting and then the next three numbers define the intensity of the red, green and blue colors that make up the color we want. If we were using an RGBW NeoPixel, we would also need to define the white color. Therefore, this function would add an additional parameter like this:</p>
<pre> setPixelColor(n, red, green, blue, white);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The second way to call the <kbd>setPixelColor()</kbd> function is to pass two arguments where the first one is the pixel number and the second is a 32-bit number that combines the red, green and blue values. This version of the function looks like this:</p>
<pre>setPixelColor(n, color);</pre>
<p>The color value can range from 0 to 16,777,216.</p>
<p>After we set the pixel's color, we then call the <kbd>show()</kbd> function to push the values out to the pixels and then use the delay function to put in a half-second pause in the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the project</h1>
                
            
            
                
<p>If we run the sketch for the RBG LED, we would see the LED slowly cycle between the five colors. The code for the NeoPixels will flip the pixels, one by one, between two colors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Challenge</h1>
                
            
            
                
<p>This will be one of the hardest challenges in the book. The Keyestudio NeoPixel shield has eight columns of pixels where each column contains five pixels where the pixels are numbered like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c0bdca92-c921-4780-848e-fd36259f20f3.png" style="width:33.25em;height:8.58em;"/></p>
<p>For the challenge, set each column to a different color and have the colors rotate from left to right across the shield. Here are a couple of hints to get you started. The first is the Adafruit NeoPixel library, which has a function named <kbd>Color()</kbd> that will return the 32-bit color based on the three red, green and blue values. Therefore, you can use the following code to convert an 8-bit number to the 32-bit color.</p>
<pre>uint32_t colorNum(int color) {
  colorPos = 255 - colorPos;
  if(colorPos &lt; 85) {
    return pixels.Color(255 - colorPos * 3, 0, colorPos * 3);
  }
  if(colorPos &lt; 170) {
    colorPos -= 85;
    return pixels.Color(0, colorPos * 3, 255 - colorPos * 3);
  }
  colorPos -= 170;
  return pixels.Color(colorPos * 3, 255 - colorPos * 3, 0);
}</pre>
<p>We could then use the following code, which will set all of the pixels in a column to their color:</p>
<pre>for (int j=0; j&lt;5; j++) {
  int pixNum = (j*8) + i;
  pixels.setPixelColor(pixNum, colorNum((tmpColorMode * 30) &amp; 255));
}</pre>
<p>The <kbd>tmpColorMode</kbd> variable is a number from 1 to 8 that will be used to pick the color for that column. That should give you the basics to start this challenge. The answer is in the downloadable code for the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how RGB LEDs work, how to use them and looked at the differences between a common anode and common cathode RGB LED. We also learned how the WS2812 (NeoPixel) works and how to use it. NeoPixels come in many different form factors and can be used almost anywhere that you need a large number of RGB LEDs.</p>
<p>In the next chapter, we will look at how to use a small buzzer with the Arduino to produce sound.</p>


            

            
        
    </body></html>