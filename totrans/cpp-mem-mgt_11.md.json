["```cpp\n// ...\n// note: not trivially destructible\nstruct NamedThing {\n   const char *name;\n   NamedThing(const char *name) : name{ name } {\n      std::print(\"{} ctor\\n\", name);\n   }\n   ~NamedThing() {\n      std::print(\"{} dtor\\n\", name);\n   }\n};\nstruct Identifier {\n   int value;\n};\n// would not compile\n/*\nvoid g() {\n   [[maybe_unused]] auto p = gcnew<NamedThing>(\"hi\");\n   [[maybe_unused]] auto q = gcnew<NamedThing>(\"there\");\n}\n*/\nvoid g() {\n   [[maybe_unused]] auto p = gcnew<Identifier>(2);\n   [[maybe_unused]] auto q = gcnew<Identifier>(3);\n}\nauto h() {\n   struct X {\n      int m() const { return 123; }\n   };\n   return gcnew<X>();\n}\nauto f() {\n   g();\n   return h();\n}\nint main() {\n   std::print(\"Pre\\n\");\n   std::print(\"{}\\n\", f()->m());\n   std::print(\"Post\\n\");\n}\n```", "```cpp\nPre\n123\nPost\n~GC with 3 objects to deallocate\n```", "```cpp\n#include <vector>\n#include <memory>\n#include <string>\n#include <print>\n#include <type_traits>\nclass GC {\n   std::vector<void*> roots;\n   GC() = default;\n   static auto &get() {\n      static GC gc;\n      return gc;\n   }\n   template <class T, class ... Args>\n      T *add_root(Args &&... args) {\n         // there will be no finalization\n         static_assert(\n            std::is_trivially_destructible_v<T>\n         );\n         return static_cast<T*>(\n            roots.emplace_back(\n               new T(std::forward<Args>(args)...)\n            )\n         );\n      }\n   // provide access privileges to gcnew<T>()\n   template <class T, class ... Args>\n      friend T* gcnew(Args&&...);\npublic:\n   ~GC() {\n      std::print(\"~GC with {} objects to deallocate\",\n                 std::size(roots));\n      for(auto p : roots) std::free(p);\n   }\n   GC(const GC &) = delete;\n   GC& operator=(const GC &) = delete;\n};\ntemplate <class T, class ... Args>\n   T *gcnew(Args &&...args) {\n      return GC::get().add_root<T>(\n         std::forward<Args>(args)...\n      );\nGC::~GC() calls std::free() but invokes no destructor, as this implementation reclaims memory but does not finalize objects.\nThis example shows a way to group memory reclamation as a single block to be executed at the end of a program. In code where there is more available memory than what the program requires, this can lead to a more streamlined program execution, albeit at the cost of a slight slowdown at program termination (of course, if you want to try this, please measure to see whether there are actual benefits for your code base!). It can also help us write analysis tools that examine how memory has been allocated throughout program execution and can be enhanced to collate additional information such as memory block size and alignment: we simply would need to keep pairs – or tuples, depending on the needs – instead of single `void*` objects in the `roots` container to aggregate the desired data.\nOf course, not being able to finalize objects allocated through this mechanism can be a severe limitation, as no non-trivially destructible type can benefit from our efforts. Let’s see how we could add finalization support to our design.\nReclamation and finalization at the end of the program\nOur second implementation will not only free the underlying storage for the objects allocated through our deferred reclamation system but will also finalize them by calling their destructors. To do so, we will need to remember the type of each object that goes through our system. There are, of course, many ways to achieve this, and we will see one of them.\nBy ensuring the finalization of reclaimed objects, we can get rid of the trivially destructible requirement of our previous implementation. We still will not guarantee the order in which objects are finalized, so it’s important that reclaimed objects do not refer to each other during finalization if we are to have sound programs, but that’s a constraint many other popular programming languages also share. This implementation will, however, keep the singleton approach and finalize and then deallocate objects and their underlying storage at the end of program execution.\nAs in the previous section, we will first look at client code. In this case, we will be using (and benefitting from) non-trivially destructible objects and use them to print out information during finalization: this will simplify the task of tracing program execution. Of course, we will also use trivially destructible types (such as `struct X`, local to the `h()` function) as there is no reason not to support these too. Note that, often (but not always), non-trivially destructible types will be RAII types (see [*Chapter 4*](B21071_04.xhtml#_idTextAnchor062)) whose objects need to free resources before their life ends, but we just want a simple example here so doing anything non-trivial such as printing out some value (which is what we are doing with `NamedThing`) will suffice in demonstrating that we handle non-trivially-destructible types correctly.\nWe will use nested function calls to highlight the local aspect of construction and allocation, as well as the non-local aspect of object destruction and deallocation since these will happen at program termination time. Our example code will be as follows:\n\n```", "```cpp\n\n When executed, you should expect the following information to be printed on the screen:\n\n```", "```cpp\n\n As can be seen, the constructors happen when invoked in the source code, but the destructors are called at program termination (after the end of `main()`) as we had announced we would do.\nOn the importance of interfaces\nYou might notice that user code essentially did not change between the non-object-finalizing implementation and this one. The beauty here is that our upgrade, or so to say, is completely achieved in the implementation, leaving the interface stable and, as such, the differences transparent to client code. Being able to change the implementation without impacting interfaces is a sign of low coupling and is a noble objective for one to seek to attain.\nHow did we get from a non-finalizing implementation to a finalizing one? Well, this implementation will also use a singleton named `GC` where “object roots” will be stored. In this case, however, we will store semantically enhanced objects, not just raw addresses (`void*` objects) as we did in the previous implementation.\nWe will achieve this objective through a set of old yet useful tricks:\n\n*   Our `GC` class will not be a generic class, as it would force us to write `GC<T>` instead of just `GC` in our code, and find a way to have a distinct `GC<T>` object for each `T` type. What we want is for a single `GC` object to store the required information for all objects that require deferred reclamation, regardless of type.\n*   In `GC`, instead of storing objects of the `void*` type, we will store objects of the `GC::GcRoot*` type. These objects will not be generic either but will be polymorphic, exposing a `destroy()` service to destroy (call the destructor, then free the underlying storage) objects.\n*   There will be classes that derive from `GC::GcRoot`. We will call such classes `GC::GcNode<T>` and there will be one for each type `T` in a program that is involved in our deferred reclamation mechanism. These are where the type-specific code will be “hidden.”\n*   By keeping `GC::GcRoot*` objects as roots but storing `GC::GcNode<T>*` in practice, we will be able to deallocate and finalize the `T` object appropriately.\n\nThe code for this implementation follows:\n\n```", "```cpp\n\n As can be seen, `GC::GcRoot` is an abstraction that trades in raw pointers (objects of the `void*` type) and contains no type-specific information, per se.\nThe type-specific information is held in derived classes of the `GcNode<T>` type:\n\n```", "```cpp\n\n As we can see, a `GcNode<T>` object can be constructed with any sequence of arguments suitable for type `T`, perfectly forwarding them to the constructor of a `T` object. The actual (raw) pointers are stored in the base class part of the object (the `GcRoot` but the destructor of a `GcNode<T>` invokes `destroy()` on that raw pointer, which casts the `void*` to the appropriate `T*` type before invoking `operator delete()`.\nThrough the `GcRoot` abstraction, a `GC` object is kept apart from type-specific details of the objects it needs to reclaim at a later point. This implementation can be seen as a form of **external polymorphism**, where we use a polymorphic hierarchy “underneath the covers” to implement functionality in such a way as to keep client code unaware.\nGiven what we have written so far, our work is almost done:\n\n*   Lifetime management can be delegated to smart pointers, as the finalization code is found in the destructor of `GcNode<T>` objects. Here, we will be using `std::unique_ptr<GcRoot>` objects (simple and efficient).\n*   The `add_root()` function will create `GcNode<T>` objects, store them in the `roots` container as pointers to their base class, `GcRoot`, and return the `T*` pointing to the newly constructed object. Thus, it installs lifetime management mechanisms while exposing pointers in ways that look natural to users of `operator new()`.\n\nThat part of the code follows:\n\n```", "```cpp\n\n So, there we have it: a way to create objects at selected points, and destroy and reclaim them all at program termination, with the corresponding upsides and downsides, of course. These tools are useful, but they are also niche tools that you should use (and customize to your needs) if there is indeed a need to do so.\nSo far, we have seen deferred reclamation facilities that terminate (and finalize, depending on the tool) at program termination. We still need a mechanism for reclamation at the end of selected scopes.\nReclamation and finalization at the end of the scope\nOur third and last implementation for this chapter will ensure reclamation and finalization at the end of the scope, but only on demand. By this, we mean that if a user wants to reclaim unused objects that are subject to deferred reclamation at the end of a scope, it will be possible to do so. Objects subject to deferred reclamation that are still considered in use will not be reclaimed, and objects that are not in use will not be reclaimed if the user code does not ask for it. Of course, at program termination, all remaining objects that are subject to deferred reclamation will be claimed, as we want to avoid leaks.\nThis implementation will be more subtle than the previous ones, as we will need to consider (a) whether an object is still being referred to at a given point in program execution and (b) whether there is a need to collect objects that are not being referred to at that time.\nTo get to that point, we will inspire ourselves from `std::shared_ptr`, a type we provided an academic and simplified version of in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096), and will write a `counting_ptr<T>` type that, instead of destroying the pointee when its last client disconnects, will mark it as ready to be reclaimed.\nThe client code for this example follows. Pay attention to the presence of objects of the `scoped_collect` type in some scopes. These represent requests made by client code to reclaim objects not in use anymore at the end of that scope:\n\n```", "```cpp\nPre\nhi ctor\nthere ctor\nhi dtor\n\"there\"\nthere dtor\n123\nPost\n```", "```cpp\n// ...\nstruct scoped_collect {\n   scoped_collect() = default;\n   scoped_collect(const scoped_collect &) = delete;\n   scoped_collect(scoped_collect &&) = delete;\n   scoped_collect&\n      operator=(const scoped_collect &) = delete;\n   scoped_collect &operator=(scoped_collect &&) = delete;\n   ~scoped_collect() {\n      GC::get().collect();\n   }\n};\n// ...\n```", "```cpp\n#include <vector>\n#include <memory>\n#include <string>\n#include <iostream>\n#include <atomic>\n#include <functional>\n#include <utility>\n```", "```cpp\ntemplate <class T>\n   class counting_ptr {\n      using count_type = std::atomic<int>;\n      T *p;\n      count_type *count;\n      std::function<void()> mark;\n   public:\n      template <class M>\n         constexpr counting_ptr(T *p, M mark) try :\n            p{ p }, mark{ mark } {\n               count = new count_type{ 1 };\n         } catch(...) {\n            delete p;\n            throw;\n         }\n      T& operator*() noexcept {\n         return *p;\n      }\n      const T& operator*() const noexcept {\n         return *p;\n      }\n      T* operator->() noexcept {\n         return p;\n      }\n      const T* operator->() const noexcept {\n         return p;\n      }\n      constexpr bool\n         operator==(const counting_ptr &other) const {\n         return p == other.p;\n      }\n      // operator!= can be omitted since C++20\n      constexpr bool\n         operator!=(const counting_ptr &other) const {\n         return !(*this == other);\n      }\n      // we allow comparing counting_ptr<T> objects\n      // to objects of type U* or counting_ptr<U> to\n      // simplify the handling of types in a class\n      // hierarchy\n      template <class U>\n         constexpr bool\n           operator==(const counting_ptr<U> &other) const {\n            return p == &*other;\n         }\n      template <class U>\n         constexpr bool\n           operator!=(const counting_ptr<U> &other) const {\n            return !(*this == other);\n         }\n      template <class U>\n         constexpr bool operator==(const U *q) const {\n            return p == q;\n         }\n      template <class U>\n         constexpr bool operator!=(const U *q) const {\n            return !(*this == q);\n         }\n       // ...\n```", "```cpp\n      // ...\n      void swap(counting_ptr &other) {\n         using std::swap;\n         swap(p, other.p);\n         swap(count, other.count);\n         swap(mark, other.mark);\n      }\n      constexpr operator bool() const noexcept {\n         return p != nullptr;\n      }\n      counting_ptr(counting_ptr &&other) noexcept\n         : p{ std::exchange(other.p, nullptr) },\n           count{ std::exchange(other.count, nullptr) },\n           mark{ other.mark } {\n      }\n      counting_ptr &\n         operator=(counting_ptr &&other) noexcept {\n         counting_ptr{ std::move(other) }.swap(*this);\n         return *this;\n      }\n      counting_ptr(const counting_ptr &other)\n         : p{ other.p }, count{ other.count },\n           mark{ other.mark } {\n         if (count) ++(*count);\n      }\n      counting_ptr &operator=(const counting_ptr &other) {\n         counting_ptr{ other }.swap(*this);\n         return *this;\n      }\n      ~counting_ptr() {\n         if (count) {\n            if ((*count)-- == 1) {\n               mark();\n               delete count;\n            }\n         }\n      }\n   };\nnamespace std {\n   template <class T, class M>\n      void swap(counting_ptr<T> &a, counting_ptr<T> &b) {\n         a.swap(b);\n      }\n}\n// ...\n```", "```cpp\n// ...\nclass GC {\n   class GcRoot {\n      void *p;\n   public:\n      auto get() const noexcept { return p; }\n      GcRoot(void *p) : p{ p } {\n      }\n      GcRoot(const GcRoot&) = delete;\n      GcRoot& operator=(const GcRoot&) = delete;\n      virtual void destroy(void*) const noexcept = 0;\n      virtual ~GcRoot() = default;\n   };\n   template <class T> class GcNode : public GcRoot {\n      void destroy(void *q) const noexcept override {\n         delete static_cast<T*>(q);\n      }\n   public:\n      template <class ... Args>\n         GcNode(Args &&... args)\n            : GcRoot(new T(std::forward<Args>(args)...)) {\n         }\n      ~GcNode() {\n         destroy(get());\n      }\n   };\n   std::vector<\n      std::pair<std::unique_ptr<GcRoot>, bool>\n   > roots;\n   GC() = default;\n   static auto &get() {\n      static GC gc;\n      return gc;\n   }\n```", "```cpp\n   void make_collectable(void *p) {\n      for (auto &[q, coll] : roots)\n         if (static_cast<GcRoot*>(p) == q.get())\n            coll = true;\n   }\n   void collect() {\n      for (auto p = std::begin(roots);\n           p != std::end(roots); ) {\n         if (auto &[ptr, collectible] = *p; collectible) {\n            ptr = nullptr;\n            p = roots.erase(p);\n         } else {\n            ++p;\n         }\n      }\n   }\n   template <class T, class ... Args>\n      auto add_root(Args &&... args) {\n         auto q = static_cast<T*>(roots.emplace_back(\n            std::make_unique<GcNode<T>>(\n               std::forward<Args>(args)...\n            ), false\n         ).first->get());\n         // the marking function is implemented as\n         // a lambda expression that iterates through\n         // the roots, then finds and marks for\n         // reclamation pointer q. It is overly\n         // simplified (linear search) and you are\n         // welcome to do something better!\n         return counting_ptr{\n            q, [&,q]() {\n               for (auto &[p, coll] : roots)\n                  if (static_cast<void*>(q) ==\n                      p.get()->get()) {\n                     coll = true;\n                     return;\n                  }\n            }\n         };\n      }\n   template <class T, class ... Args>\n      friend counting_ptr<T> gcnew(Args&&...);\n   friend struct scoped_collect;\npublic:\n   GC(const GC &) = delete;\n   GC& operator=(const GC &) = delete;\n};\n// ...\ntemplate <class T, class ... Args>\n   counting_ptr<T> gcnew(Args &&... args) {\n      return GC::get().add_root<T>(\n         std::forward<Args>(args)...\n      );\n   }\n// ...\n```", "```cpp\n\n```"]