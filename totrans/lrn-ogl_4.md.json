["```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n gl_Position = projection * view * model * vec4(position, 1.0f);\n}\n```", "```cpp\n#version 330 core\nout vec4 color;\n\nuniform vec3 objectColor;\nuniform vec3 lightColor;\n\nvoid main()\n{\n    color = vec4(lightColor * objectColor, 1.0f);\n}\n```", "```cpp\n#version 330 core\nout vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0f); // Set all 4 vector values to 1.0f\n}\n```", "```cpp\n  Shader lightingShader( \"res/shaders/lighting.vs\",\n  \"res/shaders/lighting.frag\" );\n  Shader lampShader( \"res/shaders/lamp.vs\", \"res/shaders/lamp.frag\" );\n```", "```cpp\n // First, set the container's VAO (and VBO)\n    GLuint VBO, boxVAO;\n    glGenVertexArrays( 1, &boxVAO );\n    glGenBuffers( 1, &VBO );\n```", "```cpp\n// Then, we set the light's VAO (VBO stays the same. After all, the vertices are the same for the light object (also a 3D cube))\n\nGLuint lightVAO;\nglGenVertexArrays( 1, &lightVAO );\nglBindVertexArray( lightVAO );\n\n // We only need to bind to the VBO (to link it with glVertexAttribPointer), no need to fill it; the VBO's data already contains all we need.\n\n glBindBuffer( GL_ARRAY_BUFFER, VBO );\n\n// Set the vertex attributes (only position data for the lamp)\n\nglVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof( GLfloat ), ( GLvoid * )0 );\nglEnableVertexAttribArray( 0 );\nglBindVertexArray( 0 );\n```", "```cpp\nglClearColor( 0.1f, 0.1f, 0.1f, 1.0f  );\n```", "```cpp\nlightingShader.Use( );\nGLint objectColorLoc = glGetUniformLocation( lightingShader.Program, \"objectColor\" );\nGLint lightColorLoc  = glGetUniformLocation( lightingShader.Program, \"lightColor\" );\n```", "```cpp\nglUniform3f( objectColorLoc, 1.0f, 0.5f, 0.31f );\nglUniform3f( lightColorLoc, 1.0f, 0.5f, 1.0f );\n```", "```cpp\n// Create camera transformations\nglm::mat4 view;\nview = camera.GetViewMatrix( );\n\n// Get the uniform locations\nGLint modelLoc = glGetUniformLocation( lightingShader.Program,\"model\");\nGLint viewLoc = glGetUniformLocation( lightingShader.Program,\"view\");\nGLint projLoc = glGetUniformLocation( lightingShader.Program, \"projection\" );\n```", "```cpp\n// Pass the matrices to the shader\nglUniformMatrix4fv( viewLoc, 1, GL_FALSE, glm::value_ptr( view ) );\nglUniformMatrix4fv( projLoc, 1, GL_FALSE, glm::value_ptr( projection ) );\n```", "```cpp\n// Draw the container (using container's vertex attributes)\nglBindVertexArray( boxVAO );\nglm::mat4 model;\nglUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );\nglDrawArrays( GL_TRIANGLES, 0, 36 );\nglBindVertexArray( 0 );\n```", "```cpp\n// Also draw the lamp object, again binding the appropriate shader\nlampShader.Use( );\n\n// Get location objects for the matrices on the lamp shader (these could be different on a different shader)\nmodelLoc = glGetUniformLocation( lampShader.Program, \"model\" );\nviewLoc = glGetUniformLocation( lampShader.Program, \"view\" );\nprojLoc = glGetUniformLocation( lampShader.Program, \"projection\" );\n\n// Set matrices\nglUniformMatrix4fv( viewLoc, 1, GL_FALSE, glm::value_ptr( view ) );\nglUniformMatrix4fv( projLoc, 1, GL_FALSE, glm::value_ptr( projection ) );\nmodel = glm::mat4( );\nmodel = glm::translate( model, lightPos );\nmodel = glm::scale( model, glm::vec3( 0.2f ) ); // Make it a smaller cube\nglUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );\n\n// Draw the light object (using light's vertex attributes)\nglBindVertexArray( lightVAO );\nglDrawArrays( GL_TRIANGLES, 0, 36 );\nglBindVertexArray( 0 );\n```", "```cpp\nglDeleteVertexArrays( 1, &boxVAO );\nglDeleteVertexArrays( 1, &lightVAO );\nglDeleteBuffers( 1, &VBO );\n```", "```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\n\nout vec3 Normal;\nout vec3 FragPos;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n    gl_Position = projection * view *  model * vec4(position,\n    1.0f);\n    FragPos = vec3(model * vec4(position, 1.0f));\n    Normal = mat3(transpose(inverse(model))) * normal;\n}\n```", "```cpp\n#version 330 core\nout vec4 color;\nin vec3 FragPos;\nin vec3 Normal;\n```", "```cpp\nuniform vec3 lightPos;\nuniform vec3 viewPos;\nuniform vec3 lightColor;\nuniform vec3 objectColor;\n```", "```cpp\nvoid main()\n{\n // Ambient\n float ambientStrength = 0.1f;\n vec3 ambient = ambientStrength * lightColor;\n```", "```cpp\n// Diffuse\n vec3 norm = normalize(Normal);\n vec3 lightDir = normalize(lightPos - FragPos);\n float diff = max(dot(norm, lightDir), 0.0);\n vec3 diffuse = diff * lightColor;\n```", "```cpp\n     // Specular \n     float specularStrength = 0.5f;\n     vec3 viewDir = normalize(viewPos - FragPos);\n     vec3 reflectDir = reflect(-lightDir, norm);\n     float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);\n     vec3 specular = specularStrength * spec * lightColor;\n\n     vec3 result = (ambient + diffuse + specular) * objectColor;\n     color = vec4(result, 1.0f);\n}\n```", "```cpp\nglm::vec3 GetPosition ()\n{\n    return this ->position\n}\n```", "```cpp\n     //Position             //Normal    \n     -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, -1.0f,\n      0.5f, -0.5f, -0.5f,   0.0f, 0.0f, -1.0f,\n      0.5f, 0.5f, -0.5f,    0.0f, 0.0f, -1.0f,\n      0.5f, 0.5f, -0.5f,    0.0f, 0.0f, -1.0f,\n     -0.5f, 0.5f, -0.5f,    0.0f, 0.0f, -1.0f,\n     -0.5f, -0.5f, -0.5f,   0.0f, 0.0f, -1.0f,\n```", "```cpp\n GLuint VBO, containerVAO;\n glGenVertexArrays( 1, &containerVAO );\n glGenBuffers( 1, &VBO );\n\n glBindBuffer( GL_ARRAY_BUFFER, VBO );\n glBufferData( GL_ARRAY_BUFFER, sizeof( vertices ), vertices, GL_STATIC_DRAW );\n\n glBindVertexArray( containerVAO );\n```", "```cpp\n// Position attribute\n glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof( GLfloat ), ( GLvoid * )0 );\n glEnableVertexAttribArray( 0 );\n\n // Normal attribute\n glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 1 );\n glBindVertexArray( 0 );   \n```", "```cpp\nlightingShader.Use( );\n GLint objectColorLoc = glGetUniformLocation( lightingShader.Program, \"objectColor\" );\n GLint lightColorLoc = glGetUniformLocation( lightingShader.Program, \"lightColor\" );\n GLint lightPosLoc = glGetUniformLocation( lightingShader.Program, \"lightPos\" );\n GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, \"viewPos\" );\n glUniform3f( objectColorLoc, 1.0f, 0.5f, 0.31f );\n glUniform3f( lightColorLoc, 1.0f, 1.0f, 1.0f );\n glUniform3f( lightPosLoc, lightPos.x, lightPos.y, lightPos.z );\n glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z )\n```", "```cpp\nlightPos.x -= 0.01f\nlightPos.z -= 0.01f\n```", "```cpp\nstruct Material\n{\n vec3 ambient;\n vec3 diffuse;\n vec3 specular;\n float shininess;\n};\n```", "```cpp\nstruct Light\n{\n vec3 position;\n\n vec3 ambient;\n vec3 diffuse;\n vec3 specular;\n};\n```", "```cpp\nuniform vec3 viewPos;\nuniform Material material;\nuniform Light light;\n```", "```cpp\nvec3 lightDir = normalize(light.position - FragPos);\n```", "```cpp\nvoid main()\n{\n // Ambient\n vec3 ambient = light.ambient * material.ambient;\n\n // Diffuse\n vec3 norm = normalize(Normal);\n vec3 lightDir = normalize(light.position - FragPos);\n float diff = max(dot(norm, lightDir), 0.0);\n vec3 diffuse = light.diffuse * (diff * material.diffuse);\n\n // Specular\n vec3 viewDir = normalize(viewPos - FragPos);\n vec3 reflectDir = reflect(-lightDir, norm);\n float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n vec3 specular = light.specular * (spec * material.specular);\n\n vec3 result = ambient + diffuse + specular;\n color = vec4(result, 1.0f);\n}\n```", "```cpp\n// Set lights properties\n glm::vec3 lightColor;\n lightColor.r = sin( glfwGetTime( ) * 2.0f );\n lightColor.g = sin( glfwGetTime( ) * 0.7f );\n lightColor.b = sin( glfwGetTime( ) * 1.3f );\n```", "```cpp\nglm::vec3 diffuseColor = lightColor * glm::vec3( 0.5f ); // Decrease the influence\nglm::vec3 ambientColor = diffuseColor * glm::vec3( 0.2f ); // Low influence\nglUniform3f( glGetUniformLocation( lightingShader.Program, \"light.ambient\" ), ambientColor.r, ambientColor.g, ambientColor.b );\nglUniform3f( glGetUniformLocation( lightingShader.Program, \"light.diffuse\" ), diffuseColor.r, diffuseColor.g, diffuseColor.b);\nglUniform3f( glGetUniformLocation( lightingShader.Program, \"light.specular\" ), 1.0f, 1.0f, 1.0f );\n```", "```cpp\n// Set material properties\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"material.ambient\" ), 1.0f, 0.5f, 0.31f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"material.diffuse\"), 1.0f, 0.5f, 0.31f );\n glUniform3f(glGetUniformLocation( lightingShader.Program, \"material.specular\" ), 0.5f, 0.5f, 0.5f ); // Specular doesn't have full effect on this object's material\n glUniform1f(glGetUniformLocation( lightingShader.Program, \"material.shininess\" ), 32.0f );\n```", "```cpp\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoords; \nout vec3 Normal;\nout vec3 FragPos;\nout vec2 TexCoords; \nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main() \n{\n     gl_Position = projection * view * model * vec4(position,\n     1.0f);\n     FragPos = vec3(model * vec4(position, 1.0f));\n     Normal = mat3(transpose(inverse(model))) * normal;\n     TexCoords = texCoords;\n}\n```", "```cpp\nstruct Material\n{\n     sampler2D diffuse;\n     sampler2D specular;\n     float shininess;\n};  \n```", "```cpp\nstruct Light\n{\n     vec3 position;\n\n     vec3 ambient;\n     vec3 diffuse;\n     vec3 specular;\n};\n\nin vec3 FragPos;\nin vec3 Normal;\nin vec2 TexCoords; out vec4 color;\n\nuniform vec3 viewPos;\nuniform Material material;\nuniform Light light;\n```", "```cpp\nvoid main()\n{\n     // Ambient\n     vec3 ambient = light.ambient * vec3(texture(material.diffuse,\n    TexCoords));\n\n     // Diffuse\n     vec3 norm = normalize(Normal);\n     vec3 lightDir = normalize(light.position - FragPos);\n     float diff = max(dot(norm, lightDir), 0.0);\n     vec3 diffuse = light.diffuse * diff *\n     vec3(texture(material.diffuse, TexCoords));\n\n     // Specular\n     vec3 viewDir = normalize(viewPos - FragPos);\n     vec3 reflectDir = reflect(-lightDir, norm);\n     float spec = pow(max(dot(viewDir, reflectDir), 0.0),\n     material.shininess);\n     vec3 specular = light.specular * spec * \n     vec3(texture(material.specular, TexCoords));\n\n     color = vec4(ambient + diffuse + specular, 1.0f);\n}\n```", "```cpp\n glBindVertexArray( containerVAO );\n glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(\n GLfloat ), ( GLvoid * )0 );\n glEnableVertexAttribArray( 0 );\n glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(\n GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 1 );\n glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(\n GLfloat ), ( GLvoid * )( 6 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 2 );\n```", "```cpp\n// Load textures\n GLuint diffuseMap, specularMap;\n glGenTextures( 1, &diffuseMap );\n glGenTextures( 1, &specularMap );\n```", "```cpp\nint textureWidth, textureHeight;\nunsigned char *image;\n```", "```cpp\n // Diffuse map\n image = SOIL_load_image( \"res/images/container2.png\", &textureWidth, &textureHeight, 0, SOIL_LOAD_RGB );\n glBindTexture( GL_TEXTURE_2D, diffuseMap );\n glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image );\n glGenerateMipmap( GL_TEXTURE_2D );\n SOIL_free_image_data( image );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST_MIPMAP_NEAREST );\n```", "```cpp\n// Specular map\n image = SOIL_load_image( \"res/images/container2_specular.png\", &textureWidth, &textureHeight, 0, SOIL_LOAD_RGB );\n glBindTexture( GL_TEXTURE_2D, specularMap );\n glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, image );\n glGenerateMipmap( GL_TEXTURE_2D );\n SOIL_free_image_data( image );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );\n glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST_MIPMAP_NEAREST );\n glBindTexture( GL_TEXTURE_2D, 0 ); \n```", "```cpp\n// Set texture units\n lightingShader.Use( );\n glUniform1i( glGetUniformLocation( lightingShader.Program, \"material.diffuse\" ), 0 );\n glUniform1i( glGetUniformLocation( lightingShader.Program, \"material.specular\" ), 1 );\n```", "```cpp\n // Set lights properties\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"light.ambient\" ), 0.2f, 0.2f, 0.2f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"light.diffuse\" ), 0.5f, 0.5f, 0.5f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"light.specular\" ), 1.0f, 1.0f, 1.0f );\n```", "```cpp\n // Set material properties\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"material.shininess\"), 32.0f );\n```", "```cpp\n// Bind diffuse map\n    glActiveTexture( GL_TEXTURE0 );\n    glBindTexture( GL_TEXTURE_2D, diffuseMap );\n```", "```cpp\n// Bind specular map\n     glActiveTexture( GL_TEXTURE1 );\n     glBindTexture( GL_TEXTURE_2D, specularMap ); \n```"]