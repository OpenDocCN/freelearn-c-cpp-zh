<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-291"><a id="_idTextAnchor829"/>19</h1>
<h1 id="_idParaDest-292"><a id="_idTextAnchor830"/>Using the Singleton Pattern</h1>
<p><a id="_idTextAnchor831"/>This chapter will continue our goal to expand your C++ programming skills beyond core OOP concepts, with the objective of empowering you to solve recurring types of coding conundrums utilizing core design patterns. Utilizing design patterns in coding solutions can not only provide refined solutions but also contribute to easier code maintenance and provide potential opportunities for code reuse.</p>
<p>The next core design pattern that we will learn how to implement effectively in C++ is the <strong class="bold">Singleton pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the Singleton pattern and how it contributes to OOP</li>
<li>Implementing the Singleton pattern in C++ (with simple techniques versus a paired-class approach), and using a registry to allow many classes to utilize the Singleton pattern</li>
</ul>
<p>By the end of this chapter, you will understand the Singleton pattern and how it can be used to ensure that only a single instance of a given type can exist. Adding an additional core design pattern to your knowledge set will further augment your programming skills to help you become a more valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the Singleton pattern.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor832"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter19">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter19</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter19</strong> in a file named <strong class="source-inline">Chp19-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3ThNKe0">https://bit.ly/3ThNKe0</a>.</p>
<h1 id="_idParaDest-294"><a id="_idTextAnchor833"/><a id="_idTextAnchor834"/><a id="_idTextAnchor835"/>Understanding the Singleton pattern</h1>
<p>The Singleton pattern is a creational design pattern that guarantees only one instance will exist for a class <a id="_idIndexMarker1201"/>embracing this idiom; two or more instances of <a id="_idIndexMarker1202"/>the type may simply not exist simultaneously. A class embracing this pattern will be known as a <strong class="bold">Singleton</strong>.</p>
<p>A Singleton can be implemented using static data members and static methods. This means that a Singleton will have a global point of access to the instance at hand. This ramification initially seems dangerous; introducing global state information into the code is one criticism that has led the Singleton to sometimes be considered an anti-pattern. However, with the appropriate use of access regions for the static data members defining the Singleton, we can insist that access to the Singleton (other than initialization) only uses the appropriate static methods of the class at hand (and alleviate this potential pattern concern).</p>
<p>Another criticism of the pattern is that it is not thread-safe. There may be race conditions to enter the segment of code where the Singleton instance is created. Without guaranteeing mutual exclusivity to that critical region of code, the Singleton pattern will break, allowing multiple such instances. As such, if multithreaded programming is employed, so must be proper locking mechanisms to protect the critical region of code where the Singleton is instantiated. A Singleton (implemented using static memory) is shared memory between threads in the same process; at times, Singleton can be criticized for monopolizing resources.</p>
<p>The Singleton pattern can utilize several techniques for implementation. Each manner of implementation inevitably will have benefits and drawbacks. We will use a pair of related classes, <strong class="source-inline">Singleton</strong> and <strong class="source-inline">SingletonDestroyer</strong>, to robustly fulfill the pattern. Whereas there are more simple, straightforward implementations (two of which we will briefly review), the simplest techniques leave the possibility that the Singleton will not be adequately destructed. Recall that a destructor may include important and necessary activities.</p>
<p>Singletons tend to be long-lived; it is, therefore, appropriate for a Singleton to be destructed just before the application terminates. Many Clients may have pointers to a Singleton, so no single Client should delete the Singleton. We will see that a <strong class="source-inline">Singleton</strong> will be <em class="italic">self-created</em>, so it should ideally be <em class="italic">self-destructed</em> (that is, with the help of its <strong class="source-inline">SingletonDestroyer</strong>). As such, the paired-class approach, though not as simple, will <a id="_idIndexMarker1203"/>ensure proper <strong class="source-inline">Singleton</strong> destruction. Note that our implementation will also allow the Singleton to be directly deleted; this is rare, but our code will also handle this situatio<a id="_idTextAnchor836"/>n.</p>
<p>The Singleton pattern with the paired-class implementation will include the following:</p>
<ul>
<li>A <strong class="bold">Singleton</strong> class, which <a id="_idIndexMarker1204"/>represents the core mechanics needed to implement the concept of a Singleton.</li>
<li>A <strong class="bold">SingletonDestroyer</strong> class, which will serve as a helper class to <strong class="source-inline">Singleton</strong>, ensuring <a id="_idIndexMarker1205"/>that a given Singleton is properly destructed.</li>
<li>A class derived from <strong class="source-inline">Singleton</strong> represents a class that we want to ensure can only create a single <a id="_idIndexMarker1206"/>instance of its type at a given time. This will be our <strong class="bold">Target</strong> class.</li>
<li>Optionally, the Target class may be both derived from <strong class="source-inline">Singleton</strong> and another class, which may represent existing functionality that we would like to specialize in or simply encompass (that is, <em class="italic">mix-in</em>). In this case, we will multiply inherit from an application-specific class and the Singleton class.</li>
<li>Optional <strong class="bold">Client</strong> classes, which will interact with the Target class(es) to fully define the <a id="_idIndexMarker1207"/>application at hand.</li>
<li>Alternatively, the Singleton may also be implemented within a Target class, bundling the class functionalities together in a single class.</li>
<li>A true Singleton pattern can be expanded to allow for multiple (discrete), but not an undetermined number of instances to be made. This is rare. </li>
</ul>
<p>We will focus on a traditional Singleton pattern that ensures only a single instance of a class embracing this pattern will exist at a given time.</p>
<p>Let’s move forward <a id="_idIndexMarker1208"/>to first examine two simple implementations, then our preferred paired-class implementation of the Singleton pattern.</p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor837"/>Implementing the Singleton pattern</h1>
<p>The Singleton pattern will be used to ensure that a given class may only instantiate a single instance of <a id="_idIndexMarker1209"/>that class. However, a true Singleton pattern will also have expansion capabilities to allow for multiple (but a well-defined number of) instances to be made. This unusual and not well-known caveat of the Singleton pattern is rare. </p>
<p>We will start with two simple Singleton implementations to understand their limitations. We will then progress to the more robust paired-class implementation of the Singleton, with the most common pattern goal of only allowing one Target class instantiation at any give<a id="_idTextAnchor838"/>n time. </p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor839"/>Using a simple implementation</h2>
<p>To implement a very simple Singleton, we will use a straightforward single class specification for the Singleton itself. We will define a class, known <a id="_idIndexMarker1210"/>as <strong class="source-inline">Singleton</strong>, to encapsulate the pattern. We will ensure that our constructor(s) are private so that they cannot be applied more than once. We will also add a static <strong class="source-inline">instance()</strong> method to provide the interface for instantiation of the <strong class="source-inline">Singleton</strong> object. This method will ensure that the private construction occurs exactly once. </p>
<p>Let’s take a look at this straightforward implementation, which can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1.cpp</a></p>
<pre class="source-code">
<strong class="bold">class Singleton</strong>
{
private:
    <strong class="bold">static Singleton *theInstance;</strong>   // initialized below
    <strong class="bold">Singleton();</strong>  <strong class="bold">// private to prevent multiple</strong>
<strong class="bold">                  // instantiation</strong>
public:
    <strong class="bold">static Singleton *in<a id="_idTextAnchor840"/>stance();</strong> // interface for creation
    virtual ~Singleton(); // never called, unless you
};                        // delete Singleton explicitly, 
              <a id="_idTextAnchor841"/>            // which is unlikely and atypical
<strong class="bold">Singleton *Singleton::theInstance = nullptr;</strong> // extern var
                                   // to hold static member
Singleton::Singleton()
{
    cout &lt;&lt; "Constructor" &lt;&lt; endl;
    // Below line of code is not necessary and therefore
    // commented out – see static member init. above
    // theInstance = nullptr;
}
Singleton::~Singleton()  <strong class="bold">// the destructor is not called in</strong>
{                        <strong class="bold">// the typical pattern usage</strong>
    cout &lt;&lt; "Destructor" &lt;&lt; endl;
    if (theInstance != nullptr)  
    {  
       Singleton *temp = theInstance;
       // Remove pointer to Singleton and prevent recursion
       // Remember, theInstance is static, so
       // temp-&gt;theInstance = nullptr; would be duplicative 
       theInstance = nullptr;    
       delete temp;              // delete the Singleton
       // Note, delete theInstance; without temp usage
       // above would be recursive 
    }                 
}
<strong class="bold">Singleton *Singleton::instance()</strong>
{
    if (theInstance == nullptr)
        theInstance = new Singleton();// allocate Singleton
    return theInstance;
}
int main()
{
    // create Singleton
    Singleton *s1 = <strong class="bold">Singleton::instance();</strong> 
    // returns existing Singleton (not a new one)
    Singleton *s2 = <strong class="bold">Singleton::instance();</strong> 
    // note: addresses are the same (same Singleton!)
    cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; endl; 
    return 0;
}                                         </pre>
<p>Notice, in the aforementioned class definition, we include data member <strong class="source-inline">static Singleton *theInstance;</strong> to represent the <strong class="source-inline">Singleton</strong> instance itself. Our constructor is private so it cannot be used multiple times to create multiple <strong class="source-inline">Singleton</strong> instances. Instead, we add a <strong class="source-inline">static Singleton *instance()</strong> method to create the <strong class="source-inline">Singleton</strong>. Within this method, we check whether data member <strong class="source-inline">theInstance</strong> is equal to the <strong class="source-inline">nullptr</strong> and if so, we instantiate the one and only <strong class="source-inline">Singleton</strong> instance. </p>
<p>Outside of the class definition, we see the external variable (and its initialization) to support the memory requirements of the static data member with the definition of <strong class="source-inline">Singleton *Singleton::theInstance = nullptr;</strong>. We also see how, in <strong class="source-inline">main()</strong>, we <a id="_idIndexMarker1211"/>call the static <strong class="source-inline">instance()</strong> method to create a <strong class="source-inline">Singleton</strong> instance using <strong class="source-inline">Singleton::instance()</strong>. The first call to this method will instantiate a <strong class="source-inline">Singleton</strong>, whereas subsequent calls to this method will merely return a pointer to the existing <strong class="source-inline">Singleton</strong> object. We can verify that the instances are the same by printing the address of these objects. </p>
<p>Let’s take a look at the output for this simple program:</p>
<p class="source-code">Constructor</p>
<p class="source-code">0xee1938 0xee1938</p>
<p>In the previously mentioned output, we notice something perhaps unexpected – the destructor is not called! What if the destructor had crucial tasks to<a id="_idTextAnchor842"/> perform? </p>
<h3>Understanding a key deficiency with the simple Singleton implementation</h3>
<p>The destructor is <a id="_idIndexMarker1212"/>not called for our <strong class="source-inline">Singleton</strong> in the simple implementation merely because we have not deleted the dynamically allocated <strong class="source-inline">Singleton</strong> instance through either the <strong class="source-inline">s1</strong> or <strong class="source-inline">s2</strong> identifiers. Why not? There clearly may be multiple pointers (handles) to a <strong class="source-inline">Singleton</strong> object. Deciding which handle should be responsible for removing the <strong class="source-inline">Singleton</strong> is difficult to determine – the handles would minimally need to collaborate or employ reference counting. </p>
<p>Additionally, a <strong class="source-inline">Singleton</strong> tends to exist for the duration of the application. This longevity further suggests that a <strong class="source-inline">Singleton</strong> should be in charge of its own destruction. But how? We soon see an implementation that will allow a <strong class="source-inline">Singleton</strong> to control its own destruction with a helper class. With the simple implementation, however, we might simply throw our hands in the air and suggest that the operating system will reclaim the memory resources when the application terminates – including the heap memory for this small <strong class="source-inline">Singleton</strong>. This is true; however, what if an important task needs to be completed in the destructor? We are running into a limitation within the simple pattern implementation. </p>
<p>If we need the destructor to be called, shall we resort to allowing one of the handles to delete the instance using, for example, <strong class="source-inline">delete s1;</strong>? We have previously reviewed issues regarding whether to allow any one handle to perform the deletion, but let’s now additionally <a id="_idIndexMarker1213"/>examine potential issues within the destructor itself. For example, if our destructor hypothetically only includes <strong class="source-inline">delete theInstance;</strong>, we will have a recursive function call. That is, calling <strong class="source-inline">delete s1;</strong> will invoke the <strong class="source-inline">Singleton</strong> destructor, yet <strong class="source-inline">delete theInstance;</strong> within the destructor body will recognize <strong class="source-inline">theInstance</strong> as a <strong class="source-inline">Singleton</strong> type and again call the <strong class="source-inline">Singleton</strong> destructor – <em class="italic">recursively</em>. </p>
<p>Not to worry! Our destructor, as shown, instead manages recursion by first checking whether <strong class="source-inline">theInstance</strong> data member is not equal to the <strong class="source-inline">nullptr</strong> and then arranges for <strong class="source-inline">temp</strong> to point to <strong class="source-inline">theInstance</strong> to save a handle to the instance we need to delete. We then make the assignment <strong class="source-inline">temp-&gt;theInstance = nullptr;</strong> to prevent recursion when we <strong class="source-inline">delete temp;</strong>. Why? Because <strong class="source-inline">delete temp;</strong> will also call the <strong class="source-inline">Singleton</strong> destructor. Upon this destructor call, <strong class="source-inline">temp</strong> will bind to <strong class="source-inline">this</strong> and will fail the conditional test <strong class="source-inline">if (theInstance != nullptr)</strong> on this first recursive function call, backing us out of continued recursion. Note that our upcoming implementation with a paired-class approach will not have this potential issue.</p>
<p>It is important to note that in an actual application, we would not create a domain-unspecific <strong class="source-inline">Singleton</strong> instance. Rather, we would factor our application into the design to employ the pattern. After all, we want to have a <strong class="source-inline">Singleton</strong> instance of a meaningful class type. To do so using our simple <strong class="source-inline">Singleton</strong> class as a basis, we simply inherit our Target (application-specific) class from <strong class="source-inline">Singleton</strong>. The Target class will also have private constructors – ones that accept the arguments necessary to adequately instantiate the Target class. We will then move the static <strong class="source-inline">instance()</strong> method from <strong class="source-inline">Singleton</strong> to the Target class and ensure that the argument list for <strong class="source-inline">instance()</strong> accepts the necessary arguments to pass to a private Target constructor.</p>
<p>To sum up, our simple implementation has the inherent design flaw that there is no guaranteed proper destruction for the <strong class="source-inline">Singleton</strong> itself. Letting the operating system collect the memory when the application terminates does not call the destructor. Choosing one of <a id="_idIndexMarker1214"/>many handles for the <strong class="source-inline">Singleton</strong> to delete the memory, though possible, requires coordination and also defeats the usual application of the pattern to allow the <strong class="source-inline">Singleton</strong> to live for the duration of the application. </p>
<p>Let us next consider an alternate simple implementation of using a reference to static local memory, rather than a pointer to heap memory, for our Singleton. </p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor843"/>An alternate simple implementation</h2>
<p>As an alternative approach for implementing a very straightforward Singleton, we will modify the <a id="_idIndexMarker1215"/>previous simple class definition. First, we will remove the static pointer data member (which was dynamically allocated within <strong class="source-inline">Singleton::instance()</strong>). Instead of using a static data member within the class, we will use a (non-pointer) static local variable within the <strong class="source-inline">instance()</strong> method to represent the Singleton. </p>
<p>Let’s take a look at this alternative implementation, which can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1b.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1b.cpp</a></p>
<pre class="source-code">
<strong class="bold">class Singleton</strong>
{ 
private:
    string data;
    <strong class="bold">Singleton(string d);</strong> <strong class="bold">// private to prevent multiple</strong> 
public:                  <strong class="bold">// instantiation</strong>
    <strong class="bold">static Singleton &amp;instance(string);</strong> <strong class="bold">// return reference</strong>
    // destructor is called for the static local variable
    // declared in instance() before the application ends
    virtual ~Singleton();   // destructor is now called
    const string &amp;getData() const { return data; }
};
Singleton::Singleton(string d): data(d)  // initialize data
{                                   
    cout &lt;&lt; "Constructor" &lt;&lt; endl;
}
Singleton::~Singleton()
{
    cout &lt;&lt; "Destructor" &lt;&lt; endl;
}
// Note that instance() takes a parameter to reflect how we
// can provide meaningful data to the Singleton constructor
<strong class="bold">Singleton &amp;Singleton::instance(string d)</strong>
{   // create the Singleton with desired constructor; But,
    // we can never replace the Singleton in this approach!
    // Remember, static local vars are ONLY created and 
    // initialized once - guaranteeing one Singleton
    <strong class="bold">static Singleton theInstance(d);</strong>   
    return theInstance;
}
int main()
{   
    // First call, creates/initializes Singleton
    Singleton &amp;s1 = <strong class="bold">Singleton::instance("Unique data");</strong> 
    // Second call returns existing Singleton
    // (the static local declaration is ignored)
    Singleton &amp;s2 = <strong class="bold">Singleton::instance("More data");</strong> 
    cout &lt;&lt; s1.getData() &lt;&lt; " " &lt;&lt; s2.getData() &lt;&lt; endl;
    return 0;
}                                        </pre>
<p>Notice, in the aforementioned Singleton class definition, we no longer include a static data member (nor the external static variable declaration to support this data member) to represent the <strong class="source-inline">Singleton</strong> instance itself. Instead, we have specified the Singleton’s implementation using a static local (non-pointer) variable in the static <strong class="source-inline">instance()</strong> method. Our constructor is private; it can be invoked to initialize this static local variable within a static <a id="_idIndexMarker1216"/>member function of the class. The local variable, as static (and not a pointer with an allocation), will only be created and initialized once. Its space will be set aside when the application starts and the static variable will be initialized upon the first call to <strong class="source-inline">instance()</strong>. Subsequent calls to <strong class="source-inline">instance()</strong> will not yield a replacement of this <strong class="source-inline">Singleton</strong>; the static local variable declaration will be ignored for anything other than the first call to <strong class="source-inline">instance()</strong>. Notice that the return value of <strong class="source-inline">instance()</strong> is now a reference (<strong class="source-inline">&amp;</strong>) to this static local <strong class="source-inline">Singleton</strong> instance. Remember, a static local variable will exist for the entire application (it is not stored on the stack with other local variables).</p>
<p>Also, quite importantly, notice that we have passed data to initialize the Singleton to the <strong class="source-inline">instance()</strong> method via the parameter list; this data is passed along to the <strong class="source-inline">Singleton</strong> constructor. The ability to construct the Singleton with appropriate data is quite important. By implementing the Singleton as a static local (non-pointer) variable in the static <strong class="source-inline">instance()</strong> method, we have the opportunity to construct the Singleton within this method. Note that a static pointer data member defined in the class also has this ability, as the allocation (and hence construction, such as in the previous example) is also made within the <strong class="source-inline">instance()</strong> method. However, a non-pointer static data member of the class would not allow the ability to provide meaningful constructor arguments because the instance would be created and initialized at the start of the program before such meaningful initializers would be available (not actually within the <strong class="source-inline">instance()</strong> method). In the latter case, the Singleton would only be returned from <strong class="source-inline">instance()</strong>, not initialized within it.</p>
<p>Now notice, in <strong class="source-inline">main()</strong>, we call the static <strong class="source-inline">instance()</strong> method to create a <strong class="source-inline">Singleton</strong> instance using <strong class="source-inline">Singleton::instance()</strong>. We create an alias, <strong class="source-inline">s1</strong>, using a reference to the Singleton returned from <strong class="source-inline">Singleton::instance()</strong>. The first call to this method will instantiate the <strong class="source-inline">Singleton</strong>, whereas subsequent calls to this method <a id="_idIndexMarker1217"/>will merely return a reference to the existing <strong class="source-inline">Singleton</strong> object. We can verify that the instance referenced by both aliases (<strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>) is the same object by printing the data contained within the Singleton. </p>
<p>Let’s take a look at the output for this simple program:</p>
<p class="source-code">Constructor</p>
<p class="source-code">Unique data </p>
<p class="source-code">Unique data</p>
<p class="source-code">Destructor</p>
<p>In the previously mentioned output, we notice that the destructor is automatically called to clean up the Singleton before the application ends. We also notice that the attempted creation of the second <strong class="source-inline">Singleton</strong> instance only returns the existing <strong class="source-inline">Singleton</strong>. This is because the static local variable, <strong class="source-inline">theInstance</strong>, is only created and initialized only once per application, no matter how many times <strong class="source-inline">instance()</strong> is invoked (a simple property of static local variables). However, this implementation also has a potential drawback; let’s take a look.</p>
<h3>Understanding a limitation with the alternate simple Singleton implementation</h3>
<p>The implementation <a id="_idIndexMarker1218"/>using a non-pointer static local variable in <strong class="source-inline">instance()</strong> for the Singleton does not give us the flexibility to change the Singleton. In a function, any static local variable has its memory set aside when the application begins; this memory is only initialized once (on the initial call to <strong class="source-inline">instance()</strong>). The implication is that we always have exactly one <strong class="source-inline">Singleton</strong> in the application. The space for this <strong class="source-inline">Singleton</strong> exists even if we never call <strong class="source-inline">instance()</strong> to initialize it.</p>
<p>Additionally, the <strong class="source-inline">Singleton</strong> in this implementation cannot be exchanged for another <strong class="source-inline">Singleton</strong> object due to the nature of how static local variables are implemented. In some applications, we may want one <strong class="source-inline">Singleton</strong> object at a time, yet also desire the ability to change out one instance of a <strong class="source-inline">Singleton</strong> for another. Imagine, for example, that an organization can have exactly one president; however, it is desirable that the (Singleton) president can be replaced every few years with a different (Singleton) president. The initial simple implementation using a pointer allows for this possibility, yet has the potential deficiency that its destructor is never called. Each of the simple implementations has a potential drawback.</p>
<p>Now, because we understand the limitations of the simple Singleton implementations, we will instead move onward to a preferred paired-class implementation of the Singleton <a id="_idIndexMarker1219"/>pattern. The paired-class approach will guarantee proper destruction of our <strong class="source-inline">Singleton</strong>, whether the application allows the <strong class="source-inline">Singleton</strong> to be destructed just prior to the application’s termination through the deliberate class pairing (the most frequently encountered situation), or in the rare case that a <strong class="source-inline">Singleton</strong> is destroyed prematurely in the application. This approach will also allow us to replace a Singleton with another instanc<a id="_idTextAnchor844"/>e of a Singleton. </p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor845"/>Using a more robust paired-class implementation</h2>
<p>To implement the Singleton pattern with a paired-class approach in a nicely encapsulated <a id="_idIndexMarker1220"/>fashion, we <a id="_idIndexMarker1221"/>will define a Singleton class to purely add the core mechanics of creating a single instance. We will name this class <strong class="source-inline">Singleton</strong>. We will then add a helper class to <strong class="source-inline">Singleton</strong>, known as <strong class="source-inline">SingletonDestroyer</strong>, to ensure that our <strong class="source-inline">Singleton</strong> instance always goes through proper destruction before our application terminates. This pair of classes will be related through aggregation and association. More specifically, the <strong class="source-inline">Singleton</strong> will conceptually contain a <strong class="source-inline">SingletonDestroyer</strong> (aggregate), and the <strong class="source-inline">SingletonDestroyer</strong> will hold an association to the (outer) <strong class="source-inline">Singleton</strong> in which it is conceptually embedded. Because the implementation of the <strong class="source-inline">Singleton</strong> and <strong class="source-inline">SingletonDestroyer</strong> is through static data members, the aggregation is conceptual – static members are stored as external variables.</p>
<p>Once these core classes have been defined, we will consider how we may incorporate the Singleton pattern into a class hierarchy with which we have familiarity. Let’s imagine that we would like to implement a class to encapsulate the concept of a <em class="italic">president</em>. Whether it be a president of a nation or the president of a university, it is important that there be only one president at a <a id="_idTextAnchor846"/>given point in time. <strong class="source-inline">President</strong> will be our Target class; <strong class="source-inline">President</strong> is a good candidate to utilize our Singleton pattern. </p>
<p>It is interesting to note that, whereas there will only be one president at a given point in time, it is possible to replace a president. For example, the term of a U.S. president is only four years at a time, with possible re-election for one more term. There may be similar <a id="_idIndexMarker1222"/>conditions for a university <a id="_idIndexMarker1223"/>president. A president may leave prematurely through resignation, impeachment, or death, or may simply leave upon term expiration. Once a sitting president’s existence is removed, it is then acceptable to instantiate a new, Singleton <strong class="source-inline">President</strong>. Hence, our Singleton pattern allows only one Singleton of the Target class at a given point in time.</p>
<p>Reflecting on how we may best implement a <strong class="source-inline">President</strong> class, we realize that a <strong class="source-inline">President</strong> <em class="italic">Is-A</em> <strong class="source-inline">Person</strong> and also needs to <em class="italic">mix-in</em> <strong class="source-inline">Singleton</strong> capabilities. With this in mind, we now have our design. <strong class="source-inline">President</strong> will use multiple inheritances to extend the concept of <strong class="source-inline">Person</strong> and to mix-in the functionality of a <strong class="source-inline">Singleton</strong>. </p>
<p>Certainly, we could have built a <strong class="source-inline">President</strong> class from scratch, but why do so when the <strong class="source-inline">Person</strong> components of the <strong class="source-inline">President</strong> class are represented in a well-tested and available class? Also, certainly, we could embed the <strong class="source-inline">Singleton</strong> class information into our <strong class="source-inline">President</strong> class, rather than inheriting it from a separate <strong class="source-inline">Singleton</strong> class. Absolutely, this is also an option. However, our application will instead encapsulate each piece of the solution. This will enable easier future reuse. Nonetheless, the des<a id="_idTextAnchor847"/>ign choices are many. </p>
<h3>Specifying the Singleton and <a id="_idTextAnchor848"/>the SingletonDestroyer</h3>
<p>Let’s take a look at <a id="_idIndexMarker1224"/>the mechanics of our Singleton pattern, starting <a id="_idIndexMarker1225"/>by examining the <strong class="source-inline">Singleton</strong> and <strong class="source-inline">SingletonDestroyer</strong> class definitions. These classes work cooperatively to implement the Singleton pattern. This example can be found, as a complete program, on our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex2.cpp</a></p>
<pre class="source-code">
class Singleton;    // Necessary forward class declarations
class SingletonDestroyer;
class Person;
class President;
<strong class="bold">class SingletonDestroyer   </strong>
{
private:
    <strong class="bold">Singleton *theSingleton = nullptr;</strong>
public:
    SingletonDestroyer(Singleton *s = nullptr) 
        { theSingleton = s; }
    // disallow copies and assignment
    SingletonDestroyer(const SingletonDestroyer &amp;) 
                                    = delete; 
    SingletonDestroyer &amp;operator=
       (const SingletonDestroyer &amp;) = delete;
    ~SingletonDestroyer(); // dtor shown further below
    void setSingleton(Singleton *s) { theSingleton = s; }
    Singleton *getSingleton() { return theSingleton; }
};</pre>
<p>In the <a id="_idIndexMarker1226"/>aforementioned code segment, we begin with several forward <a id="_idIndexMarker1227"/>class declarations, such as <strong class="source-inline">class Singleton;</strong>. These declarations allow references to be made to these data types before their complete class definitions have been seen by the compiler. </p>
<p>Next, let’s take a look at our <strong class="source-inline">SingletonDestroyer</strong> class definition. This simple class contains a private data member, <strong class="source-inline">Singleton *theSingleton;</strong>, which will be the association <a id="_idIndexMarker1228"/>to the <strong class="source-inline">Singleton</strong> that the <strong class="source-inline">SingletonDestroyer</strong> will <a id="_idIndexMarker1229"/>one day be responsible for deallocating (we will examine the destructor definition for <strong class="source-inline">SingletonDestroyer</strong> shortly). Notice that our destructor is not virtual as this class is not meant to be specialized. </p>
<p>Notice that our constructor has a default value of the <strong class="source-inline">nullptr</strong> specified for the <strong class="source-inline">Singleton *</strong>, which is an input parameter. <strong class="source-inline">SingletonDestroyer</strong> also contains two member functions, <strong class="source-inline">setSingleton()</strong> and <strong class="source-inline">getSingleton()</strong>, which merely provide the means to <em class="italic">set</em> and <em class="italic">get</em> the associated <strong class="source-inline">Singleton</strong> member. </p>
<p>Also notice that both the use of the copy constructor and the overloaded assignment operator in <strong class="source-inline">SingletonDestroyer</strong> have been disallowed using <strong class="source-inline">=delete</strong> in their prototypes. </p>
<p>Before we examine the destructor for this class, let us examine the class definition for <strong class="source-inline">Singleton</strong>:</p>
<pre class="source-code">
// Singleton will be mixed-in using inheritance with a
// Target class. If Singleton is used stand-alone, the data 
// members would be private. Also be sure to add a
// Static *Singleton instance(); 
// method to the public access region.
<strong class="bold">class Singleton</strong>
{
protected:    // protected data members
    <strong class="bold">static Singleton *theInstance;</strong>
    <strong class="bold">static SingletonDestroyer destroyer;</strong>
protected:   // and protected member functions
    Singleton() = default;
    // disallow copies and assignment
    Singleton(const Singleton &amp;) = delete; 
    Singleton &amp;operator=(const Singleton &amp;) = delete; 
    <strong class="bold">friend class SingletonDestroyer;</strong>
    virtual ~Singleton() 
        { cout &lt;&lt; "Singleton destructor" &lt;&lt; endl; }
};</pre>
<p>The aforementioned <strong class="source-inline">Singleton</strong> class contains protected data member <strong class="source-inline">static Singleton *theInstance;</strong>, which will represent (when allocated) a pointer to the one and only instance allocated for a class employing the Singleton idiom. </p>
<p>The protected data member <strong class="source-inline">static SingletonDestroyer destroyer;</strong> represents a conceptual aggregate or contained member. The containment is truly only conceptual, as <a id="_idIndexMarker1230"/>static data members are not stored within the memory <a id="_idIndexMarker1231"/>layout for any instance; they are instead stored in external memory and <em class="italic">name-mangled</em> to appear as part of the class. This (conceptual) aggregate subobject, <strong class="source-inline">destroyer</strong>, will be responsible for the proper destruction of the <strong class="source-inline">Singleton</strong>. Recall that the <strong class="source-inline">SingletonDestroyer</strong> has an association with the one and only <strong class="source-inline">Singleton</strong>, representing the outer object in which the <strong class="source-inline">SingletonDestroyer</strong> is conceptually contained. This association is how the <strong class="source-inline">SingletonDestroyer</strong> will access the Singleton.</p>
<p>When the memory for the external variable that implements the static data member <strong class="source-inline">static SingletonDestroyer destroyer;</strong> goes away at the end of the application, the destructor for <strong class="source-inline">SingletonDestroyer</strong> (the static, conceptual, subobject) will be called. This destructor will <strong class="source-inline">delete theSingleton;</strong>, ensuring that the outer <strong class="source-inline">Singleton</strong> object (which was dynamically allocated), will have the appropriate destructor sequence run on it. Because the destructor in <strong class="source-inline">Singleton</strong> is protected, it is necessary that <strong class="source-inline">SingletonDestroyer</strong> is specified as a friend class of <strong class="source-inline">Singleton</strong>. </p>
<p>Notice that both uses of the copy constructor and the overloaded assignment operator in <strong class="source-inline">Singleton</strong> have been disallowed using <strong class="source-inline">=delete</strong> in their prototypes. </p>
<p>In our implementation, we have assumed that <strong class="source-inline">Singleton</strong> will be mixed-in via inheritance to a derived Target class. It will be in the derived class (the one that intends to use the Singleton idiom), that we provide the required static <strong class="source-inline">instance()</strong> method to create the <strong class="source-inline">Singleton</strong> instance. Note that had <strong class="source-inline">Singleton</strong> been used as a standalone class to create Singletons, we would instead add <strong class="source-inline">static Singleton* instance()</strong> to the public access region of <strong class="source-inline">Singleton</strong>. We would also then move the data <a id="_idIndexMarker1232"/>members from the protected to the private access region. However, having <a id="_idIndexMarker1233"/>an application-unspecific Singleton is only of use to demonstrate the concept. Instead, we will apply the Singleton idiom to an actual type requiring the use of this idiom. </p>
<p>With our <strong class="source-inline">Singleton</strong> and <strong class="source-inline">SingletonDestroyer</strong> class definitions in place, let’s next examine the remaining implementat<a id="_idTextAnchor849"/><a id="_idTextAnchor850"/>i<a id="_idTextAnchor851"/>o<a id="_idTextAnchor852"/>n necessities for these classes:</p>
<pre class="source-code">
// External (name mangled) vars to hold static data mbrs
<strong class="bold">Singleton *Singleton::theInstance = nullptr;</strong>
<strong class="bold">SingletonDestroyer Singleton::destroyer;</strong>
// SingletonDestroyer destructor definition must appear 
// after class definition for Singleton because it is 
// deleting a Singleton (so its destructor can be seen)
// This is not an issue when using header and source files.
SingletonDestroyer::~SingletonDestroyer()
{   
    if (theSingleton == nullptr)
        cout &lt;&lt; "SingletonDestroyer destructor: Singleton 
                 has already been destructed" &lt;&lt; endl;
    else
    {
        cout &lt;&lt; "SingletonDestroyer destructor" &lt;&lt; endl;
        <strong class="bold">delete theSingleton;</strong>   
    }                          
}</pre>
<p>In the aforementioned code fragment, let’s first notice the two external variable definitions that provide the memory to support the two static data members within the <strong class="source-inline">Singleton</strong> class – that is, <strong class="source-inline">Singleton *Singleton::theInstance = nullptr;</strong> and <strong class="source-inline">SingletonDestroyer Singleton::destroyer;</strong>. Recall that static data members are not stored within any instance of their designated class. Rather, they are stored in external variables; these two definitions designate the memory. Notice that the data members are both labeled as <strong class="source-inline">protected</strong>. This means that though we may define their outer storage directly in this manner, we may not access these data members other than through static member functions of <strong class="source-inline">Singleton</strong>. This will give us some peace of mind. Though there is a potential global access point to the static data members, their levied protected access region requires appropriate static methods of the <strong class="source-inline">Singleton</strong> class to be used to properly manipulate these important members.</p>
<p>Next, draw your attention to the destructor for <strong class="source-inline">SingletonDestroyer</strong>. This clever destructor <a id="_idIndexMarker1234"/>first checks whether its association to the <strong class="source-inline">Singleton</strong> for <a id="_idIndexMarker1235"/>which it is responsible is equal to the <strong class="source-inline">nullptr</strong>. This will be rare and will happen in the very unusual situation when a Client releases the Singleton object directly with an explicit <strong class="source-inline">delete</strong>.</p>
<p>The usual destruction scenario in the <strong class="source-inline">SingletonDestroyer</strong> destructor will be the execution of the <strong class="source-inline">else</strong> clause in which the <strong class="source-inline">SingletonDestructor</strong>, as a static object, will be responsible for the deletion, and hence destruction, of its paired <strong class="source-inline">Singleton</strong>. Remember, there will be a contained <strong class="source-inline">SingletonDestroyer</strong> object within the <strong class="source-inline">Singleton</strong>. The memory for this static (conceptual) subobject will not go away until the application has finished. Recall that static memory is not actually part of any instance. However, the static subobject will be destructed just prior to <strong class="source-inline">main()</strong>’s completion. So, when the <strong class="source-inline">SingletonDestroyer</strong> is destructed, its usual case will be to <strong class="source-inline">delete theSingleton;</strong>, which will release its paired Singleton’s memory, allowing the <strong class="source-inline">Singleton</strong> to be properly destructed. </p>
<p>The driving design decision behind the Singleton pattern is that a Singleton is a long-lived object, and its destruction may most often correctly occur near the end of the application. The Singleton is responsible for its own inner Target object creation so that the Singleton should not be deleted (and hence destructed) by a Client. Rather, the preferred mechanism is that the <strong class="source-inline">SingletonDestroyer</strong>, when removed as a static object, deletes its paired <strong class="source-inline">Singleton</strong>. </p>
<p>Nonetheless, occasionally, there are reasonable scenarios for deleting a <strong class="source-inline">Singleton</strong> mid-application. Should a replacement <strong class="source-inline">Singleton</strong> never be created, our <strong class="source-inline">SingletonDestroyer</strong> destructor will still work correctly, identifying that its paired <strong class="source-inline">Singleton</strong> has already been released. However, it is more likely that our <strong class="source-inline">Singleton</strong> will be <a id="_idIndexMarker1236"/>replaced with another <strong class="source-inline">Singleton</strong> instance <a id="_idIndexMarker1237"/>somewhere in the application. Recall our application example where a president may be impeached, resign, or die, but will be replaced by another president. In these cases, it is acceptable for a <strong class="source-inline">Singleton</strong> to be deleted directly and a new <strong class="source-inline">Singleton</strong> is then created. In this case, the <strong class="source-inline">SingletonDestroyer</strong> will now<a id="_idTextAnchor853"/> reference the replacement <strong class="source-inline">Singleton</strong>.</p>
<h3>Der<a id="_idTextAnchor854"/>iving a Target class from Singleton </h3>
<p>Next, let’s take a look at <a id="_idIndexMarker1238"/>how we can create <a id="_idIndexMarker1239"/>our Target class, <strong class="source-inline">President</strong>, from <strong class="source-inline">Singleton</strong>:</p>
<pre class="source-code">
// Assume our Person class is as we are accustomed
// A President Is-A Person and also mixes-in Singleton 
<strong class="bold">class President: public Person, public Singleton</strong>
{
private:
    President(const string &amp;, const string &amp;, char, 
              const string &amp;);
public:
    ~President() override;   // virtual destructor
    // disallow copies and assignment
    President(const President &amp;) <strong class="bold">= delete</strong>;  
    President &amp;operator=(const President &amp;) <strong class="bold">= delete</strong>; 
    <strong class="bold">static President *instance(const string &amp;, </strong>
<strong class="bold">                    const string &amp;, char, const string &amp;);</strong>
};
President::President(const string &amp;fn, const string &amp;ln, 
    char mi, const string &amp;t): Person(fn, ln, mi, t),
                               Singleton()
{
}
President::~President()
{
    <strong class="bold">destroyer.setSingleton(nullptr);</strong>  
    cout &lt;&lt; "President destructor" &lt;&lt; endl;
}
President *President::instance(const string &amp;fn, 
           const string &amp;ln, char mi, const string &amp;t)
{
    if (theInstance == nullptr)
    {
        <strong class="bold">theInstance = new President(fn, ln, mi, t);</strong>
        <strong class="bold">destroyer.setSingleton(theInstance);</strong>
        cout &lt;&lt; "Creating the Singleton" &lt;&lt; endl;
    }
    else
        cout &lt;&lt; "Singleton previously created. 
                 Returning existing singleton" &lt;&lt; endl;
    // below cast is necessary since theInstance is 
    // a Singleton *
    <strong class="bold">return dynamic_cast&lt;President *&gt;(theInstance);  </strong>
}                              </pre>
<p>In our aforementioned Target class, <strong class="source-inline">President</strong>, we merely inherit <strong class="source-inline">President</strong> from <strong class="source-inline">Person</strong> using public inheritance and then multiply inherit <strong class="source-inline">President</strong> from <strong class="source-inline">Singleton</strong> to <em class="italic">mix-in</em> the <strong class="source-inline">Singleton</strong> mechanics.</p>
<p>We place our constructor in the private access region. Static method <strong class="source-inline">instance()</strong> will utilize this constructor internally to create the one and only <strong class="source-inline">Singleton</strong> instance permitted, to <a id="_idIndexMarker1240"/>adhere to the pattern. There is no default <a id="_idIndexMarker1241"/>constructor (unusual) because we do not wish to allow <strong class="source-inline">President</strong> instances to be created without their relevant details. Recall that C++ will not link in a default constructor if we have provided an alternate constructor interface. As we do not desire copies of a <strong class="source-inline">President</strong> or the assignment of a <strong class="source-inline">President</strong> to another potential <strong class="source-inline">President</strong>, we have disallowed copies and assignments using the <strong class="source-inline">=delete</strong> specification in the prototypes for these methods.</p>
<p>Our destructor for <strong class="source-inline">President</strong> is simple, yet crucial. In the case that our <strong class="source-inline">Singleton</strong> object will be deleted explicitly, we prepare by setting <strong class="source-inline">destroyer.setSingleton(nullptr);</strong>. Recall, <strong class="source-inline">President</strong> inherits the protected <strong class="source-inline">static SingletonDestroyer destroyer;</strong> data member. Here, we are setting the destroyer’s associated <strong class="source-inline">Singleton</strong> to the <strong class="source-inline">nullptr</strong>. This line of code in our <strong class="source-inline">President</strong> destructor then enables the destructor in <strong class="source-inline">SingletonDestroyer</strong> to accurately depend on checking for the unusual case of whether its associated <strong class="source-inline">Singleton</strong> has already been deleted before commencing the usual deletion of its <strong class="source-inline">Singleton</strong> counterpart. </p>
<p>Finally, we have defined a static method to provide the creation interface for our <strong class="source-inline">President</strong> as a <strong class="source-inline">Singleton</strong> with <strong class="source-inline">static President *instance(const string &amp;, const string &amp;, char, const string &amp;);</strong>. In the definition of <strong class="source-inline">instance()</strong>, we first check whether the inherited, protected data member <strong class="source-inline">Singleton *theInstance</strong> is equal to the <strong class="source-inline">nullptr</strong>. If we have not yet allocated the <strong class="source-inline">Singleton</strong>, we allocate <strong class="source-inline">President</strong> using the aforementioned private constructor and assign this newly allocated <strong class="source-inline">President</strong> instance to <strong class="source-inline">theInstance</strong>. This is an upcast from a <strong class="source-inline">President *</strong> to a <strong class="source-inline">Singleton *</strong>, which is no problem across a public inheritance boundary. If, however, in the <strong class="source-inline">instance()</strong> method, we find that <strong class="source-inline">theInstance</strong> is not equal to a <strong class="source-inline">nullptr</strong>, we simply return a pointer to the previously allocated <strong class="source-inline">Singleton</strong> object. As users will undoubtedly want to use this object as a <strong class="source-inline">President</strong> to enjoy the inherited <strong class="source-inline">Person</strong> features, we downcast <strong class="source-inline">theInstance</strong> to <strong class="source-inline">President *</strong> for its return value from this method.</p>
<p>Finally, let us <a id="_idIndexMarker1242"/>consider the logistics of a sample Client in <a id="_idIndexMarker1243"/>our overall application. In its simplest form, our Client will contain a <strong class="source-inline">main()</strong> function to drive the appli<a id="_idTextAnchor855"/>cation and showcase our Singleton pattern.</p>
<h3>Bringing the pattern components together within the Client</h3>
<p>Let’s now <a id="_idIndexMarker1244"/>take a look at our <strong class="source-inline">main()</strong> function to see how our pattern is orchestrated:</p>
<pre class="source-code">
int main()
{ 
    // Create a Singleton President
    <strong class="bold">President *p1 = President::instance("John", "Ada<a id="_idTextAnchor856"/>ms",</strong> 
                                        <strong class="bold">'Q', "President");</strong>
    // This second request will fail, returning 
    // the original instance
    <strong class="bold">President *p2 = President::instance("William",</strong>
<strong class="bold">                            "Harrison", 'H', "President");</strong>
    if (p1 == p2)   // Verification there's only one object
     <a id="_idTextAnchor857"/>   cout &lt;&lt; "Same instance (only 1 Singleton)" &lt;&lt; endl;
    p1-&gt;Print();
    <strong class="bold">// SingletonDestroyer will release Singleton at end</strong>
    return 0;
}</pre>
<p>Reviewing our <strong class="source-inline">main()</strong> function in the preceding code, we first allocate a Singleton <strong class="source-inline">Presiden<a id="_idTextAnchor858"/>t</strong> using <strong class="source-inline">President *p1 = President::instance("John"</strong><strong class="source-inline">, "Adams", 'Q', "President");</strong>. We then try to allocate an additional <strong class="source-inline">President</strong> on the next line of code using <strong class="source-inline">*p2</strong>. Because we can only have one <strong class="source-inline">Singleton</strong> (a <strong class="source-inline">President</strong> <em class="italic">mixes-in</em> a <strong class="source-inline">Singleton</strong>), a pointer is returned to our existing <strong class="source-inline">President</strong> and stored in <strong class="source-inline">p2</strong>. We verify that there is only one <strong class="source-inline">Singleton</strong> by comparing <strong class="source-inline">p1 == p2</strong>; the pointers indeed point to the same instance.</p>
<p>Next, we take advantage of using our <strong class="source-inline">President</strong> instance in its intended manner, such as by <a id="_idIndexMarker1245"/>using some of the inherited member functions from <strong class="source-inline">Person</strong>. As an example, we invoke <strong class="source-inline">p1-&gt;Print();</strong>. Certainly, our <strong class="source-inline">President</strong> class could have added specialized functionality that would be appropriate to utilize in our Client as well.</p>
<p>Now, at the end of <strong class="source-inline">main()</strong>, our static object <strong class="source-inline">SingletonDestroyer Singleton::destroyer;</strong> will be appropriately destructed before its memory is reclaimed. As we have seen, the destructor for <strong class="source-inline">SingletonDestroyer</strong> will (most often) issue a <strong class="source-inline">delete</strong> to its associated <strong class="source-inline">Singleton</strong> (which is actually a <strong class="source-inline">President</strong>) using <strong class="source-inline">delete theSingleton;</strong>. This will trigger our <strong class="source-inline">President</strong> destructor, <strong class="source-inline">Singleton</strong> destructor, and <strong class="source-inline">Person</strong> destructor to each be called and executed (going from most specialized to most general subobjects). As our destructor in <strong class="source-inline">Singleton</strong> is virtual, we are guaranteed to start at the proper level for<a id="_idTextAnchor859"/><a id="_idTextAnchor860"/><a id="_idTextAnchor861"/> destruction and to include all destructors.</p>
<p>Let’s<a id="_idTextAnchor862"/> take a look at the output for this program:</p>
<p class="source-code">Creating the Singleton</p>
<p class="source-code">Singleton previously created. Returning existing singleton</p>
<p class="source-code">Same instance (only 1 Singleton)</p>
<p class="source-code">President John Q Adams</p>
<p class="source-code">SingletonDestroyer destructor</p>
<p class="source-code">President destr<a id="_idTextAnchor863"/>uctor</p>
<p class="source-code">Singleton destructor</p>
<p class="source-code">Person destructor</p>
<p>In the preceding output, we can visualize the creation of the Singleton <strong class="source-inline">President</strong>, as well as see that the second <strong class="source-inline">instance()</strong> request for a <strong class="source-inline">President</strong> merely returns the existing <strong class="source-inline">President</strong>. We then see the details of the <strong class="source-inline">President</strong> that were printed. </p>
<p>Most interestingly, we can see the destruction sequence for the <strong class="source-inline">Singleton</strong>, which is driven <a id="_idIndexMarker1246"/>by the static object reclamation of the <strong class="source-inline">SingletonDestroyer</strong>. Through proper deletion of the <strong class="source-inline">Singleton</strong> in the <strong class="source-inline">SingletonDestroyer</strong> destructor, we see that <strong class="source-inline">President</strong>, <strong class="source-inline">Singleton</strong>, and <strong class="source-inline">Person</strong> destructors are each invoked as they<a id="_idTextAnchor864"/> contribute to the complete <strong class="source-inline">President</strong> object.</p>
<h3>Examining explicit Singleton deletion and its impact on SingletonDestroyer destructor </h3>
<p>Let’s take a look at <a id="_idIndexMarker1247"/>an alternate version of the Client with an alternate <strong class="source-inline">main()</strong> function. Here, we <a id="_idIndexMarker1248"/>force deletion of our <strong class="source-inline">Singleton</strong>; this is rare. In this scenario, our <strong class="source-inline">SingletonDestroyer</strong> will not delete its paired <strong class="source-inline">Singleton</strong>. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Program<span id="_idTextAnchor865"/>ming-with-CPP/blob/main/Chapter19/Chp19-Ex3.cpp</a></p>
<pre class="source-code">
int main()
{
    President *p1 = President::instance("John", "Adams", 
                                        'Q', "President");
    President *p2 = President::instance("William",
                             "Harrison", 'H', "President");
    if (p1 == p2)  // Verification there's only one object
        cout &lt;&lt; "Same instance (only 1 Singleton)" &lt;&lt; endl;
    p1-&gt;Print();
    <strong class="bold">delete p1;</strong>  // Delete the Singleton – unusual.
    return 0;   // Upon checking, the SingletonDestroyer 
}   // will no longer need to destroy its paired Singleton</pre>
<p>In the aforementioned <strong class="source-inline">main()</strong> function, notice that we explicitly deallocate our Singleton <strong class="source-inline">President</strong> using <strong class="source-inline">delete p1;</strong>, versus allowing the instance to be reclaimed <a id="_idIndexMarker1249"/>via static <a id="_idIndexMarker1250"/>objection deletion as the program ends. Fortunately, we have included a test in our <strong class="source-inline">SingletonDestroyer</strong> destructor to let us know whether the <strong class="source-inline">SingletonDestroyer</strong> must delete its associated <strong class="source-inline">Singleton</strong> or whether this deletion has already occurred.</p>
<p>Let’s take a look at the revised output to notice the differences from our original <strong class="source-inline">main()</strong>:</p>
<p class="source-code">Creating the Singleton</p>
<p class="source-code">Singleton previously created. Returning existing singleton</p>
<p class="source-code">Same instance (only 1 Singleton)</p>
<p class="source-code">President John Q Adams</p>
<p class="source-code">President destructor</p>
<p class="source-code">Singleton destructor</p>
<p class="source-code">Person destructor</p>
<p class="source-code">SingletonDestroyer destructor: Singleton has already been destructed</p>
<p>In the aforementioned output for our revised Client, we can again visualize the creation of the Singleton <strong class="source-inline">President</strong>, the <em class="italic">unsuccessful</em> creation request of a second <strong class="source-inline">President</strong>, and so on.</p>
<p>Let’s notice the destruction sequence and how it differs from our first Client. Here, the Singleton <strong class="source-inline">President</strong> is explicitly deallocated. We can see the proper deletion of the <strong class="source-inline">President</strong> through <a id="_idIndexMarker1251"/>the call and execution of the destructors in <strong class="source-inline">President</strong>, <strong class="source-inline">Singleton</strong>, and <strong class="source-inline">Person</strong> as each is executed. Now, when the application is about to end and <a id="_idIndexMarker1252"/>the static <strong class="source-inline">SingletonDestroyer</strong> is about to have its memory reclaimed, we can visualize the destructor called on the <strong class="source-inline">SingletonDestroyer</strong>. However, this destructor no longer will delete its associated <strong class="source-inline">Singleton</strong>. </p>
<h3>Understanding design advantages and disadvantages</h3>
<p>An advantage of the <a id="_idIndexMarker1253"/>preceding (paired-class) implementation of the Singleton pattern (irrespective of which <strong class="source-inline">main()</strong> is employed) is that we have guaranteed proper destruction of the <strong class="source-inline">Singleton</strong>. This happens regardless of whether the <strong class="source-inline">Singleton</strong> is long-lived and is deleted in its usual fashion by its associated <strong class="source-inline">SingletonDestroyer</strong>, or whether it is deleted earli<a id="_idTextAnchor866"/>er on in the application directly (a rare scenario).</p>
<p>A disadvantage of this implementation is inherited from the concept of the <strong class="source-inline">Singleton</strong>. That is, there <a id="_idIndexMarker1254"/>can only be one derived class of <strong class="source-inline">Singleton</strong> that incorporates the specific mechanics of the <strong class="source-inline">Singleton</strong> class. Because we have inherited <strong class="source-inline">President</strong> from <strong class="source-inline">Singleton</strong>, we are using the Singleton logistics (namely static data members, stored in external variables) for <strong class="source-inline">President</strong> and <strong class="source-inline">President</strong> alone. Should another class wish to be derived from <strong class="source-inline">Singleton</strong> to embrace this idiom, the internal implementation for the <strong class="source-inline">Singleton</strong> has already been utilized for <strong class="source-inline">President</strong>. Ouch! That does not seem fair. </p>
<p>Not to worry! Our design can be easily expanded to accommodate multiple classes that wish to use our <strong class="source-inline">Singleton</strong> base class. We will augment our design to accommodate multiple <strong class="source-inline">Singleton</strong> objects. We will assume, however, that we still intend to have only one <strong class="source-inline">Singleton</strong> instance per class type.</p>
<p>Another potential concern is thread safety. For example, if multithreaded programming will be utilized, we need to ensure that our <strong class="source-inline">static President::instance()</strong> method acts as though it is atomic, that is, uninterruptible. We can do this through carefully synchronized access to the static method itself. </p>
<p>Let us now take a brief look at how we may expand the Singleton pattern to solve this issue.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor867"/>Using a registry to allow many classes to utilize Singleton</h2>
<p>Let us more <a id="_idIndexMarker1255"/>closely examine a shortcoming with our current Singleton pattern implementation. Currently, there can only be one derived class of <strong class="source-inline">Singleton</strong> that can effectively utilize the <strong class="source-inline">Singleton</strong> class. Why is this? <strong class="source-inline">Singleton</strong> is a class that comes with external variable definitions to support the static data members within the class. The static data member representing <strong class="source-inline">theInstance</strong> (implemented using the external variable <strong class="source-inline">Singleton *Singleton::theInstance</strong>) may only be set to one <strong class="source-inline">Singleton</strong> instance. <em class="italic">Not one per class</em> – there is only one set of external variables creating the memory for the crucial <strong class="source-inline">Singleton</strong> data members of <strong class="source-inline">theInstance</strong> and <strong class="source-inline">destroyer</strong>. Herein lies the problem. </p>
<p>We can, instead, specify a <strong class="source-inline">Registry</strong> class to keep track of the classes applying the Singleton pattern. There are <a id="_idIndexMarker1256"/>many implementations for a <strong class="bold">Registry</strong>, and we will review one such implementation.</p>
<p>In our implementation, the <strong class="source-inline">Registry</strong> will be a class that pairs class names (for classes employing the Singleton pattern) with <strong class="source-inline">Singleton</strong> pointers to the single allowed instance of each registered class. We will still derive each Target class from <strong class="source-inline">Singleton</strong> (and from any other class as deemed appropriate by our design). </p>
<p>Our <strong class="source-inline">instance()</strong> method in each class <em class="italic">derived</em> from <strong class="source-inline">Singleton</strong> will be revised, as follows:</p>
<ul>
<li>Our first check within <strong class="source-inline">instance()</strong> will be to call a <strong class="source-inline">Registry</strong> method (with the derived class’ name) asking whether a <strong class="source-inline">Singleton</strong> had previously been created for that class. If the <strong class="source-inline">Registry</strong> method determines a <strong class="source-inline">Singleton</strong> for the requested derived type has previously been instantiated, a pointer to the existing instance will be returned by <strong class="source-inline">instance()</strong>.</li>
<li>Instead, if the <strong class="source-inline">Registry</strong> provides permission to allocate the <strong class="source-inline">Singleton</strong>, <strong class="source-inline">instance()</strong> will allocate the <strong class="source-inline">Singleton</strong> much as before, setting the inherited protected data member of <strong class="source-inline">theInstance</strong> to the allocated derived <strong class="source-inline">Singleton</strong>. The static <strong class="source-inline">instance()</strong> method will also set the backlink through the inherited protected destroyer data member using <strong class="source-inline">setSingleton()</strong>. We will then pass the newly instantiated derived class instance (which is a <strong class="source-inline">Singleton</strong>) to a <strong class="source-inline">Registry</strong> method to <strong class="source-inline">Store()</strong> the newly allocated <strong class="source-inline">Singleton</strong> within the <strong class="source-inline">Registry</strong>.</li>
</ul>
<p>We notice that four pointers to the same <strong class="source-inline">Singleton</strong> will exist. One will be the specialized pointer of our derived class type, which is returned from our derived class <strong class="source-inline">instance()</strong> method. This pointer will be handed to our Client for application usage. The second <strong class="source-inline">Singleton</strong> pointer will be the pointer stored in our inherited, protected data <a id="_idIndexMarker1257"/>member <strong class="source-inline">theInstance</strong>. The third <strong class="source-inline">Singleton</strong> pointer will be the pointer stored in the <strong class="source-inline">SingletonDestroyer</strong>. The fourth pointer to the <strong class="source-inline">Singleton</strong> will be a pointer that is stored in the <strong class="source-inline">Registry</strong>. No problem, we can have multiple pointers to a <strong class="source-inline">Singleton</strong>. This is one reason the <strong class="source-inline">SingletonDestroyer</strong>, used in its traditional destruction capacity, is so important – it will destroy our one and on<a id="_idTextAnchor868"/>ly <strong class="source-inline">Singleton</strong> for each type at the end of the application.</p>
<p>Our <strong class="source-inline">Registry</strong> will maintain a pair for each class employing the <strong class="source-inline">Singleton</strong> pattern, consisting of a class name and the (eventual) pointer to the specific <strong class="source-inline">Singleton</strong> for the corresponding class. The pointer to each specific <strong class="source-inline">Singleton</strong> instance will be a static data member and will additionally require an external variable to garner its underlying memory. The result is one additional external variable per class embracing the Singleton pattern. </p>
<p>The idea of the <strong class="source-inline">Registry</strong> can be expanded further still if we choose to additionally accommodate the rare use of the Singleton pattern to allow multiple (but a finite set of) <strong class="source-inline">Singleton</strong> objects per class type. This rare existence of controlled, multiple singletons is known as the <strong class="bold">Multiton pattern</strong>. An example of this extended pattern in action might be <a id="_idIndexMarker1258"/>that we chose to model a high school that has a single principal, yet multiple vice-principals. <strong class="source-inline">Principal</strong> would be an expected derived class of <strong class="source-inline">Singleton</strong>, yet the multiple vice-principals would represent a fixed number of instances of the <strong class="source-inline">Vice-Principal</strong> class (derived from <strong class="source-inline">Singleton</strong>). Our registry could be expanded to allow up to <strong class="source-inline">N</strong> registered <strong class="source-inline">Singleton</strong> objects for the <strong class="source-inline">Vice-Principal</strong> type (the multiton).</p>
<p>We have now seen an implementation of the Singleton pattern using a paired-class approach. We have folded the classes and concepts of <strong class="source-inline">Singleton</strong>, <strong class="source-inline">SingetonDestroyer</strong>, Target, and Client into the<a id="_idTextAnchor869"/> framework of classes we are accustomed to seeing, namely <strong class="source-inline">Person</strong>, as well as into a descendant class of our <strong class="source-inline">Singleton</strong> and <strong class="source-inline">Person</strong> (<strong class="source-inline">President</strong>). Let’s now briefly recap what we have learned <a id="_idIndexMarker1259"/>relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-300"><a id="_idTextAnchor870"/>Summary</h1>
<p>In this chapter, we have furthered our goal of becoming better C++ programmers by expanding our programming repertoire by embracing another design pattern. We have explored the Singleton pattern by first employing two simple approaches, and then a paired-class implementation using <strong class="source-inline">Singleton</strong> and <strong class="source-inline">SingletonDestroyer</strong>. Our approach uses inheritance to incorporate our Singleton’s implementation into our Target class. Optionally, we incorporate a useful, existing base class into our Target class using multiple inheritances.</p>
<p>Making use of core design patterns, such as the Singleton pattern, will help you more easily reuse existing, well-tested portions of code in a manner understood by other programmers. By employing familiar design patterns, you will be contributing to well-understood and reusable solutions with avant-garde programming techniques.</p>
<p>We are now ready to continue onward with our final design pattern in <a href="B19087_20.xhtml#_idTextAnchor876"><em class="italic">Chapter 20</em></a>, <em class="italic">Removing Implementation Details Using the pImpl Pattern</em>. Adding more patterns to our arsenal of programming skills makes us more versati<a id="_idTextAnchor871"/>le and valued programmers. Let’s continue onward!</p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor872"/>Questions</h1>
<ol>
<li>Using the Singleton pattern examples found in t<a id="_idTextAnchor873"/><a id="_idTextAnchor874"/>his chapter, create a program to accomplish the following:<ol><li>Implement either an interface for a <strong class="source-inline">President</strong> to <strong class="source-inline">Resign()</strong> or implement the interface to <strong class="source-inline">Impeach()</strong> a <strong class="source-inline">President</strong>. Your method should delete the current Singleton <strong class="source-inline">President</strong> (and remove that link from the <strong class="source-inline">SingletonDestroyer</strong>). <strong class="source-inline">SingletonDestroyer</strong> has a <strong class="source-inline">setSingleton()</strong> m<a id="_idTextAnchor875"/>ethod that may be useful to aid in removing the backlink. </li><li>Noting that the former Singleton <strong class="source-inline">President</strong> has been removed, create a new <strong class="source-inline">President</strong> using <strong class="source-inline">President::instance()</strong>. Verify that the new <strong class="source-inline">President</strong> has been installed.</li><li>(Optional) Create a <strong class="source-inline">Registry</strong> to allow <strong class="source-inline">Singleton</strong> to be used effectively in multiple classes (not mutually exclusively, as is the current implementation). </li></ol></li>
<li>Why can you not label the <strong class="source-inline">static instance()</strong> method as virtual in <strong class="source-inline">Singleton</strong> and override it in <strong class="source-inline">President</strong>?</li>
<li>What other examples can you imagine that might easily incorporate the Singleton pattern? </li>
</ol>
</div>
</div></body></html>