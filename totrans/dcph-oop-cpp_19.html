<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-291"><a id="_idTextAnchor829"/>19</h1>
<h1 id="_idParaDest-292"><a id="_idTextAnchor830"/>Using the Singleton Pattern</h1>
<p><a id="_idTextAnchor831"/>This chapter will continue our goal to expand your C++ programming skills beyond core OOP concepts, with the objective of empowering you to solve recurring types of coding conundrums utilizing core design patterns. Utilizing design patterns in coding solutions can not only provide refined solutions but also contribute to easier code maintenance and provide potential opportunities for code reuse.</p>
<p>The next core design pattern that we will learn how to implement effectively in C++ is the <strong class="bold">Singleton pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the Singleton pattern and how it contributes to OOP</li>
<li>Implementing the Singleton pattern in C++ (with simple techniques versus a paired-class approach), and using a registry to allow many classes to utilize the Singleton pattern</li>
</ul>
<p>By the end of this chapter, you will understand the Singleton pattern and how it can be used to ensure that only a single instance of a given type can exist. Adding an additional core design pattern to your knowledge set will further augment your programming skills to help you become a more valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the Singleton pattern.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor832"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter19">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter19</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter19</code> in a file named <code>Chp19-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3ThNKe0">https://bit.ly/3ThNKe0</a>.</p>
<h1 id="_idParaDest-294"><a id="_idTextAnchor833"/><a id="_idTextAnchor834"/><a id="_idTextAnchor835"/>Understanding the Singleton pattern</h1>
<p>The Singleton pattern is a creational design pattern that guarantees only one instance will exist for a class <a id="_idIndexMarker1201"/>embracing this idiom; two or more instances of <a id="_idIndexMarker1202"/>the type may simply not exist simultaneously. A class embracing this pattern will be known as a <strong class="bold">Singleton</strong>.</p>
<p>A Singleton can be implemented using static data members and static methods. This means that a Singleton will have a global point of access to the instance at hand. This ramification initially seems dangerous; introducing global state information into the code is one criticism that has led the Singleton to sometimes be considered an anti-pattern. However, with the appropriate use of access regions for the static data members defining the Singleton, we can insist that access to the Singleton (other than initialization) only uses the appropriate static methods of the class at hand (and alleviate this potential pattern concern).</p>
<p>Another criticism of the pattern is that it is not thread-safe. There may be race conditions to enter the segment of code where the Singleton instance is created. Without guaranteeing mutual exclusivity to that critical region of code, the Singleton pattern will break, allowing multiple such instances. As such, if multithreaded programming is employed, so must be proper locking mechanisms to protect the critical region of code where the Singleton is instantiated. A Singleton (implemented using static memory) is shared memory between threads in the same process; at times, Singleton can be criticized for monopolizing resources.</p>
<p>The Singleton pattern can utilize several techniques for implementation. Each manner of implementation inevitably will have benefits and drawbacks. We will use a pair of related classes, <code>Singleton</code> and <code>SingletonDestroyer</code>, to robustly fulfill the pattern. Whereas there are more simple, straightforward implementations (two of which we will briefly review), the simplest techniques leave the possibility that the Singleton will not be adequately destructed. Recall that a destructor may include important and necessary activities.</p>
<p>Singletons tend to be long-lived; it is, therefore, appropriate for a Singleton to be destructed just before the application terminates. Many Clients may have pointers to a Singleton, so no single Client should delete the Singleton. We will see that a <code>Singleton</code> will be <em class="italic">self-created</em>, so it should ideally be <em class="italic">self-destructed</em> (that is, with the help of its <code>SingletonDestroyer</code>). As such, the paired-class approach, though not as simple, will <a id="_idIndexMarker1203"/>ensure proper <code>Singleton</code> destruction. Note that our implementation will also allow the Singleton to be directly deleted; this is rare, but our code will also handle this situatio<a id="_idTextAnchor836"/>n.</p>
<p>The Singleton pattern with the paired-class implementation will include the following:</p>
<ul>
<li>A <strong class="bold">Singleton</strong> class, which <a id="_idIndexMarker1204"/>represents the core mechanics needed to implement the concept of a Singleton.</li>
<li>A <code>Singleton</code>, ensuring <a id="_idIndexMarker1205"/>that a given Singleton is properly destructed.</li>
<li>A class derived from <code>Singleton</code> represents a class that we want to ensure can only create a single <a id="_idIndexMarker1206"/>instance of its type at a given time. This will be our <strong class="bold">Target</strong> class.</li>
<li>Optionally, the Target class may be both derived from <code>Singleton</code> and another class, which may represent existing functionality that we would like to specialize in or simply encompass (that is, <em class="italic">mix-in</em>). In this case, we will multiply inherit from an application-specific class and the Singleton class.</li>
<li>Optional <strong class="bold">Client</strong> classes, which will interact with the Target class(es) to fully define the <a id="_idIndexMarker1207"/>application at hand.</li>
<li>Alternatively, the Singleton may also be implemented within a Target class, bundling the class functionalities together in a single class.</li>
<li>A true Singleton pattern can be expanded to allow for multiple (discrete), but not an undetermined number of instances to be made. This is rare. </li>
</ul>
<p>We will focus on a traditional Singleton pattern that ensures only a single instance of a class embracing this pattern will exist at a given time.</p>
<p>Let’s move forward <a id="_idIndexMarker1208"/>to first examine two simple implementations, then our preferred paired-class implementation of the Singleton pattern.</p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor837"/>Implementing the Singleton pattern</h1>
<p>The Singleton pattern will be used to ensure that a given class may only instantiate a single instance of <a id="_idIndexMarker1209"/>that class. However, a true Singleton pattern will also have expansion capabilities to allow for multiple (but a well-defined number of) instances to be made. This unusual and not well-known caveat of the Singleton pattern is rare. </p>
<p>We will start with two simple Singleton implementations to understand their limitations. We will then progress to the more robust paired-class implementation of the Singleton, with the most common pattern goal of only allowing one Target class instantiation at any give<a id="_idTextAnchor838"/>n time. </p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor839"/>Using a simple implementation</h2>
<p>To implement a very simple Singleton, we will use a straightforward single class specification for the Singleton itself. We will define a class, known <a id="_idIndexMarker1210"/>as <code>Singleton</code>, to encapsulate the pattern. We will ensure that our constructor(s) are private so that they cannot be applied more than once. We will also add a static <code>instance()</code> method to provide the interface for instantiation of the <code>Singleton</code> object. This method will ensure that the private construction occurs exactly once. </p>
<p>Let’s take a look at this straightforward implementation, which can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1.cpp</a></p>
<pre class="source-code">
<strong class="bold">class Singleton</strong>
{
private:
    <strong class="bold">static Singleton *theInstance;</strong>   // initialized below
    <strong class="bold">Singleton();</strong>  <strong class="bold">// private to prevent multiple</strong>
<strong class="bold">                  // instantiation</strong>
public:
    <strong class="bold">static Singleton *in<a id="_idTextAnchor840"/>stance();</strong> // interface for creation
    virtual ~Singleton(); // never called, unless you
};                        // delete Singleton explicitly, 
              <a id="_idTextAnchor841"/>            // which is unlikely and atypical
<strong class="bold">Singleton *Singleton::theInstance = nullptr;</strong> // extern var
                                   // to hold static member
Singleton::Singleton()
{
    cout &lt;&lt; "Constructor" &lt;&lt; endl;
    // Below line of code is not necessary and therefore
    // commented out – see static member init. above
    // theInstance = nullptr;
}
Singleton::~Singleton()  <strong class="bold">// the destructor is not called in</strong>
{                        <strong class="bold">// the typical pattern usage</strong>
    cout &lt;&lt; "Destructor" &lt;&lt; endl;
    if (theInstance != nullptr)  
    {  
       Singleton *temp = theInstance;
       // Remove pointer to Singleton and prevent recursion
       // Remember, theInstance is static, so
       // temp-&gt;theInstance = nullptr; would be duplicative 
       theInstance = nullptr;    
       delete temp;              // delete the Singleton
       // Note, delete theInstance; without temp usage
       // above would be recursive 
    }                 
}
<strong class="bold">Singleton *Singleton::instance()</strong>
{
    if (theInstance == nullptr)
        theInstance = new Singleton();// allocate Singleton
    return theInstance;
}
int main()
{
    // create Singleton
    Singleton *s1 = <strong class="bold">Singleton::instance();</strong> 
    // returns existing Singleton (not a new one)
    Singleton *s2 = <strong class="bold">Singleton::instance();</strong> 
    // note: addresses are the same (same Singleton!)
    cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; endl; 
    return 0;
}                                         </pre>
<p>Notice, in the aforementioned class definition, we include data member <code>static Singleton *theInstance;</code> to represent the <code>Singleton</code> instance itself. Our constructor is private so it cannot be used multiple times to create multiple <code>Singleton</code> instances. Instead, we add a <code>static Singleton *instance()</code> method to create the <code>Singleton</code>. Within this method, we check whether data member <code>theInstance</code> is equal to the <code>nullptr</code> and if so, we instantiate the one and only <code>Singleton</code> instance. </p>
<p>Outside of the class definition, we see the external variable (and its initialization) to support the memory requirements of the static data member with the definition of <code>Singleton *Singleton::theInstance = nullptr;</code>. We also see how, in <code>main()</code>, we <a id="_idIndexMarker1211"/>call the static <code>instance()</code> method to create a <code>Singleton</code> instance using <code>Singleton::instance()</code>. The first call to this method will instantiate a <code>Singleton</code>, whereas subsequent calls to this method will merely return a pointer to the existing <code>Singleton</code> object. We can verify that the instances are the same by printing the address of these objects. </p>
<p>Let’s take a look at the output for this simple program:</p>
<pre>Constructor
0xee1938 0xee1938</pre>
<p>In the previously mentioned output, we notice something perhaps unexpected – the destructor is not called! What if the destructor had crucial tasks to<a id="_idTextAnchor842"/> perform? </p>
<h3>Understanding a key deficiency with the simple Singleton implementation</h3>
<p>The destructor is <a id="_idIndexMarker1212"/>not called for our <code>Singleton</code> in the simple implementation merely because we have not deleted the dynamically allocated <code>Singleton</code> instance through either the <code>s1</code> or <code>s2</code> identifiers. Why not? There clearly may be multiple pointers (handles) to a <code>Singleton</code> object. Deciding which handle should be responsible for removing the <code>Singleton</code> is difficult to determine – the handles would minimally need to collaborate or employ reference counting. </p>
<p>Additionally, a <code>Singleton</code> tends to exist for the duration of the application. This longevity further suggests that a <code>Singleton</code> should be in charge of its own destruction. But how? We soon see an implementation that will allow a <code>Singleton</code> to control its own destruction with a helper class. With the simple implementation, however, we might simply throw our hands in the air and suggest that the operating system will reclaim the memory resources when the application terminates – including the heap memory for this small <code>Singleton</code>. This is true; however, what if an important task needs to be completed in the destructor? We are running into a limitation within the simple pattern implementation. </p>
<p>If we need the destructor to be called, shall we resort to allowing one of the handles to delete the instance using, for example, <code>delete s1;</code>? We have previously reviewed issues regarding whether to allow any one handle to perform the deletion, but let’s now additionally <a id="_idIndexMarker1213"/>examine potential issues within the destructor itself. For example, if our destructor hypothetically only includes <code>delete theInstance;</code>, we will have a recursive function call. That is, calling <code>delete s1;</code> will invoke the <code>Singleton</code> destructor, yet <code>delete theInstance;</code> within the destructor body will recognize <code>theInstance</code> as a <code>Singleton</code> type and again call the <code>Singleton</code> destructor – <em class="italic">recursively</em>. </p>
<p>Not to worry! Our destructor, as shown, instead manages recursion by first checking whether <code>theInstance</code> data member is not equal to the <code>nullptr</code> and then arranges for <code>temp</code> to point to <code>theInstance</code> to save a handle to the instance we need to delete. We then make the assignment <code>temp-&gt;theInstance = nullptr;</code> to prevent recursion when we <code>delete temp;</code>. Why? Because <code>delete temp;</code> will also call the <code>Singleton</code> destructor. Upon this destructor call, <code>temp</code> will bind to <code>this</code> and will fail the conditional test <code>if (theInstance != nullptr)</code> on this first recursive function call, backing us out of continued recursion. Note that our upcoming implementation with a paired-class approach will not have this potential issue.</p>
<p>It is important to note that in an actual application, we would not create a domain-unspecific <code>Singleton</code> instance. Rather, we would factor our application into the design to employ the pattern. After all, we want to have a <code>Singleton</code> instance of a meaningful class type. To do so using our simple <code>Singleton</code> class as a basis, we simply inherit our Target (application-specific) class from <code>Singleton</code>. The Target class will also have private constructors – ones that accept the arguments necessary to adequately instantiate the Target class. We will then move the static <code>instance()</code> method from <code>Singleton</code> to the Target class and ensure that the argument list for <code>instance()</code> accepts the necessary arguments to pass to a private Target constructor.</p>
<p>To sum up, our simple implementation has the inherent design flaw that there is no guaranteed proper destruction for the <code>Singleton</code> itself. Letting the operating system collect the memory when the application terminates does not call the destructor. Choosing one of <a id="_idIndexMarker1214"/>many handles for the <code>Singleton</code> to delete the memory, though possible, requires coordination and also defeats the usual application of the pattern to allow the <code>Singleton</code> to live for the duration of the application. </p>
<p>Let us next consider an alternate simple implementation of using a reference to static local memory, rather than a pointer to heap memory, for our Singleton. </p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor843"/>An alternate simple implementation</h2>
<p>As an alternative approach for implementing a very straightforward Singleton, we will modify the <a id="_idIndexMarker1215"/>previous simple class definition. First, we will remove the static pointer data member (which was dynamically allocated within <code>Singleton::instance()</code>). Instead of using a static data member within the class, we will use a (non-pointer) static local variable within the <code>instance()</code> method to represent the Singleton. </p>
<p>Let’s take a look at this alternative implementation, which can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1b.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1b.cpp</a></p>
<pre class="source-code">
<strong class="bold">class Singleton</strong>
{ 
private:
    string data;
    <strong class="bold">Singleton(string d);</strong> <strong class="bold">// private to prevent multiple</strong> 
public:                  <strong class="bold">// instantiation</strong>
    <strong class="bold">static Singleton &amp;instance(string);</strong> <strong class="bold">// return reference</strong>
    // destructor is called for the static local variable
    // declared in instance() before the application ends
    virtual ~Singleton();   // destructor is now called
    const string &amp;getData() const { return data; }
};
Singleton::Singleton(string d): data(d)  // initialize data
{                                   
    cout &lt;&lt; "Constructor" &lt;&lt; endl;
}
Singleton::~Singleton()
{
    cout &lt;&lt; "Destructor" &lt;&lt; endl;
}
// Note that instance() takes a parameter to reflect how we
// can provide meaningful data to the Singleton constructor
<strong class="bold">Singleton &amp;Singleton::instance(string d)</strong>
{   // create the Singleton with desired constructor; But,
    // we can never replace the Singleton in this approach!
    // Remember, static local vars are ONLY created and 
    // initialized once - guaranteeing one Singleton
    <strong class="bold">static Singleton theInstance(d);</strong>   
    return theInstance;
}
int main()
{   
    // First call, creates/initializes Singleton
    Singleton &amp;s1 = <strong class="bold">Singleton::instance("Unique data");</strong> 
    // Second call returns existing Singleton
    // (the static local declaration is ignored)
    Singleton &amp;s2 = <strong class="bold">Singleton::instance("More data");</strong> 
    cout &lt;&lt; s1.getData() &lt;&lt; " " &lt;&lt; s2.getData() &lt;&lt; endl;
    return 0;
}                                        </pre>
<p>Notice, in the aforementioned Singleton class definition, we no longer include a static data member (nor the external static variable declaration to support this data member) to represent the <code>Singleton</code> instance itself. Instead, we have specified the Singleton’s implementation using a static local (non-pointer) variable in the static <code>instance()</code> method. Our constructor is private; it can be invoked to initialize this static local variable within a static <a id="_idIndexMarker1216"/>member function of the class. The local variable, as static (and not a pointer with an allocation), will only be created and initialized once. Its space will be set aside when the application starts and the static variable will be initialized upon the first call to <code>instance()</code>. Subsequent calls to <code>instance()</code> will not yield a replacement of this <code>Singleton</code>; the static local variable declaration will be ignored for anything other than the first call to <code>instance()</code>. Notice that the return value of <code>instance()</code> is now a reference (<code>&amp;</code>) to this static local <code>Singleton</code> instance. Remember, a static local variable will exist for the entire application (it is not stored on the stack with other local variables).</p>
<p>Also, quite importantly, notice that we have passed data to initialize the Singleton to the <code>instance()</code> method via the parameter list; this data is passed along to the <code>Singleton</code> constructor. The ability to construct the Singleton with appropriate data is quite important. By implementing the Singleton as a static local (non-pointer) variable in the static <code>instance()</code> method, we have the opportunity to construct the Singleton within this method. Note that a static pointer data member defined in the class also has this ability, as the allocation (and hence construction, such as in the previous example) is also made within the <code>instance()</code> method. However, a non-pointer static data member of the class would not allow the ability to provide meaningful constructor arguments because the instance would be created and initialized at the start of the program before such meaningful initializers would be available (not actually within the <code>instance()</code> method). In the latter case, the Singleton would only be returned from <code>instance()</code>, not initialized within it.</p>
<p>Now notice, in <code>main()</code>, we call the static <code>instance()</code> method to create a <code>Singleton</code> instance using <code>Singleton::instance()</code>. We create an alias, <code>s1</code>, using a reference to the Singleton returned from <code>Singleton::instance()</code>. The first call to this method will instantiate the <code>Singleton</code>, whereas subsequent calls to this method <a id="_idIndexMarker1217"/>will merely return a reference to the existing <code>Singleton</code> object. We can verify that the instance referenced by both aliases (<code>s1</code> and <code>s2</code>) is the same object by printing the data contained within the Singleton. </p>
<p>Let’s take a look at the output for this simple program:</p>
<pre>Constructor
Unique data 
Unique data
Destructor</pre>
<p>In the previously mentioned output, we notice that the destructor is automatically called to clean up the Singleton before the application ends. We also notice that the attempted creation of the second <code>Singleton</code> instance only returns the existing <code>Singleton</code>. This is because the static local variable, <code>theInstance</code>, is only created and initialized only once per application, no matter how many times <code>instance()</code> is invoked (a simple property of static local variables). However, this implementation also has a potential drawback; let’s take a look.</p>
<h3>Understanding a limitation with the alternate simple Singleton implementation</h3>
<p>The implementation <a id="_idIndexMarker1218"/>using a non-pointer static local variable in <code>instance()</code> for the Singleton does not give us the flexibility to change the Singleton. In a function, any static local variable has its memory set aside when the application begins; this memory is only initialized once (on the initial call to <code>instance()</code>). The implication is that we always have exactly one <code>Singleton</code> in the application. The space for this <code>Singleton</code> exists even if we never call <code>instance()</code> to initialize it.</p>
<p>Additionally, the <code>Singleton</code> in this implementation cannot be exchanged for another <code>Singleton</code> object due to the nature of how static local variables are implemented. In some applications, we may want one <code>Singleton</code> object at a time, yet also desire the ability to change out one instance of a <code>Singleton</code> for another. Imagine, for example, that an organization can have exactly one president; however, it is desirable that the (Singleton) president can be replaced every few years with a different (Singleton) president. The initial simple implementation using a pointer allows for this possibility, yet has the potential deficiency that its destructor is never called. Each of the simple implementations has a potential drawback.</p>
<p>Now, because we understand the limitations of the simple Singleton implementations, we will instead move onward to a preferred paired-class implementation of the Singleton <a id="_idIndexMarker1219"/>pattern. The paired-class approach will guarantee proper destruction of our <code>Singleton</code>, whether the application allows the <code>Singleton</code> to be destructed just prior to the application’s termination through the deliberate class pairing (the most frequently encountered situation), or in the rare case that a <code>Singleton</code> is destroyed prematurely in the application. This approach will also allow us to replace a Singleton with another instanc<a id="_idTextAnchor844"/>e of a Singleton. </p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor845"/>Using a more robust paired-class implementation</h2>
<p>To implement the Singleton pattern with a paired-class approach in a nicely encapsulated <a id="_idIndexMarker1220"/>fashion, we <a id="_idIndexMarker1221"/>will define a Singleton class to purely add the core mechanics of creating a single instance. We will name this class <code>Singleton</code>. We will then add a helper class to <code>Singleton</code>, known as <code>SingletonDestroyer</code>, to ensure that our <code>Singleton</code> instance always goes through proper destruction before our application terminates. This pair of classes will be related through aggregation and association. More specifically, the <code>Singleton</code> will conceptually contain a <code>SingletonDestroyer</code> (aggregate), and the <code>SingletonDestroyer</code> will hold an association to the (outer) <code>Singleton</code> in which it is conceptually embedded. Because the implementation of the <code>Singleton</code> and <code>SingletonDestroyer</code> is through static data members, the aggregation is conceptual – static members are stored as external variables.</p>
<p>Once these core classes have been defined, we will consider how we may incorporate the Singleton pattern into a class hierarchy with which we have familiarity. Let’s imagine that we would like to implement a class to encapsulate the concept of a <em class="italic">president</em>. Whether it be a president of a nation or the president of a university, it is important that there be only one president at a <a id="_idTextAnchor846"/>given point in time. <code>President</code> will be our Target class; <code>President</code> is a good candidate to utilize our Singleton pattern. </p>
<p>It is interesting to note that, whereas there will only be one president at a given point in time, it is possible to replace a president. For example, the term of a U.S. president is only four years at a time, with possible re-election for one more term. There may be similar <a id="_idIndexMarker1222"/>conditions for a university <a id="_idIndexMarker1223"/>president. A president may leave prematurely through resignation, impeachment, or death, or may simply leave upon term expiration. Once a sitting president’s existence is removed, it is then acceptable to instantiate a new, Singleton <code>President</code>. Hence, our Singleton pattern allows only one Singleton of the Target class at a given point in time.</p>
<p>Reflecting on how we may best implement a <code>President</code> class, we realize that a <code>President</code> <em class="italic">Is-A</em> <code>Person</code> and also needs to <em class="italic">mix-in</em> <code>Singleton</code> capabilities. With this in mind, we now have our design. <code>President</code> will use multiple inheritances to extend the concept of <code>Person</code> and to mix-in the functionality of a <code>Singleton</code>. </p>
<p>Certainly, we could have built a <code>President</code> class from scratch, but why do so when the <code>Person</code> components of the <code>President</code> class are represented in a well-tested and available class? Also, certainly, we could embed the <code>Singleton</code> class information into our <code>President</code> class, rather than inheriting it from a separate <code>Singleton</code> class. Absolutely, this is also an option. However, our application will instead encapsulate each piece of the solution. This will enable easier future reuse. Nonetheless, the des<a id="_idTextAnchor847"/>ign choices are many. </p>
<h3>Specifying the Singleton and <a id="_idTextAnchor848"/>the SingletonDestroyer</h3>
<p>Let’s take a look at <a id="_idIndexMarker1224"/>the mechanics of our Singleton pattern, starting <a id="_idIndexMarker1225"/>by examining the <code>Singleton</code> and <code>SingletonDestroyer</code> class definitions. These classes work cooperatively to implement the Singleton pattern. This example can be found, as a complete program, on our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex2.cpp</a></p>
<pre class="source-code">
class Singleton;    // Necessary forward class declarations
class SingletonDestroyer;
class Person;
class President;
<strong class="bold">class SingletonDestroyer   </strong>
{
private:
    <strong class="bold">Singleton *theSingleton = nullptr;</strong>
public:
    SingletonDestroyer(Singleton *s = nullptr) 
        { theSingleton = s; }
    // disallow copies and assignment
    SingletonDestroyer(const SingletonDestroyer &amp;) 
                                    = delete; 
    SingletonDestroyer &amp;operator=
       (const SingletonDestroyer &amp;) = delete;
    ~SingletonDestroyer(); // dtor shown further below
    void setSingleton(Singleton *s) { theSingleton = s; }
    Singleton *getSingleton() { return theSingleton; }
};</pre>
<p>In the <a id="_idIndexMarker1226"/>aforementioned code segment, we begin with several forward <a id="_idIndexMarker1227"/>class declarations, such as <code>class Singleton;</code>. These declarations allow references to be made to these data types before their complete class definitions have been seen by the compiler. </p>
<p>Next, let’s take a look at our <code>SingletonDestroyer</code> class definition. This simple class contains a private data member, <code>Singleton *theSingleton;</code>, which will be the association <a id="_idIndexMarker1228"/>to the <code>Singleton</code> that the <code>SingletonDestroyer</code> will <a id="_idIndexMarker1229"/>one day be responsible for deallocating (we will examine the destructor definition for <code>SingletonDestroyer</code> shortly). Notice that our destructor is not virtual as this class is not meant to be specialized. </p>
<p>Notice that our constructor has a default value of the <code>nullptr</code> specified for the <code>Singleton *</code>, which is an input parameter. <code>SingletonDestroyer</code> also contains two member functions, <code>setSingleton()</code> and <code>getSingleton()</code>, which merely provide the means to <em class="italic">set</em> and <em class="italic">get</em> the associated <code>Singleton</code> member. </p>
<p>Also notice that both the use of the copy constructor and the overloaded assignment operator in <code>SingletonDestroyer</code> have been disallowed using <code>=delete</code> in their prototypes. </p>
<p>Before we examine the destructor for this class, let us examine the class definition for <code>Singleton</code>:</p>
<pre class="source-code">
// Singleton will be mixed-in using inheritance with a
// Target class. If Singleton is used stand-alone, the data 
// members would be private. Also be sure to add a
// Static *Singleton instance(); 
// method to the public access region.
<strong class="bold">class Singleton</strong>
{
protected:    // protected data members
    <strong class="bold">static Singleton *theInstance;</strong>
    <strong class="bold">static SingletonDestroyer destroyer;</strong>
protected:   // and protected member functions
    Singleton() = default;
    // disallow copies and assignment
    Singleton(const Singleton &amp;) = delete; 
    Singleton &amp;operator=(const Singleton &amp;) = delete; 
    <strong class="bold">friend class SingletonDestroyer;</strong>
    virtual ~Singleton() 
        { cout &lt;&lt; "Singleton destructor" &lt;&lt; endl; }
};</pre>
<p>The aforementioned <code>Singleton</code> class contains protected data member <code>static Singleton *theInstance;</code>, which will represent (when allocated) a pointer to the one and only instance allocated for a class employing the Singleton idiom. </p>
<p>The protected data member <code>static SingletonDestroyer destroyer;</code> represents a conceptual aggregate or contained member. The containment is truly only conceptual, as <a id="_idIndexMarker1230"/>static data members are not stored within the memory <a id="_idIndexMarker1231"/>layout for any instance; they are instead stored in external memory and <em class="italic">name-mangled</em> to appear as part of the class. This (conceptual) aggregate subobject, <code>destroyer</code>, will be responsible for the proper destruction of the <code>Singleton</code>. Recall that the <code>SingletonDestroyer</code> has an association with the one and only <code>Singleton</code>, representing the outer object in which the <code>SingletonDestroyer</code> is conceptually contained. This association is how the <code>SingletonDestroyer</code> will access the Singleton.</p>
<p>When the memory for the external variable that implements the static data member <code>static SingletonDestroyer destroyer;</code> goes away at the end of the application, the destructor for <code>SingletonDestroyer</code> (the static, conceptual, subobject) will be called. This destructor will <code>delete theSingleton;</code>, ensuring that the outer <code>Singleton</code> object (which was dynamically allocated), will have the appropriate destructor sequence run on it. Because the destructor in <code>Singleton</code> is protected, it is necessary that <code>SingletonDestroyer</code> is specified as a friend class of <code>Singleton</code>. </p>
<p>Notice that both uses of the copy constructor and the overloaded assignment operator in <code>Singleton</code> have been disallowed using <code>=delete</code> in their prototypes. </p>
<p>In our implementation, we have assumed that <code>Singleton</code> will be mixed-in via inheritance to a derived Target class. It will be in the derived class (the one that intends to use the Singleton idiom), that we provide the required static <code>instance()</code> method to create the <code>Singleton</code> instance. Note that had <code>Singleton</code> been used as a standalone class to create Singletons, we would instead add <code>static Singleton* instance()</code> to the public access region of <code>Singleton</code>. We would also then move the data <a id="_idIndexMarker1232"/>members from the protected to the private access region. However, having <a id="_idIndexMarker1233"/>an application-unspecific Singleton is only of use to demonstrate the concept. Instead, we will apply the Singleton idiom to an actual type requiring the use of this idiom. </p>
<p>With our <code>Singleton</code> and <code>SingletonDestroyer</code> class definitions in place, let’s next examine the remaining implementat<a id="_idTextAnchor849"/><a id="_idTextAnchor850"/>i<a id="_idTextAnchor851"/>o<a id="_idTextAnchor852"/>n necessities for these classes:</p>
<pre class="source-code">
// External (name mangled) vars to hold static data mbrs
<strong class="bold">Singleton *Singleton::theInstance = nullptr;</strong>
<strong class="bold">SingletonDestroyer Singleton::destroyer;</strong>
// SingletonDestroyer destructor definition must appear 
// after class definition for Singleton because it is 
// deleting a Singleton (so its destructor can be seen)
// This is not an issue when using header and source files.
SingletonDestroyer::~SingletonDestroyer()
{   
    if (theSingleton == nullptr)
        cout &lt;&lt; "SingletonDestroyer destructor: Singleton 
                 has already been destructed" &lt;&lt; endl;
    else
    {
        cout &lt;&lt; "SingletonDestroyer destructor" &lt;&lt; endl;
        <strong class="bold">delete theSingleton;</strong>   
    }                          
}</pre>
<p>In the aforementioned code fragment, let’s first notice the two external variable definitions that provide the memory to support the two static data members within the <code>Singleton</code> class – that is, <code>Singleton *Singleton::theInstance = nullptr;</code> and <code>SingletonDestroyer Singleton::destroyer;</code>. Recall that static data members are not stored within any instance of their designated class. Rather, they are stored in external variables; these two definitions designate the memory. Notice that the data members are both labeled as <code>protected</code>. This means that though we may define their outer storage directly in this manner, we may not access these data members other than through static member functions of <code>Singleton</code>. This will give us some peace of mind. Though there is a potential global access point to the static data members, their levied protected access region requires appropriate static methods of the <code>Singleton</code> class to be used to properly manipulate these important members.</p>
<p>Next, draw your attention to the destructor for <code>SingletonDestroyer</code>. This clever destructor <a id="_idIndexMarker1234"/>first checks whether its association to the <code>Singleton</code> for <a id="_idIndexMarker1235"/>which it is responsible is equal to the <code>nullptr</code>. This will be rare and will happen in the very unusual situation when a Client releases the Singleton object directly with an explicit <code>delete</code>.</p>
<p>The usual destruction scenario in the <code>SingletonDestroyer</code> destructor will be the execution of the <code>else</code> clause in which the <code>SingletonDestructor</code>, as a static object, will be responsible for the deletion, and hence destruction, of its paired <code>Singleton</code>. Remember, there will be a contained <code>SingletonDestroyer</code> object within the <code>Singleton</code>. The memory for this static (conceptual) subobject will not go away until the application has finished. Recall that static memory is not actually part of any instance. However, the static subobject will be destructed just prior to <code>main()</code>’s completion. So, when the <code>SingletonDestroyer</code> is destructed, its usual case will be to <code>delete theSingleton;</code>, which will release its paired Singleton’s memory, allowing the <code>Singleton</code> to be properly destructed. </p>
<p>The driving design decision behind the Singleton pattern is that a Singleton is a long-lived object, and its destruction may most often correctly occur near the end of the application. The Singleton is responsible for its own inner Target object creation so that the Singleton should not be deleted (and hence destructed) by a Client. Rather, the preferred mechanism is that the <code>SingletonDestroyer</code>, when removed as a static object, deletes its paired <code>Singleton</code>. </p>
<p>Nonetheless, occasionally, there are reasonable scenarios for deleting a <code>Singleton</code> mid-application. Should a replacement <code>Singleton</code> never be created, our <code>SingletonDestroyer</code> destructor will still work correctly, identifying that its paired <code>Singleton</code> has already been released. However, it is more likely that our <code>Singleton</code> will be <a id="_idIndexMarker1236"/>replaced with another <code>Singleton</code> instance <a id="_idIndexMarker1237"/>somewhere in the application. Recall our application example where a president may be impeached, resign, or die, but will be replaced by another president. In these cases, it is acceptable for a <code>Singleton</code> to be deleted directly and a new <code>Singleton</code> is then created. In this case, the <code>SingletonDestroyer</code> will now<a id="_idTextAnchor853"/> reference the replacement <code>Singleton</code>.</p>
<h3>Der<a id="_idTextAnchor854"/>iving a Target class from Singleton </h3>
<p>Next, let’s take a look at <a id="_idIndexMarker1238"/>how we can create <a id="_idIndexMarker1239"/>our Target class, <code>President</code>, from <code>Singleton</code>:</p>
<pre class="source-code">
// Assume our Person class is as we are accustomed
// A President Is-A Person and also mixes-in Singleton 
<strong class="bold">class President: public Person, public Singleton</strong>
{
private:
    President(const string &amp;, const string &amp;, char, 
              const string &amp;);
public:
    ~President() override;   // virtual destructor
    // disallow copies and assignment
    President(const President &amp;) <strong class="bold">= delete</strong>;  
    President &amp;operator=(const President &amp;) <strong class="bold">= delete</strong>; 
    <strong class="bold">static President *instance(const string &amp;, </strong>
<strong class="bold">                    const string &amp;, char, const string &amp;);</strong>
};
President::President(const string &amp;fn, const string &amp;ln, 
    char mi, const string &amp;t): Person(fn, ln, mi, t),
                               Singleton()
{
}
President::~President()
{
    <strong class="bold">destroyer.setSingleton(nullptr);</strong>  
    cout &lt;&lt; "President destructor" &lt;&lt; endl;
}
President *President::instance(const string &amp;fn, 
           const string &amp;ln, char mi, const string &amp;t)
{
    if (theInstance == nullptr)
    {
        <strong class="bold">theInstance = new President(fn, ln, mi, t);</strong>
        <strong class="bold">destroyer.setSingleton(theInstance);</strong>
        cout &lt;&lt; "Creating the Singleton" &lt;&lt; endl;
    }
    else
        cout &lt;&lt; "Singleton previously created. 
                 Returning existing singleton" &lt;&lt; endl;
    // below cast is necessary since theInstance is 
    // a Singleton *
    <strong class="bold">return dynamic_cast&lt;President *&gt;(theInstance);  </strong>
}                              </pre>
<p>In our aforementioned Target class, <code>President</code>, we merely inherit <code>President</code> from <code>Person</code> using public inheritance and then multiply inherit <code>President</code> from <code>Singleton</code> to <em class="italic">mix-in</em> the <code>Singleton</code> mechanics.</p>
<p>We place our constructor in the private access region. Static method <code>instance()</code> will utilize this constructor internally to create the one and only <code>Singleton</code> instance permitted, to <a id="_idIndexMarker1240"/>adhere to the pattern. There is no default <a id="_idIndexMarker1241"/>constructor (unusual) because we do not wish to allow <code>President</code> instances to be created without their relevant details. Recall that C++ will not link in a default constructor if we have provided an alternate constructor interface. As we do not desire copies of a <code>President</code> or the assignment of a <code>President</code> to another potential <code>President</code>, we have disallowed copies and assignments using the <code>=delete</code> specification in the prototypes for these methods.</p>
<p>Our destructor for <code>President</code> is simple, yet crucial. In the case that our <code>Singleton</code> object will be deleted explicitly, we prepare by setting <code>destroyer.setSingleton(nullptr);</code>. Recall, <code>President</code> inherits the protected <code>static SingletonDestroyer destroyer;</code> data member. Here, we are setting the destroyer’s associated <code>Singleton</code> to the <code>nullptr</code>. This line of code in our <code>President</code> destructor then enables the destructor in <code>SingletonDestroyer</code> to accurately depend on checking for the unusual case of whether its associated <code>Singleton</code> has already been deleted before commencing the usual deletion of its <code>Singleton</code> counterpart. </p>
<p>Finally, we have defined a static method to provide the creation interface for our <code>President</code> as a <code>Singleton</code> with <code>static President *instance(const string &amp;, const string &amp;, char, const string &amp;);</code>. In the definition of <code>instance()</code>, we first check whether the inherited, protected data member <code>Singleton *theInstance</code> is equal to the <code>nullptr</code>. If we have not yet allocated the <code>Singleton</code>, we allocate <code>President</code> using the aforementioned private constructor and assign this newly allocated <code>President</code> instance to <code>theInstance</code>. This is an upcast from a <code>President *</code> to a <code>Singleton *</code>, which is no problem across a public inheritance boundary. If, however, in the <code>instance()</code> method, we find that <code>theInstance</code> is not equal to a <code>nullptr</code>, we simply return a pointer to the previously allocated <code>Singleton</code> object. As users will undoubtedly want to use this object as a <code>President</code> to enjoy the inherited <code>Person</code> features, we downcast <code>theInstance</code> to <code>President *</code> for its return value from this method.</p>
<p>Finally, let us <a id="_idIndexMarker1242"/>consider the logistics of a sample Client in <a id="_idIndexMarker1243"/>our overall application. In its simplest form, our Client will contain a <code>main()</code> function to drive the appli<a id="_idTextAnchor855"/>cation and showcase our Singleton pattern.</p>
<h3>Bringing the pattern components together within the Client</h3>
<p>Let’s now <a id="_idIndexMarker1244"/>take a look at our <code>main()</code> function to see how our pattern is orchestrated:</p>
<pre class="source-code">
int main()
{ 
    // Create a Singleton President
    <strong class="bold">President *p1 = President::instance("John", "Ada<a id="_idTextAnchor856"/>ms",</strong> 
                                        <strong class="bold">'Q', "President");</strong>
    // This second request will fail, returning 
    // the original instance
    <strong class="bold">President *p2 = President::instance("William",</strong>
<strong class="bold">                            "Harrison", 'H', "President");</strong>
    if (p1 == p2)   // Verification there's only one object
     <a id="_idTextAnchor857"/>   cout &lt;&lt; "Same instance (only 1 Singleton)" &lt;&lt; endl;
    p1-&gt;Print();
    <strong class="bold">// SingletonDestroyer will release Singleton at end</strong>
    return 0;
}</pre>
<p>Reviewing our <code>main()</code> function in the preceding code, we first allocate a Singleton <code>Presiden<a id="_idTextAnchor858"/>t</code> using <code>President *p1 = President::instance("John"</code><code>, "Adams", 'Q', "President");</code>. We then try to allocate an additional <code>President</code> on the next line of code using <code>*p2</code>. Because we can only have one <code>Singleton</code> (a <code>President</code> <em class="italic">mixes-in</em> a <code>Singleton</code>), a pointer is returned to our existing <code>President</code> and stored in <code>p2</code>. We verify that there is only one <code>Singleton</code> by comparing <code>p1 == p2</code>; the pointers indeed point to the same instance.</p>
<p>Next, we take advantage of using our <code>President</code> instance in its intended manner, such as by <a id="_idIndexMarker1245"/>using some of the inherited member functions from <code>Person</code>. As an example, we invoke <code>p1-&gt;Print();</code>. Certainly, our <code>President</code> class could have added specialized functionality that would be appropriate to utilize in our Client as well.</p>
<p>Now, at the end of <code>main()</code>, our static object <code>SingletonDestroyer Singleton::destroyer;</code> will be appropriately destructed before its memory is reclaimed. As we have seen, the destructor for <code>SingletonDestroyer</code> will (most often) issue a <code>delete</code> to its associated <code>Singleton</code> (which is actually a <code>President</code>) using <code>delete theSingleton;</code>. This will trigger our <code>President</code> destructor, <code>Singleton</code> destructor, and <code>Person</code> destructor to each be called and executed (going from most specialized to most general subobjects). As our destructor in <code>Singleton</code> is virtual, we are guaranteed to start at the proper level for<a id="_idTextAnchor859"/><a id="_idTextAnchor860"/><a id="_idTextAnchor861"/> destruction and to include all destructors.</p>
<p>Let’s<a id="_idTextAnchor862"/> take a look at the output for this program:</p>
<pre>Creating the Singleton
Singleton previously created. Returning existing singleton
Same instance (only 1 Singleton)
President John Q Adams
SingletonDestroyer destructor
President destr<a id="_idTextAnchor863"/>uctor
Singleton destructor
Person destructor</pre>
<p>In the preceding output, we can visualize the creation of the Singleton <code>President</code>, as well as see that the second <code>instance()</code> request for a <code>President</code> merely returns the existing <code>President</code>. We then see the details of the <code>President</code> that were printed. </p>
<p>Most interestingly, we can see the destruction sequence for the <code>Singleton</code>, which is driven <a id="_idIndexMarker1246"/>by the static object reclamation of the <code>SingletonDestroyer</code>. Through proper deletion of the <code>Singleton</code> in the <code>SingletonDestroyer</code> destructor, we see that <code>President</code>, <code>Singleton</code>, and <code>Person</code> destructors are each invoked as they<a id="_idTextAnchor864"/> contribute to the complete <code>President</code> object.</p>
<h3>Examining explicit Singleton deletion and its impact on SingletonDestroyer destructor </h3>
<p>Let’s take a look at <a id="_idIndexMarker1247"/>an alternate version of the Client with an alternate <code>main()</code> function. Here, we <a id="_idIndexMarker1248"/>force deletion of our <code>Singleton</code>; this is rare. In this scenario, our <code>SingletonDestroyer</code> will not delete its paired <code>Singleton</code>. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex3.cpp</a></p>
<pre class="source-code">
int main()
{
    President *p1 = President::instance("John", "Adams", 
                                        'Q', "President");
    President *p2 = President::instance("William",
                             "Harrison", 'H', "President");
    if (p1 == p2)  // Verification there's only one object
        cout &lt;&lt; "Same instance (only 1 Singleton)" &lt;&lt; endl;
    p1-&gt;Print();
    <strong class="bold">delete p1;</strong>  // Delete the Singleton – unusual.
    return 0;   // Upon checking, the SingletonDestroyer 
}   // will no longer need to destroy its paired Singleton</pre>
<p>In the aforementioned <code>main()</code> function, notice that we explicitly deallocate our Singleton <code>President</code> using <code>delete p1;</code>, versus allowing the instance to be reclaimed <a id="_idIndexMarker1249"/>via static <a id="_idIndexMarker1250"/>objection deletion as the program ends. Fortunately, we have included a test in our <code>SingletonDestroyer</code> destructor to let us know whether the <code>SingletonDestroyer</code> must delete its associated <code>Singleton</code> or whether this deletion has already occurred.</p>
<p>Let’s take a look at the revised output to notice the differences from our original <code>main()</code>:</p>
<pre>Creating the Singleton
Singleton previously created. Returning existing singleton
Same instance (only 1 Singleton)
President John Q Adams
President destructor
Singleton destructor
Person destructor
SingletonDestroyer destructor: Singleton has already been destructed</pre>
<p>In the aforementioned output for our revised Client, we can again visualize the creation of the Singleton <code>President</code>, the <em class="italic">unsuccessful</em> creation request of a second <code>President</code>, and so on.</p>
<p>Let’s notice the destruction sequence and how it differs from our first Client. Here, the Singleton <code>President</code> is explicitly deallocated. We can see the proper deletion of the <code>President</code> through <a id="_idIndexMarker1251"/>the call and execution of the destructors in <code>President</code>, <code>Singleton</code>, and <code>Person</code> as each is executed. Now, when the application is about to end and <a id="_idIndexMarker1252"/>the static <code>SingletonDestroyer</code> is about to have its memory reclaimed, we can visualize the destructor called on the <code>SingletonDestroyer</code>. However, this destructor no longer will delete its associated <code>Singleton</code>. </p>
<h3>Understanding design advantages and disadvantages</h3>
<p>An advantage of the <a id="_idIndexMarker1253"/>preceding (paired-class) implementation of the Singleton pattern (irrespective of which <code>main()</code> is employed) is that we have guaranteed proper destruction of the <code>Singleton</code>. This happens regardless of whether the <code>Singleton</code> is long-lived and is deleted in its usual fashion by its associated <code>SingletonDestroyer</code>, or whether it is deleted earli<a id="_idTextAnchor866"/>er on in the application directly (a rare scenario).</p>
<p>A disadvantage of this implementation is inherited from the concept of the <code>Singleton</code>. That is, there <a id="_idIndexMarker1254"/>can only be one derived class of <code>Singleton</code> that incorporates the specific mechanics of the <code>Singleton</code> class. Because we have inherited <code>President</code> from <code>Singleton</code>, we are using the Singleton logistics (namely static data members, stored in external variables) for <code>President</code> and <code>President</code> alone. Should another class wish to be derived from <code>Singleton</code> to embrace this idiom, the internal implementation for the <code>Singleton</code> has already been utilized for <code>President</code>. Ouch! That does not seem fair. </p>
<p>Not to worry! Our design can be easily expanded to accommodate multiple classes that wish to use our <code>Singleton</code> base class. We will augment our design to accommodate multiple <code>Singleton</code> objects. We will assume, however, that we still intend to have only one <code>Singleton</code> instance per class type.</p>
<p>Another potential concern is thread safety. For example, if multithreaded programming will be utilized, we need to ensure that our <code>static President::instance()</code> method acts as though it is atomic, that is, uninterruptible. We can do this through carefully synchronized access to the static method itself. </p>
<p>Let us now take a brief look at how we may expand the Singleton pattern to solve this issue.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor867"/>Using a registry to allow many classes to utilize Singleton</h2>
<p>Let us more <a id="_idIndexMarker1255"/>closely examine a shortcoming with our current Singleton pattern implementation. Currently, there can only be one derived class of <code>Singleton</code> that can effectively utilize the <code>Singleton</code> class. Why is this? <code>Singleton</code> is a class that comes with external variable definitions to support the static data members within the class. The static data member representing <code>theInstance</code> (implemented using the external variable <code>Singleton *Singleton::theInstance</code>) may only be set to one <code>Singleton</code> instance. <em class="italic">Not one per class</em> – there is only one set of external variables creating the memory for the crucial <code>Singleton</code> data members of <code>theInstance</code> and <code>destroyer</code>. Herein lies the problem. </p>
<p>We can, instead, specify a <code>Registry</code> class to keep track of the classes applying the Singleton pattern. There are <a id="_idIndexMarker1256"/>many implementations for a <strong class="bold">Registry</strong>, and we will review one such implementation.</p>
<p>In our implementation, the <code>Registry</code> will be a class that pairs class names (for classes employing the Singleton pattern) with <code>Singleton</code> pointers to the single allowed instance of each registered class. We will still derive each Target class from <code>Singleton</code> (and from any other class as deemed appropriate by our design). </p>
<p>Our <code>instance()</code> method in each class <em class="italic">derived</em> from <code>Singleton</code> will be revised, as follows:</p>
<ul>
<li>Our first check within <code>instance()</code> will be to call a <code>Registry</code> method (with the derived class’ name) asking whether a <code>Singleton</code> had previously been created for that class. If the <code>Registry</code> method determines a <code>Singleton</code> for the requested derived type has previously been instantiated, a pointer to the existing instance will be returned by <code>instance()</code>.</li>
<li>Instead, if the <code>Registry</code> provides permission to allocate the <code>Singleton</code>, <code>instance()</code> will allocate the <code>Singleton</code> much as before, setting the inherited protected data member of <code>theInstance</code> to the allocated derived <code>Singleton</code>. The static <code>instance()</code> method will also set the backlink through the inherited protected destroyer data member using <code>setSingleton()</code>. We will then pass the newly instantiated derived class instance (which is a <code>Singleton</code>) to a <code>Registry</code> method to <code>Store()</code> the newly allocated <code>Singleton</code> within the <code>Registry</code>.</li>
</ul>
<p>We notice that four pointers to the same <code>Singleton</code> will exist. One will be the specialized pointer of our derived class type, which is returned from our derived class <code>instance()</code> method. This pointer will be handed to our Client for application usage. The second <code>Singleton</code> pointer will be the pointer stored in our inherited, protected data <a id="_idIndexMarker1257"/>member <code>theInstance</code>. The third <code>Singleton</code> pointer will be the pointer stored in the <code>SingletonDestroyer</code>. The fourth pointer to the <code>Singleton</code> will be a pointer that is stored in the <code>Registry</code>. No problem, we can have multiple pointers to a <code>Singleton</code>. This is one reason the <code>SingletonDestroyer</code>, used in its traditional destruction capacity, is so important – it will destroy our one and on<a id="_idTextAnchor868"/>ly <code>Singleton</code> for each type at the end of the application.</p>
<p>Our <code>Registry</code> will maintain a pair for each class employing the <code>Singleton</code> pattern, consisting of a class name and the (eventual) pointer to the specific <code>Singleton</code> for the corresponding class. The pointer to each specific <code>Singleton</code> instance will be a static data member and will additionally require an external variable to garner its underlying memory. The result is one additional external variable per class embracing the Singleton pattern. </p>
<p>The idea of the <code>Registry</code> can be expanded further still if we choose to additionally accommodate the rare use of the Singleton pattern to allow multiple (but a finite set of) <code>Singleton</code> objects per class type. This rare existence of controlled, multiple singletons is known as the <code>Principal</code> would be an expected derived class of <code>Singleton</code>, yet the multiple vice-principals would represent a fixed number of instances of the <code>Vice-Principal</code> class (derived from <code>Singleton</code>). Our registry could be expanded to allow up to <code>N</code> registered <code>Singleton</code> objects for the <code>Vice-Principal</code> type (the multiton).</p>
<p>We have now seen an implementation of the Singleton pattern using a paired-class approach. We have folded the classes and concepts of <code>Singleton</code>, <code>SingetonDestroyer</code>, Target, and Client into the<a id="_idTextAnchor869"/> framework of classes we are accustomed to seeing, namely <code>Person</code>, as well as into a descendant class of our <code>Singleton</code> and <code>Person</code> (<code>President</code>). Let’s now briefly recap what we have learned <a id="_idIndexMarker1259"/>relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-300"><a id="_idTextAnchor870"/>Summary</h1>
<p>In this chapter, we have furthered our goal of becoming better C++ programmers by expanding our programming repertoire by embracing another design pattern. We have explored the Singleton pattern by first employing two simple approaches, and then a paired-class implementation using <code>Singleton</code> and <code>SingletonDestroyer</code>. Our approach uses inheritance to incorporate our Singleton’s implementation into our Target class. Optionally, we incorporate a useful, existing base class into our Target class using multiple inheritances.</p>
<p>Making use of core design patterns, such as the Singleton pattern, will help you more easily reuse existing, well-tested portions of code in a manner understood by other programmers. By employing familiar design patterns, you will be contributing to well-understood and reusable solutions with avant-garde programming techniques.</p>
<p>We are now ready to continue onward with our final design pattern in <a href="B19087_20.xhtml#_idTextAnchor876"><em class="italic">Chapter 20</em></a>, <em class="italic">Removing Implementation Details Using the pImpl Pattern</em>. Adding more patterns to our arsenal of programming skills makes us more versati<a id="_idTextAnchor871"/>le and valued programmers. Let’s continue onward!</p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor872"/>Questions</h1>
<ol>
<li>Using the Singleton pattern examples found in t<a id="_idTextAnchor873"/><a id="_idTextAnchor874"/>his chapter, create a program to accomplish the following:<ol><li>Implement either an interface for a <code>President</code> to <code>Resign()</code> or implement the interface to <code>Impeach()</code> a <code>President</code>. Your method should delete the current Singleton <code>President</code> (and remove that link from the <code>SingletonDestroyer</code>). <code>SingletonDestroyer</code> has a <code>setSingleton()</code> m<a id="_idTextAnchor875"/>ethod that may be useful to aid in removing the backlink. </li><li>Noting that the former Singleton <code>President</code> has been removed, create a new <code>President</code> using <code>President::instance()</code>. Verify that the new <code>President</code> has been installed.</li><li>(Optional) Create a <code>Registry</code> to allow <code>Singleton</code> to be used effectively in multiple classes (not mutually exclusively, as is the current implementation). </li></ol></li>
<li>Why can you not label the <code>static instance()</code> method as virtual in <code>Singleton</code> and override it in <code>President</code>?</li>
<li>What other examples can you imagine that might easily incorporate the Singleton pattern? </li>
</ol>
</div>
</div></body></html>