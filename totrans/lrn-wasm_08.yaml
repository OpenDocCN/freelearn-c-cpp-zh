- en: Porting a Game with Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in [Chapter 7](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml), *Creating
    an Application from Scratch*, WebAssembly is still relatively limited in its current
    form. Emscripten provides powerful APIs for extending WebAssembly's capabilities
    to add functionality to your application. Compiling to a WebAssembly module and
    JavaScript glue code (instead of an executable) can, in some cases, only require
    minor changes to the existing C or C++ source.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to take a code base written in C++ that gets compiled
    to a traditional executable, and update the code so that it can be compiled to
    Wasm/JavaScript. We'll also add some additional features for tighter integration
    with the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll know how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update a C++ code base to compile to a Wasm module/JavaScript glue code (instead
    of a native executable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Emscripten's APIs to add browser integration to a C++ application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a multi-file C++ project with the proper `emcc` flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run and test a C++ application in the browser using `emrun`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're taking a Tetris clone written in C++ and updating the
    code to integrate Emscripten and compile to Wasm/JS. The code base in its original
    form compiled to an executable utilizes SDL2 and can be loaded from the command
    line. In this section, we're going to briefly review what Tetris is, how to get
    the code (without having to write it from scratch), and how to get it running.
  prefs: []
  type: TYPE_NORMAL
- en: What is Tetris?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Tetris, the main objective of the game is to rotate and move pieces (*Tetriminos*)
    of various shapes within a playing field (*well* or *matrix*) to create a row
    of blocks without gaps. When a full row is created, it is deleted from the playing
    field and your score is increased by one. In our version of the game, there won't
    be a win condition (although it would be simple to add it).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to understand the rules and mechanics of the game because the
    code uses algorithms for concepts such as collision detection and scoring. Understanding
    the goal of a function helps you understand the code within. I recommend you give
    it a try online if you need to brush up on your Tetris skills. You can play it
    at [https://emulatoronline.com/nes-games/classic-tetris/](https://emulatoronline.com/nes-games/classic-tetris/)
    without having to install Adobe Flash. It looks just like the original Nintendo
    Version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60566c17-a951-44f8-a3f4-a1e2bf8c6115.png)'
  prefs: []
  type: TYPE_IMG
- en: Classic Tetris at EmulatorOnline.com
  prefs: []
  type: TYPE_NORMAL
- en: The version we'll be working with won't contain the piece counters, levels,
    or points (we're sticking to line counts), but it will operate in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The source of the source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that a search for Tetris C++ provides a multitude of tutorials
    and example repositories to choose from. In the interest of sticking to the formatting
    and naming conventions that I've been using up to this point, I combined these
    resources to create my own version of the game. The *Further reading* section
    at the end of this chapter has links to these resources if you're interested in
    learning more. The concepts and process for porting a code base are applicable,
    regardless of the source. On that note, let's take a brief step-aside to discuss
    porting in general.
  prefs: []
  type: TYPE_NORMAL
- en: A note about porting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Porting an existing code base to Emscripten is not always a simple task. There
    are several variables to take into account when evaluating whether a C, C++, or
    Rust application is amenable to conversion. For example, games that make use of
    several third-party libraries or even a few third-party libraries that are of
    considerable complexity may require a significant amount of effort. Emscripten
    provides the following commonly used libraries out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asio`: A network and low-level I/O programming library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bullet`: A real-time collision detection and multi-physics simulation library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cocos2d`: A suite of open source, cross-platform, game development tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreeType`: A library used to render fonts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HarfBuzz`: An OpenType text shaping engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libpng`: The official PNG reference library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ogg`: A multimedia container format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL2`: A library designed to provide low-level access to audio, a keyboard,
    a mouse, a joystick, and graphics hardware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL2_image`: An image file loading library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL2_mixer`: A sample multi-channel audio mixer library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL2_net`: A small sample cross-platform networking library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDL2_ttf`: A sample library that allows you to use TrueType fonts in your
    SDL applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vorbis`: A general purpose audio and music encoding format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zlib`: A lossless data compression library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the library isn't already ported, you will need to do it yourself. This would
    benefit the community, but requires a significant investment of time and resources.
    Our Tetris example only uses SDL2, which makes the porting process relatively
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter is located in the `/chapter-08-tetris` folder of
    the `learn-webassembly` repository. There are two directories within `/chapter-08-tetris`:
    the `/output-native` folder, which contains the original (pre-ported) code and
    the `/output-wasm` folder, which contains the ported code.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use VS Code's Task feature for the native build step, you'll
    need to open the `/chapter-08-tetris/output-native` folder in VS Code, not the
    top-level `/learn-webassembly` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Building the native project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `/cmake` folder and `CMakeLists.txt` file within the `/output-native` folder
    are required to build the project. The `README.md` file contains instructions
    to get the code up and running on each platform. Building the project isn't necessary
    to work through the porting process. The process for installing the required dependencies
    and getting the project to build successfully on your platform can be time-consuming
    and complex. If you still wish to proceed, you can build the executable through
    VS Code's Task feature by selecting Tasks | Run Task... from the menu and selecting
    Build Executable from the list after following the instructions in the `README.md`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The game in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you were successful in building the project, you should be able to run it
    by selecting **Tasks** | **Run Task...** from the VS Code menu and selecting the
    Start Executable task from the list. If everything was successful, you should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34e1026f-bd47-4209-a611-671d81f98ede.png)'
  prefs: []
  type: TYPE_IMG
- en: Compiled game running natively
  prefs: []
  type: TYPE_NORMAL
- en: Our version of the game doesn't have a losing condition; it just increments
    the ROWS count by one for each row you clear. If one of the Tetriminos touches
    the top of the board, the game is over and the board resets. It's a rudimentary
    implementation of the game, but additional features increase the complexity and
    amount of code required. Let's review the code base in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The code base in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the code available, you'll need to familiarize yourself with
    the code base. Without having a good understanding of the code you want to port,
    you'll have a much harder time porting it successfully. In this chapter, we're
    going to walk through each of the C++ class and header files and describe their
    roles in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the code into objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ was designed around an object-oriented paradigm, which is what the Tetris
    code base uses to simplify management of the application. The code base consists
    of C++ class files
  prefs: []
  type: TYPE_NORMAL
- en: (`.cpp`) and header files (`.h`) that represent objects within the context of
    the game. I used the gameplay summary from the *What is Tetris?* section to extrapolate
    which objects I needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game pieces (Tetriminos) and playing field (referred to as a well or matrix)
    are good candidates for classes. Maybe less intuitively, but still just as valid,
    is the *game* itself. Classes don''t necessarily need to be as concrete as actual
    objects — they''re excellent for storing shared code. I''m a big fan of less typing,
    so I opted to use `Piece` to represent a Tetrimino and `Board` for the playing
    field (although the word *well *is shorter, it just doesn''t quite fit). I created
    a header file to store global variables (`constants.h`), a `Game` class to manage
    gameplay, and a `main.cpp` file, which acts as the entry point for the game. Here''s
    the contents of the `/src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each file (with the exception of `main.cpp` and `constants.h`) has a class (`.cpp`)
    and header (`.h`) file. Header files allow you to reuse code across multiple files
    and prevent code duplication. The *Further reading* section contains resources
    for you to learn more about header files if you're interested. The `constants.h`
    file is used in almost all of the other files within the application, so let's
    review that first.
  prefs: []
  type: TYPE_NORMAL
- en: The constants file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than have confusing *magic numbers* sprinkled throughout the code base,
    I opted for a header file containing the constants we''ll be using (`constants.h`).
    The contents of this file are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `#ifndef` statement in the first line of the file is an `#include` guard,
    which prevents the header file from being included multiple times during compilation.
    These guards are used in all of the application's header files. The purpose of
    each of these constants will become clear when we step through each of the classes.
    I included it first to provide context around the various element sizes and how
    they relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the various classes that represent aspects of the game. The
    `Piece` class represents an object at the lowest level, so we'll start there and
    work our way up to the `Board` and `Game` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The piece class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The piece, or *Tetrimino*, is the element that can be moved and rotated on
    the board. There are seven kinds of Tetriminos — each is represented by a letter
    and has a corresponding color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc6eabd2-b522-4990-9973-6d5432055b3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Tetrimino colors, taken from Wikipedia
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a way to define each piece in terms of shape, color, and current orientation.
    Each piece has four different orientations (at 90 degree increments), which results
    in 28 total variations for all pieces. The color doesn''t change, so that only
    needs to be assigned once. With that in mind, let''s first take a look at the
    header file (`piece.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The game uses SDL2 to render the various graphical elements and handle keyboard
    input, which is why we're passing a `SDL_Renderer` into the `draw()` function.
    You'll see how SDL2 is used in the `Game` class, but for now just be aware of
    its inclusion. The header file defines the interface for the `Piece` class; let's
    review the implementation in `piece.cpp`. We'll walk through each section of code
    and describe the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor and draw() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section of code defines the constructor of the `Piece` class and
    the `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The constructor initializes the class with default values. The `BoardColumns`
    and `PieceSize` values are constants from the `constants.h` file. `BoardColumns`
    represents the amount of columns that can fit on a board, which is `10` in this
    case. The `PieceSize` constant represents the area or block that a piece takes
    up in columns, which is `4`. The initial value assigned to the private `columns_`
    variable represents the center of the board.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function loops through all of the possible rows and columns on
    the board and fills in any cells that are populated by a piece with the color
    that corresponds to its kind. The determination for whether a cell is populated
    by a piece is performed in the `isBlock()` function, which we'll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: The move(), rotate(), and isBlock() functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second section contains the logic to move or rotate the piece and determine
    its current location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `move()` function updates the values of the private `column_` and `row_`
    variables, which dictates the piece's location on the board. The `rotate()` function
    sets the value of the private `angle_` variable to either `0`, `1`, `2`, or `3`
    (which is why `%= 4` is used).
  prefs: []
  type: TYPE_NORMAL
- en: Determination for which kind of piece is shown, its location, and rotation is
    performed in the `isBlock()` function. I omitted all but the first two elements
    of the `Shapes` multi-dimensional array to avoid cluttering up the file, but the
    remaining five piece kinds are present in the actual code. I will admit that this
    isn't the most elegant implementation, but it suits our purposes just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The private `kind_` and `angle_` values are specified as dimensions in the `Shapes`
    array to pick the four corresponding `char*` elements. These four elements represent
    the four possible orientations of the piece. If the index of `column + row * PieceSize`
    in the string is an asterisk, the piece is present in the specified row and column.
    If you decide to work through one of the Tetris tutorials available on the web
    (or look at one of the many Tetris repositories on GitHub), you'll find that there
    are several different ways to calculate whether a cell is populated by a piece.
    I chose this method because it's easier to visualize the pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The getColumn() and getRow() functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final section of code contains functions to get the row and column of the
    piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These functions simply return the value of the private `column_` or `row_` variable.
    Now that you have a better understanding of the `Piece` class, let's move on to
    the `Board`.
  prefs: []
  type: TYPE_NORMAL
- en: The Board class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Board` contains instances of the `Piece` class and needs to detect collisions
    among the pieces, when rows are filled, and when the game is over. Let''s start
    with the contents of the header file (`board.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Board` has a `draw()` function like the `Piece` class as well as several
    other functions for managing rows and keeping track of which cells are populated
    on the board. The `SDL2_ttf` library is used to render the ROWS: text at the bottom
    of the window with the current score (count of rows cleared). Now, let''s take
    a look at each section of the implementation file (`board.cpp`).'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor and draw() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section of code defines the constructor of the `Board` class and
    the `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Board` constructor initializes the values of the private `cells_` and `currentScore_`
    variables to default values. The `cells_` variable is a two-dimensional array
    of Booleans, with the first dimension representing columns and the second rows.
    If a piece occupies a specific column and row, the corresponding value in the
    array is `true`. The `draw()` function behaves similarly to the `draw()` function
    of `Piece` in that it fills cells that contain pieces with color. However, this
    function only fills in cells that are occupied by pieces that have reached the
    bottom of the board with a light gray color, regardless of what kind of piece
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: The isCollision() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second section of code contains logic to detect collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `isCollision()` function loops through each cell on the board until it reaches
    one populated by the `&piece` passed as an argument. If the piece is about to
    collide with either side of the board or it has reached the bottom, the function
    returns `true`, otherwise it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The unite() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third section of code contains logic to unite a piece with the top row
    when it comes to rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `unite()` function and the corresponding `isRowFull()`, `areFullRowsPresent()`,
    and `updateOffsetRow()` functions perform several operations. It updates the private
    `cells_` variable with the rows and columns that the specified `&piece` argument
    occupies by setting the appropriate array location to `true`. It also clears any
    full rows (all columns filled) from the board by setting the corresponding `cells_`
    array locations to `false` and increments the `currentScore_`. After the row is
    cleared, the `cells_` array is updated to shift the row above the cleared row
    down by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The displayScore() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final section of code displays the score at the bottom of the game window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `displayScore()` function uses the `SDL2_ttf` library to display the current
    score at the bottom of the window (underneath the board). The `TTF_Font *font`
    argument is passed in from the `Game` class to avoid initializing the font every
    time the score is updated. The `stringstream message` variable is used to create
    the text value and set it to a C `char*` within the `TTF_RenderText_Blended()`
    function. The rest of the code draws the text on a `SDL_Rect` to ensure that it's
    properly displayed.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the `Board` class; let's move on to the `Game` to see how it all
    fits together.
  prefs: []
  type: TYPE_NORMAL
- en: The Game class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Game` class contains the looping function that enables you to move pieces
    around the board with key presses. Here''s the contents of the header file (`game.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `loop()` function contains the game logic and manages state based on events.
    The first two lines under the `private:` header prevent more than one instance
    of the game from being created, which could cause a memory leak. The private methods
    reduce the amount of code lines in the `loop()` function, which simplifies maintenance
    and debugging. Let's move on to the implementation in `game.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor and destructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section of code defines the actions to perform when the class instance
    is loaded (constructor) and unloaded (destructor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The constructor represents the entry point for the application, so all of the
    required resources are allocated and initialized within it. The `TTF_OpenFont()`
    function is referencing a TrueType font file downloaded from Google Fonts named
    Press Start 2P. You can view the font at [https://fonts.google.com/specimen/Press+Start+2P](https://fonts.google.com/specimen/Press+Start+2P).
    It's present in the `/resources` folder of the repository and gets copied into
    the same folder as the executable when the project is built. If at any point an
    error occurs when initializing the SDL2 resources, a `runtime_error` is thrown
    with details of the error. The destructor (`~Game()`) frees up the resources we
    allocated for SDL2 and `SDL2_ttf` before the application exits. This is done to
    avoid a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: The loop() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final section of code represents the `Game::loop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `loop()` function returns a Boolean as long as the `SDL_QUIT` event hasn't
    fired. Every `1` second, the `draw()` functions for the `Piece` and `Board` instances
    are executed, and the piece locations on the board are updated accordingly. The
    left, right, and down arrow keys control the piece's movement while the up arrow
    key rotates the piece by 90 degrees. Appropriate responses to key presses are
    handled in the `handleKeyEvents()` function. The `checkForCollision()` function
    determines if a new instance of the active piece collided with either side of
    the board or came to rest on top of the other pieces. If it did, a new piece is
    created. The logic for clearing the rows (via the `unite()` function of `Board`)
    is also handled in this function. We're almost done! Let's move on to the `main.cpp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The main file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s no header file associated with `main.cpp` because its only purpose
    is to act as an entry point to the application. In fact, the file is only seven
    lines long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `while` statement is exited when the `loop()` function returns `false`,
    which occurs when the `SDL_QUIT` event fires. All this file is doing is creating
    a new instance of `Game` and starting the loop. That's it for the codebase; let's
    start porting!
  prefs: []
  type: TYPE_NORMAL
- en: Porting to Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have a good understanding of the code base, so now it's time to start porting
    it over with Emscripten. Fortunately, we're able to leverage some of the browser's
    features to simplify the code and completely remove a third-party library. In
    this section, we're going to update the code to compile to a Wasm module and JavaScript
    *glue* file and update some of the functionality to utilize the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for porting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `/output-wasm` folder contains the end result, but I recommend that you
    create a copy of the `/output-native` folder so that you can follow along with
    the porting process. There are VS Code Tasks set up for both native compilation
    and Emscripten compilation. If you get stuck, you can always reference the `/output-wasm`
    contents. Make sure you open your copied folder in VS Code (File | Open and select
    your copied folder), otherwise you won't be able to use the Tasks feature.
  prefs: []
  type: TYPE_NORMAL
- en: What's changing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This game is an ideal candidate for porting because it uses SDL2, a widely
    used library with an existing Emscripten port. Including SDL2 in the compilation
    step requires only one additional argument passed to the `emcc` command. An Emscripten
    port of the `SDL2_ttf` library also exists, but keeping it in the code base doesn''t
    make much sense. Its sole purpose is to render the score (amount of rows cleared)
    as text. We would need to include the TTF file with the application and complicate
    the build process. Emscripten provides the means for using JavaScript code within
    our C++, so we''re going to take a much simpler route: show the score in the DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to changing the existing code, we'll need to create an HTML and
    CSS file for displaying and styling the game in the browser. The JavaScript code
    we write will be minimal — we just need to load the Emscripten module and all
    our functionality is handled in the C++ code base. We'll also need to add a few
    `<div>` elements and lay them out accordingly to display the score. Let's start
    porting!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the web assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a folder in your project folder named `/public`. Add a new file named
    `index.html` to the `/public` folder and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.js` file being loaded in the first `<script>` tag doesn''t exist
    yet; that''ll be generated in the compilation step. Let''s add some styles to
    the elements. Create a `styles.css` file in the `/public` folder and populate
    it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the Press Start 2P font we're using is hosted on Google Fonts, we can
    import it for use on the site. The CSS rules in this file handle simple layout
    and styling. That's it for the web-related files we needed to create. Now, it's
    time to update the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Porting the existing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We only need to edit a few files to get Emscripten working correctly. For the
    sake of simplicity and compactness, only the affected sections of code will be
    included (rather than the entire file). Let's work through the files in the same
    order as the previous section and start with `constants.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the constants file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll display the rows cleared count on the DOM instead of in the game window
    itself, so you can delete the `ScreenHeight` constant from the file. We no longer
    need additional space to accommodate for the score text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: No changes need to be made to the `Piece` class files (`piece.cpp`/`piece.h`).
    However, we will need to update the `Board` class. Let's start with the header
    file (`board.h`). Starting with the bottom and working our way up, let's update
    the `displayScore()` function. In the `<body>` section of the `index.html` file,
    there's a `<span>` element with `id="score"`. We're going to update this element
    using the `emscripten_run_script` command to display the current score. As a result,
    the `displayScore()` function becomes much shorter. The before and after is shown
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the original version of the Board class''s `displayScore()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the ported version of the `displayScore()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `emscripten_run_script` action simply finds the `<span>` element on the
    DOM and sets the `innerHTML` to the current score. We can''t use the `EM_ASM()`
    function here because Emscripten doesn''t recognize the `document` object. Since
    we have access to the private `currentScore_` variable in the class, we''re going
    to move the `displayScore()` call in the `draw()` function into the `unite()`
    function. This limits the amount of calls to `displayScore()` to ensure that the
    function is called only when the score has actually changed. We only need to add
    one line of code to accomplish this. Here''s what the `unite()` function looks
    like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re no longer using the `SDL2_ttf` library, we can update the `draw()`
    function signature and remove the `displayScore()` function call. Here''s the
    updated `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `displayScore()` function call was removed from the first line of the function
    and the `TTF_Font *font` argument was removed as well. Let''s add a call to `displayScore()`
    in the constructor to ensure that the initial value is set to `0` when the game
    ends and a new one begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for the class file. Since we changed the signatures for the `displayScore()`
    and `draw()` functions, and removed the dependency for `SDL2_ttf`, we''ll need
    to update the header file. Remove the following lines from `board.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're moving right along! The final change we need to make is the also the biggest
    one. The existing code base has a `Game` class that manages the application logic
    and a `main.cpp` file that calls the `Game.loop()` function in the `main()` function.
    The looping mechanism is a while loop that continues to run as long as the `SDL_QUIT`
    event hasn't fired. We need to change our approach to accommodate for Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Emscripten provides an `emscripten_set_main_loop` function that accepts an
    `em_callback_func` looping function, `fps`, and a `simulate_infinite_loop` flag.
    We can''t include the `Game` class and pass `Game.loop()` as the `em_callback_func`
    argument, because the build will fail. Instead, we''re going to eliminate the
    `Game` class completely and move the logic into the `main.cpp` file. Copy the
    contents of `game.cpp` into `main.cpp` (overwriting the existing contents) and
    delete the `Game` class files (`game.cpp`/`game.h`). Since we''re not declaring
    a class for `Game`, remove the `Game::` prefixes from the functions. The constructor
    and destructor are no longer valid (they''re no longer part of a class), so we
    need to move that logic to a different location. We also need to reorder the file
    to ensure that our called functions come before the calling functions. The final
    result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `handleKeyEvents()` and `checkForCollision()` functions haven't changed;
    we simply moved them to the top of the file. The `loop()` function return type
    was changed from `bool` to `void` as required by `emscripten_set_main_loop`. Finally,
    the code from the constructor and destructor was moved into the `main()` function
    and any references to `SDL2_ttf` were removed. Instead of the while statement
    that called the `loop()` function of `Game`, we have the `emscripten_set_main_loop(loop,
    0, 1)` call. We changed the `#include` statements at the top of the file to accommodate
    for Emscripten, SDL2, and our `Board` and `Piece` classes. That's it for changes
    — now it's time to configure the build and test out the game.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the code updated and the required web assets present, it's time to build
    and test out the game. The compilation step is similar to the previous examples
    in this book, but we're going to use a different technique to run the game. In
    this section, we're going to configure the build task to accommodate for the C++
    files and run the application using a feature provided by Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: Building with VS Code tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to configure the build in two ways: with VS Code tasks and a Makefile.
    Makefiles are nice if you prefer to use a different editor than VS Code. The `/.vscode/tasks.json`
    file already contains the tasks you''ll need to build the project. The Emscripten
    build step is the default (a set of native build tasks is also present). Let''s
    walk through each task in the `tasks` array and review what''s taking place. The
    first task deletes any existing compiled output files prior to building:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second task performs the build with the `emcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The related arguments are placed on the same line. The only new and unfamiliar
    addition to the `args` array is the `--bind` argument with the corresponding `.cpp`
    files. This tells Emscripten that all the files after `--bind` are required to
    build the project. Test out the build by selecting Tasks | Run Build Task... from
    the menu or using the keyboard shortcut *Cmd*/*Ctrl + Shift + B*. It takes a few
    seconds to build, but the terminal will let you know when the compilation process
    is complete. If successful, you should see an `index.js` and `index.wasm` file
    in the `/public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Building with a Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you prefer not to use VS Code, you can use a Makefile to accomplish the
    same goal as the VS Code tasks. Create a file named `Makefile` in your project
    folder and populate it with the following contents (make sure that the file is
    using tabs, not spaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations being performed are identical to the VS Code tasks, just in
    a different format using more universal tooling. The default build step is set
    in the file, so you can run the following command within your project folder to
    compile the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a compiled Wasm file and JavaScript glue code, let's try running
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Running the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of using serve or `browser-sync`, we''re going to use a built-in feature
    of Emscripten''s toolchain, `emrun`. It provides the added benefit of capturing
    `stdout` and `stderr` (if you pass the `--emrun` linker flag to the `emcc` command)
    and printing them to the terminal if desired. We''re not going to use the `--emrun`
    flag, but having a local web server available without having to install any additional
    dependencies is a nice added feature to be aware of. Open up a terminal instance
    within your project folder and run the following command to start the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify `firefox` for the browser if that''s what you''re using for
    development. The `--no_emrun_detect` flag hides a message in the terminal stating
    that the HTML page is not `emrun` capable. If you navigate to `http://localhost:6931/index.html`,
    you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/700df992-90f3-4452-84da-49e770e1a1c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Tetris running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: Try rotating and moving the pieces to ensure that everything is working correctly.
    The ROWS count should increment by one when you've successfully cleared a row.
    You may also notice that if you're too close to the edge of the board, you won't
    be able to rotate some of the pieces. Congratulations, you've successfully ported
    a C++ game over to Emscripten!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we ported a Tetris clone written in C++ that used SDL2 to Emscripten
    so it could be run in the browser with WebAssembly. We covered the rules of Tetris
    and how they map to the logic within the existing codebase. We also reviewed each
    file in the existing code base individually and which changes had to be made to
    successfully compile to a Wasm file and JavaScript glue code. After updating the
    existing code, we created the required HTML and CSS files, then configured a build
    step with the appropriate `emcc` flags. Once built, the game was run using Emscripten's
    `emrun` command.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](52c9bfe6-6178-4795-8316-09aee11e8e28.xhtml), *Integrating with
    Node.js*, we're going to discuss how to integrate WebAssembly into Node.js and
    the benefits this integration provides.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the pieces called in Tetris?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one reason for choosing not to port an existing C++ code base to Emscripten?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool did we use to compile the game natively (for example, to an executable)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `constants.h` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why were we able to eliminate the SDL2_ttf library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Emscripten function did we use to start running the game?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which argument did we add to the `emcc` command to build the game and what purpose
    does it serve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantage does `emrun` offer over a tool like `serve` and Browsersync?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header Files in C++: [https://www.sitesbay.com/cpp/cpp-header-files](https://www.sitesbay.com/cpp/cpp-header-files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SDL2 Tetris on GitHub: [https://github.com/andwn/sdl2-tetris](https://github.com/andwn/sdl2-tetris)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tetris on GitHub: [https://github.com/abesary/tetris](https://github.com/abesary/tetris)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tetris - Linux on GitHub: [https://github.com/abesary/tetris-linux](https://github.com/abesary/tetris-linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
