<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Standard Qt Widgets</h1>
                </header>
            
            <article>
                
<p>Qt Widgets are not the new kid on the block, but they still do have their place in applications that target mobile and embedded devices. They are well formed, predictable and have standard UI elements.</p>
<p>Recognizable UI elements are found in Qt Widgets and work great on laptops, which are simply mobile desktops. In this chapter, you will learn to design standard looking applications. Basic widgets such as menus, icons, and lists will be discussed with an emphasis on how to constrain the user interface to medium and small-sized displays. <span><span>Topics</span></span> we will discuss include how to use Qt's dynamic layouts to handle orientation changes. Classes such as <kbd>QGraphicsScene</kbd>, <kbd>QGraphicsView</kbd>, and <kbd>QGraphicsItem</kbd> will be used. Layout API such as <kbd>QVBoxLayout</kbd>, <kbd>QGridLayout</kbd>, and <kbd>QStackedLayout</kbd> will be discussed.</p>
<p>In this chapter we will cover:</p>
<ul>
<li>Using Qt Creator and Qt Widgets to create a mobile app and run on the device</li>
<li>Differences between desktop and mobile apps including screen size, memory, gestures</li>
<li>Using Qt Widgets in dynamic layouts for easy screen size and orientation changes</li>
<li>Using <kbd>QGraphicsView</kbd> for graphical apps</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello mobile!</h1>
                </header>
            
            <article>
                
<p>So you want to develop apps for mobile and embedded devices using Qt. Excellent choice, as Qt was made for cross-platform development. To get you started, we will run through the basic procedure of using Qt Creator to create, build and run an application. We will briefly examine different aspects to consider when creating mobile and embedded apps, such as how to use Qt Creator to add a menu. Adding a <kbd>QWidget</kbd> in the designer is not that difficult, and I will show you how.</p>
<p>Qt has a long history of running on mobile devices, starting with Qt Embedded, which was initially released in 2000. Qt Embedded was the base framework for the UI Qtopia, which was initially released on the Sharp Zaurus on the SL-5000D developer edition.</p>
<p>These days, you can develop an application using Qt and sell it in the iOS App Store, Android Google Play store, or other Linux mobile phones. Qt apps run on TVs and you can even see them running on entertainment systems in cars and planes. It runs on medical devices as well as industrial automation machines on factory floors.</p>
<p>There are considerations for using Qt on mobile and embedded devices such as memory constraints and display size constraints. Mobiles have touchscreens, and embedded devices might not have screens at all. </p>
<p>When you install Qt, you can use the Qt Creator IDE to edit, build and run your code. It's free and open source, so you can even customize it. I once had a patch that customized Qt Creator in a way that would allow me to print out all the keyboard commands that is was using, so I could have a quick reference sheet. Let's take a quick look at Qt Creator, that was once known as Workbench.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt Creator</h1>
                </header>
            
            <article>
                
<p><span><span>We are</span></span> not going to go into any great detail about Qt Creator, but I thought I should mention it to demonstrate how we could go about using it to develop a cross-platform <kbd>QWidget</kbd> based application that runs on a desktop and mobile platform. Some differences between the two will be discussed. We'll then demonstrate how using dynamic layouts can help you target many different screen sizes and handle device orientation changes. You might already be familiar with Qt Creator, so we will refresh your memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic Qt Creator procedure</h1>
                </header>
            
            <article>
                
<p class="p1">The basic procedure for cross-compiling and building apps that run on a mobile device are straight forward after you get set up. The procedure that we would hypothetically follow is:</p>
<ol>
<li class="p1"><span class="packt_screen">File</span> | <span class="packt_screen">New File</span> <span class="packt_screen">or</span> <span class="packt_screen">Project...</span> | <span class="packt_screen">Qt Widgets Application</span>, click the <span class="packt_screen">Choose...</span> button</li>
<li>Write some amazing code</li>
<li class="p1">Select the <span class="packt_screen">Projects</span> icon on the left side of <span class="packt_screen">Qt Creator</span>, then pick which target platform you want like <span class="packt_screen">Qt 5.12.0</span> <span class="packt_screen">for iOS</span></li>
<li class="p1">Hit <em>Ctrl</em> + <em>B</em>, or <em>Command</em> +<span class="s1"> <em>B</em> to build</span></li>
<li class="p1">Hit <em>Ctrl</em> + <em>R</em>, o<span class="s4">r</span> <em>Command </em>+ <em>R</em><span class="s3"> to run</span></li>
<li>Hit <em>F5</em>, or <em>Command</em> + <em>Y</em> to debug</li>
</ol>
<p class="p1">For this first chapter, we will use Qt Widgets, which are UI elements that are more closely aligned to traditional desktop computer applications. They are still useful for mobile and embedded devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt Designer</h1>
                </header>
            
            <article>
                
<p>Qt Creator comes with a design tool named Qt Designer. When you create a new template application, you will see a list of files on the left. It will open your application form in Qt Designer when you click on any <kbd>.ui</kbd> file.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter01-a</kbd><span> directory, in the </span><kbd>cp1</kbd><span> branch.</span></div>
<p class="p1">Navigate to <span class="packt_screen">Forms</span> | <span class="packt_screen">mainwindow.ui</span> and double click on that. This will open the UI file in Qt Creators Designer. A UI file is just a text file in the form of XML, and you can edit that file directly if you choose. The following image shows how it looks when opened in Qt Designer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1bead9f6-e9bb-419f-9340-5a7bcf8e06bb.png"/></p>
<p>Let's start with something just about every desktop application has—a <span class="packt_screen">Menu</span>. Your mobile or embedded application might even need a <span class="packt_screen">Menu</span>. As you can see, there is a template <span class="packt_screen">Menu</span> that the Qt app wizard has produced for us. We need to customize this to make it usable. We can add some sub-menu items to demonstrate basic Qt Creator functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Add a QMenu</h1>
                </header>
            
            <article>
                
<p><span>Click on the application form where it says</span> <span class="packt_screen">Menu</span> <span>to add menu items. Type in something like</span> <kbd>Item1</kbd><span>, hit <em>Enter</em>. Add another menu item, as demonstrated in the following image:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82d969a7-759d-4030-b93a-c91190d4a7c1.png" style="width:8.42em;height:5.67em;"/></p>
<p>If you were to build this now, you would have an empty application with a <span class="packt_screen">Menu</span>, so let's add more to demonstrate how to add widgets from the list of widgets that is on the left side of Qt Creator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Add QListView</h1>
                </header>
            
            <article>
                
<p>Our UI form needs some content. We will build and run it for the desktop, then build and run it for the mobile simulator to compare the two. The procedure here is easy as drag and drop. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>On the left side of Qt Creator is a list of <span class="packt_screen">Widgets</span>, <span class="packt_screen">Layouts</span> and <span class="packt_screen">Spacers</span> that you can simply drag and drop to place onto the template form and create your masterpiece Qt application. Let's get started:</span></p>
<ol>
<li class="p1">Drag a <span class="packt_screen">ListView</span> and drop it on the form.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5406742a-752d-4b14-aef1-e23ed79bc91f.png"/></p>
<ol start="2">
<li class="p1 CDPAlignLeft CDPAlign">Select <span class="packt_screen">Desktop</span> kit and build and run it by hitting the Run button. Qt Creator can build and run your application in the same step if you have made any changes to the form or source code. When you run it, the application should look similar to this image:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe198551-16f7-47ae-8020-da8a2b260b7f.png" style="width:15.75em;height:14.50em;"/></p>
<p>That's all fine and dandy, but it is not running on anything small like a phone.</p>
<p>Qt Creator comes with iOS and Android simulators, which you can use to see how your application will run on a small screened device. It is not an emulator, which is to say it does not try to emulate the device hardware, but simply simulates the machine. In effect, Qt Creator is building and running the target architectures.</p>
<ol start="3">
<li class="p1 CDPAlignLeft CDPAlign">Now select <span class="packt_screen">iOS Simulator</span> kit, or <kbd>Android</kbd> from the <span class="packt_screen">Projects</span> tool in green, as seen in the following image:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"> <img style="font-size: 1em;width:5.00em;height:23.25em;" src="assets/72629807-bb30-405a-ab3a-2cbacfc573d0.png"/></p>
<ol start="4">
<li><span>Build and run it, which will start it in the simulator.</span></li>
</ol>
<p class="mce-root"/>
<p>Here is this app running on the iOS simulator:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/679053a5-fd4a-4a8c-8bfa-6bf647c0eae1.png" style="width:25.25em;height:47.83em;"/> </p>
<p class="p1">There you go! You made a mobile app! Feels good, doesn't it? As you see, it looks slightly different in the simulator. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going smaller, handling screen sizes</h1>
                </header>
            
            <article>
                
<p>Porting applications which were developed for the desktop to run on smaller mobile devices can be a daunting task, depending on the application. Even creating new apps for mobiles, a few considerations need to be made, such as differences in screen resolution, memory constraints, and handling orientation changes. Touch screens add another fantastic way to offer touch gestures and can be challenging due to the differences in the size of a finger as point compared to a mouse pointer. Then there are sensors, GPS and networking to contemplate! </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Screen resolution</h1>
                </header>
            
            <article>
                
<p class="p1">As you can see in the previous images in the <em>Add QListView</em> section, the application paradigms are fairly different between desktop and mobile phones. When you move to an even smaller display, things start to get tricky in regards to fitting everything on the screen.</p>
<p class="p1">Luckily, there are Qt Widgets that can help. The C++ classes <kbd>QScrollArea</kbd>, <kbd>QStackedWidget</kbd> and <kbd>QTabbedWidget</kbd> can show content more appropriately. Delegating your on-screen widgets to different pages will allow your users the same ease-of-navigation which a desktop application allows.</p>
<p class="p1">There might also be an issue on mobile devices while using <kbd>QMenu</kbd>. They can be long, unruly and have a menu tree that drills down too deeply for a small scre<span>en</span>. Here's a menu which works well on a desktop:</p>
<p class="p1 CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:30.67em;height:19.50em;" src="assets/c1a1a823-53bb-46ab-a397-515e73f002b5.png"/></p>
<p>On a mobile device, the last items on this menu become unreachable and unusable. We need to redesign this!</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d1788e62-d176-4bd3-a9c6-07fa94a416d6.png" style="width:25.50em;height:45.67em;"/></p>
<p class="mce-root"/>
<p class="p1">Menus can be fixed by eliminating them or refactoring them to reduce their depth, or by using something like a <kbd>QStackedWidget</kbd> to present the <span class="packt_screen">Menu</span> options.</p>
<p class="mce-root"/>
<p class="p1">Qt has support for high (<strong>Dots Per Inch</strong>) <strong><span>DPI</span></strong> displays. Newer versions of Qt automatically compensate for differences between high DPI and low DPI displays for iOS and the Wayland display server protocol. For Android, the environmental variable <kbd>QT_AUTO_SCALE_FACTOR</kbd> needs to be set to true. To test different scale factors, set <kbd>QT_SCALE_FACTOR</kbd>, which works best with an integer, typically 1 or 2.</p>
<p>Let's run through a few examples of widgets and how they can be better used on differing screens:</p>
<ul>
<li>Widgets like <kbd>QScrollBar</kbd> can be increased in size to better accommodate a finger as pointer, or better yet be hidden and use the widget itself to scroll. The UI usually needs to be simplified.</li>
<li>Long <kbd>QListViews</kbd> can present some challenges. You can try to filter or add a search feature for such long lists to make the data more accessible and eye pleasing on smaller displays.</li>
<li>Even <span><kbd>QStackedWidget</kbd> or <kbd>QTabbedWidget</kbd> can be too big. Don't make the user flick left or right more than a few pages. Anything more can be cumbersome and annoying for the user to be flicking endlessly to get at content.</span></li>
<li><kbd>QStyleSheets</kbd> are a good way to scale for smaller display's, allowing the developer to specify customizations to any widget. You can increase the padding and margins to make it easier for finger touch input. You can either set a style on a specific widget or apply it to the entire <kbd>QApplication</kbd> for a certain class of widget.</li>
</ul>
<pre>qApp-&gt;setStyleSheet("QButton {padding: 10px;}");</pre>
<p>or for one particular widget it would be:</p>
<pre>myButton-&gt;setStyleSheet("padding: 10px;");</pre>
<p>Let's apply this only when there is a touch screen available on the device. It will make the button slightly bigger and easier to hit with a finger:</p>
<pre>if (!QTouchScreen::devices().isEmpty()) {<br/>   qApp-&gt;setStyleSheet("QButton {padding: 10px;}");<br/>}</pre>
<div class="packt_tip">If you set one style with a style sheet, you will most likely need to customize the other properties and sub-controls as well. Applying one style sheet removes the default style.</div>
<p>Of course, it is also easy to set a style sheet in Qt Designer, just right click on the target widget and select, <span class="packt_screen">Change styleSheet</span> from the context menu. As seen here on the Apple Mac:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/97df5f88-44e3-4546-bdda-d93a8e20977a.png" style="width:34.67em;height:32.17em;"/></div>
<p>Mobile phones and embedded devices have smaller displays, and they also have less RAM and storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory and storage</h1>
                </header>
            
            <article>
                
<p class="p1">Mobile phones and embedded devices usually have less memory than desktop machines.<span class="Apple-converted-space"> </span>Especially for embedded devices both RAM and storage are limited.</p>
<p class="p1">The amount of storage space used can be lowered by optimizing images, compressing if needed. If different screen sizes are not used, the images can by manually resized instead of scaling at runtime.</p>
<p class="p1">There are also heap vs stack considerations which generally always pass arguments into functions by reference by using the <kbd>&amp;</kbd> (ampersand) operator. You will notice this in the majority of Qt code.</p>
<p class="p1">Compiler optimizations can greatly effect both performance and the size of executables. In general, Qt's <kbd>qmake mkspec</kbd> build files are fairly good at using the correct optimizations.</p>
<p class="p1">If storage space is a critical consideration, then building Qt yourself is a good idea. Configuring Qt using the <kbd>-no-feature-*</kbd> to configure out any Qt features you might not need is a good way to reduce it's footprint. For example, if a device has one static Ethernet cable connection and does not need network bearer management, simply configure Qt using <kbd>-no-feature-bearermanagement</kbd>. If you know you are not using SQL why ship those storage using libraries? Running configure with <kbd>--list-features</kbd> argument will list all the features available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Orientation</h1>
                </header>
            
            <article>
                
<p class="p1">Mobile devices move around (whodathunkit?) and sometimes it is better to view a particular app in landscape mode instead of portrait. On Android and iOS, responding to orientation changes are built in and occurs by default according to the users configuration. One thing you might need to do, is actually disable the orientation change. </p>
<p>On <strong>iOS</strong>, you need to edit the <kbd>plist.info</kbd> file. For the key <span class="n"><kbd>UISupportedInterfaceOrientations</kbd>, you need to add the following:</span></p>
<pre>&lt;array&gt;&lt;string&gt;UIInterfaceOrientationLandscapeLeft&lt;/string&gt;&lt;/array&gt;</pre>
<p>On <strong>Android</strong>, edit the <span><kbd>AndroidManifest.xml</kbd> file <kbd>android:screenOrientation="landscape"</kbd></span></p>
<p class="p1">If a picture frame device has a custom-built operating system, it might need it's photo viewing app to respond when the user switches orientations. That's where Qt Sensors can help out. More on that later in the first section of <a href="0a6e358d-e771-458e-b68f-380149f259a0.xhtml">Chapter 7</a>, <em>Machines Talking</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gestures</h1>
                </header>
            
            <article>
                
<p class="p1">Touchscreen gestures are another way mobiles are different to desktops. Multi-touch screens have revolutionized the device world. <kbd>QPanGesture</kbd>, <kbd>QPinchGesture</kbd> and <kbd>QSwipeGesture</kbd> <span class="s2">can be used to great effect on these devices, and Qt Quick has components build for this type of thing—<kbd>Flickable</kbd>, <kbd>SwipeView</kbd>, <kbd>PinchArea</kbd> and others. More on Qt Quick later.</span></p>
<p>To use <kbd>QGestures</kbd>, first create a <kbd>QList</kbd> of containing the gestures you want to handle, and call the <kbd>grabGesture</kbd> function for the target widget.</p>
<pre><span>QList</span>&lt;<span>Qt</span>::<span>GestureType</span>&gt;<span> </span>gestures;<br/>gestures<span> </span><span>&lt;&lt;</span><span> </span>Qt::PanGesture;<br/>gestures<span> </span><span>&lt;&lt;</span><span> </span>Qt::PinchGesture;<br/>gestures<span> </span><span>&lt;&lt;</span><span> </span>Qt::SwipeGesture;<br/><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="type"><a href="http://doc.qt.io/qt-5/qt.html"><span class="typ">Qt</span></a></span><span class="operator"><span class="pun">::</span></span><span class="typ">GestureType</span><span class="pln"> gesture :</span><span class="pln"> gestures</span><span class="pun">)</span><span class="pln">
    someWidget-&gt;grabGesture</span><span class="pun">(</span><span class="pln">gesture</span><span class="pun">);</span></pre>
<p>You will need to derive from and then override the widgets event loop to handle when the event happens.</p>
<pre><span>bool</span><span> </span><span>SomeWidget</span>::<span>event</span>(<span>QEvent</span><span> </span><span>*</span>event)<br/>{<br/><span>    </span><span>if</span><span> </span>(event<span>-&gt;</span>type()<span> </span><span>==</span><span> </span><span>QEvent</span>::<span>Gesture</span>)<br/><span>        </span><span>return</span><span> handleG</span>esture(<span>static_cast</span>&lt;<span>QGestureEvent </span><span>*</span>&gt;(event));<br/><span>    </span><span>return</span><span> </span>QWidget::event(event);<br/>}</pre>
<p>To do something useful with the gesture, we could handle it like this:</p>
<pre><span>if</span><span> </span>(<span>QGesture</span><span> </span><span>*</span>swipe<span> </span><span>=</span><span> </span>event<span>-&gt;</span>gesture(<span>Qt</span>::<span>SwipeGesture</span>)) {<br/>    if (<span>swipe-&gt;</span>state()<span> </span><span>==</span><span> </span>Qt::GestureFinished)<span> </span>{<br/><span>        </span><span>switch</span><span> </span>(gesture<span>-&gt;</span>horizontalDirection()) {<br/>            case <span>QSwipeGesture</span>::<span>Left:<br/>            break;<br/></span>            case <span>QSwipeGesture</span>::<span>Right:<br/>            break;<br/></span>            case <span>QSwipeGesture</span>::Up<span>:<br/>            break;<br/></span>            case <span>QSwipeGesture</span>::<span>Down:<br/>            break;<br/></span>        }<br/>    }<br/>}</pre>
<p class="p3"><span class="s3">Devices with sensors also have access to <kbd>QSensorGesture</kbd>, which enable motion gestures such as shake. More on that later, in <span class="cdp-organizer-chapter-number"><a href="0a6e358d-e771-458e-b68f-380149f259a0.xhtml">Chapter 7</a>,</span><span> </span><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label"><em>Machines Talking</em>.</span></span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic layouts</h1>
                </header>
            
            <article>
                
<p class="p1">Considering that mobile phones come in all shapes and sizes, it would be ridiculous to need to provide a different package for every different screen resolution. Hence we will use dynamic layouts.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter01-layouts</kbd><span> directory, in the </span><kbd>cp1</kbd><span> branch.</span></div>
<p class="p1">Qt Widgets have support for this using classes such as <kbd>QVBoxLayout</kbd> and <kbd>QGridLayout</kbd>.</p>
<p class="p1">Qt Creator's designer is the easiest way to develop dynamic layouts. Let's go through how we can do that.</p>
<p>To set up a layout, we position a widget on the application form, and press <em>Command</em> or <em>Control</em> on the keyboard while selecting the widgets that we want to put in a layout. Here are two <kbd>QPushButtons</kbd> selected for use:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2d581605-39ce-43db-a05a-0598e7abfd38.png"/></p>
<p class="mce-root"/>
<p class="p1">Next, click on the <span class="packt_screen">Horizontal Layout</span> icon highlighted here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d41f07bf-9db4-4e1c-9ffe-45fb8867935f.png"/></p>
<p class="CDPAlignLeft CDPAlign"><span>You will then see the two widgets enclosed by a thin red box as in</span> the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dd780f36-b362-4146-9bb6-c1851af0f4dc.png" style="width:17.67em;height:5.00em;"/></p>
<p>Now repeat this for the remaining widgets.</p>
<p>To make the widgets expand and resize with the form, click on the background and select <span class="packt_screen">Grid Layout:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b78d085-2083-451f-9e1d-2802abe677df.png"/></p>
<p class="p1">Save and build this, and this app will now be able to resize for orientation changes as well as being able to work on different sized screens. Notice how this looks like in portrait (vertical) orientation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/507a6a4b-2153-489e-9f71-eb2c6452e54b.png" style="width:20.83em;height:45.08em;"/></p>
<p>Also note how this same application looks in landscape (horizontal) orientation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/709eb346-27da-49b3-910a-e298d7bf7408.png" style="width:50.33em;height:23.25em;"/></p>
<p>As you can see, this application can change with orientation changes, but all the widgets are visible and usable. Using <kbd>QSpacer</kbd> will help guide the widgets and layouts positioning. They can push the widgets together, apart, or hold some to one side or another.</p>
<p>Of course, layouts can be used without touching Qt Designer. For example the following code:</p>
<pre>QPushButton *button = new QPushButton(this);<br/>QPushButton *button2 = new QPushButton(this);<br/>Q<span>BoxLayout </span><span>*boxL</span><span>ayout </span><span>=</span><span> </span><span>new</span><span> QVBoxLayout;<br/>boxLayout-&gt;addWidget(button);<br/>boxLayout-&gt;addWidget(button2);<br/>QHBoxLayout *horizontalLayout = new QHBoxLayout;<br/></span><span>horizontalLayout-&gt;setLayout(boxLayout);</span><span> </span></pre>
<p><kbd>QLayout</kbd> and friends are the key to writing a cross-platform application that can <span>accommodate</span> the myriad screen resolutions and dynamically changing orientations of the target devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Graphics view</h1>
                </header>
            
            <article>
                
<p class="p1"><kbd>QGraphicsView</kbd>, <kbd>QGraphicScene</kbd> and <kbd>QGraphicsItem</kbd> provide a way for applications based on Qt Widgets to show 2D graphics.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter01-graphicsview</kbd><span> directory, in the </span><kbd>cp1</kbd><span> branch.</span></div>
<p>Every <kbd>QGraphicsView</kbd> needs a <kbd>QGraphicsScene</kbd>. Every <kbd>QGraphicsScene</kbd> needs one or more <kbd>QGraphicsItem</kbd>.</p>
<p><kbd>QGraphicsItem</kbd> can be any of the following: </p>
<ul>
<li><kbd><span>QGraphicsEllipseItem</span></kbd></li>
<li><kbd><span>QGraphicsLineItem</span></kbd></li>
<li><kbd><span>QGraphicsLineItem</span></kbd></li>
<li><kbd><span>QGraphicsPathItem</span></kbd></li>
<li><kbd><span>QGraphicsPixmapItem</span></kbd></li>
<li><kbd><span>QGraphicsPolygonItem</span></kbd></li>
<li><kbd><span>QGraphicsRectItem</span></kbd></li>
<li><kbd><span>QGraphicsSimpleTextItem</span></kbd></li>
<li><kbd>QGraphicsTextItem</kbd></li>
</ul>
<p>Qt Designer has support for adding <kbd>QGraphicsView</kbd> . You can follow these steps to do so:</p>
<ol>
<li>Drag the <kbd>QGraphicsView</kbd> to a new application form and fill the form with a <kbd>QGridLayout</kbd> like we did before.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d3ee54ba-fcb9-4e35-8eb2-23bde797938a.png" style="width:16.00em;height:15.58em;"/></p>
<ol start="2">
<li>Implement a <kbd>QGraphicsScene</kbd> in the source code and add it to the <kbd>QGraphicsView</kbd></li>
</ol>
<pre style="padding-left: 60px"><span>QGraphicsScene *</span><span>gScene</span><span> </span>=<span> </span><span>new</span><span> </span><span>QGraphicsScene</span>(<span>this</span>);<br/><span>ui</span>-&gt;<span>graphicsView</span>-&gt;<span>setScene</span>(<span>gScene</span>);</pre>
<ol start="3">
<li>Define a rectangle which will be the extent of the <kbd>Scene</kbd>. Here it is smaller than the size of the graphics view so we can go on and define some collision detection.</li>
</ol>
<pre style="padding-left: 60px">gScene-&gt;setSceneRect(-50, -50, 120, 120);<br/><br/></pre>
<ol start="4">
<li>Create a red rectangle to show the bounding rectangle. To make it a red color, create a <kbd>QPen</kbd> which will be used to paint the rectangle and then add the rectangle to the <kbd>Scene</kbd>. </li>
</ol>
<pre style="padding-left: 60px"><span>QPen</span><span> </span><span>pen</span><span> </span>=<span> </span><span>QPen</span>(<span>Qt</span>::<span>red</span>);<br/><span>gScene</span>-&gt;<span>addRect</span>(<span>gScene</span>-&gt;<span>sceneRect</span>(),<span> </span><span>pen</span>);</pre>
<ol start="5">
<li>Build and run the application. You will notice an app with a red bordered square on it.</li>
</ol>
<p>As mentioned before, <kbd>QGraphicsView</kbd> shows <kbd>QGraphicsItems</kbd>. If we want to add some collision detection we need to subclass <span><kbd>QGraphicsSimpleTextItem</kbd>.</span></p>
<p>The header file for this is as follows:</p>
<pre><span>#include</span><span> </span><span>&lt;QGraphicsScene&gt;<br/></span><span>#include</span><span> </span><span>&lt;QGraphicsSimpleTextItem&gt;<br/></span><span>#include</span><span> </span><span>&lt;QGraphicsItem&gt;<br/></span><span>#include</span><span> </span><span>&lt;QPainter&gt;<br/></span>class<span> </span><span>TextGraphic</span><span> </span><span>:</span><span>public</span><span> </span><span>QGraphicsSimpleTextItem<br/></span>{<br/><span>public</span>:<br/><span>    </span><span>TextGraphic</span>(<span>const</span><span> </span><span>QString</span><span> </span>&amp;<span>text</span>);<br/>    <span>void</span><span> </span><span>paint</span><span>(</span><span>QPainter</span><span> </span><span>*</span><span>painter</span><span>,</span><span> </span><span>const</span><span> </span><span>QStyleOptionGraphicsItem</span><span> </span><span>*</span><span>option</span><span>,</span><span> </span><span>QWidget</span><span> </span><span>*</span><span>widget</span><span>);<br/></span><span>    </span><span>QString</span><span> </span><span>simpleText</span>;<br/>};</pre>
<p>This custom class derived from <span><kbd>QGraphicsSimpleTextItem</kbd> will reimplement the <kbd>paint(..)</kbd> function, and use the </span><kbd>collidingItems(...)</kbd> <span>function of</span> <kbd>scene</kbd> <span>to detect when something collides with our text object. Normally, <kbd>collidingItems</kbd> will return a <kbd>QList</kbd> of <kbd>QGraphicsItems</kbd>, but here it is just used to detect if any items are colliding.</span></p>
<p>Since this class holds only one item, it is known which item it is. If a collision is detected, the text changes. We don't need to check if the item's text is different before we change it, as the parent class's <kbd>setText(...)</kbd> does that for us.</p>
<pre><span>TextGraphic</span>::<span>TextGraphic</span>(<span>const</span><span> </span><span>QString</span><span> </span>&amp;<span>text</span>)<br/><span> </span>:<span> </span><span>QGraphicsSimpleTextItem</span>(<span>text</span>),<br/><span>      </span><span>simpleText</span>(<span>text</span>)<br/>{<br/>}<br/><br/>void<span> </span><span>TextGraphic</span><span>::</span><span>paint</span><span>(</span><span>QPainter</span><span> </span><span>*</span><span>painter</span><span>,</span><span> </span><span>const</span><span> </span><span>QStyleOptionGraphicsItem</span><span> </span><span>*</span><span>option</span><span>,</span><span> </span><span>QWidget</span><span> </span><span>*</span><span>widget</span><span>)<br/></span>{<br/><span>    </span><span>if</span><span> </span>(<span>scene</span>()-&gt;<span>collidingItems</span>(<span>this</span>).<span>isEmpty</span>())<br/><span>        </span><span>QGraphicsSimpleTextItem</span>::<span>setText</span>(<span>"BOOM!"</span>);<br/><span>    </span><span>else</span><br/><span>        QGraphicsSimpleTextItem</span>::<span>setText</span>(<span>simpleText</span>);<br/> <br/><span>    QGraphicsSimpleTextItem</span><span>::</span><span>paint</span><span>(</span><span>painter</span><span>, </span><span>option</span><span>, </span><span>widget</span><span>);<br/></span>}</pre>
<p>Now create our <kbd>TextGraphic</kbd> object and add it to the <kbd>Scene</kbd> to use.</p>
<pre><span>T</span><span>extGraphic</span><span> </span>*<span>text</span><span> </span>=<span> </span><span>new</span><span> </span><span>TextGraphic</span>(<span>QStringLiteral</span>(<span>"Qt</span><span> </span><span>Mobile!"</span>));<br/><span>gScene</span>-&gt;<span>addItem</span>(<span>text</span>);</pre>
<p>If you build and run this, notice the <kbd>text</kbd> object will not move if we try to drag it around. <kbd>QGraphicsItems</kbd> have a <kbd>flag</kbd> property called <kbd>QGraphicsItem::ItemIsMovable</kbd> <span>that can be set to allow it to be moved around, either by the user or programmatically:</span></p>
<pre><span>text</span>-&gt;<span>setFlag</span>(<span>QGraphicsItem</span>::<span>ItemIsMovable</span>);</pre>
<p>When we build and run this, you can grab the <kbd>text</kbd> object and move it around. If it goes beyond our bounding rectangle, it will change text, only returning to the original text if it moves inside the red box again.</p>
<p>If you wanted to animate this, just throw in a timer and change the <kbd>text</kbd> object's position when the timer fires.</p>
<p>Even with Qt Quick's software renderer, <kbd>QGraphicsView</kbd> is still a viable solution for graphics animation. If the target device's storage space is really tight, there might not be enough space to add Qt Quick libraries. Or a legacy app might be difficult to import to Qt Quick.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span><span>In this chapter we covered </span></span>some of the issues facing mobile and embedded developers when trying to develop for smaller display devices, and how  <kbd>QStyleSheets</kbd> can be used to change the interface at runtime to adapt itself for using touchscreen inputs.</p>
<p class="mce-root">We discussed storage and memory space requirements, and the need to configure unneeded features out of Qt to make it have a smaller footprint.</p>
<p class="mce-root">We went through handling orientation changes and discussed using screen gestures such as <kbd>Pinch</kbd> and <kbd>Swipe</kbd>.</p>
<p class="mce-root">We learning how to use Qt Designer to add <kbd>QLayouts</kbd> to create dynamically resizing applications.</p>
<p class="mce-root">Finally, we discussed how to use <kbd>QGraphicsView</kbd> to utilize graphical elements such as graphical text and images.</p>
<p>Next, we will go through the next best thing since sliced bread<span> for mobile and embedded development—</span>Qt Quick and QML. Then we'll crack on with the real fancy stuff about graphical effects to spice up any interface!</p>


            </article>

            
        </section>
    </body></html>