<html><head></head><body>
		<div><h1 id="_idParaDest-542" class="chapter-number"><a id="_idTextAnchor542"/>14</h1>
			<h1 id="_idParaDest-543"><a id="_idTextAnchor543"/>Permutations, Partitions, and Heaps</h1>
			<p>This chapter explores some of the most essential yet often overlooked aspects of the algorithmic library<a id="_idIndexMarker842"/> of the C++ <strong class="bold">Standard Template Library </strong>(<strong class="bold">STL</strong>). The chapter sheds light on sequence organization through partitioning, sequence variation via permutations, and the fascinating world of heap-based operations. These operations are the backbone of many advanced algorithms and data structures. By understanding and mastering them, developers can enhance the efficiency of their applications, optimize data handling, and ensure the integrity of their datasets.</p>
			<p>In this chapter, we will cover the following topics related to STL:</p>
			<ul>
				<li>Partitioning</li>
				<li>Permutations</li>
				<li>Heap operations</li>
				<li>Best practices</li>
			</ul>
			<h1 id="_idParaDest-544"><a id="_idTextAnchor544"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-545"><a id="_idTextAnchor545"/>Partitioning</h1>
			<p><strong class="bold">Partitioning</strong>, in<a id="_idIndexMarker843"/> its simplest form, is about organizing sequences based on specific criteria, ensuring that all elements for which the requirements hold true precede those for which it does not. It is about segregating data efficiently, optimizing its organization for rapid access, and enhancing computational efficiency.</p>
			<p>The C++ STL offers a rich set of algorithms for partitioning tasks. While one might be tempted to use simple<a id="_idIndexMarker844"/> loops and conditionals to achieve such tasks, these STL functions are optimized, tested, and designed to offer the best performance. These algorithms are implemented by experts who have a deep understanding of the underlying system, handle the edge cases, and typically take advantage of compiler optimizations and even (potentially) parallelization.</p>
			<h2 id="_idParaDest-546"><a id="_idTextAnchor546"/>std::partition and its power</h2>
			<p>One of the most <a id="_idIndexMarker845"/>foundational functions in this category is <code>std::partition</code>. This function reorganizes elements in a range based on a predicate. It ensures that all elements satisfying the predicate come before those that don’t. But here’s a vital thing to remember: the order of the elements is not guaranteed to be preserved. If order matters to you, then <code>std::stable_partition</code> is your friend. While it may have a slightly higher overhead, it retains the relative order of the elements.</p>
			<p>Let’s look at<a id="_idIndexMarker846"/> an example. Consider a sequence of integers, and suppose you’d like to separate even numbers from odd ones. A call to <code>std::partition</code> with an appropriate lambda can swiftly complete the job, as shown in the following code:</p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {7, 1471414, 3, 18, 9, 518955};
auto it = std::partition(numbers.begin(), numbers.end(), [](int n) { return n % 2 == 0; });</pre>			<p>After this operation, the iterator will iterate over the range of odd numbers.</p>
			<h2 id="_idParaDest-547"><a id="_idTextAnchor547"/>Checking partitions with std::is_partitioned</h2>
			<p>Once a <a id="_idIndexMarker847"/>range is <a id="_idIndexMarker848"/>partitioned, it might be beneficial to ensure that the partitioning holds true, especially in larger systems or when integrating multiple algorithms. Enter <code>std::is_partitioned</code>, a handy function that checks whether a range is partitioned based on a given predicate. This can be particularly useful when building upon multiple operations, ensuring that assumptions about data layout hold firm.</p>
			<h2 id="_idParaDest-548"><a id="_idTextAnchor548"/>The utility of std::partition_point</h2>
			<p>After <a id="_idIndexMarker849"/>partitioning, one might ask, <em class="italic">Where’s the dividing line?</em> That’s where <code>std::partition_point</code> comes into play. This function returns an iterator pointing to the first element in the newly partitioned range, which does not satisfy the predicate. It assumes the range is partitioned and leverages binary search, ensuring a swift response.</p>
			<h2 id="_idParaDest-549"><a id="_idTextAnchor549"/>Partitioning beyond basic sequences</h2>
			<p>While the <a id="_idIndexMarker850"/>preceding examples primarily use vectors, partitioning isn’t limited to them. One can employ these techniques on arrays, lists, and even more advanced containers. However, it is crucial to remember that the underlying container characteristics, such as random access capability, can influence the efficiency of these operations.</p>
			<p>Combining these partitioning functions, one can build efficient, flexible, and highly organized systems<a id="_idIndexMarker851"/> that cater to diverse computational needs. Consider the following real-world applications:</p>
			<ul>
				<li><code>std::is_partitioned</code> and <code>std::partition</code> can be used in various sorting algorithms such as Quicksort and Hoare partitioning. They help in efficiently partitioning elements based on a condition.</li>
				<li><code>std::partition_point</code> can be used in binary search algorithms. It helps find the first element in a partitioned range that doesn’t satisfy a given condition. This can be useful for searching in sorted datasets.</li>
				<li><code>std::partition</code> can efficiently separate elements that meet a condition from those that do not; for example, filtering even and odd numbers from a list.</li>
				<li><code>std::partition</code> can help separate elements into<a id="_idIndexMarker852"/> different partitions based on these criteria.</li>
				<li><code>std::partition</code> can be used to efficiently divide the data based on certain conditions, improving parallelization.</li>
				<li><code>std::partition</code> can be used to partition the data and then analyze the outliers separately.</li>
				<li><strong class="bold">Game development</strong>: In game development, you might use partitioning to separate visible objects from hidden ones for rendering optimization.</li>
				<li><strong class="bold">Database queries</strong>: When querying a database, you can use partitioning to separate the data that matches specific filter conditions from the rest of the dataset.</li>
				<li><strong class="bold">Resource management</strong>: In resource management scenarios, such as memory allocation, you can use partitioning to efficiently segregate used and unused memory blocks efficiently. As developers, we constantly grapple with diverse data and its efficient handling. Partitioning offers a structured way to handle this, enabling optimized organization and rapid data access. While seemingly simple, it forms the backbone of many advanced algorithms.</li>
			</ul>
			<p>By mastering partitioning with the STL, one not only enhances individual operations but elevates the overall efficiency and structure of applications. As we progress to permutations and heap operations in subsequent sections, remember the foundational importance of efficient data organization.</p>
			<h1 id="_idParaDest-550"><a id="_idTextAnchor550"/>Permutations</h1>
			<p>A journey into<a id="_idIndexMarker853"/> permutations is a journey into how the elements of a sequence can be arranged. With the vastness of the sequences and datasets handled by developers today, the ability to organize, shuffle, rotate, and switch elements around becomes a fascinating exercise and a critical requirement for many applications. The C++ STL, with<a id="_idIndexMarker854"/> its power-packed permutation algorithms, offers a path to unlock this potential effortlessly. In this section, we will learn how to generate, manipulate, and rotate permutations, along with practical examples.</p>
			<h2 id="_idParaDest-551"><a id="_idTextAnchor551"/>Generating permutations with std::next_permutation</h2>
			<p>Imagine<a id="_idIndexMarker855"/> listing all possible<a id="_idIndexMarker856"/> permutations of a dataset, analyzing them, and perhaps using them for a brute-force solution to a problem. The STL provides <code>std::next_permutation</code> for this exact purpose. Given a range, this function rearranges its elements to the next lexicographically greater permutation. When all permutations have been exhausted, the function returns <code>false</code>, offering a clear signal to the developer.</p>
			<p>Consider a simple sequence: <code>{1, 2, 3}</code>. With successive calls to <code>std::next_permutation</code>, one can generate <code>{1, 3, 2}</code>, <code>{2, 1, 3}</code>, and so forth until the sequence loops back, as illustrated by the following code:</p>
			<pre class="source-code">
std::vector&lt;int&gt; data = {1, 2, 3};
 do {
  for (int num : data) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
} while (std::next_permutation(data.begin(), data.end()));</pre>			<h2 id="_idParaDest-552"><a id="_idTextAnchor552"/>Predecessor permutations with std::prev_permutation</h2>
			<p>Sometimes, looking<a id="_idIndexMarker857"/> backward is essential, exploring permutations that precede the current<a id="_idIndexMarker858"/> arrangement. The twin to our previously discussed function, <code>std::prev_permutation</code>, does just that. It transforms the sequence into its immediate lexicographically smaller permutation.</p>
			<h2 id="_idParaDest-553"><a id="_idTextAnchor553"/>Shuffling elements randomly with std::shuffle</h2>
			<p>While<a id="_idIndexMarker859"/> structured permutations have their place, there are times when randomness is the order of the day.</p>
			<p>Enter <code>std::shuffle</code>, an<a id="_idIndexMarker860"/> algorithm that rearranges elements in a completely random order. Paired with a robust random number generator, it ensures true randomness, which is crucial for many applications.</p>
			<p>Real-world uses<a id="_idIndexMarker861"/> for <code>std::shuffle</code> include the following:</p>
			<ul>
				<li><code>std::shuffle</code> can be used to achieve this randomness.</li>
				<li><code>std::shuffle</code> can be used to shuffle the answer choices.</li>
				<li><code>std::shuffle</code>, and then pick the first N elements.</li>
				<li><code>std::shuffle</code> can help introduce randomness into the game.</li>
				<li><code>std::shuffle</code> to randomize the order of tracks, providing variety to the listeners.</li>
				<li><code>std::shuffle</code> can be used to shuffle inputs or events to test different code paths.</li>
				<li><strong class="bold">Machine learning and data science</strong>: When training machine learning models or conducting experiments in data science, you may need to shuffle the dataset to ensure that the model doesn’t learn any order-related biases.</li>
				<li><code>std::shuffle</code> can be used to generate the randomization needed for such algorithms.</li>
				<li><code>std::shuffle</code> to simulate random outcomes or the shuffling of cards or dice.</li>
				<li><code>std::shuffle</code> is unsuitable for cryptographic purposes, the concept of shuffling is crucial in cryptographic algorithms for purposes such as card-shuffling functionality for secure card games.</li>
			</ul>
			<h2 id="_idParaDest-554"><a id="_idTextAnchor554"/>Rotating sequences with std::rotate</h2>
			<p>Not all<a id="_idIndexMarker864"/> permutations involve intricate rearrangements. Sometimes, it<a id="_idIndexMarker865"/> is about simple rotations. <code>std::rotate</code> moves elements so that the chosen element becomes the new first element. It’s like turning a dial where the numbers rotate around a central point.</p>
			<p>The following is a simple example demonstrating the use of <code>std::rotate</code>:</p>
			<pre class="source-code">
std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
std::rotate(nums.begin(), nums.begin() + 2, nums.end());
// nums now holds {3, 4, 5, 1, 2}</pre>			<p>Let us now look at the wide range<a id="_idIndexMarker866"/> of real-world applications of <code>std::rotate</code>:</p>
			<ul>
				<li><code>std::rotate</code> can be used to reposition the text efficiently.</li>
				<li><code>std::rotate</code> can be used to swap or cycle image resources.</li>
				<li><strong class="bold">Scheduling and time management</strong>: In scheduling applications, you might want to shift a schedule by rotating the appointments or tasks for a day or a week to accommodate changes.</li>
				<li><code>std::rotate</code> to efficiently manage the movement of data in and out of the buffer.</li>
				<li><code>std::rotate</code> can be used for such bit manipulation.</li>
				<li><code>std::rotate</code> as part of the sorting process to handle partially ordered data efficiently.</li>
				<li><strong class="bold">Image processing</strong>: In image processing, you might need to rotate pixel values to perform image transformations or manipulations.</li>
				<li><code>std::rotate</code> can be used to shift elements in vectors or arrays when solving equations or performing iterative calculations.</li>
				<li><strong class="bold">Memory management</strong>: In memory management scenarios, you might need to shift memory blocks to optimize memory allocation and defragmentation.</li>
				<li><strong class="bold">Algorithm optimization</strong>: In algorithm design, rotating elements can help improve the efficiency of certain operations by reducing the number of swaps or data movements.</li>
				<li><code>std::rotate</code> can be used to simulate the rotation of puzzle pieces.</li>
				<li><code>std::rotate</code> can be employed to create animated effects by rotating or shifting data points.</li>
			</ul>
			<p>Permutations <a id="_idIndexMarker869"/>with the STL bring forth an<a id="_idIndexMarker870"/> exciting blend of mathematical theory and practical computing. They embody the spirit of reorganization, viewing data from different perspectives and ensuring no stone (or sequence!) is left unturned. As we delve deeper into heaps and their operations in the following sections, remember this power of permutation, which can transform and re-envision sequences in countless ways.</p>
			<h1 id="_idParaDest-555"><a id="_idTextAnchor555"/>Heap operations</h1>
			<p>The journey into<a id="_idIndexMarker871"/> algorithmic wonders would be incomplete without exploring heaps. <strong class="bold">Heaps</strong> are unique structures prioritizing data in a specific order, ascending or descending. At the heart of a heap lies its promise: the element with the highest (or lowest) priority will always be at the top. With the C++ STL, managing heaps becomes intuitive, lending efficiency and power to applications requiring priority-based operations.</p>
			<h2 id="_idParaDest-556"><a id="_idTextAnchor556"/>Constructing heaps with std::make_heap</h2>
			<p>Creating a <a id="_idIndexMarker872"/>heap from a random data collection is the first step in the process. With <code>std::make_heap</code>, one can swiftly transform <a id="_idIndexMarker873"/>any sequence into a max heap, where the largest element is at the beginning. The following code demonstrates the use of <code>std::make_heap</code>:</p>
			<pre class="source-code">
std::vector&lt;int&gt; v = {3, 7, 2, 5, 1, 7, 4, 9};
std::make_heap(v.begin(), v.end());</pre>			<p>With the simple call above, our <code>v</code> vector now holds a valid max heap. Based on the given comparator or default comparison, the most significant element will always be at the front.</p>
			<h2 id="_idParaDest-557"><a id="_idTextAnchor557"/>Adding and removing elements – std::push_heap and std::pop_heap</h2>
			<p>With heaps, the <a id="_idIndexMarker874"/>operations aren’t just about<a id="_idIndexMarker875"/> looking at the top element. Adding and removing data from the heap is fundamental. When a new element is <a id="_idIndexMarker876"/>added to the underlying sequence, <code>std::push_heap</code> ensures it is placed appropriately in the heap, as shown in the following code:</p>
			<pre class="source-code">
v.push_back(8);  // Add element to vector
std::push_heap(v.begin(), v.end());  // Re-adjust the heap</pre>			<p>Conversely, to<a id="_idIndexMarker877"/> remove the top element, <code>std::pop_heap</code> is used. This function doesn’t erase the element but moves it to the end of the sequence, making it convenient for removal, as illustrated in the following code:</p>
			<pre class="source-code">
std::pop_heap(v.begin(), v.end());
v.pop_back();  // Remove the former top element</pre>			<p>Adding and removing elements from a heap is the core of heap-based operations. Now, let’s move on to something a bit more advanced: heap-based sorting.</p>
			<h2 id="_idParaDest-558"><a id="_idTextAnchor558"/>Heap-based sorting – the power of std::sort_heap</h2>
			<p>Heaps <a id="_idIndexMarker878"/>are more than just priority <a id="_idIndexMarker879"/>management. Their structure allows for an efficient sorting mechanism. <code>std::sort_heap</code> turns the heap into a sorted range in ascending order, as shown in the following code:</p>
			<pre class="source-code">
std::sort_heap(v.begin(), v.end());</pre>			<p>It’s worth noting that heap-based sorting can be especially effective when dealing with datasets where insertion and extraction operations are frequent, making it a valuable tool in a developer’s toolkit.</p>
			<h2 id="_idParaDest-559"><a id="_idTextAnchor559"/>Checking heap validity with std::is_heap</h2>
			<p>Ensuring<a id="_idIndexMarker880"/> that a sequence maintains its heap<a id="_idIndexMarker881"/> properties is crucial. <code>std::is_heap</code> offers a quick validity check, returning <code>true</code> if the given range forms a heap and <code>false</code> otherwise, as shown in the following code:</p>
			<pre class="source-code">
bool isHeap = std::is_heap(v.begin(), v.end());</pre>			<p>This function is especially valuable when working with complex sequences, ensuring data operations haven’t disrupted the heap structure.</p>
			<h2 id="_idParaDest-560"><a id="_idTextAnchor560"/>The significance of heaps in today’s computing</h2>
			<p>Heaps <a id="_idIndexMarker882"/>are integral in modern-day computing, from task scheduling to network packet management. Their structure facilitates efficient priority management, making them indispensable in scenarios including simulations, event-driven programming, and more.</p>
			<p>These heap-based <a id="_idIndexMarker883"/>operations can be used in many real-world scenarios:</p>
			<ul>
				<li><code>std::priority_queue</code> container employs a heap internally to effectively manage the highest-priority element at the fore.</li>
				<li><strong class="bold">Job scheduling</strong>: In job scheduling algorithms, tasks or jobs often have associated priorities or deadlines. A min-heap can be used to prioritize and schedule tasks efficiently.</li>
				<li><strong class="bold">Dijkstra’s shortest path algorithm</strong>: Dijkstra’s algorithm for finding the shortest path in a weighted graph uses a priority queue implemented with a min-heap to select the next vertex to explore.</li>
				<li><strong class="bold">Huffman coding</strong>: A popular data compression technique, Huffman coding builds a binary tree with characters’ frequencies as weights. A min-heap can be used to efficiently merge nodes during tree construction.</li>
				<li><strong class="bold">Heap sort</strong>: Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure to repeatedly extract the maximum (for a max-heap) or minimum (for a min-heap) element from an unsorted array, resulting in a sorted array. It is an in-place sorting algorithm with a time complexity of <em class="italic">O(n </em><em class="italic">log n)</em>.</li>
				<li><strong class="bold">Event scheduling</strong>: In<a id="_idIndexMarker884"/> discrete event simulation or real-time systems, events often have associated timestamps. A min-heap can be used to schedule and process events in chronological order.</li>
				<li><strong class="bold">Memory management</strong>: Dynamic memory allocation and deallocation in some memory management systems use heaps to efficiently allocate and free memory blocks.</li>
				<li><strong class="bold">Load balancing:</strong> Tasks or processes are distributed among available resources in load balancing algorithms. A min-heap can help manage resource availability and task assignment.</li>
				<li><strong class="bold">Online median calculation</strong>: When processing a continuous stream of data, you can maintain two heaps (a max-heap and a min-heap) to calculate the median of the data efficiently.</li>
				<li><strong class="bold">Merge sorted files</strong>: When merging multiple sorted files or streams, a min-heap can be used to select the smallest element among all available elements, facilitating the merge process.</li>
				<li><strong class="bold">Disk space management</strong>: In file systems, managing free disk space efficiently often involves maintaining a heap of available disk blocks.</li>
				<li><strong class="bold">Job prioritization in print queues</strong>: Print job queues can prioritize print jobs based on various factors such as user priority or document size, which can be efficiently managed using a priority queue implemented with a heap.</li>
			</ul>
			<p>The heap operations provided by the C++ STL equip developers with the means to handle priority-driven tasks efficiently. They merge the theoretical elegance of data structures with practical utility. As we transition to best practices in the next section, it is essential to internalize the role heaps play in shaping efficient, responsive, and reliable applications.</p>
			<h1 id="_idParaDest-561"><a id="_idTextAnchor561"/>Best practices</h1>
			<p>Navigating <a id="_idIndexMarker885"/>permutations, partitions, and heaps offers valuable insights into the capabilities of the C++ STL. These foundational elements can significantly boost application performance and reliability when used effectively. Following best practices is critical to maximizing these benefits and ensuring consistent, optimized data operations. These best practices include the following:</p>
			<ul>
				<li><strong class="bold">Simplify permutation tasks</strong>: Though permutations provide a broad range of sequence variations, it’s important not to overcomplicate the process. Choose permutation operations that directly serve the task at hand. For intricate operations, breaking them down can help maintain clarity and focus.</li>
				<li><code>std::next_permutation</code> and <code>std::prev_permutation</code> to traverse permutations. Utilizing these functions eliminates the need to generate permutations manually and promotes efficient and error-free operations.</li>
				<li><strong class="bold">Optimal partitioning</strong>: A precise and unambiguous predicate is essential when dividing data. Unclear criteria can yield unpredictable partitions and potentially decrease application efficiency. Being familiar with your data’s characteristics can aid in effective partitioning. If the data has inherent order or structure, it’s advantageous to factor that into the partitioning algorithms to enhance performance and reduce resource use.</li>
				<li><strong class="bold">Maintain comparator consistency</strong>: For heap operations, using comparators consistently is crucial. Any inconsistency in their use can disturb the heap structure and lead to unexpected results. For example, suppose you use one comparator to build a max-heap and switch to a different comparator for extracting elements. In that case, the heap’s structure might be disturbed, and you might not get the expected maximum element.</li>
				<li><code>std::push_heap</code> and <code>std::pop_heap</code> to preserve heap integrity.</li>
				<li><code>std::sort</code> may be more efficient for more static datasets.</li>
			</ul>
			<p>These <a id="_idIndexMarker886"/>partitioning, permutation, and heap concepts can significantly improve application performance and reliability. Simplifying permutation tasks to avoid complexity, utilizing STL permutation functions for efficiency, ensuring clear criteria for data partitioning, maintaining comparator consistency for heap operations, prioritizing heap access with appropriate functions, and choosing sorting methods based on the dataset’s characteristics and update frequency are all helpful. Following best practices in these areas is essential for maximizing the benefits of the C++ STL and ensuring consistent and optimized data operations in programming.</p>
			<h1 id="_idParaDest-562"><a id="_idTextAnchor562"/>Summary</h1>
			<p>Throughout this chapter, we have covered the manipulation of sequences. We explored partitioning techniques, which organize data based on specific predicates, and examined various permutation algorithms that enable reordering elements within a range. We also investigated the heap operations provided by STL, which facilitate priority queue implementations and efficient sorting.</p>
			<p>Understanding these operations is essential for developers because they underpin many higher-level algorithms and are foundational to efficient data processing. Mastery of partitioning allows for quick segregation of data, permutations enable the exploration of all possible orderings of a dataset, and heaps provide a means to maintain a collection always sorted by priority. These tools are fundamental for tasks requiring optimized data retrieval, manipulation, and organization.</p>
			<p>In the next chapter, we will explore the range concept, which offers a more expressive approach to handling sequences of elements. The chapter will discuss the advantages of range-based operations for sorting and searching algorithms, highlighting their enhanced composability and readability. As we progress into this chapter, we will gain insights into the practical application of these modern techniques, ensuring our continued growth as adept and contemporary C++ developers.</p>
		</div>
	</body></html>