["```cpp\n// Example 01\nclass B {\n  public:\n  B() : i_(0) {}\n  virtual ~B() {}\n  virtual void f(int i) = 0;\n  int get() const { return i_; }\n  protected:\n  int i_;\n};\nclass D : public B {\n  public:\n  void f(int i) override { i_ += i; }\n};\n```", "```cpp\n// Example 01\nclass A {\n  public:\n  A() : i_(0) {}\n  void f(int i) { i_ += i; }\n  int get() const { return i_; }\n  protected:\n  int i_;\n};\n```", "```cpp\nvoid BM_none(benchmark::State& state) {\n  A* a = new A;\n  int i = 0;\n  for (auto _ : state) a->f(++i);\n  benchmark::DoNotOptimize(a->get());\n  delete a;\n}\nvoid BM_dynamic(benchmark::State& state) {\n  B* b = new D;\n  int i = 0;\n  for (auto _ : state) b->f(++i);\n  benchmark::DoNotOptimize(b->get());\n  delete b;\n}\n```", "```cpp\nvoid BM_dynamic(benchmark::State& state) {\n  D d;\n  int i = 0;\n  for (auto _ : state) d.f(++i);\n  benchmark::DoNotOptimize(b->get());\n}\n```", "```cpp\n#define REPEAT2(x) x x\n#define REPEAT4(x) REPEAT2(x) REPEAT2(x)\n#define REPEAT8(x) REPEAT4(x) REPEAT4(x)\n#define REPEAT16(x) REPEAT8(x) REPEAT8(x)\n#define REPEAT32(x) REPEAT16(x) REPEAT16(x)\n#define REPEAT(x) REPEAT32(x)\n```", "```cpp\nREPEAT(b->f(++i);)\n```", "```cpp\nstate.SetItemsProcessed(32*state.iterations());\n```", "```cpp\nBenchmark           Time UserCounters...\nBM_none          1.60 ns items_per_second=19.9878G/s\nBM_dynamic       9.04 ns items_per_second=3.54089G/s\n```", "```cpp\ntemplate <typename D> class B {\n  ...\n};\nclass D : public B<D> {\n  ...\n};\n```", "```cpp\n// Example 01\ntemplate <typename D> class B {\n  public:\n  B() : i_(0) {}\n  void f(int i) { static_cast<D*>(this)->f(i); }\n  int get() const { return i_; }\n  protected:\n  int i_;\n};\nclass D : public B<D> {\n  public:\n  void f(int i) { i_ += i; }\n};\n```", "```cpp\nB<D>* b = ...;\nb->f(5);\n```", "```cpp\nvoid BM_static(benchmark::State& state) {\n  B<D>* b = new D;\n  int i = 0;\n  for (auto _ : state) {\n    REPEAT(b->f(++i);)\n  }\n  benchmark::DoNotOptimize(b->get());\n  state.SetItemsProcessed(32*state.iterations());\n}\n```", "```cpp\nBenchmark           Time UserCounters...\nBM_none          1.60 ns items_per_second=19.9878G/s\nBM_dynamic       9.04 ns items_per_second=3.54089G/s\nBM_static        1.55 ns items_per_second=20.646G/s\n```", "```cpp\ntemplate <typename D> class B {\n  using T = typename D::T;\n  T* p_;\n};\nclass D : public B<D> {\n  using T = int;\n};\n```", "```cpp\ntemplate <typename C> class stack {\n  C c_;\n  public:\n  using value_type = typename C::value_type;\n  void push(const valuetype& v) { c.push_back(v); }\n  value_type pop() {\n    value_type v = c.back();\n    c.pop_back();\n    return v;\n  }\n};\nstack<std::vector<int>> s;\n```", "```cpp\nclass A {\n  public:\n  using T = int;\n  T x_;\n};\nB<A> b; // Compiles with no problems\n```", "```cpp\nclass D : public B<D> ...\n```", "```cpp\nclass A;\nB<A> b; // Now does not compile\n```", "```cpp\ntemplate <typename D> class B {\n  ...\n  void f(int i) { derived()->f(i); }\n  D* derived() { return static_cast<D*>(this); }\n};\nclass D : public B<D> {\n  ...\n  void f(int i) { i_ += i; }\n};\n```", "```cpp\n// Example 01a\ntemplate <typename D> class B {\n  typename D::value_type get() const {\n    return static_cast<const D*>(this)->get();\n  }\n  …\n};\nD : public B<D> {\n  using value_type = int;\n  value_type get() const { … };\n  …\n};\n```", "```cpp\n// Example 01a\ntemplate <typename D> class B {\n  auto get() const {\n    return static_cast<const D*>(this)->get();\n  }\n  …\n};\n```", "```cpp\n// Example 01a\ntemplate <typename T, typename value_type> class B {\n  value_type value_;\n  …\n};\nclass D : public B<D, int> {\n  using value_type = int;\n  value_type get() const { … }\n  …\n};\n```", "```cpp\ntemplate <typename D> class B {\n  public:\n  ...\n  void f(int i) { static_cast<D*>(this)->f(i); }\n  protected:\n  int i_;\n};\nclass D : public B<D> {\n  public:\n  void f(int i) { i_ += i; }\n};\n```", "```cpp\nD* d = ...; // Get an object of type D\nd->f(5);\nB<D>* b = ...; // Also has to be an object of type D\nb->f(5);\n```", "```cpp\n// Example 01\ntemplate <typename D> void apply(B<D>* b, int& i) {\n  b->f(++i);\n}\n```", "```cpp\nB<D>* b = new D;    // 1\napply(b);         // 2\n```", "```cpp\nvoid apply(B* b) { ... }\nB* b = new D;    // 1\napply(b);        // 2\n```", "```cpp\n// Example 02\ntemplate <typename D> class B {\n  public:\n  ...\n  void f(int i) { static_cast<D*>(this)->f(i); }\n};\nclass D : public B<D> {\n  // no f() here!\n};\n...\nB<D>* b = ...;\nb->f(5); // 1\n```", "```cpp\n// Example 03\ntemplate <typename D> class B {\n  public:\n  ...\n  void f(int i) { static_cast<D*>(this)->f_impl(i); }\n};\nclass D : public B<D> {\n  void f_impl(int i) { i_ += i; }\n};\n...\nB<D>* b = ...;\nb->f(5);\n```", "```cpp\n// Example 03\ntemplate <typename D> class B {\n  public:\n  ...\n  void f(int i) { static_cast<D*>(this)->f_impl(i); }\n  void f_impl(int i) {}\n};\nclass D1 : public B<D1> {\n  void f_impl(int i) { i_ += i; }\n};\nclass D2 : public B<D2> {\n  // No f() here\n};\n...\nB<D1>* b = ...;\nb->f(5); // Calls D1::f_impl()\nB<D2>* b1 = ...;\nb1->f(5); // Calls B::f_impl() by default\n```", "```cpp\ntemplate <typename D> void apply(B<D>& b) {\n  ... operate on b ...\n}\n{\n  std::vector<D> v;\n  v.push_back(D(...)); // Objects created as D\n  ...\n  apply(v[0]); // Objects processed as B&\n} // Objects deleted as D\n```", "```cpp\nB<D>* b = new D;\n...\ndelete b;\n```", "```cpp\ntemplate <typename D> class B {\n  public:\n  ~B() { static_cast<D*>(this)->~D(); }\n};\n```", "```cpp\ntemplate <typename D> void destroy(B<D>* b) {\n  delete static_cast<D*>(b);\n}\n```", "```cpp\ntemplate <typename D> class B {\n  public:\n  ...\n  void f(int i) { static_cast<D*>(this)->f_impl(i); }\n  private:\n  void f_impl(int i) {}\n};\nclass D : public B<D> {\n  private:\n  void f_impl(int i) { i_ += i; }\n  friend class B<D>;\n};\n```", "```cpp\nclass D1 : public B<D> {\n  private:\n  void f_impl(int i) { i_ -= i; }\n  friend class B<D1>;\n};\n```", "```cpp\nB<D1>* b = new D1;\n```", "```cpp\ntemplate <typename D> class B {\n  int i_;\n  B() : i_(0) {}\n  friend D;\n  public:\n  void f(int i) { static_cast<D*>(this)->f_impl(i); }\n  private:\n  void f_impl(int i) {}\n};\n```", "```cpp\n// Example 04\ntemplate <typename D> struct plus_base {\n  D operator+(const D& rhs) const {\n    D tmp = rhs;\n    tmp += static_cast<const D&>(*this);\n    return tmp;\n  }\n};\nclass D : public plus_base<D> {\n  int i_;\n  public:\n  explicit D(int i) : i_(i) {}\n  D& operator+=(const D& rhs) {\n    i_ += rhs.i_;\n    return *this;\n  }\n};\n```", "```cpp\n// Example 05\ntemplate <typename D> struct plus_base {\n  friend D operator+(const D& lhs, const D& rhs) {\n    D tmp = lhs;\n    tmp += rhs;\n    return tmp;\n  }\n};\nclass D : public plus_base<D> {\n  int i_;\n  public:\n  explicit D(int i) : i_(i) {}\n  D& operator+=(const D& rhs) {\n    i_ += rhs.i_;\n    return *this;\n  }\n};\n```", "```cpp\ntemplate <typename D> struct compare_base {\n  friend bool operator!=(const D& lhs, const D& rhs) {\n    return !(lhs == rhs); }\n  friend bool operator<=(const D& lhs, const D& rhs) {\n    return lhs.cmp(rhs) <= 0;\n  }\n  friend bool operator>=(const D& lhs, const D& rhs) {\n    return lhs.cmp(rhs) >= 0;\n  }\n  friend bool operator< (const D& lhs, const D& rhs) {\n    return lhs.cmp(rhs) <  0;\n  }\n  friend bool operator> (const D& lhs, const D& rhs) {\n    return lhs.cmp(rhs) >  0;\n  }\n};\nclass D : public compare_base<D> {\n  int i_;\n  public:\n  explicit D(int i) : i_(i) {}\n  auto cmp(const D& rhs) const {\n    return (i_ < rhs.i_) ? -1 : ((i_ > rhs.i_) ? 1 : 0);\n  }\n  bool operator==(const D& rhs) const {\n    return i_ == rhs.i_;\n  }\n};\n```", "```cpp\n// Example 05\ntemplate <typename D> struct plus_base {\n  friend D operator+(const D& lhs, const D& rhs) { … }\n};\nclass D : public plus_base<D> {\n  D& operator+=(const D& rhs) { … }\n};\n```", "```cpp\ntemplate <typename T>\nT operator+(const T& lhs, const T& rhs) {\n  T tmp = lhs;\n  tmp += rhs;\n  return tmp;\n}\n```", "```cpp\ntemplate <typename T>\nrequires( requires(T a, T b) { a += b; } )\nT operator+(const T& lhs, const T& rhs) { … }\n```", "```cpp\ntemplate <typename T>\nconstexpr inline bool gen_plus = false; // General\ntemplate <typename T>\nrequires gen_plus<T>\nT operator+(const T& lhs, const T& rhs) { … }\n```", "```cpp\nclass D { // No special base\n  D& operator+=(const D& rhs) { … }\n};\ntemplate <>\nconstexpr inline bool generate_plus<D> = true; // Opt-in\n```", "```cpp\n// Example 08\ntemplate <typename D> class registry {\n  public:\n  static size_t count;\n  static D* head;\n  D* prev;\n  D* next;\n  protected:\n  registry() {\n    ++count;\n    prev = nullptr;\n    next = head;\n    head = static_cast<D*>(this);\n    if (next) next->prev = head;\n  }\n  registry(const registry&) {\n    ++count;\n    prev = nullptr;\n    next = head;\n    head = static_cast<D*>(this);\n    if (next) next->prev = head;\n  }\n  ~registry() {\n    --count;\n    if (prev) prev->next = next;\n    if (next) next->prev = prev;\n    if (head == this) head = next;\n  }\n};\ntemplate <typename D> size_t registry<D>::count(0);\ntemplate <typename D> D* registry<D>::head(nullptr);\n```", "```cpp\n// Example 08\nclass C : public registry<C> {\n  int i_;\n  public:\n  C(int i) : i_(i) {}\n};\n```", "```cpp\n// Example 09\nstruct Animal {\n  public:\n  enum Type { CAT, DOG, RAT };\n  Animal(Type t, const char* n) : type(t), name(n) {}\n  const Type type;\n  const char* const name;\n};\ntemplate <typename D> class GenericVisitor {\n  public:\n  template <typename it> void visit(it from, it to) {\n    for (it i = from; i != to; ++i) {\n      this->visit(*i);\n    }\n  }\n  private:\n  D& derived() { return *static_cast<D*>(this); }\n  void visit(const Animal& animal) {\n    switch (animal.type) {\n      case Animal::CAT:\n        derived().visit_cat(animal); break;\n      case Animal::DOG:\n        derived().visit_dog(animal); break;\n      case Animal::RAT:\n        derived().visit_rat(animal); break;\n    }\n  }\n  void visit_cat(const Animal& animal) {\n    cout << \"Feed the cat \" << animal.name << endl;\n  }\n  void visit_dog(const Animal& animal) {\n    cout << \"Wash the dog \" << animal.name << endl;\n  }\n  void visit_rat(const Animal& animal) {\n  cout << \"Eeek!\" << endl;\n}\n  friend D;\n  GenericVisitor() = default;\n};\n```", "```cpp\nclass DefaultVisitor :\n  public GenericVisitor<DefaultVisitor> {\n};\n```", "```cpp\nstd::vector<Animal> animals {\n  {Animal::CAT, \"Fluffy\"},\n  {Animal::DOG, \"Fido\"},\n  {Animal::RAT, \"Stinky\"}};\nDefaultVisitor().visit(animals.begin(), animals.end());\n```", "```cpp\nFeed the cat Fluffy\nWash the dog Fido\nEeek!\n```", "```cpp\nclass TrainerVisitor :\n  public GenericVisitor<TrainerVisitor> {\n  friend class GenericVisitor<TrainerVisitor>;\n  void visit_dog(const Animal& animal) {\n    cout << \"Train the dog \" << animal.name << endl;\n  }\n};\nclass FelineVisitor :\n  public GenericVisitor<FelineVisitor> {\n  friend class GenericVisitor<FelineVisitor>;\n  void visit_cat(const Animal& animal) {\n    cout << \"Hiss at the cat \" << animal.name << endl;\n  }\n  void visit_dog(const Animal& animal) {\n    cout << \"Growl at the dog \" << animal.name << endl;\n  }\n  void visit_rat(const Animal& animal) {\n    cout << \"Eat the rat \" << animal.name << endl;\n  }\n};\n```", "```cpp\nFeed the cat Fluffy\nTrain the dog Fido\nEeek!\n```", "```cpp\nHiss at the cat Fluffy\nGrowl at the dog Fido\nEat the rat Stinky\n```", "```cpp\ntemplate <typename D> struct plus_base {…};\nclass D : public plus_base<D> {…};\n```", "```cpp\n// Example 10\ntemplate <typename D> struct Factory {\n  template <typename... Args>\n  static D* create(Args&&... args) {\n    return new D(std::forward<Args>(args)...);\n  }\n  static void destroy(D* d) { delete d; }\n};\n```", "```cpp\n// Example 10\ntemplate <typename D> struct Stringify {\n  operator std::string() const {\n    std::stringstream S;\n    S << *static_cast<const D*>(this);\n    return S.str();\n  }\n};\n```", "```cpp\n// Example 10\nclass C1 : public Stringify<C1>, public Factory<C1> {…};\n```", "```cpp\nclass C2 : public Stringify<C2>, public TLFactory<C2> {…};\n```", "```cpp\ntemplate <typename… Policies>\nclass C : public Policies… {};\n```", "```cpp\ntemplate <template <typename> class B> class C;\n```", "```cpp\ntemplate <template <typename> class B>\nclass C : public B<template argument> {…};\n```", "```cpp\ntemplate <template <typename> class B>\nclass C : public B<C<B>> {…};\n```", "```cpp\n// Example 11\ntemplate <template <typename> class... Policies>\nclass C : public Policies<C<Policies...>>... {…};\n```", "```cpp\n// Example 11\ntemplate <typename T,\n          template <typename> class... Policies>\nclass C : public Policies<C<T, Policies...>>... {\n  T t_;\n  public:\n  explicit C(T t) : t_(t) {}\n  const T& get() const { return t_; }\n  friend std::ostream&\n  operator<<(std::ostream& out, const C c) {\n    out << c.t_;\n    return out;\n  }\n};\n```", "```cpp\nusing X = C<int, Factory, Stringify>;\n```", "```cpp\ntemplate <typename T> using Y = C<T, Factory, Stringify>;\n```"]