<html><head></head><body>
<div id="_idContainer062">
<h1 class="chapter-number" id="_idParaDest-273"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-274"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.2.1">Extended Reality with OpenXR</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Similar to what Vulkan is for graphics, OpenXR, an integral part of the world of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Extended Reality</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">XR</span></strong><span class="koboSpan" id="kobo.7.1">), is an API that serves as a powerful tool for implementing XR applications. </span><span class="koboSpan" id="kobo.7.2">This </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.8.1">chapter provides an overview of OpenXR and how to use it in conjunction with Vulkan. </span><span class="koboSpan" id="kobo.8.2">We start with a basic introduction to OpenXR, explaining its role and significance in XR applications, and follow with recipes that may be </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.9.1">used to improve your XR applications, such as </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">single pass multiview</span></strong><span class="koboSpan" id="kobo.11.1"> rendering, a technique that optimizes the rendering of stereo scenes. </span><span class="koboSpan" id="kobo.11.2">The chapter further expands into the realm of foveated rendering, a method that significantly </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.12.1">bolsters </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">Frames Per Second</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.15.1">FPS</span></strong><span class="koboSpan" id="kobo.16.1">) by rendering different sections of the screen at diverse resolutions. </span><span class="koboSpan" id="kobo.16.2">We delve into the implementation </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.17.1">of this technique using the </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">fragment shading rate</span></strong><span class="koboSpan" id="kobo.19.1"> feature of the Vulkan extension, providing you with a practical understanding of </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.20.1">its application. </span><span class="koboSpan" id="kobo.20.2">Lastly, we delve into the use of </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">half floats</span></strong><span class="koboSpan" id="kobo.22.1">, a practical aid in conserving memory space on </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Head-Mounted Displays</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.25.1">HMDs</span></strong><span class="koboSpan" id="kobo.26.1">). </span><span class="koboSpan" id="kobo.26.2">By the </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.27.1">end of this chapter, you will have gained an understanding of these concepts and will be equipped with the skills to apply them effectively in your </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">XR projects.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.31.1">Getting started </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">with OpenXR</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">How to implement single pass </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">multiview rendering</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Implementing static foveated rendering with a fragment </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">density map</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Retrieving eye gaze information from OpenXR in </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">your app</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Implementing dynamic foveated rendering using Qualcomm’s fragment density map </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">Offset extension</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Using half floats to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">memory load</span></span></li>
</ul>
<h1 id="_idParaDest-275"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.43.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.44.1">For this chapter, you will need to install Android Studio and will also need a Meta Quest 2 or Meta Quest </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.45.1">Pro to run the </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Virtual Reality</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">VR</span></strong><span class="koboSpan" id="kobo.49.1">) sample application provided in the repository. </span><span class="koboSpan" id="kobo.49.2">Please follow these steps to install the tools needed to build, install, and run an application on </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the device:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.51.1">Download and install the Android Studio Hedgehog version </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">from </span></span><a href="https://developer.android.com/studio/releases"><span class="No-Break"><span class="koboSpan" id="kobo.53.1">https://developer.android.com/studio/releases</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.54.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.55.1">We also recommend installing the Meta Quest developer hub from </span><a href="https://developer.oculus.com/downloads/package/oculus-developer-hub-win"><span class="koboSpan" id="kobo.56.1">https://developer.oculus.com/downloads/package/oculus-developer-hub-win</span></a><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">This tool provides several features that help the development of </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">XR applications.</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">Please follow the steps outlined in the following link to make sure that your device is developer-ready—that is, you can debug, deploy, and test VR </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">apps: </span></span><a href="https://developer.oculus.com/documentation/native/android/mobile-device-setup/"><span class="No-Break"><span class="koboSpan" id="kobo.61.1">https://developer.oculus.com/documentation/native/android/mobile-device-setup/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.63.1">To launch the project, simply launch Android Studio and open this chapter's </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">project</span></strong><span class="koboSpan" id="kobo.65.1"> folder located in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">source/chapter8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1"> directory</span></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">.</span></span></p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.69.1">Getting started with OpenXR</span></h1>
<p><span class="koboSpan" id="kobo.70.1">Before we dive </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.71.1">into how our application code is structured, let’s talk about some important </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">OpenXR concepts:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">XrInstance</span></strong><span class="koboSpan" id="kobo.74.1">: This is </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.75.1">the starting point for an OpenXR application. </span><span class="koboSpan" id="kobo.75.2">It represents the application’s connection to an OpenXR runtime. </span><span class="koboSpan" id="kobo.75.3">It is the first object you create and the last thing </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">you destroy.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">XrSystemId</span></strong><span class="koboSpan" id="kobo.78.1">: After </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.79.1">creating an instance, the application queries for a system ID, which represents a specific device or group of devices, such as a </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">VR headset.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">XrViewConfigurationType</span></strong><span class="koboSpan" id="kobo.82.1">: This is used to select a view configuration that the </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.83.1">application will use to display images. </span><span class="koboSpan" id="kobo.83.2">Different configurations can represent different display setups, such as monoscopic, stereoscopic, and </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">so on.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">XrSession</span></strong><span class="koboSpan" id="kobo.86.1">: Once the instance is set up and the system ID and view configuration </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.87.1">are determined, a session is created. </span><span class="koboSpan" id="kobo.87.2">A session represents the application’s interaction with a device. </span><span class="koboSpan" id="kobo.87.3">The session manages the life cycle, rendering parameters, and input data for </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">the device.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">XrSpace</span></strong><span class="koboSpan" id="kobo.90.1">: Spaces </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.91.1">represent coordinate systems within the XR environment. </span><span class="koboSpan" id="kobo.91.2">They are used to position objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">3D space.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">XrSwapchain</span></strong><span class="koboSpan" id="kobo.94.1">: A swapchain is </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.95.1">a collection of textures used to buffer images for display. </span><span class="koboSpan" id="kobo.95.2">After the session has been established, the swapchain is created to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">the rendering.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">xrBeginFrame</span></strong><span class="koboSpan" id="kobo.98.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">xrEndFrame</span></strong><span class="koboSpan" id="kobo.100.1">: These are functions used to start and end the </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.101.1">rendering of a frame. </span><span class="koboSpan" id="kobo.101.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">xrBeginFrame</span></strong><span class="koboSpan" id="kobo.103.1"> function </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.104.1">signals the start of a rendering frame, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">xrEndFrame</span></strong><span class="koboSpan" id="kobo.106.1"> signals the end of a frame. </span><span class="koboSpan" id="kobo.106.2">They are called for each frame in the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">render loop.</span></span><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.108.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.109.1">.1</span></em><span class="koboSpan" id="kobo.110.1"> depicts the basic idea about how to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">use OpenXR:</span></span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.112.1"><img alt="Figure 8.1 – OpenXR object interaction diagram" src="image/B18491_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Figure 8.1 – OpenXR object interaction diagram</span></p>
<p><span class="koboSpan" id="kobo.114.1">In this recipe, we will learn about the main OpenXR initialization events, and which functions we need to use to render a frame and display them on a device. </span><span class="koboSpan" id="kobo.114.2">The recipe will also cover how the OpenXR code is handled in </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the repository.</span></span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.116.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.117.1">The first step in creating an OpenXR application involves setting up an </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">XrInstance</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">This instance </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.120.1">is the primary connection between your application and the OpenXR runtime. </span><span class="koboSpan" id="kobo.120.2">To create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">XrInstance</span></strong><span class="koboSpan" id="kobo.122.1">, you’ll need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">xrCreateInstance</span></strong><span class="koboSpan" id="kobo.124.1"> function. </span><span class="koboSpan" id="kobo.124.2">Before you do this, you will need to decide which extensions your application requires. </span><span class="koboSpan" id="kobo.124.3">At the very least, your application will need to enable a graphics binding extension, which specifies the graphics API that will be used. </span><span class="koboSpan" id="kobo.124.4">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">xrEnumerateInstanceExtensionProperties</span></strong><span class="koboSpan" id="kobo.126.1"> to enumerate all extensions supported by the platform. </span><span class="koboSpan" id="kobo.126.2">Additionally, before calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">xrCreateInstance</span></strong><span class="koboSpan" id="kobo.128.1">, you will need to populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">XrApplicationInfo</span></strong><span class="koboSpan" id="kobo.130.1"> structure. </span><span class="koboSpan" id="kobo.130.2">This structure holds essential details about your application, such as the application’s name, engine name, and </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">version information.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">After these details are set, you can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">xrCreateInstance</span></strong><span class="koboSpan" id="kobo.134.1">, which will return an instance handle upon successful creation. </span><span class="koboSpan" id="kobo.134.2">Following the creation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">XrInstance</span></strong><span class="koboSpan" id="kobo.136.1">, the next step involves querying for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">SystemId</span></strong><span class="koboSpan" id="kobo.138.1"> and selecting an </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">XrViewConfigurationView</span></strong><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">SystemId</span></strong><span class="koboSpan" id="kobo.142.1"> represents a specific XR device or a group of devices, such as a VR headset, and it can be retrieved using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">xrGetSystem</span></strong><span class="koboSpan" id="kobo.144.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">XrViewConfigurationView</span></strong><span class="koboSpan" id="kobo.146.1">, on the other hand, allows you to choose the view configuration that your application will use for displaying images. </span><span class="koboSpan" id="kobo.146.2">This could range from monoscopic to stereoscopic configurations, depending on your device type. </span><span class="koboSpan" id="kobo.146.3">In the recipes in this chapter, we will be using the stereo view by </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">specifying </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">The next step </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.151.1">is to create a instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">XrSession</span></strong><span class="koboSpan" id="kobo.153.1">. </span><span class="koboSpan" id="kobo.153.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">XrSession</span></strong><span class="koboSpan" id="kobo.155.1"> represents your application’s active interaction with the XR device. </span><span class="koboSpan" id="kobo.155.2">It handles the rendering parameters, input data, and overall life cycle of the application’s interaction with the device. </span><span class="koboSpan" id="kobo.155.3">To create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">XrSession</span></strong><span class="koboSpan" id="kobo.157.1">, we will need to fill the graphics binding information in </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">XrSessionCreateInfo</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">Since we are using Vulkan, we will specify graphics binding using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">XrGraphicsBindingVulkanKHR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1"> structure.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Tracking spatial relationships is very important in XR platforms. </span><span class="koboSpan" id="kobo.162.2">An instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">XrSpace</span></strong><span class="koboSpan" id="kobo.164.1"> class represent something that is being tracked by the XR system. </span><span class="koboSpan" id="kobo.164.2">To interact with tracked objects, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">XrSpace</span></strong><span class="koboSpan" id="kobo.166.1"> handles. </span><span class="koboSpan" id="kobo.166.2">Several spaces are known as reference spaces, which can be accessed using sessions and enumerations. </span><span class="koboSpan" id="kobo.166.3">There are three types of reference spaces </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">in OpenXR:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">XR_REFERENCE_SPACE_TYPE_LOCAL</span></strong><span class="koboSpan" id="kobo.169.1">: Seated or </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">static space</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">XR_REFERENCE_SPACE_TYPE_VIEW</span></strong><span class="koboSpan" id="kobo.172.1">: Head </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">locked space</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">XR_REFERENCE_SPACE_TYPE_STAGE</span></strong><span class="koboSpan" id="kobo.175.1">: An area bounded by an environment in which the user can </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">move around</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.177.1">To get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">XrSpace</span></strong><span class="koboSpan" id="kobo.179.1"> from these enumerations, you will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">xrCreateReferenceSpace</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">Another kind of space you can create is </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">xrCreateActionSpace</span></strong><span class="koboSpan" id="kobo.183.1">, which is used when you need to create a space from a pose action. </span><span class="koboSpan" id="kobo.183.2">For instance, we use it to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">XrSpace</span></strong><span class="koboSpan" id="kobo.185.1"> for gaze location and orientation. </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">xrLocateSpace</span></strong><span class="koboSpan" id="kobo.187.1"> is an API which is used to determine transform relative to </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">other spaces.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">To render graphics, we will need to create a swapchain, just like in Vulkan. </span><span class="koboSpan" id="kobo.189.2">To create one, you need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">xrCreateSwapchain</span></strong><span class="koboSpan" id="kobo.191.1">. </span><span class="koboSpan" id="kobo.191.2">Next, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">xrEnumerateSwapchainImages</span></strong><span class="koboSpan" id="kobo.193.1"> to acquire multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">XrSwapchainImageVulkanKHR</span></strong><span class="koboSpan" id="kobo.195.1"> instances that hold a reference </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">vkImage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">In OpenXR, a key concept is that of layers. </span><span class="koboSpan" id="kobo.199.2">Imagine layers as distinct sections or elements of the final rendered scene in a virtual or augmented reality experience. </span><span class="koboSpan" id="kobo.199.3">Rather than presenting a flat, single-image view, OpenXR creates a multi-dimensional perspective by </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.200.1">independently rendering each layer and then compositing them to form the final image. </span><span class="koboSpan" id="kobo.200.2">The most frequently used layer is </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">XrCompositionLayerProjection</span></strong><span class="koboSpan" id="kobo.202.1">. </span><span class="koboSpan" id="kobo.202.2">This layer is responsible for rendering the main scene. </span><span class="koboSpan" id="kobo.202.3">To create a sense of depth and immersion typical of VR experiences, this layer incorporates multiple views—one for each eye in a VR headset. </span><span class="koboSpan" id="kobo.202.4">This arrangement produces a stereoscopic 3D effect. </span><span class="koboSpan" id="kobo.202.5">But </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">XrCompositionLayerProjection</span></strong><span class="koboSpan" id="kobo.204.1"> isn’t the only layer at work. </span><span class="koboSpan" id="kobo.204.2">OpenXR also employs layers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">XrCompositionLayerQuad</span></strong><span class="koboSpan" id="kobo.206.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">XrCompositionLayerCubeKHR</span></strong><span class="koboSpan" id="kobo.208.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">XrCompositionLayerEquirectKHR</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">Each of these plays a unique role in enhancing the rendering of the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">final image.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Now we will move to the render loop; the application render loop consists of three </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">main functions:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">xrWaitFrame</span></strong><span class="koboSpan" id="kobo.215.1"> blocks until the OpenXR runtime determines that it’s the right time to </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.216.1">start the next frame. </span><span class="koboSpan" id="kobo.216.2">This includes computations and rendering based on the user’s </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">head pose.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">xrBeginFrame</span></strong><span class="koboSpan" id="kobo.219.1"> is called </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.220.1">by the application to mark the start of rendering for the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">given frame.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">xrEndFrame</span></strong><span class="koboSpan" id="kobo.223.1"> submits </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.224.1">the frame </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">for display.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.226.1">The next part is acquiring and releasing swapchain images: </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">xrAcquireSwapchainImage</span></strong><span class="koboSpan" id="kobo.228.1"> gives the index of the current swapchain image but it doesn’t give you permission to write to the image. </span><span class="koboSpan" id="kobo.228.2">To write to the swapchain image, you will need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">xrWaitSwapchainImage</span></strong><span class="koboSpan" id="kobo.230.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">xrReleaseSwapchainImage</span></strong><span class="koboSpan" id="kobo.232.1"> is called just before </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">xrEndFrame</span></strong><span class="koboSpan" id="kobo.234.1">, before the rendering is done. </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">xrEndFrame</span></strong><span class="koboSpan" id="kobo.236.1"> will use the most recently released swapchain image for displaying to </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the device.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">The last important call is </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">xrPollEvents</span></strong><span class="koboSpan" id="kobo.240.1">, which is used to retrieve events from the event queue. </span><span class="koboSpan" id="kobo.240.2">Events in OpenXR represent various types of occurrences, such as changes in session state, input from the user, or changes in the environment. </span><span class="koboSpan" id="kobo.240.3">For instance, an event might be generated when the user puts on or takes off their headset, when they press a button on a controller, or when the tracking system loses or regains sight of a tracked object. </span><span class="koboSpan" id="kobo.240.4">It’s usually called once </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">a frame.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">In the repository, the code for OpenXR is encapsulated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">OXR::Context</span></strong><span class="koboSpan" id="kobo.244.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">OXR::OXRSwapchain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1"> classes.</span></span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.247.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.248.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">OXR::Context</span></strong><span class="koboSpan" id="kobo.250.1"> class in the repository manages most of OpenXR calls and states. </span><span class="koboSpan" id="kobo.250.2">In this </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.251.1">recipe, we will show you the details of these functions and how to use them to initialize the OpenXR sample app in </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the repository:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.253.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">OXR::Context::initializeExtensions</span></strong><span class="koboSpan" id="kobo.255.1"> method finds the extensions available in the OpenXR runtime and filters out the requested extensions that aren’t supported. </span><span class="koboSpan" id="kobo.255.2">Once the available extensions are fetched, it iterates through the requested extensions, eliminating any that aren’t available. </span><span class="koboSpan" id="kobo.255.3">That results in a list of extensions that are both requested </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">and supported:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.257.1">
void Context::initializeExtensions() {
   uint32_t numExtensions = 0;
  xrEnumerateInstanceExtensionProperties(
    nullptr, 0, &amp;numExtensions, nullptr);
  availableExtensions_.resize(
    numExtensions,
    {XR_TYPE_EXTENSION_PROPERTIES});
  xrEnumerateInstanceExtensionProperties(
    nullptr, numExtensions, &amp;numExtensions,
    availableExtensions_.data());
  requestedExtensions_.erase(
    std::remove_if(
      requestedExtensions_.begin(),
      requestedExtensions_.end(),
      [this](const char *ext) {
        return std::none_of(
          availableExtensions_.begin(),
          availableExtensions_.end(),
          [ext](
            const XrExtensionProperties &amp;props) {
            return strcmp(props.extensionName,
                          ext) == 0;
          });
      }),
    requestedExtensions_.end());
}</span></pre></li> <li><span class="koboSpan" id="kobo.258.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Context::createInstance()</span></strong><span class="koboSpan" id="kobo.260.1"> method is responsible for creating an OpenXR instance </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.261.1">with basic application information and the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">extension details:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.263.1">
bool Context::createInstance() {
  const XrApplicationInfo appInfo = {
    .applicationName = "OpenXR Example",
    .applicationVersion = 0,
    .engineName = "OpenXR Example",
    .engineVersion = 0,
    .apiVersion = XR_CURRENT_API_VERSION,
  };
  const XrInstanceCreateInfo instanceCreateInfo =
    {
      .type = XR_TYPE_INSTANCE_CREATE_INFO,
      .createFlags = 0,
      .applicationInfo = appInfo,
      .enabledApiLayerCount = 0,
      .enabledApiLayerNames = nullptr,
      .enabledExtensionCount =
        static_cast&lt;uint32_t&gt;(
          requestedExtensions_.size()),
      .enabledExtensionNames =
        requestedExtensions_.data(),
    };
  XR_CHECK(xrCreateInstance(&amp;instanceCreateInfo,
                            &amp;instance_));
  XR_CHECK(xrGetInstanceProperties(
    instance_, &amp;instanceProps_));
}</span></pre></li> <li><span class="koboSpan" id="kobo.264.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Context::systemInfo</span></strong><span class="koboSpan" id="kobo.266.1"> method retrieves and stores the properties of the OpenXR system for a head-mounted display. </span><span class="koboSpan" id="kobo.266.2">It fetches the system ID and its properties, including </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.267.1">system name, vendor ID, graphics properties, tracking properties, and eye </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">gaze support:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
void Context::systemInfo() {
  const XrSystemGetInfo systemGetInfo = {
    .type = XR_TYPE_SYSTEM_GET_INFO,
    .formFactor =
      XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY,
  };
  XR_CHECK(xrGetSystem(instance_, &amp;systemGetInfo,
                       &amp;systemId_));
  XR_CHECK(xrGetSystemProperties(
    instance_, systemId_, &amp;systemProps_));
}</span></pre></li> <li><span class="koboSpan" id="kobo.270.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Context::enumerateViewConfigurations</span></strong><span class="koboSpan" id="kobo.272.1"> function enumerates all the view configurations supported by the system and then selects and stores properties of the one that matches the predefined supported configuration. </span><span class="koboSpan" id="kobo.272.2">If the selected configuration supports the required number of viewports, it stores the configuration properties and the view </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">configuration views.</span></span></li>
<li><span class="koboSpan" id="kobo.274.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Context::initGraphics</span></strong><span class="koboSpan" id="kobo.276.1"> function is designed to initialize the graphics requirements for Vulkan. </span><span class="koboSpan" id="kobo.276.2">It achieves this by obtaining key components such as the Vulkan instance and device extensions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">xrGetVulkanInstanceExtensionsKHR</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">xrGetVulkanDeviceExtensionsKHR</span></strong><span class="koboSpan" id="kobo.280.1"> are functions used in the OpenXR API to retrieve the names of Vulkan instance and device extensions, respectively, that are needed by a particular </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">OpenXR runtime:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
void Context::initGraphics() {
  uint32_t bufferSize = 0;
  pfnGetVulkanInstanceExtensionsKHR(
    instance_, systemId_, 0, &amp;bufferSize, NULL);
  requiredVkInstanceExtensionsBuffer_.resize(
    bufferSize);
  pfnGetVulkanInstanceExtensionsKHR(
    instance_, systemId_, bufferSize, &amp;bufferSize,
    requiredVkInstanceExtensionsBuffer_.data());
  pfnGetVulkanDeviceExtensionsKHR(
    instance_, systemId_, 0, &amp;bufferSize, NULL);
  requiredVkDeviceExtensionsBuffer_.resize(
    bufferSize);
  pfnGetVulkanDeviceExtensionsKHR(
    instance_, systemId_, bufferSize, &amp;bufferSize,
    requiredVkDeviceExtensionsBuffer_.data());
}</span></pre></li> <li><span class="koboSpan" id="kobo.283.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Context::initializeSession</span></strong><span class="koboSpan" id="kobo.285.1"> function creates a new OpenXR session. </span><span class="koboSpan" id="kobo.285.2">It begins by creating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">XrGraphicsBindingVulkanKHR</span></strong><span class="koboSpan" id="kobo.287.1"> object, which is used to bind Vulkan to the XR session. </span><span class="koboSpan" id="kobo.287.2">This object is populated with the Vulkan instance, physical device, and device, as well as the queue family index. </span><span class="koboSpan" id="kobo.287.3">This information allows the OpenXR runtime to interface with the Vulkan API. </span><span class="koboSpan" id="kobo.287.4">Then, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">XrSessionCreateInfo</span></strong><span class="koboSpan" id="kobo.289.1"> object is created, which is used to specify the parameters for creating a new session. </span><span class="koboSpan" id="kobo.289.2">This object attributes are populated with the </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.290.1">nature of the session to be created, the graphics binding, and the system ID. </span><span class="koboSpan" id="kobo.290.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">xrCreateSession</span></strong><span class="koboSpan" id="kobo.292.1"> function is called to create </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the session:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
bool Context::initializeSession(
  VkInstance vkInstance,
  VkPhysicalDevice vkPhysDevice,
  VkDevice vkDevice, uint32_t queueFamilyIndex) {
  // Bind Vulkan to XR session
  const XrGraphicsBindingVulkanKHR
    graphicsBinding = {
      XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR,
      NULL,
      vkInstance,
      vkPhysDevice,
      vkDevice,
      queueFamilyIndex,
      0,
    };
  const XrSessionCreateInfo sessionCreateInfo = {
    .type = XR_TYPE_SESSION_CREATE_INFO,
    .next = &amp;graphicsBinding,
    .createFlags = 0,
    .systemId = systemId_,
  };
  XR_CHECK(xrCreateSession(
    instance_, &amp;sessionCreateInfo, &amp;session_));
  return true;
}</span></pre></li> <li><span class="koboSpan" id="kobo.295.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Context::enumerateReferenceSpaces</span></strong><span class="koboSpan" id="kobo.297.1"> function retrieves the types of </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.298.1">reference spaces available for the current OpenXR session. </span><span class="koboSpan" id="kobo.298.2">It calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">xrEnumerateReferenceSpaces</span></strong><span class="koboSpan" id="kobo.300.1"> to fill a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">XrReferenceSpaceType</span></strong><span class="koboSpan" id="kobo.302.1"> structures with the available reference space types. </span><span class="koboSpan" id="kobo.302.2">Finally, it checks whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">XR_REFERENCE_SPACE_TYPE_STAGE</span></strong><span class="koboSpan" id="kobo.304.1"> type is available and stores this information in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">stageSpaceSupported_</span></strong><span class="koboSpan" id="kobo.306.1"> variable. </span><span class="koboSpan" id="kobo.306.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">XR_REFERENCE_SPACE_TYPE_STAGE</span></strong><span class="koboSpan" id="kobo.308.1"> type represents a standing-scale experience where the user has a small amount of room to </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">move around.</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Context::createSwapchains</span></strong><span class="koboSpan" id="kobo.312.1"> function is responsible for creating the swapchains needed for rendering. </span><span class="koboSpan" id="kobo.312.2">Based on the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">useSinglePassStereo_</span></strong><span class="koboSpan" id="kobo.314.1">, it either creates a single swapchain that will be used for both views (in case of single-pass stereo rendering), or separate swapchains for each view. </span><span class="koboSpan" id="kobo.314.2">For each swapchain, it creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">OXRSwapchain</span></strong><span class="koboSpan" id="kobo.316.1"> instance. </span><span class="koboSpan" id="kobo.316.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">OXRSwapchain</span></strong><span class="koboSpan" id="kobo.318.1"> constructor is called with the Vulkan context, the OpenXR session, the viewport for the swapchain, and the number of views per swapchain. </span><span class="koboSpan" id="kobo.318.2">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">initialize</span></strong><span class="koboSpan" id="kobo.320.1"> function to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">OXRSwapchain</span></strong><span class="koboSpan" id="kobo.322.1"> instance. </span><span class="koboSpan" id="kobo.322.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">initialize</span></strong><span class="koboSpan" id="kobo.324.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">OXRSwapchain</span></strong><span class="koboSpan" id="kobo.326.1"> class sets up the color and depth swapchains for an OpenXR session by </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.327.1">calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">xrCreateSwapchain</span></strong><span class="koboSpan" id="kobo.329.1"> function. </span><span class="koboSpan" id="kobo.329.2">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">XrSwapchain</span></strong><span class="koboSpan" id="kobo.331.1"> is created, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">enumerateSwapchainImages</span></strong><span class="koboSpan" id="kobo.333.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">OXRSwapchain</span></strong><span class="koboSpan" id="kobo.335.1">, which is responsible for creating a vector </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">XrSwapchainImageVulkanKHR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.339.1">
void Context::createSwapchains(
  VulkanCore::Context &amp;ctx) {
  const uint32_t numSwapchainProviders =
    useSinglePassStereo_ ? </span><span class="koboSpan" id="kobo.339.2">1 : kNumViews;
  const uint32_t numViewsPerSwapchain =
    useSinglePassStereo_ ? </span><span class="koboSpan" id="kobo.339.3">kNumViews : 1;
  swapchains_.reserve(numSwapchainProviders);
  for (uint32_t i = 0; i &lt; numSwapchainProviders;
       i++) {
    swapchains_.emplace_back(
      std::make_unique&lt;OXRSwapchain&gt;(
        ctx, session_, viewports_[i],
        numViewsPerSwapchain));
    swapchains_.back()-&gt;initialize();
  }
}</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">OXRSwapchain</span></strong><span class="koboSpan" id="kobo.341.1"> also provides functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">getSurfaceTexture</span></strong><span class="koboSpan" id="kobo.343.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">releaseSwapchainImages</span></strong><span class="koboSpan" id="kobo.345.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">getSurfaceTexture</span></strong><span class="koboSpan" id="kobo.347.1"> is responsible for acquiring a swapchain by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">xrAcquireSwapchainImage</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.349.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">xrWaitSwapchainImage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">Before starting to render, </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">OXR::Context::beginFrame</span></strong><span class="koboSpan" id="kobo.354.1"> first synchronizes frame submission with the display by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">xrWaitFrame</span></strong><span class="koboSpan" id="kobo.356.1">, which returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">XrFrameState</span></strong><span class="koboSpan" id="kobo.358.1"> structure. </span><span class="koboSpan" id="kobo.358.2">The frame state specifies a predicted display time when the runtime predicts a frame will be displayed. </span><span class="koboSpan" id="kobo.358.3">The function also calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">xrBeginFrame</span></strong><span class="koboSpan" id="kobo.360.1">, which must be called before rendering starts, and retrieves some other </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.361.1">important information, such as the head and view poses, and calculates view and </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">camera transformations:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
XrFrameState Context::beginFrame() {
  const XrFrameWaitInfo waitFrameInfo = {
    XR_TYPE_FRAME_WAIT_INFO};
  XrFrameState frameState = {XR_TYPE_FRAME_STATE};
  XR_CHECK(xrWaitFrame(session_, &amp;waitFrameInfo,
                       &amp;frameState));
  XrFrameBeginInfo beginFrameInfo = {
    XR_TYPE_FRAME_BEGIN_INFO};
  XR_CHECK(
    xrBeginFrame(session_, &amp;beginFrameInfo));
  XrSpaceLocation loc = {
    loc.type = XR_TYPE_SPACE_LOCATION};
  XR_CHECK(xrLocateSpace(
    headSpace_, stageSpace_,
    frameState.predictedDisplayTime, &amp;loc));
  XrPosef headPose = loc.pose;
  XrViewState viewState = {XR_TYPE_VIEW_STATE};
  const XrViewLocateInfo projectionInfo = {
    .type = XR_TYPE_VIEW_LOCATE_INFO,
    .viewConfigurationType =
      viewConfigProps_.viewConfigurationType,
    .displayTime =
      frameState.predictedDisplayTime,
    .space = headSpace_,
  };
  uint32_t numViews = views_.size();
  views_[0].type = XR_TYPE_VIEW;
  views_[1].type = XR_TYPE_VIEW;
  XR_CHECK(xrLocateViews(
    session_, &amp;projectionInfo, &amp;viewState,
    views_.size(), &amp;numViews, views_.data()));
}</span></pre></li> <li><span class="koboSpan" id="kobo.364.1">Once rendering </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.365.1">has been completed, the application must call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">OXR::endFrame</span></strong><span class="koboSpan" id="kobo.367.1"> method, which in turn calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">xrEndFrame</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">XrFrameEndInfo</span></strong><span class="koboSpan" id="kobo.371.1"> structure specifies the type of layer being presented (and its flags) and its associated spaces (with its poses and field of view angles and maybe depth information) and how the image(s) should be blended with underlying layers. </span><span class="koboSpan" id="kobo.371.2">Note that, for the sake of conciseness, only the critical sections of the code are displayed here. </span><span class="koboSpan" id="kobo.371.3">For a comprehensive understanding, please refer to the full code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">original source:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
void Context::endFrame(XrFrameState frameState) {
  const XrFrameEndInfo endFrameInfo = {
    .type = XR_TYPE_FRAME_END_INFO,
    .displayTime =
      frameState.predictedDisplayTime,
    .environmentBlendMode =
      XR_ENVIRONMENT_BLEND_MODE_OPAQUE,
    .layerCount = 1,
    .layers = layers,
  };
  XR_CHECK(xrEndFrame(session_, &amp;endFrameInfo));
}</span></pre></li> <li><span class="koboSpan" id="kobo.374.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">android_main</span></strong><span class="koboSpan" id="kobo.376.1"> function, outside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">OXR::Context</span></strong><span class="koboSpan" id="kobo.378.1"> class, serves as the main </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.379.1">entry point for a native Android activity. </span><span class="koboSpan" id="kobo.379.2">It initializes both OpenXR (</span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">oxrContext</span></strong><span class="koboSpan" id="kobo.381.1">) and Vulkan (</span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">vkContext</span></strong><span class="koboSpan" id="kobo.383.1">) contexts and sets up their required extensions and features. </span><span class="koboSpan" id="kobo.383.2">After creating an instance, it establishes a session and creates swapchains for rendering. </span><span class="koboSpan" id="kobo.383.3">Shader modules for vertex and fragment shaders are also created. </span><span class="koboSpan" id="kobo.383.4">The function then enters a loop where it handles OpenXR events, begins a frame, carries out rendering actions, and ends the frame. </span><span class="koboSpan" id="kobo.383.5">This loop continues until the app is requested to be destroyed. </span><span class="koboSpan" id="kobo.383.6">Please note that, for brevity, a significant amount of detail has been omitted from this summary. </span><span class="koboSpan" id="kobo.383.7">You are encouraged to review the actual code in the repository for a </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">comprehensive understanding:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
void android_main(struct android_app *pApp) {
  OXR::Context oxrContext(pApp);
  oxrContext.initializeExtensions();
  oxrContext.createInstance();
  VulkanCore::Context vkContext(
    VkApplicationInfo{});
  vkContext.createVkDevice(
    oxrContext.findVkGraphicsDevice(
      vkContext.instance()),
    oxrContext.vkDeviceExtensions(),
    VK_QUEUE_GRAPHICS_BIT);
  oxrContext.initializeSession(
    vkContext.instance(),
    vkContext.physicalDevice().vkPhysicalDevice(),
    vkContext.device(),
    vkContext.physicalDevice()
      .graphicsFamilyIndex()
      .value());
  oxrContext.createSwapchains(vkContext);
  auto commandMgr =
    vkContext.createGraphicsCommandQueue(3, 3);
  do {
    auto frameState = oxrContext.beginFrame();
    if (frameState.shouldRender == XR_FALSE) {
      oxrContext.endFrame(frameState);
      continue;
    }
    auto commandBuffer =
      commandMgr.getCmdBufferToBegin();
    vkCmdDrawIndexedIndirect(
      commandBuffer, buffers[3]-&gt;vkBuffer(), 0,
      numMeshes,
      sizeof(EngineCore::
               IndirectDrawCommandAndMeshData));
    commandMgr.submit(
      &amp;vkContext.swapchain()-&gt;createSubmitInfo(
        &amp;commandBuffer,
        &amp;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
        false, false));
    commandMgr.goToNextCmdBuffer();
    oxrContext.swapchain(0)
      -&gt;releaseSwapchainImages();
    oxrContext.endFrame(frameState);
  } while (!pApp-&gt;destroyRequested);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.386.1">This recipe involves a sequence of steps starting from initializing the OpenXR and Vulkan contexts to </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.387.1">entering a game event loop for handling OpenXR events and rendering. </span><span class="koboSpan" id="kobo.387.2">The process is intricate and involves enabling specific features, handling graphics commands, and managing frames. </span><span class="koboSpan" id="kobo.387.3">This guide has provided a simplified overview, and we strongly recommend reviewing the full code in the repository for a </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">complete understanding.</span></span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.389.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.390.1">For more details, please refer to the OpenXR guide </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">by Khronos:</span></span></p>
<ul>
<li><a href="https://www.khronos.org/files/openxr-10-reference-guide.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.392.1">https://www.khronos.org/files/openxr-10-reference-guide.pdf</span></span></a></li>
</ul>
<h1 id="_idParaDest-280"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.393.1">How to implement single pass multiview rendering</span></h1>
<p><span class="koboSpan" id="kobo.394.1">XR devices must render scenes at least twice for each frame, generating one image for each eye. </span><span class="koboSpan" id="kobo.394.2">Single pass multiview rendering is a technique used to enhance the performance </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.395.1">of XR applications by allowing the rendering of multiple views in a single pass. </span><span class="koboSpan" id="kobo.395.2">This effectively enables the rendering of the scene from both eye’s perspectives with one </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">draw call.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">In this recipe, we will navigate how to enable the Multiview rendering feature in Vulkan and how to use it to render the scene for both eyes in one </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">render pass.</span></span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.399.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.400.1">In the context of Vulkan, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES</span></strong><span class="koboSpan" id="kobo.402.1"> extension specifies whether multiple views are supported in a single rendering pass. </span><span class="koboSpan" id="kobo.402.2">Once the feature is enabled, you can specify multiple viewports and scissor rectangles for your rendering pass. </span><span class="koboSpan" id="kobo.402.3">The graphics pipeline will then render the scene from different perspectives in a single pass, reducing the need for </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">duplicate operations.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Besides enabling a Vulkan extension, you will also need to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">GL_EXT_multiview</span></strong><span class="koboSpan" id="kobo.406.1"> extension in your shader code. </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">GL_EXT_multiview</span></strong><span class="koboSpan" id="kobo.408.1"> is a GLSL extension that allows multiple views to be rendered in a single pass. </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">GL_EXT_multiview</span></strong><span class="koboSpan" id="kobo.410.1"> introduces a new built-in variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">gl_ViewIndex</span></strong><span class="koboSpan" id="kobo.412.1">, that can be used in your shaders to determine which view is being rendered. </span><span class="koboSpan" id="kobo.412.2">It contains the index of the </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.413.1">current view being processed and can be used to adjust your drawing based on the view index (for instance, index </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">0</span></strong><span class="koboSpan" id="kobo.415.1"> may represent the left eye, while index </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">1</span></strong><span class="koboSpan" id="kobo.417.1"> can represent the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">right eye).</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">We also need the ability to query whether multiview is supported by hardware or not using </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">VkPhysicalDeviceMultiviewFeatures</span></strong><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">Additionally, we need to specify that we will be using multiple views when creating the render pass. </span><span class="koboSpan" id="kobo.421.3">This is done by adding an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">VkRenderPassMultiviewCreateInfo</span></strong><span class="koboSpan" id="kobo.423.1"> structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">pNext</span></strong><span class="koboSpan" id="kobo.425.1"> chain of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">VkRenderPassCreateInfo</span></strong><span class="koboSpan" id="kobo.427.1"> structure. </span><span class="koboSpan" id="kobo.427.2">One other important part is that swapchain images need to have multiple layers (in our case, two—one for each eye), and the results of the rendering go to different layers of the attachments. </span><span class="koboSpan" id="kobo.427.3">You may think that we could have rendered the same scene twice (one for left and one for right), but that would mean we build a command buffer that sends all the geometry and textures twice. </span><span class="koboSpan" id="kobo.427.4">This extension helps us send data only once and only shaders are fired twice (for each view ID). </span><span class="koboSpan" id="kobo.427.5">The only difference between these two executions is uniform data for </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the camera.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">To support multiview, code changes are required in various areas of the code base. </span><span class="koboSpan" id="kobo.429.2">In this case, we needed to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Texture</span></strong><span class="koboSpan" id="kobo.431.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">RenderPass</span></strong><span class="koboSpan" id="kobo.433.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Context</span></strong><span class="koboSpan" id="kobo.435.1"> classes, and </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">shader files.</span></span></p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.437.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.438.1">In the following steps, we will go through details on how to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">this recipe:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.440.1">Extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">VulkanCore::Texture</span></strong><span class="koboSpan" id="kobo.442.1"> to support </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">vkImageView</span></strong><span class="koboSpan" id="kobo.444.1"> created using </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">VK_IMAGE_VIEW_TYPE_2D_ARRAY</span></strong><span class="koboSpan" id="kobo.446.1">; this is necessary if we have multiple layers in the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">same texture.</span></span></li>
<li><span class="koboSpan" id="kobo.448.1">Add support for multiview in </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">VulkanCore::RenderPass</span></strong><span class="koboSpan" id="kobo.450.1">; this is achieved by connecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">VkRenderPassMultiviewCreateInfo</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.452.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">VkRenderPassCreateInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.455.1">Add support to enable multiview extension in </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">VulkanCore::Context</span></strong><span class="koboSpan" id="kobo.457.1">; this is abstracted in a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">enableMultiView</span></strong><span class="koboSpan" id="kobo.459.1">, which simply enables </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">VkPhysicalDeviceMultiviewFeatures</span></strong><span class="koboSpan" id="kobo.461.1"> if it is supported by a </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">physical device.</span></span></li>
<li><span class="koboSpan" id="kobo.463.1">The vertex </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.464.1">shader is now passed two </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Model View Projection</span></strong><span class="koboSpan" id="kobo.466.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.467.1">MVP</span></strong><span class="koboSpan" id="kobo.468.1">) matrices, one for the left eye and the other </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.469.1">for the right eye. </span><span class="koboSpan" id="kobo.469.2">A function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Context::mvp(index)</span></strong><span class="koboSpan" id="kobo.471.1"> was introduced, so that we can query MVP for the left and </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">right eye.</span></span></li>
<li><span class="koboSpan" id="kobo.473.1">We also introduced a constant named </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">kUseSinglePassStereo</span></strong><span class="koboSpan" id="kobo.475.1"> that can be used to control whether we want to use a single pass </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">or not.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.477.1">Given that the code is distributed across various files, we strongly suggest delving into the repository for a comprehensive review of the implementation. </span><span class="koboSpan" id="kobo.477.2">Specifically, the file located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">source/chapter8/app/src/main/cpp/main.cpp</span></strong><span class="koboSpan" id="kobo.479.1"> should warrant your </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">particular attention.</span></span></p>
<h1 id="_idParaDest-283"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.481.1">Implementing static foveated rendering with a fragment density map</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.482.1">Foveated rendering</span></strong><span class="koboSpan" id="kobo.483.1"> is a </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.484.1">cutting-edge graphics rendering technique </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.485.1">that leverages the human eye’s natural tendency to focus on specific regions of a scene, optimizing computational resources by allocating higher detail and resolution to the </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.486.1">central, foveal vision, and progressively reducing it toward the peripheral vision. </span><span class="koboSpan" id="kobo.486.2">This mimics the way the human eye perceives detail, offering a substantial performance boost in graphics rendering without sacrificing </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">visual quality.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">In this </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.489.1">recipe, we will see how to implement fixed foveated rendering by using the </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">fragment density map</span></strong><span class="koboSpan" id="kobo.491.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.492.1">FDM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">) extension.</span></span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.494.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.495.1">The FDM device extension in Vulkan (</span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">VK_EXT_fragment_density</span></strong><span class="koboSpan" id="kobo.497.1">) enables an application to specify different levels of detail to use in different areas of the render target </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.498.1">by means of a texture that encodes how many times a fragment shader will be invoked for </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.499.1">that area. </span><span class="koboSpan" id="kobo.499.2">The FDM may be modified on each frame to accommodate the user’s eye gaze direction. </span><span class="koboSpan" id="kobo.499.3">This recipe only works with HMDs that provide eye gaze detection, such as Meta’s Quest Pro. </span><span class="koboSpan" id="kobo.499.4">The recipe presented here works for a single-pass stereo </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">rendering approach.</span></span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.501.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.502.1">Before creating and using an FDM and the FDM Offset extension, we need to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">the extensions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.504.1">Before enabling the feature, it is necessary to check whether the physical device supports it. </span><span class="koboSpan" id="kobo.504.2">Doing so requires appending an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">VkPhysicalDeviceFragmentDensityMapFeaturesEXT</span></strong><span class="koboSpan" id="kobo.506.1"> structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">pNext</span></strong><span class="koboSpan" id="kobo.508.1"> chain of </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">VkPhysicalDeviceFeatures2</span></strong><span class="koboSpan" id="kobo.510.1"> passed to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">vkGetPhysicalDeviceFeatures2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1"> function.</span></span><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">VkPhysicalDeviceFragmentDensityMapFeaturesEXT:: fragmentDensityMap</span></strong><span class="koboSpan" id="kobo.514.1"> specifies whether the device supports the </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">FDM extension.</span></span></p></li>
<li><span class="koboSpan" id="kobo.516.1">The extension has properties that need to be queried to be used properly. </span><span class="koboSpan" id="kobo.516.2">To do that, also include an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">VkPhysicalDeviceFragmentDensityMapPropertiesEXT</span></strong><span class="koboSpan" id="kobo.518.1"> structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">pNext</span></strong><span class="koboSpan" id="kobo.520.1"> chain of </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">VkPhysicalDeviceProperties2</span></strong><span class="koboSpan" id="kobo.522.1"> and query those properties with </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">vkGetPhysicalDeviceProperties2</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">We will use these properties in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.525.1">step 4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.527.1">The FDM extension is a device extension and its name needs to be passed in during the creation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">VkDevice</span></strong><span class="koboSpan" id="kobo.529.1"> object: </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">"VK_EXT_fragment_density_map"</span></strong><span class="koboSpan" id="kobo.531.1"> (or the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">definition, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.535.1">An FDM’s size doesn’t map to the framebuffers on a one-to-one ratio. </span><span class="koboSpan" id="kobo.535.2">One texel of the </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.536.1">map affects an </span><em class="italic"><span class="koboSpan" id="kobo.537.1">area</span></em><span class="koboSpan" id="kobo.538.1"> of the render target. </span><span class="koboSpan" id="kobo.538.2">This area’s size can be queried from </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">VkPhysicalDeviceFragmentDensityMapPropertiesEXT</span></strong><span class="koboSpan" id="kobo.540.1">, from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">minFragmentDensityTexelSize</span></strong><span class="koboSpan" id="kobo.542.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">maxFragmentDensityTexelSize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1"> properties.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.545.1">In </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.546.1">our recipe, we will create an FDM with texels that map to an area that is at least 32 x 32 of the render target, bounded </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">minFragmentDensityTexelSize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.550.1">
const glm::vec2 mapSize = glm::vec2(
    std::ceilf(
        oxrContext.swapchain(0)
            -&gt;viewport()
            .recommendedImageRectWidth /
        std::max(
            32u,
            vkContext.physicalDevice()
                .fragmentDensityMapProperties()
                .minFragmentDensityTexelSize.width)),
    std::ceilf(
        oxrContext.swapchain(0)
            -&gt;viewport()
            .recommendedImageRectHeight /
        std::max(
            32u,
            vkContext.physicalDevice()
                .fragmentDensityMapProperties()
                .minFragmentDensityTexelSize.height)));</span></pre></li> <li><span class="koboSpan" id="kobo.551.1">An </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.552.1">FDM is </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.553.1">a regular texture with some special </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">usage flags:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
std::shared_ptr&lt;VulkanCore::Texture&gt; =
    std::make_shared&lt;VulkanCore::Texture&gt;(
        vkContext, VK_IMAGE_TYPE_2D,
        VK_FORMAT_R8G8_UNORM,
        static_cast&lt;VkImageCreateFlags&gt;(0),
        VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
        VkExtent3D{static_cast&lt;uint32_t&gt;(mapSize.x),
                   static_cast&lt;uint32_t&gt;(mapSize.y),
                   1},
        1, 2, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
        false, VK_SAMPLE_COUNT_1_BIT,
        "fragment density map", true,
        VK_IMAGE_TILING_LINEAR);</span></pre></li> <li><span class="koboSpan" id="kobo.556.1">The format of the texture is </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">VK_FORMAT_R8G8_UNORM</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">Each pixel stored in the map specifies the density of fragments to be used for that area of the render target, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">255</span></strong><span class="koboSpan" id="kobo.560.1"> means the density should be the highest (or the default: one fragment per render target’s pixel; </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">128</span></strong><span class="koboSpan" id="kobo.562.1"> for half the density, and so on). </span><span class="koboSpan" id="kobo.562.2">In our recipe, our map is initialized to </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">128</span></strong><span class="koboSpan" id="kobo.564.1"> (half density) and then manipulated to have an area in the center with a radius equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">2</span></strong><span class="koboSpan" id="kobo.566.1"> texels with </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">full density:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.568.1">
std::vector&lt;uint8_t&gt; fdmData(mapSize.x *mapSize.y * 2,
                             255);
constexpr uint16_t high_res_radius = 8;
const glm::vec2 center = mapSize / 2.f;
for (uint32_t x = 0; x &lt; mapSize.x; ++x) {
  for (uint32_t y = 0; y &lt; mapSize.y; ++y) {
    const float length =
        glm::length(glm::vec2(x, y) - center);
    if (length &lt; high_res_radius) {
      const uint32_t index =
          (y * mapSize.x * 2) + x * 2;
      fdmData[index] = 255;     // full density
      fdmData[index + 1] = 255; // full density</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.569.1">Note </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.570.1">that the image has two layers, one for each eye. </span><span class="koboSpan" id="kobo.570.2">The data is uploaded to the </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.571.1">device twice, once for each layer of </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the image.</span></span></p></li> <li><span class="koboSpan" id="kobo.573.1">Once the data has been uploaded for each layer of the map, the texture’s layout needs to be transitioned to the special </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">layout, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.577.1">The FDM needs to be specified and referenced by the render pass in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">VkAttachmentDescription</span></strong><span class="koboSpan" id="kobo.579.1"> structure, just like any other attachment used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">render pass:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
const auto fdmAttachDesc = VkAttachmentDescription{
    .format = VK_FORMAT_R8G8_UNORM,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    .loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    .initialLayout =
        VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
    .finalLayout =
        VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
};</span></pre></li> <li><span class="koboSpan" id="kobo.582.1">The </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.583.1">FDM must not appear as a color or depth</span><span class="Annotation-reference"> </span><span class="koboSpan" id="kobo.584.1">stencil attachment in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">VkSubpassDescription::pColorAttachments</span></strong><span class="koboSpan" id="kobo.586.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">VkSubpassDescription::pDepthStencilAttachment</span></strong><span class="koboSpan" id="kobo.588.1"> arrays. </span><span class="koboSpan" id="kobo.588.2">Instead, it </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.589.1">must be referenced in an instance of the special </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">VkRenderPassFragmentDensityMapCreateInfoEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
const VkRenderPassFragmentDensityMapCreateInfoEXT
    fdmAttachmentci = {
        .sType =
            VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
        .fragmentDensityMapAttachment =
            {
                .attachment =
                    </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">fragmentDensityAttachmentReference</span></strong><span class="koboSpan" id="kobo.594.1">,
                .layout =
                    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
            },
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.595.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">fragmentDensityAttachmentReference</span></strong><span class="koboSpan" id="kobo.597.1"> variable in the preceding snippet </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.598.1">refers to the </span><em class="italic"><span class="koboSpan" id="kobo.599.1">index</span></em><span class="koboSpan" id="kobo.600.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">VkAttachmentDescription</span></strong><span class="koboSpan" id="kobo.602.1"> structure </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.603.1">that mentions the FDM in the attachment description array passed </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">VkRenderPassCreateInfo::pAttachments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">.</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.607.1">Bug prevention notice</span></p>
<p class="callout"><span class="koboSpan" id="kobo.608.1">The order in which this structure appears in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">VkRenderPassCreateInfo:: pAttachments</span></strong><span class="koboSpan" id="kobo.610.1"> array must match the index of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">VkImage</span></strong><span class="koboSpan" id="kobo.612.1"> array passed </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">VkFramebufferCreateInfo::pAttachments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">.</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.616.1">The instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">VkRenderPassFragmentDensityMapCreateInfoEXT</span></strong><span class="koboSpan" id="kobo.618.1"> structure needs to be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">pNext</span></strong><span class="koboSpan" id="kobo.620.1"> chain property of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">VkRenderPassCreateInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
const VkRenderPassCreateInfo rpci = {
    .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    .pNext = </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">&amp;fdmAttachmentci</span></strong><span class="koboSpan" id="kobo.625.1">,
    ...
</span><span class="koboSpan" id="kobo.625.2">};</span></pre></li> <li><span class="koboSpan" id="kobo.626.1">The image view of the FDM needs to be part of the framebuffer as well. </span><span class="koboSpan" id="kobo.626.2">Its image view must be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">VkFramebufferCreateInfo::pAttachments</span></strong><span class="koboSpan" id="kobo.628.1"> array and its index into this array must match that of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">VkAttachmentDescription</span></strong><span class="koboSpan" id="kobo.630.1"> structure passed to the creation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">render pass.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.632.1">This marks </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.633.1">the end of our guide on static foveated rendering. </span><span class="koboSpan" id="kobo.633.2">In the upcoming sections, we’ll </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.634.1">expand our exploration into the realm of dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">foveated rendering.</span></span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.636.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.637.1">For more information, check out the extension information at the </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">following links:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.639.1">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map.html</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.640.1">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_fragment_density_map_offset.html</span></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">.</span></span></li>
</ul>
<h1 id="_idParaDest-287"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.642.1">Retrieving eye gaze information from OpenXR in your app</span></h1>
<p><span class="koboSpan" id="kobo.643.1">The realm of VR has evolved to the extent that some HMDs are now equipped with the capability </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.644.1">to track the user’s eye gaze. </span><span class="koboSpan" id="kobo.644.2">This feature, which identifies the direction in which the user is looking, can be harnessed </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.645.1">for a variety of tasks, enhancing the interactivity and immersion of VR experiences. </span><span class="koboSpan" id="kobo.645.2">In this recipe, we will guide you through the process of enabling and retrieving eye gaze data from OpenXR in your application. </span><span class="koboSpan" id="kobo.645.3">Additionally, we will illustrate how to calculate the focal region—the specific area the user is looking at—in pixel coordinates on the render target used </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">for display.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.647.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.648.1">For this recipe, you will need an HMD that supports eye-tracking features, such as Meta’s Quest Pro. </span><span class="koboSpan" id="kobo.648.2">You will also need to provide permission to the app to track the user’s eye, which can be achieved through the </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">Settings</span></strong><span class="koboSpan" id="kobo.650.1"> menu on </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">most devices.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">Also, get acquainted with how spaces and actions are supported and used in OpenXR (see the </span><em class="italic"><span class="koboSpan" id="kobo.653.1">Getting started with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.654.1">OpenXR</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1"> recipe).</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">This recipe </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.657.1">was authored and tested </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.658.1">with Meta’s Quest Pro device, so some of the code shown here is specific to that platform. </span><span class="koboSpan" id="kobo.658.2">Your implementation might require small tweaks to work on </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">your device.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.660.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.661.1">Adding eye gaze support requires allowing the device to track the user’s eyes. </span><span class="koboSpan" id="kobo.661.2">This requires executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.663.1">Before using the eye-tracking feature in your app, you need to request permission by adding the following lines to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">AndroidManifest.xml</span></strong><span class="koboSpan" id="kobo.665.1"> file of </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">your app:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.667.1">
&lt;uses-permission android:name="com.oculus.permission.EYE_TRACKING" /&gt;
&lt;uses-permission android:name="oculus.software.eye_tracking" /&gt;
&lt;uses-feature android:name="oculus.software.eye_tracking"/&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.668.1">Grant permission to your app to track the user’s eye with </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.670.1">
adb shell pm grant </span><strong class="bold"><span class="koboSpan" id="kobo.671.1">com.example.openxrsample</span></strong><span class="koboSpan" id="kobo.672.1"> com.oculus.permission.EYE_TRACKING</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.673.1">Run the preceding command on a terminal on your desktop with your headset connected to it. </span><span class="koboSpan" id="kobo.673.2">The command grants permission to the app called </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">com.example.openxrsample</span></strong><span class="koboSpan" id="kobo.675.1"> and you might need to change it to your </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">app’s name.</span></span></p></li> <li><span class="koboSpan" id="kobo.677.1">Enable </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.678.1">the OpenXR extension </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.679.1">when creating your OpenXR instance by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.681.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">XrInstanceCreateInfo::enableExtensionNames</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1"> array:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.684.1">
const XrApplicationInfo appInfo = {
    .applicationName = "OpenXR Example",
    .applicationVersion = 0,
    .engineName = "OpenXR Example",
    .engineVersion = 0,
    .apiVersion = XR_CURRENT_API_VERSION,
};
std::vector&lt;const char *&gt; requestedExtensions = {
    XR_KHR_VULKAN_ENABLE_EXTENSION_NAME,
   XR_FB_SWAPCHAIN_UPDATE_STATE_VULKAN_EXTENSION_NAME,
    </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.686.1">,
};
const XrInstanceCreateInfo instanceCreateInfo = {
    .type = XR_TYPE_INSTANCE_CREATE_INFO,
    .createFlags = 0,
    .applicationInfo = appInfo,
    .enabledApiLayerCount = 0,
    .enabledApiLayerNames = nullptr,
    .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
        requestedExtensions_.size()),
    .enabledExtensionNames =
        requestedExtensions_.data(),
};
XR_CHECK(xrCreateInstance(&amp;instanceCreateInfo,
                          &amp;instance_));</span></pre></li> <li><span class="koboSpan" id="kobo.687.1">We begin </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.688.1">by adding a few member </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.689.1">variables to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">OXR:Context</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.691.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.692.1">
XrActionSet eyegazeActionSet_ = XR_NULL_HANDLE;
XrAction eyeGazeAction_ = XR_NULL_HANDLE;
XrSpace gazeActionSpace_ = XR_NULL_HANDLE;
XrSpace localReferenceSpace_ = XR_NULL_HANDLE;</span></pre></li> <li><span class="koboSpan" id="kobo.693.1">Eye tracking is considered an input action in OpenXR, so we create an action set to store the eye-tracking </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">action (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">OXR::Context::eyegazeActionSet_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
const XrActionSetCreateInfo actionSetInfo{
    .type = XR_TYPE_ACTION_SET_CREATE_INFO,
    .actionSetName = "gameplay",
    .localizedActionSetName = "Eye Gaze Action Set",
    .priority = 0,
};
XR_CHECK(xrCreateActionSet(instance_, &amp;actionSetInfo,
                           &amp;eyegazeActionSet_));</span></pre></li> <li><span class="koboSpan" id="kobo.698.1">We then create an action that represents the eye </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">gaze input:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.700.1">
const XrActionCreateInfo actionInfo{
    .type = XR_TYPE_ACTION_CREATE_INFO,
    .actionName = "user_intent",
    .actionType = XR_ACTION_TYPE_POSE_INPUT,
    .localizedActionName = "Eye Gaze Action",
};
XR_CHECK(xrCreateAction(eyegazeActionSet_, &amp;actionInfo,
                        &amp;eyegazeAction_));</span></pre></li> <li><span class="koboSpan" id="kobo.701.1">We’ll </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.702.1">need paths that identify </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.703.1">the input action and </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">its pose:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.705.1">
XrPath eyeGazeInteractionProfilePath;
XR_CHECK(xrStringToPath(
    instance_,
    "/interaction_profiles/ext/eye_gaze_interaction",
    &amp;eyeGazeInteractionProfilePath));
XrPath gazePosePath;
XR_CHECK(xrStringToPath(
    instance_, "/user/eyes_ext/input/gaze_ext/pose",
    &amp;gazePosePath));</span></pre></li> <li><span class="koboSpan" id="kobo.706.1">The action and its pose need to be bound together using an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">XrActionSuggestedBinding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.708.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.709.1">
const XrActionSuggestedBinding bindings{
    .action = eyegazeAction_,
    .binding = gazePosePath,
};
const XrInteractionProfileSuggestedBinding
    suggestedBindings{
        .type =
            XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING,
        .interactionProfile =
            eyeGazeInteractionProfilePath,
        .countSuggestedBindings = 1,
        .suggestedBindings = &amp;bindings,
    };
XR_CHECK(xrSuggestInteractionProfileBindings(
    instance_, &amp;suggestedBindings));</span></pre></li> <li><span class="koboSpan" id="kobo.710.1">Actions </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.711.1">need to be attached </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.712.1">to a session to work, which can be done by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">xrAttachSessionActionSets</span></strong><span class="koboSpan" id="kobo.714.1"> with the action set that stores the eye </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">gaze action:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.716.1">
const XrSessionActionSetsAttachInfo attachInfo{
    .type = XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO,
    .countActionSets = 1,
    .actionSets = &amp;eyegazeActionSet_,
};
XR_CHECK(xrAttachSessionActionSets(session_,
                                   &amp;attachInfo));</span></pre></li> <li><span class="koboSpan" id="kobo.717.1">We also need to create an action space for the eye gaze action to define a position and orientation of the new space’s origin within a natural reference frame of the </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">pose action:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.719.1">
const XrActionSpaceCreateInfo createActionSpaceInfo{
    .type = XR_TYPE_ACTION_SPACE_CREATE_INFO,
    .action = eyegazeAction_,
    .poseInActionSpace = poseIdentity_,
};
XR_CHECK(xrCreateActionSpace(session_,
                             &amp;createActionSpaceInfo,
                             &amp;gazeActionSpace_));</span></pre></li> <li><span class="koboSpan" id="kobo.720.1">The last </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.721.1">initialization step is to </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.722.1">create a local reference space, which we’ll use to base the eye gaze position and orientation. </span><span class="koboSpan" id="kobo.722.2">The type of the reference space is </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">XR_REFERENCE_SPACE_TYPE_VIEW</span></strong><span class="koboSpan" id="kobo.724.1"> as the eye gaze is locked to the eye or headset location and orientation. </span><span class="koboSpan" id="kobo.724.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">eyePoseIdentity</span></strong><span class="koboSpan" id="kobo.726.1"> variable is initialized with the identity orientation, at a height of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">1.8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1"> meters:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
const XrPosef eyePoseIdentity = {
  .orientation = {.x = 0,
                  .y = 0,
                  .z = 0,
                  .w = 1.f},
  .position = {0, 1.8f, 0},
};
const XrReferenceSpaceCreateInfo
    createReferenceSpaceInfo{
        .type = XR_TYPE_REFERENCE_SPACE_CREATE_INFO,
        .referenceSpaceType =
            XR_REFERENCE_SPACE_TYPE_VIEW,
        .poseInReferenceSpace = </span><strong class="bold"><span class="koboSpan" id="kobo.730.1">eyePoseIdentity</span></strong><span class="koboSpan" id="kobo.731.1">,
    };
XR_CHECK(xrCreateReferenceSpace(
    session_, &amp;createReferenceSpaceInfo,
    &amp;localReferenceSpace_));</span></pre></li> <li><span class="koboSpan" id="kobo.732.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">OXR::Context::beginFrame</span></strong><span class="koboSpan" id="kobo.734.1"> method, we update the current state of the </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.735.1">eye gaze action, but only if </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.736.1">the current state of the app is </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">focused</span></strong><span class="koboSpan" id="kobo.738.1">. </span><span class="koboSpan" id="kobo.738.2">We can then get the action’s state pose </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">xrGetActionStatePose</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.742.1">
if (currentState_ == XR_SESSION_STATE_FOCUSED) {
  XrActiveActionSet activeActionSet{
      .actionSet = eyegazeActionSet_,
      .subactionPath = XR_NULL_PATH,
  };
  const XrActionsSyncInfo syncInfo{
      .type = XR_TYPE_ACTIONS_SYNC_INFO,
      .countActiveActionSets = 1,
      .activeActionSets = &amp;activeActionSet,
  };
  XR_CHECK(xrSyncActions(session_, &amp;syncInfo));
  XrActionStatePose actionStatePose{
      XR_TYPE_ACTION_STATE_POSE};
  const XrActionStateGetInfo getActionStateInfo{
      .type = XR_TYPE_ACTION_STATE_GET_INFO,
      .action = eyegazeAction_,
  };
  XR_CHECK(xrGetActionStatePose(session_,
                                &amp;getActionStateInfo,
                                &amp;actionStatePose));</span></pre></li> <li><span class="koboSpan" id="kobo.743.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">actionStatePose</span></strong><span class="koboSpan" id="kobo.745.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">active</span></strong><span class="koboSpan" id="kobo.747.1">, that means we can go ahead and locate the action </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.748.1">in </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">localReferenceSpace</span></strong><span class="koboSpan" id="kobo.750.1"> at the </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.751.1">predicted time from the frame state </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">queried before:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.753.1">
  if (actionStatePose.isActive)
    XrEyeGazeSampleTimeEXT eyeGazeSampleTime{
        XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT};
    XrSpaceLocation gazeLocation{
        XR_TYPE_SPACE_LOCATION, &amp;eyeGazeSampleTime};
    XR_CHECK(xrLocateSpace(
        gazeActionSpace_, localReferenceSpace_,
        frameState.predictedDisplayTime,
        &amp;gazeLocation));</span></pre></li> <li><span class="koboSpan" id="kobo.754.1">If both the gaze’s orientation and position are valid, we can use them to calculate where, in pixel coordinates, the user is looking at the image being presented on </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">the device:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.756.1">
    const bool orientationValid =
        gazeLocation.locationFlags &amp;
        XR_SPACE_LOCATION_ORIENTATION_VALID_BIT;
    const bool positionValid =
        gazeLocation.locationFlags &amp;
        XR_SPACE_LOCATION_POSITION_VALID_BIT;
    if (orientationValid &amp;&amp; positionValid) {
      eyeGazePositionScreen_[0] =
        screenCoordinatesFromEyeGazePose(gazeLocation,
                                         0, 0);
      eyeGazePositionScreen_[1] =
        screenCoordinatesFromEyeGazePose(gazeLocation,
                                         1, 0);
    }</span></pre></li> <li><span class="koboSpan" id="kobo.757.1">Calculating </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.758.1">the screen coordinates </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.759.1">of the user’s gaze is simple. </span><span class="koboSpan" id="kobo.759.2">The following function performs all the math to convert from an </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">XrPosef</span></strong><span class="koboSpan" id="kobo.761.1"> structure (the eye gaze location) to the coordinates on the screen. </span><span class="koboSpan" id="kobo.761.2">It uses the swapchain dimensions to convert the canonical view direction in OpenXR, which points to the </span><em class="italic"><span class="koboSpan" id="kobo.762.1">-Z</span></em><span class="koboSpan" id="kobo.763.1"> direction, to </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">screen space:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.765.1">
glm::vec3
Context::screenCoordinatesFromEyeGazePose(
  XrSpaceLocation gazeLocation, int eye,
  float offset) {
  XrVector3f canonicalViewDirection{0, 0, -1.f};
  // Reset the position. </span><span class="koboSpan" id="kobo.765.2">We won't need it
  gazeLocation.pose.position = {0, 0, 0};
  XrVector3f transformedViewDirection;
  XrPosef_TransformVector3f(
    &amp;transformedViewDirection, &amp;gazeLocation.pose,
    &amp;canonicalViewDirection);
  XrMatrix4x4f proj;
  XrMatrix4x4f_CreateProjectionFov(
    &amp;proj, GRAPHICS_OPENGL, views_[eye].fov,
    near_, far_);
  const XrVector4f tanAngle = {
    -transformedViewDirection.x /
      transformedViewDirection.z,
    -transformedViewDirection.y /
      transformedViewDirection.z,
    -1.f, 0};
  const auto width = swapchain(0)
                       -&gt;viewport()
                       .recommendedImageRectWidth;
  const auto height =
    swapchain(0)
      -&gt;viewport()
      .recommendedImageRectHeight;
  XrMatrix4x4f scalem;
  XrMatrix4x4f_CreateScale(&amp;scalem, 0.5f, 0.5f,
                           1.f);
  XrMatrix4x4f biasm;
  XrMatrix4x4f_CreateTranslation(&amp;biasm, 0.5f,
                                 0.5f, 0);
  XrMatrix4x4f rectscalem;
  XrMatrix4x4f_CreateScale(&amp;rectscalem, width,
                           height, 1.f);
  XrMatrix4x4f rectbiasm;
  XrMatrix4x4f_CreateTranslation(&amp;rectbiasm, 0, 0,
                                 0);
  XrMatrix4x4f rectfromclipm;
  XrMatrix4x4f_Multiply(&amp;rectfromclipm,
                        &amp;rectbiasm, &amp;rectscalem);
  XrMatrix4x4f_Multiply(&amp;rectfromclipm,
                        &amp;rectfromclipm, &amp;biasm);
  XrMatrix4x4f_Multiply(&amp;rectfromclipm,
                        &amp;rectfromclipm, &amp;scalem);
  XrMatrix4x4f rectfromeyem;
  XrMatrix4x4f_Multiply(&amp;rectfromeyem,
                        &amp;rectfromclipm, &amp;proj);
  rectfromeyem.m[11] = -1.f;
  XrVector4f texCoords;
  XrMatrix4x4f_TransformVector4f(
    &amp;texCoords, &amp;rectfromeyem, &amp;tanAngle);
  return glm::vec3(texCoords.x,
                   height - texCoords.y - offset,
                   texCoords.y);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.766.1">The function uses the helper types and functions defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">xr_linear.h</span></strong><span class="koboSpan" id="kobo.768.1">. </span><span class="koboSpan" id="kobo.768.2">The projection matrix is calculated in the function, and not cached at the class level, to allow it to be modified while the app </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">is running.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.770.1">The sample </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.771.1">app in the repository displays </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.772.1">a washed-out round cursor, about 10 pixels in radius, for each eye if eye-tracking is supported by the device to help you see how the eye gaze behaves in the </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">final output.</span></span></p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.774.1">Implementing dynamic foveated rendering using Qualcomm’s fragment density map Offset extension</span></h1>
<p><span class="koboSpan" id="kobo.775.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.776.1">Implementing static foveated rendering with a fragment density map</span></em><span class="koboSpan" id="kobo.777.1"> recipe, we </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.778.1">discussed how to render fragments at a lower density than one fragment per pixel using a map that dictates the fragment density for regions of the render </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.779.1">target. </span><span class="koboSpan" id="kobo.779.2">Although useful, the application of a static map is limited because the user’s gaze changes as they look around to inspect the scene displayed on the device. </span><span class="koboSpan" id="kobo.779.3">Recomputing and modifying the map for each frame, based on the user’s input, may be computationally expensive and tax the CPU with extra work, making the performance gained with the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">FDM moot.</span></span></p>
<p><span class="koboSpan" id="kobo.781.1">Another option is to apply an offset to the static FDM and let the GPU perform the heavy lifting of translating the densities from the map to the rendered scene. </span><span class="koboSpan" id="kobo.781.2">Thanks to Qualcomm’s FDM Offset device extension, this </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">is possible.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">In this recipe, we will show you how to use this extension to dynamically translate the FDM based on the user’s </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">gaze direction.</span></span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.785.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.786.1">For this recipe, you will need an HMD that supports eye-tracking features, such as Meta’s Quest Pro. </span><span class="koboSpan" id="kobo.786.2">This recipe was authored and tested with Meta’s Quest Pro device, so some of the code shown here is specific to that platform. </span><span class="koboSpan" id="kobo.786.3">This recipe assumes you have already implemented static foveated rendering using a fragment density map. </span><span class="koboSpan" id="kobo.786.4">If not, you </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.787.1">might want to refer to our previous guide on that topic to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">foundational concepts.</span></span></p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.789.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.790.1">This </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.791.1">extension simplifies the application code by applying an offset to the FDM at render time, inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">render loop:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.793.1">All attachments used in the render pass where the offset is applied to the FDM must be created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM</span></strong><span class="koboSpan" id="kobo.795.1"> flag. </span><span class="koboSpan" id="kobo.795.2">Since we are rendering directly to swapchain images, the swapchain images need to be created with that flag. </span><span class="koboSpan" id="kobo.795.3">Swapchain images are created by OpenXR. </span><span class="koboSpan" id="kobo.795.4">Thankfully, Meta devices provide the ability to provide additional Vulkan flags to be used during the creation of swapchain images. </span><span class="koboSpan" id="kobo.795.5">For that, create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">XrVulkanSwapchainCreateInfoMETA</span></strong><span class="koboSpan" id="kobo.797.1"> structure and add the flag mentioned before to its </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">addditionalCreateFlags</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.799.1"> property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.800.1">
const XrVulkanSwapchainCreateInfoMETA
  vulkanImageAdditionalFlags{
    .type =
      XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META,
    .next = nullptr,
    .additionalCreateFlags =
      VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT |
      VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM,
  };
Const XrSwapchainCreateInfo swapChainCreateInfo = {
  .type = XR_TYPE_SWAPCHAIN_CREATE_INFO,
  .next = &amp;vulkanImageAdditionalFlags,
  ...
</span><span class="koboSpan" id="kobo.800.2">};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.801.1">The instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">XrVulkanSwapchainCreateInfoMETA</span></strong><span class="koboSpan" id="kobo.803.1"> structure must be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">pNext</span></strong><span class="koboSpan" id="kobo.805.1"> chain of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">XrSwapchainCreateInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.807.1"> structure.</span></span></p></li> <li><span class="koboSpan" id="kobo.808.1">Before </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.809.1">enabling the FDM Offset feature, it is necessary </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.810.1">to check whether the physical device supports it. </span><span class="koboSpan" id="kobo.810.2">Doing so requires appending an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM</span></strong><span class="koboSpan" id="kobo.812.1"> structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">pNext</span></strong><span class="koboSpan" id="kobo.814.1"> chain of </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">VkPhysicalDeviceFeatures2</span></strong><span class="koboSpan" id="kobo.816.1"> passed to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">vkGetPhysicalDeviceFeatures2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1"> function.</span></span><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM:: fragmentDensityMapOffset</span></strong><span class="koboSpan" id="kobo.820.1"> specifies whether the FDM Offset extension </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">is supported.</span></span></p></li>
<li><span class="koboSpan" id="kobo.822.1">The extension has properties that need to be queried to be used properly. </span><span class="koboSpan" id="kobo.822.2">To do that, also include an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM</span></strong><span class="koboSpan" id="kobo.824.1"> structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">pNext</span></strong><span class="koboSpan" id="kobo.826.1"> chain of </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">VkPhysicalDeviceProperties2</span></strong><span class="koboSpan" id="kobo.828.1"> and query those properties with </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">vkGetPhysicalDeviceProperties2</span></strong><span class="koboSpan" id="kobo.830.1">. </span><span class="koboSpan" id="kobo.830.2">We will use </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">them later.</span></span></li>
<li><span class="koboSpan" id="kobo.832.1">The FDM Offset extension is a device extension and its name needs to be passed in during the creation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">VkDevice</span></strong><span class="koboSpan" id="kobo.834.1"> object: </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">"VK_QCOM_fragment_density_map_offset"</span></strong><span class="koboSpan" id="kobo.836.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.840.1">The FDM texture needs to be created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.842.1">creation flag.</span></span></li>
<li><span class="koboSpan" id="kobo.843.1">The </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.844.1">offsets are applied to the FDM by creating an instance </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.845.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">VkSubpassFragmentDensityMapOffsetEndInfoQCOM</span></strong><span class="koboSpan" id="kobo.847.1"> structure and adding it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">pNext</span></strong><span class="koboSpan" id="kobo.849.1"> chain of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">VkSubpassEndInfo</span></strong><span class="koboSpan" id="kobo.851.1"> structure. </span><span class="koboSpan" id="kobo.851.2">Note that, in this case, you need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">vkCmdEndRenderPass2</span></strong><span class="koboSpan" id="kobo.853.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">vkCmdEndRenderPass</span></strong><span class="koboSpan" id="kobo.855.1"> isn’t extensible (we’ll see how to calculate the offsets in the </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">next step):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.857.1">
const std::array&lt;VkOffset2D, 2&gt; offsets = {
  leftEyeOffset,
  rightEyeOffset,
};
const VkSubpassFragmentDensityMapOffsetEndInfoQCOM
  offsetInfo = {
    .sType =
      VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM,
    .fragmentDensityOffsetCount =
      offsets.size(), // 1 for each
                      // layer/multiview view
    .pFragmentDensityOffsets =
      offsets
        .data(), // aligned to
                 // fragmentDensityOffsetGranularity
};
const VkSubpassEndInfo subpassEndInfo = {
  .sType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
  .pNext = &amp;offsetInfo,
};
vkCmdEndRenderPass2KHR(commandBuffer,
                       &amp;subpassEndInfo);</span></pre></li> <li><span class="koboSpan" id="kobo.858.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">eyeGazeScreenPosLeft</span></strong><span class="koboSpan" id="kobo.860.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">eyeGazeScreenPosRight</span></strong><span class="koboSpan" id="kobo.862.1"> offsets can </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.863.1">be calculated using the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.864.1">Retrieving eye gaze information from OpenXR in your app</span></em><span class="koboSpan" id="kobo.865.1">. </span><span class="koboSpan" id="kobo.865.2">In the sample app </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.866.1">provided in the repository, they can be retrieved from the context with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">OXR::Context::eyeGazeScreenPos(int </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">eye)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.869.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.870.1">
const glm::vec2 swapchainImageCenter =
  glm::vec2(oxrContext.swapchain(0)
                -&gt;viewport()
                .recommendedImageRectWidth /
              2.f,
            oxrContext.swapchain(0)
                -&gt;viewport()
                .recommendedImageRectHeight /
              2.f);
const glm::vec2 offsetInPixelsLeft =
  glm::vec2(</span><strong class="bold"><span class="koboSpan" id="kobo.871.1">eyeGazeScreenPosLeft</span></strong><span class="koboSpan" id="kobo.872.1">) -
  swapchainImageCenter;
const glm::vec2 offsetInPixelsRight =
  glm::vec2(</span><strong class="bold"><span class="koboSpan" id="kobo.873.1">eyeGazeScreenPosRight</span></strong><span class="koboSpan" id="kobo.874.1">) -
  swapchainImageCenter;
const glm::vec2 fdmOffsetGranularity = glm::vec2(
  vkContext.physicalDevice()
    .fragmentDensityMapOffsetProperties()
    .fragmentDensityOffsetGranularity.width,
  vkContext.physicalDevice()
    .fragmentDensityMapOffsetProperties()
    .fragmentDensityOffsetGranularity.height);
const VkOffset2D leftEyeOffset{
  offsetInPixelsLeft.x,
  offsetInPixelsLeft.y,
};
const VkOffset2D rightEyeOffset{
  offsetInPixelsRight.x,
  offsetInPixelsRight.y,
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.875.1">This </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.876.1">extension is powerful because it allows static </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.877.1">FDM to be used to achieve dynamic foveation without the need to impose an extra CPU load of recalculating the map every frame. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.878.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.879.1">.2</span></em><span class="koboSpan" id="kobo.880.1"> shows the result of rendering the bistro scene on a Quest Pro with an FDM plus Qualcomm’s FDM Offset extension. </span><span class="koboSpan" id="kobo.880.2">The white circle is the cursor used to help visualize the eye </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">gaze direction.</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.882.1"><img alt="Figure 8.2 – The bistro scene rendered on a Quest Pro with an FDM applied to the eye gaze direction" src="image/B18491_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.883.1">Figure 8.2 – The bistro scene rendered on a Quest Pro with an FDM applied to the eye gaze direction</span></p>
<p><span class="koboSpan" id="kobo.884.1">This </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.885.1">concludes our recipe on dynamic foveated rendering. </span><span class="koboSpan" id="kobo.885.2">In the next recipe, we </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.886.1">will learn how we can reduce memory load since the VR devices have limited </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">GPU memory.</span></span></p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.888.1">Using half floats to reduce memory load</span></h1>
<p><span class="koboSpan" id="kobo.889.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.890.1">half float</span></strong><span class="koboSpan" id="kobo.891.1">, also </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.892.1">known as a </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">half-precision floating point</span></strong><span class="koboSpan" id="kobo.894.1">, is a binary </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.895.1">floating-point format that occupies 16 bits. </span><span class="koboSpan" id="kobo.895.2">It plays a crucial role specifically for its application in VR devices and other low-performance hardware. </span><span class="koboSpan" id="kobo.895.3">A half-precision floating point has a smaller memory footprint and </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.896.1">requires less bandwidth, which can significantly improve the performance and efficiency of such devices. </span><span class="koboSpan" id="kobo.896.2">They are ideal for scenarios where the precision of full single-precision floating-point numbers is not necessary, such as storing pixel values in graphics, performing large but simple computations in machine learning models, and certain calculations in 3D graphics. </span><span class="koboSpan" id="kobo.896.3">Employing 16 bits not only bolsters throughput but also diminishes register usage, a key determinant of GPU performance. </span><span class="koboSpan" id="kobo.896.4">The quantity of shaders that can run concurrently is directly contingent upon the available registers, thus making their efficient usage crucial. </span><span class="koboSpan" id="kobo.896.5">In this recipe, we demonstrate how to use half floats in Vulkan and how we can reduce memory consumption by storing vertex data in 16-bit floats instead </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">of 32-bit.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.898.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.899.1">To implement a half float in your application, there are several Vulkan and GLSL features that you need to be aware of. </span><span class="koboSpan" id="kobo.899.2">Vulkan supports half floats by enabling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">storageBuffer16BitAccess</span></strong><span class="koboSpan" id="kobo.901.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">shaderFloat16</span></strong><span class="koboSpan" id="kobo.903.1"> features. </span><span class="koboSpan" id="kobo.903.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">storageBuffer16BitAccess</span></strong><span class="koboSpan" id="kobo.905.1"> feature allows you to use a 16-bit format for storage buffers, which can save memory and bandwidth. </span><span class="koboSpan" id="kobo.905.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">shaderFloat16</span></strong><span class="koboSpan" id="kobo.907.1"> feature enables the use of 16-bit floating-point types in your shaders, which can improve performance by reducing the amount of data that needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">be processed.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">On the GLSL side, you would need to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">GL_EXT_shader_explicit_arithmetic_types_float16</span></strong><span class="koboSpan" id="kobo.911.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">GL_EXT_shader_16bit_storage</span></strong><span class="koboSpan" id="kobo.913.1"> extensions. </span><span class="koboSpan" id="kobo.913.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">GL_EXT_shader_explicit_arithmetic_types_float16</span></strong><span class="koboSpan" id="kobo.915.1"> extension allows you to perform arithmetic operations with half-precision floating-point numbers directly in your shaders. </span><span class="koboSpan" id="kobo.915.2">Meanwhile, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">GL_EXT_shader_16bit_storage</span></strong><span class="koboSpan" id="kobo.917.1"> extension enables you to store half-precision floating-point numbers in your shader storage blocks and </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">interface blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">By leveraging these Vulkan and GLSL features, you can effectively incorporate a half float in your application, optimizing performance, especially for </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">low-performance devices.</span></span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.921.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.922.1">Follow </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.923.1">these steps to effectively implement the 16-bit float, starting with the activation of specific features and then modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">shader code:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.925.1">Initially, we must activate two specific features: </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">storageBuffer16BitAccess</span></strong><span class="koboSpan" id="kobo.927.1"> (found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">VkPhysicalDeviceVulkan11Features</span></strong><span class="koboSpan" id="kobo.929.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">shaderFloat16</span></strong><span class="koboSpan" id="kobo.931.1"> (located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">VkPhysicalDeviceVulkan12Features</span></strong><span class="koboSpan" id="kobo.933.1">). </span><span class="koboSpan" id="kobo.933.2">To facilitate this, we have incorporated a function within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">VulkanCore::Context</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.936.1">
void Context::enable16bitFloatFeature() {
  enable11Features_.storageBuffer16BitAccess = VK_TRUE;
  enable12Features_.shaderFloat16 = VK_TRUE;
}</span></pre></li> <li><span class="koboSpan" id="kobo.937.1">Next, we change our shader code and add GLSL extensions to it. </span><span class="koboSpan" id="kobo.937.2">This is done inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">app/src/main/assets/shaders/Common.glsl</span></strong><span class="koboSpan" id="kobo.939.1"> file. </span><span class="koboSpan" id="kobo.939.2">We also change the vertex structure inside this file to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">float16_t</span></strong><span class="koboSpan" id="kobo.941.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">float</span></strong><span class="koboSpan" id="kobo.943.1">. </span><span class="koboSpan" id="kobo.943.2">We also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">glm::packHalf1x16</span></strong><span class="koboSpan" id="kobo.945.1"> to convert a 32-bit float to 16-bit when loading </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">GLB assets:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.947.1">
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
struct Vertex {
  float16_t posX;
  float16_t posY;
  float16_t posZ;
  float16_t normalX;
  float16_t normalY;
  float16_t normalZ;
  float16_t tangentX;
  float16_t tangentY;
  float16_t tangentZ;
  float16_t tangentW;
  float16_t uvX;
  float16_t uvY;
  float16_t uvX2;
  float16_t uvY2;
  int material;
};</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.948.1">In conclusion, implementing a 16-bit float offers significant improvement in GPU performance, especially in the context of VR and other low-performance devices. </span><span class="koboSpan" id="kobo.948.2">By activating </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.949.1">the necessary features in Vulkan and making the appropriate adjustments in our GLSL shaders, we can take advantage of the benefits that a 16-bit float has to offer. </span><span class="koboSpan" id="kobo.949.2">It’s a relatively straightforward process that involves enabling specific features, adjusting shader code, and modifying data structures to accommodate the </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">half-precision format.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">In this chapter, you embarked on a journey through the world of OpenXR. </span><span class="koboSpan" id="kobo.951.2">You started by grasping the fundamentals and swiftly moved on to mastering advanced techniques. </span><span class="koboSpan" id="kobo.951.3">You learned how to implement single pass multiview rendering and how to utilize the fragment density map for static foveated rendering. </span><span class="koboSpan" id="kobo.951.4">You also gained the skills to retrieve eye gaze information for your app. </span><span class="koboSpan" id="kobo.951.5">Further, you unlocked the secrets of implementing dynamic foveated rendering using Qualcomm’s fragment density map Offset extension. </span><span class="koboSpan" id="kobo.951.6">Lastly, you discovered the power of using half floats to significantly reduce memory load in </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">your applications.</span></span></p>
</div>
</body></html>