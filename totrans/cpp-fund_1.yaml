- en: '*Chapter 1*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*'
- en: Getting Started
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Lesson Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程目标
- en: 'By the end of this chapter, you will be able:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Explain the C++ compilation model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释C++编译模型
- en: Execute the `main()` function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`main()`函数
- en: Illustrate the declaration and definition of variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明变量的声明和定义
- en: Determine built-in arithmetic types, references, and pointers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定内置算术类型、引用和指针
- en: Explain the scope of a variable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释变量的作用域
- en: Use control flow statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制流语句
- en: Define and utilize arrays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义并使用数组
- en: In this chapter, you will learn about the usage of variables and control flow
    statements to create more robust programs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用变量和控制流语句来创建更健壮的程序。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: C++ has been a major player in the software development industry for more than
    30 years, supporting some of the most successful companies in the world.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++在软件开发行业中已经是一个主要角色超过30年，支持世界上一些最成功的公司。
- en: In recent years, interest in the language has been growing more than ever, and
    it is an extremely popular choice for large-scale systems, with many big companies
    sponsoring its advancement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，对该语言的需求比以往任何时候都要增长，它是一个极其流行的选择，适用于大规模系统，许多大型公司都赞助其发展。
- en: C++ remains a complex language, which puts a lot of power in the hands of the
    developer. However, this also comes with a lot of opportunities to make mistakes.
    It is a unique language as it has the ability to enable programmers to write high-level
    abstractions while retaining full control of hardware, performance, and maintainability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++仍然是一种复杂的语言，它将大量权力交到开发者手中。然而，这也带来了很多犯错的机会。它是一种独特的语言，因为它能够使程序员编写高级抽象，同时保留对硬件、性能和可维护性的完全控制。
- en: The C++ Compilation Model
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++编译模型
- en: 'It is fundamental to know how C++ compilation works to understand how programs
    are compiled and executed. Compiling C++ source code into machine-readable code
    consists of the following four processes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 了解C++编译工作原理是理解程序如何编译和执行的基础。将C++源代码编译成机器可读代码包括以下四个过程：
- en: Preprocessing the source code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预处理源代码。
- en: Compiling the source code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码。
- en: Assembling the compiled file.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编编译后的文件。
- en: Linking the object code file to create an executable file.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标代码文件链接以创建可执行文件。
- en: Let's start with a simple C++ program to understand how compilation happens.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的C++程序开始，了解编译是如何发生的。
- en: 'Create a file named `HelloUniverse.cpp` and save it on the **Desktop** after
    copy-pasting the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`HelloUniverse.cpp`的文件，并将以下代码复制粘贴到桌面后保存：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, using the `cd` command on the Terminal, navigate to the location where
    our file is saved and execute the following command if you are on UNIX:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用终端上的`cd`命令导航到文件保存的位置，如果你使用的是UNIX系统，请执行以下命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are on a Windows system, a different compiler must be used. The command
    to compile the code with the Visual Studio compiler is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows系统，必须使用不同的编译器。使用Visual Studio编译器编译代码的命令如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program, once executed, will print `Hello Universe` on the Terminal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序一旦执行，将在终端上打印`Hello Universe`。
- en: 'Let''s demystify the C++ compilation process using the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下图表来揭示C++编译过程：
- en: '![Figure 1.1: C++ compilation of the HelloUniverse file](img/C11557_01_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：HelloUniverse文件的C++编译](img/C11557_01_01.jpg)'
- en: 'Figure 1.1: C++ compilation of the HelloUniverse file'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：HelloUniverse文件的C++编译
- en: When the C++ preprocessor encounters the `#include <file>` directive, it replaces
    it with the content of the file creating an expanded source code file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当C++预处理器遇到`#include <file>`指令时，它将其替换为文件的内容，创建一个扩展的源代码文件。
- en: Then, this expanded source code file is compiled into an assembly language for
    the platform.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这个扩展的源代码文件被编译成平台的汇编语言。
- en: The assembler converts the file that's generated by the compiler into the object
    code file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器生成的文件被汇编器转换成目标代码文件。
- en: This object code file is linked together with the object code files for any
    library functions to produce an executable file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此目标代码文件与任何库函数的目标代码文件链接在一起，生成可执行文件。
- en: Difference Between Header and Source Files
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题文件和源文件的差异
- en: Source files contain the actual implementation code. Source files typically
    have the extension `.cpp`, although other extensions such as `.cc`, `.ccx`, or
    `.c++` are also quite common.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件包含实际的实现代码。源文件通常具有`.cpp`扩展名，尽管其他扩展名如`.cc`、`.ccx`或`.c++`也很常见。
- en: On the other hand, header files contain code that describes the functionalities
    that are available. These functionalities can be referred to and used by the executable
    code in the source files, allowing source files to know what functionality is
    defined in other source files. The *most* common extensions for header files are
    `.hpp`, `.hxx`, and `.h`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，头文件包含描述可用功能的代码。这些功能可以通过源文件中的可执行代码进行引用和使用，允许源文件知道在其他源文件中定义了哪些功能。头文件最常见的扩展名是`.hpp`、`.hxx`和`.h`。
- en: To create an executable file from the header and the source files, the compiler
    starts by preprocessing the directives (preceded by a `#` sign and generally at
    the top of the files) that are contained in them. In the preceding `HelloUniverse`
    program, the directive would be `#include`. It is preprocessed by the compiler
    before actual compilation and replaced with the content of the `iostream` header,
    which describes standard functionality for reading and writing from streams.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头文件和源文件创建可执行文件，编译器首先预处理它们包含的指令（以`#`符号开头，通常位于文件顶部）。在先前的`HelloUniverse`程序中，指令将是`#include`。在真正的编译之前，编译器会对其进行预处理，并将其替换为`iostream`头文件的内容，该文件描述了从流中进行读取和写入的标准功能。
- en: The second step is to process each source file and produce an object file that
    contains the machine code relative to that source file. Finally, the compilers
    link all the object files into a single executable program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是处理每个源文件，并生成包含与该源文件相关的机器代码的对象文件。最后，编译器将所有对象文件链接成一个单独的可执行程序。
- en: We saw that the preprocessor converts the content of the directives into the
    source files. Headers can also include other headers, which will be expanded,
    creating a chain of expansions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，预处理器将指令的内容转换为源文件。头文件也可以包含其他头文件，这将进行展开，创建一个展开链。
- en: 'For example, let''s assume that the content of the `logger.hpp` header is as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设`logger.hpp`头文件的内容如下：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s also assume that the content of the `calculator.hpp` header is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也假设`calculator.hpp`头文件的内容如下：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `main.cpp` file, we include both directives, as shown in the following
    code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件中，我们包含了两个指令，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result of the expansion will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 展开的结果将如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, the logger has been added in the resulting file twice:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，日志记录器在结果文件中添加了两次：
- en: It was added the first time because we included `logger.hpp` in the `main.cpp`
    file
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是在第一次添加的，因为我们已经在`main.cpp`文件中包含了`logger.hpp`。
- en: It was added the second time because we included `calculator.hpp`, which then
    includes `logger.hpp`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是在第二次添加的，因为我们包含了`calculator.hpp`，然后它又包含了`logger.hpp`。
- en: Included files that are not directly specified in a `#include` directive in
    the file we are compiling, but are instead included by some other included file,
    are called **transitive included files**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编译的文件中未直接指定在`#include`指令中，而是由其他包含文件包含的包含文件，被称为**间接包含文件**。
- en: Often, including the same header file multiple times creates a problem with
    multiple definitions, as we will see in *Lesson 2*, *Functions*, and *the Lesson
    03*, *Classes.*
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，包含相同的头文件多次会创建一个多定义问题，正如我们将在*第2课*，*函数*和*第03课*，*类*中看到的那样。
- en: 'Including the same file multiple times is very likely because of the transitive
    included files we explained before, and will often result in a compilation error.
    In C++, there is a convention to prevent problems that originate from including
    a header file multiple times: **include guards**.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前解释的间接包含文件，多次包含相同的文件很可能，并且通常会引发编译错误。在C++中，有一个约定可以防止由于多次包含头文件而产生的问题：**包含保护器**。
- en: An include guard is a specific pattern of instructing the preprocessor to ignore
    the content of the header if it has been included before.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 包含保护器是一种特定的指令模式，指示预处理器在之前已包含的情况下忽略头文件的内容。
- en: 'It consists of writing all the header code inside the following structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括在以下结构内部编写所有头文件代码：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `<unique_name>` is a name unique throughout the C++ project; it typically
    consists of the header file name, such as `LOGGER_HPP` for the `logger.hpp` header.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<unique_name>`是在整个C++项目中唯一的名称；它通常由头文件名组成，例如`logger.hpp`头文件的`LOGGER_HPP`。
- en: The preceding code checks whether a special preprocessor variable, `<unique_name>`,
    exists. If it does not exist, it defines it and it proceeds to read the content
    of the header. If it exists, it will skip all the code until the `#endif` part.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码检查一个特殊的预处理变量 `<unique_name>` 是否存在。如果不存在，它将定义它并继续读取头文件的内容。如果存在，它将跳过直到 `#endif`
    部分的所有代码。
- en: Since initially the special variable does not exist, the first time the preprocessor
    includes a header, it creates the variable and proceeds to read the file. The
    subsequent times, the variable is already defined, so the preprocessor jumps to
    the `#endif` directive, skipping all the content of the header file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于特殊变量最初不存在，预处理程序第一次包含头文件时，它会创建该变量并继续读取文件。随后的时间，变量已经定义，因此预处理程序会跳转到 `#endif`
    指令，跳过头文件的所有内容。
- en: 'Compilation is a process that ensures that a program is syntactically correct,
    but it does not perform any checks regarding its logical correctness. This means
    that a program that compiles correctly might still produce undesired results:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译是一个确保程序在语法上正确的过程，但它不会对程序的逻辑正确性进行检查。这意味着编译正确的程序可能仍然会产生不期望的结果：
- en: '![Figure 1.2: Compilation and linking processes for an executable file ](img/C11557_01_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：可执行文件的编译和链接过程](img/C11557_01_02.jpg)'
- en: 'Figure 1.2: Compilation and linking processes for an executable file'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.2：可执行文件的编译和链接过程
- en: Every C++ program needs to define a starting point, that is, the part of the
    code the execution should start from. The convention is to have a uniquely named
    main function in the source code, which will be the first thing to be executed.
    This function is called by the operating system, so it needs to return a value
    that indicates the status of the program; for this reason, it is also referred
    to as the `exit status code`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 C++ 程序都需要定义一个起点，即执行应该从代码的哪个部分开始。惯例是在源代码中有一个唯一命名的 `main` 函数，它将是首先被执行的部分。这个函数由操作系统调用，因此它需要返回一个表示程序状态的值；因此，它也被称为
    `退出状态码`。
- en: Let's see how we can compile a program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何编译一个程序。
- en: Together with C, C++ is the language with the most supported hardware and platforms.
    This means that there are many C++ compilers, produced by many different vendors.
    Each compiler can accept parameters in a different way, and it's important to
    consult the manual of the compiler you are using when developing in C++ to understand
    the available options and their meaning.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 语言一样，C++ 是支持硬件和平台最多的语言。这意味着有许多由不同供应商生产的 C++ 编译器。每个编译器可以以不同的方式接受参数，因此在 C++
    开发时，了解你所使用的编译器的可用选项及其含义非常重要。
- en: 'We''ll now see how to compile a program with two of the most common compilers:
    the Microsoft Visual Studio compiler and GCC.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何使用两个最常用的编译器编译程序：Microsoft Visual Studio 编译器和 GCC。
- en: Compiling a File into an Object File
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文件编译成目标文件
- en: 'To compile the `myfile.cpp` file in to an object file named `myfile.obj`, we
    can run the following commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `myfile.cpp` 文件编译成名为 `myfile.obj` 的目标文件，我们可以运行以下命令：
- en: '![Figure 1.3: Compiling the CPP file ](img/C11557_01_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：编译 CPP 文件](img/C11557_01_03.jpg)'
- en: 'Figure 1.3: Compiling the CPP file'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.3：编译 CPP 文件
- en: When we compile, it is common to include some headers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，通常包括一些头文件。
- en: We can include the headers defined in the C++ standard without performing any
    action, but in case we want to include user-defined headers, we need to tell the
    compiler in which folders to look up the header files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不执行任何操作就包含 C++ 标准中定义的头文件，但如果我们想包含用户定义的头文件，我们需要告诉编译器在哪些文件夹中查找头文件。
- en: For MSVC, you need to pass the parameter as `/I path`, where `path` is the path
    to the directory to look in for the header.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MSVC，你需要将参数作为 `/I path` 传递，其中 `path` 是要查找头文件的目录路径。
- en: For GCC, you need to pass the parameter as `-I path`, where `path` has the same
    meaning as in MSVC.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GCC，你需要将参数作为 `-I path` 传递，其中 `path` 的含义与 MSVC 相同。
- en: 'If `myfile.cpp` is including a header in the `include` directory, we would
    compile the file with the following commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `myfile.cpp` 在 `include` 目录中包含一个头文件，我们将使用以下命令编译该文件：
- en: '![Figure 1.4: Compiling the CPP file with the include directory ](img/C11557_01_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：使用包含目录编译 CPP 文件](img/C11557_01_04.jpg)'
- en: 'Figure 1.4: Compiling the CPP file with the include directory'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.4：使用包含目录编译 CPP 文件
- en: We can compile several files in their respective object files, and then link
    them all together to create the final application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个文件编译成它们各自的目标文件，然后将它们全部链接起来以创建最终的应用程序。
- en: Linking Object Files
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接目标文件
- en: 'To link together two object files called `main.obj` and `mylib.obj` into an
    executable, we can run the following commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个名为 `main.obj` 和 `mylib.obj` 的目标文件链接成一个可执行文件，我们可以运行以下命令：
- en: '![Figure 1.5: Compiling two object files ](img/C11557_01_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：编译两个目标文件](img/C11557_01_05.jpg)'
- en: 'Figure 1.5: Compiling two object files'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.5：编译两个目标文件
- en: With MSVC, we will create an executable named `main.exe`, while with `g++`,
    the executable will be named `main`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MSVC，我们将创建一个名为 `main.exe` 的可执行文件，而使用 `g++`，可执行文件将被命名为 `main`。
- en: For convenience, MSVC and GCC offer a way to compile several files into an executable,
    without the need to create an object file for each file, and then link the files
    together.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，MSVC 和 GCC 提供了一种方法，可以将多个文件编译成一个可执行文件，而无需为每个文件创建一个目标文件，然后再将文件链接起来。
- en: Even in this case, if the files are including any user-defined header, you need
    to specify the header location with the `/I` or `-I` flags.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种情况下，如果文件包含任何用户定义的头文件，你也需要使用 `/I` 或 `-I` 标志指定头文件的位置。
- en: 'To compile the `main.cpp` and `mylib.cpp` files together, which uses some headers
    from the `include` folder, you can use the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `main.cpp` 和 `mylib.cpp` 文件一起编译，这些文件使用 `include` 文件夹中的某些头文件，你可以使用以下命令：
- en: '![Figure 1.6: Compiling files with include folder ](img/C11557_01_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：包含文件夹的文件编译](img/C11557_01_06.jpg)'
- en: 'Figure 1.6: Compiling files with include folder'
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.6：包含文件夹的文件编译
- en: Working with the main Function
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 `main` 函数一起工作
- en: 'In the next chapter, we will discuss functions in more depth; for now, we can
    define the `main` function, which does nothing, apart from returning a successful
    status code in the following way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地讨论函数；现在，我们可以以以下方式定义 `main` 函数，它什么都不做，除了返回一个成功状态码：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line contains the definition of the function, constituted by the return
    type `int`, the name of the `main` function, and the list of arguments, which
    in this case is an empty list. Then, we have the body of the function, delimited
    by curly braces. Finally, the body is composed of a single instruction that will
    return a successful status code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含函数的定义，由返回类型 `int`、`main` 函数的名称以及参数列表组成，在这个例子中是一个空列表。然后，我们有了函数的主体，由花括号界定。最后，主体由一条将返回成功状态码的单个指令组成。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: As opposed to C, in a C++ program, the return statement is optional. The compiler
    automatically adds `return 0` if you don't explicitly return a value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 语言不同，在 C++ 程序中，返回语句是可选的。如果你没有明确返回值，编译器会自动添加 `return 0`。
- en: We will discuss these topics in more detail later; what is important to know
    is that this is a valid C++ program that can be compiled and executed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地讨论这些主题；重要的是要知道这是一个有效的 C++ 程序，它可以被编译和执行。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Most C compilers can compile C or C++ by determining the language based on the
    file extension.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 C 编译器可以通过确定文件扩展名来编译 C 或 C++ 语言。
- en: 'Exercise 1: Compiling and Executing the main Function'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1：编译和执行 `main` 函数
- en: 'In this exercise, we will create a source file named `main.cpp` containing
    the code. Compile the file and run the program. We will be using it to explore
    the C++ environment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个名为 `main.cpp` 的源文件，其中包含代码。编译该文件并运行程序。我们将使用它来探索 C++ 环境：
- en: Using your favorite text editor (Sublime Text, Visual Studio Code, Atom, or
    Notepad++ if you use Windows), create a new file and name it `main.cpp`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器（如果你使用 Windows，可以是 Sublime Text、Visual Studio Code、Atom 或 Notepad++），创建一个新文件并将其命名为
    `main.cpp`。
- en: 'Write the following code in the `main.cpp` file and save it:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 文件中写下以下代码并保存：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compile the `main.cpp` file using the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译 `main.cpp` 文件：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The compilation process will produce an executable file, which will be named
    `main.exe` on a Windows system and `main.out` on a UNIX one.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译过程将生成一个可执行文件，在 Windows 系统上命名为 `main.exe`，在 UNIX 系统上命名为 `main.out`。
- en: Built-in Data Types
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: In most programming languages, data is stored in variables, which are labels
    that refer to the part of memory defined by the programmer. Each variable has
    an associated type. The type defines what kind of values the variable can hold.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，数据存储在变量中，变量是程序员定义的内存部分的标签。每个变量都有一个关联的类型。类型定义了变量可以持有哪种类型的值。
- en: 'The built-in data types of C++ are divided into two categories:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的内置数据类型分为两类：
- en: '**Primitive data types**: Can be used directly by the user to declare variables'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始数据类型**：可以直接由用户声明变量'
- en: '**Abstract or user defined data types**: Are defined by the user, for example,
    to define a class in C++ or a structure'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象或用户定义的数据类型**：由用户定义，例如，在 C++ 中定义一个类或结构'
- en: Primitive Data Types
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: 'Primitive data types consist of the following types:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型包括以下类型：
- en: '`int` type stores a whole number value ranging from `-2147483648` to `2147483647`.
    This data type usually takes up `4` bytes of memory space.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 类型存储一个从 `-2147483648` 到 `2147483647` 的整数。此数据类型通常占用 `4` 字节内存空间。'
- en: '`char` type stores character data. It is guaranteed to be big enough to represent
    any UTF-8 single byte code unit; for UTF-16 and UTF-32, `char16_t` and `char32_t`
    are used, respectively. `char` typically takes 1 byte of memory space.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 类型存储字符数据。它保证足够大，可以表示任何 UTF-8 单字节代码单元；对于 UTF-16 和 UTF-32，分别使用 `char16_t`
    和 `char32_t`。`char` 通常占用 1 字节内存空间。'
- en: '`bool` data type is capable of holding one of two values: `true` or `false`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool` 数据类型能够存储两个值之一：`true` 或 `false`。'
- en: '`float` type is used for storing single precision floating point values. This
    data type usually takes up 4 bytes of memory space.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 类型用于存储单精度浮点值。此数据类型通常占用 4 字节内存空间。'
- en: '`double` type is used for storing double precision floating point values. This
    data type usually takes up 8 bytes of memory space.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` 类型用于存储双精度浮点值。此数据类型通常占用 8 字节内存空间。'
- en: '`void` type is a valueless data type that is used for functions that do not
    return a value.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void` 类型是一个无值的类型，用于不需要返回值的函数。'
- en: '`wchar_t` type is also used to represent character sets, but allows for greater
    size. While char supports characters between 8 and 32 bits, a wide character is
    2 to 4 bytes long.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wchar_t` 类型也用于表示字符集，但允许更大的尺寸。虽然 `char` 支持介于 8 到 32 位的字符，但宽字符是 2 到 4 字节长。'
- en: The character types `char` and `wchar_t` hold numeric values corresponding to
    the characters in the machine's character set.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类型 `char` 和 `wchar_t` 包含与机器字符集中的字符相对应的数值。
- en: Datatype Modifiers
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型修饰符
- en: 'The numeric types offered by the C++ programming language fall into three categories:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编程语言提供的数值类型分为三类：
- en: Signed
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带符号
- en: Unsigned
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号
- en: Floating point
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: The signed and unsigned types come with different sizes, which means each of
    them can represent a smaller or larger range of values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 带符号和无符号的类型有不同的尺寸，这意味着每个都可以表示更小或更大的值范围。
- en: Integer types can be signed or unsigned, where signed types can be used to distinguish
    between negative or positive numbers, while unsigned can only represent numbers
    greater than or equal to zero.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型可以是带符号的或无符号的，其中带符号的类型可以用来区分负数或正数，而无符号的只能表示大于或等于零的数。
- en: The signed keyword is optional; the programmer only needs to specify it if the
    type is unsigned. Thus, `signed int` and `int` are the same types, but they are
    different from `unsigned int`, or just `unsigned` for brevity. Indeed, if it is
    not specified, an unsigned type always defaults to `int`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`signed` 关键字是可选的；程序员只有在类型是无符号的情况下才需要指定它。因此，`signed int` 和 `int` 是相同的类型，但它们与
    `unsigned int` 或简称 `unsigned` 不同。确实，如果没有指定，无符号类型始终默认为 `int`。'
- en: 'Integers, as previously mentioned, can come in different sizes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，整数可以有不同的尺寸：
- en: '`int`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`short int`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short int`'
- en: '`long int`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long int`'
- en: '`long long int`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long long int`'
- en: The `short int` type, or just `short`, is guaranteed to be at least 16 bits
    according to the standard. This means it can hold values in the range of `-32768`
    to `32767`. If it was also `unsigned`, so `unsigned short int` or just `unsigned
    int`, this range would be `0` to `65535`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`short int` 类型，或简称 `short`，根据标准保证至少为 16 位。这意味着它可以存储从 `-32768` 到 `32767` 范围内的值。如果它也是
    `unsigned`，那么就是 `unsigned short int` 或简称 `unsigned int`，这个范围将是 `0` 到 `65535`。'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The effective size in memory of types can change based on the platform for which
    the code is compiled. C++ is present in many platforms, from supercomputers in
    data centers to small embedded chips in industrial settings. To be able to support
    all these different types of machines, the standard only sets the minimum requirements
    on built-in types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在内存中的有效尺寸可以根据代码编译的平台而改变。C++ 存在于许多平台，从数据中心中的超级计算机到工业环境中的小型嵌入式芯片。为了能够支持所有这些不同类型的机器，标准只为内置类型设定了最小要求。
- en: Variable Definition
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量定义
- en: A variable is named storage that refers to a location in memory that can be
    used to hold a value. C++ is a strongly-typed language and it requires every variable
    to be declared with its type before its first use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个名为存储的命名空间，它指向内存中的一个位置，可以用来存储值。C++是一种强类型语言，它要求在第一次使用之前必须声明每个变量的类型。
- en: The type of the variable is used by the compiler to determine the memory that
    needs to be reserved and the way to interpret its value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的类型被编译器用来确定需要预留的内存以及解释其值的方式。
- en: 'The following syntax is used to declare a new variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法用于声明一个新变量：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Variable names in C++ can contain letters from the alphabet, both upper and
    lower case, digits and underscores (_). While digits are allowed, they cannot
    be the first character of a variable name. Multiple variables of the same type
    can all be declared in the same statement by listing their variable names, separated
    by commas:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的变量名可以包含字母表中的字母，大小写均可，数字和下划线（_）。虽然允许使用数字，但不能作为变量名的第一个字符。可以通过列出变量名（用逗号分隔）在同一语句中声明相同类型的多个变量：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is equivalent to the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When declaring a variable, its value is left undetermined until an assignment
    is performed. It is also possible to declare a variable with a given value; this
    operation is also referred to as **variable initialization**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，其值在执行赋值之前是不确定的。也可以声明一个具有给定值的变量；这种操作也称为**变量初始化**。
- en: 'One way – and probably the most common one – to initialize a variable, also
    referred to as **C-like initialization**, uses the following syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化变量的一个方法——也称为**C样式初始化**——使用以下语法：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another solution is constructor initialization, which we will see in detail
    in *Lesson 3*, *Classes*. Constructor initialization looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是构造函数初始化，我们将在第3课，*类*中详细看到。构造函数初始化看起来是这样的：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Uniform initialization or list initialization introduces brace initialization,
    which allows for the initialization of variables and objects of different types:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一致初始化或列表初始化引入了花括号初始化，这允许对不同类型的变量和对象进行初始化：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Demystifying Variable Initialization
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 揭秘变量初始化
- en: 'When a variable is initialized, the compiler can figure out the type needed
    to store the value provided, which means that it is not necessary to specify the
    type of the variable. The compiler is indeed able to deduct the type of the variable,
    so this feature is also referred to as **type deduction**. For this reason, the
    **auto** keyword has been introduced to replace the type name during initialization.
    The initialization syntax becomes this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被初始化时，编译器可以确定存储提供的值所需的数据类型，这意味着不需要指定变量的类型。编译器确实能够推导出变量的类型，因此这个特性也被称为**类型推导**。因此，引入了**auto**关键字来替换初始化期间的类型名称。初始化语法变为如下：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another way to avoid directly providing a type is to use the `decltype` specifier.
    It is used to deduce a type of a given entity and is written with the following
    syntax:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接提供类型的一种方法是用`decltype`指定符。它用于推导给定实体的类型，并使用以下语法编写：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `variable_name2` is declared according to the type deducted from `variable_name1`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`variable_name2`是根据从`variable_name1`推导出的类型声明的。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Type deduction using the `auto` and `decltype` keywords has been introduced
    by the C++11 standard to simplify and facilitate variable declaration when the
    type cannot be obtained. But at the same time, their extended use when not really
    needed can reduce code readability and robustness. We will see this in more detail
    in *Lesson 4*, *Generic Programming and Templates*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto`和`decltype`关键字进行类型推导是由C++11标准引入的，以简化在无法获得类型时变量的声明。但与此同时，在不真正需要时它们的扩展使用可能会降低代码的可读性和健壮性。我们将在第4课，*泛型编程和模板*中更详细地看到这一点。
- en: In the following code, we will check a valid statement for variables by creating
    a new source file named `main.cpp` and analyzing the code one line at a time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将通过创建一个名为`main.cpp`的新源文件并逐行分析代码来检查变量的有效语句。
- en: Which one of the following is a valid statement?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个是有效的语句？
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pointers and References
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针和引用
- en: In the previous section, variables have been defined as portions of memory that
    can be accessed by their name. In this way, the programmer does not need to remember
    the memory location and size that's reserved, but can conveniently refer to the
    variable name.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，变量被定义为可以通过其名称访问的内存部分。这样，程序员不需要记住保留的内存位置和大小，但可以方便地引用变量名。
- en: In C++, the way to retrieve the actual memory address of a variable is done
    by preceding the variable name with an ampersand sign (`&`), also known as the
    **address-of operator**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，获取变量实际内存地址的方法是在变量名前加上一个井号符号（`&`），这被称为**取地址运算符**。
- en: 'The syntax to use the concept of the address-of operator is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用取地址运算符概念的正确语法如下：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using this in code will return the physical memory address of the variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用这将返回变量的物理内存地址。
- en: Pointers
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针
- en: A data structure that's capable of storing a memory address in C++ is known
    as a **pointer**. A pointer always points to an object of a specific type, and
    because of that we need to specify the type of the object that's pointed to when
    declaring the pointer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 C++ 中存储内存地址的数据结构被称为**指针**。指针始终指向特定类型的对象，因此我们在声明指针时需要指定所指向的对象的类型。
- en: 'The syntax to declare a pointer is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 声明指针的语法如下：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Multiple declarations in the same statement are also possible when it comes
    to a pointer, but it is important to remember that an asterisk (`*`) is needed
    for each pointer declaration. An example of multiple pointer declaration is as
    follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到指针时，同一语句中也可以有多个声明，但重要的是要记住每个指针声明都需要一个星号（`*`）。以下是一个多个指针声明的示例：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the asterisk is specified only for the first declaration, the two variables
    will have different types. For example, in the following declaration, only the
    former is a pointer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当只指定第一个声明时，两个变量将具有不同的类型。例如，在以下声明中，只有前者是指针：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Independently of the pointed variable type, a pointer will always occupy the
    same size in memory. This derives from the fact that the memory space needed by
    the pointer is not related to a value stored by the variable, but to a memory
    address that is platform-dependent.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不论指向的变量类型如何，指针在内存中总是占据相同的大小。这源于指针所需的内存空间与变量存储的值无关，而是与平台相关的内存地址有关。
- en: 'Intuitively, a pointer assignment has the same syntax as any other variable:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，指针赋值的语法与其他任何变量相同：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous syntax will copy the memory address of the `variable_name` variable
    into the pointer named `pointer_name`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的语法将 `variable_name` 变量的内存地址复制到名为 `pointer_name` 的指针中。
- en: 'The following code snippet will first initialize `pointer_name1` with the memory
    address of `variable_name`, and then it initializes `pointer_name2` with the value
    stored in `pointer_name``1`, which is the memory address of `variable_name`. As
    a result, `pointer_name2` will end up pointing to the `variable_name` variable:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段首先将 `pointer_name1` 初始化为 `variable_name` 的内存地址，然后将 `pointer_name2` 初始化为
    `pointer_name1` 中存储的值，即 `variable_name` 的内存地址。因此，`pointer_name2` 最终将指向 `variable_name`
    变量：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following implementation is invalid:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现是无效的：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, `pointer_name2` would be initialized with the memory address of
    `pointer_name1`, resulting in a pointer that points to another pointer. The way
    to point a pointer to another pointer is to use the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`pointer_name2` 将被初始化为 `pointer_name1` 的内存地址，从而产生一个指向另一个指针的指针。将指针指向另一个指针的方法是使用以下代码：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Two asterisks (`*`) indicate the `type` that's pointed is now a pointer. In
    general, the syntax simply requires an asterisk (`*`) for each level of indirection
    in the declaration of the pointer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 两个星号（`*`）表示所指向的类型现在是一个指针。一般来说，语法只需要在指针声明的每个间接级别前使用一个星号（`*`）。
- en: 'To access the actual content at a given memory address, it is possible to use
    the dereference operator (`*`), followed by the memory address or a pointer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问给定内存地址的实际内容，可以使用解引用运算符（`*`），后跟内存地址或指针：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The value contained by `variable_name2` is the same as the one contained by
    `variable_name1`. The same applies when it comes to assignment:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`variable_name2` 包含的值与 `variable_name1` 包含的值相同。赋值时也是如此：'
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: References
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用
- en: 'Unlike a pointer, a reference is just an alias for an object, which is essentially
    a way to give another name to an existing variable. The way to define a reference
    is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针不同，引用只是一个对象的别名，这本质上是一种给现有变量起另一个名字的方式。定义引用的方式如下：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s examine the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下示例：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can identify three main differences with pointers:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将指针与以下三个主要区别进行识别：
- en: Once initialized, a reference remains bound to its initial object. So, it is
    not possible to reassign a reference to another object. Any operations performed
    on a reference are actually operations on the object that has been referred.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦初始化，引用就会绑定到其初始对象。因此，不可能将引用重新赋值给另一个对象。对引用执行的所有操作实际上是对被引用的对象的操作。
- en: Since there is not the possibility to rebind a reference, it is necessary to
    initialize it.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有重新绑定引用的可能性，因此必须对其进行初始化。
- en: References are always associated with a variable that's stored in memory, but
    the variable might not be valid, in which case the reference should not be used.
    We will see more on this in the *Lesson 6, Object-Oriented Programming*.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用始终与存储在内存中的变量相关联，但该变量可能无效，在这种情况下，不应使用该引用。我们将在*第6课，面向对象编程*中看到更多关于这一点的内容。
- en: It is possible to define multiple references to the same object. Since the reference
    is not an object, it is not possible to have a reference to another reference.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义多个对同一对象的引用。由于引用不是一个对象，因此不可能有对另一个引用的引用。
- en: 'In the following code, given that `a` is an integer, `b` is a float, and `p`
    is a pointer to an integer, verify which of the variable initialization is valid
    and invalid:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，假设`a`是一个整数，`b`是一个浮点数，`p`是一个指向整数的指针，验证哪些变量初始化是有效和无效的：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The const Qualifier
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量限定符
- en: 'In C++, it is possible to define a variable whose value will not be modified
    once initialized. The way to inform the compiler of this situation is through
    the `const` keyword. The syntax to declare and initialize a `const` variable is
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以定义一个变量，其值一旦初始化后就不会被修改。通知编译器这种情况的方式是通过`const`关键字。声明和初始化`const`变量的语法如下：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are several reasons to enforce immutability in a C++ program, the most
    important ones being correctness and performance. Ensuring that a variable is
    constant will prevent the compilation of code that accidentally tries to change
    that variable, preventing possible bugs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++程序中强制不可变性的原因有几个，其中最重要的原因是正确性和性能。确保变量是常量将防止编译器编译出试图意外更改该变量的代码，从而防止可能的错误。
- en: The other reason is that informing the compiler about the immutability of the
    variable allows for optimizing the code and logic behind the implementation of
    the code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，通知编译器变量的不可变性允许优化代码及其背后的逻辑。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: After creating an object, if its state remains unchanged, then this characteristic
    is known as immutability.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象后，如果其状态保持不变，那么这种特性被称为不可变性。
- en: 'An example of immutability is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的一个例子如下：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: An object is immutable if its state doesn't change once the object has been
    created. Consequently, a class is immutable if its instances are immutable. We
    will learn more about classes in *Lesson 3*, *Classes*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象是不可变的，如果它的状态在对象创建后不发生变化。因此，如果一个类的实例是不可变的，那么这个类也是不可变的。我们将在*第3课，类*中了解更多关于类的内容。
- en: Modern C++ supports another notion of immutability, which is expressed with
    the `constexpr` keyword. In particular, it is used when it is necessary for the
    compiler to evaluate the constant at compile time. Also, every variable declared
    as `constexpr` is implicitly `const`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++支持另一种不可变性的概念，这通过`constexpr`关键字来表示。特别是，当编译器需要在编译时评估常量时，它会被使用。此外，每个被声明为`constexpr`的变量都是隐式`const`的。
- en: 'The previous topic introduced pointers and references; it turns out that even
    those can be declared as `const`. The following is pretty straightforward to understand,
    and its syntax is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个主题介绍了指针和引用；结果发现，即使是它们也可以声明为`const`。以下内容相对直观易懂，其语法如下：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This syntax shows how we can declare a reference to an object that has a `const`
    type; such a reference is colloquially called a **const reference**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法展示了我们如何声明一个对具有`const`类型的对象的引用；这样的引用俗称为**const引用**。
- en: 'References to `const` cannot be used to change the object they refer to. Note
    that it is possible to bind a `const` reference to a non-`const` type, which is
    typically used to express that the object that''s been referenced will be used
    as an immutable one:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对`const`的引用不能用来改变它们所引用的对象。请注意，将`const`引用绑定到非`const`类型是可能的，这通常用来表达所引用的对象将被用作不可变对象：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, the opposite is not allowed. If an object is `const`, then it can
    only be referenced by a `const` reference:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相反的情况是不允许的。如果一个对象是`const`，那么它只能通过`const`引用来引用：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An example of this is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Just like for references, pointers can point to the `const` object, and the
    syntax is also similar and intuitive:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像引用一样，指针可以指向`const`对象，其语法也是类似且直观的：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An example of this is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`const` object addresses can only be stored in a pointer to `const`, but the
    opposite is not true. We could have a pointer to `const` point to a non-`const`
    object and, in this case, like for a reference to `const`, we are not guaranteed
    that the object itself will not change, but only that the pointer cannot be used
    to modify it.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`对象的地址只能存储在指向`const`的指针中，但反之则不然。我们可以有一个指向`const`的指针指向一个非`const`对象，在这种情况下，就像对`const`的引用一样，我们无法保证对象本身不会改变，但只能保证指针不能用来修改它。'
- en: With pointers, since they are also objects, we have an additional case, which
    is the `const` pointer. While for references saying `const` reference is just
    a short version of reference to `const`, this is not the case for the pointer
    and has a totally different meaning.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指针，由于它们也是对象，我们还有一个额外的案例，即`const`指针。虽然对于引用来说，`const`引用只是指向`const`的引用的简写，但对于指针来说并非如此，它有完全不同的含义。
- en: 'Indeed, a `const` pointer is a pointer that is itself constant. Here, the pointer
    does not indicate anything about the pointed object; it might be either `const`
    or non-`const`, but what we cannot change instead is the address pointed to by
    the pointer once it has been initialized. The syntax is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个`const`指针本身就是一个常量指针。在这里，指针本身并不指示指向的对象；它可能是`const`或非`const`，但我们不能改变的是一旦初始化后指针所指向的地址。其语法如下：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the `const` keyword is placed after the `*` symbol. The easiest
    way to keep this rule in mind is to read from right to left, so `pointer-name
    > const > * > type` can be read as follows: `pointer-name` is a `const` pointer
    to an object of type `type`. An example of this is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`const`关键字放在`*`符号之后。记住这个规则的最简单方法是从右向左阅读，所以`pointer-name > const > * > type`可以读作如下：`pointer-name`是一个指向类型为`type`的`const`指针。以下是一个例子：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Pointer to const and const to pointer are independent and can be expressed
    in the same statement:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 指向`const`和`const`到指针是独立的，可以在同一个语句中表达：
- en: '`const type *const pointer_name = &variable_name;`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`const type *const pointer_name = &variable_name;`'
- en: The preceding line indicates that both the pointed object and the pointer are
    `const`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行表示指向的对象和指针都是`const`。
- en: The Scope of Variables
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: 'As we have already seen, variable names refer to a specific entity of a program.
    The live area of the program where this name has a particular meaning is also
    called a `scope` of a name. Scopes in C++ are delimited with curly braces, and
    this area is also called a **block**. An entity that''s declared outside of any
    block has a **global scope** and is valid anywhere in the code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，变量名指的是程序中一个特定实体的引用。程序中这个名称具有特定意义的活跃区域也称为名称的`作用域`。C++中的作用域由花括号限定，这个区域也称为**块**。在块外部声明的实体具有**全局作用域**，在代码的任何地方都是有效的：
- en: '![Figure 1.7: Scope of a variable ](img/C11557_01_07.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7：变量的作用域](img/C11557_01_07.jpg)'
- en: 'Figure 1.7: Scope of a variable'
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：变量的作用域
- en: The same name can be declared in two scopes and refers to different entities.
    Also, a name is visible once it is declared until the end of the block in which
    it is declared.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个名称可以在两个作用域中声明，并引用不同的实体。此外，一旦声明，名称就可见，直到其声明的作用域块的末尾。
- en: 'Let''s understand the scope of global and local variables with the following
    example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解全局变量和局部变量的作用域：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Scopes can be nested, and we call the containing and contained scope the outer
    and inner scope, respectively. Names declared in the outer scope can be used in
    the inner one. Re-declaration of a name that was initially declared in the outer
    scope is possible. The result will be that the new variable will hide the one
    that was declared in the outer scope.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可以嵌套，我们分别称包含范围和被包含范围为外部范围和内部范围。外部范围内声明的名称可以在内部使用。在内部范围重新声明最初在外部范围中声明的名称是可能的。结果将是新变量将隐藏在内部范围中声明的变量。
- en: 'Let''s examine the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next chapter, we will explore how to use local and global variables with
    functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用函数中的局部和全局变量。
- en: In the following code, we will find the values of all the variables without
    executing the program.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将找到所有变量的值，而无需执行程序。
- en: 'The following program shows how variable initialization works:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了变量初始化的工作原理：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Control Flow Statements
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制流语句
- en: In a program, it is rare to provide useful functionality by just executing a
    linear sequence of operations. Commonly, a program must be able to react in different
    ways in response to different situations or execute the same operation multiple
    times in different contexts.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，仅通过执行一系列线性操作来提供有用的功能是很少见的。通常，程序必须能够对不同的情况做出不同的反应，或者在不同的上下文中多次执行相同的操作。
- en: We will now see the control flow statements C++ offers to the programmer to
    control the sequence of operations to be executed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到 C++ 为程序员提供的控制流语句，以控制要执行的运算顺序。
- en: Selection Statement – if-else
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择语句 – if-else
- en: 'C++ provides conditional execution support, where the `if` keyword indicates
    whether or not to execute the following statement or block, depending on the fulfillment
    of the condition provided:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了条件执行支持，其中 `if` 关键字指示是否根据提供的条件执行后续语句或块：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the expression named `condition` evaluates to `true`, then the statement
    is executed; otherwise, it will be ignored and the program will continue with
    the subsequent code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名为 `condition` 的表达式评估为 `true`，则执行该语句；否则，它将被忽略，程序将继续执行后续代码。
- en: 'The conditionally executed code can be a single statement or an entire block
    containing multiple ones. These statements needs to be enclosed in braces (`{}`)
    to form a block:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 条件执行代码可以是一个单独的语句，也可以是一个包含多个语句的整个块。这些语句需要用大括号 (`{}`) 括起来形成一个块：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is common to forget the brace brackets and write the control statement in
    the following manner:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 常常会忘记大括号，并以以下方式编写控制语句：
- en: '`if (condition)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (condition)`'
- en: '`statement1`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`statement1`'
- en: '`statement2`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`statement2`'
- en: In such a case, the compiler will not warn you, and it will execute `statement1`
    depending on the condition, but always execute `statement2`. To avoid such a situation,
    it can be a good practice to always add the braces.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器不会警告你，它将根据条件执行 `statement1`，但总是执行 `statement2`。为了避免这种情况，始终添加大括号可能是一个好习惯。
- en: It is possible to specify what to execute instead when the condition evaluates
    to `false`. This is done through the `else` keyword, which is followed by a statement
    or a block.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件评估为 `false` 时，可以指定要执行的操作。这是通过 `else` 关键字完成的，它后面跟着一个语句或一个块。
- en: 'The following syntax is used to indicate that `statement1` should be executed
    if the `case` condition evaluates to `true`, and otherwise `statement2` is executed:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法用于指示如果 `case` 条件评估为 `true`，则执行 `statement1`，否则执行 `statement2`：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we can concatenate on multiple if-else statements to produce a more
    complex branching logic. Let''s examine the following example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将多个 if-else 语句连接起来，以产生更复杂的分支逻辑。让我们看看以下示例：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With this generic structure, it is possible to check the unlimited number of
    conditions and execute only the corresponding statement or the final one contained
    in the `else` branch.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种通用结构，可以检查无限数量的条件，并只执行相应的语句或 `else` 分支中包含的最终语句。
- en: 'It is important to be aware that once one of the conditions is met, all of
    the ones that follow are discarded, for example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，一旦满足其中一个条件，后续的所有条件都将被丢弃，例如：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The previous code will always execute `statement1` for any positive `x`, regardless
    of whether it is greater than 100 or not.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将始终为任何正数 `x` 执行 `statement1`，无论它是否大于 100。
- en: 'An alternative way is to sequence several `if` keywords, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是按顺序使用多个 `if` 关键字，如下所示：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s demystify the previous logic with the following example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来消除之前逻辑的神秘感：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this way, all the conditions are evaluated independently and more than one
    statement can potentially be executed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有条件都是独立评估的，并且可能执行多个语句。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: As the `else` statement has no condition defined, after evaluating the `if`
    statement, the control comes to the `else` block to execute the statement.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`else`语句没有定义条件，在评估`if`语句之后，控制流会转到`else`块以执行语句。
- en: Selection Statement – switch
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择语句 – switch
- en: 'Another selection statement, with similarities to the `if-else` concatenation
    construction, is the `switch` statement. It is limited to constant expressions
    and is mainly used to check for a value among a number of possible expressions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择语句，与`if-else`连接构造类似，是`switch`语句。它限于常量表达式，主要用于检查多个可能的表达式中的一个值：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `expression` present in the parentheses following the `switch` keyword is
    evaluated against multiple cases, searching for the first equality between the
    expression and the constants. If none of the cases match, the default one (if
    it exists, since it is optional) is executed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`关键字后面的括号中出现的`expression`将与多个情况进行比较，寻找表达式与常量之间的第一个相等性。如果没有情况匹配，将执行默认情况（如果存在，因为它是可选的）。
- en: It is important to keep in mind that the order of evaluation is sequential,
    and as soon as one of the constants matches, the corresponding group of statements
    are executed. The `break` keyword prevents them from further execution. If the
    `break` keyword is not included, all statements following the case, including
    the ones under different labels, are also executed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，评估顺序是顺序的，并且一旦某个常量匹配，就会执行相应的语句组。`break`关键字阻止它们进一步执行。如果不包含`break`关键字，则也会执行随后的所有语句，包括在不同标签下的语句。
- en: We will explore the break keyword more in the *Jump statements – break and continue*
    section.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*跳转语句 – break 和 continue*部分更深入地探讨`break`关键字。
- en: Iteration Statement – for loop
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代语句 – for 循环
- en: 'The `for` loop is a construct that''s used to repeat a statement a certain
    number of times. The syntax of the `for` loop is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环是一个用于重复执行语句一定次数的构造。`for`循环的语法如下：'
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `for` loop consists of two parts: the `initialization`, `condition`, and
    `increase` statements. The body can be a single statement or a block of multiple
    ones.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环由两部分组成：初始化、条件和增加语句。主体可以是一个单独的语句或多个语句的块。'
- en: The initialization statement is typically (but not necessarily) used to declare
    a new variable, usually a counter, and to initialize it to a certain value. The
    initialization statement is executed only once, at the beginning of the loop.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句通常（但不一定）用于声明一个新的变量，通常是一个计数器，并将其初始化为某个特定值。初始化语句仅在循环开始时执行一次。
- en: Secondly, the condition statement is checked. This is similar to the condition
    that's checked for an `if` statement. If the condition is `true`, the body of
    the loop is executed, otherwise the program continues its execution with the instruction
    after the body of the `for` loop.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，检查条件语句。这与`if`语句中检查的条件类似。如果条件为`true`，则执行循环体，否则程序将继续执行`for`循环体之后的指令。
- en: After the body executes, the `increase` statement is executed. This usually
    changes the counter of the initialization statement. The condition is then checked
    again and, if `true`, the steps are repeated. The loop ends when the condition
    evaluates to `false`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行主体之后，执行增加语句。这通常改变初始化语句的计数器。然后再次检查条件，如果为`true`，则重复步骤。当条件评估为`false`时，循环结束。
- en: 'The fields in the header of a `for` loop are optional and can be left blank,
    but the `semicolons` cannot be omitted. When the condition is omitted, it always
    evaluates to `true`. For example, the following corresponds to an infinite loop
    where the statement is executed unconditionally:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的头部字段是可选的，可以留空，但分号不能省略。当省略条件时，它始终评估为`true`。例如，以下对应于一个无限循环，其中语句无条件执行：'
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another variant of the `for` loop is called a range-based for loop, the syntax
    for which is as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的另一种变体称为基于范围的`for`循环，其语法如下：'
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A range is a sequence of elements, like arrays, which are explained in the next
    section. This range-based `for` loop is used to iterate over all elements of these
    sequences. The `for` declaration, the name is a temporary variable that's declared
    for every iteration of the loop. This is used to store the current element. The
    declaration needs to be the same type as the elements contained in the range.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是一系列元素，如数组，这些将在下一节中解释。这个基于范围的 `for` 循环用于遍历这些序列的所有元素。`for` 声明，名称是循环每次迭代声明的临时变量。这用于存储当前元素。声明需要与范围中包含的元素类型相同。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A range-based `for` loop is a good example where `type` deduction and the use
    of the `auto` keyword for the declaration makes the code more readable and helps
    the programmer find the right type to use.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环是 `type` 推断和为声明使用 `auto` 关键字使代码更易读并帮助程序员找到正确类型的良好示例。
- en: 'A loop placed inside a loop is known as a **nested loop**. Let''s look at the
    following diagram to understand what a nested for loop is:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 放在循环内部的循环称为 **嵌套循环**。让我们通过以下图表来了解什么是嵌套 for 循环：
- en: '![Figure 1.8: Nested for loop ](img/C11557_01_08.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8：嵌套 for 循环](img/C11557_01_08.jpg)'
- en: 'Figure 1.8: Nested for loop'
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.8：嵌套 for 循环
- en: 'Using the following example, let''s explore how a nested for loop works and
    print a reverse half-triangle on the console:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下示例，让我们探索嵌套 for 循环的工作原理，并在控制台上打印一个倒置的半三角形：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Iteration Statement – while loop
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代语句 – while 循环
- en: 'Another iteration statement is the `while` loop. It is simpler than the `for`
    loop. The syntax for it is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个迭代语句是 `while` 循环。它比 `for` 循环简单。它的语法如下：
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It repeats the statement until the condition is met. When the condition is
    not `true` anymore, the loop ends and the program continues its execution right
    after the loop:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 它会重复执行语句，直到满足条件。当条件不再为 `true` 时，循环结束，程序在循环之后继续执行：
- en: Note
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A `while` loop can always be expressed using a `for` loop.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `while` 循环可以用 `for` 循环表示。
- en: 'Here is an example: `for ( ; condition ; ) statement;`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：`for ( ; condition ; ) statement;`
- en: Iteration Statement – do-while loop
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代语句 – do-while 循环
- en: 'A similar loop is the `do-while` loop, where the condition is checked after
    the execution of the statement, instead of before. It uses the following syntax:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的循环是 `do-while` 循环，其中条件是在执行语句之后而不是之前进行检查的。它使用以下语法：
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It guarantees at least one execution of the statement, even though the condition
    never evaluates to `true`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 即使条件永远不会评估为 `true`，它也保证了至少执行一次语句。
- en: Jump Statements – break and continue
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳转语句 – break 和 continue
- en: 'The `break` keyword is used to end a loop independently, regardless of whether
    it fulfils its condition. In the following program, when `condition2` becomes
    `true`, the break statement will immediately terminate the `while` loop:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 关键字用于独立结束循环，无论它是否满足条件。在以下程序中，当 `condition2` 变为 `true` 时，`break` 语句将立即终止
    `while` 循环：'
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, the `continue` statement is used to skip the rest of the body''s
    loop in the current iteration. In the following example, when `condition2` evaluates
    to `true`, `continue` is called, causing the program to reach the end of the loop,
    skipping `statement2` and continuing with the next iteration:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 `continue` 语句来跳过当前迭代中循环体剩余的部分。在下面的示例中，当 `condition2` 评估为 `true` 时，调用
    `continue`，导致程序到达循环的末尾，跳过 `statement2` 并继续下一个迭代：
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `break` and continue statements can be used in both `for` and `while` loops.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 和 `continue` 语句都可以用在 `for` 和 `while` 循环中。'
- en: The try-catch block
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-catch 块
- en: During the execution of a program, an anomaly may occur. We refer to these runtime
    problems as **exceptions**, and they represent the response to an exceptional
    circumstance that arises outside of the normal functioning of a program. Designing
    code that's resilient to errors is one of the hardest things a programmer has
    to deal with.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中，可能会发生异常。我们将这些运行时问题称为 **异常**，它们代表了程序正常功能之外出现的异常情况对响应。设计能够抵御错误的代码是程序员必须应对的最困难的事情之一。
- en: Exceptions are generally thrown using the `throw` keyword when something that
    cannot be handled is encountered by the program. This is also referred to as **raising
    an exception**.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 异常通常在程序遇到无法处理的情况时使用 `throw` 关键字抛出。这也被称为 **抛出异常**。
- en: 'The `try` keyword is followed by a block containing statements that might throw
    one or more exceptions. These exceptions can be caught by one or more `catch`
    clauses, which are sequentially listed after the `try` block. The syntax for this
    is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 关键字后面跟着一个包含可能抛出一个或多个异常的语句的块。这些异常可以通过一个或多个 `catch` 子句捕获，这些子句按顺序列在 `try`
    块之后。此语法的语法如下：'
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A `catch` block consists of the `catch` keyword, the exception declaration,
    and a block. Based on the exception thrown inside the `try` block, one `catch`
    clause is selected and the corresponding block is executed. Once the `catch` block
    has terminated, the program continues its execution with the statement following
    the last `catch` clause.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 块由 `catch` 关键字、异常声明和块组成。根据 `try` 块内部抛出的异常，选择一个 `catch` 子句并执行相应的块。一旦
    `catch` 块终止，程序将继续执行最后一个 `catch` 子句之后的语句。'
- en: 'Let''s examine the following example to understand how try-catch conditional
    statements handle exceptions:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解如何使用 try-catch 条件语句处理异常：
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Exercise 2: Counting the Number of Times a Specific Number Appears in a Given
    List'
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：计算特定数字在给定列表中出现的次数
- en: In this exercise, we will discuss using the `if` statement and a `for` loop
    to count our magic number. Here, we will be trying to find all numbers that are
    divisible by 3, ranging from 1 to 30\.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将讨论使用 `if` 语句和 `for` 循环来计数我们的魔法数字。在这里，我们将尝试找到所有能被 3 整除的数字，范围从 1 到 30。
- en: Hint
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提示
- en: To find out if a number is divisible by another, use the modulo (%) operator.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出一个数字是否能被另一个数字整除，请使用取模 (%) 运算符。
- en: 'Now, let''s perform the following steps:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行以下步骤：
- en: 'Import all the required header files:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必需的头文件：
- en: '[PRE64]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We need to store the number of times a number is divisible by 3 in a counter.
    For this reason, we define and initialize the `count` variable to `0`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将一个数字被 3 整除的次数存储在一个计数器中。因此，我们定义并初始化 `count` 变量为 `0`：
- en: '[PRE65]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we will use a `for` loop that produces values from 1 to 30 so that we
    can check whether they are divisible by 3 or not:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个生成 1 到 30 的值的 `for` 循环，以便我们可以检查它们是否能被 3 整除：
- en: '[PRE66]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we will check in the body of the `for` loop by using an `if` statement
    and the expression `x%3 == 0`, which evaluates to `true` if the division has a
    remainder equal to `0`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在 `for` 循环体中使用 `if` 语句和表达式 `x%3 == 0` 来检查，如果除法余数为 `0`，则该表达式评估为 `true`：
- en: '[PRE67]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If the previous condition returns to `true`, then the `X` variable is divisible
    by `3` and we can increment the counter.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面的条件返回 `true`，则 `X` 变量能被 `3` 整除，我们可以增加计数器。
- en: 'Finally, we can print `count`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以打印 `count`：
- en: '[PRE68]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Bonus exercises**:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加练习**：'
- en: Find how many numbers are divisible by 11 within the range of 1 to 100
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出 1 到 100 范围内有多少个数字能被 11 整除
- en: Print all the numbers that are not divisible by 3 within the range of 1 to 30
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 1 到 30 范围内所有不能被 3 整除的数字
- en: 'Activity 1: Finding the Factors of 7 between 1 and 100 Using a while Loop'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 1：使用 while 循环在 1 到 100 范围内找到 7 的因子
- en: In the following activity, we will use a `while` loop and implement the previous
    concept from the earlier exercise to print the numbers between 1 and 100 that
    are divisible by 7.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，我们将使用 `while` 循环并实现之前练习中的概念，以打印 1 到 100 范围内能被 7 整除的数字。
- en: 'Now, let''s rewrite the previous code using a `while` loop in the following
    way:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以以下方式使用 `while` 循环重写之前的代码：
- en: Create a variable of the `unsigned` type.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `unsigned` 类型的变量。
- en: Now, write the logic to print the numbers that are divisible by `7` using the
    `while` loop.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `while` 循环编写打印能被 `7` 整除的数字的逻辑。
- en: 'Then, we have to increase the value of `i` after each iteration. Use the following
    code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在每次迭代后，我们必须增加 `i` 的值。使用以下代码：
- en: '[PRE69]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The solution for this activity can be found on page 282.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 282 页找到。
- en: Arrays
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: An **array** is a data structure containing a series of elements of the same
    type that have been placed in contiguous memory locations that can be individually
    accessed by their position.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是一种数据结构，它包含一系列相同类型的元素，这些元素被放置在连续的内存位置中，可以通过它们的位置单独访问。'
- en: Arrays have fixed sizes and cannot be extended; this contributes to their runtime
    performance, with a cost in terms of limited flexibility.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 数组具有固定的大小，不能扩展；这有助于它们的运行时性能，但以有限的灵活性为代价。
- en: Array Declaration
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组声明
- en: 'Like any other variable, arrays need to be declared before they can be used.
    An array declaration has the following form:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如同任何其他变量一样，数组在使用之前需要声明。数组声明具有以下形式：
- en: '[PRE70]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, `type` is the type of the contained elements, `name` is the identifier
    of the `array` variable, and elements is the length of the array, so it signifies
    the number of elements contained within.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type`是包含元素的类型，`name`是`array`变量的标识符，而`elements`是数组的长度，因此它表示包含的元素数量。
- en: The term `elements` needs to be a constant expressions that is known at compile
    time, since that is the time when the array size is evaluated to determine the
    dimension of the block of static memory to allocate.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`elements`需要是一个在编译时已知的常量表达式，因为那时会评估数组大小以确定分配的静态内存块的维度。
- en: When an array is declared, its content is left undetermined, which means that
    the elements are not set to any specific value. This is often confusing for programmers
    as you might expect that the elements are initialized to the default value for
    the array type.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个数组时，其内容是不确定的，这意味着元素没有被设置为任何特定的值。这对于程序员来说常常令人困惑，因为你可能会期望元素被初始化为数组类型的默认值。
- en: Array Initialization
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组初始化
- en: 'Array elements can be specifically initialized at declaration time by enclosing
    these initial values in braces:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在声明时特别初始化数组元素，将这些初始值括在花括号中：
- en: '[PRE71]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When we initialize a list array, we can also omit its length as it will be
    determined by the number of values provided. The following declaration is equivalent
    to the previous one:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化列表数组时，我们也可以省略其长度，因为它将由提供的值的数量确定。以下声明与上一个声明等效：
- en: '[PRE72]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If the number of elements is provided, but the array is initialized with fewer
    elements, then the remaining value will be *zero-initialized*, for example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了元素数量，但数组只初始化了较少的元素，那么剩余的值将被*零初始化*，例如：
- en: '[PRE73]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The previous code is equivalent to the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码等效于以下代码：
- en: '[PRE74]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Accessing the Values of an Array
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问数组的值
- en: 'The values of an array can be accessed in the same way as any other values
    of the same type. The following is the syntax to access an array:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像访问同一类型的任何其他值一样访问数组的值。以下访问数组的语法：
- en: '[PRE75]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: An element of an array can be accessed to store a new element or to read its
    value.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 可以访问数组元素以存储新元素或读取其值。
- en: 'For example, the following statement updates the value at position 4 of the
    previously declared array named `foo`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下语句更新了之前声明的名为`foo`的数组中位置4的值：
- en: '[PRE76]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The following is used to copy the content of the element at position 2 into
    a new variable:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下用于将位置2的元素内容复制到一个新变量中：
- en: '[PRE77]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It is important to notice that the elements at positions `4` and `2` refer
    to the fifth and third elements, respectively. This is due to the fact that indexing
    starts from `0`. The following diagram illustrates how index entries work in arrays:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，位置`4`和`2`的元素分别指的是第五个和第三个元素。这是因为索引是从`0`开始的。以下图表说明了数组中索引条目的工作方式：
- en: '![Figure 1.9: Initializing a one-dimensional array ](img/C11557_01_09.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9：初始化一维数组](img/C11557_01_09.jpg)'
- en: 'Figure 1.9: Initializing a one-dimensional array'
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.9：初始化一维数组
- en: Exceeding the valid range of indices for an array is syntactically correct,
    so the compiler will not produce any errors. Accessing an array out of bounds
    in C++ is considered an undefined behavior, which means that the code's behavior
    is not prescribed by the language specification. This can result in runtime errors
    such as bugs caused by access to an unallocated location in memory or program
    termination (segmentation fault) due to an attempt to access memory not owned
    by the program.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '超出数组索引的有效范围在语法上是正确的，因此编译器不会产生任何错误。在C++中访问数组越界被视为未定义行为，这意味着代码的行为不是由语言规范规定的。这可能导致运行时错误，例如由于访问未分配的内存位置而导致的错误，或者由于尝试访问程序不拥有的内存而导致程序终止（段错误）。 '
- en: Multidimensional Arrays
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组
- en: Multidimensional arrays are commonly described as *arrays of arrays*, where
    an array's elements are other arrays.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组通常描述为*数组中的数组*，其中数组的元素是其他数组。
- en: 'The following syntax illustrates a bi-dimensional array:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法说明了二维数组：
- en: '[PRE78]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, `n` is the dimension of the array and `m` is the dimension of its elements.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`n`是数组的维度，`m`是其元素的维度。
- en: Typically, in a bi-dimensional array like the previous one, the first dimension
    is referred to as the `row` and the second one is referred to as the `column`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在像之前的二维数组这样的数组中，第一个维度被称为`行`，第二个维度被称为`列`。
- en: 'Multidimensional arrays are not limited to two dimensions; they can have as
    many dimensions as needed, but keep in mind that the memory that''s used increases
    exponentially with each dimension. Similar to one-dimensional arrays, multidimensional
    arrays can be initialized by specifying a list of initializers, one for each row.
    Let''s examine the following code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组不仅限于二维；它们可以有需要的任意多个维度，但请注意，随着每个维度的增加，使用的内存呈指数增长。类似于一维数组，多维数组可以通过指定每个行的初始化器列表来初始化。让我们检查以下代码：
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Alternatively, since the compiler can infer the length of the internal arrays
    from the definition, the nested braces are optional and provided only for readability:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于编译器可以从定义中推断内部数组的长度，嵌套的大括号是可选的，仅提供以提高可读性：
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Activity 2: Defining a Bi-Dimensional Array and Initializing Its Elements'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：定义一个二维数组并初始化其元素
- en: 'In this section, we will define a bi-dimensional array (`3x3`) of type integer
    and write a program to assign each element the addition of their corresponding
    index entries in the array:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一个整数类型的二维数组（`3x3`）并编写一个程序来为每个元素分配其对应数组索引条目的加和：
- en: Define an array of integers of size `3x3`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个大小为`3x3`的整数数组。
- en: Iterate over each element of the array using a nested `for` loop and assign
    the product values `x` and `y` to the index.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用嵌套的`for`循环遍历数组的每个元素，并将乘积值`x`和`y`分配给索引。
- en: 'Note:'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: The solution for this activity can be found on page 282.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第282页找到。
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the basic structure and syntax of the language. We started
    with an overview of the compilation model, the process of transforming C++ source
    code into an executable program. We wrote, compiled, and ran our first program,
    a simple `main` function that successfully returns an exit/return code.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了该语言的基本结构和语法。我们从编译模型的概述开始，该模型是将C++源代码转换为可执行程序的过程。我们编写、编译并运行了我们的第一个程序，一个简单的`main`函数，该函数成功返回了退出/返回代码。
- en: We described the built-in arithmetic types that the language offers.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了该语言提供的内置算术类型。
- en: We learned how to declare and define variable names, and what the difference
    is between references and pointers. We also saw the use of the `const` qualifier
    and its advantages.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何声明和定义变量名，以及引用和指针之间的区别。我们还看到了`const`限定符的使用及其优势。
- en: Furthermore, we talked about control flow statements and how to exploit them
    to perform more complex actions.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了控制流语句以及如何利用它们执行更复杂的行为。
- en: Finally, we presented arrays and multidimensional arrays, and the operation
    to perform to initialize them and access their values. In the next chapter, we
    will learn what functions in C++ are, and how and why we should use them in our
    code.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了数组和多维数组，以及初始化它们和访问其值所需的操作。在下一章中，我们将学习C++中的函数是什么，以及为什么我们应该在我们的代码中使用它们。
