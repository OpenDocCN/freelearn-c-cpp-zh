<html><head></head><body>
<div id="_idContainer055">
<h1 class="chapter-number" id="_idParaDest-198"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-199"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.2.1">Distributed Systems and IoT Architecture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">By accessing communication peripherals, such as network controllers and radio interfaces, microcontrollers are able to establish data communication with nearby devices and even with remote servers through </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">A set of embedded targets connected together and interacting with each other can be seen as a self-contained distributed system. </span><span class="koboSpan" id="kobo.5.2">Homogeneous machine-to-machine communication can be implemented using non-standard, and even </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">proprietary, protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Depending on the set of standard protocols it implements, an embedded system may be able to successfully communicate with heterogeneous, remote systems. </span><span class="koboSpan" id="kobo.7.2">Implementing standard protocols that are standardized or widely supported introduces the possibility to interact with gateways in the same geographic area, and with remote cloud servers across </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The connectivity range of small, embedded devices may include remote coordination using </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Information Technology</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">IT</span></strong><span class="koboSpan" id="kobo.13.1">) systems. </span><span class="koboSpan" id="kobo.13.2">The encounter between the two worlds has changed the modern interpretation of distributed systems: low-power, inexpensive devices can now be part of services with solid roots in IT, which, in turn, can extend their branches into localized and specialized sensors and actuators, creating what has been known as the </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Internet of </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.15.1">Things</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.17.1">IoT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">This technological step, considered revolutionary by many, is capable of changing the way we access technology, and human-to-machine interaction processes, forever. </span><span class="koboSpan" id="kobo.19.2">Unfortunately, the security aspects of IoT communication have too often been neglected, leading to unpleasant incidents, which may compromise the confidentiality and integrity of the data transmitted and permit attackers to take control of </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">remote devices.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">This chapter analyzes the telecommunication technologies and protocols that are possible to integrate into embedded targets, using them to better understand the design from the point of view of the whole embedded system, up to integration within </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">IoT networks.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">We will learn about the networking model, starting from the physical layer and the possible technologies for establishing wireless or wired links, up to tailored embedded applications that can establish secure communication with cloud services, using standard </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">communication protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In particular, we will look at </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Network interfaces</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Internet protocols</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.30.1">TLS</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">application protocols</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">By the end of this chapter, you will have an in-depth understanding of today’s microcontroller’s </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">IoT capabilities.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.35.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.36.1">In this chapter, we assume that you are familiar with general concepts of modern computer networking, although no previous experience with distributed applications is required. </span><span class="koboSpan" id="kobo.36.2">For a more complete background on network programming, which is relevant to the content of this chapter, we suggest, as further reading, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Hands On Network Programming with C</span></em><span class="koboSpan" id="kobo.38.1"> (L. </span><span class="koboSpan" id="kobo.38.2">Van Winkle – Packt Publishing 2019). </span><span class="koboSpan" id="kobo.38.3">There are no specific examples provided in the book’s repository for</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.39.1"> this chapter. </span><span class="koboSpan" id="kobo.39.2">More complete examples of TCP and </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.41.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.42.1">TLS</span></strong><span class="koboSpan" id="kobo.43.1">) client/server communication can be found in the source code distribution of the open source projects </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">presented here.</span></span><a id="_idTextAnchor314"/></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.45.1">Network interfaces</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Embedded devices</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.47.1"> often integrate one or more communication interfaces. </span><span class="koboSpan" id="kobo.47.2">Many microcontrollers integrate the </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Media Access Control</span></strong><span class="koboSpan" id="kobo.49.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.50.1">MAC</span></strong><span class="koboSpan" id="kobo.51.1">) portion</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.52.1"> of an Ethernet interface, so connecting</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.53.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">Physical Layer Transceiver</span></strong><span class="koboSpan" id="kobo.55.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.56.1">PHY</span></strong><span class="koboSpan" id="kobo.57.1">) would enable LAN access. </span><span class="koboSpan" id="kobo.57.2">Some devices are coupled with radio transceivers, operating at fixed frequency ranges and implementing one or more protocols to communicate over wireless links. </span><span class="koboSpan" id="kobo.57.3">Frequently used frequencies for wireless communication are the 2.4 GHz band, in use by Bluetooth and 802.11 Wi-Fi, and some specific ISM ranges of frequency below 1 GHz, which depend on local regulations. </span><span class="koboSpan" id="kobo.57.4">Usable sub-GHz frequencies include the 868 MHz ISM band in the European Union and the 915 MHz ISM band in the US. </span><span class="koboSpan" id="kobo.57.5">Transceivers are usually designed to access the physical layer according to specific link protocols, regulating shared access to the physical media among two or more devices. </span><span class="koboSpan" id="kobo.57.6">While two interfaces accessing the same media can have different configurations, the MAC model implemented must follow the same specifications on all the endpoints in order to establish point-to-point communication. </span><span class="koboSpan" id="kobo.57.7">Part of the MAC layer may be implemented in the device itself, which, in turn, can use a parallel or a serial interface to transfer data to and from </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the microcontroller.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Hardware manufacturers </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.60.1">may distribute the device drivers to access the link layer. </span><span class="koboSpan" id="kobo.60.2">When the full source code is made available, it is easier for a developer to customize the media access, integrate the device communication features, and tailor the communication to any protocol stack supported by the media. </span><span class="koboSpan" id="kobo.60.3">However, many device drivers are only partially open source, sometimes limiting the possibilities for integration with open standards. </span><span class="koboSpan" id="kobo.60.4">Moreover, integrating third-party proprietary code into an embedded system impacts the project maintenance and often requires workarounds for known issues or to enable features not foreseen by the manufacturer, and definitely impacts the security model of </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">The implementation of device drivers in embedded systems, for either wired or wireless network interfaces, includes integrating the relevant access control mechanism in the communication logic and dealing with specific channel features. </span><span class="koboSpan" id="kobo.62.2">Some characteristics of the link may affect the design of higher-level communication, thus impacting the architecture of the entire distributed system. </span><span class="koboSpan" id="kobo.62.3">Alongside a reliable interaction with the MAC mechanisms, aspects such as bit rate, latency, and maximum packet size must be addressed and evaluated in the design phase to evaluate the resources required based on the goals of </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">The next section offers an overview of some popular network interfaces in the embedded world, typically used by connected devices to communicate with the other components of a broader distributed system. </span><span class="koboSpan" id="kobo.64.2">The subsequent section will suggest some criteria to navigate through the options for selecting the best technology for a specific purpose during the design of the communication infrastructures </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">and protoc</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.66.1">ols.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.67.1">MAC</span></h2>
<p><span class="koboSpan" id="kobo.68.1">The most</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.69.1"> important components to establish successful communication links over any physical media are grouped in the MAC logic, the implementation of which is often a shared responsibility between the software and hardware. </span><span class="koboSpan" id="kobo.69.2">Different technologies have evolved to define standards to access the links that are used nowadays for machine-to-machine communication, while only a few can scale within the context of a geographically distributed IoT system without intermediate gateways performing </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">protocol conversions.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">Some of the standards are directly derived from the IT world and consist of adaptations of existing TCP/IP technologies capable of scaling down to fit within the limited resources available on embedded systems. </span><span class="koboSpan" id="kobo.71.2">Other standards have evolved entirely within the context of small, embedded devices, and interaction with the classic IT infrastructure is achieved through the modeling of TCP/IP protocols on top of low-power wireless technologies. </span><span class="koboSpan" id="kobo.71.3">In both cases, the research for convergence is dictated by the need for broader integration of small, inexpensive, self-powered devices into </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">IoT services.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">There is no such thing as a definitive one-size-fits-all solution to define network access for embedded systems. </span><span class="koboSpan" id="kobo.73.2">The differences in requirements across the embedded industry have encouraged the development of tailored MAC protocols and technologies, both standardized and proprietary, each of them tailored to respond to the need for specific features or a range of </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">In the following subsections, some of the most successful MAC technologies for machine-to-machine communication are described, taking into consideration the aspects related to the adoption of the technology and the modes </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">of integra</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.77.1">tion.</span></span></p>
<h3><span class="koboSpan" id="kobo.78.1">Ethernet</span></h3>
<p><span class="koboSpan" id="kobo.79.1">Even though</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.80.1"> it may sound a little impractical for contexts in which the size of the whole system is comparable to an RJ-45 connector, Ethernet</span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.81.1"> is still the most reliable and fastest channel of communication available to integrate into </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Many Cortex-M </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.84.1">microcontrollers are equipped with one Ethernet MAC controller, which must be integrated with an external PHY. </span><span class="koboSpan" id="kobo.84.2">Other link-layer protocols implement the same mechanism for link-layer addressing, consisting of a 14-byte preamble attached to each packet transmitted, indicating the source and destination link addresses and the type of payload contained in the packet being transported. </span><span class="koboSpan" id="kobo.84.3">The MAC addresses are rewritten every time a packet is routed toward an Ethernet-like interface by the TCP/IP stack so that they match the next link that the packet must cross in its journey toward its </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">final destination.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Device drivers</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.87.1"> can activate filters to discard all the traffic that does not involve the host, which would otherwise impact the amount of background data communication unnecessarily being processed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">TCP/</span><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.89.1">IP stack.</span></span></p>
<h3><span class="koboSpan" id="kobo.90.1">Wi-Fi</span></h3>
<p><span class="koboSpan" id="kobo.91.1">Among </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.92.1">all the possibilities in the wireless universe, 802.11 Wi-Fi is chosen for its high-speed, low-latency channel, and for the widest possible topological compatibility, including with personal computers and mobile devices. </span><span class="koboSpan" id="kobo.92.2">However, the power requirement of a Wi-Fi transceiver can sometimes be difficult to afford for low-power devices. </span><span class="koboSpan" id="kobo.92.3">The complexity of protocols and mechanisms to regulate media access requires a consistent amount of controlling software, which is often distributed in binary form, and thus impossible to debug and maintain without the support of </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the manufacturers.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Wi-Fi provides large bandwidth and reasonably low latency and may implement authentication and encryption at the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">data-link level.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">While it is technically possible to realize a local mesh network configuring the Wi-Fi transceivers to operate in an ad hoc mode, embedded systems equipped with 802.11 technology are mostly used to connect to existing infrastructures to interact with other portable devices and access </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Several embedded low-cost platforms are available on the market, equipped with a TCP/IP stack and a built-in RTOS, which can be used as a standalone platform or integrated into complete systems to access wireless LAN, either as a station or to provide an </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">acc</span><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.100.1">ess point.</span></span></p>
<h3><span class="koboSpan" id="kobo.101.1">Low-Rate Wireless Personal Area Networks (LR-WPANs)</span></h3>
<p><span class="koboSpan" id="kobo.102.1">Sensor mesh</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.103.1"> networks make extensive use of wireless technology to establish </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.104.1">communication in a local geographical area. </span><span class="koboSpan" id="kobo.104.2">The 802.15.4 standard regulates the access to 2.4 GHz and sub-GHz frequencies to provide limited-range local area networks with a typical maximum bit rate of 250 Kbps, which can be accessed using low-cost, low-power transceivers. </span><span class="koboSpan" id="kobo.104.3">The media access is not based on infrastructure and supports contention resolution and collision detection at the MAC level, using a beaconing system. </span><span class="koboSpan" id="kobo.104.4">Each node can be addressed using 2 bytes, and the special address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">0xFFFF</span></strong><span class="koboSpan" id="kobo.106.1"> is reserved for broadcast traffic to reach all the nodes in visibility. </span><span class="koboSpan" id="kobo.106.2">The maximum payload size for 802.15.4 frames is fixed to 127 bytes, and thus it is not possible to encapsulate full-size IP packets routed from an Ethernet or a wireless LAN link. </span><span class="koboSpan" id="kobo.106.3">Network</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.107.1"> protocol implementations that are capable of communicating through 802.15.4 interfaces are either application-specific, do not support IP networking, or offer fragmentation and compression mechanisms to transmit and receive each packet across multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">wireless frames.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">While not </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.110.1">specifically designed for the IoT, and not directly compatible with classic IP infrastructures, there are multiple choices available to build networks on top of 802.15.4. </span><span class="koboSpan" id="kobo.110.2">In fact, while the standard specifies the MAC protocol for exchanging frames among nodes that are in visibility, multiple link-layer technologies, standard and non-standard, have been developed to define networks on to</span><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.111.1">p </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">of 802.15.4.</span></span></p>
<h3><span class="koboSpan" id="kobo.113.1">LR-WPAN industrial link-layer extensions</span></h3>
<p><span class="koboSpan" id="kobo.114.1">Thanks</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.115.1"> to the flexibility </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.116.1">of the transceivers, and the capability of transmitting and receiving 802.15.4 raw frames, it is relatively easy to implement networking protocols </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">for LR-WPANs.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">In the pre-IoT era, the process automation industry was the first to adopt the 802.15.4 technology and had been searching for a standard protocol stack to enable compatibility among devices from different manufacturers for a long time. </span><span class="koboSpan" id="kobo.118.2">The Zigbee protocol stack endeavored to become a de facto, industry-imposed standard for 802.15.4 networking, with noticeable success, considering the proprietary, closed-source, and royalties applicable to its commercial use. </span><span class="koboSpan" id="kobo.118.3">In a parallel effort, the </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">International Society of Automation</span></strong><span class="koboSpan" id="kobo.120.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.121.1">ISA</span></strong><span class="koboSpan" id="kobo.122.1">) has </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.123.1">created a proposal for the open standard ISA100.11a, which aims to define the guidelines for building networks based on 802.15.4 links to be used in industrial automation processes. </span><span class="koboSpan" id="kobo.123.2">Another industrial automation protocol, originally developed by a consortium of enterprises and then approved by the </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">International Electrotechnical Commission</span></strong><span class="koboSpan" id="kobo.125.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.126.1">IEC</span></strong><span class="koboSpan" id="kobo.127.1">) as</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.128.1"> a standard for industrial automation, </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">is WirelessHART.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Technologies such as Zigbee, ISA100.1, and WirelessHART define the entire protocol stack above 802.15.4, including network definition and transport mechanisms, providing custom address mechanisms and communication models, and exporting an API that can be used </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.131.1">to integrate applications. </span><span class="koboSpan" id="kobo.131.2">From the perspective of the design of the distributed system, enabling internet connectivity for devices in a custom network, not implementing the IP stack, requires one or more devices to act as a gateway, rerouting and transforming each packet for the custom LR-WPAN protocol stack. </span><span class="koboSpan" id="kobo.131.3">The transformation procedure, however, violates the end-to-end semantics of TCP/IP communication, impacting various aspects of the communication, including </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">e</span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.133.1">nd-to-end security.</span></span></p>
<h3><span class="koboSpan" id="kobo.134.1">6LoWPAN</span></h3>
<p><span class="koboSpan" id="kobo.135.1">6LoWPAN, described in RFC 4944, is the IETF-standardized 802.15.4 link protocol that can</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.136.1"> transport IPv6 packets, and it is the established</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.137.1"> standard for IP-compatible LR-WPANs. </span><span class="koboSpan" id="kobo.137.2">6LoWPAN makes it possible for embedded systems to access the internet using 802.15.4 interfaces, as long as the nodes implement TCP/IP networking, and the link layer provides mechanisms to transmit and receive full-size IP packets using short LR-WPAN frames. </span><span class="koboSpan" id="kobo.137.3">The content of the packet is fragmented and transmitted into consecutive transport units, and the network and transport headers are optionally compressed to reduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">transmission overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">There is currently no IPv4 counterpart of the 6LoWPAN standard; however, IETF is evaluating proposals adopting a similar approach to enable legacy IPv4 connectivity for </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">embedded nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">6LoWPAN is part of several network stack implementations, and it is part of a recent attempt to create an industrial alliance, the Thread group, whose goal is to promote a fully IPv6, low-power mesh network technology based on open-standard protocols designed for the IoT. </span><span class="koboSpan" id="kobo.141.2">Multiple free and open source TCP/IP stacks and embedded operating systems support 6LoWPAN and can access 802.15.4 transceivers to provide the necessary link infrastructure to build IP networks based on the functionalities and the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">protocol implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">Mesh networking can optionally be added to the link layer to provide a transparent bridge mechanism called mesh-under, where all the frames are repeated by the link layer to the remote corners of the mesh until their destination </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">is reached.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Because 6LoWPAN provides the infrastructure for building the network topology, mesh networking can be </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.146.1">approached differently, using application-level protocols to</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.147.1"> update the routing tables at the IP level. </span><span class="koboSpan" id="kobo.147.2">These mechanisms, known as route-over mesh networking, are based on standardized dynamic routing mechanisms, and may also be used to extend the mesh network across di</span><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.148.1">fferent </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">physical links.</span></span></p>
<h3><span class="koboSpan" id="kobo.150.1">Bluetooth</span></h3>
<p><span class="koboSpan" id="kobo.151.1">Another</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.152.1"> machine-to-machine connectivity technology</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.153.1"> in constant evolution is Bluetooth. </span><span class="koboSpan" id="kobo.153.2">Its physical layer is based on 2.4 GHz communication to establish host/device communication or provide the infrastructure for PAN supporting multiple protocols, including TCP/IP communication. </span><span class="koboSpan" id="kobo.153.3">Thanks to its longtime success and its consequent wide adoption in the market of personal computers and portable devices, Bluetooth connectivity has started to gain popularity in the universe of embedded microcontrollers, mostly due to the recent evolution of the standard in the direction of lower </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">power consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Initially designed as a wireless replacement for serial communication for devices at a close range, the </span><em class="italic"><span class="koboSpan" id="kobo.156.1">classic</span></em><span class="koboSpan" id="kobo.157.1"> Bluetooth technology has evolved to support integrated dedicated channels, including TCP/IP-capable network interfaces and dedicated audio and video </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">streaming links.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">A low-power variant of the protocol stack, introduced with version 4 of the standard definition, has been designed to limit energy consumption for embedded sensor nodes and introduces a new set of services. </span><span class="koboSpan" id="kobo.159.2">A sensor device may export a </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Generic Attribute Profile</span></strong><span class="koboSpan" id="kobo.161.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.162.1">GATT</span></strong><span class="koboSpan" id="kobo.163.1">) that </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.164.1">can be accessed by a client (usually a host machine) to establish communication with a device. </span><span class="koboSpan" id="kobo.164.2">When the transceiver on the target is inactive, it consumes a small amount of power, with it still remaining possible to discover its attribute and initiate a GATT transfer from a client. </span><span class="koboSpan" id="kobo.164.3">Bluetooth is mostly used nowadays for short-range communication; to access sensor nodes from personal computers and portable devices; to exchange multimedia content with remote audio devices such as speakers, headsets, and hands-free automotive voice interfaces; and in several healthcare applications, thanks to some profiles being specifically </span><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.165.1">designed for </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">this purpose.</span></span></p>
<h3><span class="koboSpan" id="kobo.167.1">Mobile networks</span></h3>
<p><span class="koboSpan" id="kobo.168.1">Connecting</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.169.1"> remote devices that have no fixed infrastructure available in their surroundings has been made possible using the same technology that portable devices use to access the internet over mobile networks, such as GSM/GPRS, 3G, and LTE. </span><span class="koboSpan" id="kobo.169.2">The increasing complexity, cost, and energy requirements characterizing the devices that access broadband mobile connectivity have increased the impact of integrating this sort of network communication into microcontroller-based embedded devices. </span><span class="koboSpan" id="kobo.169.3">Mobile networks support TCP/IP protocols natively and provide direct connectivity to the internet, or in some cases, to restricted networks provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">access infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Although still popular in some specific markets, such as automotive and railway, broadband network access profiles are usually overkill for transferring a small amount of information from remote sensor devices, while simpler modems to access older, narrow-bandwidth technologies are slowly disappearing from </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the market.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">While mobile network technologies evolve, focusing on the requirements of the mobile phone market, embedded device architects are in search of new technologies that better match the needs of distributed IoT systems. </span><span class="koboSpan" id="kobo.173.2">New technologies better meet the embedded market goals and evolution toward low-power, cost-effective, </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">l</span><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.175.1">ong-distance communication.</span></span></p>
<h3><span class="koboSpan" id="kobo.176.1">Low-Power Wide Area Networks (LPWANs)</span></h3>
<p><span class="koboSpan" id="kobo.177.1">LWPANs </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.178.1">are a family of emerging technologies that fill the market gap for cost-effective, low-power, long-distance, narrow-band communication. </span><span class="koboSpan" id="kobo.178.2">As for LR-WPANs, different industrial alliances have been formed in an attempt to conquer the market, and in some cases, establish a standard protocol stack for universal LPWAN networks. </span><span class="koboSpan" id="kobo.178.3">This process has led to healthy competition on features, costs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">power-saving features.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">LPWAN technologies are usually based on sub-GHz physical channels, but use different radio settings, allowing for an increased range. </span><span class="koboSpan" id="kobo.180.2">Devices can communicate with each other over the air, and, in some cases, use an infrastructure to increase coverage, even across thousands of kilometers, when in visibility of a </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">base station.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">The most noticeable emerging technologies in this field include </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.184.1">LoRa</span></strong><span class="koboSpan" id="kobo.185.1">/</span><strong class="bold"><span class="koboSpan" id="kobo.186.1">LoRaWAN</span></strong><span class="koboSpan" id="kobo.187.1">: Based </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.188.1">on patented wireless radio access mechanisms and a fully proprietary protocol stack, this technology provides long-distance communication with a high bit rate compared to similar technologies. </span><span class="koboSpan" id="kobo.188.2">While it offers several interesting features, such as local node-to-node communication in the absence of infrastructure, the closed-protocol approach </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.189.1">makes this approach less appealing for the embedded market, and less likely to keep its place in the LPWAN competition eventually in favor of more </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">open standards.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Sigfox</span></strong><span class="koboSpan" id="kobo.192.1">: This</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.193.1"> ultra-narrow-band radio technology requires an infrastructure to operate, and offers</span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.194.1"> a particularly low bit rate on very long ranges. </span><span class="koboSpan" id="kobo.194.2">Regulated infrastructure access allows a limited number of bytes to be transferred from or to a node every day, and the payload of the messages is fixed at 12 bytes. </span><span class="koboSpan" id="kobo.194.3">While the physical layer implementation is proprietary, the protocol stack is distributed in source code form. </span><span class="koboSpan" id="kobo.194.4">Radio regulations in some countries are still an open point, though, and may impact the development of this technology worldwide, despite its considerable success in the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">European market.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.196.1">Weightless</span></strong><span class="koboSpan" id="kobo.197.1">: Another</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.198.1"> technology based on ultra-narrow-band, Weightless is a fully open standard for LPWAN operating in the sub-GHz range. </span><span class="koboSpan" id="kobo.198.2">Similar to Sigfox in terms of range and performance, it provides an improved security model as an alternative to the classic pre-shared keys deploying mechanisms, allowing for over-the-air security key </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">negotiation mechanisms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.200.1">DASH7</span></strong><span class="koboSpan" id="kobo.201.1">: The</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.202.1"> youngest of the technologies described here is based on a fully open design. </span><span class="koboSpan" id="kobo.202.2">The source code for the entire lightweight protocol stack is provided by the DASH7 alliance, which allows for easier integration of the technology into embedded systems. </span><span class="koboSpan" id="kobo.202.3">This protocol stack is designed to provide flexibility while designing distributed systems, due to the multiple choices in defining the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">network topology.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.204.1">LPWAN protocols are not directly compatible with IP and require one of the nodes on the network to generate TCP/IP traffic based on the long-range communication data acquired from the nodes. </span><span class="koboSpan" id="kobo.204.2">The sporadic, low-bit rate characteristics of the network traffic make these technologies operate in their own field, and require nodes capable of rerouting data from the nodes when the architecture of the distributed systems foresees access</span><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.205.1">ing remote nodes on </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the internet.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.207.1">Selecting the appropriate network interfaces</span></h2>
<p><span class="koboSpan" id="kobo.208.1">Depending </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.209.1">on the use case, each embedded system may benefit from the communication facilities offered by the technologies described in this section. </span><span class="koboSpan" id="kobo.209.2">Due to the high specialization of some embedded devices, a design tailored to specific use cases may even go beyond this classification and use technologies that are designed for one specific use case. </span><span class="koboSpan" id="kobo.209.3">Wireless communication is impossible in some cases, due to emission regulations in some environments, and when the media is not capable of transporting radio waves reliably, such as underwater or through the </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">human body.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Submarines may communicate via specific transceivers, using sound waves to represent the data. </span><span class="koboSpan" id="kobo.211.2">Other widespread technologies are available for wired communication as well. </span><span class="koboSpan" id="kobo.211.3">Power line communication allows existing wires to be reused to refit older devices and brings local network connectivity, extending Ethernet or serial interfaces buses using high-frequency modulation that does not impact the original purpose of the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">wires used.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">As it turns out, embedded devices have a broad range of possibilities when it comes to connectivity. </span><span class="koboSpan" id="kobo.213.2">The optimal choice always depends on the specific use case and the resources available on the system to implement protocols and standards required to reach the other endpoints of the communication. </span><span class="koboSpan" id="kobo.213.3">When selecting a communication technology, there might be several aspects to take </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">into account:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.215.1">The range </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">of communication</span></span></li>
<li><span class="koboSpan" id="kobo.217.1">The bit rate required for </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">data transfer</span></span></li>
<li><span class="koboSpan" id="kobo.219.1">The total cost of ownership (transceiver price, integration effort, and </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">service costs)</span></span></li>
<li><span class="koboSpan" id="kobo.221.1">Media-specific limitations, such as any latency introduced by </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">the transceiver</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">The impact of RF interference on the hardware </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">design requirements</span></span></li>
<li><span class="koboSpan" id="kobo.225.1">The maximum </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">transfer unit</span></span></li>
<li><span class="koboSpan" id="kobo.227.1">Power consumption and </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">energy footprint</span></span></li>
<li><span class="koboSpan" id="kobo.229.1">Protocols or standards supported for compatibility with </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">third-party systems</span></span></li>
<li><span class="koboSpan" id="kobo.231.1">Compliance with Internet protocols for integration in </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">IoT systems</span></span></li>
<li><span class="koboSpan" id="kobo.233.1">Topology flexibility, dynamic routing, and mesh </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">network feasibility</span></span></li>
<li><span class="koboSpan" id="kobo.235.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">security model</span></span></li>
<li><span class="koboSpan" id="kobo.237.1">The resources required to implement drivers and protocols for a </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">specific technology</span></span></li>
<li><span class="koboSpan" id="kobo.239.1">The use of open standards to avoid lock-in for </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">long-lived projects</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.241.1">Each and every</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.242.1"> technology for connected devices offers a different take on how these aspects are addressed in its intrinsic design, also depending on whether the technology has been borrowed from a different context, such as Ethernet or GSM/LTE, or has been designed with low-power embedded systems in mind, as in LR-WPAN and </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">LWPAN protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">Selecting the appropriate communication channels when designing distributed systems is an operation that requires strict collaboration between hardware and software design. </span><span class="koboSpan" id="kobo.244.2">Creating connected devices involves one more level of complexity, especially in the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">low-power domain.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">The next section focuses on how the implementation of Internet protocols can be adapted to scale down to embedded devices to produce network endpoints that operate within standards and are rich in features. </span><span class="koboSpan" id="kobo.246.2">TCP/IP stack implementation can be extended and configured to meet the requirements of an IoT-distributed system. </span><span class="koboSpan" id="kobo.246.3">Cases in which non-IP protocols are translated by a border gateway to integrate non-standard communication in IoT systems (edge gateways) are not covered here, as they often involve larger dedicated systems with multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">network interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">As we have observed, the embedded industry is specialized enough to operate at the edge of the standards, but a new research trend is bringing TCP/IP communication back to its original position as the established standard for network communication, due to the increasing influence of the existing IT infrastructure in distributed systems, including small, low-power, cost-effective embedded systems. </span><span class="koboSpan" id="kobo.248.2">This has also recently extended in the market to standard security functionality, increasing the presence of secure end-to-end communication protocols such as TLS and DTLS on </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">embedded systems.</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.250.1">The Internet protocols</span></h1>
<p><span class="koboSpan" id="kobo.251.1">Standardized at</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.252.1"> the beginning of the 1980s, the IP stack, mostly referred to nowadays as TCP/IP, is a family of network, transport, and application protocols providing standard communication over a wide range of technologies and interfaces. </span><span class="koboSpan" id="kobo.252.2">In the upcoming subsections, we will discuss the integration of these standard protocols into embedded systems, describe the interfaces that embedded applications use to communicate with remote endpoints, and learn how to interact with the different layers of the stack, from the network interfaces up to the socket abstraction to establish connections or connectionless sessions with a </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">remote peer.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.254.1">Standard protocols, custom implementations</span></h2>
<p><span class="koboSpan" id="kobo.255.1">Designing distributed </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.256.1">communication using non-standard protocol stacks is, in almost all cases, not worth the effort required to reinvent state-of-the-art technology. </span><span class="koboSpan" id="kobo.256.2">TCP/IP standards have been the subject of extensive research for many decades, and have been the main building block for the internet as we know it today, integrating billions of heterogeneous devices. </span><span class="koboSpan" id="kobo.256.3">Equipping an embedded system with TCP/IP capabilities is no longer a pioneering task, as several open source implementations exist, and they can easily be integrated into small embedded systems, as long as they can access physical communication channels providing data transfer capabilities between two or </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">more endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Sockets are the </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.259.1">standard way to access transport-layer communication from network applications. </span><span class="koboSpan" id="kobo.259.2">The Berkeley socket model, later standardized by POSIX, includes a naming standard for functions and components and the behavior in a UNIX operating system. </span><span class="koboSpan" id="kobo.259.3">If the TCP/IP stack is integrated with the operating system, the scheduler can provide a mechanism to suspend the caller while waiting for a specific input, and the socket call API can be implemented to match POSIX specifications. </span><span class="koboSpan" id="kobo.259.4">In a bare-metal event-based application, however, synchronization with the sockets is done using callbacks, in order to follow the event-based model of the main loop. </span><span class="koboSpan" id="kobo.259.5">For this reason, writing applications that interact with network protocols is slightly different in terms of the APIs and paradigms. </span><span class="koboSpan" id="kobo.259.6">In a non-blocking network application within a single thread, no operation should keep the CPU busy while waiting for events, except the main loop function itself. </span><span class="koboSpan" id="kobo.259.7">Socket function calls make no exception, requiring a mechanism to initiate an operation, register a callback function to handle the end of it, and the</span><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.260.1">n immediately return to the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">main loop.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.262.1">The TCP/IP stack</span></h2>
<p><span class="koboSpan" id="kobo.263.1">A modern</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.264.1"> TCP/IP stack is perhaps the most fundamental part of a distributed embedded system. </span><span class="koboSpan" id="kobo.264.2">The reliability of the communications depends on how accurately the standard protocols are implemented, and the security of the services running on the device may be compromised by defects hidden in the TCP/IP stack implementation, its interface drivers, and the glue code to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">socket abstractions.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">The most popular open source TCP/IP library for embedded devices is the </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">lightweight IP</span></strong><span class="koboSpan" id="kobo.268.1"> stack, best</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.269.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">lwIP</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">Integrated with many real-time OSes and even distributed in a bundle by hardware manufacturers, lwIP provides the IPv4 and IPv6 network, UDP and TCP socket communication, DNS and DHCP client, and a rich bundle of application-layer protocols that can be integrated into an embedded system using just a few tens of KBs of memory. </span><span class="koboSpan" id="kobo.271.3">Despite being tailored for small microcontrollers, the resources required by a fully featured stack, such as lwIP, are out of range for some smaller devices, including most sensor processing targets with ultra-low </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">power characteristics.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.273.1">Micro IP</span></strong><span class="koboSpan" id="kobo.274.1">, mostly referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">uIP</span></strong><span class="koboSpan" id="kobo.276.1">, is a </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.277.1">minimalistic TCP/IP implementation based on the unusual but brilliant intuition of processing one single buffer at a time. </span><span class="koboSpan" id="kobo.277.2">Not having to allocate multiple buffers in memory keeps the amount of RAM needed for TCP/IP communication as limited as possible, and reduces the complexity of the implementation of TCP and other protocols, and, as a result of this, the code size of the entire stack. </span><span class="koboSpan" id="kobo.277.3">uIP is not designed to scale up to a higher bit rate or for implementing advanced features, but it is sometimes the best compromise to connect nodes with very limited resources, mostly to </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">LR-WPAN networks.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">picoTCP is a</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.280.1"> free software TCP/IP stack with a more recent history. </span><span class="koboSpan" id="kobo.280.2">It shares similar resource footprints and features lists with lwIP, but has a different modular design and a stronger focus on IoT protocols, providing dynamic routing, IP filtering, and NAT capabilities. </span><span class="koboSpan" id="kobo.280.3">With native support for 6LoWPAN over 802.15.4 devices, picoTCP can be used to build mesh networks, using either the mesh-under capabilities in 6LoWPAN, or a more classic route-over approach, using dynamic routing protocols, such as OLSR and AODV, provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">the modules.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Other implementations exist for both open source and proprietary TCP/IP stacks, which can be integrated into both bare-metal applications and embedded operating systems, often providing similar APIs for integrating interface drivers and interacting with the system to provide socket communication to higher-level applications. </span><span class="koboSpan" id="kobo.282.2">An embedded TCP/IP stack is connected to network devices through a device driver, providing a function to send frames to the network, and capable of delivering the received packets using an entry point function, which the TCP/IP stack uses to take the packet in charge. </span><span class="koboSpan" id="kobo.282.3">The packets that are currently being handled by the TCP/IP stack may require asynchronous</span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.283.1"> operations, so the application, or the OS, must ensure that the stack loop function is called periodically so that it can process the packets in the buffers. </span><span class="koboSpan" id="kobo.283.2">Finally, a socket interface is provided by the transport layer for the application to create and use the s</span><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.284.1">ocket to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">remote endpoints.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.286.1">Network device drivers</span></h2>
<p><span class="koboSpan" id="kobo.287.1">In order to </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.288.1">integrate a driver for a network interface, the TCP/IP stack exposes an interface to its lowest layers, sending and receiving buffers containing frames or packets. </span><span class="koboSpan" id="kobo.288.2">If the device supports the link-layer Ethernet address, TCP/IP stacks must connect an additional component to deal with Ethernet frames, and activate the neighbor discovery protocols to find the MAC address of the receiving device before initiating any </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">IP communication.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">lwIP provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">netif</span></strong><span class="koboSpan" id="kobo.292.1"> structure, describing a network interface, which must be allocated by the driver code, but is then initialized automatically by the stack using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">netif_add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
struct *netif netif_add(struct netif *mynetif,
    struct ip_addr *ipaddr,
    struct ip_addr *netmask,
    struct ip_addr *gw, void *state,
    err_t (* init)(struct netif *netif),
    err_t (* input)(struct pbuf *p, struct netif *netif));</span></pre>
<p><span class="koboSpan" id="kobo.296.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">ipaddr</span></strong><span class="koboSpan" id="kobo.298.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">netmask</span></strong><span class="koboSpan" id="kobo.300.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">gw</span></strong><span class="koboSpan" id="kobo.302.1"> arguments can be used to set an initial IPv4 configuration for the link created through this interface. </span><span class="koboSpan" id="kobo.302.2">lwIP supports one IPv4 address and three IPv6 addresses per interface, but all of them can be reconfigured at a later stage by accessing the relative fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">netif</span></strong><span class="koboSpan" id="kobo.304.1"> structure. </span><span class="koboSpan" id="kobo.304.2">The IP address can be configured either using a static IP address or a mechanism to automatically assign it, such as DHCP negotiation, or deriving it from </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">link-local addresses.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">state</span></strong><span class="koboSpan" id="kobo.308.1"> variable is a user-defined pointer that can create an association between the net device and a private field that can be accessed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">netif-&gt;state</span></strong><span class="koboSpan" id="kobo.310.1"> pointer in the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">driver code.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">The </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.313.1">function pointer provided as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">init</span></strong><span class="koboSpan" id="kobo.315.1"> argument is called during the initialization of the stack, with the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">netif</span></strong><span class="koboSpan" id="kobo.317.1"> pointer, and it must be used by the driver to initialize the remaining fields for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">netif</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1"> device.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">The function pointer provided through the input argument describes the internal action that the stack has to perform when it receives a packet from the network. </span><span class="koboSpan" id="kobo.320.2">If the device communicates using Ethernet frames, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">ethernet_input</span></strong><span class="koboSpan" id="kobo.322.1"> function should be supplied to indicate that additional processing for the Ethernet frame would be required before parsing the frame content and that the network supports neighbor discovery protocols to associate IP addresses to MAC addresses before transmitting the data. </span><span class="koboSpan" id="kobo.322.2">If the driver is handling naked IP packets instead, the receiving function to associate </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">ip_input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">The device driver initialization is finalized in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">init</span></strong><span class="koboSpan" id="kobo.328.1"> function, which must also assign a value to other important fields in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">netif</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1"> structure:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">hw_addr</span></strong><span class="koboSpan" id="kobo.332.1">: Containing the MAC address for the Ethernet device, </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">if supported.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">mtu</span></strong><span class="koboSpan" id="kobo.335.1">: The maximum transfer unit size allowed by </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">this interface.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">name</span></strong><span class="koboSpan" id="kobo.338.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">num</span></strong><span class="koboSpan" id="kobo.340.1">: For device identification on </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the system.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">output</span></strong><span class="koboSpan" id="kobo.343.1">: This function pointer is called by the stack to append a custom link header to the IP packet ready for transmission. </span><span class="koboSpan" id="kobo.343.2">For Ethernet devices, this should point to </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">etharp_output</span></strong><span class="koboSpan" id="kobo.345.1"> to trigger neighbor </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">discovery mechanisms.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">link_output</span></strong><span class="koboSpan" id="kobo.348.1">: This function pointer is called by the stack when a buffer is ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">be transmitted.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.350.1">After the link has been marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">up</span></strong><span class="koboSpan" id="kobo.352.1"> by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">netif_up</span></strong><span class="koboSpan" id="kobo.354.1">, the device driver can call the input function upon the reception of new packets, and the stack itself will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">output</span></strong><span class="koboSpan" id="kobo.356.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">link_output</span></strong><span class="koboSpan" id="kobo.358.1"> functions to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the driver.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">picoTCP exports a similar interface to implement device drivers, but it supports multiple addresses per interface, so the IP configuration is separate from the device drivers. </span><span class="koboSpan" id="kobo.360.2">Each device has a list of associated IPv4 and IPv6 links, each with its own IP configuration, to implement multi-homed services. </span><span class="koboSpan" id="kobo.360.3">A device driver structure in picoTCP must begin with a physical entry of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">pico_device</span></strong><span class="koboSpan" id="kobo.362.1"> structure as its first field. </span><span class="koboSpan" id="kobo.362.2">This way, both structures point to the same address and the device can maintain its own private fields at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">pico_device</span></strong><span class="koboSpan" id="kobo.364.1"> structure. </span><span class="koboSpan" id="kobo.364.2">To initialize the device, the structure is allocated in the driver, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">pico_device_init</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.366.1">is called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
int pico_device_init(struct pico_device *dev, const char *name, const uint8_t *mac);</span></pre>
<p><span class="koboSpan" id="kobo.368.1">The three </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.369.1">arguments required are the pre-allocated device structure, a name used for identification within the system, and the Ethernet MAC address, if present. </span><span class="koboSpan" id="kobo.369.2">If the MAC is null, the stack bypasses the Ethernet protocol, and all the traffic handled by the driver is naked IP packets with no link-layer extensions. </span><span class="koboSpan" id="kobo.369.3">The driver must implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">send</span></strong><span class="koboSpan" id="kobo.371.1"> function that is used by the stack to deliver the frames or packets to be transmitted by the interface, and input is managed through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">pico_stack_recv</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
int32_t pico_stack_recv(struct pico_device *dev, uint8_t *buffer, uint32_t len);</span></pre>
<p><span class="koboSpan" id="kobo.375.1">The device is passed again as an argument so that the stack automatically recognizes whether the interface is receiving an Ethernet frame or a raw IP packet with no headers, and reacts accordingly. </span><span class="koboSpan" id="kobo.375.2">IP addresses can be configured using </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">pico_ipv4_link_add</span></strong><span class="koboSpan" id="kobo.377.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">pico_ipv6_link_add</span></strong><span class="koboSpan" id="kobo.379.1">, and the routing table is accessed through its API to add ga</span><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.380.1">teways and static routes to </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">specific networks.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.382.1">Running the TCP/IP stack</span></h2>
<p><span class="koboSpan" id="kobo.383.1">To</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.384.1"> integrate a network stack, the system must generally provide a few commodities, such as timekeeping and heap-memory management. </span><span class="koboSpan" id="kobo.384.2">All the system features required by the stack are associated at compile time using a system-specific configuration header, which associates functions and global </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">values accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Depending on the characteristics of the physical channels and the throughput to achieve, a TCP/IP stack may become very demanding in terms of heap memory used, allocating space for new incoming buffers until the upper layers can process them. </span><span class="koboSpan" id="kobo.386.2">Assigning separate memory pools to TCP/IP stack operations might help in some designs to keep the memory usage of the stack under control by placing thresholds and hard limits without impacting the functionality of the other components on </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Most libraries implement their own internal timers using a monotonic counter, provided by the system and increased independently by another component in the system. </span><span class="koboSpan" id="kobo.388.2">The time tracking value can be increased using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">SysTick</span></strong><span class="koboSpan" id="kobo.390.1"> interrupt, providing an acceptable </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.391.1">accuracy at which the stack can organize timed operations for the protocols. </span><span class="koboSpan" id="kobo.391.2">For lwIP, it is sufficient to export a global variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">lwip_sys_now</span></strong><span class="koboSpan" id="kobo.393.1">, which contains the time elapsed from booting, expressed in milliseconds. </span><span class="koboSpan" id="kobo.393.2">picoTCP needs to export a macro or an inline function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">PICO_TIME_MS</span></strong><span class="koboSpan" id="kobo.395.1"> returning the same value. </span><span class="koboSpan" id="kobo.395.2">Both stacks expect that the main loop of the application provides recurring entry points, by calling a function in the core API, required to manage the internal states of the </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">system protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">To check whether any of the pending timers have expired, the system calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">sys_check_timeouts</span></strong><span class="koboSpan" id="kobo.399.1"> in lwIP, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">pico_stack_tick</span></strong><span class="koboSpan" id="kobo.401.1"> in picoTCP, from the main event loop or a dedicated thread when running within an OS. </span><span class="koboSpan" id="kobo.401.2">The interval between consecutive calls may impact timer accuracy, and, in general, should not be longer than a few milliseconds to ensure that the network stack is responsive to </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">timed events.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Network interfaces must also be polled for input from the network, either continuously or through an appropriate interrupt handling implemented in the system. </span><span class="koboSpan" id="kobo.403.2">When new data is available, the device drivers allocate new buffers and initiate the processing by calling the input functions of the data link or the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">network layer.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">A typical bare-metal application using lwIP begins by performing all the initialization steps for the stack and the device driver. </span><span class="koboSpan" id="kobo.405.2">The structure for the network interface is allocated in the main function stack and initialized with a static IPv4 configuration. </span><span class="koboSpan" id="kobo.405.3">The following code assumes that the device driver exports a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">driver_netdev_create</span></strong><span class="koboSpan" id="kobo.407.1">, which populates the interface-specific fields </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">and callbacks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
void main(void)
{
  struct netif netif;
  struct ip_addr ipaddr, gateway, netmask;
  IP4_ADDR(&amp;ipaddr, 192,168,0,2);
  IP4_ADDR(&amp;gw, 192,168,0,1);
  IP4_ADDR(&amp;netmask, 255,255,255,0);
  lwip_init();
  netif_add(&amp;netif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL,
  driver_netdev_create, ethernet_input);
  netif_set_default(&amp;netif);</span></pre>
<p><span class="koboSpan" id="kobo.410.1">The network interface is then activated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">TCP/IP stack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
  netif_set_up(&amp;netif);</span></pre>
<p><span class="koboSpan" id="kobo.413.1">Before </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.414.1">entering the main loop, the application initializes the communication by creating and configuring the sockets, and associating </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the callbacks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
  application_init_sockets();</span></pre>
<p><span class="koboSpan" id="kobo.417.1">The main loop relies on the driver to export a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">driver_netdev_poll</span></strong><span class="koboSpan" id="kobo.419.1"> in this case, which is the function where the driver calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">ethernet_input</span></strong><span class="koboSpan" id="kobo.421.1"> whenever a new frame is received. </span><span class="koboSpan" id="kobo.421.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">sys_check_timeouts</span></strong><span class="koboSpan" id="kobo.423.1"> is called so that lwIP can keep track of the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">pending timers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
  while (1) {
   /* poll netif, pass packet to lwIP */
   driver_netdev_poll(&amp;netif);
   sys_check_timeouts();
   WFI();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.426.1">A similar procedure is expected from bare-metal applications running picoTCP. </span><span class="koboSpan" id="kobo.426.2">The initialization of the device driver is independent of the stack, and the driver is expected to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">pico_device_init</span></strong><span class="koboSpan" id="kobo.428.1"> on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">pico_device</span></strong><span class="koboSpan" id="kobo.430.1"> struct contained in the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">driver_device</span></strong><span class="koboSpan" id="kobo.432.1"> type as the mandatory first member. </span><span class="koboSpan" id="kobo.432.2">The only function exported by the driver is </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">driver_netdev_create</span></strong><span class="koboSpan" id="kobo.434.1">, which also associates its specific network-polling function pointer, which will be called by </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">pico_stack_tick</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">The stack expects a callback to </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">pico_stack_recv</span></strong><span class="koboSpan" id="kobo.438.1"> whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">poll</span></strong><span class="koboSpan" id="kobo.440.1"> function of the driver has new incoming packets </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">to process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
void main(void)
{
  struct driver_device dev;
  struct ip4 addr, netmask, gw, zero, any;
  pico_string_to_ipv4("192.168.0.2", &amp;ipaddr.addr);
  pico_string_to_ipv4("255.255.255.0", &amp;netmask.addr);
  pico_string_to_ipv4("192.168.0.1", &amp;gw.addr);
  any.addr = 0;
  pico_stack_init();
  driver_netdev_create(&amp;dev);</span></pre>
<p><span class="koboSpan" id="kobo.443.1">The IPv4 address </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.444.1">configuration is performed by accessing the API of the IPv4 module. </span><span class="koboSpan" id="kobo.444.2">Applications may associate one or more IP address configurations by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">pico_ipv4_link_add</span></strong><span class="koboSpan" id="kobo.446.1"> and specifying the address and netmask. </span><span class="koboSpan" id="kobo.446.2">A route in the IP protocol is created automatically to reach all the neighbors in the subnet through </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
  pico_ipv4_link_add(&amp;dev, ipaddr, netmask);</span></pre>
<p><span class="koboSpan" id="kobo.449.1">To add a default route, the gateway is associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">0.0.0.0</span></strong><span class="koboSpan" id="kobo.451.1"> address (indicating any host) with a metric of </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">1</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">The default gateway can be later overridden by defining more specific routes for </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">other subnetworks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.455.1">
  pico_ipv4_route_add(any, any, gw, 1, NULL);</span></pre>
<p><span class="koboSpan" id="kobo.456.1">As in the previous example, the application can now initialize its sockets and associate callbacks that will be called by the stack </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">when needed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
  application_init_sockets();</span></pre>
<p><span class="koboSpan" id="kobo.459.1">This simple main loop calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">pico_stack_tick</span></strong><span class="koboSpan" id="kobo.461.1"> repeatedly, which will poll all the associated network interfaces in a round-robin, and perform all the pending actions in all </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">protocol modules:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
  while (1)
  pico_stack_tick();
  WFI();
}</span></pre>
<p><span class="koboSpan" id="kobo.464.1">All the TCP/IP actions</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.465.1"> are associated with socket callbacks, which are called whenever the application is expected to react to network and timeout events, and timeouts are set up automatically by the stack when required to manage the internal states of the single protocols. </span><span class="koboSpan" id="kobo.465.2">The interface that is provided to access the socket communication in the absence of an operating system, as previously mentioned, is based on custom callbacks, depending on the implementation of the specific stack. </span><span class="koboSpan" id="kobo.465.3">The next section shows how to use non-blocking socket </span><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.466.1">APIs in two different TCP/IP </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">stack implementations.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.468.1">Socket communication</span></h2>
<p><span class="koboSpan" id="kobo.469.1">The</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.470.1"> interface provided by lwIP for bare-metal socket communication, also called the raw socket API, consists of custom calls, each specifying a callback whenever an event is expected from the stack. </span><span class="koboSpan" id="kobo.470.2">When a specific event occurs, lwIP will call the callback from the main </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">loop function.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">The description of a TCP socket in lwIP is contained in a TCP-specific protocol control block structure, </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">tcp_pcb</span></strong><span class="koboSpan" id="kobo.474.1">. </span><span class="koboSpan" id="kobo.474.2">To allocate a new control block for the listening TCP socket, the following function </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">is used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
struct tcp_pcb *tcp_new(void);</span></pre>
<p><span class="koboSpan" id="kobo.477.1">To accept a TCP connection, a bare-metal lwIP TCP server would first </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">call this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
err_t tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr,
    u16_t port);
err_t tcp_listen(struct tcp_pcb *pcb);</span></pre>
<p><span class="koboSpan" id="kobo.480.1">These non-blocking functions bind the socket to a local address and put it into a </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">listening state.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">At this point, a POSIX application using blocking sockets would call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">accept</span></strong><span class="koboSpan" id="kobo.484.1"> function, which would wait indefinitely for the next incoming connection on the socket. </span><span class="koboSpan" id="kobo.484.2">A lwIP bare-metal application instead calls </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
void tcp_accept(struct tcp_pcb *pcb,
    err_t (* accept)(void *arg, struct tcp_pcb *newpcb,
    err_t err)
);</span></pre>
<p><span class="koboSpan" id="kobo.487.1">This </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.488.1">simply indicates that the server is ready to accept new connections, and wants to be called back to the address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">accept</span></strong><span class="koboSpan" id="kobo.490.1"> function that has been passed as a parameter when a new incoming connection </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">is established.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">Using the same mechanism, to receive the next data segment, the application calls </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
void tcp_recv(struct tcp_pcb *pcb,
    err_t (* recv)(void *arg, struct tcp_pcb *tpcb,
    struct pbuf *p, err_t err)
);</span></pre>
<p><span class="koboSpan" id="kobo.495.1">This indicates to the TCP/IP stack that the application is ready to receive the next segment over the TCP connection, and the operation can be performed when a new buffer is available because the stack calls the actual </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">recv</span></strong><span class="koboSpan" id="kobo.497.1"> function that has been specified as the argument when </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">tcp_recv</span></strong><span class="koboSpan" id="kobo.499.1"> has </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">been called.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Similarly, picoTCP associates one callback with each socket object. </span><span class="koboSpan" id="kobo.501.2">The callback is a common point to react to any socket-related events, such as a new incoming TCP connection, new data to be read on the socket buffer, or the end of the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">write operation.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">The callback is specified when the socket </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">is created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
struct pico_socket *pico_socket_open(uint16_t net,
    uint16_t proto,
void (*wakeup)(uint16_t ev, 
    struct pico_socket *s));</span></pre>
<p><span class="koboSpan" id="kobo.506.1">The </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.507.1">preceding function creates a new socket object for use in the specified network and transport protocol context, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">net</span></strong><span class="koboSpan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">proto</span></strong><span class="koboSpan" id="kobo.511.1"> arguments respectively, and reacts to all socket events by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">wakeup</span></strong><span class="koboSpan" id="kobo.513.1"> function that is provided by the application. </span><span class="koboSpan" id="kobo.513.2">Using this mechanism, picoTCP successfully detects half-closed socket connections and other events that are not specifically related to the current operation in progress but may occur due to a state change in the socket </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">communication model.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">A TCP socket server can be configured on the newly created socket using </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">these functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
int pico_socket_bind(struct pico_socket *s,
    void *local_addr,
    uint16_t *port);
int pico_socket_listen(struct pico_socket *s, int backlog);</span></pre>
<p><span class="koboSpan" id="kobo.518.1">At this point, the application has to wait for the incoming connections without calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">accept</span></strong><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">An event is generated, which calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">wakeup</span></strong><span class="koboSpan" id="kobo.522.1"> function, whenever a new incoming connection is established, and the application can finally call </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">accept</span></strong><span class="koboSpan" id="kobo.524.1"> to generate the new socket object, corresponding to the </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">incoming connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
struct pico_socket *pico_socket_accept(
    struct pico_socket *s,
    void *orig,
    uint16_t *local_port);</span></pre>
<p><span class="koboSpan" id="kobo.527.1">The first argument passed to the picoTCP </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">wakeup</span></strong><span class="koboSpan" id="kobo.529.1"> callback is a bitmask indicating the event types that occurred on the socket. </span><span class="koboSpan" id="kobo.529.2">Events may be </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">EV_RD</span></strong><span class="koboSpan" id="kobo.532.1">: Indicating that there is data to read on the incoming </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">data buffer.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">EV_CONN</span></strong><span class="koboSpan" id="kobo.535.1">: Indicating that a new connection has been established, after calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">connect</span></strong><span class="koboSpan" id="kobo.537.1">, or while waiting in a listening state, before </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">accept</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">EV_CLOSE</span></strong><span class="koboSpan" id="kobo.542.1">: Triggered when the other side of the connection sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">FIN</span></strong><span class="koboSpan" id="kobo.544.1"> TCP segment, indicating that it has finished its transmission. </span><span class="koboSpan" id="kobo.544.2">The socket is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">CLOSE_WAIT</span></strong><span class="koboSpan" id="kobo.546.1"> state, meaning that the application may still send data before terminating </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">the connection.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">EV_FIN</span></strong><span class="koboSpan" id="kobo.549.1">: Indicating that the socket has been closed, and it is not usable anymore after returning from </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">the callback.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">EV_ERR</span></strong><span class="koboSpan" id="kobo.552.1">: An </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">error occurred.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.554.1">The </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.555.1">callback interface provided by the TCP/IP stacks may be a little obscure to use at the beginning, but it is a very efficient way to achieve higher throughput when correctly implemented in </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">Both the TCP/IP stacks we have analyzed are capable of providing more standardized APIs in combination with an operating system, by running the TCP/IP library main loop in a separate thread and providing access to the sockets using </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">system calls.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">Socket communication is only one of the APIs exposed by the TCP/IP stacks. </span><span class="koboSpan" id="kobo.559.2">Other protocols implemented by the stack provide their own function signatures; these are described in both </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">libraries’ manuals.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.561.1">Connectionless protocols</span></h2>
<p><span class="koboSpan" id="kobo.562.1">TCP is a </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.563.1">widely used transport protocol, wherever the connection-oriented paradigm makes sense for the application. </span><span class="koboSpan" id="kobo.563.2">Its connectionless counterpart, UDP, is mostly used to solve a different range of problems, but it can, in some cases, cover all the needs of a small, resource-limited embedded system. </span><span class="koboSpan" id="kobo.563.3">TCP implementations are, in fact, large and, on some platforms, they take up a considerable portion of the available flash space. </span><span class="koboSpan" id="kobo.563.4">This is due to the complex internal mechanisms of TCP, which result in a lot of code to include to manage retransmissions, timeouts, and acknowledgments; organize buffers; and keep track of multiple state machines for </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">each socket.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">UDP, on the other hand, is quite simple and applies few transformations to the data from the socket interface to the network and vice-versa. </span><span class="koboSpan" id="kobo.565.2">Typically, UDP implementations are much smaller in size and due to the lack of reliability requirements, do not need to keep track of the order and gaps in the data already transmitted or received, impacting the runtime RAM usage as well. </span><span class="koboSpan" id="kobo.565.3">When the network characteristics permit it, using UDP for low-traff</span><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.566.1">ic redundant data transmission is often a </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">viable option.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.568.1">Mesh networks and dynamic routing</span></h2>
<p><span class="koboSpan" id="kobo.569.1">As</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.570.1"> previously mentioned, a link-layer protocol may be able to implement mesh-under mechanisms, which hide the complexity of the topology for the upper layers. </span><span class="koboSpan" id="kobo.570.2">A different approach is applied when the link-layer protocol does not implement this feature, or whenever the mesh solution may be extended across different network interfaces, and thus must implement a standard protocol that is interface-agnostic. </span><span class="koboSpan" id="kobo.570.3">Each link connects two devices in direct visibility, which, in turn, coordinates to detect the optimal network path to reach a remote node, based on the detected topology. </span><span class="koboSpan" id="kobo.570.4">Intermediate nodes along the path are configured to route the traffic toward the destination, based on the information available on the </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">current topology:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.572.1"><img alt="Figure 9.1 – Example of a mesh network topology (node A chooses node C to route packets towards I, after detecting the optimal four-hop route)" src="image/B18730_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.573.1">Figure 9.1 – Example of a mesh network topology (node A chooses node C to route packets towards I, after detecting the optimal four-hop route)</span></p>
<p><span class="koboSpan" id="kobo.574.1">In some scenarios, the topology is not fixed but evolves when nodes in the path become unavailable or change their location, altering their direct visibility with adjacent nodes. </span><span class="koboSpan" id="kobo.574.2">Mesh networks with </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.575.1">non-static topology are referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">Mobile Ad Hoc Networks </span></strong><span class="koboSpan" id="kobo.577.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.578.1">MANETs</span></strong><span class="koboSpan" id="kobo.579.1">). </span><span class="koboSpan" id="kobo.579.2">Dynamic routing</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.580.1"> mechanisms designed for MANETs must be able to react to topology changes and update their routes accordingly, as the network is in </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">continuous evolution.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">Route-over mesh mechanisms are implemented within the TCP/IP stack because they must be </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.583.1">able to reconfigure the IP routing table at runtime, and access socket communication. </span><span class="koboSpan" id="kobo.583.2">Mesh networks </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.584.1">based on dynamic IP routing rely on different protocols, which can be divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">two categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.586.1">Proactive dynamic-routing protocols</span></strong><span class="koboSpan" id="kobo.587.1">: Each network node sends a broadcast </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.588.1">message to announce its presence on the network, and other nodes can detect a neighbor’s presence by reading the messages, and communicating the neighbor list to the neighbors. </span><span class="koboSpan" id="kobo.588.2">The mesh network is ready to use at all times and requires a fixed reconfiguration time on </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">topology changes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.590.1">Reactive dynamic-routing protocols</span></strong><span class="koboSpan" id="kobo.591.1">: Nodes can be idling when there is no data to</span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.592.1"> exchange, and then the path is configured by querying every neighbor, asking for a route to the destination. </span><span class="koboSpan" id="kobo.592.2">The message is then repeated, increasing a counter to keep track of the hops, until it reaches the destination, at which point, using the reply, the network can define the path requested by the sender. </span><span class="koboSpan" id="kobo.592.3">These mechanisms imply that dynamic routes are formed on demand, so the first messages of the communication can suffer an additional delay; on the other hand, it requires less power and may react faster to </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">topology changes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.594.1">The most widely used protocols in</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.595.1"> the former </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.596.1">group are </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.598.1">Optimized Link-State Routing</span></strong><span class="koboSpan" id="kobo.599.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.600.1">OLSR</span></strong><span class="koboSpan" id="kobo.601.1">), standardized</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.602.1"> by IETF in RFC3626 </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">and RFC7181</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.604.1">Better Approach to Mobile Ad Hoc </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.605.1">Networking</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.606.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.607.1">B.A.T.M.A.N.</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.609.1">Babel (</span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">IETF RFC6126)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.611.1">Destination Sequence Distance </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.612.1">Vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.614.1">DSDV</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.616.1">The reactive, on-demand</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.617.1"> routing protocols standardized by IETF are </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.619.1">Ad-hoc, On-demand, Distance Vector</span></strong><span class="koboSpan" id="kobo.620.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.621.1">AODV</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">), RFC3561</span></span></li>
<li><span class="koboSpan" id="kobo.623.1">Dynamic Source </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">Routing (RFC4728)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.625.1">The choice of a routing protocol depends, once again, on the requirements of the mesh network that needs to be built. </span><span class="koboSpan" id="kobo.625.2">Reactive, on-demand protocols are the best fit in networks with sporadic data and battery-powered nodes, where a longer reaction time from the routing protocol is acceptable. </span><span class="koboSpan" id="kobo.625.3">Always-on, embedded systems may benefit from proactive routing mechanisms instead, which ensure that the routing tables are always updated to the last known state of the network, and each node knows the best route toward each possible destination at all times, but, at the same time, requires regular updates to travel across the network in the form of broadcast packets, constantly refreshing the status of the network nodes and </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">their neighbors.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">picoTCP, which </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.628.1">has been designed to provide advanced routing</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.629.1"> technologies for IoT devices, supports one mesh-under mechanism, in the 6LoWPAN link layer, and</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.630.1"> two route-over protocols, namely OLSR (reactive) and AODV (proactive), giving broader choices for integrating TCP/IP communication into mobile, ad hoc networks. </span><span class="koboSpan" id="kobo.630.2">To enable OLSR, for example, it is sufficient to compile the stack with support for OLSR, and the OLSR daemon service will automatically be enabled and run within the main TCP/IP stack loop. </span><span class="koboSpan" id="kobo.630.3">All the devices that must participate in the definition of the mesh network must be added by </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">pico_olsr_add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
pico_olsr_add(struct pico_device *dev);</span></pre>
<p><span class="koboSpan" id="kobo.635.1">AODV networking can be enabled similarly, and the interfaces are added using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">pico_aodv_add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
pico_aodv_add(struct pico_devices *dev);</span></pre>
<p><span class="koboSpan" id="kobo.639.1">In both cases, the services will run transparently for the user and alter the routing table every time a new node is detected on the network in the case of OLSR, or every time that we request communication to a remote node and an on-demand route is created to reach it. </span><span class="koboSpan" id="kobo.639.2">Nodes that are not in direct visibility specify a first-hop gateway that guarantees that the destination node can be reached, using the routing metric as an indication of the number of hops so that when a new, shorter destination is found, the route is replaced and the communication can continue, ideally with no disruptions caused by the route </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">being replaced.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">Routing protocols, such as OLSR, can consider other parameters rather than the number of hops when calculating the best path to a given destination in the mesh network. </span><span class="koboSpan" id="kobo.641.2">It is possible, for instance, to integrate information about the wireless link quality, such as the signal-to-noise ratio or the indication of the received signal strength, when calculating the best path. </span><span class="koboSpan" id="kobo.641.3">This allows us to select routes based on multiple parameters, and always select the best option available in terms of a </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">wireless signal.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Route-over </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.644.1">mesh network strategies do not foresee mechanisms to forward broadcast packets, which must be repeated by the link-layer protocol in </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.645.1">order to reach all the nodes in the network. </span><span class="koboSpan" id="kobo.645.2">However, it is known that implementing such a mechanism can easily trigger a ping-pong effect where a single packet is bounced across two or more nodes, so broadcast-forwarding mechanisms implemented in the link layer must avoid retransmitting the same frame twice by keeping track of the last few frames forwarded </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">this way.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">For IoT systems in the real world, communication requires implementing security for data in transfer. </span><span class="koboSpan" id="kobo.647.2">This includes, but is not limited to, encryption to guarantee the confidentiality of the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">data transmitted.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Implementing standard security protocols guarantees interoperability between heterogeneous components in the network (for example, between the device and a remote server), in an end-to-end fashion and relying on software solutions that are perfectly compatible with the protocols used in the classic IT wo</span><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.650.1">rld. </span><span class="koboSpan" id="kobo.650.2">The next section approaches transport layer security </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">and proposes.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.652.1">TLS</span></h1>
<p><span class="koboSpan" id="kobo.653.1">Link-layer protocols</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.654.1"> often provide some basic security mechanisms to guarantee the authentication of the client connecting to a specific network and encrypt data by using symmetric keys such as AES. </span><span class="koboSpan" id="kobo.654.2">In most cases, authentication at the link layer is sufficient to guarantee a basic level of security. </span><span class="koboSpan" id="kobo.654.3">Nevertheless, pre-shared, well-known keys often used in LR-WPAN network stacks may be vulnerable to multiple kinds of attacks, and using a pre-shared key would allow an attacker to decipher any traffic that has been previously captured on the same link if the key was compromised. </span><span class="koboSpan" id="kobo.654.4">In other scenarios, encryption alone is not sufficient to guarantee that the other endpoint is what it claims to be, or that the data flow has not been altered </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">during transmission.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">A device that takes part in an IoT-distributed system is required to implement a higher grade of security, especially in embedded devices that do not protect the memory in any way and where any backdoor means that attackers can take control of the device, and retrieve all the sensitive information, such as private keys used for authentication and encryption in the communication with remote systems. </span><span class="koboSpan" id="kobo.656.2">TLS is a set of cryptography protocols aimed to provide secure communication over standard TCP/IP sockets. </span><span class="koboSpan" id="kobo.656.3">The responsibilities of this component are mostly focused on three key requirements for secure communication in </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">distributed systems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.658.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">confidentiality</span></strong><span class="koboSpan" id="kobo.660.1"> of </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.661.1">communication between the parts involved through the use of symmetric cryptography. </span><span class="koboSpan" id="kobo.661.2">TLS defines cryptographic techniques aimed to generate one-time symmetric keys, which lose their validity at the end of the session they were </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">generated for.</span></span></li>
<li><span class="koboSpan" id="kobo.663.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">authentication</span></strong><span class="koboSpan" id="kobo.665.1"> of the </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.666.1">parts involved in the communication, using public-key cryptography to sign and verify a challenge payload. </span><span class="koboSpan" id="kobo.666.2">Due to the properties of asymmetric keys, only the part that owns the secret private key is able to sign a payload, while anyone can verify the authenticity of the signature by checking the signature with the public key counterpart of the key that signed </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">the message.</span></span></li>
<li><span class="koboSpan" id="kobo.668.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">integrity</span></strong><span class="koboSpan" id="kobo.670.1"> of the communication, using message digests, which verify that the message has not been modified along </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">its path.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.672.1">A few open source</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.673.1"> implementations of the required protocol suite to enable standard cryptography algorithms and strategies for secure socket communications are available for the </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">embedded market.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.675.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.676.1">Closed-source, proprietary implementations for security components should be avoided in this context as much as possible because security issues are much harder to track down in a closed system, and the source of the implementation has to be blindly trusted in terms of </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">vulnerability management.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">One of the most complete and up-to-date implementations is provided by the free and open source software library, </span><strong class="bold"><span class="koboSpan" id="kobo.679.1">wolfSSL</span></strong><span class="koboSpan" id="kobo.680.1">. </span><span class="koboSpan" id="kobo.680.2">The</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.681.1"> library offers the latest standard version of both TLS and DTLS and is designed for performance and reliability on small embedded systems, including support for hardware accelerators and random number generators for many embedded platforms designed for </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">system security.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">wolfSSL implements the cryptographic primitives in its core library (</span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">wolfCrypt</span></strong><span class="koboSpan" id="kobo.685.1">) and groups them in cipher suites used by TLS sockets that can be easily integrated into both, bare-metal network applications and any embedded operating system that provides a transport socket communication API. </span><span class="koboSpan" id="kobo.685.2">These cryptography primitives are optimized for embedded devices, and use assembly code for the most performance-critical operations for the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">best performance.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">The main</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.688.1"> advantage of a TLS/SSL library designed for microcontrollers is that it implements the same protocols as any PC or server on the internet, but with a fraction of the code size, and keeps the resources usage, such as memory usage during the most expensive cryptographic operations, under control at </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">all times.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">The adoption of a TLS library with support for bleeding-edge cryptography algorithms allows perfect integration with the security measures implemented in the classic IT infrastructure components of the IoT network. </span><span class="koboSpan" id="kobo.690.2">On the cloud side, services meant to be accessed by remote embedded systems should allow the selection of more efficient cipher suites based on elliptic curves, as the classic RSA-based public key encryption requires larger keys and complex calculations to reach the same level of security. </span><span class="koboSpan" id="kobo.690.3">New standards for public-key-based encryption, such as Curve22519, are included in the TLS 1.3 specifications to provide more efficient key handling for systems with fewer resources while keeping the same security level of older algorithms. </span><span class="koboSpan" id="kobo.690.4">Selecting the right set of cryptographic algorithms for TLS communication among heterogeneous systems must take into account the computation times of the operations performed on the target, </span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.691.1">such as encryption, session key generation, payload signing, </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">and verification.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.693.1">Securing socket communication</span></h2>
<p><span class="koboSpan" id="kobo.694.1">wolfSSL has </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.695.1">built-in support for many embedded operating systems, to adapt to the specific memory configurations and socket interfaces provided by different paradigms, and can also be integrated into a bare-metal system with any compatible TCP/IP stack, or easily adapted thanks to a </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.696.1">generic, callback-based </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">Input/Output</span></strong><span class="koboSpan" id="kobo.698.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.699.1">I/O</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">) interface.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">In either case, bare-metal or OS, the application must be designed to access the </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">Secure Socket Layer</span></strong><span class="koboSpan" id="kobo.703.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.704.1">SSL</span></strong><span class="koboSpan" id="kobo.705.1">) to</span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.706.1"> communicate with the remote system, while the library is responsible for providing the abstraction for the secure communication channel through the transport layer. </span><span class="koboSpan" id="kobo.706.2">To integrate TLS sessions on top of an existing bare-metal TCP/IP implementation, wolfSSL can be configured to work in non-blocking mode, polling the system for new packets received on the socket, which must be processed by the TLS layer. </span><span class="koboSpan" id="kobo.706.3">The application initiates a TCP connection as usual, either by connecting to a remote socket in the client mode or by accepting new connections from a local listening socket. </span><span class="koboSpan" id="kobo.706.4">After the connection is established, wolfSSL assigns a context to it when the application calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">wolfSSL_accept</span></strong><span class="koboSpan" id="kobo.708.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">wolfSSL_connect</span></strong><span class="koboSpan" id="kobo.710.1">, in server mode or in client mode, respectively, to initiate the TLS handshake with the remote system. </span><span class="koboSpan" id="kobo.710.2">Data communication is then available using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">wolfSSL_read</span></strong><span class="koboSpan" id="kobo.712.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">wolfSSL_write</span></strong><span class="koboSpan" id="kobo.714.1"> functions, instead of the normal socket read/write functions exported by the TCP/IP stack so that the stream can be processed by the additional SSL built by the TLS library </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">on top.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">The </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.717.1">following usage example refers to using wolfSSL to create a TLS socket on top of a TCP connection. </span><span class="koboSpan" id="kobo.717.2">The approach for creating a DTLS socket, the TLS equivalent for connectionless socket, on top of UDP is quite similar, and still uses the same connect/accept paradigm as TLS, despite UDP being usually utilized in a peer-to-peer fashion that does not expose a net distinction between the client and the server side as well as TCP does. </span><span class="koboSpan" id="kobo.717.3">More information about creating DTLS connectionless secure sockets can be found in the wolfSSL user </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">manual (</span></span><a href="https://www.wolfssl.com/documentation/manuals/wolfssl/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.719.1">https://www.wolfssl.com/documentation/manuals/wolfssl/index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.720.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">In our simple usage example, the library is first initialized before accessing any API, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">wolfSSL_Init</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">This is the only requirement to initialize and create new objects that are commonly called contexts. </span><span class="koboSpan" id="kobo.723.3">A single context implements one specific method (the TLS v. </span><span class="koboSpan" id="kobo.723.4">1.2 server in this example) and will be associated with one or more existing sockets through a different abstraction called </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">SSL</span></strong><span class="koboSpan" id="kobo.725.1">, which, in the case of the wolfSSL implementation, is represented by a variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">WOLFSSL</span></strong><span class="koboSpan" id="kobo.727.1">. </span><span class="koboSpan" id="kobo.727.2">Multiple SSL objects generated from the same context share the same set of cryptography keys and I/O callback functions that wolfSSL can use to query the system for incoming data, or transmit the processed data through the </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">socket connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.729.1">
wolfSSL_Init();
wolfSSL_CTX *ctx;
ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method());
wolfSSL_SetIORecv(ctx, wolfssl_recv_cb);
wolfSSL_SetIOSend(ctx, wolfssl_send_cb);</span></pre>
<p><span class="koboSpan" id="kobo.730.1">The two callbacks are implemented in the system to access socket communication in the TCP/IP stack, by using the system-specific TCP socket API. </span><span class="koboSpan" id="kobo.730.2">Suppose, for example, that a custom TCP implementation exports read and write functions as </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">tcp_socket_write</span></strong><span class="koboSpan" id="kobo.732.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">tcp_socket_read</span></strong><span class="koboSpan" id="kobo.734.1"> in a bare-metal context, and these functions return </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">0</span></strong><span class="koboSpan" id="kobo.736.1"> when no action is taken because the TCP/IP stack is busy or not ready to process the buffers. </span><span class="koboSpan" id="kobo.736.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">wolfssl_send_cb</span></strong><span class="koboSpan" id="kobo.738.1"> callback can be implemented to return the size of the processed data in case of success, or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">WOLFSSL_CBIO_ERR_WANT_WRITE</span></strong><span class="koboSpan" id="kobo.740.1"> special value, which indicate that the I/O operation could not be completed </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">without blocking:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.742.1">
int wolfssl_send_cb(WOLFSSL* ssl, char *buf, int sz, void *sk_ctx)
{
 tcp_ip_socket *sk = (tcp_ip_socket *)sk_ctx;
 int ret = tcp_socket_write(sk, buf, sz);
 if (ret &gt; 0)
   return ret;
 else
   return WOLFSSL_CBIO_ERR_WANT_WRITE;
}</span></pre>
<p><span class="koboSpan" id="kobo.743.1">And the </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.744.1">corresponding read callback will use the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">WOLFSSL_CBIO_ERR_WANT_READ</span></strong><span class="koboSpan" id="kobo.746.1"> special value to indicate that no data is available to process from </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">the stack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
int wolfssl_recv_cb(WOLFSSL *ssl, char *buf, int sz, void *sk_ctx)
{
  tcp_ip_socket *sk = (tcp_ip_socket *)sk_ctx;
  int ret = tcp_socket_read(sk, buf, sz);
  if (ret &gt; 0)
    return ret;
  else
    return WOLFSSL_CBIO_ERR_WANT_READ;
}</span></pre>
<p><span class="koboSpan" id="kobo.749.1">For most commonly used operating systems and TCP/IP stack APIs, wolfSSL already provides default I/O callbacks, so implementing custom callback functions is not required as long as you activate the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">configuration options.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">wolfSSL_CTX</span></strong><span class="koboSpan" id="kobo.753.1"> object, associated with SSL objects for every connection, must be equipped with a set of certificates and keys prior to initiating any communication. </span><span class="koboSpan" id="kobo.753.2">In a more </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.754.1">complex system, certificates and keys are stored in the filesystem and can be accessed when wolfSSL has been integrated to use file operations. </span><span class="koboSpan" id="kobo.754.2">In embedded systems where filesystems are often not supported, certificates and keys can be stored in memory instead, and loaded into the context using pointers to their locations </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">in memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
wolfSSL_CTX_use_certificate_buffer(ctx, certificate, len, SSL_FILETYPE_ASN1);
wolfSSL_CTX_use_PrivateKey_buffer(ctx, key, len,SSL_FILETYPE_ASN1 );</span></pre>
<p><span class="koboSpan" id="kobo.757.1">The socket context that is passed to the callbacks is set after the underlying TCP connection is established. </span><span class="koboSpan" id="kobo.757.2">For a server, this can be done contextually to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">accept</span></strong><span class="koboSpan" id="kobo.759.1"> function, while a client can associate the socket to the specific SSL context after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">connect</span></strong><span class="koboSpan" id="kobo.761.1"> function has returned successfully. </span><span class="koboSpan" id="kobo.761.2">Accepting an SSL connection on the server side requires the application to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">wolfSSL_accept</span></strong><span class="koboSpan" id="kobo.763.1"> so that the SSL handshake can be finalized before any actual data transfers. </span><span class="koboSpan" id="kobo.763.2">The SSL accept procedure should follow the socket </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">accept</span></strong><span class="koboSpan" id="kobo.765.1"> call, after the pointer to the TCP/IP socket object is associated as the context in the SSL object, and will be used as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">sk_ctx</span></strong><span class="koboSpan" id="kobo.767.1"> argument for the callbacks related to </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">this socket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.769.1">
tcp_ip_socket new_sk = accept(listen_sk, origin);
WOLFSSL ssl = wolfSSL_new(ctx);
if (new_sk) {
  wolfSSL_SetIOReadCtx(ssl, new_sk);
  wolfSSL_SetIOWriteCtx(ssl, new_sk);</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">wolfSSL_accept</span></strong><span class="koboSpan" id="kobo.771.1"> is called after setting the socket context, because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">accept</span></strong><span class="koboSpan" id="kobo.773.1"> mechanism may already need to call the underlying stack to progress through </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">its states:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
 int ret = wolfSSL_accept(ssl);</span></pre>
<p><span class="koboSpan" id="kobo.776.1">If the SSL handshake is successful, </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">wolfSSL_accept</span></strong><span class="koboSpan" id="kobo.778.1"> returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">WOLFSSL_SUCCESS</span></strong><span class="koboSpan" id="kobo.780.1"> special value, so the secure socket is now ready for communication through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">wolfSSL_read</span></strong><span class="koboSpan" id="kobo.782.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">wolfSSL_write</span></strong><span class="koboSpan" id="kobo.784.1"> functions. </span><span class="koboSpan" id="kobo.784.2">When running in a bare-metal application, </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">wolfSSL_read</span></strong><span class="koboSpan" id="kobo.786.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">wolfSSL_write</span></strong><span class="koboSpan" id="kobo.788.1"> must be used in non-blocking mode, by setting this flag at runtime on the SSL </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">session object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
  wolfSSL_set_using_nonblock(ssl, 1);</span></pre>
<p><span class="koboSpan" id="kobo.791.1">Using</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.792.1"> non-blocking I/O for wolfSSL functions ensures that the event-driven main loop model previously described for transport sockets can be kept because calling library functions never stalls the system. </span><span class="koboSpan" id="kobo.792.2">API functions in wolfSSL are designed to immediately return specific values (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">WANT_WRITE</span></strong><span class="koboSpan" id="kobo.794.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">WANT_READ</span></strong><span class="koboSpan" id="kobo.796.1">) to indicate that the operation is in progress, and the associated function (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">wolfSSL_accept</span></strong><span class="koboSpan" id="kobo.798.1"> in this case) should be called again later when new data from the underlying TCP socket </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">Once the communication between transport endpoints is secured, it is possible to exchange data using secure socket communications. </span><span class="koboSpan" id="kobo.800.2">What follows</span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.801.1"> is an overview of some of the most common application protocols used by </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">IoT systems.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.803.1">Application protocols</span></h1>
<p><span class="koboSpan" id="kobo.804.1">In order </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.805.1">to be able to communicate with remote devices and cloud servers in a distributed scenario, embedded systems must implement standard protocols that are compatible with the existing infrastructure. </span><span class="koboSpan" id="kobo.805.2">Two of the most common approaches taken when designing remote services are </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.807.1">Web-based services</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.808.1">Message protocols</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.809.1">The former is mainly the classic, client-server, </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.811.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.812.1">REST</span></strong><span class="koboSpan" id="kobo.813.1">)-based communication that is popular in web services accessed through personal computers</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.814.1"> or portable devices. </span><span class="koboSpan" id="kobo.814.2">Web services require no adaptation in particular on the cloud side to support embedded systems, except for the choice of an embedded-friendly cipher set, as described in the </span><em class="italic"><span class="koboSpan" id="kobo.815.1">Securing socket communication</span></em><span class="koboSpan" id="kobo.816.1"> section. </span><span class="koboSpan" id="kobo.816.2">However, the request-reply communication model introduces some restrictions on the design of distributed applications. </span><span class="koboSpan" id="kobo.816.3">The HTTP protocol can be upgraded by common agreement on the two HTTP endpoints, and support WebSocket, which is a protocol that provides the abstraction of a symmetric, bidirectional channel on top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">HTTP services.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">Message protocols </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.819.1">are a different approach that better reflects the functions of a sensor- or actuator-embedded system, where information is exchanged by using short binary messages, which can be relayed by intermediate agents and gathered or distributed from server nodes. </span><span class="koboSpan" id="kobo.819.2">Message protocols are the preferred choice when the network includes smaller nodes because of the simpler presentation of the data, as opposed to web services, which are mostly based on human-readable strings and add a much larger overhead to the transport size and memory footprint of the targets having to handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">ASCII strings.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">In both cases, TLS should be supported at the infrastructure- and device-level, for end-to-end encryption and reliable device identification. </span><span class="koboSpan" id="kobo.821.2">Plaintext authentication and pre-shared key encryption are obsolete techni</span><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.822.1">ques and thus should not be part of the security strategy of modern </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">distributed systems.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.824.1">Message protocols</span></h2>
<p><span class="koboSpan" id="kobo.825.1">Message-based</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.826.1"> communication protocols are not a novelty in computer networking software but have found a particularly good match with IoT-distributed systems, especially in scenarios where a one-to-many message-based model allows us to reach many devices at a time and establish bidirectional communication, or multiple devices from different locations can communicate with each other using an external server that acts as a communication broker. </span><span class="koboSpan" id="kobo.826.2">The lack of standardization in this area has led to several different models, each one with its own API and network </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">protocol definition.</span></span></p>
<p><span class="koboSpan" id="kobo.828.1">Some open standards in particular, however, have been designed to implement secure distributed messaging systems specifically tailored for a system with reduced resources and networks with limited bandwidth, by including specifications that are reasonably feasible to implement within a</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.829.1"> small code footprint. </span><span class="koboSpan" id="kobo.829.2">This is the case with the </span><strong class="bold"><span class="koboSpan" id="kobo.830.1">Message-Queuing Telemetry Transport</span></strong><span class="koboSpan" id="kobo.831.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.832.1">MQTT</span></strong><span class="koboSpan" id="kobo.833.1">) protocol. </span><span class="koboSpan" id="kobo.833.2">Thanks to its publisher-subscriber model and the possibility to interconnect embedded devices at different physical locations over TCP/IP, MQTT has become widely used and is supported by several </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">cloud architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">The protocol relies on TCP for establishing connections to a central broker, which dispatches messages from publishers to subscribers. </span><span class="koboSpan" id="kobo.835.2">Publishers push data for a certain topic, described by a URI, and subscribers can filter the topics they want to follow upon connection so that the broker selectively only forwards the messages matching </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">the filters.</span></span></p>
<p><span class="koboSpan" id="kobo.837.1">A</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.838.1"> few implementations for the client library exist for small, embedded devices too, although many of them lack support for security mechanisms. </span><span class="koboSpan" id="kobo.838.2">The protocol supports a plaintext password-authentication mechanism, which is not a valid security measure, and should never be used on top of clear TCP/IP communication because passwords can easily be intercepted along </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">the path.</span></span></p>
<p><span class="koboSpan" id="kobo.840.1">According to the standard, instead of the socket-based TCP communication through IANA-registered TCP port </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">1883</span></strong><span class="koboSpan" id="kobo.842.1">, it is possible to establish an SSL session, which uses TCP port </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">8883</span></strong><span class="koboSpan" id="kobo.844.1"> instead. </span><span class="koboSpan" id="kobo.844.2">A secure implementation that uses SSL sessions on top of TCP is provided by wolfSSL, in a separate GPL library</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.845.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.846.1">wolfMQTT</span></strong><span class="koboSpan" id="kobo.847.1">. </span><span class="koboSpan" id="kobo.847.2">This library offers secure MQTT socket connections by default. </span><span class="koboSpan" id="kobo.847.3">It is capable of implementing both client and server authentication through certifi</span><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.848.1">cates and public keys and provides symmetric-key encryption through the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">established session.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.850.1">The REST architectural pattern</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.851.1">REST</span></strong><span class="koboSpan" id="kobo.852.1"> was a</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.853.1"> term introduced by Roy Fielding to </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.854.1">describe the pattern used by web services to communicate with remote systems using a stateless protocol. </span><span class="koboSpan" id="kobo.854.2">In a REST-compliant system, resources are accessed in the form of HTTP requests targeting a specific URI, using the same protocol stack as web pages obtained through a request from a remote browser. </span><span class="koboSpan" id="kobo.854.3">In fact, REST requests are extended HTTP requests, representing all data as encoded strings, transported through TCP in a readable </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">HTTP stream.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">Adopting this </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.857.1">pattern provides a number of architectural benefits on the server side, and allows us to build distributed systems with very high scalability. </span><span class="koboSpan" id="kobo.857.2">Although not very efficient and definitely not designed with embedded systems resources in mind, embedded systems can inte</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.858.1">ract with remote web services exposed by a RESTful system by implementing a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">REST client.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.860.1">Distributed systems – single points of failure</span></h2>
<p><span class="koboSpan" id="kobo.861.1">Designing </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.862.1">distributed systems also means taking into account link defects, unreachable gateways, and other failures. </span><span class="koboSpan" id="kobo.862.2">Embedded devices should not stop working when disconnected from the internet, but rather offer fallback mechanisms based on local gateways. </span><span class="koboSpan" id="kobo.862.3">Consider, for example, a demotic IoT system for controlling all the heating and cooling units in a house, accessible from portable devices and coordinated remotely using any network access. </span><span class="koboSpan" id="kobo.862.4">Temperature sensors, heaters, and coolers are controlled using a mesh network of embedded devices while the central control is on remote cloud servers. </span><span class="koboSpan" id="kobo.862.5">The system can control the actuators remotely based on user settings and sensor readings. </span><span class="koboSpan" id="kobo.862.6">This gives us the possibility to access the service even from a remote location, allowing the user to tune the system to set the desired temperature in each room, based on the commands sent from user interfaces, which are processed and relayed by the cloud to reach their destination in the embedded devices. </span><span class="koboSpan" id="kobo.862.7">As long as all the components are connected to the internet, the IoT system works </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.864.1">Nevertheless, in the case of connection failure, users will not be able to control the system or activate any function. </span><span class="koboSpan" id="kobo.864.2">Terminating the application service on a local device within the local area network ensures the continuity of the services across failures of the link to the internet and any issues that would prevent the local network from accessing the remote cloud device. </span><span class="koboSpan" id="kobo.864.3">If this kind of mechanism is in place, a system disconnected from the internet would still provide a failover alternative to access sensors and actuators, assuming that all the actors at play are connected to a common LAN. </span><span class="koboSpan" id="kobo.864.4">Moreover, having a local system processing and relaying settings and commands reduces the latency of the actions requested because requests do not have to travel across the internet to be processed and forwarded back to the same network. </span><span class="koboSpan" id="kobo.864.5">Designing reliable IoT networks must include a careful assessment of the single points of failure among all the links and devices used to provide services, and this must include the backbone link used to reach services, messa</span><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.865.1">ge brokers, and remote devices that can cause malfunctions or other issues on the </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">entire system.</span></span></p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.867.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.868.1">This chapter has given us an overview of the design of machine-to-machine distributed systems and IoT services, including connected embedded devices, with a focus on security elements that are too often overlooked or underestimated in embedded development. </span><span class="koboSpan" id="kobo.868.2">The technology proposed allows full, professional-grade, secure, and fast TCP/IP connectivity on very small targets and uses state-of-the-art technology, such as the most recent version of the TLS cipher suites. </span><span class="koboSpan" id="kobo.868.3">Several approaches have been considered, both in terms of hardware and software technologies available for microcontroller-based targets, for a broader view of the technologies, protocols, and security algorithms available for building distributed </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.870.1">The next chapter will illustrate the multitasking possibilities of modern embedded microcontrollers by explaining how to write a small scheduler for Cortex-M microprocessors from scratch, and will summarize the key roles of a real-time operating system running on an </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">embedded target.</span></span></p>
</div>


<div class="Content" id="_idContainer056">
<h1 id="_idParaDest-219"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.1.1">Part 4 – </span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2.1">Multithreading</span></span></h1>
<p><span class="koboSpan" id="kobo.3.1">This part introduces parallel multithreaded applications through the development of a scheduler and an explanation of context change in an ARM CPU. </span><span class="koboSpan" id="kobo.3.2">In the last chapter, the TEE approach is explained, with examples of a system secured </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">with TrustZone-M.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following chapters:</span></span></p>
<ul>
<li><a href="B18730_10.xhtml#_idTextAnchor357"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Parallel Tasks and Scheduling</span></em></li>
<li><a href="B18730_11.xhtml#_idTextAnchor403"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Trusted Execution Environment</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer057">
</div>
</div>
</body></html>