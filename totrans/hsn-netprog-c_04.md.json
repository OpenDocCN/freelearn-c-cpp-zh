["```cpp\ngit clone https://github.com/codeplea/Hands-On-Network-Programming-with-C\ncd Hands-On-Network-Programming-with-C/chap03\n```", "```cpp\n/*chap03.h*/\n\n#if defined(_WIN32)\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0600\n#endif\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"ws2_32.lib\")\n\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <errno.h>\n\n#endif\n\n#if defined(_WIN32)\n#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET)\n#define CLOSESOCKET(s) closesocket(s)\n#define GETSOCKETERRNO() (WSAGetLastError())\n\n#else\n#define ISVALIDSOCKET(s) ((s) >= 0)\n#define CLOSESOCKET(s) close(s)\n#define SOCKET int\n#define GETSOCKETERRNO() (errno)\n#endif\n\n#include <stdio.h>\n#include <string.h>\n```", "```cpp\nwhile(1) {\n    socket_client = accept(socket_listen, &new_client, &new_client_length);\n    int pid = fork();\n    if (pid == 0) { //child process\n        close(socket_listen);\n        recv(socket_client, ...);\n        send(socket_client, ...);\n        close(socket_client);\n        exit(0);\n    }\n    //parent process\n    close(socket_client);\n}\n```", "```cpp\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n    fd_set *exceptfds, struct timeval *timeout);\n```", "```cpp\nfd_set our_sockets;\nFD_ZERO(&our_sockets);\nFD_SET(socket_listen, &our_sockets);\nFD_SET(socket_a, &our_sockets);\nFD_SET(socket_b, &our_sockets);\n```", "```cpp\nSOCKET max_socket;\nmax_socket = socket_listen;\nif (socket_a > max_socket) max_socket = socket_a;\nif (socket_b > max_socket) max_socket = socket_b;\n```", "```cpp\nfd_set copy;\ncopy = our_sockets;\n\nselect(max_socket+1, &copy, 0, 0, 0);\n```", "```cpp\nif (FD_ISSET(socket_listen, &copy)) {\n    //socket_listen has a new connection\n    accept(socket_listen...\n}\n\nif (FD_ISSET(socket_a, &copy)) {\n    //socket_a is ready to be read from\n    recv(socket_a...\n}\n\nif (FD_ISSET(socket_b, &copy)) {\n    //socket_b is ready to be read from\n    recv(socket_b...\n}\n```", "```cpp\nstruct timeval {\n    long tv_sec;\n    long tv_usec;\n}\n```", "```cpp\nstruct timeval timeout;\ntimeout.tv_sec = 1;\ntimeout.tv_usec = 500000;\nselect(max_socket+1, &copy, 0, 0, &timeout);\n```", "```cpp\nselect(max_sockets+1, &ready_to_read, &ready_to_write, &excepted, &timeout);\n```", "```cpp\nSOCKET i;\nfor (i = 1; i <= max_socket; ++i) {\n    if (FD_ISSSET(i, &master)) {\n        CLOSESOCKET(i);\n    }\n}\n```", "```cpp\n/*tcp_client.c*/\n\n#include \"chap03.h\"\n```", "```cpp\n/*tcp_client.c*/\n\n#if defined(_WIN32)\n#include <conio.h>\n#endif\n```", "```cpp\n/*tcp_client.c*/\n\nint main(int argc, char *argv[]) {\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*tcp_client.c*/\n\n    if (argc < 3) {\n        fprintf(stderr, \"usage: tcp_client hostname port\\n\");\n        return 1;\n    }\n```", "```cpp\n/*tcp_client.c*/\n\n    printf(\"Configuring remote address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    struct addrinfo *peer_address;\n    if (getaddrinfo(argv[1], argv[2], &hints, &peer_address)) {\n        fprintf(stderr, \"getaddrinfo() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*tcp_client.c*/\n\n    printf(\"Remote address is: \");\n    char address_buffer[100];\n    char service_buffer[100];\n    getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen,\n            address_buffer, sizeof(address_buffer),\n            service_buffer, sizeof(service_buffer),\n            NI_NUMERICHOST);\n    printf(\"%s %s\\n\", address_buffer, service_buffer);\n```", "```cpp\n/*tcp_client.c*/\n\n    printf(\"Creating socket...\\n\");\n    SOCKET socket_peer;\n    socket_peer = socket(peer_address->ai_family,\n            peer_address->ai_socktype, peer_address->ai_protocol);\n    if (!ISVALIDSOCKET(socket_peer)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*tcp_client.c */\n\n    printf(\"Connecting...\\n\");\n    if (connect(socket_peer,\n                peer_address->ai_addr, peer_address->ai_addrlen)) {\n        fprintf(stderr, \"connect() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n    freeaddrinfo(peer_address);\n```", "```cpp\n/*tcp_client.c */\n\n    printf(\"Connected.\\n\");\n    printf(\"To send data, enter text followed by enter.\\n\");\n```", "```cpp\n/*tcp_client.c */\n\n    while(1) {\n\n        fd_set reads;\n        FD_ZERO(&reads);\n        FD_SET(socket_peer, &reads);\n#if !defined(_WIN32)\n        FD_SET(0, &reads);\n#endif\n\n        struct timeval timeout;\n        timeout.tv_sec = 0;\n        timeout.tv_usec = 100000;\n\n        if (select(socket_peer+1, &reads, 0, 0, &timeout) < 0) {\n            fprintf(stderr, \"select() failed. (%d)\\n\", GETSOCKETERRNO());\n            return 1;\n        }\n```", "```cpp\n/*tcp_client.c*/\n\n        if (FD_ISSET(socket_peer, &reads)) {\n            char read[4096];\n            int bytes_received = recv(socket_peer, read, 4096, 0);\n            if (bytes_received < 1) {\n                printf(\"Connection closed by peer.\\n\");\n                break;\n            }\n            printf(\"Received (%d bytes): %.*s\",\n                    bytes_received, bytes_received, read);\n        }\n```", "```cpp\n/*tcp_client.c */\n\n#if defined(_WIN32)\n        if(_kbhit()) {\n#else\n        if(FD_ISSET(0, &reads)) {\n#endif\n            char read[4096];\n            if (!fgets(read, 4096, stdin)) break;\n            printf(\"Sending: %s\", read);\n            int bytes_sent = send(socket_peer, read, strlen(read), 0);\n            printf(\"Sent %d bytes.\\n\", bytes_sent);\n        }\n```", "```cpp\n/*tcp_client.c */\n\n    }\n\n    printf(\"Closing socket...\\n\");\n    CLOSESOCKET(socket_peer);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    printf(\"Finished.\\n\");\n    return 0;\n}\n```", "```cpp\ngcc tcp_client.c -o tcp_client\n```", "```cpp\ngcc tcp_client.c -o tcp_client.exe -lws2_32\n```", "```cpp\ntcp_client example.com 80\n```", "```cpp\ntcp_client 127.0.0.1 8080\n```", "```cpp\nGET / HTTP/1.1\nHost: example.com\n```", "```cpp\n/*tcp_serve_toupper.c*/\n\n#include \"chap03.h\"\n#include <ctype.h>\n\nint main() {\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n    printf(\"Configuring local address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n\n    struct addrinfo *bind_address;\n    getaddrinfo(0, \"8080\", &hints, &bind_address);\n\n    printf(\"Creating socket...\\n\");\n    SOCKET socket_listen;\n    socket_listen = socket(bind_address->ai_family,\n            bind_address->ai_socktype, bind_address->ai_protocol);\n    if (!ISVALIDSOCKET(socket_listen)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*tcp_serve_toupper.c*/\n\n    printf(\"Binding socket to local address...\\n\");\n    if (bind(socket_listen,\n                bind_address->ai_addr, bind_address->ai_addrlen)) {\n        fprintf(stderr, \"bind() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n    freeaddrinfo(bind_address);\n\n    printf(\"Listening...\\n\");\n    if (listen(socket_listen, 10) < 0) {\n        fprintf(stderr, \"listen() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n    fd_set master;\n    FD_ZERO(&master);\n    FD_SET(socket_listen, &master);\n    SOCKET max_socket = socket_listen;\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n    printf(\"Waiting for connections...\\n\");\n\n    while(1) {\n        fd_set reads;\n        reads = master;\n        if (select(max_socket+1, &reads, 0, 0, 0) < 0) {\n            fprintf(stderr, \"select() failed. (%d)\\n\", GETSOCKETERRNO());\n            return 1;\n        }\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n        SOCKET i;\n        for(i = 1; i <= max_socket; ++i) {\n            if (FD_ISSET(i, &reads)) {\n                //Handle socket\n            }\n        }\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n                if (i == socket_listen) {\n                    struct sockaddr_storage client_address;\n                    socklen_t client_len = sizeof(client_address);\n                    SOCKET socket_client = accept(socket_listen,\n                            (struct sockaddr*) &client_address,\n                            &client_len);\n                    if (!ISVALIDSOCKET(socket_client)) {\n                        fprintf(stderr, \"accept() failed. (%d)\\n\",\n                                GETSOCKETERRNO());\n                        return 1;\n                    }\n\n                    FD_SET(socket_client, &master);\n                    if (socket_client > max_socket)\n                        max_socket = socket_client;\n\n                    char address_buffer[100];\n                    getnameinfo((struct sockaddr*)&client_address,\n                            client_len,\n                            address_buffer, sizeof(address_buffer), 0, 0,\n                            NI_NUMERICHOST);\n                    printf(\"New connection from %s\\n\", address_buffer);\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n                } else {\n                    char read[1024];\n                    int bytes_received = recv(i, read, 1024, 0);\n                    if (bytes_received < 1) {\n                        FD_CLR(i, &master);\n                        CLOSESOCKET(i);\n                        continue;\n                    }\n\n                    int j;\n                    for (j = 0; j < bytes_received; ++j)\n                        read[j] = toupper(read[j]);\n                    send(i, read, bytes_received, 0);\n                }\n```", "```cpp\n/*tcp_serve_toupper.c */\n\n            } //if FD_ISSET\n        } //for i to max_socket\n    } //while(1)\n\n    printf(\"Closing listening socket...\\n\");\n    CLOSESOCKET(socket_listen);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    printf(\"Finished.\\n\");\n    return 0;\n}\n```", "```cpp\ngcc tcp_serve_toupper.c -o tcp_serve_toupper\n./tcp_serve_toupper\n```", "```cpp\ngcc tcp_serve_toupper.c -o tcp_serve_toupper.exe -lws2_32\ntcp_serve_toupper.exe\n```", "```cpp\ntcp_client 127.0.0.1 8080\n```", "```cpp\n/*tcp_serve_toupper.c excerpt*/\n\n                    int j;\n                    for (j = 0; j < bytes_received; ++j)\n                        read[j] = toupper(read[j]);\n                    send(i, read, bytes_received, 0);\n```", "```cpp\n/*tcp_serve_chat.c excerpt*/\n\n                    SOCKET j;\n                    for (j = 1; j <= max_socket; ++j) {\n                        if (FD_ISSET(j, &master)) {\n                            if (j == socket_listen || j == i)\n                                continue;\n                            else\n                                send(j, read, bytes_received, 0);\n                        }\n                    }\n```", "```cpp\ngcc tcp_serve_chat.c -o tcp_serve_chat\n./tcp_serve_chat\n```", "```cpp\ngcc tcp_serve_chat.c -o tcp_serve_chat.exe -lws2_32\ntcp_serve_chat.exe\n```", "```cpp\ntcp_client 127.0.0.1 8080\n```", "```cpp\nint begin = 0;\nwhile (begin < buffer_len) {\n    int sent = send(peer_socket, buffer + begin, buffer_len - begin, 0);\n    if (sent == -1) {\n        //Handle error\n    }\n    begin += sent;\n}\n```", "```cpp\nrecv(socket_peer, buffer, 4096, 0);\nprintf(buffer);\n```", "```cpp\nrecv(socket_peer, buffer, 4096, 0);\nprintf(\"%s\", buffer);\n```"]