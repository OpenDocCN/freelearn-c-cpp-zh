["```cpp\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); \nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); \nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); \nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); \n\nGLFWwindow *window = glfwCreateWindow(800, 600, \"Title\", nullptr, nullptr);\n```", "```cpp\nglad --generator=c --out-path=GL --profile=core --api=gl=4.6\n```", "```cpp\nif(!gladLoadGL()) {\n  std::cerr << \"Unable to load OpenGL functions!\" << std::endl;\n  exit(EXIT_FAILURE);\n}\n```", "```cpp\n#include <glm/glm.hpp> \n#include <glm/gtc/matrix_transform.hpp> \n```", "```cpp\nglm::vec4 position = glm::vec4( 1.0f, 0.0f, 0.0f, 1.0f ); \nglm::mat4 view = glm::lookAt( \n        glm::vec3(0.0f, 0.0f, 5.0f),\n        glm::vec3(0.0f, 0.0f, 0.0f),\n        glm::vec3(0.0f, 1.0f, 0.0f) \n   ); \nglm::mat4 model(1.0f);   // The identity matrix \nmodel = glm::rotate( model, 90.0f, glm::vec3(0.0f,1.0f,0.0) ); \nglm::mat4 mv = view * model; \nglm::vec4 transformed = mv * position; \n```", "```cpp\nusing namespace glm; \n```", "```cpp\n#include <glm/glm.hpp> \nusing glm::vec3; \nusing glm::mat4; \n```", "```cpp\nglm::mat4 proj = glm::perspective( viewAngle, aspect, nearDist, farDist ); \nglUniformMatrix4fv(location, 1, GL_FALSE, &proj[0][0]); \n```", "```cpp\nglUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(proj));\n```", "```cpp\nconst GLubyte *renderer = glGetString( GL_RENDERER ); \nconst GLubyte *vendor = glGetString( GL_VENDOR ); \nconst GLubyte *version = glGetString( GL_VERSION ); \nconst GLubyte *glslVersion = \n       glGetString( GL_SHADING_LANGUAGE_VERSION ); \n\nGLint major, minor; \nglGetIntegerv(GL_MAJOR_VERSION, &major); \nglGetIntegerv(GL_MINOR_VERSION, &minor); \n\nprintf(\"GL Vendor            : %s\\n\", vendor); \nprintf(\"GL Renderer          : %s\\n\", renderer); \nprintf(\"GL Version (string)  : %s\\n\", version); \nprintf(\"GL Version (integer) : %d.%d\\n\", major, minor); \nprintf(\"GLSL Version         : %s\\n\", glslVersion);\n```", "```cpp\nGLint nExtensions; \nglGetIntegerv(GL_NUM_EXTENSIONS, &nExtensions); \n\nfor( int i = 0; i < nExtensions; i++ ) \n      printf(\"%s\\n\", glGetStringi( GL_EXTENSIONS, i ) );\n```", "```cpp\n#version 460\nin vec3 VertexPosition; \nin vec3 VertexColor; \n\nout vec3 Color; \n\nvoid main() \n{ \n   Color = VertexColor; \n   gl_Position = vec4( VertexPosition, 1.0 ); \n}\n```", "```cpp\nGLuint vertShader = glCreateShader( GL_VERTEX_SHADER ); \nif( 0 == vertShader ) { \n  std::cerr << \"Error creating vertex shader.\" << std::endl;\n  exit(EXIT_FAILURE); \n} \n```", "```cpp\nstd::string shaderCode = loadShaderAsString(\"basic.vert.glsl\"); \nconst GLchar * codeArray[] = { shaderCode.c_str() }; \nglShaderSource( vertShader, 1, codeArray, NULL ); \n```", "```cpp\nglCompileShader( vertShader );\n```", "```cpp\nGLint result; \nglGetShaderiv( vertShader, GL_COMPILE_STATUS, &result ); \nif( GL_FALSE == result ) { \n  std::cerr << \"Vertex shader compilation failed!\" << std::endl;\n\n  // Get and print the info log\n  GLint logLen; \n  glGetShaderiv(vertShader, GL_INFO_LOG_LENGTH, &logLen); \n  if( logLen > 0 ) { \n    std::string log(logLen, ' '); \n    GLsizei written; \n    glGetShaderInfoLog(vertShader, logLen, &written, &log[0]); \n    std::cerr << \"Shader log: \" << std::endl << log;\n  } \n} \n```", "```cpp\n#version 460 \n\nin vec3 Color; \nout vec4 FragColor; \n\nvoid main() { \n  FragColor = vec4(Color, 1.0); \n} \n```", "```cpp\nGLuint programHandle = glCreateProgram(); \nif( 0 == programHandle ) \n{ \n  std::cerr << \"Error creating program object.\" << std::endl; \n  exit(EXIT_FAILURE); \n} \n```", "```cpp\nglAttachShader( programHandle, vertShader ); \nglAttachShader( programHandle, fragShader ); \n```", "```cpp\nglLinkProgram( programHandle );\n```", "```cpp\nGLint status; \nglGetProgramiv( programHandle, GL_LINK_STATUS, &status ); \nif( GL_FALSE == status ) {\n  std::cerr << \"Failed to link shader program!\" << std::endl;\n  GLint logLen; \n  glGetProgramiv(programHandle, GL_INFO_LOG_LENGTH, &logLen); \n  if( logLen > 0 ) { \n    std::string(logLen, ' ');\n    GLsizei written;\n    glGetProgramInfoLog(programHandle, logLen, &written, &log[0]); \n    std::cerr << \"Program log: \" << std::endl << log;\n  } \n} \n```", "```cpp\nelse\n  glUseProgram( programHandle );\n```", "```cpp\n// Detach and delete shader objects\nglDetachShader(programHandle, vertShader);\nglDetachShader(programHandle, fragShader);\nglDeleteShader(vertShader);\nglDeleteShader(fragShader);\n```", "```cpp\nlayout (location=0) out vec4 VertColor;\nlayout (location=1) out vec3 VertNormal;\n```", "```cpp\nlayout (location=0) in vec3 Color;\nlayout (location=1) in vec3 Normal;\n```", "```cpp\nGLint formats = 0;\nglGetIntegerv(GL_NUM_PROGRAM_BINARY_FORMATS, &formats);\nif( formats < 1 ) {\n  std::cerr << \"Driver does not support any binary formats.\" << std::endl;\n  exit(EXIT_FAILURE);\n}\n\n```", "```cpp\n// Get the binary length\nGLint length = 0;\nglGetProgramiv(program, GL_PROGRAM_BINARY_LENGTH, &length);\n\n// Retrieve the binary code\nstd::vector<GLubyte> buffer(length);\nGLenum format = 0;\nglGetProgramBinary(program, length, NULL, &format, buffer.data());\n\n// Write the binary to a file.\nstd::string fName(\"shader.bin\");\nstd::cout << \"Writing to \" << fName << \", binary format = \" << format << std::endl;\nstd::ofstream out(fName.c_str(), std::ios::binary);\nout.write( reinterpret_cast<char *>(buffer.data()), length );\nout.close();\n```", "```cpp\nGLuint program = glCreateProgram();\n\n// Load binary from file\nstd::ifstream inputStream(\"shader.bin\", std::ios::binary);\nstd::istreambuf_iterator<char> startIt(inputStream), endIt;\nstd::vector<char> buffer(startIt, endIt);  // Load file\ninputStream.close();\n\n// Install shader binary\nglProgramBinary(program, format, buffer.data(), buffer.size() );\n\n// Check for success/failure\nGLint status;\nglGetprogramiv(program, GL_LINK_STATUS, &status);\nif( GL_FALSE == status ) {\n  // Handle failure ...\n}\n```", "```cpp\nglslangValidator -G -o basic.vert.spv basic.vert.glsl\nglslangValidator -G -o basic.frag.spv basic.frag.glsl\n```", "```cpp\nGLuint vertShader = glCreateShader(GL_VERTEX_SHADER);\n\n// Load the shader into a std::vector\nstd::ifstream inStream(\"basic.vert.spv\", std::ios::binary);\nstd::istreambuf_iterator<char> startIt(inStream), endIt;\nstd::vector<char> buffer(startIt, endIt);\ninStream.close();\n\n// Load using glShaderBinary\nglShaderBinary(1, &vertShader, GL_SHADER_BINARY_FORMAT_SPIR_V, buffer.data(), buffer.size());\n\n// Specialize the shader (specify the entry point)\nglSpecializeShader( vertShader, \"main\", 0, 0, 0);\n\n// Check for success/failure\nGLint status;\nglGetShaderiv(vertShader, GL_COMPILE_STATUS, &status);\nif( GL_FALSE == status ) {\n  // Loading failed...\n}\n```"]