<html><head></head><body>
		<div><h1 id="_idParaDest-38"><em class="italic"><a id="_idTextAnchor037"/>Chapter 3</em>: Testing with LLVM LIT</h1>
			<p>In the previous chapter, we learned how to take advantage of LLVM's own CMake utilities to improve our development experience. We also learned how to seamlessly integrate LLVM into other out-of-tree projects. In this chapter, we're going to talk about how to get hands-on with LLVM's own testing infrastructure, LIT.</p>
			<p><strong class="bold">LIT</strong> is a testing infrastructure that was originally developed for running LLVM's regression tests. Now, it's not only the harness for running all the tests in LLVM (both <strong class="bold">unit </strong>and <strong class="bold">regression tests)</strong> but also a generic testing framework that can be used outside of LLVM. It also provides a wide range of testing formats to tackle different scenarios. This chapter will give you a thorough tour of the components in this framework and help you master LIT.</p>
			<p>We are going to cover the following topics in this chapter:</p>
			<ul>
				<li>Using LIT in out-of-tree projects</li>
				<li>Learning about advanced FileCheck tricks</li>
				<li>Exploring the TestSuite framework</li>
			</ul>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>The core of LIT is written in <em class="italic">Python</em>, so please make sure you have Python 2.7 or Python 3.x installed (Python 3.x is preferable, as LLVM is gradually retiring Python 2.7 now).</p>
			<p>In addition, there are a bunch of supporting utilities, such as <code>FileCheck</code>, which will be used later. To build those utilities, the fastest way, unfortunately, is to build any of the <code>check-XXX</code> (phony) targets. For example, we could build <code>check-llvm-support</code>, as shown in the following code:</p>
			<pre>$ ninja check-llvm-support</pre>
			<p>Finally, the last section requires that <code>llvm-test-suite</code> has been built, which is a separate repository from <code>llvm-project</code>. We can clone it by using the following command:</p>
			<pre>$ git clone https://github.com/llvm/llvm-test-suite</pre>
			<p>The easiest way to configure the build will be using one of the cached CMake configs. For example, to build the test suite with optimizations (<code>O3</code>), we will use the following code:</p>
			<pre>$ mkdir .O3_build
$ cd .O3_build
$ cmake -G Ninja -DCMAKE_C_COMPILER=&lt;desired Clang binary \ path&gt; -C ../cmake/caches/O3.cmake ../</pre>
			<p>Then, we can build it normally using the following command:</p>
			<pre>$ ninja all</pre>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Using LIT in out-of-tree projects</h1>
			<p>Writing an<a id="_idIndexMarker060"/> in-tree LLVM IR regression test is pretty easy: all <a id="_idIndexMarker061"/>you need to do is annotate the IR file with testing directives. Look at the following script, for example:</p>
			<pre><strong class="bold">; RUN: opt &lt; %s<a id="_idTextAnchor040"/> -instcombine -S -o - | FileCheck %s</strong>
target triple = "x86_64-unknown-linux"
define i32 @foo(i32 %c) {
entry:
<strong class="bold">  ; CHECK: [[RET:%.+]] = add nsw i32 %c, 3</strong>
<strong class="bold">  ; CHECK: ret i32 [[RET]]</strong>
  %add1 = add nsw i32 %c, 1
  %add2 = add nsw i32 %add1, 2
  ret i32 %add2
}</pre>
			<p>This script checks if <code>InstCombine</code> (triggered by the <code>-instcombine</code> command-line option shown in the preceding snippet) simplifies two succeeding arithmetic adds into one. After putting this file into an arbitrary folder under <code>llvm/test</code>, the script will automatically be picked and run as part of the regression test when you're executing the <code>llvm-lit</code> command-line tool.</p>
			<p>Despite its convenience, this barely helps you use LIT in out-of-tree projects. Using LIT out-of-tree is especially useful when your project needs some end-to-end testing facilities, such as a format converter, a text processor, a linter, and, of course, a compiler. This section will <a id="_idIndexMarker062"/>show you how to bring LIT to your out-of-tree projects, and then provide you with a <a id="_idIndexMarker063"/>complete picture of the running flow of LIT.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Preparing for our example project </h2>
			<p>In this section, we <a id="_idIndexMarker064"/>will use an out-of-tree CMake project. This example project builds a command-line tool, <code>js-minifier</code>, that <em class="italic">minifies</em> arbitrary JavaScript code. We will transform the following JavaScript code:</p>
			<pre>const foo = (a, b) =&gt; {
  let c = a + b;
  console.log(`This is ${c}`); 
}</pre>
			<p>This will be transformed into some other <em class="italic">semantic-equivalent</em> code that is as short as possible:</p>
			<pre>const foo = (a,b) =&gt; {let c = a + b; console.log(`This is ${c}`);}</pre>
			<p>Instead of teaching you how to write this <code>js-minifier</code>, the goal of this section is to show you how to create a LIT testing environment to <em class="italic">test</em> this tool.</p>
			<p>The example project has the following folder structure:</p>
			<pre>/JSMinifier
  |__ CMakeLists.txt
  |__ /src
      |__ js-minifier.cpp
  |__ /test
      |__ <strong class="bold">test.js</strong>
      |__ CMakeLists.txt
  |__ /build</pre>
			<p>The files under the <code>/src</code> folder contain the source code for <code>js-minifier</code> (which we are not going to cover here). What we will focus on here are the files that will be used for testing <code>js-minifier</code>, which sit under the <code>/test</code> folder (for now, there is only one file, <code>test.js</code>).</p>
			<p>In this section, we are going to set up a testing environment so that when we run <code>llvm-lit</code> – the testing driver and main character of this section – under the CMake <code>/build</code> folder, it will print<a id="_idIndexMarker065"/> testing results, like this:</p>
			<pre>$ cd build
$ llvm-lit -sv .
-- Testing: 1 tests, 1 workers –
PASS: JSMinifier Test :: test.js (1 of 1)
Testing Time: 0.03s
  Expected Passes    : 1</pre>
			<p>This shows how many and what test cases have passed.</p>
			<p>Here is the testing script, <code>test.js</code>:</p>
			<pre>// <strong class="bold">RUN: %jsm %s -o - | FileCheck</strong>
// <strong class="bold">CHECK</strong>: const foo = (a,b) =&gt;
// <strong class="bold">CHECK-SAME</strong>: {let c = a + b; console.log(`This is ${c}`);}
const foo = (a, b) =&gt; {
  let c = a + b;
  console.log(`This is ${c}`); 
}</pre>
			<p>As you can see, it is a simple testing process that runs the <code>js-minifier</code> tool – represented by the <code>%jsm</code> directive, which will be replaced by the real path to <code>js-minifier</code> executable, as explained later – and checks the running result with <code>FileCheck</code> by using its <code>CHECK</code> and <code>CHECK-SAME</code> directives.</p>
			<p>With that, we've set up our example project. Before we wrap up the preparation, there is one final tool we need to create.</p>
			<p>Since we're trying to cut down on our reliance on the LLVM source tree, recreate the <code>llvm-lit</code> command-line<a id="_idIndexMarker066"/> tool using the <code>LIT</code> package available in the <em class="italic">PyPi repository</em> (that is, the <code>pip</code> command-line tool). All you need to do is install that package:</p>
			<pre>$ pip install --user lit</pre>
			<p>Finally, wrap the package with the following script:</p>
			<pre>#!/usr/bin/env python
from lit.main import main
if __name__ == '__main__':
    main()</pre>
			<p>Now, we can use LIT without building an LLVM tree! Next, we will create some LIT configuration scripts that will drive the whole testing flow.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>Writing LIT configurations</h2>
			<p>In this subsection, we'll show you how to write LIT<a id="_idIndexMarker067"/> configuration scripts. These scripts describe the testing process – where the files will be tested, the testing environment (if we need to import any tool, for example), the policy when there is a failure, and so on. Learning these skills can greatly improve how you use LIT in places outside the LLVM tree. Let's get started:</p>
			<ol>
				<li>Inside the <code>/JSMinifier/test</code> folder, create a file called <code>lit.cfg.py</code> that contains the following content:<pre>import lit.formats
config.name = 'JSMinifier Test'
config.test_format = <code>config</code> variable here is a Python object that will be populated later when this script is loaded into LIT's runtime. It's basically a registry with predefined fields that carry configuration values, along with custom fields that can be added by <code>lit.*.py</code> scripts at any time.</p><p>The <code>config.test_format</code> field suggests that LIT will run every test inside a shell environment (in <a id="_idIndexMarker068"/>the <code>ShTest</code> format), while the <code>config.suffixes</code> field suggests that only files with <code>.js</code> in their filename suffix will be treated as test cases (that is, all the JavaScript files).</p></li>
				<li>Following on from the code snippet in the previous step, LIT now needs two other pieces of information: the <em class="italic">root path</em> to the test files and the <em class="italic">working directory</em>:<pre>…
config.suffixes = ['.js']
config.test_source_root = os.path.dirname(__file__)
config.test_exec_root = os.path.join(<code>config.test_source_root</code>, it's simply pointing to <code>/JSMinifier/test</code>. On the other hand, <code>config.test_exec_root</code>, which is the working directory, is pointing to a place whose parent folder is the value of a custom configuration field, <code>my_obj_root</code>. While it will be introduced later, simply put, it points to the <code>build</code> folder path. In other words, <code>config.test_exec_root</code> will eventually have a value of <code>/JSMinifier/build/test</code>.</p></li>
				<li>The <code>%jsm</code> directive we saw earlier in <code>test.js</code> is used as a placeholder that will eventually be replaced with the real/absolute path of the <code>js-minifier</code> executable. The following lines will set up the replacements:<pre>…
config.test_exec_root = os.path.join(config.my_obj_root, 'test')
config.<code>config.substitutions</code> field, which makes LIT replace every <code>%jsm</code> occurrence in the test files with the <code>/JSMinifier/build/js-minifier</code> value. This wraps up all the content in <code>lit.cfg.py</code>.</p></li>
				<li>Now, create a new file called <code>lit.site.cfg.py.in</code> and put it under the <code>/JSMinifier/test</code> folder. The first part of this file looks like this:<pre>import os
config.my_src_root = r'@CMAKE_SOURCE_DIR@'
config.my_obj_root = r'@CMAKE_BINARY_DIR@'</pre><p>The mystery <code>config.my_obj_root</code> field is finally resolved here, but instead of pointing to a normal string, it is assigned to a weird value called <code>@CMAKE_BINARY_DIR@</code>. Again, this will be replaced by CMake with the real path later. The same goes for the <code>config.my_src_root</code> field.</p></li>
				<li>Finally, <code>lit.site.cfg.py.in</code> is wrapped up by these lines:<pre>…
lit_config.<code>@</code> being resolved and copied into the <code>build</code> folder. From there, it will <em class="italic">call back</em> the <code>lit.cfg.py</code> script we saw in the earlier steps. This will be explained later in this section.</p></li>
				<li>Finally, it's time to replace those weird @-clamped strings with real values using CMake's <code>configure_file</code> function. In <code>/JSMinifier/test/CMakeLists.txt</code>, add the following line somewhere inside the<a id="_idIndexMarker070"/> file:<pre><code>configure_file</code> function will replace all the @-clamped string occurrences in the input file (<code>lit.site.cfg.py.in</code>, in this case) with their CMake variable counterparts in the current CMake context. </p><p>For example, let's say there is a file called <code>demo.txt.in</code> that contains the following content:</p><pre>name = "@FOO@"
age = @AGE@</pre><p>Now, let's use <code>configure_file</code> in <code>CMakeLists.txt</code>:</p><pre>set(FOO "John Smith")
set(AGE 87)
configure_file(demo.txt.in
               demo.txt @ONLY)</pre><p>Here, the aforementioned replacement will kick in and generate an output file, <code>demo.txt</code>, that contains the following content:</p><pre>name = "John Smith"
age = 87</pre></li>
				<li>Back to the <code>lit.site.cfg.py.in</code> snippets, since <code>CMAKE_SOURCE_DIR</code> and <code>CMAKE_BINARY_DIR</code> are always available, they point to the root source folder and the <code>build</code><code><a id="_idIndexMarker071"/></code> folder, respectively. The resulting <code>/JSMinifier/build/test/lit.site.cfg.py</code> will contain the following content:<pre>import os
config.my_src_root = r'<strong class="bold">/absolute/path/to/JSMinifier</strong>'
config.my_obj_root = r'<strong class="bold">/absolute/path/to/JSMinifier/build</strong>'
lit_config.load_config(
    config, os.path.join(config.my_src_root, 'test/      lit.cfg.py'))</pre></li>
			</ol>
			<p>With that, we have learned how to write LIT configuration scripts for our example project. Now, it is time to explain some details of how LIT works internally, and why we need so many files (<code>lit.cfg.py</code>, <code>lit.site.cfg.py.in</code>, and <code>lit.site.cfg.py</code>).</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>LIT internals</h2>
			<p>Let's look at the<a id="_idIndexMarker072"/> following diagram, which illustrates the workflow of running LIT tests in the demo project we just created:</p>
			<div><div><img src="img/B14590_03_01.jpg" alt="Figure 3.1 – The forking flow of LIT in our example project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The forking flow of LIT in our example project</p>
			<p>Let's take a look <a id="_idIndexMarker073"/>at this diagram in more detail:</p>
			<ol>
				<li value="1"><code>lit.site.cfg.py.in</code> is copied to <code>/JSMinifier/build/lit.site.cfg.py</code>, which carries some CMake variable values.</li>
				<li>The <code>llvm-lit</code> command is launched inside <code>/JSMinifier/build</code>. It will execute <code>lit.site.cfg.py</code> first.</li>
				<li><code>lit.site.cfg.py</code> then uses the <code>load_configure</code> Python function to load the main LIT configurations (<code>lit.cfg.py</code>) and run all the test cases.</li>
			</ol>
			<p>The most crucial part of this diagram is explaining the roles of <code>lit.site.cfg.py</code> and <code>lit.site.cfg.py.in</code>: many parameters, such as the absolute path to the <code>build</code> folder, will remain unknown until the CMake configuration process is complete. So, a <em class="italic">trampoline</em> script – that is, <code>lit.site.cfg.py</code> – is placed inside the <code>build</code> folder to relay that information to the real test runner.</p>
			<p>In this section, we learned how to write LIT configuration scripts for our out-of-tree example project. We also learned how LIT works under the hood. Knowing this can help you use LIT in a wide variety of projects, in addition to LLVM. In the next section, we will focus on <code>FileCheck</code>, a <a id="_idIndexMarker074"/>crucial and commonly used LIT utility that performs advanced pattern checking.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Learning useful FileCheck tricks</h1>
			<p><code>grep</code> command-line tool available in Unix/Linux systems, but provides a more powerful yet straightforward syntax for line-based contexts. Furthermore, the fact that you can put <code>FileCheck</code> directives beside the testing targets makes the test cases self-contained and easy to understand. </p>
			<p>Though basic <code>FileCheck</code> syntax is easy to get hands-on with, there are many other <code>FileCheck</code> functionalities that truly unleash the power of <code>FileCheck</code> and greatly improve your testing experiences – creating more concise testing scripts and parsing more complex program output, to name a few. This section will show you some of those skills.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Preparing for our example project</h2>
			<p>The <code>FileCheck</code> command-line<a id="_idIndexMarker076"/> tool needs to be built first. Similar to the previous section, building one of the <code>check-XXX</code> (phony) targets in the LLVM tree is the easiest way to do so. The following is an example of this:</p>
			<pre>$ ninja check-llvm-support</pre>
			<p>In this section, we are going to use an imaginary command-line tool called <code>js-obfuscator</code>, a JavaScript obfuscator, for our example. <strong class="bold">Obfuscation</strong> is a common technique that's used to hide<a id="_idIndexMarker077"/> intellectual properties or enforce security protections. For example, we could use a real-world JavaScript obfuscator on the following JavaScript code:</p>
			<pre>const onLoginPOST = (req, resp) =&gt; {
  if(req.name == 'admin')
    resp.send('OK');
  else
    resp.sendError(403);
}
myReset.post('/console', onLoginPOST);</pre>
			<p>This would <a id="_idIndexMarker078"/>transform it into the following code:</p>
			<pre>const t = "nikfmnsdzaO";
const aaa = (a, b) =&gt; {
  if(a.z[0] == t[9] &amp;&amp; a.z[1] == t[7] &amp;&amp;…)
    b.f0(t[10] + t[2].toUpperCase());
  else
    b.f1(0x193);
}
G.f4(YYY, aaa);</pre>
			<p>This tool will try to make the original script as human-unreadable as possible. The challenge for the testing part is to verify its correctness while still reserving enough space for randomness. Simply put, <code>js-obfuscator</code> will only apply four obfuscation rules:</p>
			<ol>
				<li value="1">Only obfuscate local variable names, including formal parameters. The formal parameter names should always be obfuscated in <em class="italic">&lt;lower case word&gt;&lt;argument index number&gt;</em> format. The local variable names will always be obfuscated into a combination of lowercase and uppercase letters.</li>
				<li>If we are declaring functions with the arrow syntax – for example, <code>let foo = (arg1, arg2) =&gt; {…}</code> – the arrow and the left curly brace (<code>=&gt; {</code>) need to be put in the next line. </li>
				<li>Replace a literal number with the same value but in a different representation; for example, replacing <em class="italic">87</em> with <em class="italic">0x57</em> or <em class="italic">87.000</em>.</li>
				<li>When you supply the tool with the <code>--shuffle-funcs</code> command-line option, shuffle the declaration/appearing<a id="_idIndexMarker079"/> order of the top-level functions.</li>
			</ol>
			<p>Finally, the following JavaScript code is the example to be used with the <code>js-obfuscator</code> tool:</p>
			<pre>const square = x =&gt; x * x;
const cube = x =&gt; x * x * x;
const my_func1 = (input1, input2, input3) =&gt; {
  // <strong class="bold">TODO: Check if the arrow and curly brace are in the second   // line</strong>
  // <strong class="bold">TODO: Check if local variable and parameter names are   // obfuscated</strong>
  let intermediate = square(input3);
  let output = input1 + intermediate - input2;
  return output;
}
const my_func2 = (factor1, factor2) =&gt; {
  // <strong class="bold">TODO: Check if local variable and parameter names are   // obfuscated</strong>
  let term2 = cube(factor1);
  // <strong class="bold">TODO: Check if literal numbers are obfuscated</strong>
  return my_func1(94,
                  term2, factor2);
}
console.log(my_func2(1,2));</pre>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Writing FileCheck directives</h2>
			<p>The following <a id="_idIndexMarker080"/>steps are going to fill in all the <code>TODO</code> comments that appeared in the preceding code:</p>
			<ol>
				<li value="1">Going according to the line number, the first task is to check whether the local variables and parameters have been obfuscated properly. According to the spec, formal parameters have special renaming rules (that is, <em class="italic">&lt;lower case word&gt;&lt;argument index number&gt;</em>), so using the normal <code>CHECK</code> directive with FileCheck's own regex syntax will be the most suitable solution here:<pre>// CHECK: my_func1 = ({{[a-z]+0}}, {{[a-z]+1}}, // {{[a-z]+2}})
const my_func1 = (input1, input2, input3) =&gt; {
…</pre><p>FileCheck uses a subset of regular expressions for pattern matching, which are enclosed by either <code>{{…}}</code> or <code>[[…]]</code> symbols. We will cover the latter one shortly.</p></li>
				<li>This code looks pretty straightforward. However, the semantics of the code also need to be correct once obfuscation has been performed. So, in addition to checking the format, the succeeding references to those parameters need to be refactored as well, which is where FileCheck's pattern binding comes in:<pre>// CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])
const my_func1 = (input1, input2, input3) =&gt; {
  // CHECK: square(<code>A0</code> ~ <code>A2</code> using the <code>[[…]]</code> syntax, in which the binding variable name and the pattern are divided by a colon: <code>[[&lt;binding variable&gt;:&lt;pattern&gt;]]</code>. On the reference sites of the binding variable, the same <code>[[…]]</code> syntax is used, but without the pattern part.</p><p class="callout-heading">Note</p><p class="callout">A binding variable can have multiple definition sites. Its reference sites will read the last defined value. </p></li>
				<li>Let's not forget the second rule – the arrow and left curly brace of the function header need to be put in the second line. To implement the concept of "the line after," we can use the <code>CHECK-NEXT</code> directive:<pre>// CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])
const my_func1 = (input1, input2, input3) =&gt; {
  // <code>CHECK</code> directive, <code>CHECK-NEXT</code> will not only check if the pattern exists<a id="_idIndexMarker082"/> but also ensure that the pattern is in the line that follows the line matched by the previous directive.</p></li>
				<li>Next, all the local variables and formal parameters are checked in <code>my_func1</code>:<pre>// CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])
const my_func1 = (input1, input2, input3) =&gt; {
  // CHECK: let [[IM:[a-zA-Z]+]] = square([[A2]]);
  let intermediate = square(input3);
  // CHECK: let [[OUT:[a-zA-Z]+]] =
  // <code>CHECK-SAME</code> directive was used to match the succeeding pattern in the exact same line. The rationale behind this is that FileCheck expected different <code>CHECK</code> directives to be matched in different <em class="italic">lines</em>. So, let's say part of the snippet was written like this:</p><pre>// CHECK: let [[OUT:[a-zA-Z]+]] =
// CHECK: [[A0]] + [[IM]] - [[A1]];</pre><p>It will <em class="italic">only</em> match code that spread across two lines or more, as shown here:</p><pre>let BGHr =
    r0 + jkF + r1;</pre><p>It will throw an error otherwise. This directive is especially useful if you wish to avoid writing a super<a id="_idIndexMarker083"/> long line of checking statements, thus making the testing scripts more concise and readable.</p></li>
				<li>Going into <code>my_func2</code>, now, it's time to check if the literal numbers have been obfuscated properly. The checking statement here is designed to accept any instances/patterns <em class="italic">except</em> the original numbers. Therefore, the <code>CHECK-NOT</code> directive will be sufficient here:<pre>…
// CHECK: return my_func1(
// CHECK-NOT: 94 
return my_func1(94,
                term2, factor2);
…
// CHECK: return my_func1
// CHECK-NOT: 94,
// <strong class="bold">CHECK-SAME</strong>: {{0x5[eE]}}
return my_func1(94,
                term2, factor2);</pre></li>
				<li>Now, only one <a id="_idIndexMarker085"/>obfuscation rule needs to be verified: when the <code>js-obfuscator</code> tool is supplied with an additional command-line option, <code>--shuffle-funcs</code>, which effectively shuffles all top-level functions, we need to check whether the top-level functions maintain certain ordering, even after they have been shuffled. In JavaScript, functions are resolved when they're called. This means that <code>cube</code>, <code>square</code>, <code>my_func1</code>, and <code>my_func2</code> can have an arbitrary ordering, as long as they're placed before the <code>console.log(…)</code> statement. To express this kind of flexibility, the <code>CHECK-DAG</code> directive can be pretty useful.<p>Adjacent <code>CHECK-DAG</code> directives will match texts in arbitrary orders. For example, let's say we have the following directives:</p><pre>// CHECK-DAG: 123
// CHECK-DAG: 456</pre><p>These directives will match the following content:</p><pre>123
456</pre><p>They will also match the following content:</p><pre>456
123</pre><p>However, this <a id="_idIndexMarker086"/>freedom of ordering will not hold across either a <code>CHECK</code> or <code>CHECK-NOT</code> directive. For example, let's say we have these directives:</p><pre>// CHECK-DAG: 123
// CHECK-DAG: 456
// <strong class="bold">CHECK</strong>: 789
// CHECK-DAG: abc
// CHECK-DAG: def</pre><p>These directives will match the following text:</p><pre>456
123
789
def
abc</pre><p>However, they <a id="_idIndexMarker087"/>will not match the following text:</p><pre>456
789
123
def
abc</pre></li>
				<li>Back to our motivated example, the obfuscation rule can be checked by using the following code:<pre>…
// <code>FileCheck</code> provides a way to multiplex different <em class="italic">check suites</em> into a single file, where each suite can define how it runs and separates the checks from other suites. </p></li>
				<li>The idea of the check prefix in <code>FileCheck</code> is pretty simple: you can create a <em class="italic">check suite</em> that runs independently with other suites. Instead of using the <code>CHECK</code> string, each suite will replace it with another string in all the directives mentioned earlier (<code>CHECK-NOT</code> and <code>CHECK-SAME</code>, to name a few), including <code>CHECK</code> itself, in order to distinguish it from other suites in the same file. For example, you can create a suite with the <code>YOLO</code> prefix so that that part of the example now looks as follows:<pre>// <code>--check-prefix</code> command-line option. Here, the <code>FileCheck</code> command invocation will look like this:</p><pre><strong class="bold">$ cat test.out.js | FileCheck --check-prefix=YOLO test.js</strong></pre></li>
				<li>Finally, let's go back to our example. The last obfuscation rule can be solved by using an alternative <a id="_idIndexMarker089"/>prefix for those <code>CHECK-DAG</code> directives:<pre>…
// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const square =
// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const cube =
// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const my_func1 =
// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const my_func2 =
// <strong class="bold">CHECK-SHUFFLE</strong>: console.log
console.log(my_func2(1,2));</pre></li>
			</ol>
			<p>This must be combined with the default check suite. All the checks mentioned in this section can be run in two separate commands, as follows:</p>
			<pre># Running the default check suite
$ js-obfuscator test.js | FileCheck test.js
# Running check suite for the function shuffling option
$ js-obfuscator <strong class="bold">--shuffle-funcs</strong> test.js | \
  FileCheck --check-prefix=CHECK-SHUFFLE test.js</pre>
			<p>In this section, we have shown some advanced and useful <code>FileCheck</code> skills through our example project. These skills provide you with different ways to write validation patterns and make your LIT test script more concise.</p>
			<p>So far, we have been talking about the testing methodology, which runs tests in a shell-like environment (that is, in the <code>ShTest</code> LIT format). In the next section, we are going to introduce an alternative LIT framework – the TestSuite framework and testing format that was originated <a id="_idIndexMarker090"/>from the <code>llvm-test-suite</code> project – which provides a <em class="italic">different kind</em> of useful testing methodology for LIT.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Exploring the TestSuite framework</h1>
			<p>In the previous sections, we learned how regression tests were performed in LLVM. More specifically, we looked at the <code>ShTest</code> testing format (recalling the <code>config.test_format = lit.formats.ShTest(…)</code> line), which basically runs end-to-end tests in a <a id="_idIndexMarker091"/>shell script fashion. The <code>ShTest</code> format provides more flexibility when it comes to validating results since it can use the <code>FileCheck</code> tool we introduced in the previous section, for example.</p>
			<p>This section is going to introduce another kind of testing format: <code>llvm-test-suite</code> project – a collection of test suites and benchmarks created for testing and benchmarking LLVM. Similar to <code>ShTest</code>, this LIT format is also designed to run end-to-end tests. However, TestSuite aims to make developers' lives easier when they want to integrate <em class="italic">existing</em> executable-based test suites or benchmark codebases. For example, if you want to use the famous <strong class="bold">SPEC benchmark</strong> as one<a id="_idIndexMarker092"/> of your test suites, all you need to do is add a build description and the expected output in plain text. This is also useful when your testing logic cannot be expressed <a id="_idIndexMarker093"/>using a <strong class="bold">textual testing script</strong>, as we saw in previous sections.</p>
			<p>In this section, we will learn how to import an existing test suite or benchmark codebase into the <code>llvm-test-suite</code> project.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Preparing for our example project</h2>
			<p>First, please follow the instructions at the beginning of this chapter to build <code>llvm-test-suite</code>.</p>
			<p>The rest of the <a id="_idIndexMarker094"/>section is going to use a pseudo test suite <a id="_idIndexMarker095"/>project called <code>GeoDistance</code> project uses C++ and a GNU <code>Makefile</code> to build a command-line tool, <code>geo-distance</code>, that calculates and prints out the total distance of a path constructed by a list of latitude and longitude pairs provided by the input file. </p>
			<p>It should have the following folder structure:</p>
			<pre>GeoDistance
  |___ helper.cpp
  |___ main.cpp
  |___ sample_input.txt
  |___ Makefile</pre>
			<p>Here, the <code>Makefile</code> looks like this:</p>
			<pre>FLAGS := -DSMALL_INPUT -ffast-math
EXE := geo-distance
OBJS := helper.o main.o
%.o: %.cpp
    $(CXX) $(FLAGS) -c $^
$(EXE): $(OBJS)
    $(CXX) $(FLAGS) $&lt; -o $@</pre>
			<p>To run the <code>geo-distance</code> command-line tool, use the following command:</p>
			<pre>$ geo-distance ./sample_input.txt</pre>
			<p>This prints out the<a id="_idIndexMarker096"/> floating-point distance to <code>stdout</code>:</p>
			<pre>$ geo-distance ./sample_input.txt
94.873467</pre>
			<p>The floating-point precision requirement here is <code>0.001</code>.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Importing code into llvm-test-suite</h2>
			<p>Basically, there are only two things we need to do to import existing test suites or benchmarks<a id="_idIndexMarker097"/> into <code>llvm-test-suite</code>:</p>
			<ul>
				<li>Use CMake as the build system</li>
				<li>Compose verification rules</li>
			</ul>
			<p>To use CMake as the build system, the project folder needs to be put under the <code>MultiSource/Applications</code> subdirectory inside the <code>llvm-test-suite</code> source tree. Then, we need to update the enclosing <code>CMakeLists.txt</code> accordingly:</p>
			<pre># Inside MultiSource/Applications/CMakeLists.txt
…
add_subdirectory(GeoDistance)</pre>
			<p>To migrate <a id="_idIndexMarker098"/>from our GNU <code>Makefile</code> to <code>CMakeLists.txt</code>, instead of rewriting it using the built-in CMake directives such as <code>add_executable</code>, LLVM provides some handy functions and macros for you:</p>
			<pre># Inside MultiSource/Applications/GeoDistance/CMakeLists.txt
# (Unfinished)
llvm_multisource(geo-distance)
llvm_test_data(geo-distance sample_input.txt)</pre>
			<p>There are some new CMake directives here. <code>llvm_multisource</code> and its sibling, <code>llvm_singlesource</code>, add a new executable build target from multiple source files or only a single source file, respectively. They're basically <code>add_executable</code>, but as shown in the previous code, you can choose to leave the source file list empty, and it will use all the C/C++ source files shown in the current directory as input.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If there are multiple source files but you're using <code>llvm_singlesource</code>, every source file will be treated as a standalone executable.</p>
			<p><code>llvm_test_data</code> copies any resource/data files you want to use during runtime to the proper working directory. In this case, it's the <code>sample_input.txt</code> file.</p>
			<p>Now that the skeleton has been set up, it's time to configure the compilation flags using the following code:</p>
			<pre># Inside MultiSource/Applications/GeoDistance/CMakeLists.txt
# (Continue)
list(APPEND CPPFLAGS -DSMALL_INPUT)
list(APPEND CFLAGS -ffast-math)
llvm_multisource(geo-distance)
llvm_test_data(geo-distance sample_input.txt)</pre>
			<p>Finally, TestSuite needs<a id="_idIndexMarker099"/> to know how to run the test and how to verify the result:</p>
			<pre># Inside MultiSource/Applications/GeoDistance/CMakeLists.txt
# (Continue)
…
set(RUN_OPTIONS sample_input.txt)
set(FP_TOLERANCE 0.001)
llvm_multisource(geo-distance)
…</pre>
			<p>The <code>RUN_OPTIONS</code> CMake variable is pretty straightforward – it provides the command-line options for the testing executable. </p>
			<p>For the verification part, by default, TestSuite will use an enhanced diff to compare the output of <code>stdout</code> and the exit code against files whose filename end with <code>.reference_output</code>. </p>
			<p>For example, in our case, a <code>GeoDistance/geo-distance.reference_output</code> file is created with the expected answer and exit status code:</p>
			<pre>94.873
exit 0</pre>
			<p>You might find that the expected answer here is slightly different from the output at the beginning of this section (<code>94.873467</code>), and that's because the comparison tool allows you to designate the desired floating-point precision, which is controlled by the <code>FP_TOLERANCE</code> CMake variable shown previously.</p>
			<p>In this section, we learned how to leverage the <code>llvm-test-suite</code> project and its TestSuite<a id="_idIndexMarker100"/> framework to test executables that are either from an existing codebase or are unable to express testing logic using textual scripts. This will help you become more efficient in testing different kinds of projects using LIT. </p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Summary</h1>
			<p>LIT is a general-purpose testing framework that can not only be used inside LLVM, but also arbitrary projects with little effort. This chapter tried to prove this point by showing you how to integrate LIT into an out-of-tree project without even needing to build LLVM. Second, we saw FileCheck – a powerful pattern checker that's used by many LIT test scripts. These skills can reinforce the expressiveness of your testing scripts. Finally, we presented you with the TestSuite framework, which is suitable for testing different kinds of program and complements the default LIT testing format.</p>
			<p>In the next chapter, we will explore another supporting framework in the LLVM project: <strong class="bold">TableGen</strong>. We will show you that TableGen is also a <em class="italic">general toolbox</em> that can solve problems in out-of-tree projects, albeit almost being exclusively used by backend development in LLVM nowadays.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Further reading</h1>
			<p>Currently, the source code for FileCheck – written in C++ – is still inside LLVM's source tree. Try to replicate its functionality using Python (<a href="https://github.com/mull-project/FileCheck.py">https://github.com/mull-project/FileCheck.py</a>), which will effectively help you use FileCheck without building LLVM, just like LIT!</p>
		</div>
	</body></html>