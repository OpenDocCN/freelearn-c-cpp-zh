<html><head></head><body>
		<div id="_idContainer009">
			<h1 id="_idParaDest-38"><em class="italic"><a id="_idTextAnchor037"/>Chapter 3</em>: Testing with LLVM LIT</h1>
			<p>In the previous chapter, we learned how to take advantage of LLVM's own CMake utilities to improve our development experience. We also learned how to seamlessly integrate LLVM into other out-of-tree projects. In this chapter, we're going to talk about how to get hands-on with LLVM's own testing infrastructure, LIT.</p>
			<p><strong class="bold">LIT</strong> is a testing infrastructure that was originally developed for running LLVM's regression tests. Now, it's not only the harness for running all the tests in LLVM (both <strong class="bold">unit </strong>and <strong class="bold">regression tests)</strong> but also a generic testing framework that can be used outside of LLVM. It also provides a wide range of testing formats to tackle different scenarios. This chapter will give you a thorough tour of the components in this framework and help you master LIT.</p>
			<p>We are going to cover the following topics in this chapter:</p>
			<ul>
				<li>Using LIT in out-of-tree projects</li>
				<li>Learning about advanced FileCheck tricks</li>
				<li>Exploring the TestSuite framework</li>
			</ul>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>The core of LIT is written in <em class="italic">Python</em>, so please make sure you have Python 2.7 or Python 3.x installed (Python 3.x is preferable, as LLVM is gradually retiring Python 2.7 now).</p>
			<p>In addition, there are a bunch of supporting utilities, such as <strong class="source-inline">FileCheck</strong>, which will be used later. To build those utilities, the fastest way, unfortunately, is to build any of the <strong class="source-inline">check-XXX</strong> (phony) targets. For example, we could build <strong class="source-inline">check-llvm-support</strong>, as shown in the following code:</p>
			<p class="source-code">$ ninja check-llvm-support</p>
			<p>Finally, the last section requires that <strong class="source-inline">llvm-test-suite</strong> has been built, which is a separate repository from <strong class="source-inline">llvm-project</strong>. We can clone it by using the following command:</p>
			<p class="source-code">$ git clone https://github.com/llvm/llvm-test-suite</p>
			<p>The easiest way to configure the build will be using one of the cached CMake configs. For example, to build the test suite with optimizations (<strong class="source-inline">O3</strong>), we will use the following code:</p>
			<p class="source-code">$ mkdir .O3_build</p>
			<p class="source-code">$ cd .O3_build</p>
			<p class="source-code">$ cmake -G Ninja -DCMAKE_C_COMPILER=&lt;desired Clang binary \ path&gt; -C ../cmake/caches/O3.cmake ../</p>
			<p>Then, we can build it normally using the following command:</p>
			<p class="source-code">$ ninja all</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Using LIT in out-of-tree projects</h1>
			<p>Writing an<a id="_idIndexMarker060"/> in-tree LLVM IR regression test is pretty easy: all <a id="_idIndexMarker061"/>you need to do is annotate the IR file with testing directives. Look at the following script, for example:</p>
			<p class="source-code"><strong class="bold">; RUN: opt &lt; %s<a id="_idTextAnchor040"/> -instcombine -S -o - | FileCheck %s</strong></p>
			<p class="source-code">target triple = "x86_64-unknown-linux"</p>
			<p class="source-code">define i32 @foo(i32 %c) {</p>
			<p class="source-code">entry:</p>
			<p class="source-code"><strong class="bold">  ; CHECK: [[RET:%.+]] = add nsw i32 %c, 3</strong></p>
			<p class="source-code"><strong class="bold">  ; CHECK: ret i32 [[RET]]</strong></p>
			<p class="source-code">  %add1 = add nsw i32 %c, 1</p>
			<p class="source-code">  %add2 = add nsw i32 %add1, 2</p>
			<p class="source-code">  ret i32 %add2</p>
			<p class="source-code">}</p>
			<p>This script checks if <strong class="source-inline">InstCombine</strong> (triggered by the <strong class="source-inline">-instcombine</strong> command-line option shown in the preceding snippet) simplifies two succeeding arithmetic adds into one. After putting this file into an arbitrary folder under <strong class="source-inline">llvm/test</strong>, the script will automatically be picked and run as part of the regression test when you're executing the <strong class="source-inline">llvm-lit</strong> command-line tool.</p>
			<p>Despite its convenience, this barely helps you use LIT in out-of-tree projects. Using LIT out-of-tree is especially useful when your project needs some end-to-end testing facilities, such as a format converter, a text processor, a linter, and, of course, a compiler. This section will <a id="_idIndexMarker062"/>show you how to bring LIT to your out-of-tree projects, and then provide you with a <a id="_idIndexMarker063"/>complete picture of the running flow of LIT.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Preparing for our example project </h2>
			<p>In this section, we <a id="_idIndexMarker064"/>will use an out-of-tree CMake project. This example project builds a command-line tool, <strong class="source-inline">js-minifier</strong>, that <em class="italic">minifies</em> arbitrary JavaScript code. We will transform the following JavaScript code:</p>
			<p class="source-code">const foo = (a, b) =&gt; {</p>
			<p class="source-code">  let c = a + b;</p>
			<p class="source-code">  console.log(`This is ${c}`); </p>
			<p class="source-code">}</p>
			<p>This will be transformed into some other <em class="italic">semantic-equivalent</em> code that is as short as possible:</p>
			<p class="source-code">const foo = (a,b) =&gt; {let c = a + b; console.log(`This is ${c}`);}</p>
			<p>Instead of teaching you how to write this <strong class="source-inline">js-minifier</strong>, the goal of this section is to show you how to create a LIT testing environment to <em class="italic">test</em> this tool.</p>
			<p>The example project has the following folder structure:</p>
			<p class="source-code">/JSMinifier</p>
			<p class="source-code">  |__ CMakeLists.txt</p>
			<p class="source-code">  |__ /src</p>
			<p class="source-code">      |__ js-minifier.cpp</p>
			<p class="source-code">  |__ /test</p>
			<p class="source-code">      |__ <strong class="bold">test.js</strong></p>
			<p class="source-code">      |__ CMakeLists.txt</p>
			<p class="source-code">  |__ /build</p>
			<p>The files under the <strong class="source-inline">/src</strong> folder contain the source code for <strong class="source-inline">js-minifier</strong> (which we are not going to cover here). What we will focus on here are the files that will be used for testing <strong class="source-inline">js-minifier</strong>, which sit under the <strong class="source-inline">/test</strong> folder (for now, there is only one file, <strong class="source-inline">test.js</strong>).</p>
			<p>In this section, we are going to set up a testing environment so that when we run <strong class="source-inline">llvm-lit</strong> – the testing driver and main character of this section – under the CMake <strong class="source-inline">/build</strong> folder, it will print<a id="_idIndexMarker065"/> testing results, like this:</p>
			<p class="source-code">$ cd build</p>
			<p class="source-code">$ llvm-lit -sv .</p>
			<p class="source-code">-- Testing: 1 tests, 1 workers –</p>
			<p class="source-code">PASS: JSMinifier Test :: test.js (1 of 1)</p>
			<p class="source-code">Testing Time: 0.03s</p>
			<p class="source-code">  Expected Passes    : 1</p>
			<p>This shows how many and what test cases have passed.</p>
			<p>Here is the testing script, <strong class="source-inline">test.js</strong>:</p>
			<p class="source-code">// <strong class="bold">RUN: %jsm %s -o - | FileCheck</strong></p>
			<p class="source-code">// <strong class="bold">CHECK</strong>: const foo = (a,b) =&gt;</p>
			<p class="source-code">// <strong class="bold">CHECK-SAME</strong>: {let c = a + b; console.log(`This is ${c}`);}</p>
			<p class="source-code">const foo = (a, b) =&gt; {</p>
			<p class="source-code">  let c = a + b;</p>
			<p class="source-code">  console.log(`This is ${c}`); </p>
			<p class="source-code">}</p>
			<p>As you can see, it is a simple testing process that runs the <strong class="source-inline">js-minifier</strong> tool – represented by the <strong class="source-inline">%jsm</strong> directive, which will be replaced by the real path to <strong class="source-inline">js-minifier</strong> executable, as explained later – and checks the running result with <strong class="source-inline">FileCheck</strong> by using its <strong class="source-inline">CHECK</strong> and <strong class="source-inline">CHECK-SAME</strong> directives.</p>
			<p>With that, we've set up our example project. Before we wrap up the preparation, there is one final tool we need to create.</p>
			<p>Since we're trying to cut down on our reliance on the LLVM source tree, recreate the <strong class="source-inline">llvm-lit</strong> command-line<a id="_idIndexMarker066"/> tool using the <strong class="source-inline">LIT</strong> package available in the <em class="italic">PyPi repository</em> (that is, the <strong class="source-inline">pip</strong> command-line tool). All you need to do is install that package:</p>
			<p class="source-code">$ pip install --user lit</p>
			<p>Finally, wrap the package with the following script:</p>
			<p class="source-code">#!/usr/bin/env python</p>
			<p class="source-code">from lit.main import main</p>
			<p class="source-code">if __name__ == '__main__':</p>
			<p class="source-code">    main()</p>
			<p>Now, we can use LIT without building an LLVM tree! Next, we will create some LIT configuration scripts that will drive the whole testing flow.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>Writing LIT configurations</h2>
			<p>In this subsection, we'll show you how to write LIT<a id="_idIndexMarker067"/> configuration scripts. These scripts describe the testing process – where the files will be tested, the testing environment (if we need to import any tool, for example), the policy when there is a failure, and so on. Learning these skills can greatly improve how you use LIT in places outside the LLVM tree. Let's get started:</p>
			<ol>
				<li>Inside the <strong class="source-inline">/JSMinifier/test</strong> folder, create a file called <strong class="source-inline">lit.cfg.py</strong> that contains the following content:<p class="source-code">import lit.formats</p><p class="source-code">config.name = 'JSMinifier Test'</p><p class="source-code">config.test_format = <strong class="bold">lit.formats.ShTest</strong>(True)</p><p class="source-code">config.suffixes = ['.js']</p><p>Here, the snippet is providing LIT with some information. The <strong class="source-inline">config</strong> variable here is a Python object that will be populated later when this script is loaded into LIT's runtime. It's basically a registry with predefined fields that carry configuration values, along with custom fields that can be added by <strong class="source-inline">lit.*.py</strong> scripts at any time.</p><p>The <strong class="source-inline">config.test_format</strong> field suggests that LIT will run every test inside a shell environment (in <a id="_idIndexMarker068"/>the <strong class="source-inline">ShTest</strong> format), while the <strong class="source-inline">config.suffixes</strong> field suggests that only files with <strong class="source-inline">.js</strong> in their filename suffix will be treated as test cases (that is, all the JavaScript files).</p></li>
				<li>Following on from the code snippet in the previous step, LIT now needs two other pieces of information: the <em class="italic">root path</em> to the test files and the <em class="italic">working directory</em>:<p class="source-code">…</p><p class="source-code">config.suffixes = ['.js']</p><p class="source-code">config.test_source_root = os.path.dirname(__file__)</p><p class="source-code">config.test_exec_root = os.path.join(<strong class="bold">config.my_obj_root</strong>, 'test')</p><p>For <strong class="source-inline">config.test_source_root</strong>, it's simply pointing to <strong class="source-inline">/JSMinifier/test</strong>. On the other hand, <strong class="source-inline">config.test_exec_root</strong>, which is the working directory, is pointing to a place whose parent folder is the value of a custom configuration field, <strong class="source-inline">my_obj_root</strong>. While it will be introduced later, simply put, it points to the <strong class="source-inline">build</strong> folder path. In other words, <strong class="source-inline">config.test_exec_root</strong> will eventually have a value of <strong class="source-inline">/JSMinifier/build/test</strong>.</p></li>
				<li>The <strong class="source-inline">%jsm</strong> directive we saw earlier in <strong class="source-inline">test.js</strong> is used as a placeholder that will eventually be replaced with the real/absolute path of the <strong class="source-inline">js-minifier</strong> executable. The following lines will set up the replacements:<p class="source-code">…</p><p class="source-code">config.test_exec_root = os.path.join(config.my_obj_root, 'test')</p><p class="source-code">config.<strong class="bold">substitutions</strong>.append(('%jsm',</p><p class="source-code">    os.path.join(config.my_obj_root, 'js-minifier')))</p><p>This code adds a new entry to<a id="_idIndexMarker069"/> the <strong class="source-inline">config.substitutions</strong> field, which makes LIT replace every <strong class="source-inline">%jsm</strong> occurrence in the test files with the <strong class="source-inline">/JSMinifier/build/js-minifier</strong> value. This wraps up all the content in <strong class="source-inline">lit.cfg.py</strong>.</p></li>
				<li>Now, create a new file called <strong class="source-inline">lit.site.cfg.py.in</strong> and put it under the <strong class="source-inline">/JSMinifier/test</strong> folder. The first part of this file looks like this:<p class="source-code">import os</p><p class="source-code">config.my_src_root = r'@CMAKE_SOURCE_DIR@'</p><p class="source-code">config.my_obj_root = r'@CMAKE_BINARY_DIR@'</p><p>The mystery <strong class="source-inline">config.my_obj_root</strong> field is finally resolved here, but instead of pointing to a normal string, it is assigned to a weird value called <strong class="source-inline">@CMAKE_BINARY_DIR@</strong>. Again, this will be replaced by CMake with the real path later. The same goes for the <strong class="source-inline">config.my_src_root</strong> field.</p></li>
				<li>Finally, <strong class="source-inline">lit.site.cfg.py.in</strong> is wrapped up by these lines:<p class="source-code">…</p><p class="source-code">lit_config.<strong class="bold">load_configure</strong>(</p><p class="source-code">    config, os.path.join(config.my_src_root, '<strong class="bold">test/      lit.cfg.py</strong>'))</p><p>Even though this snippet is pretty simple, it's a little hard to understand. Simply put, this file will eventually be <em class="italic">materialized</em> into another file, with all the variables clamped by <strong class="source-inline">@</strong> being resolved and copied into the <strong class="source-inline">build</strong> folder. From there, it will <em class="italic">call back</em> the <strong class="source-inline">lit.cfg.py</strong> script we saw in the earlier steps. This will be explained later in this section.</p></li>
				<li>Finally, it's time to replace those weird @-clamped strings with real values using CMake's <strong class="source-inline">configure_file</strong> function. In <strong class="source-inline">/JSMinifier/test/CMakeLists.txt</strong>, add the following line somewhere inside the<a id="_idIndexMarker070"/> file:<p class="source-code"><strong class="bold">configure_file</strong>(lit.site.cfg.py.in</p><p class="source-code">               lit.site.cfg.py @ONLY)</p><p>The <strong class="source-inline">configure_file</strong> function will replace all the @-clamped string occurrences in the input file (<strong class="source-inline">lit.site.cfg.py.in</strong>, in this case) with their CMake variable counterparts in the current CMake context. </p><p>For example, let's say there is a file called <strong class="source-inline">demo.txt.in</strong> that contains the following content:</p><p class="source-code">name = "@FOO@"</p><p class="source-code">age = @AGE@</p><p>Now, let's use <strong class="source-inline">configure_file</strong> in <strong class="source-inline">CMakeLists.txt</strong>:</p><p class="source-code">set(FOO "John Smith")</p><p class="source-code">set(AGE 87)</p><p class="source-code">configure_file(demo.txt.in</p><p class="source-code">               demo.txt @ONLY)</p><p>Here, the aforementioned replacement will kick in and generate an output file, <strong class="source-inline">demo.txt</strong>, that contains the following content:</p><p class="source-code">name = "John Smith"</p><p class="source-code">age = 87</p></li>
				<li>Back to the <strong class="source-inline">lit.site.cfg.py.in</strong> snippets, since <strong class="source-inline">CMAKE_SOURCE_DIR</strong> and <strong class="source-inline">CMAKE_BINARY_DIR</strong> are always available, they point to the root source folder and the <strong class="source-inline">build</strong><strong class="source-inline"><a id="_idIndexMarker071"/></strong> folder, respectively. The resulting <strong class="source-inline">/JSMinifier/build/test/lit.site.cfg.py</strong> will contain the following content:<p class="source-code">import os</p><p class="source-code">config.my_src_root = r'<strong class="bold">/absolute/path/to/JSMinifier</strong>'</p><p class="source-code">config.my_obj_root = r'<strong class="bold">/absolute/path/to/JSMinifier/build</strong>'</p><p class="source-code">lit_config.load_config(</p><p class="source-code">    config, os.path.join(config.my_src_root, 'test/      lit.cfg.py'))</p></li>
			</ol>
			<p>With that, we have learned how to write LIT configuration scripts for our example project. Now, it is time to explain some details of how LIT works internally, and why we need so many files (<strong class="source-inline">lit.cfg.py</strong>, <strong class="source-inline">lit.site.cfg.py.in</strong>, and <strong class="source-inline">lit.site.cfg.py</strong>).</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>LIT internals</h2>
			<p>Let's look at the<a id="_idIndexMarker072"/> following diagram, which illustrates the workflow of running LIT tests in the demo project we just created:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B14590_03_01.jpg" alt="Figure 3.1 – The forking flow of LIT in our example project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The forking flow of LIT in our example project</p>
			<p>Let's take a look <a id="_idIndexMarker073"/>at this diagram in more detail:</p>
			<ol>
				<li value="1"><strong class="source-inline">lit.site.cfg.py.in</strong> is copied to <strong class="source-inline">/JSMinifier/build/lit.site.cfg.py</strong>, which carries some CMake variable values.</li>
				<li>The <strong class="source-inline">llvm-lit</strong> command is launched inside <strong class="source-inline">/JSMinifier/build</strong>. It will execute <strong class="source-inline">lit.site.cfg.py</strong> first.</li>
				<li><strong class="source-inline">lit.site.cfg.py</strong> then uses the <strong class="source-inline">load_configure</strong> Python function to load the main LIT configurations (<strong class="source-inline">lit.cfg.py</strong>) and run all the test cases.</li>
			</ol>
			<p>The most crucial part of this diagram is explaining the roles of <strong class="source-inline">lit.site.cfg.py</strong> and <strong class="source-inline">lit.site.cfg.py.in</strong>: many parameters, such as the absolute path to the <strong class="source-inline">build</strong> folder, will remain unknown until the CMake configuration process is complete. So, a <em class="italic">trampoline</em> script – that is, <strong class="source-inline">lit.site.cfg.py</strong> – is placed inside the <strong class="source-inline">build</strong> folder to relay that information to the real test runner.</p>
			<p>In this section, we learned how to write LIT configuration scripts for our out-of-tree example project. We also learned how LIT works under the hood. Knowing this can help you use LIT in a wide variety of projects, in addition to LLVM. In the next section, we will focus on <strong class="source-inline">FileCheck</strong>, a <a id="_idIndexMarker074"/>crucial and commonly used LIT utility that performs advanced pattern checking.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Learning useful FileCheck tricks</h1>
			<p><strong class="bold">FileCheck</strong> is an advanced <a id="_idIndexMarker075"/>pattern checker that originates from LLVM. It has a similar role as the <strong class="source-inline">grep</strong> command-line tool available in Unix/Linux systems, but provides a more powerful yet straightforward syntax for line-based contexts. Furthermore, the fact that you can put <strong class="source-inline">FileCheck</strong> directives beside the testing targets makes the test cases self-contained and easy to understand. </p>
			<p>Though basic <strong class="source-inline">FileCheck</strong> syntax is easy to get hands-on with, there are many other <strong class="source-inline">FileCheck</strong> functionalities that truly unleash the power of <strong class="source-inline">FileCheck</strong> and greatly improve your testing experiences – creating more concise testing scripts and parsing more complex program output, to name a few. This section will show you some of those skills.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Preparing for our example project</h2>
			<p>The <strong class="source-inline">FileCheck</strong> command-line<a id="_idIndexMarker076"/> tool needs to be built first. Similar to the previous section, building one of the <strong class="source-inline">check-XXX</strong> (phony) targets in the LLVM tree is the easiest way to do so. The following is an example of this:</p>
			<p class="source-code">$ ninja check-llvm-support</p>
			<p>In this section, we are going to use an imaginary command-line tool called <strong class="source-inline">js-obfuscator</strong>, a JavaScript obfuscator, for our example. <strong class="bold">Obfuscation</strong> is a common technique that's used to hide<a id="_idIndexMarker077"/> intellectual properties or enforce security protections. For example, we could use a real-world JavaScript obfuscator on the following JavaScript code:</p>
			<p class="source-code">const onLoginPOST = (req, resp) =&gt; {</p>
			<p class="source-code">  if(req.name == 'admin')</p>
			<p class="source-code">    resp.send('OK');</p>
			<p class="source-code">  else</p>
			<p class="source-code">    resp.sendError(403);</p>
			<p class="source-code">}</p>
			<p class="source-code">myReset.post('/console', onLoginPOST);</p>
			<p>This would <a id="_idIndexMarker078"/>transform it into the following code:</p>
			<p class="source-code">const t = "nikfmnsdzaO";</p>
			<p class="source-code">const aaa = (a, b) =&gt; {</p>
			<p class="source-code">  if(a.z[0] == t[9] &amp;&amp; a.z[1] == t[7] &amp;&amp;…)</p>
			<p class="source-code">    b.f0(t[10] + t[2].toUpperCase());</p>
			<p class="source-code">  else</p>
			<p class="source-code">    b.f1(0x193);</p>
			<p class="source-code">}</p>
			<p class="source-code">G.f4(YYY, aaa);</p>
			<p>This tool will try to make the original script as human-unreadable as possible. The challenge for the testing part is to verify its correctness while still reserving enough space for randomness. Simply put, <strong class="source-inline">js-obfuscator</strong> will only apply four obfuscation rules:</p>
			<ol>
				<li value="1">Only obfuscate local variable names, including formal parameters. The formal parameter names should always be obfuscated in <em class="italic">&lt;lower case word&gt;&lt;argument index number&gt;</em> format. The local variable names will always be obfuscated into a combination of lowercase and uppercase letters.</li>
				<li>If we are declaring functions with the arrow syntax – for example, <strong class="source-inline">let foo = (arg1, arg2) =&gt; {…}</strong> – the arrow and the left curly brace (<strong class="source-inline">=&gt; {</strong>) need to be put in the next line. </li>
				<li>Replace a literal number with the same value but in a different representation; for example, replacing <em class="italic">87</em> with <em class="italic">0x57</em> or <em class="italic">87.000</em>.</li>
				<li>When you supply the tool with the <strong class="source-inline">--shuffle-funcs</strong> command-line option, shuffle the declaration/appearing<a id="_idIndexMarker079"/> order of the top-level functions.</li>
			</ol>
			<p>Finally, the following JavaScript code is the example to be used with the <strong class="source-inline">js-obfuscator</strong> tool:</p>
			<p class="source-code">const square = x =&gt; x * x;</p>
			<p class="source-code">const cube = x =&gt; x * x * x;</p>
			<p class="source-code">const my_func1 = (input1, input2, input3) =&gt; {</p>
			<p class="source-code">  // <strong class="bold">TODO: Check if the arrow and curly brace are in the second   // line</strong></p>
			<p class="source-code">  // <strong class="bold">TODO: Check if local variable and parameter names are   // obfuscated</strong></p>
			<p class="source-code">  let intermediate = square(input3);</p>
			<p class="source-code">  let output = input1 + intermediate - input2;</p>
			<p class="source-code">  return output;</p>
			<p class="source-code">}</p>
			<p class="source-code">const my_func2 = (factor1, factor2) =&gt; {</p>
			<p class="source-code">  // <strong class="bold">TODO: Check if local variable and parameter names are   // obfuscated</strong></p>
			<p class="source-code">  let term2 = cube(factor1);</p>
			<p class="source-code">  // <strong class="bold">TODO: Check if literal numbers are obfuscated</strong></p>
			<p class="source-code">  return my_func1(94,</p>
			<p class="source-code">                  term2, factor2);</p>
			<p class="source-code">}</p>
			<p class="source-code">console.log(my_func2(1,2));</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Writing FileCheck directives</h2>
			<p>The following <a id="_idIndexMarker080"/>steps are going to fill in all the <strong class="source-inline">TODO</strong> comments that appeared in the preceding code:</p>
			<ol>
				<li value="1">Going according to the line number, the first task is to check whether the local variables and parameters have been obfuscated properly. According to the spec, formal parameters have special renaming rules (that is, <em class="italic">&lt;lower case word&gt;&lt;argument index number&gt;</em>), so using the normal <strong class="source-inline">CHECK</strong> directive with FileCheck's own regex syntax will be the most suitable solution here:<p class="source-code">// CHECK: my_func1 = ({{[a-z]+0}}, {{[a-z]+1}}, // {{[a-z]+2}})</p><p class="source-code">const my_func1 = (input1, input2, input3) =&gt; {</p><p class="source-code">…</p><p>FileCheck uses a subset of regular expressions for pattern matching, which are enclosed by either <strong class="source-inline">{{…}}</strong> or <strong class="source-inline">[[…]]</strong> symbols. We will cover the latter one shortly.</p></li>
				<li>This code looks pretty straightforward. However, the semantics of the code also need to be correct once obfuscation has been performed. So, in addition to checking the format, the succeeding references to those parameters need to be refactored as well, which is where FileCheck's pattern binding comes in:<p class="source-code">// CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])</p><p class="source-code">const my_func1 = (input1, input2, input3) =&gt; {</p><p class="source-code">  // CHECK: square(<strong class="bold">[[A2]]</strong>)</p><p class="source-code">  let intermediate = square(input3);</p><p class="source-code">…</p><p>This code binds the<a id="_idIndexMarker081"/> pattern of the formal parameters with the names <strong class="source-inline">A0</strong> ~ <strong class="source-inline">A2</strong> using the <strong class="source-inline">[[…]]</strong> syntax, in which the binding variable name and the pattern are divided by a colon: <strong class="source-inline">[[&lt;binding variable&gt;:&lt;pattern&gt;]]</strong>. On the reference sites of the binding variable, the same <strong class="source-inline">[[…]]</strong> syntax is used, but without the pattern part.</p><p class="callout-heading">Note</p><p class="callout">A binding variable can have multiple definition sites. Its reference sites will read the last defined value. </p></li>
				<li>Let's not forget the second rule – the arrow and left curly brace of the function header need to be put in the second line. To implement the concept of "the line after," we can use the <strong class="source-inline">CHECK-NEXT</strong> directive:<p class="source-code">// CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])</p><p class="source-code">const my_func1 = (input1, input2, input3) =&gt; {</p><p class="source-code">  // <strong class="bold">CHECK-NEXT:</strong> =&gt; { </p><p>Compared to the original <strong class="source-inline">CHECK</strong> directive, <strong class="source-inline">CHECK-NEXT</strong> will not only check if the pattern exists<a id="_idIndexMarker082"/> but also ensure that the pattern is in the line that follows the line matched by the previous directive.</p></li>
				<li>Next, all the local variables and formal parameters are checked in <strong class="source-inline">my_func1</strong>:<p class="source-code">// CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])</p><p class="source-code">const my_func1 = (input1, input2, input3) =&gt; {</p><p class="source-code">  // CHECK: let [[IM:[a-zA-Z]+]] = square([[A2]]);</p><p class="source-code">  let intermediate = square(input3);</p><p class="source-code">  // CHECK: let [[OUT:[a-zA-Z]+]] =</p><p class="source-code">  // <strong class="bold">CHECK-SAME</strong>: [[A0]] + [[IM]] - [[A1]];</p><p class="source-code">  let output = input1 + intermediate - input2;</p><p class="source-code">  // CHECK: return [[OUT]];</p><p class="source-code">  return output;</p><p class="source-code">}</p><p>As highlighted in the preceding code, the <strong class="source-inline">CHECK-SAME</strong> directive was used to match the succeeding pattern in the exact same line. The rationale behind this is that FileCheck expected different <strong class="source-inline">CHECK</strong> directives to be matched in different <em class="italic">lines</em>. So, let's say part of the snippet was written like this:</p><p class="source-code">// CHECK: let [[OUT:[a-zA-Z]+]] =</p><p class="source-code">// CHECK: [[A0]] + [[IM]] - [[A1]];</p><p>It will <em class="italic">only</em> match code that spread across two lines or more, as shown here:</p><p class="source-code">let BGHr =</p><p class="source-code">    r0 + jkF + r1;</p><p>It will throw an error otherwise. This directive is especially useful if you wish to avoid writing a super<a id="_idIndexMarker083"/> long line of checking statements, thus making the testing scripts more concise and readable.</p></li>
				<li>Going into <strong class="source-inline">my_func2</strong>, now, it's time to check if the literal numbers have been obfuscated properly. The checking statement here is designed to accept any instances/patterns <em class="italic">except</em> the original numbers. Therefore, the <strong class="source-inline">CHECK-NOT</strong> directive will be sufficient here:<p class="source-code">…</p><p class="source-code">// CHECK: return my_func1(</p><p class="source-code">// CHECK-NOT: 94 </p><p class="source-code">return my_func1(94,</p><p class="source-code">                term2, factor2);</p><p class="callout-heading">Note </p><p class="callout">The first <strong class="source-inline">CHECK</strong> directive is required. This is because <strong class="source-inline">CHECK-NOT</strong> will not move the cursor from the line before <strong class="source-inline">return my_func1(94</strong>. Here, <strong class="source-inline">CHECK-NOT</strong> will give a false negative without a <strong class="source-inline">CHECK</strong> directive to move the cursor to the correct line first.</p><p>In addition, <strong class="source-inline">CHECK-NOT</strong> is pretty useful to express the concept of <em class="italic">not &lt;a specific pattern&gt;…but &lt;the correct pattern&gt;</em> when it's used with <strong class="source-inline">CHECK-SAME</strong>, as we mentioned earlier. </p><p>For example, if the obfuscation rule states that all the literal numbers need to be obfuscated into their hexadecimal counterparts, then you can express the assertion of <em class="italic">don't want to see 94… but want to see 0x5E/0x5e at the same place instead</em> using<a id="_idIndexMarker084"/> the following code:</p><p class="source-code">…</p><p class="source-code">// CHECK: return my_func1</p><p class="source-code">// CHECK-NOT: 94,</p><p class="source-code">// <strong class="bold">CHECK-SAME</strong>: {{0x5[eE]}}</p><p class="source-code">return my_func1(94,</p><p class="source-code">                term2, factor2);</p></li>
				<li>Now, only one <a id="_idIndexMarker085"/>obfuscation rule needs to be verified: when the <strong class="source-inline">js-obfuscator</strong> tool is supplied with an additional command-line option, <strong class="source-inline">--shuffle-funcs</strong>, which effectively shuffles all top-level functions, we need to check whether the top-level functions maintain certain ordering, even after they have been shuffled. In JavaScript, functions are resolved when they're called. This means that <strong class="source-inline">cube</strong>, <strong class="source-inline">square</strong>, <strong class="source-inline">my_func1</strong>, and <strong class="source-inline">my_func2</strong> can have an arbitrary ordering, as long as they're placed before the <strong class="source-inline">console.log(…)</strong> statement. To express this kind of flexibility, the <strong class="source-inline">CHECK-DAG</strong> directive can be pretty useful.<p>Adjacent <strong class="source-inline">CHECK-DAG</strong> directives will match texts in arbitrary orders. For example, let's say we have the following directives:</p><p class="source-code">// CHECK-DAG: 123</p><p class="source-code">// CHECK-DAG: 456</p><p>These directives will match the following content:</p><p class="source-code">123</p><p class="source-code">456</p><p>They will also match the following content:</p><p class="source-code">456</p><p class="source-code">123</p><p>However, this <a id="_idIndexMarker086"/>freedom of ordering will not hold across either a <strong class="source-inline">CHECK</strong> or <strong class="source-inline">CHECK-NOT</strong> directive. For example, let's say we have these directives:</p><p class="source-code">// CHECK-DAG: 123</p><p class="source-code">// CHECK-DAG: 456</p><p class="source-code">// <strong class="bold">CHECK</strong>: 789</p><p class="source-code">// CHECK-DAG: abc</p><p class="source-code">// CHECK-DAG: def</p><p>These directives will match the following text:</p><p class="source-code">456</p><p class="source-code">123</p><p class="source-code">789</p><p class="source-code">def</p><p class="source-code">abc</p><p>However, they <a id="_idIndexMarker087"/>will not match the following text:</p><p class="source-code">456</p><p class="source-code">789</p><p class="source-code">123</p><p class="source-code">def</p><p class="source-code">abc</p></li>
				<li>Back to our motivated example, the obfuscation rule can be checked by using the following code:<p class="source-code">…</p><p class="source-code">// <strong class="bold">CHECK-DAG</strong>: const square =</p><p class="source-code">// <strong class="bold">CHECK-DAG</strong>: const cube =</p><p class="source-code">// <strong class="bold">CHECK-DAG</strong>: const my_func1 =</p><p class="source-code">// <strong class="bold">CHECK-DAG</strong>: const my_func2 =</p><p class="source-code">// <strong class="bold">CHECK</strong>: console.log</p><p class="source-code">console.log(my_func2(1,2));</p><p>However, function <a id="_idIndexMarker088"/>shuffling will only happen if an additional command-line option is supplied to the tool. Fortunately, <strong class="source-inline">FileCheck</strong> provides a way to multiplex different <em class="italic">check suites</em> into a single file, where each suite can define how it runs and separates the checks from other suites. </p></li>
				<li>The idea of the check prefix in <strong class="source-inline">FileCheck</strong> is pretty simple: you can create a <em class="italic">check suite</em> that runs independently with other suites. Instead of using the <strong class="source-inline">CHECK</strong> string, each suite will replace it with another string in all the directives mentioned earlier (<strong class="source-inline">CHECK-NOT</strong> and <strong class="source-inline">CHECK-SAME</strong>, to name a few), including <strong class="source-inline">CHECK</strong> itself, in order to distinguish it from other suites in the same file. For example, you can create a suite with the <strong class="source-inline">YOLO</strong> prefix so that that part of the example now looks as follows:<p class="source-code">// <strong class="bold">YOLO</strong>: my_func2 = ([[A0:[a-z]+0]], [[A1:[a-z]+1]])</p><p class="source-code">const my_func2 = (factor1, factor2) =&gt; {</p><p class="source-code">…</p><p class="source-code">// <strong class="bold">YOLO-NOT</strong>: return my_func1(94,</p><p class="source-code">// <strong class="bold">YOLO-SAME</strong>: return my_func1({{0x5[eE]}},</p><p class="source-code">return my_func1(94,</p><p class="source-code">                term2, factor2);</p><p class="source-code">…</p><p>To use a custom prefix, it needs to be specified in the <strong class="source-inline">--check-prefix</strong> command-line option. Here, the <strong class="source-inline">FileCheck</strong> command invocation will look like this:</p><p class="source-code"><strong class="bold">$ cat test.out.js | FileCheck --check-prefix=YOLO test.js</strong></p></li>
				<li>Finally, let's go back to our example. The last obfuscation rule can be solved by using an alternative <a id="_idIndexMarker089"/>prefix for those <strong class="source-inline">CHECK-DAG</strong> directives:<p class="source-code">…</p><p class="source-code">// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const square =</p><p class="source-code">// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const cube =</p><p class="source-code">// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const my_func1 =</p><p class="source-code">// <strong class="bold">CHECK-SHUFFLE-DAG</strong>: const my_func2 =</p><p class="source-code">// <strong class="bold">CHECK-SHUFFLE</strong>: console.log</p><p class="source-code">console.log(my_func2(1,2));</p></li>
			</ol>
			<p>This must be combined with the default check suite. All the checks mentioned in this section can be run in two separate commands, as follows:</p>
			<p class="source-code"># Running the default check suite</p>
			<p class="source-code">$ js-obfuscator test.js | FileCheck test.js</p>
			<p class="source-code"># Running check suite for the function shuffling option</p>
			<p class="source-code">$ js-obfuscator <strong class="bold">--shuffle-funcs</strong> test.js | \</p>
			<p class="source-code">  FileCheck --check-prefix=CHECK-SHUFFLE test.js</p>
			<p>In this section, we have shown some advanced and useful <strong class="source-inline">FileCheck</strong> skills through our example project. These skills provide you with different ways to write validation patterns and make your LIT test script more concise.</p>
			<p>So far, we have been talking about the testing methodology, which runs tests in a shell-like environment (that is, in the <strong class="source-inline">ShTest</strong> LIT format). In the next section, we are going to introduce an alternative LIT framework – the TestSuite framework and testing format that was originated <a id="_idIndexMarker090"/>from the <strong class="source-inline">llvm-test-suite</strong> project – which provides a <em class="italic">different kind</em> of useful testing methodology for LIT.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Exploring the TestSuite framework</h1>
			<p>In the previous sections, we learned how regression tests were performed in LLVM. More specifically, we looked at the <strong class="source-inline">ShTest</strong> testing format (recalling the <strong class="source-inline">config.test_format = lit.formats.ShTest(…)</strong> line), which basically runs end-to-end tests in a <a id="_idIndexMarker091"/>shell script fashion. The <strong class="source-inline">ShTest</strong> format provides more flexibility when it comes to validating results since it can use the <strong class="source-inline">FileCheck</strong> tool we introduced in the previous section, for example.</p>
			<p>This section is going to introduce another kind of testing format: <strong class="bold">TestSuite</strong>. The TestSuite format is part of the <strong class="source-inline">llvm-test-suite</strong> project – a collection of test suites and benchmarks created for testing and benchmarking LLVM. Similar to <strong class="source-inline">ShTest</strong>, this LIT format is also designed to run end-to-end tests. However, TestSuite aims to make developers' lives easier when they want to integrate <em class="italic">existing</em> executable-based test suites or benchmark codebases. For example, if you want to use the famous <strong class="bold">SPEC benchmark</strong> as one<a id="_idIndexMarker092"/> of your test suites, all you need to do is add a build description and the expected output in plain text. This is also useful when your testing logic cannot be expressed <a id="_idIndexMarker093"/>using a <strong class="bold">textual testing script</strong>, as we saw in previous sections.</p>
			<p>In this section, we will learn how to import an existing test suite or benchmark codebase into the <strong class="source-inline">llvm-test-suite</strong> project.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Preparing for our example project</h2>
			<p>First, please follow the instructions at the beginning of this chapter to build <strong class="source-inline">llvm-test-suite</strong>.</p>
			<p>The rest of the <a id="_idIndexMarker094"/>section is going to use a pseudo test suite <a id="_idIndexMarker095"/>project called <strong class="bold">GeoDistance</strong>. The <strong class="source-inline">GeoDistance</strong> project uses C++ and a GNU <strong class="source-inline">Makefile</strong> to build a command-line tool, <strong class="source-inline">geo-distance</strong>, that calculates and prints out the total distance of a path constructed by a list of latitude and longitude pairs provided by the input file. </p>
			<p>It should have the following folder structure:</p>
			<p class="source-code">GeoDistance</p>
			<p class="source-code">  |___ helper.cpp</p>
			<p class="source-code">  |___ main.cpp</p>
			<p class="source-code">  |___ sample_input.txt</p>
			<p class="source-code">  |___ Makefile</p>
			<p>Here, the <strong class="source-inline">Makefile</strong> looks like this:</p>
			<p class="source-code">FLAGS := -DSMALL_INPUT -ffast-math</p>
			<p class="source-code">EXE := geo-distance</p>
			<p class="source-code">OBJS := helper.o main.o</p>
			<p class="source-code">%.o: %.cpp</p>
			<p class="source-code">    $(CXX) $(FLAGS) -c $^</p>
			<p class="source-code">$(EXE): $(OBJS)</p>
			<p class="source-code">    $(CXX) $(FLAGS) $&lt; -o $@</p>
			<p>To run the <strong class="source-inline">geo-distance</strong> command-line tool, use the following command:</p>
			<p class="source-code">$ geo-distance ./sample_input.txt</p>
			<p>This prints out the<a id="_idIndexMarker096"/> floating-point distance to <strong class="source-inline">stdout</strong>:</p>
			<p class="source-code">$ geo-distance ./sample_input.txt</p>
			<p class="source-code">94.873467</p>
			<p>The floating-point precision requirement here is <strong class="source-inline">0.001</strong>.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Importing code into llvm-test-suite</h2>
			<p>Basically, there are only two things we need to do to import existing test suites or benchmarks<a id="_idIndexMarker097"/> into <strong class="source-inline">llvm-test-suite</strong>:</p>
			<ul>
				<li>Use CMake as the build system</li>
				<li>Compose verification rules</li>
			</ul>
			<p>To use CMake as the build system, the project folder needs to be put under the <strong class="source-inline">MultiSource/Applications</strong> subdirectory inside the <strong class="source-inline">llvm-test-suite</strong> source tree. Then, we need to update the enclosing <strong class="source-inline">CMakeLists.txt</strong> accordingly:</p>
			<p class="source-code"># Inside MultiSource/Applications/CMakeLists.txt</p>
			<p class="source-code">…</p>
			<p class="source-code">add_subdirectory(GeoDistance)</p>
			<p>To migrate <a id="_idIndexMarker098"/>from our GNU <strong class="source-inline">Makefile</strong> to <strong class="source-inline">CMakeLists.txt</strong>, instead of rewriting it using the built-in CMake directives such as <strong class="source-inline">add_executable</strong>, LLVM provides some handy functions and macros for you:</p>
			<p class="source-code"># Inside MultiSource/Applications/GeoDistance/CMakeLists.txt</p>
			<p class="source-code"># (Unfinished)</p>
			<p class="source-code">llvm_multisource(geo-distance)</p>
			<p class="source-code">llvm_test_data(geo-distance sample_input.txt)</p>
			<p>There are some new CMake directives here. <strong class="source-inline">llvm_multisource</strong> and its sibling, <strong class="source-inline">llvm_singlesource</strong>, add a new executable build target from multiple source files or only a single source file, respectively. They're basically <strong class="source-inline">add_executable</strong>, but as shown in the previous code, you can choose to leave the source file list empty, and it will use all the C/C++ source files shown in the current directory as input.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If there are multiple source files but you're using <strong class="source-inline">llvm_singlesource</strong>, every source file will be treated as a standalone executable.</p>
			<p><strong class="source-inline">llvm_test_data</strong> copies any resource/data files you want to use during runtime to the proper working directory. In this case, it's the <strong class="source-inline">sample_input.txt</strong> file.</p>
			<p>Now that the skeleton has been set up, it's time to configure the compilation flags using the following code:</p>
			<p class="source-code"># Inside MultiSource/Applications/GeoDistance/CMakeLists.txt</p>
			<p class="source-code"># (Continue)</p>
			<p class="source-code">list(APPEND CPPFLAGS -DSMALL_INPUT)</p>
			<p class="source-code">list(APPEND CFLAGS -ffast-math)</p>
			<p class="source-code">llvm_multisource(geo-distance)</p>
			<p class="source-code">llvm_test_data(geo-distance sample_input.txt)</p>
			<p>Finally, TestSuite needs<a id="_idIndexMarker099"/> to know how to run the test and how to verify the result:</p>
			<p class="source-code"># Inside MultiSource/Applications/GeoDistance/CMakeLists.txt</p>
			<p class="source-code"># (Continue)</p>
			<p class="source-code">…</p>
			<p class="source-code">set(RUN_OPTIONS sample_input.txt)</p>
			<p class="source-code">set(FP_TOLERANCE 0.001)</p>
			<p class="source-code">llvm_multisource(geo-distance)</p>
			<p class="source-code">…</p>
			<p>The <strong class="source-inline">RUN_OPTIONS</strong> CMake variable is pretty straightforward – it provides the command-line options for the testing executable. </p>
			<p>For the verification part, by default, TestSuite will use an enhanced diff to compare the output of <strong class="source-inline">stdout</strong> and the exit code against files whose filename end with <strong class="source-inline">.reference_output</strong>. </p>
			<p>For example, in our case, a <strong class="source-inline">GeoDistance/geo-distance.reference_output</strong> file is created with the expected answer and exit status code:</p>
			<p class="source-code">94.873</p>
			<p class="source-code">exit 0</p>
			<p>You might find that the expected answer here is slightly different from the output at the beginning of this section (<strong class="source-inline">94.873467</strong>), and that's because the comparison tool allows you to designate the desired floating-point precision, which is controlled by the <strong class="source-inline">FP_TOLERANCE</strong> CMake variable shown previously.</p>
			<p>In this section, we learned how to leverage the <strong class="source-inline">llvm-test-suite</strong> project and its TestSuite<a id="_idIndexMarker100"/> framework to test executables that are either from an existing codebase or are unable to express testing logic using textual scripts. This will help you become more efficient in testing different kinds of projects using LIT. </p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Summary</h1>
			<p>LIT is a general-purpose testing framework that can not only be used inside LLVM, but also arbitrary projects with little effort. This chapter tried to prove this point by showing you how to integrate LIT into an out-of-tree project without even needing to build LLVM. Second, we saw FileCheck – a powerful pattern checker that's used by many LIT test scripts. These skills can reinforce the expressiveness of your testing scripts. Finally, we presented you with the TestSuite framework, which is suitable for testing different kinds of program and complements the default LIT testing format.</p>
			<p>In the next chapter, we will explore another supporting framework in the LLVM project: <strong class="bold">TableGen</strong>. We will show you that TableGen is also a <em class="italic">general toolbox</em> that can solve problems in out-of-tree projects, albeit almost being exclusively used by backend development in LLVM nowadays.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Further reading</h1>
			<p>Currently, the source code for FileCheck – written in C++ – is still inside LLVM's source tree. Try to replicate its functionality using Python (<a href="https://github.com/mull-project/FileCheck.py">https://github.com/mull-project/FileCheck.py</a>), which will effectively help you use FileCheck without building LLVM, just like LIT!</p>
		</div>
	</body></html>