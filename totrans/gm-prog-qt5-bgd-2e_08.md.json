["```cpp\nvoid doSomePainting(QPainter *painter) {\n    painter->drawLine(QPoint(0,0), QPoint(100, 40));\n} \n```", "```cpp\nQFontMetrics fm = painter.fontMetrics();\nQRect rect = fm.boundingRect(\"Game Programming using Qt\"); \n```", "```cpp\n{\n    QPainter painter(this); // paint on the current object\n    QPen pen(Qt::red);\n    pen.setWidth(2);\n    painter.setPen(pen);\n    painter.setBrush(Qt::yellow);\n    painter.drawRect(0, 0, 100, 50);\n} \n```", "```cpp\nprotected:\n    void paintEvent(QPaintEvent *); \n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n} \n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n    QPen pen(Qt::black);\n    pen.setWidth(4);\n    painter.setPen(pen);\n    QRect r = rect().adjusted(10, 10, -10, -10);\n    painter.drawRoundedRect(r, 20, 10);\n} \n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing, true);\n    // ...\n} \n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *) {\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing, true);\n    QPen pen(Qt::black);\n    pen.setWidth(4);\n    painter.setPen(pen);\n    QRect r = rect().adjusted(10, 10, -10, -10);\n    painter.drawRoundedRect(r, 20, 10);\n    painter.save();\n    r.adjust(2, 2, -2, -2);\n    painter.setViewport(r);\n    r.moveTo(0, -r.height() / 2);\n    painter.setWindow(r);\n    drawChart(&painter, r);\n    painter.restore();\n} \n```", "```cpp\nvoid Widget::drawChart(QPainter *painter, const QRect &rect) {\n    painter->setPen(Qt::red);\n    painter->drawLine(0, 0, rect.width(), 0);\n} \n```", "```cpp\nclass Widget : public QWidget\n{\n    // ...\npublic slots:\n    void addPoint(unsigned yVal) {\n        m_points << qMax(0u, yVal);\n        update();\n    }\n    void clear() {\n        m_points.clear();\n        update();\n    }\nprotected:\n    // ...\n    QVector<quint16> m_points;\n}; \n```", "```cpp\nvoid Widget::drawChart(QPainter *painter, const QRect &rect) {\n    painter->setPen(Qt::red);\n    painter->drawLine(0, 0, rect.width(), 0);\n    painter->save();\n    painter->setRenderHint(QPainter::Antialiasing, false);\n    painter->setPen(Qt::blue);\n    for(int i = 0; i < m_points.size(); ++i) {\n        painter->drawLine(i, -m_points.at(i), i, m_points.at(i));\n    }\n    painter->restore();\n} \n```", "```cpp\nfor(int i = 0; i < 450; ++i) {\n    w.addPoint(qrand() % 120);\n}\n```", "```cpp\nQ_PROPERTY(int selectionStart READ selectionStart\n                              NOTIFY selectionChanged)\nQ_PROPERTY(int selectionEnd   READ selectionEnd\n                              NOTIFY selectionChanged)\n```", "```cpp\nvoid Widget::mousePressEvent(QMouseEvent *mouseEvent) {\n    m_selectionStart = m_selectionEnd = mouseEvent->pos().x() - 12;\n    emit selectionChanged();\n    update();\n}\nvoid Widget::mouseMoveEvent(QMouseEvent *mouseEvent) {\n    m_selectionEnd = mouseEvent->pos().x() - 12;\n    emit selectionChanged();\n    update();\n} \n```", "```cpp\nvoid Widget::drawSelection(QPainter *painter, const QRect &rect) {\n    if(m_selectionStart < 0) {\n        return;\n    }\n    painter->save();\n    painter->setPen(Qt::NoPen);\n    painter->setBrush(palette().highlight());\n    QRect selectionRect = rect;\n    selectionRect.setLeft(m_selectionStart);\n    selectionRect.setRight(m_selectionEnd);\n    painter->drawRect(selectionRect);\n    painter->restore();\n} \n```", "```cpp\nfor(int i = 0; i < m_points.size(); ++i) {\n    if(m_selectionStart <= i && m_selectionEnd >=i) {\n        painter->setPen(Qt::white);\n    } else {\n        painter->setPen(Qt::blue);\n    }\n    painter->drawLine(i, -m_points.at(i), i, m_points.at(i));\n} \n```", "```cpp\nbool Widget::event(QEvent *e) {\n  if(e->type() == QEvent::Gesture) {\n    QGestureEvent *gestureEvent = static_cast<QGestureEvent*>(e);\n    QGesture *pan  = gestureEvent->gesture(Qt::PanGesture);\n    if(pan) {\n      handlePanGesture(static_cast<QPanGesture*>(pan));\n    }\n  }\n  return QWidget::event(e);\n} \n```", "```cpp\nQImage trueColor(\"image.png\");\nQImage indexed = trueColor.convertToFormat(QImage::Format_Indexed8); \n```", "```cpp\nQImage indexed = ...;\nQVector<QRgb> colorTable = indexed.colorTable();\nfor(QRgb &item: colorTable) {\n    int gray = qGray(item);\n    item = qRgb(gray, gray, gray);\n}\nindexed.setColorTable(colorTable); \n```", "```cpp\nQImage grayImage = coloredImage.convertToFormat(QImage::Format_Grayscale8);\n```", "```cpp\nQPixmap px(256, 256);\npx.fill(Qt::transparent);\nQPainter painter(&px);\npainter.setPen(Qt::NoPen);\npainter.setBrush(Qt::blue);\nQRect r = px.rect().adjusted(10, 10, -10, -10);\npainter.drawRect(r);\npainter.setBrush(Qt::red);\npainter.drawEllipse(r); \n```", "```cpp\npainter.drawText(10, 20, \"Drawing some text at (10, 20)\"); \n```", "```cpp\npainter.drawText(rect, Qt::AlignLeft | Qt::TextShowMnemonic, \"&ABC\"); \n```", "```cpp\nclass TextWidget : public QWidget {\npublic:\n    TextWidget(QWidget *parent = nullptr) : QWidget(parent) {}\n    void setText(const QString &txt) {\n        m_staticText.setText(txt);\n        update();\n    }\nprotected:\n    void paintEvent(QPaintEvent *) {\n        QPainter painter(this);\n        painter.drawStaticText(0, 0, m_staticText);\n    }\nprivate:\n    QStaticText m_staticText;\n}; \n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *event)\n{\n    QRect exposedRect = event->rect();\n    ...\n    drawSelection(&painter, r, exposedRect);\n    drawChart(&painter, r, exposedRect);\n    painter.restore();\n} \n```", "```cpp\nvoid Widget::drawSelection(QPainter *painter, const QRect &rect,\n                           const QRect &exposedRect)\n{\n    // ...\n    QRect selectionRect = rect;\n    selectionRect.setLeft(m_selectionStart);\n    selectionRect.setRight(m_selectionEnd);\n    painter->drawRect(selectionRect.intersected(exposedRect));\n    painter->restore();\n} \n```", "```cpp\nvoid Widget::drawChart(QPainter *painter, const QRect &rect,\n                       const QRect &exposedRect)\n{\n    painter->setPen(Qt::red);\n    painter->drawLine(exposedRect.left(), 0, exposedRect.width(), 0);\n    painter->save();\n    painter->setRenderHint(QPainter::Antialiasing, false);\n    const int lastPoint = qMin(m_points.size(),\n                               exposedRect.right() + 1);\n    for(int i = exposedRect.left(); i < lastPoint; ++i) {\n      if(m_selectionStart <= i && m_selectionEnd >=i) {\n        painter->setPen(Qt::white);\n      } else\n      painter->setPen(Qt::blue);\n      painter->drawLine(i, -m_points.at(i), i, m_points.at(i));\n    }\n    painter->restore();\n    Q_UNUSED(rect)\n} \n```", "```cpp\nvoid Widget::paintEvent(QPaintEvent *event)\n{\n    QRect exposedRect = event->rect();\n    QPainter painter(this);\n    painter.drawPixmap(exposedRect, m_pixmap, exposedRect);\n} \n```", "```cpp\npublic:\n    ChessBoard* board() const;\npublic slots:\n    virtual void newGame();\nsignals:\n    void boardChanged(ChessBoard*);\nprotected:\n    virtual void setupBoard();\n    void setBoard(ChessBoard *board); \n```", "```cpp\nvoid ChessAlgorithm::setBoard(ChessBoard *board)\n{\n    if(board == m_board) {\n        return;\n    }\n    delete m_board;\n    m_board = board;\n    emit boardChanged(m_board);\n} \n```", "```cpp\nvoid ChessAlgorithm::setupBoard()\n{\n    setBoard(new ChessBoard(8, 8, this));\n} \n```", "```cpp\nvoid ChessAlgorithm::newGame()\n{\n    setupBoard();\n} \n```", "```cpp\n  Q_PROPERTY(int ranks READ ranks NOTIFY ranksChanged)\n  Q_PROPERTY(int columns READ columns NOTIFY columnsChanged) \n```", "```cpp\nprotected:\n    void setRanks(int newRanks);\n    void setColumns(int newColumns); \n```", "```cpp\nvoid ChessBoard::setRanks(int newRanks)\n{\n    if(ranks() == newRanks) {\n        return;\n    }\n    m_ranks = newRanks;\n    emit ranksChanged(m_ranks);\n} \n```", "```cpp\nvoid ChessView::setBoard(ChessBoard *board)\n{\n    if(m_board == board) {\n        return;\n    }\n    if(m_board) {\n        // disconnect all signal-slot connections between m_board and this\n        m_board->disconnect(this);\n    }\n    m_board = board;\n    // connect signals (to be done later)\n    updateGeometry();\n} \n```", "```cpp\nprivate:\n    QPointer<ChessBoard> m_board; \n```", "```cpp\nChessBoard *ChessView::board() const {\n    return m_board;\n} \n```", "```cpp\nQVector<char> m_boardData; \n```", "```cpp\nvoid ChessBoard::initBoard()\n{\n    m_boardData.fill(' ', ranks() * columns());\n    emit boardReset();\n} \n```", "```cpp\nvoid ChessBoard::setRanks(int newRanks)\n{\n    if(ranks() == newRanks) {\n        return;\n    }\n    m_ranks = newRanks;\n    initBoard();\n    emit ranksChanged(m_ranks);\n}\n\nvoid ChessBoard::setColumns(int newColumns)\n{\n    if(columns() == newColumns) {\n        return;\n    }\n    m_columns = newColumns;\n    initBoard();\n    emit columnsChanged(m_columns);\n} \n```", "```cpp\nchar ChessBoard::data(int column, int rank) const\n{\n    return m_boardData.at((rank-1) * columns() + (column - 1));\n} \n```", "```cpp\nvoid ChessBoard::setData(int column, int rank, char value)\n{\n    if(setDataInternal(column, rank, value)) {\n        emit dataChanged(column, rank);\n    }\n} \n```", "```cpp\nbool ChessBoard::setDataInternal(int column, int rank, char value)\n{\n    int index = (rank-1) * columns() + (column - 1);\n    if(m_boardData.at(index) == value) {\n        return false;\n    }\n    m_boardData[index] = value;\n    return true;\n} \n```", "```cpp\nsignals:\n    void ranksChanged(int);\n    void columnsChanged(int);\n    void dataChanged(int c, int r);\n    void boardReset(); \n```", "```cpp\nvoid ChessBoard::movePiece(int fromColumn, int fromRank, \n                           int toColumn, int toRank)\n{\n    setData(toColumn, toRank, data(fromColumn, fromRank));\n    setData(fromColumn, fromRank, ' ');\n} \n```", "```cpp\n\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\" \n```", "```cpp\nvoid ChessBoard::setFen(const QString &fen)\n{\n    int index = 0;\n    int skip = 0;\n    const int columnCount = columns();\n    QChar ch;\n    for(int rank = ranks(); rank > 0; --rank) {\n        for(int column = 1; column <= columnCount; ++column) {\n            if(skip > 0) {\n                ch = ' ';\n                skip--;\n            } else {\n                ch = fen.at(index++);\n                if(ch.isDigit()) {\n                    skip = ch.toLatin1() - '0';\n                    ch = ' ';\n                    skip--;\n                }\n            }\n            setDataInternal(column, rank, ch.toLatin1());\n        }\n        QChar next = fen.at(index++);\n        if(next != '/' && next != ' ') {\n            initBoard();\n            return; // fail on error\n        }\n    }\n    emit boardReset();\n} \n```", "```cpp\nQ_PROPERTY(QSize fieldSize\n           READ fieldSize WRITE setFieldSize\n           NOTIFY fieldSizeChanged) \n```", "```cpp\nvoid ChessView::setFieldSize(QSize arg)\n{\n    if (m_fieldSize == arg) {\n        return;\n    }\n    m_fieldSize = arg;\n    emit fieldSizeChanged(arg);\n    updateGeometry();\n} \n```", "```cpp\nQSize ChessView::sizeHint() const\n{\n    if(!m_board) {\n        return QSize(100,100);\n    }\n    QSize boardSize = QSize(fieldSize().width()\n        * m_board->columns() + 1,\n    m_fieldSize.height() * m_board->ranks() + 1);\n    // 'M' is the widest letter\n    int rankSize = fontMetrics().width('M') + 4;\n    int columnSize = fontMetrics().height() + 4;\n    return boardSize + QSize(rankSize, columnSize);\n} \n```", "```cpp\nQRect ChessView::fieldRect(int column, int rank) const\n{\n    if(!m_board) {\n        return QRect();\n    }\n    const QSize fs = fieldSize();\n    QPoint topLeft((column - 1) * fs.width(),\n                   (m_board->ranks()-rank) * fs.height());\n    QRect fRect = QRect(topLeft, fs);\n    // offset rect by rank symbols\n    int offset = fontMetrics().width('M');    \n    return fRect.translated(offset+4, 0);\n} \n```", "```cpp\nvoid ChessView::paintEvent(QPaintEvent *)\n{\n    if(!m_board) {\n        return;\n    }\n    QPainter painter(this);\n    for(int r = m_board->ranks(); r > 0; --r) {\n        painter.save();\n        drawRank(&painter, r);\n        painter.restore();\n    }\n    for(int c = 1; c <= m_board->columns(); ++c) {\n        painter.save();\n        drawColumn(&painter, c);\n        painter.restore();\n    }\n    for(int r = 1; r <= m_board->ranks(); ++r) {\n        for(int c = 1; c <= m_board->columns(); ++c) {\n            painter.save();\n            drawField(&painter, c, r);\n            painter.restore();\n        }\n    }\n} \n```", "```cpp\nvoid ChessView::drawRank(QPainter *painter, int rank)\n{\n    QRect r = fieldRect(1, rank);\n    QRect rankRect = QRect(0, r.top(), r.left(), r.height())\n        .adjusted(2, 0, -2, 0);\n    QString rankText = QString::number(rank);\n    painter->drawText(rankRect,\n       Qt::AlignVCenter | Qt::AlignRight, rankText);\n}\n\nvoid ChessView::drawColumn(QPainter *painter, int column)\n{\n    QRect r = fieldRect(column, 1);\n    QRect columnRect =\n        QRect(r.left(), r.bottom(), r.width(), height() - r.bottom())\n        .adjusted(0, 2, 0, -2);\n    painter->drawText(columnRect,\n        Qt::AlignHCenter | Qt::AlignTop, QChar('a' + column - 1));\n} \n```", "```cpp\nvoid ChessView::drawField(QPainter *painter, int column, int rank)\n{\n    QRect rect = fieldRect(column, rank);\n    QColor fillColor = (column + rank) % 2 ?\n        palette().color(QPalette::Light) :\n        palette().color(QPalette::Mid);\n    painter->setPen(palette().color(QPalette::Dark));\n    painter->setBrush(fillColor);\n    painter->drawRect(rect);\n} \n```", "```cpp\nChessView *m_view;\nChessAlgorithm *m_algorithm; \n```", "```cpp\nMainWindow::MainWindow(QWidget *parent) :\n  QMainWindow(parent),\n  ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    m_view = new ChessView;\n    m_algorithm = new ChessAlgorithm(this);\n    m_algorithm->newGame();\n    m_view->setBoard(m_algorithm->board());\n    setCentralWidget(m_view);\n    m_view->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);\n    m_view->setFieldSize(QSize(50,50));\n    layout()->setSizeConstraint(QLayout::SetFixedSize);\n} \n```", "```cpp\npublic:\n    void setPiece(char type, const QIcon &icon);\n    QIcon piece(char type) const;\nprivate:\n    QMap<char, QIcon> m_pieces; \n```", "```cpp\nvoid ChessView::setPiece(char type, const QIcon &icon)\n{\n    m_pieces.insert(type, icon);\n    update();\n}\n\nQIcon ChessView::piece(char type) const\n{\n    return m_pieces.value(type, QIcon());\n} \n```", "```cpp\nm_view->setPiece('P', QIcon(\":/pieces/Chess_plt45.svg\")); // pawn\nm_view->setPiece('K', QIcon(\":/pieces/Chess_klt45.svg\")); // king\nm_view->setPiece('Q', QIcon(\":/pieces/Chess_qlt45.svg\")); // queen\nm_view->setPiece('R', QIcon(\":/pieces/Chess_rlt45.svg\")); // rook\nm_view->setPiece('N', QIcon(\":/pieces/Chess_nlt45.svg\")); // knight\nm_view->setPiece('B', QIcon(\":/pieces/Chess_blt45.svg\")); // bishop\n\nm_view->setPiece('p', QIcon(\":/pieces/Chess_pdt45.svg\")); // pawn\nm_view->setPiece('k', QIcon(\":/pieces/Chess_kdt45.svg\")); // king\nm_view->setPiece('q', QIcon(\":/pieces/Chess_qdt45.svg\")); // queen\nm_view->setPiece('r', QIcon(\":/pieces/Chess_rdt45.svg\")); // rook\nm_view->setPiece('n', QIcon(\":/pieces/Chess_ndt45.svg\")); // knight\nm_view->setPiece('b', QIcon(\":/pieces/Chess_bdt45.svg\")); // bishop \n```", "```cpp\nvoid ChessView::paintEvent(QPaintEvent *)\n{\n    // ...\n    for(int r = m_board->ranks(); r > 0; --r) {\n        for(int c = 1; c <= m_board->columns(); ++c) {\n            drawPiece(&painter, c, r);\n        }\n    }\n} \n```", "```cpp\nvoid ChessView::drawPiece(QPainter *painter, int column, int rank)\n{\n    QRect rect = fieldRect(column, rank);\n    char value = m_board->data(column, rank);\n    if(value != ' ') {\n        QIcon icon = piece(value);\n        if(!icon.isNull()) {\n            icon.paint(painter, rect, Qt::AlignCenter);\n        }\n    }\n} \n```", "```cpp\nvoid ChessAlgorithm::newGame()\n{\n  setupBoard();\n  board()->setFen(\n      \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\"\n  );\n} \n```", "```cpp\nQPoint ChessView::fieldAt(const QPoint &pt) const\n{\n    if(!m_board) {\n        return QPoint();\n    }\n    const QSize fs = fieldSize();\n    int offset = fontMetrics().width('M') + 4;\n    // 'M' is the widest letter\n    if(pt.x() < offset) {\n        return QPoint();\n    }\n    int c = (pt.x() - offset) / fs.width();\n    int r = pt.y() / fs.height();\n    if(c < 0 || c >= m_board->columns() ||\n       r < 0 || r >= m_board->ranks()) {\n        return QPoint();\n    }\n    return QPoint(c + 1, m_board->ranks() - r);\n    // max rank - r\n} \n```", "```cpp\nsignals:\n  void clicked(const QPoint &); \n```", "```cpp\nvoid ChessView::mouseReleaseEvent(QMouseEvent *event)\n{\n    QPoint pt = fieldAt(event->pos());\n    if(pt.isNull()) {\n        return;\n    }\n    emit clicked(pt);\n} \n```", "```cpp\nconnect(m_view, &ChessView::clicked,\n        this,   &MainWindow::viewClicked);\n```", "```cpp\nvoid MainWindow::viewClicked(const QPoint &field)\n{\n    if(m_clickPoint.isNull()) {\n        m_clickPoint = field;\n    } else {\n      if(field != m_clickPoint) {\n        m_view->board()->movePiece(\n          m_clickPoint.x(), m_clickPoint.y(),\n          field.x(), field.y()\n        );\n      }\n      m_clickPoint = QPoint();\n    }\n} \n```", "```cpp\nvoid ChessView::setBoard(ChessBoard *board)\n{\n    // ...\n    m_board = board;\n    // connect signals\n    if(board) {\n      connect(board, SIGNAL(dataChanged(int,int)),\n              this,  SLOT(update()));\n      connect(board, SIGNAL(boardReset()),\n              this,  SLOT(update()));\n    }\n    updateGeometry();\n} \n```", "```cpp\nclass ChessView : public QWidget\n    // ...\npublic:\n    class Highlight {\n    public:\n        Highlight() {}\n        virtual ~Highlight() {}\n        virtual int type() const { return 0; }\n    };\n    // ...\n}; \n```", "```cpp\nclass FieldHighlight : public Highlight {\npublic:\n    enum { Type = 1 };\n    FieldHighlight(int column, int rank, QColor color)\n      : m_field(column, rank), m_color(color) {}\n    inline int column() const { return m_field.x(); }\n    inline int rank() const { return m_field.y(); }\n    inline QColor color() const { return m_color; }\n    int type() const { return Type; }\nprivate:\n    QPoint m_field;\n    QColor m_color;\n}; \n```", "```cpp\npublic:\n    void addHighlight(Highlight *hl);\n    void removeHighlight(Highlight *hl);\n    inline Highlight *highlight(int index) const {\n        return m_highlights.at(index);\n    }\n    inline int highlightCount() const {\n        return m_highlights.size();\n    } \n```", "```cpp\nvoid ChessView::addHighlight(ChessView::Highlight *hl) {\n    m_highlights.append(hl); \n    update(); \n}\n\nvoid ChessView::removeHighlight(ChessView::Highlight *hl) { \n    m_highlights.removeOne(hl); \n    update(); \n} \n```", "```cpp\ndrawHighlights(&painter); \n```", "```cpp\nvoid ChessView::drawHighlights(QPainter *painter)\n{\n    for(int idx = 0; idx < highlightCount(); ++idx) {\n        Highlight *hl = highlight(idx);\n        if(hl->type() == FieldHighlight::Type) {\n            FieldHighlight *fhl = static_cast<FieldHighlight*>(hl);\n            QRect rect = fieldRect(fhl->column(), fhl->rank());\n            painter->fillRect(rect, fhl->color());\n        }\n    }\n} \n```", "```cpp\nvoid MainWindow::viewClicked(const QPoint &field)\n{\n    if(m_clickPoint.isNull()) {\n        if(m_view->board()->data(field.x(), field.y()) != ' ') {\n            m_clickPoint = field;\n            m_selectedField = new ChessView::FieldHighlight(\n              field.x(), field.y(), QColor(255, 0, 0, 50)\n            );\n            m_view->addHighlight(m_selectedField);\n        }\n    } else {\n        if(field != m_clickPoint) {\n            m_view->board()->movePiece(\n                m_clickPoint.x(), m_clickPoint.y(), field.x(), field.y()\n            );\n        };\n        m_clickPoint = QPoint();\n        m_view->removeHighlight(m_selectedField);\n        delete m_selectedField;\n        m_selectedField = nullptr;\n    }\n} \n```", "```cpp\nclass ChessAlgorithm : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(Result result READ result)\n    Q_PROPERTY(Player currentPlayer\n               READ currentPlayer\n               NOTIFY currentPlayerChanged)\npublic:\n    enum Result { NoResult, Player1Wins, Draw, Player2Wins };\n    Q_ENUM(Result)\n    enum Player { NoPlayer, Player1, Player2 };\n    Q_ENUM(Player)\n\n    explicit ChessAlgorithm(QObject *parent = 0);\n    ChessBoard* board() const;\n    inline Result result() const {\n        return m_result;\n    }\n    inline Player currentPlayer() const {\n        return m_currentPlayer;\n    }\n\nsignals:\n    void boardChanged(ChessBoard*);\n    void gameOver(Result);\n    void currentPlayerChanged(Player);\n\npublic slots:\n    virtual void newGame();\n    virtual bool move(int colFrom, int rankFrom, int colTo, int rankTo);\n    bool move(const QPoint &from, const QPoint &to);\n\nprotected:\n    virtual void setupBoard();\n    void setBoard(ChessBoard *board);\n    void setResult(Result);\n    void setCurrentPlayer(Player);\nprivate:\n    ChessBoard *m_board;\n    Result m_result;\n    Player m_currentPlayer;\n}; \n```", "```cpp\nvoid ChessAlgorithm::setResult(Result value)\n{\n    if(result() == value) {\n        return;\n    }\n    if(result() == NoResult) {\n        m_result = value;\n        emit gameOver(m_result);\n    } else {\n        m_result = value;\n    }\n}\n\nvoid ChessAlgorithm::setCurrentPlayer(Player value)\n{\n    if(currentPlayer() == value) {\n        return;\n    }\n    m_currentPlayer = value;\n    emit currentPlayerChanged(m_currentPlayer);\n} \n```", "```cpp\nbool ChessAlgorithm::move(int colFrom, int rankFrom,\n   int colTo, int rankTo)\n{\n    Q_UNUSED(colFrom)\n    Q_UNUSED(rankFrom)\n    Q_UNUSED(colTo)\n    Q_UNUSED(rankTo)\n    return false;\n} \n```", "```cpp\nbool ChessAlgorithm::move(const QPoint &from, const QPoint &to)\n{\n    return move(from.x(), from.y(), to.x(), to.y());\n} \n```", "```cpp\nclass FoxAndHounds : public ChessAlgorithm\n{\npublic:\n    FoxAndHounds(QObject *parent = 0);\n    void newGame();\n    bool move(int colFrom, int rankFrom, int colTo, int rankTo);\n}; \n```", "```cpp\nvoid FoxAndHounds::newGame()\n{\n    setupBoard();\n    board()->setFen(\"3p4/8/8/8/8/8/8/P1P1P1P1 w\");\n     // 'w' - white to move\n    m_fox = QPoint(5,8);\n    setResult(NoResult);\n    setCurrentPlayer(Player1);\n} \n```", "```cpp\nbool FoxAndHounds::move(int colFrom, int rankFrom,\n   int colTo, int rankTo)\n{\n    if(currentPlayer() == NoPlayer) {\n        return false;\n    }\n\n    // is there a piece of the right color?\n    char source = board()->data(colFrom, rankFrom);\n    if(currentPlayer() == Player1 && source != 'P') return false;\n    if(currentPlayer() == Player2 && source != 'p') return false;\n\n    // both can only move one column right or left\n    if(colTo != colFrom + 1 && colTo != colFrom - 1) return false;\n\n    // do we move within the board?\n    if(colTo < 1  || colTo  > board()->columns()) return false;\n    if(rankTo < 1 || rankTo > board()->ranks())   return false;\n\n    // is the destination field black?\n    if((colTo + rankTo) % 2) return false;\n\n    // is the destination field empty?\n    char destination = board()->data(colTo, rankTo);\n    if(destination != ' ') return false;\n\n    // is white advancing?\n    if(currentPlayer() == Player1 && rankTo <= rankFrom) return false;\n\n    board()->movePiece(colFrom, rankFrom, colTo, rankTo);\n    // make the move\n    if(currentPlayer() == Player2) {\n      m_fox = QPoint(colTo, rankTo); // cache fox position\n    }\n    // check win condition\n    if(currentPlayer() == Player2 && rankTo == 1) {\n        setResult(Player2Wins); // fox has escaped\n    } else if(currentPlayer() == Player1 && !foxCanMove()) {\n        setResult(Player1Wins); // fox can't move\n    } else {\n        // the other player makes the move now\n        setCurrentPlayer(currentPlayer() == Player1 ? Player2 : Player1);\n    }\n    return true;\n} \n```", "```cpp\nbool FoxAndHounds::foxCanMove() const\n{\n    if(emptyByOffset(-1, -1) || emptyByOffset(-1, 1) ||\n       emptyByOffset( 1, -1) || emptyByOffset( 1, 1)) {\n        return true;\n    }\n    return false;\n} \n```", "```cpp\nbool FoxAndHounds::emptyByOffset(int x, int y) const\n{\n    const int destCol = m_fox.x() + x;\n    const int destRank = m_fox.y() + y;\n    if(destCol < 1 || destRank < 1 ||\n       destCol >  board()->columns() ||\n       destRank > board()->ranks()) {\n        return false;\n    }\n    return (board()->data(destCol, destRank) == ' ');\n} \n```", "```cpp\nvoid MainWindow::viewClicked(const QPoint &field)\n{\n    if(m_clickPoint.isNull()) {\n        // ...\n    } else {\n        if(field != m_clickPoint) {\n            m_algorithm->move(m_clickPoint, field);\n        }\n        // ...\n    }\n} \n```", "```cpp\nclass UciEngine : public QObject {\n    Q_OBJECT\npublic:\n    UciEngine(QObject *parent = 0) : QObject(parent) {\n        m_uciEngine = new QProcess(this);\n        m_uciEngine->setReadChannel(QProcess::StandardOutput);\n        connect(m_uciEngine, SIGNAL(readyRead()), SLOT(readFromEngine()));\n    }\npublic slots:\n    void startEngine(const QString &enginePath) {\n        m_uciEngine->start(enginePath);\n    }\n    void sendCommand(const QString &command) {\n        m_uciEngine->write(command.toLatin1());\n    }\nprivate slots:\n    void readFromEngine() {\n        while(m_uciEngine->canReadLine()) {\n            QString line = QString::fromLatin1(m_uciEngine->readLine());\n            emit messageReceived(line);\n        }\n    }\nsignals:\n    void messageReceived(QString);\nprivate:\n    QProcess *m_uciEngine;\n}; \n```"]