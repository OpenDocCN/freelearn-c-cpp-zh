- en: Appendix A
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A
- en: 'In this section of the book, we will look at some additional recipes that were
    outside the scope of [Chapter 3](caff231f-af25-4be5-a3b1-c4db3d65939d.xhtml),
    *Exploring Functions*:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将探讨一些超出[第 3 章](caff231f-af25-4be5-a3b1-c4db3d65939d.xhtml)“探索函数”范围的其他菜谱：
- en: Creating a sequential file and entering some text into it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个顺序文件并将一些文本输入到它里面
- en: Reading content from a sequential file and displaying it onscreen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从顺序文件读取内容并在屏幕上显示
- en: Creating a random file and entering some data into it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个随机文件并将一些数据输入到它里面
- en: Reading content from a random file and displaying it onscreen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从随机文件读取内容并在屏幕上显示
- en: Decrypting the contents of an encrypted file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密加密文件的内容
- en: Creating a sequential file and entering some data into it
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个顺序文件并将一些数据输入到它里面
- en: In this recipe, we will be creating a sequential file and the user can enter
    any desired number of lines into it. The name of the file to be created is passed
    through command line arguments. You can enter as many lines in the file as you
    want and, when finished, you have to type `stop`, followed by pressing the *Enter*
    key.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个顺序文件，用户可以输入任意数量的行到它里面。要创建的文件名将通过命令行参数传递。你可以输入任意多的行到文件中，完成时，你必须输入
    `stop`，然后按 *Enter* 键。
- en: How to do it…
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open a sequential file in write-only mode and point to it with a file pointer:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以只写模式打开一个顺序文件，并用文件指针指向它：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enter the content for the file when prompted:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时输入文件内容：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter `stop` when you are done entering the file content:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成输入文件内容时，请输入 `stop`：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the string you entered is not `stop`, the string is written into the file:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你输入的字符串不是 `stop`，则该字符串将被写入文件：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Close the file pointer to release all the resources allocated to the file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件指针以释放分配给文件的所有资源：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `createtextfile.c` program for creating a sequential file is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建顺序文件的 `createtextfile.c` 程序如下：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解它。
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define a file pointer by the name `fp`. We will open the sequential file,
    whose name is supplied through the command-line argument, in write-only mode and
    set the `fp` file pointer to point at it. If the file cannot be opened in write-only
    mode, it might be because there are not enough permissions or disk space constraints.
    An error message will be displayed and the program will terminate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过名称 `fp` 定义一个文件指针。我们将以只写模式打开通过命令行参数提供的顺序文件，并将 `fp` 文件指针设置为指向它。如果文件无法以只写模式打开，可能是因为权限不足或磁盘空间限制。将显示错误消息，程序将终止。
- en: If the file opens successfully in write-only mode, you will be prompted to enter
    the contents for the file. All the text you enter will be assigned to the `str`
    string variable, which is then written into the file. You should enter `stop`
    when you have completed entering the content into the file. Finally, we will close
    the file pointer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件以只写模式成功打开，你将被提示输入文件内容。你输入的所有文本都将分配给 `str` 字符串变量，然后写入文件。完成输入文件内容后，你应该输入 `stop`。最后，我们将关闭文件指针。
- en: 'Let''s use GCC to compile the `createtextfile.c` program, as shown in the following
    statement:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `createtextfile.c` 程序，如下所示：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you get no errors or warnings, it means that the `createtextfile.c` program
    has been compiled into an executable file, `createtextfile.exe`. Let''s run this
    executable file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着 `createtextfile.c` 程序已经被编译成了一个可执行文件，名为 `createtextfile.exe`。让我们运行这个可执行文件：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Voila! We've successfully created a sequential file and entered data in it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功创建了一个顺序文件并在其中输入了数据。
- en: Now let's move on to the next recipe!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个菜谱！
- en: Reading content from a sequential file and displaying it onscreen
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从顺序文件读取内容并在屏幕上显示
- en: In this recipe, we assume that a sequential file already exists, so we will
    be reading the contents of that file and displaying it onscreen. The name of the
    file whose contents we want to read will be supplied through command-line arguments.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们假设一个顺序文件已经存在，因此我们将读取该文件的内容并在屏幕上显示。我们想要读取内容的文件名将通过命令行参数提供。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the sequential file in read-only mode and set the `fp` file pointer to
    point at it:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以只读模式打开顺序文件并将 `fp` 文件指针设置为指向它：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The program terminates if the file cannot be opened in read-only mode:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件无法以只读模式打开，程序将终止：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set a `while` loop to execute until the end of the file is reached:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个`while`循环，直到文件末尾：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the `while` loop, one line at a time is read from the file and is displayed
    onscreen:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，一次读取一行文件并显示在屏幕上：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Close the file pointer to release all the resources allocated to the file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件指针以释放分配给文件的所有资源：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `readtextfile.c` program for reading a sequential file is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 读取顺序文件的`readtextfile.c`程序如下：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的情况。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We will define a file pointer is defined by the name of `fp` and a string by
    the name of `buffer` of size 255\. We will open the sequential file, whose name
    is supplied through the command-line argument, in read-only mode and set the `fp`
    file pointer to point at it. If the file cannot be opened in read-only mode because
    the file does not exist or because of a lack of enough permissions, an error message
    will be displayed and the program will terminate.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`fp`的文件指针和一个名为`buffer`的字符串，大小为255。我们将以只读模式打开通过命令行参数提供的顺序文件，并将`fp`文件指针设置为指向它。如果因为文件不存在或权限不足而无法以只读模式打开文件，将显示错误消息，程序将终止。
- en: If the file opens successfully in read-only mode, set a `while` loop to execute
    until the end of the file is reached. Use the `fgets` function to read one line
    at a time from the file; the line read from the file is assigned to the `buffer`
    string. Then, display the content in the `buffer` string onscreen. When the end
    of the file has been reached, the `while` loop will terminate and the file pointer
    is closed to release all the resources allocated to the file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件以只读模式成功打开，设置一个`while`循环，直到文件末尾。使用`fgets`函数逐行从文件中读取；从文件中读取的行被分配给`buffer`字符串。然后，在屏幕上显示`buffer`字符串中的内容。当到达文件末尾时，`while`循环将终止，文件指针被关闭以释放分配给文件的所有资源。
- en: 'Let''s use GCC to compile the `readtextfile.c` program, as shown in the following
    statement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`readtextfile.c`程序，如下所示：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you get no errors or warnings, this means that the `readtextfile.c` program
    has been compiled into an executable file, `readtextfile.exe`. Assuming the file
    whose content we want to read is textfile.txt, let''s run the executable file,
    `readtextfile.exe`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`readtextfile.c`程序已经被编译成一个可执行文件，`readtextfile.exe`。假设我们想要读取内容的文件是textfile.txt，让我们运行可执行文件`readtextfile.exe`：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Voila! We've successfully read the content from our sequential file and displayed
    it onscreen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功从我们的顺序文件中读取内容并在屏幕上显示。
- en: Now, let's move on to the next recipe!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到下一个菜谱！
- en: Creating a random file and entering some data into it
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个随机文件并将一些数据输入其中
- en: In this recipe, we will be creating a random file and we will enter some lines
    of text into it. The random files are structured, and the content in the random
    file is written via structures. The benefit of creating a file using structures
    is that we can compute the location of any structure directly and can access any
    content in the file randomly. The name of the file to be created is passed through
    command-line arguments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个随机文件，并将一些文本行输入其中。随机文件是有结构的，随机文件中的内容是通过结构写入的。使用结构创建文件的好处是我们可以直接计算任何结构的定位，并且可以随机访问文件中的任何内容。要创建的文件名通过命令行参数传递。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following are the steps to create a random file and enter a few lines of
    text in it. You can enter any number of lines as desired; simply type `stop`,
    followed by the *Enter* key, when you are done:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建随机文件并在其中输入几行文本的步骤如下。你可以输入任意数量的行；完成时，只需按`stop`，然后按`Enter`键：
- en: 'Define a structure consisting of a string member:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个由字符串成员组成的结构：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open a random file in write-only mode and point to it with a file pointer:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以只写模式打开一个随机文件，并用文件指针指向它：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The program will terminate if the file cannot be opened in write-only mode:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件无法以只写模式打开，程序将终止：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Enter the file contents when prompted and store it into the structure members:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示时输入文件内容并将其存储到结构成员中：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the text entered is not `stop`, the structure containing the text is written
    into the file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的文本不是`stop`，则包含该文本的结构将被写入文件：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Steps 4 and 5 are repeated until you enter `stop`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤4和5，直到你输入`stop`。
- en: 'When you enter `stop`, the file pointed at by the file pointer is closed to
    release the resources allocated to the file:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入`stop`时，指向文件的文件指针被关闭以释放分配给文件的资源：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `createrandomfile.c` program for creating a random file is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建随机文件的`createrandomfile.c`程序如下：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解一下代码。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's start by defining a structure by the name `data` consisting of a member `str`,
    which is a string variable of size 255\. Then we will define a file pointer by
    the name `fp`, followed by a variable line as a type data structure, so the line
    becomes a structure with a member called `str`. We will open a random file, whose
    name is supplied through a command-line argument, in write-only mode and set the `fp`
    file pointer to point at it. If the file cannot be opened in write-only mode for
    any reason, an error message will be displayed and the program will terminate.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个名为`data`的结构体开始，它包含一个名为`str`的成员，这是一个大小为255的字符串变量。然后我们将定义一个名为`fp`的文件指针，接着是一个类型为`data`结构体的变量`line`，这样行就变成了一个包含名为`str`的成员的结构体。我们将以只写模式打开一个名为通过命令行参数提供的随机文件，并将`fp`文件指针设置为指向它。如果由于任何原因无法以只写模式打开文件，将显示错误消息，程序将终止。
- en: You will be prompted to enter the file contents. The text you enter will be
    assigned to the `str` member of the line structure. Because you are supposed to
    enter `stop` to indicate that you have finished entering data in the file, the
    text you entered will be compared with the `stop` string. If the text entered
    is not `stop`, it is written into the file pointed at by the `fp` file pointer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入文件内容。你输入的文本将被分配给行结构体的`str`成员。因为你应该输入`stop`来表示你已完成文件中的数据输入，所以你输入的文本将与`stop`字符串进行比较。如果输入的文本不是`stop`，它将被写入由`fp`文件指针指向的文件。
- en: Because it is a random file, the text is written into the file through the structure
    line. The `fwrite` function writes the number of bytes equal to the size of the
    structure line into the file pointed at by the `fp` pointer at its current position.
    The text in the `str` member of the line structure is written into the file. When
    the text entered by the user is `stop`, the file pointed at by file pointer, the
    `fp` file pointer is closed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是随机文件，所以文本通过结构行写入文件。`fwrite`函数将等于结构行大小的字节数写入由`fp`指针指向的文件在其当前位置。行结构中的`str`成员中的文本被写入文件。当用户输入的文本是`stop`时，指向文件的文件指针`fp`被关闭。
- en: 'Let''s use GCC to compile the `createrandomfile.c` program, as shown in the
    following statement:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`createrandomfile.c`程序，如下所示：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you get no errors or warnings, this means that the `createrandomfile.c` program 
    has been compiled into an executable file, `createrandomfile.exe`. Assuming that
    we want to create a random file with the name `random.data`, let''s run the executable
    file, `createrandomfile.exe`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`createrandomfile.c`程序已经被编译成一个可执行文件，`createrandomfile.exe`。假设我们想要创建一个名为`random.data`的随机文件，让我们运行可执行文件`createrandomfile.exe`：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Voila! We've successfully created a random file and entered some data in it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功创建了一个随机文件并在其中输入了一些数据。
- en: Now let's move on to the next recipe!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个菜谱！
- en: Reading content from a random file and displaying it onscreen
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从随机文件读取内容并在屏幕上显示
- en: In this recipe, we will be reading the contents of a random file and will be
    displaying it on screen. Because the content in the random file comprises records,
    where the size of the record is already known, any record from the random file
    can be picked up randomly; hence, this type of file gets the name of *random file*.
    To access the *n*th record from a random file, we don't have to read all the *n*-1
    records first as we would do in a sequential file. We can compute the location
    of that record and can access it directly. The name of the file to be read is
    passed through command-line arguments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将读取随机文件的内容，并将其显示在屏幕上。因为随机文件中的内容由记录组成，其中记录的大小已经知道，所以可以从随机文件中随机选择任何记录；因此，这种类型的文件被称为*随机文件*。要从随机文件中访问第*n*条记录，我们不需要先读取前*n*-1条记录，就像在顺序文件中做的那样。我们可以计算该记录的位置，并直接访问它。要读取的文件名通过命令行参数传递。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Define a structure consisting of a string member:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含字符串成员的结构体：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open a random file in read-only mode and point at it with a file pointer:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以只读模式打开一个随机文件，并用文件指针指向它：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The program will terminate if the file cannot be opened in read-only mode:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件无法以只读模式打开，程序将终止：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Find the total number of bytes in the file. Divide the retrieved total number
    of bytes in the file by the size of one record to get the total number of records
    in the file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到文件中的总字节数。将检索到的文件总字节数除以每条记录的大小，以获取文件中的总记录数：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use a `for` loop to read one record at a time from the file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环一次读取文件中的一个记录：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The content read from the random file is via the structure defined in step
    1\. Display the contents of the file by displaying the file content assigned to
    structure members:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从随机文件读取的内容是通过步骤1中定义的结构体获取的。通过显示分配给结构体成员的文件内容来显示文件内容：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The end of the file is reached when the `for` loop has finished. Close the
    file pointer to release the resources allocated to the file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`for`循环结束时，达到文件末尾。关闭文件指针以释放分配给文件的资源：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `readrandomfile.c` program for reading the content from a random file is
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 读取随机文件内容的`readrandomfile.c`程序如下：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We will define a structure by the name, `data`, consisting of a member, `str`,
    which is a string variable of size 255\. Then, a file pointer is defined by the
    name of `fp` and a variable line by the type data structure, so the line becomes
    a structure with a member called `str`. We will open a random file, whose name
    is supplied through the command-line argument, in read-only mode and set the `fp`
    file pointer to point at it. If the file cannot be opened in read-only mode for
    any reason, an error message will be displayed and the program will terminate.
    The file error can occur if any non-existing file is referred to, or if the file
    does not have enough permissions. If the file opens in read-only mode successfully,
    the next step is to find the total count of the number of records in the file.
    For this, the following formula is applied:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`data`的结构体，它包含一个名为`str`的成员，该成员是一个大小为255的字符串变量。然后，定义一个名为`fp`的文件指针和一个类型为数据结构`line`的变量，这样行就变成了一个具有名为`str`的成员的结构体。我们将以只读模式打开一个随机文件，其名称通过命令行参数提供，并将`fp`文件指针设置为指向它。如果由于任何原因无法以只读模式打开文件，将显示错误消息，并终止程序。如果引用了任何不存在的文件，或者文件没有足够的权限，则可能发生文件错误。如果文件成功以只读模式打开，下一步是找到文件中的记录总数。为此，应用以下公式：
- en: '*Total number of bytes in the file/size of one record*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件中的总字节数/每条记录的大小*'
- en: To find the total number of bytes in the file, first move the file pointer to
    the end of the file by invoking the `fseek` function. Thereafter, using the `ftell`
    function, retrieve the total number of bytes consumed by the file. We will then
    divide the total number of bytes in the file by the size of one record to determine
    the total count of records in the file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到文件中的总字节数，首先通过调用`fseek`函数将文件指针移动到文件末尾。然后，使用`ftell`函数检索文件消耗的总字节数。然后，我们将文件中的总字节数除以每条记录的大小，以确定文件中的总记录数。
- en: Now, we are ready to read one record at a time from the file, and to do so,
    we will move the file pointer to the beginning of the file. We will set a `for`
    loop to execute the same amount of times as the number of records in the file.
    Within the `for` loop, we will invoke the `fread` function to read one record
    at a time from the file. The text read from the file is assigned to the `str`
    member of the line structure. The content in the `str` member of the line structure
    is displayed onscreen. When the `for` loop terminates, the file pointed to by
    the `fp` file pointer is closed to release the resources allocated to the file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好一次读取文件中的一个记录，为此，我们将文件指针移动到文件的开头。我们将设置一个`for`循环，使其执行次数与文件中的记录数相同。在`for`循环内部，我们将调用`fread`函数一次读取文件中的一个记录。从文件中读取的文本被分配给行结构体的`str`成员。行结构体中`str`成员的内容将在屏幕上显示。当`for`循环结束时，由`fp`文件指针指向的文件将被关闭，以释放分配给文件的资源。
- en: 'Let''s use GCC to compile the `readrandomfile.c` program , as shown in the
    following statement:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`readrandomfile.c`程序，如下所示：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you get no errors or warnings, this means that the `readrandomfile.c` program 
    has been compiled into an executable file, `readrandomfile.exe`. Assuming that
    we want to create a random file with the name `random.data`, let''s run the executable
    file, `readrandomfile.exe`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，这意味着`readrandomfile.c`程序已被编译成可执行文件，`readrandomfile.exe`。假设我们想要创建一个名为`random.data`的随机文件，让我们运行可执行文件，`readrandomfile.exe`：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Voila! We've successfully read the content from a random file and displayed
    it onscreen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功从随机文件中读取内容并在屏幕上显示它。
- en: Now let's move on to the next recipe!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个菜谱！
- en: Decrypting the contents of an encrypted file
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密加密文件的内容
- en: In this recipe, we will be reading an encrypted file. We will be decrypting
    its content and writing the decrypted contents into another sequential file. Both
    filenames, the encrypted one and the one with which we will save the decrypted
    version, are supplied through command-line arguments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将读取一个加密文件。我们将解密其内容，并将解密后的内容写入另一个顺序文件。两个文件名，加密文件和我们将保存解密版本的文件，都是通过命令行参数提供的。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Two files are used in this program. One is opened in read-only mode and the
    other is opened in write-only mode. The contents of one file is read and decrypted,
    and the decrypted content is stored in another file. The following are the steps
    to decrypt an existing encrypted file and save the decrypted version into another
    file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中使用了两个文件。一个是只读模式打开的，另一个是只写模式打开的。读取并解密一个文件的内容，并将解密内容存储在另一个文件中。以下是将现有加密文件解密并保存到另一个文件的步骤：
- en: 'Open two files, one in read-only and the other in write-only mode:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以只读和只写模式打开两个文件：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If either of the files cannot be opened in their respective modes, the program
    will terminate after displaying an error message:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任一文件无法以相应模式打开，程序将在显示错误消息后终止：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set a `while` loop to execute. It will read one line at a time from the file
    to be read:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个`while`循环来执行。它将逐行从要读取的文件中读取：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The length of the line that is read from the file is computed:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取的行的长度被计算：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set a `for` loop to execute. This will access all the characters of the line
    one by one:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个`for`循环来执行。这将逐个访问行的所有字符：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the value of `45` to the ASCII value of each character to decrypt it. I
    assume that ASCII value `45` was deducted from each character to encrypt the file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`45`的值加到每个字符的ASCII值上以解密它。我假设每个字符的ASCII值减去`45`以加密文件：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The decrypted line is written into the second file:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密后的行将被写入第二个文件：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When the `while` loop has finished (read, which is the file being decrypted),
    both the file pointers are closed to release the resources allocated to them:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`while`循环完成后（读取，即正在解密的文件），两个文件指针都将被关闭以释放分配给它们的资源：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `decryptfile.c` program for decrypting an encrypted file is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解密加密文件的`decryptfile.c`程序如下：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will define two file pointers, `fp` and `fq`. We will open the first file
    that is supplied through the command-line argument in read-only mode, and the
    second file in write-only mode. If the files cannot be opened in the read-only
    mode and write-only mode, respectively, an error message will be displayed and
    the program will terminate. The file that opens in read-only mode is pointed at
    by the `fp` file pointer and the file that opens in write-only mode is pointed
    at by the file `fq` file pointer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义两个文件指针，`fp`和`fq`。我们将以只读模式打开通过命令行参数提供的第一个文件，并将第二个文件以只写模式打开。如果无法以只读模式和只写模式分别打开文件，将显示错误消息，程序将终止。以只读模式打开的文件由`fp`文件指针指向，以只写模式打开的文件由`fq`文件指针指向。
- en: We will set a `while` loop to execute, which will read all the lines from the
    file pointed at by the `fp` pointer  one by one. The `while` loop will continue
    to execute until the end of the file pointed at by `fp` is reached.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个`while`循环来执行，该循环将逐行读取由`fp`指针指向的文件的每一行。`while`循环将继续执行，直到到达由`fp`指向的文件的末尾。
- en: .Within the `while` loop, a line is read and is assigned to the `buffer` string
    variable. The length of the line is computed.  We will then set a `for` loop is
    set to execute up until the end of the line; that is, each character of the line
    is accessed. We will add the value `45` to the ASCII value of each character to
    encrypt it. Thereafter, we will write the decrypted line into the second file.
    The file is pointed at by the `fq` file pointer. When the file from which the
    content was read is finished with, both the file pointers are closed to release
    the resources allocated to both the files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，读取一行并将其分配给 `buffer` 字符串变量。计算行的长度。然后设置一个 `for` 循环，执行到行的末尾；也就是说，访问行的每个字符。我们将把值
    `45` 添加到每个字符的 ASCII 值以加密它。之后，我们将解密后的行写入第二个文件。该文件由 `fq` 文件指针指向。当读取内容的文件完成时，关闭两个文件指针以释放分配给两个文件的资源。
- en: 'Let''s use GCC to compile the `decryptfile.c` program, as shown in the following
    statement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `decryptfile.c` 程序，如下所示：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Assume the encrypted file is named `encrypted.txt`. Let''s see the encrypted
    text in this file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设加密文件命名为 `encrypted.txt`。让我们看看这个文件中的加密文本：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding command is executed in Windows' Command Prompt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令是在 Windows 的命令提示符中执行的。
- en: 'If you get no errors or warnings while compiling the file, this means that
    the `decryptfile.c` program  has been compiled into an executable file, `decryptfile.exe`.
    Assume that an encrypted file by the name of `encrypted.txt` already exists and
    you want to decrypt it into another file, `originalfile.txt`. So, let''s run the
    executable, `decryptfile.exe`, to decrypt the  `encrypted.txt` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译文件时没有错误或警告，这意味着 `decryptfile.c` 程序已经被编译成一个可执行文件，名为 `decryptfile.exe`。假设已经存在一个名为
    `encrypted.txt` 的加密文件，并且你想将其解密到另一个文件中，名为 `originalfile.txt`。因此，让我们运行可执行文件 `decryptfile.exe`
    来解密 `encrypted.txt` 文件：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s see the contents of `orignalfile.txt` to see whether it contains the
    decrypted version of the file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看 `orignalfile.txt` 的内容，看看它是否包含文件的解密版本：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Voila! You can see that `originalfile.txt` contains the decrypted file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你可以看到 `originalfile.txt` 包含了解密后的文件。
