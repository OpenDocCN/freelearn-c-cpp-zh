- en: Appendix A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section of the book, we will look at some additional recipes that were
    outside the scope of [Chapter 3](caff231f-af25-4be5-a3b1-c4db3d65939d.xhtml),
    *Exploring Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sequential file and entering some text into it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading content from a sequential file and displaying it onscreen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a random file and entering some data into it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading content from a random file and displaying it onscreen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting the contents of an encrypted file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sequential file and entering some data into it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be creating a sequential file and the user can enter
    any desired number of lines into it. The name of the file to be created is passed
    through command line arguments. You can enter as many lines in the file as you
    want and, when finished, you have to type `stop`, followed by pressing the *Enter*
    key.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a sequential file in write-only mode and point to it with a file pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the content for the file when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter `stop` when you are done entering the file content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the string you entered is not `stop`, the string is written into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the file pointer to release all the resources allocated to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createtextfile.c` program for creating a sequential file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define a file pointer by the name `fp`. We will open the sequential file,
    whose name is supplied through the command-line argument, in write-only mode and
    set the `fp` file pointer to point at it. If the file cannot be opened in write-only
    mode, it might be because there are not enough permissions or disk space constraints.
    An error message will be displayed and the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: If the file opens successfully in write-only mode, you will be prompted to enter
    the contents for the file. All the text you enter will be assigned to the `str`
    string variable, which is then written into the file. You should enter `stop`
    when you have completed entering the content into the file. Finally, we will close
    the file pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `createtextfile.c` program, as shown in the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, it means that the `createtextfile.c` program
    has been compiled into an executable file, `createtextfile.exe`. Let''s run this
    executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Voila! We've successfully created a sequential file and entered data in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Reading content from a sequential file and displaying it onscreen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we assume that a sequential file already exists, so we will
    be reading the contents of that file and displaying it onscreen. The name of the
    file whose contents we want to read will be supplied through command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the sequential file in read-only mode and set the `fp` file pointer to
    point at it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The program terminates if the file cannot be opened in read-only mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a `while` loop to execute until the end of the file is reached:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `while` loop, one line at a time is read from the file and is displayed
    onscreen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the file pointer to release all the resources allocated to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readtextfile.c` program for reading a sequential file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define a file pointer is defined by the name of `fp` and a string by
    the name of `buffer` of size 255\. We will open the sequential file, whose name
    is supplied through the command-line argument, in read-only mode and set the `fp`
    file pointer to point at it. If the file cannot be opened in read-only mode because
    the file does not exist or because of a lack of enough permissions, an error message
    will be displayed and the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: If the file opens successfully in read-only mode, set a `while` loop to execute
    until the end of the file is reached. Use the `fgets` function to read one line
    at a time from the file; the line read from the file is assigned to the `buffer`
    string. Then, display the content in the `buffer` string onscreen. When the end
    of the file has been reached, the `while` loop will terminate and the file pointer
    is closed to release all the resources allocated to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `readtextfile.c` program, as shown in the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, this means that the `readtextfile.c` program
    has been compiled into an executable file, `readtextfile.exe`. Assuming the file
    whose content we want to read is textfile.txt, let''s run the executable file,
    `readtextfile.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Voila! We've successfully read the content from our sequential file and displayed
    it onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a random file and entering some data into it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be creating a random file and we will enter some lines
    of text into it. The random files are structured, and the content in the random
    file is written via structures. The benefit of creating a file using structures
    is that we can compute the location of any structure directly and can access any
    content in the file randomly. The name of the file to be created is passed through
    command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to create a random file and enter a few lines of
    text in it. You can enter any number of lines as desired; simply type `stop`,
    followed by the *Enter* key, when you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a structure consisting of a string member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a random file in write-only mode and point to it with a file pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will terminate if the file cannot be opened in write-only mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the file contents when prompted and store it into the structure members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the text entered is not `stop`, the structure containing the text is written
    into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Steps 4 and 5 are repeated until you enter `stop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you enter `stop`, the file pointed at by the file pointer is closed to
    release the resources allocated to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createrandomfile.c` program for creating a random file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by defining a structure by the name `data` consisting of a member `str`,
    which is a string variable of size 255\. Then we will define a file pointer by
    the name `fp`, followed by a variable line as a type data structure, so the line
    becomes a structure with a member called `str`. We will open a random file, whose
    name is supplied through a command-line argument, in write-only mode and set the `fp`
    file pointer to point at it. If the file cannot be opened in write-only mode for
    any reason, an error message will be displayed and the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted to enter the file contents. The text you enter will be
    assigned to the `str` member of the line structure. Because you are supposed to
    enter `stop` to indicate that you have finished entering data in the file, the
    text you entered will be compared with the `stop` string. If the text entered
    is not `stop`, it is written into the file pointed at by the `fp` file pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is a random file, the text is written into the file through the structure
    line. The `fwrite` function writes the number of bytes equal to the size of the
    structure line into the file pointed at by the `fp` pointer at its current position.
    The text in the `str` member of the line structure is written into the file. When
    the text entered by the user is `stop`, the file pointed at by file pointer, the
    `fp` file pointer is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `createrandomfile.c` program, as shown in the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, this means that the `createrandomfile.c` program 
    has been compiled into an executable file, `createrandomfile.exe`. Assuming that
    we want to create a random file with the name `random.data`, let''s run the executable
    file, `createrandomfile.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Voila! We've successfully created a random file and entered some data in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Reading content from a random file and displaying it onscreen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be reading the contents of a random file and will be
    displaying it on screen. Because the content in the random file comprises records,
    where the size of the record is already known, any record from the random file
    can be picked up randomly; hence, this type of file gets the name of *random file*.
    To access the *n*th record from a random file, we don't have to read all the *n*-1
    records first as we would do in a sequential file. We can compute the location
    of that record and can access it directly. The name of the file to be read is
    passed through command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a structure consisting of a string member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a random file in read-only mode and point at it with a file pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will terminate if the file cannot be opened in read-only mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the total number of bytes in the file. Divide the retrieved total number
    of bytes in the file by the size of one record to get the total number of records
    in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a `for` loop to read one record at a time from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The content read from the random file is via the structure defined in step
    1\. Display the contents of the file by displaying the file content assigned to
    structure members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The end of the file is reached when the `for` loop has finished. Close the
    file pointer to release the resources allocated to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readrandomfile.c` program for reading the content from a random file is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will define a structure by the name, `data`, consisting of a member, `str`,
    which is a string variable of size 255\. Then, a file pointer is defined by the
    name of `fp` and a variable line by the type data structure, so the line becomes
    a structure with a member called `str`. We will open a random file, whose name
    is supplied through the command-line argument, in read-only mode and set the `fp`
    file pointer to point at it. If the file cannot be opened in read-only mode for
    any reason, an error message will be displayed and the program will terminate.
    The file error can occur if any non-existing file is referred to, or if the file
    does not have enough permissions. If the file opens in read-only mode successfully,
    the next step is to find the total count of the number of records in the file.
    For this, the following formula is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Total number of bytes in the file/size of one record*'
  prefs: []
  type: TYPE_NORMAL
- en: To find the total number of bytes in the file, first move the file pointer to
    the end of the file by invoking the `fseek` function. Thereafter, using the `ftell`
    function, retrieve the total number of bytes consumed by the file. We will then
    divide the total number of bytes in the file by the size of one record to determine
    the total count of records in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to read one record at a time from the file, and to do so,
    we will move the file pointer to the beginning of the file. We will set a `for`
    loop to execute the same amount of times as the number of records in the file.
    Within the `for` loop, we will invoke the `fread` function to read one record
    at a time from the file. The text read from the file is assigned to the `str`
    member of the line structure. The content in the `str` member of the line structure
    is displayed onscreen. When the `for` loop terminates, the file pointed to by
    the `fp` file pointer is closed to release the resources allocated to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `readrandomfile.c` program , as shown in the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, this means that the `readrandomfile.c` program 
    has been compiled into an executable file, `readrandomfile.exe`. Assuming that
    we want to create a random file with the name `random.data`, let''s run the executable
    file, `readrandomfile.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Voila! We've successfully read the content from a random file and displayed
    it onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the contents of an encrypted file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be reading an encrypted file. We will be decrypting
    its content and writing the decrypted contents into another sequential file. Both
    filenames, the encrypted one and the one with which we will save the decrypted
    version, are supplied through command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two files are used in this program. One is opened in read-only mode and the
    other is opened in write-only mode. The contents of one file is read and decrypted,
    and the decrypted content is stored in another file. The following are the steps
    to decrypt an existing encrypted file and save the decrypted version into another
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open two files, one in read-only and the other in write-only mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If either of the files cannot be opened in their respective modes, the program
    will terminate after displaying an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a `while` loop to execute. It will read one line at a time from the file
    to be read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of the line that is read from the file is computed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a `for` loop to execute. This will access all the characters of the line
    one by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the value of `45` to the ASCII value of each character to decrypt it. I
    assume that ASCII value `45` was deducted from each character to encrypt the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The decrypted line is written into the second file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `while` loop has finished (read, which is the file being decrypted),
    both the file pointers are closed to release the resources allocated to them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decryptfile.c` program for decrypting an encrypted file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define two file pointers, `fp` and `fq`. We will open the first file
    that is supplied through the command-line argument in read-only mode, and the
    second file in write-only mode. If the files cannot be opened in the read-only
    mode and write-only mode, respectively, an error message will be displayed and
    the program will terminate. The file that opens in read-only mode is pointed at
    by the `fp` file pointer and the file that opens in write-only mode is pointed
    at by the file `fq` file pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We will set a `while` loop to execute, which will read all the lines from the
    file pointed at by the `fp` pointer  one by one. The `while` loop will continue
    to execute until the end of the file pointed at by `fp` is reached.
  prefs: []
  type: TYPE_NORMAL
- en: .Within the `while` loop, a line is read and is assigned to the `buffer` string
    variable. The length of the line is computed.  We will then set a `for` loop is
    set to execute up until the end of the line; that is, each character of the line
    is accessed. We will add the value `45` to the ASCII value of each character to
    encrypt it. Thereafter, we will write the decrypted line into the second file.
    The file is pointed at by the `fq` file pointer. When the file from which the
    content was read is finished with, both the file pointers are closed to release
    the resources allocated to both the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `decryptfile.c` program, as shown in the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume the encrypted file is named `encrypted.txt`. Let''s see the encrypted
    text in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command is executed in Windows' Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get no errors or warnings while compiling the file, this means that
    the `decryptfile.c` program  has been compiled into an executable file, `decryptfile.exe`.
    Assume that an encrypted file by the name of `encrypted.txt` already exists and
    you want to decrypt it into another file, `originalfile.txt`. So, let''s run the
    executable, `decryptfile.exe`, to decrypt the  `encrypted.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the contents of `orignalfile.txt` to see whether it contains the
    decrypted version of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Voila! You can see that `originalfile.txt` contains the decrypted file.
  prefs: []
  type: TYPE_NORMAL
