<html><head></head><body>
		<div><h1 id="_idParaDest-77"><em class="italic"><a id="_idTextAnchor076"/>Chapter 3</em>: STL Containers</h1>
			<p>In this chapter, we will focus on the container classes in the STL. In short, a <em class="italic">container</em> is an object that contains a collection of other objects, or <em class="italic">elements</em>. The STL provides a complete suite of container types that form the foundation of the STL itself.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>A quick overview of the STL container types</h1>
			<p>The STL provides a <a id="_idIndexMarker150"/>comprehensive set of container types, including <em class="italic">sequential containers</em>, <em class="italic">associative containers</em>, and <em class="italic">container adapters</em>. Here's a brief overview: </p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Sequential containers</h2>
			<p>The sequential containers <a id="_idIndexMarker151"/>provide an interface where the <a id="_idIndexMarker152"/>elements are arranged in sequence. While you may use the elements sequentially, some of these containers use contiguous storage, and others do not. The STL includes these sequential containers:</p>
			<ul>
				<li>The <code>array</code> is a<a id="_idIndexMarker153"/> fixed-size sequence that holds a specific <a id="_idIndexMarker154"/>number of elements in contiguous storage. Once allocated, it cannot change size. This is the simplest and fastest contiguous storage container.</li>
				<li>The <code>vector</code> is like an array <a id="_idIndexMarker155"/>that can shrink and grow. Its <a id="_idIndexMarker156"/>elements are stored contiguously, so changing size may involve the expense of allocating memory and moving data. A <code>vector</code> may keep extra space in reserve to mitigate that cost. Inserting and deleting elements from anywhere other than the <em class="italic">back</em> of a <code>vector</code> will trigger realignment of the elements to maintain contiguous storage.</li>
				<li>The <code>list</code> is a <a id="_idIndexMarker157"/>doubly-linked list structure that allows <a id="_idIndexMarker158"/>elements to be inserted and deleted in constant (<em class="italic">O(1)</em>) time. Traversing the list happens in linear <em class="italic">O(n)</em> time. A single-linked variant is available as <code>forward_list</code>, which only iterates forward. A <code>forward_list</code> uses less space and is somewhat more efficient than a doubly-linked <code>list</code>, but lacks some capability.</li>
				<li>The <code>deque</code> (commonly pronounced, <em class="italic">deck</em>) is a <code>deque</code> allows <a id="_idIndexMarker159"/>random access to its elements, much <a id="_idIndexMarker160"/>like a <code>vector</code>, but does not guarantee contiguous storage.</li>
			</ul>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Associative containers</h2>
			<p>An associative <a id="_idIndexMarker161"/>container associates a key with each <a id="_idIndexMarker162"/>element. Elements are referenced by their key, rather than their position in the container. STL associative containers include these containers:</p>
			<ul>
				<li>The <code>set</code> is an <a id="_idIndexMarker163"/>associative container where each element is <a id="_idIndexMarker164"/>also its own key. Elements are ordered, usually by some sort of binary tree. Elements in a <code>set</code> are immutable and cannot be modified, but they can be inserted and removed. Elements in a <code>set</code> are <em class="italic">unique</em>, duplicates are not allowed. A <code>set</code> iterates in order according to its sorting operators.</li>
				<li>The <code>multiset</code> is<a id="_idIndexMarker165"/> like<a id="_idIndexMarker166"/> a <code>set</code> with non-unique keys, where duplicates are allowed.</li>
				<li>The <code>unordered_set</code> is<a id="_idIndexMarker167"/> like a <code>set</code> that does not iterate in order. Elements are not sorted <a id="_idIndexMarker168"/>in any specific order, but are organized according to their hash values for fast access.</li>
				<li>The <code>unordered_multiset</code> is<a id="_idIndexMarker169"/> like an <code>unordered_set</code> with non-unique keys, where <a id="_idIndexMarker170"/>duplicates are allowed.</li>
				<li>The <code>map</code> is an <a id="_idIndexMarker171"/>associative container for key-value pairs, where<a id="_idIndexMarker172"/> each <em class="italic">key</em> is mapped to a specific <em class="italic">value</em> (or <em class="italic">payload</em>). The types of the key and value may be different. Keys are unique but values are not. A map iterates in order of its keys, according to its sorting operators.</li>
				<li>The <code>multimap</code> is<a id="_idIndexMarker173"/> like a <code>map</code> with non-unique keys, where <a id="_idIndexMarker174"/>duplicate keys are allowed.</li>
				<li>The <code>unordered_map</code> is like <a id="_idIndexMarker175"/>a<a id="_idIndexMarker176"/> map that does not iterate in order.</li>
				<li>The <code>unordered_multimap</code> is <a id="_idIndexMarker177"/>like <a id="_idIndexMarker178"/>an <code>unordered_map</code> with non-unique keys, where duplicates are allowed.</li>
			</ul>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Container adapters</h2>
			<p>A container adapter<a id="_idIndexMarker179"/> is a class which encapsulates an <a id="_idIndexMarker180"/>underlying container. The container class provides a specific set of member functions to access the underlying container elements. The STL provides these container adapters:</p>
			<ul>
				<li>The <code>stack</code> provides <a id="_idIndexMarker181"/>a <code>vector</code>, <code>deque</code>, or <code>list</code>. If no underlying container is specified, the default is <code>deque</code>.</li>
				<li>The <code>queue</code> provides <a id="_idIndexMarker184"/>a <code>deque</code> or <code>list</code>. If no underlying container is specified, the default is <code>deque</code>.</li>
				<li>The <code>priority_queue</code> keeps <a id="_idIndexMarker187"/>the greatest value<a id="_idIndexMarker188"/> element at the top, according to a <em class="italic">strict weak ordering</em>. It provides a constant time lookup of the greatest value element, at the expense of logarithmic time insertion and extraction. The underlying container may be one of <code>vector</code> or <code>deque</code>. If no underlying container is specified, the default is <code>vector</code>.</li>
			</ul>
			<p>In this chapter we will cover the following recipes:</p>
			<ul>
				<li>Use uniform erasure functions to delete items from a container</li>
				<li>Delete items from an unsorted vector in constant time</li>
				<li>Access vector elements directly and safely</li>
				<li>Keep vector elements sorted</li>
				<li>Efficiently insert elements into a map</li>
				<li>Efficiently modify the keys of map items</li>
				<li>Use <code>unordered_map</code> with custom keys</li>
				<li>Use set to sort and filter user input</li>
				<li>A simple RPN calculator with deque</li>
				<li>A word frequency counter with map</li>
				<li>Find long sentences with a vector of vectors</li>
				<li>A ToDo list using multimap</li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Technical requirements</h1>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Use uniform erasure functions to delete items from a container</h1>
			<p>Before C++20, the <em class="italic">erase-remove idiom</em> was<a id="_idIndexMarker189"/> commonly <a id="_idIndexMarker190"/>used to efficiently delete elements from an STL container. This was a little cumbersome, but not a great burden. It was common to use a function like this for the task:</p>
			<pre>template&lt;typename Tc, typename Tv&gt;
void remove_value(Tc &amp; c, const Tv v) {
    auto remove_it = <strong class="bold">std::remove</strong>(c.begin(), c.end(), v);
    <strong class="bold">c.erase</strong>(remove_it, c.end());
}</pre>
			<p>The <code>std::remove()</code> function is from the <code>&lt;algorithms&gt;</code> header. <code>std::remove()</code> searches for the specified value and removes it by shifting elements forward from the end of the container. It does not change the size of the container. It returns an iterator past the end of the shifted range. We then call the container's <code>erase()</code> function to delete the remaining elements.</p>
			<p>This two-step process is now reduced to one step with the new uniform erasure function:</p>
			<pre><strong class="bold">std::erase(c, 5)</strong>;   // same as remove_value() function</pre>
			<p>This one function call does the same thing as the <code>remove_value()</code> function we wrote above.</p>
			<p>There's also a version that uses a predicate function. For example, to remove all even numbered values from a numeric container:</p>
			<pre>std::erase_if(c, [](auto x) { return x % 2 == 0; });</pre>
			<p>Let's look at the uniform erasure functions in a bit more detail.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>How to do it…</h2>
			<p>There are two forms of the uniform erasure functions. The first form, called <code>erase()</code>, takes two parameters, a container and a value:</p>
			<pre>erase(container, value); </pre>
			<p>The container may be any of the sequential containers (<code>vector</code>, <code>list</code>, <code>forward_list</code>, <code>deque</code>), except <code>array</code>, which cannot change size.</p>
			<p>The second form, called <code>erase_if()</code>, takes a container and a predicate function:</p>
			<pre>erase_if(container, predicate); </pre>
			<p>This form works with any of the containers that work with <code>erase()</code>, plus the associative containers, <code>set</code>, <code>map</code>, and their multi-key and unordered variants.</p>
			<p>The functions <code>erase()</code> and <code>erase_if()</code> are defined, as non-member functions, in the header for the corresponding container. There is no need to include another header.</p>
			<p>Let's look at some examples:</p>
			<ul>
				<li>First, let's <a id="_idIndexMarker191"/>define a simple<a id="_idIndexMarker192"/> function to print the size and elements of a sequential container:<pre>void printc(auto &amp; r) {
    cout &lt;&lt; format("size({}) ", r.size());
    for( auto &amp; e : r ) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; "\n";
}</pre></li>
			</ul>
			<p>The <code>printc()</code> function uses the C++20 <code>format()</code> function to format a string for <code>cout</code>.</p>
			<ul>
				<li>Here's a <code>vector</code> with 10 integer elements, printed with our <code>printc()</code> function:<pre>vector v{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };
printc(v);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">size: 10: 0 1 2 3 4 5 6 7 8 9</strong></pre>
			<p>We see that the vector has 10 elements. Now we can use <code>erase()</code> to remove all elements with the value <code>5</code>:</p>
			<pre><strong class="bold">erase</strong>(v, 5);
printc(v);</pre>
			<p>Output:</p>
			<pre><strong class="bold">size: 9: 0 1 2 3 4 6 7 8 9</strong></pre>
			<p>The <code>vector</code> version of the <code>std::erase()</code> function is defined in the <code>&lt;vector&gt;</code> header. After the <code>erase()</code> call, the element with the value 5 has been removed and the vector has 9 elements.</p>
			<ul>
				<li>This works<a id="_idIndexMarker193"/> just as well <a id="_idIndexMarker194"/>with a <code>list</code> container:<pre>list l{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
printc(l);
<strong class="bold">erase</strong>(l, 5);
printc(l);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">size: 10: 0 1 2 3 4 5 6 7 8 9</strong>
<strong class="bold">size: 9: 0 1 2 3 4 6 7 8 9</strong></pre>
			<p>The <code>list</code> version of the <code>std::erase()</code> function is defined in the <code>&lt;list&gt;</code> header. After the <code>erase()</code> call, the element with the value <code>5</code> has been removed and the <code>list</code> has 9 elements.</p>
			<ul>
				<li>We can use <code>erase_if()</code> to remove all the even numbered elements with a simple predicate function:<pre>vector v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
printc(v);
<strong class="bold">erase_if</strong>(v, [](auto x) { return x % 2 == 0; });
printc(v);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">size: 10: 0 1 2 3 4 5 6 7 8 9</strong>
<strong class="bold">size: 5: 1 3 5 7 9</strong></pre>
			<ul>
				<li>The <code>erase_if()</code> function <a id="_idIndexMarker195"/>also <a id="_idIndexMarker196"/>works with associative containers, like <code>map</code>:<pre>void print_assoc(auto&amp; r) {
    cout &lt;&lt; format("size: {}: ", r.size());
    for( <strong class="bold">auto&amp; [k, v]</strong> : r ) cout &lt;&lt; format("{}:{} ",
        k, v);
    cout &lt;&lt; "\n";
}
int main() {
    map&lt;int, string&gt; m{ {1, "uno"}, {2, "dos"},
        {3, "tres"}, {4, "quatro"}, {5, "cinco"} };
    print_assoc(m);
    <strong class="bold">erase_if</strong>(m, 
        [](auto&amp; p) { <strong class="bold">auto&amp; [k, v] = p</strong>;
        return k % 2 == 0; }
    );
    print_assoc(m);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">size: 5: 1:uno 2:dos 3:tres 4:quatro 5:cinco</strong>
<strong class="bold">size: 3: 1:uno 3:tres 5:cinco</strong></pre>
			<p>Because each element of a <code>map</code> is returned as a <code>pair</code>, we need a different function to print them. The <code>print_assoc()</code> function unpacks the <code>pair</code> elements with a <em class="italic">structured binding</em> in the <code>for</code> loop. We also use a structured binding in the predicate function of <code>erase_if()</code> to isolate the key for filtering the even numbered elements.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>How it works…</h2>
			<p>The <code>erase()</code> and <code>erase_if()</code> functions are simply wrappers that perform the <em class="italic">erase-remove idiom</em> in one step. They<a id="_idIndexMarker197"/> perform <a id="_idIndexMarker198"/>the same operations as a function, like this:</p>
			<pre>template&lt;typename Tc, typename Tv&gt;
void remove_value(Tc &amp; c, const Tv v) {
    auto remove_it = std::remove(c.begin(), c.end(), v);
    c.erase(remove_it, c.end());
}</pre>
			<p>If we consider a simple <code>vector</code> of <code>int</code>, called <code>vec</code>, with the following values:</p>
			<pre>vector vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</pre>
			<p>We can visualize <code>vec</code> as a one-row table of <code>int</code> values:</p>
			<div><div><img src="img/B18267_03_01.jpg" alt="Figure 3.1 – begin() and end() iterators&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – begin() and end() iterators</p>
			<p>The <code>begin()</code> iterator points at the first element, and the <code>end()</code> iterator points <em class="italic">past</em> the last element. This configuration is standard for all STL sequential containers.</p>
			<p>When we call <code>remove(c.begin(), c.end(), 5)</code>, the algorithm searches for matching elements, starting at the <code>begin()</code> iterator. For each matching element that it finds, it shifts the next element into its place. It continues searching and shifting until it reaches the <code>end()</code> iterator. The result is a container where all the remaining elements are at the beginning, without the deleted elements, and in their original order. The <code>end()</code> iterator is unchanged and the remaining elements are <em class="italic">undefined</em>. We can visualize the operation like this:</p>
			<div><div><img src="img/B18267_03_02.jpg" alt="Figure 3.2 – Removing an element&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Removing an element</p>
			<p>The <code>remove()</code> function<a id="_idIndexMarker199"/> returns<a id="_idIndexMarker200"/> an iterator (<code>remove_it</code>) that points to the first element <em class="italic">past</em> the elements that were shifted. The <code>end()</code> iterator remains as it was before the <code>remove() </code>operation. To further illustrate, if we were to remove all even-numbered elements using <code>remove_if()</code>, our result would look like this:</p>
			<div><div><img src="img/B18267_03_03.jpg" alt="Figure 3.3 – After removing even-numbered elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – After removing even-numbered elements</p>
			<p>In this case, all that remains is the five odd-numbered elements followed by five elements of <em class="italic">undefined</em> value.</p>
			<p>The container's <code>erase()</code> function is then called to erase the remaining elements:</p>
			<pre>c.erase(remove_it, c.end());</pre>
			<p>The container's <code>erase()</code> function is called with the <code>remove_it</code> and <code>end()</code> iterators to delete all the undefined elements.</p>
			<p>The <code>erase()</code> and <code>erase_if()</code> functions<a id="_idIndexMarker201"/> call <a id="_idIndexMarker202"/>both the <code>remove()</code> function and the container's <code>erase()</code> function, in order to perform the <em class="italic">erase-remove idiom</em> in one step.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Delete items from an unsorted vector in constant time</h1>
			<p>Using the uniform<a id="_idIndexMarker203"/> erasure functions (or the <em class="italic">erase-remove idiom</em>) to delete items from the middle of a vector takes <em class="italic">O(n)</em> (<em class="italic">linear</em>) time. This is because elements must be shifted from the end of the vector to close the gap of the deleted items. If the order of items in the vector is not important, we can optimize this process to take <em class="italic">O(1)</em> (<em class="italic">constant</em>) time. Here's how.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>How to do it…</h2>
			<p>This recipe takes advantage of the fact that removing an element from the end of a vector is quick and easy.</p>
			<ul>
				<li>Let's start by defining a function to print out a vector:<pre>void printc(auto &amp; r) {
    cout &lt;&lt; format("size({}) ", r.size());
    for( auto &amp; e : r ) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
				<li>In our <code>main()</code> function we define a vector of <code>int</code> and print it using <code>printc()</code>:<pre>int main() {
    vector v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    printc(v);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">size(10) 0 1 2 3 4 5 6 7 8 9</strong></pre>
			<ul>
				<li>Now we'll<a id="_idIndexMarker204"/> write the function that will delete an element from the vector:<pre>template&lt;typename T&gt;
void quick_delete(T&amp; v, size_t idx) {
    if (idx &lt; v.size()) {
        v[idx] = <strong class="bold">move(v.back())</strong>;
        <strong class="bold">v.pop_back()</strong>;
    }
}</pre></li>
			</ul>
			<p>The <code>quick_delete()</code> function takes two arguments, a vector <code>v</code> and an index <code>idx</code>. We first check to make sure our index is within boundaries. Then we call the <code>move()</code> function from the <code>&lt;algorithms&gt;</code> header to move the last element of the vector to the position of our index. Finally, the <code>v.pop_back()</code> function is called to shorten the vector from the back.</p>
			<ul>
				<li>Let's also include a version of <code>quick_delete()</code> for use with an iterator instead of an index.<pre>template&lt;typename T&gt;
void quick_delete(T&amp; v, typename T::iterator it) {
    if (it &lt; v.end()) {
        *it = <strong class="bold">move(v.back())</strong>;
        <strong class="bold">v.pop_back()</strong>;
    }
}</pre></li>
			</ul>
			<p>This<a id="_idIndexMarker205"/> version of <code>quick_delete()</code> operates from an iterator instead of an index. Otherwise, it works the same as the indexed version.</p>
			<ul>
				<li>Now we can call it from our <code>main()</code> function:<pre>int main() {
    vector v{ 12, 196, 47, 38, 19 };
    printc(v);
    auto it = std::ranges::find(v, 47);
    quick_delete(v, it);
    printc(v);
    quick_delete(v, 1);
    printc(v);
}</pre></li>
			</ul>
			<p>And the output will look like this:</p>
			<pre><strong class="bold">size(5) 12 196 47 38 19</strong>
<strong class="bold">size(4) 12 196 19 38</strong>
<strong class="bold">size(3) 12 38 19</strong></pre>
			<p>The first call to <code>quick_delete()</code> uses an iterator from the <code>std::ranges::find()</code><code> </code>algorithm. This deletes the value <code>47</code> from the vector. Notice the value from the back of the vector (<code>19</code>) takes its place. The second call to <code>quick_delete()</code> uses an index (<code>1</code>) to delete the second element from the vector (<code>196</code>). Again, the value from the back of the vector takes its place.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>How it works…</h2>
			<p>The <code>quick_delete()</code> function uses a simple trick to delete elements from a vector quickly and <a id="_idIndexMarker206"/>efficiently. The element at the back of the vector is moved (<em class="italic">not copied</em>) into the position of the element to be deleted. The deleted element is discarded in the process. Then, the <code>pop_back()</code> function shortens the vector by one element from the end.</p>
			<p>This takes advantage of the fact that deleting the element at the back of the vector is especially cheap. The <code>pop_back()</code> function operates at constant complexity, as it only needs to change the <code>end()</code> iterator.</p>
			<p>This diagram shows the state of the vector before and after the <code>quick_delete()</code> operation:</p>
			<div><div><img src="img/B18267_03_04.jpg" alt="Figure 3.4 – Before and after quick_delete()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Before and after quick_delete()</p>
			<p>The <code>quick_remove()</code> operation simply <em class="italic">moves</em> the element from the back of the vector into the position of the iterator (<code>it</code>), then shortens the vector by one element. It's important to use <code>std::move()</code> instead of an assignment to move the element. The move <a id="_idIndexMarker207"/>operation is much faster than a copy-assignment, especially for large objects.</p>
			<p>If you don't require ordered elements, this is an extremely efficient technique. It happens in constant (<em class="italic">O(1)</em>) time and without touching any other elements.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Access vector elements directly and safely</h1>
			<p>The <code>vector</code> is one of <a id="_idIndexMarker208"/>the most widely used containers in the STL, and for good reason. It's just as convenient as an <code>array</code> but far more powerful and flexible. It's common practice to use the <code>[]</code> operator to access elements in a vector like this:</p>
			<pre>vector v{ 19, 71, 47, 192, 4004 };
auto &amp; i = v[2];</pre>
			<p>The <code>vector</code> class also provides a member function for the same purpose:</p>
			<pre>auto &amp; i = v.at(2);</pre>
			<p>The result is the same but there is an important difference. The <code>at()</code> function does bounds checking and the <code>[]</code> operator does not. This is intentional, as it allows the <code>[]</code> operator to maintain compatibility with the original C-array. Let's examine this in a bit more detail.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>How to do it…</h2>
			<p>There are two ways to access an element with an index in a vector. The <code>at()</code> member function does bounds checking, and the <code>[]</code> operator does not.</p>
			<ul>
				<li>Here's a<a id="_idIndexMarker209"/> simple <code>main()</code> function that initializes a vector and accesses an element:<pre>int main() {
    vector v{ 19, 71, 47, 192, 4004 };
    auto &amp; i = v[2];
    cout &lt;&lt; format("element is {}\n", i);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">element is 47</strong></pre>
			<p>Here, I used the <code>[]</code> operator to directly access the third element in the vector. As with most sequential objects in C++, the index starts at <code>0</code> so the third element is number <code>2</code>.</p>
			<ul>
				<li>The vector has five elements, numbered <code>0</code> through <code>4</code>. If I were to try to access element number <code>5</code> that would be beyond the boundary of the vector:<pre>vector v{ 19, 71, 47, 192, 4004 };
auto &amp; i = v[5];
cout &lt;&lt; format("element is {}\n", i);
element is 0</pre></li>
			</ul>
			<p>This result is extremely deceiving. It's a common error, since humans tend to count from 1, not 0. But there is no guarantee that an element past the end of the vector has any particular value.</p>
			<ul>
				<li>Even worse, the <code>[]</code> operator will silently allow you to <em class="italic">write</em> to a position beyond the end of the vector:<pre>vector v{ 19, 71, 47, 192, 4004 };
v[5] = 2001;
auto &amp; i = v[5];
cout &lt;&lt; format("element is {}\n", i);
element is 2001</pre></li>
			</ul>
			<p>I have now written<a id="_idIndexMarker210"/> to memory that is not under my control and the compiler has <em class="italic">silently</em> allowed it, with no error messages or crashes. But do not be fooled—this is extremely dangerous code, and it <em class="italic">will</em> cause problems at some point in the future. Out of bounds memory access is one of the primary causes of security breaches.</p>
			<ul>
				<li>The solution is to use the <code>at()</code> member function wherever possible, instead of the <code>[]</code> operator:<pre>vector v{ 19, 71, 47, 192, 4004 };
auto &amp; i = v.at(5);
cout &lt;&lt; format("element is {}\n", i);</pre></li>
			</ul>
			<p>Now we get a run-time exception:</p>
			<pre>terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 5) &gt;= this-&gt;size() (which is 5)
Aborted</pre>
			<p>The code compiles without error, but the <code>at()</code> function checks the boundaries of the container and throws a <em class="italic">run-time exception</em> when you try to access memory outside of those boundaries. This is the exception message from code compiled with the GCC compiler. The message will be different in different environments.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>How it works…</h2>
			<p>The <code>[]</code> operator and the <code>at()</code> member function do the same job; they provide direct access to container elements based on their indexed position. The <code>[]</code> operator does it without any bounds checking, so it may be a tiny bit faster in some intensely iterative applications.</p>
			<p>That said, the <code>at()</code> function <em class="italic">should be your default choice</em>. While the bounds checking may take a few CPU cycles, it's cheap insurance. For most applications the benefit is well <a id="_idIndexMarker211"/>worth the cost.</p>
			<p>While the <code>vector</code> class is commonly used as a direct-access container, the <code>array</code> and <code>deque</code> containers also support both the <code>[]</code> operator and the <code>at()</code> member function. These caveats apply there as well.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>There's more…</h2>
			<p>In some applications you may not want your application to just <em class="italic">crash</em> when an out-of-bounds condition is encountered. In this case, you can <em class="italic">catch</em> the exception, like this:</p>
			<pre>int main() {
    vector v{ 19, 71, 47, 192, 4004 };
    try {
        v.at(5) = 2001;
    } catch (const std::out_of_range &amp; e) {
        std::cout &lt;&lt;
            format("Ouch!\n{}\n", e.what());
    }
    cout &lt;&lt; format("end element is {}\n", v.back());
}</pre>
			<p>Output:</p>
			<pre>Ouch!
vector::_M_range_check: __n (which is 5) &gt;= this-&gt;size() (which is 5)
end element is 4004</pre>
			<p>The <code>try</code> block catches the exception specified in the <code>catch</code> clause, in this case the exception is <code>std::out_of_range</code>. The <code>e.what()</code> function returns a C-string with the error <a id="_idIndexMarker212"/>message from the STL library. Each library will have different messages.</p>
			<p>Keep in mind that this also applies to <code>array</code> and <code>deque</code> containers.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Keep vector elements sorted</h1>
			<p>The <code>vector</code> is a <a id="_idIndexMarker213"/>sequential container that keeps elements in the order in which they were inserted. It does not sort elements, nor change their order in any way. Other containers, such as <code>set</code> and <code>map</code>, keep elements sorted, but those containers are not random-access and may not have the features you need. You can, however, keep your vector sorted. It just requires a little bit of management.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>How to do it…</h2>
			<p>The idea with this recipe is to create a simple function, <code>insert_sorted()</code>, that inserts an element into the correct position in a vector to keep the vector sorted.</p>
			<ul>
				<li>For convenience, we'll start with a <em class="italic">type alias</em> for a vector of strings:<pre><strong class="bold">using Vstr</strong> = std::vector&lt;std::string&gt;;</pre></li>
			</ul>
			<p>I like a type alias here because the exact details of the vector are not so important as its application.</p>
			<ul>
				<li>Then we can define a couple of support functions:<pre>// print a vector
void <strong class="bold">printv</strong>(const auto&amp; v) {
    for(const auto&amp; e : v) {
        cout &lt;&lt; format("{} ", e);
    }
    cout &lt;&lt; "\n";
}
// is it sorted? 
void <strong class="bold">psorted</strong>(const Vstr&amp; v) {
    if(<strong class="bold">std::ranges::is_sorted(v)</strong>) cout&lt;&lt; "sorted: ";
    else cout &lt;&lt; "unsorted: ";
    printv(v);
}</pre></li>
			</ul>
			<p>The <code>printv()</code> function<a id="_idIndexMarker214"/> is simple enough; it prints the elements of the vector on one line.</p>
			<p>The <code>psorted()</code> function uses the <em class="italic">ranges</em> version of the <code>is_sorted()</code> algorithm to tell us if the vector is sorted. Then it calls <code>printv()</code> to print the vector.</p>
			<ul>
				<li>Now we can initialize a <code>Vstr</code> vector in our <code>main()</code> function:<pre>int main() {
    Vstr v{ 
        "Miles",
        "Hendrix",
        "Beatles",
        "Zappa",
        "Shostakovich"
    };
    psorted(v);
}</pre></li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">unsorted: Miles Hendrix Beatles Zappa Shostakovich</strong></pre>
			<p>At this point we have a <code>Vstr</code> vector with the names of some interesting musicians, in no particular order.</p>
			<ul>
				<li>Let's sort our vector using the <code>ranges</code> version of the <code>sort()</code> algorithm.<pre><strong class="bold">std::ranges::sort(v)</strong>;
psorted(v);</pre></li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">sorted: Beatles Hendrix Miles Shostakovich Zappa</strong></pre>
			<ul>
				<li>At this point, we<a id="_idIndexMarker215"/> want to be able to insert items into the vector so that they're already in sorted order. The <code>insert_sorted()</code> function does this for us:<pre>void insert_sorted(Vstr&amp; v, const string&amp; s) {
    const auto pos{ <strong class="bold">std::ranges::lower_bound(v, s)</strong> };
    v.insert(pos, s);
}</pre></li>
			</ul>
			<p>The <code>insert_sorted()</code> function uses the <em class="italic">ranges</em> version of the <code>lower_bound()</code> algorithm to get an iterator for the <code>insert()</code> function that keeps the vector sorted.</p>
			<ul>
				<li>Now we can use the <code>insert_sorted()</code> function to insert more musicians into the vector:<pre>insert_sorted(v, "Ella");
insert_sorted(v, "Stones");</pre></li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">sorted: Beatles Ella Hendrix Miles Shostakovich Stones Zappa</strong></pre>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>How it works…</h2>
			<p>The <code>insert_sorted()</code> function is used to insert elements into a sorted vector while maintaining<a id="_idIndexMarker216"/> its order:</p>
			<pre>void insert_sorted(Vstr&amp; v, const string&amp; s) {
    const auto pos{ <strong class="bold">std::ranges::lower_bound(v, s)</strong> };
    v.insert(pos, s);
}</pre>
			<p>The <code>lower_bound()</code> algorithm finds the first element <em class="italic">not less than</em> the argument. We then use the iterator returned by <code>lower_bound()</code> to insert an element at the correct position.</p>
			<p>In this case we're using the ranges version of <code>lower_bound()</code>, but either version will work.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>There's more…</h2>
			<p>The <code>insert_sorted()</code> function can be made more generic by using a template. This version will work with other container types, such as <code>set</code>, <code>deque</code>, and <code>list</code>.</p>
			<pre><strong class="bold">template&lt;typename C, typename E&gt;</strong>
void insert_sorted(C&amp; c, const E&amp; e) {
    const auto pos{ std::ranges::lower_bound(c, e) };
    c.insert(pos, e);
}</pre>
			<p>Keep in mind that the <code>std::sort()</code> algorithm (and its derivatives) requires a container that <a id="_idIndexMarker217"/>supports random access. Not all STL containers fulfill this requirement. Notably, <code>std::list</code> does not.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Efficiently insert elements into a map</h1>
			<p>The <code>map</code> class is an<a id="_idIndexMarker218"/> associative container that holds <em class="italic">key-value pairs</em>, where<a id="_idIndexMarker219"/> keys must be unique within the container.</p>
			<p>There are a number of ways to populate a map container. Consider a <code>map</code> defined like this:</p>
			<pre>map&lt;string, string&gt; m;</pre>
			<p>You can add an element with the <code>[]</code> operator:</p>
			<pre>m["Miles"] = "Trumpet"</pre>
			<p>You can use the <code>insert()</code> member function:</p>
			<pre>m.insert(pair&lt;string,string&gt;("Hendrix", "Guitar"));</pre>
			<p>Or, you can use the <code>emplace()</code> member function:</p>
			<pre>m.emplace("Krupa", "Drums");</pre>
			<p>I tend to gravitate toward the <code>emplace()</code> function. Introduced with C++11, <code>emplace()</code> uses <em class="italic">perfect forwarding</em> to <strong class="bold">emplace</strong> (create in place) the new element for the container. The<a id="_idIndexMarker220"/> parameters are forwarded directly to the element constructors. This is quick, efficient, and easy to code.</p>
			<p>Though it's certainly an improvement over the other options, the problem with <code>emplace()</code> is that it constructs an object even when it's not needed. This involves calling the constructors, allocating memory, and moving data around, and then discarding that temporary object.</p>
			<p>To solve this problem, C++17 provides the new <code>try_emplace()</code> function which only constructs the <em class="italic">value object</em> if it's needed. This is especially important with large objects or many emplacements.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Each element of a <em class="italic">map</em> is a key-value <em class="italic">pair</em>. Within the pair structure, the elements are named, <code>first</code> and <code>second</code>, but their purpose in the map is <em class="italic">key</em> and <em class="italic">value</em>. I tend to think of the value object as the <em class="italic">payload</em>, as this is usually the point of the map. To search for an existing key, the <code>try_emplace()</code> function must construct the key object; this cannot be avoided. But it need not construct the payload object unless and until it's needed for insertion into the map.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>How to do it…</h2>
			<p>The new <code>try_emplace()</code> function avoids the overhead of constructing the <em class="italic">payload object</em> unless and until it is needed. This creates a valuable efficiency in the case of key collisions, especially<a id="_idIndexMarker221"/> with <a id="_idIndexMarker222"/>large payloads. Let's take a look:</p>
			<ul>
				<li>First, we create a payload class. For demonstration purposes, this class has a simple <code>std::string</code> payload and displays a message when constructed:<pre>struct BigThing {
    string v_;
    BigThing(const char * v) : v_(v) {
        cout &lt;&lt; format("BigThing constructed {}\n", v_);
    }
};
using Mymap = map&lt;string, BigThing&gt;;</pre></li>
			</ul>
			<p>This <code>BigThing</code> class has only one member function, a constructor that displays a message when the object is constructed. We'll use this to keep track of how often a <code>BigThing</code> object is constructed. In practice, of course, this class would be bigger, and use more resources.</p>
			<p>Each map element will consist of a pair of objects, a <code>std::string</code> for the key and a <code>BigThing</code> object for the payload. <code>Mymap</code> is just a convenience alias. This allows us to focus on function rather than form.</p>
			<ul>
				<li>We'll also create a <code>printm()</code> function to print the contents of the map:<pre>void printm(Mymap&amp; m) {
    for(auto&amp; [k, v] : m) {
        cout &lt;&lt; format("[{}:{}] ", k, v.v_);
    }
    cout &lt;&lt; "\n";
}</pre></li>
			</ul>
			<p>This uses <a id="_idIndexMarker223"/>the C++20 <code>format()</code> function to print out the map, so <a id="_idIndexMarker224"/>we can keep track of the elements as we insert them.</p>
			<ul>
				<li>In our <code>main()</code> function we create the map object and insert some elements:<pre>int main() {
    Mymap m;
    m.emplace("Miles", "Trumpet");
    m.emplace("Hendrix", "Guitar");
    m.emplace("Krupa", "Drums");
    m.emplace("Zappa", "Guitar");
    m.emplace("Liszt", "Piano");
    printm(m);
} </pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">BigThing constructed Trumpet</strong>
<strong class="bold">BigThing constructed Guitar</strong>
<strong class="bold">BigThing constructed Drums</strong>
<strong class="bold">BigThing constructed Guitar</strong>
<strong class="bold">BigThing constructed Piano</strong>
<strong class="bold">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]</strong></pre>
			<p>Our output shows the construction of each of the payload objects, and then the output from the <code>printm()</code> function call.</p>
			<ul>
				<li>I used the <code>emplace()</code> function to add the elements to the map, and each payload element was constructed just once. We can use the <code>try_emplace()</code> function<a id="_idIndexMarker225"/> and<a id="_idIndexMarker226"/> the result will be the same:<pre>Mymap m;
m.try_emplace("Miles", "Trumpet");
m.try_emplace("Hendrix", "Guitar");
m.try_emplace("Krupa", "Drums");
m.try_emplace("Zappa", "Guitar");
m.try_emplace("Liszt", "Piano");
printm(m);</pre></li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">BigThing constructed Trumpet</strong>
<strong class="bold">BigThing constructed Guitar</strong>
<strong class="bold">BigThing constructed Drums</strong>
<strong class="bold">BigThing constructed Guitar</strong>
<strong class="bold">BigThing constructed Piano</strong>
<strong class="bold">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]</strong></pre>
			<ul>
				<li>The difference between <code>emplace()</code> and <code>try_emplace()</code> shows up when we try to insert new elements with duplicate keys:<pre>cout &lt;&lt; "emplace(Hendrix)\n";
m.emplace("Hendrix", "Singer");
cout &lt;&lt; "try_emplace(Zappa)\n";
m.try_emplace("Zappa", "Composer"); 
printm(m); </pre></li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">emplace(Hendrix)</strong>
<strong class="bold">BigThing constructed Singer</strong>
<strong class="bold">try_emplace(Zappa)</strong>
<strong class="bold">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]</strong> </pre>
			<p>The <code>emplace()</code> function<a id="_idIndexMarker227"/> tried to add an element with a <a id="_idIndexMarker228"/>duplicate key (<code>"Hendrix"</code>). It failed but <em class="italic">still constructed</em> the payload object (<code>"Singer"</code>). The <code>try_emplace()</code> function also tried to add an element with a duplicate key (<code>"Zappa"</code>). It failed and <em class="italic">did not</em> construct the payload object.</p>
			<p>This example demonstrates the distinction between <code>emplace()</code> and <code>try_emplace()</code>.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>How it works…</h2>
			<p>The <code>try_emplace()</code> function signature is similar to that of <code>emplace()</code>, so it should be easy to retrofit legacy code. Here's the <code>try_emplace()</code> function signature:</p>
			<pre>pair&lt;iterator, bool&gt; try_emplace( const Key&amp; k, Args&amp;&amp;... args );</pre>
			<p>At first glance, this looks different from the <code>emplace()</code> signature:</p>
			<pre>pair&lt;iterator,bool&gt; emplace( Args&amp;&amp;... args );</pre>
			<p>The distinction is that <code>try_emplace()</code> uses a separate parameter for the <em class="italic">key</em> argument, which allows it to be isolated for construction. Functionally, if you're using <em class="italic">template argument deduction</em>, <code>try_emplace()</code> can be a drop-in replacement:</p>
			<pre>m.emplace("Miles", "Trumpet");
m.try_emplace("Miles", "Trumpet");</pre>
			<p>The return value of <code>try_emplace()</code> is the same as that of <code>emplace()</code>, a pair representing <a id="_idIndexMarker229"/>an <a id="_idIndexMarker230"/>iterator and a bool:</p>
			<pre>const char * key{"Zappa"};
const char * payload{"Composer"};
if(auto [it, success] = m.try_emplace(key, payload);
        !success) {
    cout &lt;&lt; "update\n";
    it-&gt;second = payload;
}
printm(m);</pre>
			<p>Output: </p>
			<pre>update
BigThing constructed Composer
[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Composer]</pre>
			<p>Here I used <em class="italic">structured binding</em> (<code>auto [it, success] =</code>) with an <code>if</code> <em class="italic">initializer statement</em> to test the return value and conditionally update the payload. Notice that it still just constructs the payload object once.</p>
			<p>It's worth noting that the <code>try_emplace()</code> function also works with <code>unordered_map</code>. We change our alias and everything works the same except unordered:</p>
			<pre>using Mymap = unordered_map&lt;string, BigThing&gt;; </pre>
			<p>The advantage of <code>try_emplace()</code> is that it only constructs the payload object <em class="italic">if and when</em> it's ready to store it in the map. In practice, this should save significant resources at run-time. You <a id="_idIndexMarker231"/>should<a id="_idIndexMarker232"/> always favor <code>try_emplace()</code> over <code>emplace()</code>.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Efficiently modify the keys of map items</h1>
			<p>A <code>map</code> is an <a id="_idIndexMarker233"/>associative container that stores key-value pairs. The container is <a id="_idIndexMarker234"/>ordered by the keys. The keys must be unique and they are <code>const</code>-qualified, so they cannot be changed.</p>
			<p>For example, if I populate a <code>map</code> and attempt to change the key, I'll get an error at compilation time:</p>
			<pre>map&lt;int, string&gt; mymap {
    {1, "foo"}, {2, "bar"}, {3, "baz"}
};
auto it = mymap.begin(); 
it-&gt;first = 47;</pre>
			<p>Output:</p>
			<pre>error: assignment of read-only member ...
    5 |     it-&gt;first = 47;
      |     ~~~~~~~~~~^~~~</pre>
			<p>If you need to re-order a map container, you may do so by swapping keys using the <code>extract()</code> method.</p>
			<p>New with C++17, <code>extract()</code> is a member function in the <code>map</code> class and its derivatives. It allows elements of a map to be extracted from the sequence without touching the payload. Once extracted, the key is no longer <code>const</code>-qualified and may be modified.</p>
			<p>Let's look at an example.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>How to do it…</h2>
			<p>In this example we'll define a map that represents contestants in a race. At some point during the race, the order changes and we need to modify the keys of the map.</p>
			<ul>
				<li>We'll start by defining an alias for the <code>map</code> type:<pre>using Racermap = map&lt;unsigned int, string&gt;;</pre></li>
			</ul>
			<p>This allows us to use the type consistently throughout our code.</p>
			<ul>
				<li>We'll write <a id="_idIndexMarker235"/>a <a id="_idIndexMarker236"/>function for printing out the map:<pre>void printm(const Racermap &amp;m)
{
    cout &lt;&lt; "Rank:\n";
    for (const auto&amp; [rank, racer] : m) {
        cout &lt;&lt; format("{}:{}\n", rank, racer);
    }
}</pre></li>
			</ul>
			<p>We can pass the map to this function at any time to print out the current rankings of our contestants.</p>
			<ul>
				<li>In our <code>main()</code> function we define a <code>map</code> with the initial state of our racers:<pre>int main() {
    Racermap racers {
        {1, "Mario"}, {2, "Luigi"}, {3, "Bowser"},
        {4, "Peach"}, {5, "Donkey Kong Jr"}
    };
    printm(racers);
    node_swap(racers, 3, 5);
    printm(racers);
}</pre></li>
			</ul>
			<p>The key is an <code>int</code> indicating the rank of the racer. The value is a <code>string</code> with the name of the racer.</p>
			<p>We then call <code>printm()</code> to print the current rank. The call to <code>node_swap()</code> will swap the keys of two racers, then we print gain.</p>
			<ul>
				<li>At some point, one of the racers falls behind and another racer takes the opportunity to<a id="_idIndexMarker237"/> move up in the rankings. The <code>node_swap()</code> function <a id="_idIndexMarker238"/>will swap the ranking of two racers:<pre>template&lt;typename M, typename K&gt;
bool node_swap(M &amp; m, K k1, K k2) {
    auto node1{ m.extract(k1) };
    auto node2{ m.extract(k2) };
    if(node1.empty() || node2.empty()) {
        return false;
    }
    swap(node1.key(), node2.key());
    m.insert(move(node1));
    m.insert(move(node2));
    return true;
}</pre></li>
			</ul>
			<p>This function uses the <code>map.extract()</code> method to extract the specified elements from the map. These extracted elements are called <em class="italic">nodes</em>.</p>
			<p>A <em class="italic">node</em> is a new concept beginning with C++17. This allows an element to be extracted from a map-type structure without touching the element itself. The node is unlinked, and a <em class="italic">node handle</em> is returned. Once extracted, the node handle provides <em class="italic">writable</em> access to the key via the node's <code>key()</code> function. We can then swap the keys and insert them back into the map, without ever having to copy or manipulate the payload.</p>
			<ul>
				<li>When we run this code we get a printout of the map, before and after the node swap:</li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">Rank:</strong>
<strong class="bold">1:Mario</strong>
<strong class="bold">2:Luigi</strong>
<strong class="bold">3:Bowser</strong>
<strong class="bold">4:Peach</strong>
<strong class="bold">5:Donkey Kong Jr</strong>
<strong class="bold">Rank:</strong>
<strong class="bold">1:Mario</strong>
<strong class="bold">2:Luigi</strong>
<strong class="bold">3:Donkey Kong Jr</strong>
<strong class="bold">4:Peach</strong>
<strong class="bold">5:Bowser</strong></pre>
			<p>This is all made<a id="_idIndexMarker239"/> possible<a id="_idIndexMarker240"/> by the <code>extract()</code> method and the new <code>node_handle</code> class. Let's take a closer look at how this works.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>How it works…</h2>
			<p>This technique uses the new <code>extract()</code> function, which returns a <code>node_handle</code> object. As the name suggests, a <code>node_handle</code> is a handle to a <em class="italic">node</em>, which consists of an associative element and its related structures. The extract function <em class="italic">disassociates</em> the node while leaving it in place, and returns a <code>node_handle</code> object. This has the effect of removing the node from the associative container without touching the data itself. The <code>node_handle</code> allows you to access the disassociated node.</p>
			<p>The <code>node_handle</code> has a member function, <code>key()</code>, which returns a <em class="italic">writable</em> reference to the node key. This allows you to change the key, while it's disassociated from <a id="_idIndexMarker241"/>the <a id="_idIndexMarker242"/>container.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>There's more…</h2>
			<p>There are a few things to keep in mind when using <code>extract()</code> and a <code>node_handle</code>:</p>
			<ul>
				<li>If the key is not found, the <code>extract()</code> function returns an <em class="italic">empty</em> node handle. You can test if a node handle is empty with the <code>empty()</code> function:<pre>auto node{ mapthing.extract(key) };
if(node.empty()) {
    // node handle is empty
}</pre></li>
				<li>There are two overloads of the <code>exract()</code> function:<pre>node_type extract(const key_type&amp; x);
node_type extract(const_iterator position);</pre></li>
			</ul>
			<p>We used the first form, by passing a key. You may also use an iterator, which should not require a lookup.</p>
			<ul>
				<li>Keep in mind that you cannot make a reference from a literal, so a call like <code>extract(1)</code> will usually crash with a segmentation fault.</li>
				<li>Keys must remain unique when inserted into a <code>map</code>.</li>
			</ul>
			<p>For example, if I try to change a key to a value already in the map:</p>
			<pre>auto node_x{ racers.extract(racers.begin()) };
node_x.key() = 5;  // 5 is Donkey Kong Jr
auto status = racers.insert(move(node_x));
if(!status.inserted) {
    cout &lt;&lt; format("insert failed, dup key: {}",
        status.position-&gt;second);
    exit(1);
}</pre>
			<p>The insert fails and we get our error message:</p>
			<pre>insert failed, dup key: Donkey Kong Jr</pre>
			<p>In this example I've passed the <code>begin()</code> iterator to <code>extract()</code>. I then assigned the key a value that's already in use (5, <em class="italic">Donkey Kong Jr</em>). The insert failed and the<a id="_idIndexMarker243"/> resulting <code>status.inserted</code> is <a id="_idIndexMarker244"/>false. <code>status.position</code> is an iterator to the found key. In the <code>if()</code> block, I used <code>format()</code> to print the value the found key.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Use unordered_map with custom keys</h1>
			<p>With an<a id="_idIndexMarker245"/> ordered <code>map</code>, the type of the key must be<a id="_idIndexMarker246"/> sortable, which means it must at least support the less-than <code>&lt;</code> comparison operator. Suppose you want to use an associative container with a custom type that is not sortable. For example, a vector where <code>(0, 1)</code> is not smaller or larger than <code>(1, 0)</code>, it simply points in a different direction. In such cases, you may still use the <code>unordered_map</code> type. Let's look at how to do this.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>How to do it…</h2>
			<p>For this recipe we'll create an <code>unordered_map</code> object that uses <em class="italic">x</em>/<em class="italic">y</em> coordinates for the key. We will need a few support functions for this.</p>
			<ul>
				<li>First, we'll define a structure for the coordinates:<pre>struct Coord {
    int x{};
    int y{};
};</pre></li>
			</ul>
			<p>This is a simple structure with two members, <code>x</code> and <code>y</code>, for the coordinates.</p>
			<ul>
				<li>Our map will<a id="_idIndexMarker247"/> use the <code>Coord</code> structure for the<a id="_idIndexMarker248"/> key, and an <code>int</code> for the value:<pre>using Coordmap = unordered_map&lt;Coord, int&gt;;</pre></li>
			</ul>
			<p>We use a <code>using</code> alias to make it convenient to use our map.</p>
			<ul>
				<li>To use the <code>Coord</code> struct as a key, we need a couple of overloads. These are required for use with an <code>unordered_map</code>. First, we'll define an equality comparison operator:<pre>bool operator==(const Coord&amp; lhs, const Coord&amp; rhs) {
    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;
}</pre></li>
			</ul>
			<p>It's a simple function that compares the <code>x</code> members with each other, and the <code>y</code> members with each other.</p>
			<ul>
				<li>We also need a <code>std::hash</code> class specialization. This makes it possible to retrieve map elements with the key:<pre>namespace std {
    template&lt;&gt;
    struct hash&lt;Coord&gt; {
        size_t operator()(const Coord&amp; c) const {
            return static_cast&lt;size_t&gt;(c.x)
                 + static_cast&lt;size_t&gt;(c.y);
        }
    };
}</pre></li>
			</ul>
			<p>This provides a specialization for the default <code>hash</code> class used by the <code>std::unordered_map</code> class. It must be in the <code>std</code> namespace.</p>
			<ul>
				<li>We'll also write <a id="_idIndexMarker249"/>a print function to print <a id="_idIndexMarker250"/>a <code>Coordmap</code> object:<pre>void print_Coordmap(const Coordmap&amp; m) {
    for (const auto&amp; [key, value] : m) {
        cout &lt;&lt; format("{{ ({}, {}): {} }} ",
            key.x, key.y, value);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This uses the C++20 <code>format()</code> function to print the <em class="italic">x</em>/<em class="italic">y</em> key and the value. Notice the use of the double braces, <code>{{</code> and <code>}}</code>, to print single braces.</p>
			<ul>
				<li>Now that we have all our support functions, we can write the <code>main()</code> function.<pre>int main() {
    Coordmap m {
        { {0, 0}, 1 },
        { {0, 1}, 2 },
        { {2, 1}, 3 } 
    };
    print_Coordmap(m);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">{ (2, 1): 3 } { (0, 1): 2 } { (0, 0): 1 }</strong></pre>
			<p>At this point, we've defined a <code>Coordmap</code> object that accepts <code>Coord</code> objects for the keys and maps them to arbitrary values.</p>
			<ul>
				<li>We can also access individual members based on the <code>Coord</code> keys:<pre>Coord k{ 0, 1 };
cout &lt;&lt; format("{{ ({}, {}): {} }}\n", k.x, k.y, m.at(k));</pre></li>
			</ul>
			<p>Output: </p>
			<pre><strong class="bold">{ (0, 1): 2 }</strong></pre>
			<p>Here we <a id="_idIndexMarker251"/>define a <code>Coord</code> object named <code>k</code>, and we <a id="_idIndexMarker252"/>use that with the <code>at()</code> function to retrieve a value from the <code>unordered_map</code>.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>How it works…</h2>
			<p>The <code>unordered_map</code> class relies on a hash class to lookup elements from the key. We normally instantiate an object like this:</p>
			<pre>std::unordered_map&lt;key_type, value_type&gt; my_map;</pre>
			<p>What's not obvious here is that, because we haven't one, it's using a <em class="italic">default hash class</em>. The full template type definition of the <code>unordered_map</code> class looks like this:</p>
			<pre>template&lt;
    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt; std::pair&lt;const Key, 
      T&gt; &gt;
&gt; class unordered_map;</pre>
			<p>The template provides default values for <code>Hash</code>, <code>KeyEqual</code>, and <code>Allocator</code>, so we don't normally include them in our definitions. In our example, we've provided a specialization for the default <code>std::hash</code> class.</p>
			<p>The STL contains specializations of <code>std::hash</code> for most of the standard types, like <code>string</code>, <code>int</code>, and so on. For it to work with our class, it needs a specialization.</p>
			<p>We could have<a id="_idIndexMarker253"/> passed a function to the template parameter, like<a id="_idIndexMarker254"/> this:</p>
			<pre>std::unordered_map&lt;coord, value_type, my_hash_type&gt; my_map;</pre>
			<p>That certainly would work. In my view, the specialization is more general.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Use set to sort and filter user input</h1>
			<p>The <code>set</code> container <a id="_idIndexMarker255"/>is an associative container <a id="_idIndexMarker256"/>where each <a id="_idIndexMarker257"/>element<a id="_idIndexMarker258"/> is a <em class="italic">single value</em>, which is used as the key. Elements in a <code>set</code> are maintained in sorted order and duplicate keys are not allowed.</p>
			<p>The <code>set</code> container is often misunderstood, and it does have fewer and more specific uses than more general containers such as <code>vector</code> and <code>map</code>. One common use for a <code>set</code> is to filter duplicates from a set of values.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>How to do it…</h2>
			<p>In this recipe we will read words from the <em class="italic">standard input</em> and filter out the duplicates.</p>
			<ul>
				<li>We'll start by defining an alias for an <code>istream</code> iterator. We'll use this to get input from the command line.<pre>using input_it = istream_iterator&lt;string&gt;;</pre></li>
				<li>In the <code>main()</code> function, we'll define a <code>set</code> for our words:<pre>int main() {
    set&lt;string&gt; words;</pre></li>
			</ul>
			<p>The <code>set</code> is defined as a set of <code>string</code> elements.</p>
			<ul>
				<li>We define a pair of iterators for use with the <code>inserter()</code> function:<pre>input_it it{ cin };
input_it end{};</pre></li>
			</ul>
			<p>The <code>end</code> iterator is <a id="_idIndexMarker259"/>initialized<a id="_idIndexMarker260"/> with<a id="_idIndexMarker261"/> its default <a id="_idIndexMarker262"/>constructor. This is known as the <em class="italic">end-of-stream</em> iterator. When our input ends, this iterator will compare equal with the <code>cin</code> iterator.</p>
			<ul>
				<li>The <code>inserter()</code> function is used to insert elements into the <code>set</code> container:<pre>copy(it, end, inserter(words, words.end()));</pre></li>
			</ul>
			<p>We use <code>std::copy()</code> to conveniently copy words from the input stream.</p>
			<ul>
				<li>Now we can print out our <code>set</code> to see the results:<pre>for(const string &amp; w : words) {
    cout &lt;&lt; format("{} ", w);
}
cout &lt;&lt; '\n';</pre></li>
				<li>We can run the program by piping a bunch of words to its input:<pre>$ echo "a a a b c this that this foo foo foo" | ./set-words
a b c foo that this</pre></li>
			</ul>
			<p>The <code>set</code> has eliminated the duplicates and retained a sorted list of the words that were inserted.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>How it works…</h2>
			<p>The <code>set</code> container is the heart of this recipe. It only holds unique elements. When you insert a duplicate, that insert will fail. So, you end up with a sorted list of each unique element.</p>
			<p>But that's not the only interesting part of this recipe.</p>
			<p>The <code>istream_iterator</code> is an input iterator that reads objects from a stream. We instantiated the input iterator like this:</p>
			<pre>istream_iterator&lt;string&gt; it{ cin };</pre>
			<p>Now we have an input iterator of type <code>string</code> from the <code>cin</code> stream. Every time we dereference this iterator, it will return one word from the input stream.</p>
			<p>We also instantiated another <code>istream_iterator</code>:</p>
			<pre>istream_iterator&lt;string&gt; end{};</pre>
			<p>This calls the default constructor, which gives us a special <em class="italic">end-of-stream </em>iterator. When the input iterator reaches the end of the stream, it will become equal to the <em class="italic">end-of-stream </em>iterator. This is convenient for ending loops, such as the one created by the <code>copy()</code> algorithm.</p>
			<p>The <code>copy()</code> algorithm takes three iterators, the beginning and end of the range to copy, and a destination iterator:</p>
			<pre>copy(it, end, inserter(words, words.end()));</pre>
			<p>The <code>inserter()</code> function<a id="_idIndexMarker263"/> takes a container <a id="_idIndexMarker264"/>and<a id="_idIndexMarker265"/> an<a id="_idIndexMarker266"/> iterator for the insertion point, and returns an <code>insert_iterator</code> of the appropriate type for the container and its elements.</p>
			<p>This combination of <code>copy()</code> and <code>inserter()</code> makes it easy to copy elements from a stream into the <code>set</code> container.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>A simple RPN calculator with deque</h1>
			<p>An <strong class="bold">RPN</strong> (<strong class="bold">Reverse Polish Notation</strong>) calculator is a stack-based calculator that uses postfix <a id="_idIndexMarker267"/>notation, where the operator follows<a id="_idIndexMarker268"/> the operands. It's commonly used in printing calculators and, notably, the HP 12C, the most popular electronic calculator of all time.</p>
			<p>After becoming familiar with its operational modality, many people prefer an RPN calculator. (I've been using the HP 12C and 16C since they were first introduced in the early 1980s.) For example, using conventional algebraic notation, to add 1 and 2 you would type <code>1 + 2</code>. Using RPN, you would type <code>1 2 +</code>. The operator comes <em class="italic">after</em> the operands.</p>
			<p>Using an algebraic calculator, you would need to press an <code>=</code> key to indicate that you want a result. With an RPN calculator this is unnecessary because the operator processes immediately, serving a double purpose. On the other hand, an RPN calculator often requires an <em class="italic">Enter</em> keypress to push an operand onto the stack.</p>
			<p>We can easily implement an RPN calculator using a stack-based data structure. For example, consider an RPN calculator with a four-position stack:</p>
			<div><div><img src="img/B18267_03_05.jpg" alt="Figure 3.5 – RPN addition operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – RPN addition operation</p>
			<p>Each operand is pushed onto the stack as they are entered. When the operator is entered, the operands are popped off, operated upon, and the result is pushed back onto the stack. The result may then be used in the next operation. For example, consider the case of <code>(3+2)×3</code>:</p>
			<div><div><img src="img/B18267_03_06.jpg" alt="Figure 3.6 – RPN stack operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – RPN stack operations</p>
			<p>One advantage of <a id="_idIndexMarker269"/>RPN is that you can leave <a id="_idIndexMarker270"/>operands on the stack for future calculations, reducing the need for separate memory registers. Consider the case of <code>(9×6)+(2×3)</code>:</p>
			<div><div><img src="img/B18267_03_07.jpg" alt="Figure 3.7 – RPN multiple stack operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – RPN multiple stack operations</p>
			<p>Notice that we first perform the operations within the parentheses, then the final operation on the intermediate results. This may seem more complex at first, but it makes a lot of sense once you get used to it.</p>
			<p>Now, let's build a simple RPN calculator using the STL <code>deque</code> container.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>How to do it…</h2>
			<p>For this implementation, we'll use a <code>deque</code> container for our stack. Why not use a <code>stack</code> container? The <code>stack</code> class is a container-adapter, which uses another container (usually a <code>deque</code>) for its storage. For our purposes, <code>stack</code> doesn't provide any tangible advantage over <code>deque</code>. And <code>deque</code> allows us to iterate over and display the RPN stack, like a paper tape calculator.</p>
			<ul>
				<li>We'll encapsulate our RPN calculator in a class. There are a few advantages to using a<a id="_idIndexMarker271"/> class <a id="_idIndexMarker272"/>here. <em class="italic">Encapsulation</em> provides <em class="italic">safety</em>, <em class="italic">reusability</em>, <em class="italic">extensibility</em>, and a <em class="italic">clean interface</em>. We'll call our class <code>RPN</code>:<pre>class RPN {
    deque&lt;double&gt; deq_{};
    constexpr static double zero_{0.0};
    constexpr static double inf_ 
        { std::numeric_limits&lt;double&gt;::infinity() };
...  // public and private members go here
};</pre></li>
			</ul>
			<p>The <code>deque</code> data store, named <code>deq_</code>, is in the private area of the class to protect it. This is where we store the RPN stack.</p>
			<p>The <code>zero_</code> constant is used throughout the class, both as a return value and as a comparison operand. The <code>inf_</code> constant is used for a divide-by-zero error. These constants are declared <code>constexpr static</code> so they don't take up space in every instance.</p>
			<p>I like to name private data members with a trailing underscore to remind me that they're private.</p>
			<ul>
				<li>We don't need an explicit constructor or destructor because the <code>deque</code> class manages its own resources. So, our public interface consists of just three functions:<pre>public:
    // process an operand/operator
    double op(const string &amp; s) {
        if(is_numeric(s)) {
            double v{stod(s, nullptr)};
            deq_.push_front(v);
            return v;
        }
        else return optor(s);
    }
    // empty the stack
    void clear() {
        deq_.clear();
    }
    // print the stack
    string get_stack_string() const {
        string s{};
        for(auto v : deq_) {
            s += format("{} ", v);
        }
        return s;
    }</pre></li>
			</ul>
			<p>The <code>double op()</code> function is the main entry point for the RPN class. It takes a <code>string</code>, with either a number or an operator. If it's a number, it's converted into a <code>double</code> and pushed onto the stack. If it's an operator, we call <code>optor()</code> to perform the operation. This is the main logic of the class.</p>
			<p>The <code>void clear()</code> function simply calls <code>clear()</code> on the <code>deque</code> to empty the stack.</p>
			<p>And finally, the <code>string get_stack_string()</code> function returns the contents of the stack in a <code>string</code>.</p>
			<ul>
				<li>In the <code>private</code> section, we have the supporting utilities that make the interface<a id="_idIndexMarker273"/> work. The <code>pop_get2()</code> function<a id="_idIndexMarker274"/> pops two operands from the stack and returns them as a pair. We use this as operands for the operators:<pre>    pair&lt;double, double&gt; pop_get2() {
        if(deq_.size() &lt; 2) return {zero_, zero_};
        double v1{deq_.front()};
        deq_.pop_front();
        double v2{deq_.front()};
        deq_.pop_front();
        return {v2, v1};
    }</pre></li>
				<li>The <code>is_numeric()</code> function checks to see if the string is entirely numeric. We also allow the decimal <code>.</code> character.<pre>    bool is_numeric(const string&amp; s) {
        for(const char c : s) {
            if(c != '.' &amp;&amp; !std::isdigit(c)) return 
              false;
        }
        return true;
    }</pre></li>
				<li>The <code>optor()</code> function performs the operators. We use a <code>map</code> container to map an operator to<a id="_idIndexMarker275"/> a corresponding<a id="_idIndexMarker276"/> lambda function.<pre>double optor(const string&amp; op) {
    map&lt;string, double (*)(double, double)&gt; opmap {
        {"+", [](double l, double r){ return l + r; }},
        {"-", [](double l, double r){ return l - r; }},
        {"*", [](double l, double r){ return l * r; }},
        {"/", [](double l, double r){ return l / r; }},
        {"^", [](double l, double r)
            { return pow(l, r); }},
        {"%", [](double l, double r)
            { return fmod(l, r); }}
    };
    if(opmap.find(op) == m.end()) return zero_;
    auto [l, r] = pop_get2();
    // don’t divide by zero
    if(op == "/" &amp;&amp; r == zero_) deq_.push_front(inf_);
    else deq_.push_front(opmap.at(op)(l, r));
    return deq_.front();
}</pre></li>
			</ul>
			<p>The <code>map</code> container with lambda functions makes a quick and easy jump table.</p>
			<p>We use the <code>find()</code> function in <code>map</code> to test if we have a valid operator.</p>
			<p>After a test for divide-by-zero, the <code>map</code> is dereferenced, and the operator is called.</p>
			<p>The result of the operation is pushed onto the stack and returned.</p>
			<ul>
				<li>Those are all the <a id="_idIndexMarker277"/>function members <a id="_idIndexMarker278"/>of the <code>RPN</code> class. Now we can use it in our <code>main()</code> function:<pre>int main() {
    RPN rpn;
    for(string o{}; cin &gt;&gt; o; ) {
        rpn.op(o);
        auto stack_str{rpn.get_stack_string()};
        cout &lt;&lt; format("{}: {}\n", o, stack_str);
    }
}</pre></li>
			</ul>
			<p>We'll test this is by piping a string into the program from the command line. We use a <code>for</code> loop to fetch each word from the <code>cin</code> stream and pass it to <code>rpn.op()</code>. I like the <code>for</code> loop here, as it's easy to contain the scope of the <code>o</code> variable. We then print the stack using the <code>get_stack_string()</code> function after each command line item.</p>
			<ul>
				<li>We can run the program by piping in an expression like this:<pre>$ echo "9 6 * 2 3 * +" | ./rpn
9: 9
6: 6 9
*: 54
2: 2 54
3: 3 2 54
*: 6 54
+: 60</pre></li>
			</ul>
			<p>This looks like a lot of coding but it's actually quite simple. With the comments, the <code>RPN</code> class is less than 70 lines of code. The full <code>rpn.cpp</code> source code is in the GitHub repository.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>How it works…</h2>
			<p>The <code>RPN</code> class operates by first determining the nature of each chunk of input. If it's a number, we push it onto the stack. If it's an operator, we pop two operands off the top of the stack, apply the operation, and push the result back on the stack. If we don't recognize the input, we just ignore it.</p>
			<p>The <code>deque</code> class is a double-ended queue. To use it as a stack, we pick an end and both push and pop from<a id="_idIndexMarker279"/> that same end. I chose <a id="_idIndexMarker280"/>the <code>front</code> end of the deque, but it would work just as well from the <code>back</code>. We just need to do everything from the same end.</p>
			<p>If we determine that an input is numeric, we convert it to a <code>double</code> and push it onto the front of the <code>deque</code> using <code>push_front()</code>.</p>
			<pre>    if(is_numeric(s)) {
        double v{stod(s, nullptr)};
        deq_.push_front(v);
        return v;
    }</pre>
			<p>When we need to use values from the stack, we pop them off the front of the deque. We use <code>front()</code> to get the value, and then <code>pop_front()</code> to pop it off the stack.</p>
			<pre>    pair&lt;double, double&gt; pop_get2() {
        if(deq_.size() &lt; 2) return {zero_, zero_};
        double v1{deq_.front()};
        deq_.pop_front();
        double v2{deq_.front()};
        deq_.pop_front();
        return {v2, v1};
    }</pre>
			<p>Using a map for our operators makes it easy to both check if an operator is valid, and to execute the operation.</p>
			<pre>    map&lt;string, double (*)(double, double)&gt; opmap {
        {"+", [](double l, double r){ return l + r; }},
        {"-", [](double l, double r){ return l - r; }},
        {"*", [](double l, double r){ return l * r; }},
        {"/", [](double l, double r){ return l / r; }},
        {"^", [](double l, double r){ return pow(l, r); }},
        {"%", [](double l, double r){ return fmod(l, r); }}
    };</pre>
			<p>We can test for the <a id="_idIndexMarker281"/>validity of an operator by <a id="_idIndexMarker282"/>using the <code>find()</code> function:</p>
			<pre>    if(opmap.find(op) == opmap.end()) return zero_;</pre>
			<p>And we can call the operator by dereferencing the <code>map</code> with the <code>at()</code> function:</p>
			<pre>    opmap.at(op)(l, r)</pre>
			<p>We both call the operator lambda and push the result onto the <code>deque</code> in one statement:</p>
			<pre>    deq_.push_front(opmap.at(op)(l, r));</pre>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>There's more…</h2>
			<p>In this recipe, we use the <code>cin</code> stream to feed operations to the RPN calculator. It would be just as easy to do this with an STL container.</p>
			<pre>int main() {
    RPN rpn;
    vector&lt;string&gt; opv{ "9", "6", "*", "2", "3", "*", "+" 
      };
    for(auto o : opv) {
        rpn.op(o);
        auto stack_str{rpn.get_stack_string()};
        cout &lt;&lt; format("{}: {}\n", o, stack_str);
    }
}</pre>
			<p>Output:</p>
			<pre>9: 9
6: 6 9
*: 54
2: 2 54
3: 3 2 54
*: 6 54
+: 60</pre>
			<p>By putting the RPN calculator in a class with a clean interface, we've created a flexible tool that can be used in many different contexts.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>A word frequency counter with map</h1>
			<p>This recipe uses <a id="_idIndexMarker283"/>the unique key property of the <code>map</code> container <a id="_idIndexMarker284"/>to count duplicate words from a stream of text.</p>
			<p>The STL <code>map</code> container is an <em class="italic">associative</em> container. It consists of elements organized in <em class="italic">key-value pairs</em>. The keys are used for lookup and must be unique.</p>
			<p>In this recipe, we will leverage the unique key requirement of the STL <code>map</code> container to count the number of occurrences of each word in a text file.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>How to do it…</h2>
			<p>There are a few parts to this task that we can solve separately:</p>
			<ol>
				<li>We need to get the text from a file. We'll use the <code>cin</code> stream for this.</li>
				<li>We need to separate words from punctuation and other non-word content. We'll use the <code>regex</code> (Regular Expression) library for this.</li>
				<li>We need to count the frequency of each word. This is the main objective of the recipe. We'll use the STL <code>map</code> container for this.</li>
				<li>Finally, we need to sort the results, first by frequency and then alphabetically by word within frequency. For this we'll use a the STL <code>sort</code> algorithm with a <code>vector</code> container.</li>
			</ol>
			<p>Even with all those tasks, the resulting code is relatively short, just about 70 lines with headers and all. Let's dive in:</p>
			<ul>
				<li>We'll start with some aliases for convenience:<pre>namespace ranges = std::ranges;
namespace regex_constants = std::regex_constants;</pre></li>
			</ul>
			<p>For namespaces within the <code>std::</code> space, I like to make aliases that are shorter, but still let me know that I'm using a token in a particular namespace. Especially with the <code>ranges</code> namespace, which often re-uses the names of existing algorithms.</p>
			<ul>
				<li>We store the regular expression in a constant. I don't like to clutter up the global namespace because that can lead to collisions. I tend to use a namespace based on my initials for things like this:<pre>namespace bw {
    constexpr const char * re{"(\\w+)"};
}</pre></li>
			</ul>
			<p>It's easy enough to get it later using <code>bw::re</code>, and that tells me exactly what it is.</p>
			<ul>
				<li>At the top of <code>main()</code>, we define our data structures:<pre>int main() {
    map&lt;string, int&gt; <strong class="bold">wordmap</strong>{};    
    vector&lt;pair&lt;string, int&gt;&gt; <strong class="bold">wordvec</strong>{};
    regex <strong class="bold">word_re</strong>(bw::re);
    size_t total_words{};</pre></li>
			</ul>
			<p>Our<a id="_idIndexMarker285"/> main <code>map</code> is called <code>wordmap</code>. We <a id="_idIndexMarker286"/>have a <code>vector</code> named <code>wordvec</code> that we'll use as a sorting container. And finally, our <code>regex</code> class, <code>word_re</code>.</p>
			<ul>
				<li>The <code>for</code> loop is where most of the work happens. We read text from the <code>cin</code> stream, apply the <code>regex</code>, and store words in the <code>map</code>:<pre>for(string s{}; cin &gt;&gt; s; ) {
    auto <strong class="bold">words_begin</strong>{
        sregex_iterator(s.begin(), s.end(), word_re) };
    auto <strong class="bold">words_end</strong>{ sregex_iterator() };
    for(auto <strong class="bold">r_it</strong>{words_begin}; <strong class="bold">r_it</strong> != words_end; 
      <strong class="bold">++r_it</strong>) {
        <strong class="bold">smatch</strong> match{ *r_it };
        auto <strong class="bold">word_str</strong>{match.str()};
        <strong class="bold">ranges::transform</strong>(word_str, word_str.begin(),
            [](unsigned char c){ return <strong class="bold">tolower</strong>(c); });
        auto [map_it, result] =
            <strong class="bold">wordmap.try_emplace</strong>(word_str, 0);
        auto &amp; [w, count] = *map_it;
        ++total_words;
        <strong class="bold">++count</strong>;
    }
}</pre></li>
			</ul>
			<p>I like a <code>for</code> loop for<a id="_idIndexMarker287"/> this because it allows me to <a id="_idIndexMarker288"/>contain the scope of the <code>s</code> variable.</p>
			<p>We start by defining iterators for the <code>regex</code> results. This allows us to distinguish multiple words even when surrounded only by punctuation. The <code>for(r_it...)</code> loop returns individual words from the <code>cin</code> string.</p>
			<p>The <code>smatch</code> type is a specialization of a <code>regex</code> string match class. It gives us the next word from our <code>regex</code>.</p>
			<p>We then use the <code>transform</code> algorithm to make the words lowercase – so we can count words regardless of case. (For example, "The" is the same word as "the".)</p>
			<p>Next, we use <code>try_emplace()</code> to add the word to the map. If it's already there, it will not be replaced.</p>
			<p>Finally, we increment the count for the word in the <code>map</code> with <code>++count</code>.</p>
			<ul>
				<li>Now we have the words and their frequency counts in our <code>map</code>. But they're in alphabetical order and we want them in descending order of frequency. For this, we put them in a vector and sort them:<pre>    auto unique_words = wordmap.size();
    wordvec.reserve(unique_words);
    ranges::move(wordmap, back_inserter(wordvec));
    ranges::sort(wordvec, [](const auto&amp; a, const 
      auto&amp; b) { 
        if(a.second != b.second)
            return (a.second &gt; b.second);
        return (a.first &lt; b.first);
    });
    cout &lt;&lt; format("unique word count: {}\n", 
      total_words);
    cout &lt;&lt; format("unique word count: {}\n", 
      unique_words);</pre></li>
			</ul>
			<p><code>wordvec</code> is a <a id="_idIndexMarker289"/>vector of pairs, with the word<a id="_idIndexMarker290"/> and the frequency count. We use the <code>ranges::move()</code> algorithm to populate the <code>vector</code>, then the <code>ranges::sort()</code> algorithm to sort the <code>vector</code>. Notice that the <em class="italic">predicate lambda function</em> sorts first by the count (descending) and then by the word (ascending).</p>
			<ul>
				<li>Finally, we print the results:<pre>    for(int limit{20}; auto&amp; [w, count] : wordvec) {
        cout &lt;&lt; format("{}: {}\n", count, w);
        if(--limit == 0) break;
    }
}</pre></li>
			</ul>
			<p>I set a limit to print only the first 20 entries. You can comment out the <code>if(--limit == 0) break;</code> line to print the whole list.</p>
			<ul>
				<li>In the example files, I've included a text file with a copy of <em class="italic">The Raven</em>, by Edgar Allen Poe. The<a id="_idIndexMarker291"/> poem is in the public domain. We <a id="_idIndexMarker292"/>can use this to test the program:<pre><strong class="bold">$ ./word-count &lt; the-raven.txt</strong>
<strong class="bold">total word count: 1098</strong>
<strong class="bold">unique word count: 439</strong>
<strong class="bold">56: the</strong>
<strong class="bold">38: and</strong>
<strong class="bold">32: i</strong>
<strong class="bold">24: my</strong>
<strong class="bold">21: of</strong>
<strong class="bold">17: that</strong>
<strong class="bold">17: this</strong>
<strong class="bold">15: a</strong>
<strong class="bold">14: door</strong>
<strong class="bold">11: chamber</strong>
<strong class="bold">11: is</strong>
<strong class="bold">11: nevermore</strong>
<strong class="bold">10: bird</strong>
<strong class="bold">10: on</strong>
<strong class="bold">10: raven</strong>
<strong class="bold">9: me</strong>
<strong class="bold">8: at</strong>
<strong class="bold">8: from</strong>
<strong class="bold">8: in</strong>
<strong class="bold">8: lenore</strong></pre></li>
			</ul>
			<p>The poem has 1,098 words total, and 439 of them are unique.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>How it works…</h2>
			<p>The core of the recipe is the use of a <code>map</code> object to count duplicate words. But there are other parts that merit consideration.</p>
			<p>We use the <code>cin</code> stream to read text from the <em class="italic">standard input</em>. By default, <code>cin</code> will skip <em class="italic">whitespace</em> when reading into a <code>string</code> object. By putting a string object on the right-hand side of the <code>&gt;&gt;</code> operator (<code>cin &gt;&gt; s</code>) we get chunks of text separated by whitespace. This is a good enough definition of a word-at-a-time for many purposes, but we need linguistic <a id="_idIndexMarker293"/>words. And for that we will use a regular <a id="_idIndexMarker294"/>expression.</p>
			<p>The <code>regex</code> class provides a choice of regular expression <em class="italic">grammars</em> and it defaults to <em class="italic">ECMA</em> grammar. In the ECMA grammar, the regular expression <code>"(\w+)"</code> is a shortcut for <code>"([A-Za-z0-9_]+)"</code>. This will select words that include these characters.</p>
			<p>Regular expressions are a language unto themselves. To learn more about regular expressions, I recommend the book <em class="italic">Mastering Regular Expressions</em> by Jeffrey Friedl.</p>
			<p>As we get each word from the <code>regex</code> engine, we use the map object's <code>try_emplace()</code> method to conditionally add the word to our <code>wordmap</code>. If the word is not in the map, we add it with a count of <code>0</code>. If the word is already in the map, the count is untouched. We increment the count later in the loop, so it's always correct.</p>
			<p>After the map is populated with all the unique words from the file, we transfer it to a vector using the <code>ranges::move()</code> algorithm. The <code>move()</code> algorithm makes this transfer quick <a id="_idIndexMarker295"/>and efficient. Then we can sort it in the vector <a id="_idIndexMarker296"/>using <code>ranges::sort()</code>. The <em class="italic">predicate lambda function</em> for sorting includes comparisons for both sides of the pair, so we end up with a result that's sorted by both word count (descending) and the word.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Find long sentences with a vector of vectors</h1>
			<p>It can be useful for<a id="_idIndexMarker297"/> a writer to make sure they are using variety of sentence lengths, or to ensure none of their sentences are too long. Let's build a tool that evaluates a text file for sentence length.</p>
			<p>Choosing the appropriate container is key when using the STL. If you need something ordered, it's often best to use an associative container, such as <code>map</code> or <code>multimap</code>. In this case, however, since we need a custom sort, it's easier to sort a <code>vector</code>.</p>
			<p>The <code>vector</code> is generally the most flexible of the STL containers. Whenever another container type seems appropriate, but is missing one important capability, the <code>vector</code> is often an effective solution. In this case, where we need a custom sort, the vector works great.</p>
			<p>This recipe uses a <em class="italic">vector of vectors</em>. The inner <code>vector</code> stores the words of a sentence, and the outer <code>vector</code> stores the inner <code>vector</code>s. As you'll see, this affords a lot of flexibility while retaining all the relevant data.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>How to do it…</h2>
			<p>This program needs to read in words, find the ends of sentences, store and sort the sentences, then print out the results.</p>
			<ul>
				<li>We'll start by writing a little function to tell us when we've hit the end of a sentence:<pre>bool is_eos(const string_view &amp; str) {
    constexpr const char * <strong class="bold">end_punct</strong>{ ".!?" };
    for(auto c : str) {
        if(<strong class="bold">strchr</strong>(end_punct, c) != nullptr) return 
          true;
    }
    return false;
}</pre></li>
			</ul>
			<p>The <code>is_eos()</code> function uses <code>string_view</code> because it's efficient and we don't need anything more. Then we use the <code>strchr()</code> library function to check if a word<a id="_idIndexMarker298"/> contains one of the end-of-sentence punctuation characters (<code>".!?"</code>). These are the three possible characters to end a sentence in the English language.</p>
			<ul>
				<li>In the <code>main()</code> function, we start by defining the <em class="italic">vector of vectors</em>:<pre>vector&lt;vector&lt;string&gt;&gt; vv_sentences{vector&lt;string&gt;{}};</pre></li>
			</ul>
			<p>This defines a <code>vector</code> of elements typed <code>vector&lt;string&gt;</code> named <code>vv_sentences</code>. The <code>vv_sentences</code> object is initialized with one empty vector for the first sentence.</p>
			<p>This creates a vector that contains other vectors. The inner vectors will each hold a sentence of words.</p>
			<ul>
				<li>Now we can process the stream of words:<pre>for(string s{}; cin &gt;&gt; s; ) {
    vv_sentences.<strong class="bold">back()</strong>.emplace_back(s);
    if(<strong class="bold">is_eos(s)</strong>) {
      vv_sentences.<strong class="bold">emplace_back(vector&lt;string&gt;{})</strong>;
    }
}</pre></li>
			</ul>
			<p>The <code>for</code> loop returns one word at a time from the input stream. The <code>back()</code> method on the <code>vv_sentences</code> object is used to access the current vector of words, and the current word is added using <code>emplace_back()</code>. Then we call <code>is_eos()</code> to see if this was the end of a sentence. If so, we add a new empty vector to <code>vv_sentences</code> to start the next sentence.</p>
			<ul>
				<li>Because we always add a new empty vector to the end of <code>vv_sentences</code> after each end-of-sentence character, we will usually end up with an empty sentence vector at the end. Here we check for this, and delete it if necessary:<pre>    // delete back if empty
    if(vv_sentences.back().empty()) 
        vv_sentences.pop_back();</pre></li>
				<li>Now we can <a id="_idIndexMarker299"/>sort the <code>vv_sentences</code> vector by the size of the sentences:<pre>    sort(vv_sentences, [](const auto&amp; l, 
        const auto&amp; r) {
            <strong class="bold">return l.size() &gt; r.size();</strong>
        });</pre></li>
			</ul>
			<p>This is why the <code>vector</code> is so convenient for this project. It's quick and easy to sort using the <code>ranges::sort()</code> algorithm with a simple <em class="italic">predicate</em> for sorting by size in descending order.</p>
			<ul>
				<li>Now we can print our result: <pre>    constexpr int WLIMIT{10};
    <strong class="bold">for(auto&amp; v : vv_sentences)</strong> {
        size_t size = v.size();
        size_t limit{WLIMIT};
        cout &lt;&lt; <strong class="bold">format("{}: ", size)</strong>;
        <strong class="bold">for(auto&amp; s : v)</strong> {
            cout &lt;&lt; <strong class="bold">format("{} ", s)</strong>;
            if(--limit == 0) {
                <strong class="bold">if(size &gt; WLIMIT) cout &lt;&lt; "...";</strong>
                break;
            }
        }
        cout &lt;&lt; '\n';
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>The outer loop and the inner loop correspond to the outer and inner vectors. We simply loop <a id="_idIndexMarker300"/>through the vectors and print out the size of the inner vector with <code>format("{}: ", size)</code> and then each word with <code>format("{} ", s)</code>. We don't want to print the very long sentences in their entirety, so we define a limit of 10 words and print an ellipsis if there's more.</p>
			<ul>
				<li>The output looks like this, using the first few paragraphs of this recipe for input:<pre><strong class="bold">$ ./sentences &lt; sentences.txt</strong>
<strong class="bold">27: It can be useful for a writer to make sure ...</strong>
<strong class="bold">19: Whenever another container type seems appropriate, but is missing one ...</strong>
<strong class="bold">18: If you need something ordered, it's often best to use ...</strong>
<strong class="bold">17: The inner vector stores the words of a sentence, and ...</strong>
<strong class="bold">16: In this case, however, since we need a descending sort, ...</strong>
<strong class="bold">16: In this case, where we need our output sorted in ...</strong>
<strong class="bold">15: As you'll see, this affords a lot of flexibility while ...</strong>
<strong class="bold">12: Let's build a tool that evaluates a text file for ...</strong>
<strong class="bold">11: The vector is generally the most flexible of the STL ...</strong>
<strong class="bold">9: Choosing the appropriate container key when using the STL.</strong>
<strong class="bold">7: This recipe uses a vector of vectors.</strong></pre></li>
			</ul>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>How it works…</h2>
			<p>Finding punctuation is simple using the <code>strchr()</code> function from the C Standard Library. Remember, all<a id="_idIndexMarker301"/> of C and its Standard Library are included in the definition of the C++ language. There's no reason not to use it where appropriate.</p>
			<pre>bool is_eos(const string_view &amp; str) {
    constexpr const char * end_punct{ ".!?" };
    for(auto c : str) {
        if(<strong class="bold">strchr(end_punct, c) != nullptr</strong>) return true;
    }
    return false;
}</pre>
			<p>This function will fail to properly separate sentences if there's punctuation in the middle of words. That may happen in some forms of poetry or in a badly formatted text file. I've seen this done with <code>std::string</code> iterators, and with regular expressions, but for our purposes this is quick and easy.</p>
			<p>We read the text file one word at a time using <code>cin</code>:</p>
			<pre>for(string s{}; <strong class="bold">cin &gt;&gt; s</strong>; ) {
    ...
}</pre>
			<p>This avoids the overhead of reading a large file into memory all at once. The <code>vector</code> will already be large, containing all the words of the file. It's not necessary to also hold the entire text file in memory. In the rare case that a file is too large, it would be necessary to find another strategy, or use a database.</p>
			<p>The <em class="italic">vector of vectors</em> may look complex at first glance, but it's no more complicated than using two separate vectors.</p>
			<pre><strong class="bold">vector&lt;vector&lt;string&gt;&gt;</strong> vv_sentences{<strong class="bold">vector&lt;string&gt;{}</strong>};</pre>
			<p>This declares an <em class="italic">outer</em> <code>vector</code>, with <em class="italic">inner</em> elements of type <code>vector&lt;string&gt;</code>. The <em class="italic">outer</em> vector is named <code>vv_sentences</code>. The <em class="italic">inner</em> vectors are anonymous; they require no<a id="_idIndexMarker302"/> name. This definition initializes the <code>vv_sentences</code> object with one element, an empty <code>vector&lt;string&gt;</code> object.</p>
			<p>The <em class="italic">current</em> inner vector will always be available as <code>vv_senteces.back()</code>:</p>
			<pre><strong class="bold">vv_sentences.back()</strong>.emplace_back(s);</pre>
			<p>When we've completed one inner vector, we simply create a new one with:</p>
			<pre>vv_sentences.emplace_back(vector&lt;string&gt;{});</pre>
			<p>This creates a new anonymous <code>vector&lt;string&gt;</code> object and <em class="italic">emplaces</em> it at the back of the <code>vv_sentences</code> object.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>A ToDo list using multimap</h1>
			<p>An ordered <a id="_idIndexMarker303"/>task list (or a <em class="italic">ToDo list</em>) is a common computing <a id="_idIndexMarker304"/>application. Formally stated, it's a list of tasks associated with a priority, sorted in reverse numerical order.</p>
			<p>You may be tempted to use a <code>priority_queue</code> for this, because as the name implies, it's already sorted in priority (reverse numerical) order. The disadvantage of a <code>priority_queue</code> is that it has no iterators, so it's difficult to operate on it without pushing and popping items to and from the queue.</p>
			<p>For this recipe, we'll use a <code>multimap</code> for the ordered list. The <code>multimap</code> <em class="italic">associative container</em> keeps items in order, and it can be accessed using <em class="italic">reverse iterators</em> for the proper sort order.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>How to do it…</h2>
			<p>This is a short and simple recipe that initializes a <code>multimap</code> and prints it in reverse order.</p>
			<ul>
				<li>We start with a type alias for our <code>multimap</code>:<pre>using todomap = multimap&lt;int, string&gt;;</pre></li>
			</ul>
			<p>Our <code>todomap</code> is a <code>multimap</code> with an <code>int</code> key and a <code>string</code> payload.</p>
			<ul>
				<li>We have<a id="_idIndexMarker305"/> a<a id="_idIndexMarker306"/> small utility function for printing the <code>todomap</code> in reverse order:<pre>void rprint(todomap&amp; todo) {
    for(auto it = todo.rbegin(); it != todo.rend(); 
      ++it) {
        cout &lt;&lt; format("{}: {}\n", it-&gt;first, 
          it-&gt;second);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This uses reverse iterators to print the <code>todomap</code>.</p>
			<ul>
				<li>The <code>main()</code> function is short and sweet:<pre>int main()
{
    todomap todo {
        {1, "wash dishes"},
        {0, "watch teevee"},
        {2, "do homework"},
        {0, "read comics"}
    };
    <strong class="bold">rprint</strong>(todo);
}</pre></li>
			</ul>
			<p>We initialize the <code>todomap</code> with tasks. Notice that the tasks are not in any particular order, but they do have priorities in the keys. The <code>rprint()</code> function<a id="_idIndexMarker307"/> will<a id="_idIndexMarker308"/> print them in priority order.</p>
			<ul>
				<li>The output looks like this:<pre><strong class="bold">$ ./todo</strong>
<strong class="bold">2: do homework</strong>
<strong class="bold">1: wash dishes</strong>
<strong class="bold">0: read comics</strong>
<strong class="bold">0: watch teevee</strong></pre></li>
			</ul>
			<p>The ToDo list prints out in priority order, just as we need it.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>How it works…</h2>
			<p>It's a short and simple recipe. It uses the <code>multimap</code> container to hold items for a prioritized list.</p>
			<p>The only trick is in the <code>rprint()</code> function:</p>
			<pre>void rprint(todomap&amp; todo) {
    for(auto it = todo.<strong class="bold">rbegin()</strong>; it != todo.<strong class="bold">rend()</strong>; ++it) {
        cout &lt;&lt; format("{}: {}\n", it-&gt;first, it-&gt;second);
    }
    cout &lt;&lt; '\n';
}</pre>
			<p>Notice the<a id="_idIndexMarker309"/> reverse<a id="_idIndexMarker310"/> iterators, <code>rbegin()</code> and <code>rend()</code>. It's not possible to change the sort order of a <code>multimap</code>, but it does provide reverse iterators. This makes the <code>multimap</code> behave exactly as we need it for our prioritized list.</p>
		</div>
	</body></html>