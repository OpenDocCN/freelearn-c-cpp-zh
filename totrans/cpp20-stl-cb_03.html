<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-77"><em class="italic"><a id="_idTextAnchor076"/>Chapter 3</em>: STL Containers</h1>
			<p>In this chapter, we will focus on the container classes in the STL. In short, a <em class="italic">container</em> is an object that contains a collection of other objects, or <em class="italic">elements</em>. The STL provides a complete suite of container types that form the foundation of the STL itself.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>A quick overview of the STL container types</h1>
			<p>The STL provides a <a id="_idIndexMarker150"/>comprehensive set of container types, including <em class="italic">sequential containers</em>, <em class="italic">associative containers</em>, and <em class="italic">container adapters</em>. Here's a brief overview: </p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Sequential containers</h2>
			<p>The sequential containers <a id="_idIndexMarker151"/>provide an interface where the <a id="_idIndexMarker152"/>elements are arranged in sequence. While you may use the elements sequentially, some of these containers use contiguous storage, and others do not. The STL includes these sequential containers:</p>
			<ul>
				<li>The <strong class="source-inline">array</strong> is a<a id="_idIndexMarker153"/> fixed-size sequence that holds a specific <a id="_idIndexMarker154"/>number of elements in contiguous storage. Once allocated, it cannot change size. This is the simplest and fastest contiguous storage container.</li>
				<li>The <strong class="source-inline">vector</strong> is like an array <a id="_idIndexMarker155"/>that can shrink and grow. Its <a id="_idIndexMarker156"/>elements are stored contiguously, so changing size may involve the expense of allocating memory and moving data. A <strong class="source-inline">vector</strong> may keep extra space in reserve to mitigate that cost. Inserting and deleting elements from anywhere other than the <em class="italic">back</em> of a <strong class="source-inline">vector</strong> will trigger realignment of the elements to maintain contiguous storage.</li>
				<li>The <strong class="source-inline">list</strong> is a <a id="_idIndexMarker157"/>doubly-linked list structure that allows <a id="_idIndexMarker158"/>elements to be inserted and deleted in constant (<em class="italic">O(1)</em>) time. Traversing the list happens in linear <em class="italic">O(n)</em> time. A single-linked variant is available as <strong class="source-inline">forward_list</strong>, which only iterates forward. A <strong class="source-inline">forward_list</strong> uses less space and is somewhat more efficient than a doubly-linked <strong class="source-inline">list</strong>, but lacks some capability.</li>
				<li>The <strong class="source-inline">deque</strong> (commonly pronounced, <em class="italic">deck</em>) is a <strong class="bold">d</strong>ouble-<strong class="bold">e</strong>nded <strong class="bold">que</strong>ue. It's a sequential container that can be expanded or contracted on both ends. A <strong class="source-inline">deque</strong> allows <a id="_idIndexMarker159"/>random access to its elements, much <a id="_idIndexMarker160"/>like a <strong class="source-inline">vector</strong>, but does not guarantee contiguous storage.</li>
			</ul>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Associative containers</h2>
			<p>An associative <a id="_idIndexMarker161"/>container associates a key with each <a id="_idIndexMarker162"/>element. Elements are referenced by their key, rather than their position in the container. STL associative containers include these containers:</p>
			<ul>
				<li>The <strong class="source-inline">set</strong> is an <a id="_idIndexMarker163"/>associative container where each element is <a id="_idIndexMarker164"/>also its own key. Elements are ordered, usually by some sort of binary tree. Elements in a <strong class="source-inline">set</strong> are immutable and cannot be modified, but they can be inserted and removed. Elements in a <strong class="source-inline">set</strong> are <em class="italic">unique</em>, duplicates are not allowed. A <strong class="source-inline">set</strong> iterates in order according to its sorting operators.</li>
				<li>The <strong class="source-inline">multiset</strong> is<a id="_idIndexMarker165"/> like<a id="_idIndexMarker166"/> a <strong class="source-inline">set</strong> with non-unique keys, where duplicates are allowed.</li>
				<li>The <strong class="source-inline">unordered_set</strong> is<a id="_idIndexMarker167"/> like a <strong class="source-inline">set</strong> that does not iterate in order. Elements are not sorted <a id="_idIndexMarker168"/>in any specific order, but are organized according to their hash values for fast access.</li>
				<li>The <strong class="source-inline">unordered_multiset</strong> is<a id="_idIndexMarker169"/> like an <strong class="source-inline">unordered_set</strong> with non-unique keys, where <a id="_idIndexMarker170"/>duplicates are allowed.</li>
				<li>The <strong class="source-inline">map</strong> is an <a id="_idIndexMarker171"/>associative container for key-value pairs, where<a id="_idIndexMarker172"/> each <em class="italic">key</em> is mapped to a specific <em class="italic">value</em> (or <em class="italic">payload</em>). The types of the key and value may be different. Keys are unique but values are not. A map iterates in order of its keys, according to its sorting operators.</li>
				<li>The <strong class="source-inline">multimap</strong> is<a id="_idIndexMarker173"/> like a <strong class="source-inline">map</strong> with non-unique keys, where <a id="_idIndexMarker174"/>duplicate keys are allowed.</li>
				<li>The <strong class="source-inline">unordered_map</strong> is like <a id="_idIndexMarker175"/>a<a id="_idIndexMarker176"/> map that does not iterate in order.</li>
				<li>The <strong class="source-inline">unordered_multimap</strong> is <a id="_idIndexMarker177"/>like <a id="_idIndexMarker178"/>an <strong class="source-inline">unordered_map</strong> with non-unique keys, where duplicates are allowed.</li>
			</ul>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Container adapters</h2>
			<p>A container adapter<a id="_idIndexMarker179"/> is a class which encapsulates an <a id="_idIndexMarker180"/>underlying container. The container class provides a specific set of member functions to access the underlying container elements. The STL provides these container adapters:</p>
			<ul>
				<li>The <strong class="source-inline">stack</strong> provides <a id="_idIndexMarker181"/>a <strong class="bold">LIFO</strong> (last-in, first-out) interface <a id="_idIndexMarker182"/>where elements may be added and<a id="_idIndexMarker183"/> extracted from only one end of the container. The underlying container may be one of <strong class="source-inline">vector</strong>, <strong class="source-inline">deque</strong>, or <strong class="source-inline">list</strong>. If no underlying container is specified, the default is <strong class="source-inline">deque</strong>.</li>
				<li>The <strong class="source-inline">queue</strong> provides <a id="_idIndexMarker184"/>a <strong class="bold">FIFO</strong> (first-in, first-out) interface <a id="_idIndexMarker185"/>where elements may be added at one <a id="_idIndexMarker186"/>end of the container and extracted from the other end. The underlying container may be one of <strong class="source-inline">deque</strong> or <strong class="source-inline">list</strong>. If no underlying container is specified, the default is <strong class="source-inline">deque</strong>.</li>
				<li>The <strong class="source-inline">priority_queue</strong> keeps <a id="_idIndexMarker187"/>the greatest value<a id="_idIndexMarker188"/> element at the top, according to a <em class="italic">strict weak ordering</em>. It provides a constant time lookup of the greatest value element, at the expense of logarithmic time insertion and extraction. The underlying container may be one of <strong class="source-inline">vector</strong> or <strong class="source-inline">deque</strong>. If no underlying container is specified, the default is <strong class="source-inline">vector</strong>.</li>
			</ul>
			<p>In this chapter we will cover the following recipes:</p>
			<ul>
				<li>Use uniform erasure functions to delete items from a container</li>
				<li>Delete items from an unsorted vector in constant time</li>
				<li>Access vector elements directly and safely</li>
				<li>Keep vector elements sorted</li>
				<li>Efficiently insert elements into a map</li>
				<li>Efficiently modify the keys of map items</li>
				<li>Use <strong class="source-inline">unordered_map</strong> with custom keys</li>
				<li>Use set to sort and filter user input</li>
				<li>A simple RPN calculator with deque</li>
				<li>A word frequency counter with map</li>
				<li>Find long sentences with a vector of vectors</li>
				<li>A ToDo list using multimap</li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Technical requirements</h1>
			<p>You can find the code for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap03</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Use uniform erasure functions to delete items from a container</h1>
			<p>Before C++20, the <em class="italic">erase-remove idiom</em> was<a id="_idIndexMarker189"/> commonly <a id="_idIndexMarker190"/>used to efficiently delete elements from an STL container. This was a little cumbersome, but not a great burden. It was common to use a function like this for the task:</p>
			<p class="source-code">template&lt;typename Tc, typename Tv&gt;</p>
			<p class="source-code">void remove_value(Tc &amp; c, const Tv v) {</p>
			<p class="source-code">    auto remove_it = <strong class="bold">std::remove</strong>(c.begin(), c.end(), v);</p>
			<p class="source-code">    <strong class="bold">c.erase</strong>(remove_it, c.end());</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">std::remove()</strong> function is from the <strong class="source-inline">&lt;algorithms&gt;</strong> header. <strong class="source-inline">std::remove()</strong> searches for the specified value and removes it by shifting elements forward from the end of the container. It does not change the size of the container. It returns an iterator past the end of the shifted range. We then call the container's <strong class="source-inline">erase()</strong> function to delete the remaining elements.</p>
			<p>This two-step process is now reduced to one step with the new uniform erasure function:</p>
			<p class="source-code"><strong class="bold">std::erase(c, 5)</strong>;   // same as remove_value() function</p>
			<p>This one function call does the same thing as the <strong class="source-inline">remove_value()</strong> function we wrote above.</p>
			<p>There's also a version that uses a predicate function. For example, to remove all even numbered values from a numeric container:</p>
			<p class="source-code">std::erase_if(c, [](auto x) { return x % 2 == 0; });</p>
			<p>Let's look at the uniform erasure functions in a bit more detail.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>How to do it…</h2>
			<p>There are two forms of the uniform erasure functions. The first form, called <strong class="source-inline">erase()</strong>, takes two parameters, a container and a value:</p>
			<p class="source-code">erase(container, value); </p>
			<p>The container may be any of the sequential containers (<strong class="source-inline">vector</strong>, <strong class="source-inline">list</strong>, <strong class="source-inline">forward_list</strong>, <strong class="source-inline">deque</strong>), except <strong class="source-inline">array</strong>, which cannot change size.</p>
			<p>The second form, called <strong class="source-inline">erase_if()</strong>, takes a container and a predicate function:</p>
			<p class="source-code">erase_if(container, predicate); </p>
			<p>This form works with any of the containers that work with <strong class="source-inline">erase()</strong>, plus the associative containers, <strong class="source-inline">set</strong>, <strong class="source-inline">map</strong>, and their multi-key and unordered variants.</p>
			<p>The functions <strong class="source-inline">erase()</strong> and <strong class="source-inline">erase_if()</strong> are defined, as non-member functions, in the header for the corresponding container. There is no need to include another header.</p>
			<p>Let's look at some examples:</p>
			<ul>
				<li>First, let's <a id="_idIndexMarker191"/>define a simple<a id="_idIndexMarker192"/> function to print the size and elements of a sequential container:<p class="source-code">void printc(auto &amp; r) {</p><p class="source-code">    cout &lt;&lt; format("size({}) ", r.size());</p><p class="source-code">    for( auto &amp; e : r ) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; "\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">printc()</strong> function uses the C++20 <strong class="source-inline">format()</strong> function to format a string for <strong class="source-inline">cout</strong>.</p>
			<ul>
				<li>Here's a <strong class="source-inline">vector</strong> with 10 integer elements, printed with our <strong class="source-inline">printc()</strong> function:<p class="source-code">vector v{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p><p class="source-code">printc(v);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">size: 10: 0 1 2 3 4 5 6 7 8 9</strong></p>
			<p>We see that the vector has 10 elements. Now we can use <strong class="source-inline">erase()</strong> to remove all elements with the value <strong class="source-inline">5</strong>:</p>
			<p class="source-code"><strong class="bold">erase</strong>(v, 5);</p>
			<p class="source-code">printc(v);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">size: 9: 0 1 2 3 4 6 7 8 9</strong></p>
			<p>The <strong class="source-inline">vector</strong> version of the <strong class="source-inline">std::erase()</strong> function is defined in the <strong class="source-inline">&lt;vector&gt;</strong> header. After the <strong class="source-inline">erase()</strong> call, the element with the value 5 has been removed and the vector has 9 elements.</p>
			<ul>
				<li>This works<a id="_idIndexMarker193"/> just as well <a id="_idIndexMarker194"/>with a <strong class="source-inline">list</strong> container:<p class="source-code">list l{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p><p class="source-code">printc(l);</p><p class="source-code"><strong class="bold">erase</strong>(l, 5);</p><p class="source-code">printc(l);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">size: 10: 0 1 2 3 4 5 6 7 8 9</strong></p>
			<p class="source-code"><strong class="bold">size: 9: 0 1 2 3 4 6 7 8 9</strong></p>
			<p>The <strong class="source-inline">list</strong> version of the <strong class="source-inline">std::erase()</strong> function is defined in the <strong class="source-inline">&lt;list&gt;</strong> header. After the <strong class="source-inline">erase()</strong> call, the element with the value <strong class="source-inline">5</strong> has been removed and the <strong class="source-inline">list</strong> has 9 elements.</p>
			<ul>
				<li>We can use <strong class="source-inline">erase_if()</strong> to remove all the even numbered elements with a simple predicate function:<p class="source-code">vector v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p><p class="source-code">printc(v);</p><p class="source-code"><strong class="bold">erase_if</strong>(v, [](auto x) { return x % 2 == 0; });</p><p class="source-code">printc(v);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">size: 10: 0 1 2 3 4 5 6 7 8 9</strong></p>
			<p class="source-code"><strong class="bold">size: 5: 1 3 5 7 9</strong></p>
			<ul>
				<li>The <strong class="source-inline">erase_if()</strong> function <a id="_idIndexMarker195"/>also <a id="_idIndexMarker196"/>works with associative containers, like <strong class="source-inline">map</strong>:<p class="source-code">void print_assoc(auto&amp; r) {</p><p class="source-code">    cout &lt;&lt; format("size: {}: ", r.size());</p><p class="source-code">    for( <strong class="bold">auto&amp; [k, v]</strong> : r ) cout &lt;&lt; format("{}:{} ",</p><p class="source-code">        k, v);</p><p class="source-code">    cout &lt;&lt; "\n";</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    map&lt;int, string&gt; m{ {1, "uno"}, {2, "dos"},</p><p class="source-code">        {3, "tres"}, {4, "quatro"}, {5, "cinco"} };</p><p class="source-code">    print_assoc(m);</p><p class="source-code">    <strong class="bold">erase_if</strong>(m, </p><p class="source-code">        [](auto&amp; p) { <strong class="bold">auto&amp; [k, v] = p</strong>;</p><p class="source-code">        return k % 2 == 0; }</p><p class="source-code">    );</p><p class="source-code">    print_assoc(m);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">size: 5: 1:uno 2:dos 3:tres 4:quatro 5:cinco</strong></p>
			<p class="source-code"><strong class="bold">size: 3: 1:uno 3:tres 5:cinco</strong></p>
			<p>Because each element of a <strong class="source-inline">map</strong> is returned as a <strong class="source-inline">pair</strong>, we need a different function to print them. The <strong class="source-inline">print_assoc()</strong> function unpacks the <strong class="source-inline">pair</strong> elements with a <em class="italic">structured binding</em> in the <strong class="source-inline">for</strong> loop. We also use a structured binding in the predicate function of <strong class="source-inline">erase_if()</strong> to isolate the key for filtering the even numbered elements.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>How it works…</h2>
			<p>The <strong class="source-inline">erase()</strong> and <strong class="source-inline">erase_if()</strong> functions are simply wrappers that perform the <em class="italic">erase-remove idiom</em> in one step. They<a id="_idIndexMarker197"/> perform <a id="_idIndexMarker198"/>the same operations as a function, like this:</p>
			<p class="source-code">template&lt;typename Tc, typename Tv&gt;</p>
			<p class="source-code">void remove_value(Tc &amp; c, const Tv v) {</p>
			<p class="source-code">    auto remove_it = std::remove(c.begin(), c.end(), v);</p>
			<p class="source-code">    c.erase(remove_it, c.end());</p>
			<p class="source-code">}</p>
			<p>If we consider a simple <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong>, called <strong class="source-inline">vec</strong>, with the following values:</p>
			<p class="source-code">vector vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p>
			<p>We can visualize <strong class="source-inline">vec</strong> as a one-row table of <strong class="source-inline">int</strong> values:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B18267_03_01.jpg" alt="Figure 3.1 – begin() and end() iterators&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – begin() and end() iterators</p>
			<p>The <strong class="source-inline">begin()</strong> iterator points at the first element, and the <strong class="source-inline">end()</strong> iterator points <em class="italic">past</em> the last element. This configuration is standard for all STL sequential containers.</p>
			<p>When we call <strong class="source-inline">remove(c.begin(), c.end(), 5)</strong>, the algorithm searches for matching elements, starting at the <strong class="source-inline">begin()</strong> iterator. For each matching element that it finds, it shifts the next element into its place. It continues searching and shifting until it reaches the <strong class="source-inline">end()</strong> iterator. The result is a container where all the remaining elements are at the beginning, without the deleted elements, and in their original order. The <strong class="source-inline">end()</strong> iterator is unchanged and the remaining elements are <em class="italic">undefined</em>. We can visualize the operation like this:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B18267_03_02.jpg" alt="Figure 3.2 – Removing an element&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Removing an element</p>
			<p>The <strong class="source-inline">remove()</strong> function<a id="_idIndexMarker199"/> returns<a id="_idIndexMarker200"/> an iterator (<strong class="source-inline">remove_it</strong>) that points to the first element <em class="italic">past</em> the elements that were shifted. The <strong class="source-inline">end()</strong> iterator remains as it was before the <strong class="source-inline">remove() </strong>operation. To further illustrate, if we were to remove all even-numbered elements using <strong class="source-inline">remove_if()</strong>, our result would look like this:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B18267_03_03.jpg" alt="Figure 3.3 – After removing even-numbered elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – After removing even-numbered elements</p>
			<p>In this case, all that remains is the five odd-numbered elements followed by five elements of <em class="italic">undefined</em> value.</p>
			<p>The container's <strong class="source-inline">erase()</strong> function is then called to erase the remaining elements:</p>
			<p class="source-code">c.erase(remove_it, c.end());</p>
			<p>The container's <strong class="source-inline">erase()</strong> function is called with the <strong class="source-inline">remove_it</strong> and <strong class="source-inline">end()</strong> iterators to delete all the undefined elements.</p>
			<p>The <strong class="source-inline">erase()</strong> and <strong class="source-inline">erase_if()</strong> functions<a id="_idIndexMarker201"/> call <a id="_idIndexMarker202"/>both the <strong class="source-inline">remove()</strong> function and the container's <strong class="source-inline">erase()</strong> function, in order to perform the <em class="italic">erase-remove idiom</em> in one step.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Delete items from an unsorted vector in constant time</h1>
			<p>Using the uniform<a id="_idIndexMarker203"/> erasure functions (or the <em class="italic">erase-remove idiom</em>) to delete items from the middle of a vector takes <em class="italic">O(n)</em> (<em class="italic">linear</em>) time. This is because elements must be shifted from the end of the vector to close the gap of the deleted items. If the order of items in the vector is not important, we can optimize this process to take <em class="italic">O(1)</em> (<em class="italic">constant</em>) time. Here's how.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>How to do it…</h2>
			<p>This recipe takes advantage of the fact that removing an element from the end of a vector is quick and easy.</p>
			<ul>
				<li>Let's start by defining a function to print out a vector:<p class="source-code">void printc(auto &amp; r) {</p><p class="source-code">    cout &lt;&lt; format("size({}) ", r.size());</p><p class="source-code">    for( auto &amp; e : r ) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
				<li>In our <strong class="source-inline">main()</strong> function we define a vector of <strong class="source-inline">int</strong> and print it using <strong class="source-inline">printc()</strong>:<p class="source-code">int main() {</p><p class="source-code">    vector v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</p><p class="source-code">    printc(v);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">size(10) 0 1 2 3 4 5 6 7 8 9</strong></p>
			<ul>
				<li>Now we'll<a id="_idIndexMarker204"/> write the function that will delete an element from the vector:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">void quick_delete(T&amp; v, size_t idx) {</p><p class="source-code">    if (idx &lt; v.size()) {</p><p class="source-code">        v[idx] = <strong class="bold">move(v.back())</strong>;</p><p class="source-code">        <strong class="bold">v.pop_back()</strong>;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">quick_delete()</strong> function takes two arguments, a vector <strong class="source-inline">v</strong> and an index <strong class="source-inline">idx</strong>. We first check to make sure our index is within boundaries. Then we call the <strong class="source-inline">move()</strong> function from the <strong class="source-inline">&lt;algorithms&gt;</strong> header to move the last element of the vector to the position of our index. Finally, the <strong class="source-inline">v.pop_back()</strong> function is called to shorten the vector from the back.</p>
			<ul>
				<li>Let's also include a version of <strong class="source-inline">quick_delete()</strong> for use with an iterator instead of an index.<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">void quick_delete(T&amp; v, typename T::iterator it) {</p><p class="source-code">    if (it &lt; v.end()) {</p><p class="source-code">        *it = <strong class="bold">move(v.back())</strong>;</p><p class="source-code">        <strong class="bold">v.pop_back()</strong>;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>This<a id="_idIndexMarker205"/> version of <strong class="source-inline">quick_delete()</strong> operates from an iterator instead of an index. Otherwise, it works the same as the indexed version.</p>
			<ul>
				<li>Now we can call it from our <strong class="source-inline">main()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    vector v{ 12, 196, 47, 38, 19 };</p><p class="source-code">    printc(v);</p><p class="source-code">    auto it = std::ranges::find(v, 47);</p><p class="source-code">    quick_delete(v, it);</p><p class="source-code">    printc(v);</p><p class="source-code">    quick_delete(v, 1);</p><p class="source-code">    printc(v);</p><p class="source-code">}</p></li>
			</ul>
			<p>And the output will look like this:</p>
			<p class="source-code"><strong class="bold">size(5) 12 196 47 38 19</strong></p>
			<p class="source-code"><strong class="bold">size(4) 12 196 19 38</strong></p>
			<p class="source-code"><strong class="bold">size(3) 12 38 19</strong></p>
			<p>The first call to <strong class="source-inline">quick_delete()</strong> uses an iterator from the <strong class="source-inline">std::ranges::find()</strong><strong class="source-inline"> </strong>algorithm. This deletes the value <strong class="source-inline">47</strong> from the vector. Notice the value from the back of the vector (<strong class="source-inline">19</strong>) takes its place. The second call to <strong class="source-inline">quick_delete()</strong> uses an index (<strong class="source-inline">1</strong>) to delete the second element from the vector (<strong class="source-inline">196</strong>). Again, the value from the back of the vector takes its place.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>How it works…</h2>
			<p>The <strong class="source-inline">quick_delete()</strong> function uses a simple trick to delete elements from a vector quickly and <a id="_idIndexMarker206"/>efficiently. The element at the back of the vector is moved (<em class="italic">not copied</em>) into the position of the element to be deleted. The deleted element is discarded in the process. Then, the <strong class="source-inline">pop_back()</strong> function shortens the vector by one element from the end.</p>
			<p>This takes advantage of the fact that deleting the element at the back of the vector is especially cheap. The <strong class="source-inline">pop_back()</strong> function operates at constant complexity, as it only needs to change the <strong class="source-inline">end()</strong> iterator.</p>
			<p>This diagram shows the state of the vector before and after the <strong class="source-inline">quick_delete()</strong> operation:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B18267_03_04.jpg" alt="Figure 3.4 – Before and after quick_delete()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Before and after quick_delete()</p>
			<p>The <strong class="source-inline">quick_remove()</strong> operation simply <em class="italic">moves</em> the element from the back of the vector into the position of the iterator (<strong class="source-inline">it</strong>), then shortens the vector by one element. It's important to use <strong class="source-inline">std::move()</strong> instead of an assignment to move the element. The move <a id="_idIndexMarker207"/>operation is much faster than a copy-assignment, especially for large objects.</p>
			<p>If you don't require ordered elements, this is an extremely efficient technique. It happens in constant (<em class="italic">O(1)</em>) time and without touching any other elements.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Access vector elements directly and safely</h1>
			<p>The <strong class="source-inline">vector</strong> is one of <a id="_idIndexMarker208"/>the most widely used containers in the STL, and for good reason. It's just as convenient as an <strong class="source-inline">array</strong> but far more powerful and flexible. It's common practice to use the <strong class="source-inline">[]</strong> operator to access elements in a vector like this:</p>
			<p class="source-code">vector v{ 19, 71, 47, 192, 4004 };</p>
			<p class="source-code">auto &amp; i = v[2];</p>
			<p>The <strong class="source-inline">vector</strong> class also provides a member function for the same purpose:</p>
			<p class="source-code">auto &amp; i = v.at(2);</p>
			<p>The result is the same but there is an important difference. The <strong class="source-inline">at()</strong> function does bounds checking and the <strong class="source-inline">[]</strong> operator does not. This is intentional, as it allows the <strong class="source-inline">[]</strong> operator to maintain compatibility with the original C-array. Let's examine this in a bit more detail.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>How to do it…</h2>
			<p>There are two ways to access an element with an index in a vector. The <strong class="source-inline">at()</strong> member function does bounds checking, and the <strong class="source-inline">[]</strong> operator does not.</p>
			<ul>
				<li>Here's a<a id="_idIndexMarker209"/> simple <strong class="source-inline">main()</strong> function that initializes a vector and accesses an element:<p class="source-code">int main() {</p><p class="source-code">    vector v{ 19, 71, 47, 192, 4004 };</p><p class="source-code">    auto &amp; i = v[2];</p><p class="source-code">    cout &lt;&lt; format("element is {}\n", i);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">element is 47</strong></p>
			<p>Here, I used the <strong class="source-inline">[]</strong> operator to directly access the third element in the vector. As with most sequential objects in C++, the index starts at <strong class="source-inline">0</strong> so the third element is number <strong class="source-inline">2</strong>.</p>
			<ul>
				<li>The vector has five elements, numbered <strong class="source-inline">0</strong> through <strong class="source-inline">4</strong>. If I were to try to access element number <strong class="source-inline">5</strong> that would be beyond the boundary of the vector:<p class="source-code">vector v{ 19, 71, 47, 192, 4004 };</p><p class="source-code">auto &amp; i = v[5];</p><p class="source-code">cout &lt;&lt; format("element is {}\n", i);</p><p class="source-code">element is 0</p></li>
			</ul>
			<p>This result is extremely deceiving. It's a common error, since humans tend to count from 1, not 0. But there is no guarantee that an element past the end of the vector has any particular value.</p>
			<ul>
				<li>Even worse, the <strong class="source-inline">[]</strong> operator will silently allow you to <em class="italic">write</em> to a position beyond the end of the vector:<p class="source-code">vector v{ 19, 71, 47, 192, 4004 };</p><p class="source-code">v[5] = 2001;</p><p class="source-code">auto &amp; i = v[5];</p><p class="source-code">cout &lt;&lt; format("element is {}\n", i);</p><p class="source-code">element is 2001</p></li>
			</ul>
			<p>I have now written<a id="_idIndexMarker210"/> to memory that is not under my control and the compiler has <em class="italic">silently</em> allowed it, with no error messages or crashes. But do not be fooled—this is extremely dangerous code, and it <em class="italic">will</em> cause problems at some point in the future. Out of bounds memory access is one of the primary causes of security breaches.</p>
			<ul>
				<li>The solution is to use the <strong class="source-inline">at()</strong> member function wherever possible, instead of the <strong class="source-inline">[]</strong> operator:<p class="source-code">vector v{ 19, 71, 47, 192, 4004 };</p><p class="source-code">auto &amp; i = v.at(5);</p><p class="source-code">cout &lt;&lt; format("element is {}\n", i);</p></li>
			</ul>
			<p>Now we get a run-time exception:</p>
			<p class="source-code">terminate called after throwing an instance of 'std::out_of_range'</p>
			<p class="source-code">  what():  vector::_M_range_check: __n (which is 5) &gt;= this-&gt;size() (which is 5)</p>
			<p class="source-code">Aborted</p>
			<p>The code compiles without error, but the <strong class="source-inline">at()</strong> function checks the boundaries of the container and throws a <em class="italic">run-time exception</em> when you try to access memory outside of those boundaries. This is the exception message from code compiled with the GCC compiler. The message will be different in different environments.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>How it works…</h2>
			<p>The <strong class="source-inline">[]</strong> operator and the <strong class="source-inline">at()</strong> member function do the same job; they provide direct access to container elements based on their indexed position. The <strong class="source-inline">[]</strong> operator does it without any bounds checking, so it may be a tiny bit faster in some intensely iterative applications.</p>
			<p>That said, the <strong class="source-inline">at()</strong> function <em class="italic">should be your default choice</em>. While the bounds checking may take a few CPU cycles, it's cheap insurance. For most applications the benefit is well <a id="_idIndexMarker211"/>worth the cost.</p>
			<p>While the <strong class="source-inline">vector</strong> class is commonly used as a direct-access container, the <strong class="source-inline">array</strong> and <strong class="source-inline">deque</strong> containers also support both the <strong class="source-inline">[]</strong> operator and the <strong class="source-inline">at()</strong> member function. These caveats apply there as well.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>There's more…</h2>
			<p>In some applications you may not want your application to just <em class="italic">crash</em> when an out-of-bounds condition is encountered. In this case, you can <em class="italic">catch</em> the exception, like this:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    vector v{ 19, 71, 47, 192, 4004 };</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        v.at(5) = 2001;</p>
			<p class="source-code">    } catch (const std::out_of_range &amp; e) {</p>
			<p class="source-code">        std::cout &lt;&lt;</p>
			<p class="source-code">            format("Ouch!\n{}\n", e.what());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    cout &lt;&lt; format("end element is {}\n", v.back());</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">Ouch!</p>
			<p class="source-code">vector::_M_range_check: __n (which is 5) &gt;= this-&gt;size() (which is 5)</p>
			<p class="source-code">end element is 4004</p>
			<p>The <strong class="source-inline">try</strong> block catches the exception specified in the <strong class="source-inline">catch</strong> clause, in this case the exception is <strong class="source-inline">std::out_of_range</strong>. The <strong class="source-inline">e.what()</strong> function returns a C-string with the error <a id="_idIndexMarker212"/>message from the STL library. Each library will have different messages.</p>
			<p>Keep in mind that this also applies to <strong class="source-inline">array</strong> and <strong class="source-inline">deque</strong> containers.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Keep vector elements sorted</h1>
			<p>The <strong class="source-inline">vector</strong> is a <a id="_idIndexMarker213"/>sequential container that keeps elements in the order in which they were inserted. It does not sort elements, nor change their order in any way. Other containers, such as <strong class="source-inline">set</strong> and <strong class="source-inline">map</strong>, keep elements sorted, but those containers are not random-access and may not have the features you need. You can, however, keep your vector sorted. It just requires a little bit of management.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>How to do it…</h2>
			<p>The idea with this recipe is to create a simple function, <strong class="source-inline">insert_sorted()</strong>, that inserts an element into the correct position in a vector to keep the vector sorted.</p>
			<ul>
				<li>For convenience, we'll start with a <em class="italic">type alias</em> for a vector of strings:<p class="source-code"><strong class="bold">using Vstr</strong> = std::vector&lt;std::string&gt;;</p></li>
			</ul>
			<p>I like a type alias here because the exact details of the vector are not so important as its application.</p>
			<ul>
				<li>Then we can define a couple of support functions:<p class="source-code">// print a vector</p><p class="source-code">void <strong class="bold">printv</strong>(const auto&amp; v) {</p><p class="source-code">    for(const auto&amp; e : v) {</p><p class="source-code">        cout &lt;&lt; format("{} ", e);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; "\n";</p><p class="source-code">}</p><p class="source-code">// is it sorted? </p><p class="source-code">void <strong class="bold">psorted</strong>(const Vstr&amp; v) {</p><p class="source-code">    if(<strong class="bold">std::ranges::is_sorted(v)</strong>) cout&lt;&lt; "sorted: ";</p><p class="source-code">    else cout &lt;&lt; "unsorted: ";</p><p class="source-code">    printv(v);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">printv()</strong> function<a id="_idIndexMarker214"/> is simple enough; it prints the elements of the vector on one line.</p>
			<p>The <strong class="source-inline">psorted()</strong> function uses the <em class="italic">ranges</em> version of the <strong class="source-inline">is_sorted()</strong> algorithm to tell us if the vector is sorted. Then it calls <strong class="source-inline">printv()</strong> to print the vector.</p>
			<ul>
				<li>Now we can initialize a <strong class="source-inline">Vstr</strong> vector in our <strong class="source-inline">main()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    Vstr v{ </p><p class="source-code">        "Miles",</p><p class="source-code">        "Hendrix",</p><p class="source-code">        "Beatles",</p><p class="source-code">        "Zappa",</p><p class="source-code">        "Shostakovich"</p><p class="source-code">    };</p><p class="source-code">    psorted(v);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">unsorted: Miles Hendrix Beatles Zappa Shostakovich</strong></p>
			<p>At this point we have a <strong class="source-inline">Vstr</strong> vector with the names of some interesting musicians, in no particular order.</p>
			<ul>
				<li>Let's sort our vector using the <strong class="source-inline">ranges</strong> version of the <strong class="source-inline">sort()</strong> algorithm.<p class="source-code"><strong class="bold">std::ranges::sort(v)</strong>;</p><p class="source-code">psorted(v);</p></li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">sorted: Beatles Hendrix Miles Shostakovich Zappa</strong></p>
			<ul>
				<li>At this point, we<a id="_idIndexMarker215"/> want to be able to insert items into the vector so that they're already in sorted order. The <strong class="source-inline">insert_sorted()</strong> function does this for us:<p class="source-code">void insert_sorted(Vstr&amp; v, const string&amp; s) {</p><p class="source-code">    const auto pos{ <strong class="bold">std::ranges::lower_bound(v, s)</strong> };</p><p class="source-code">    v.insert(pos, s);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">insert_sorted()</strong> function uses the <em class="italic">ranges</em> version of the <strong class="source-inline">lower_bound()</strong> algorithm to get an iterator for the <strong class="source-inline">insert()</strong> function that keeps the vector sorted.</p>
			<ul>
				<li>Now we can use the <strong class="source-inline">insert_sorted()</strong> function to insert more musicians into the vector:<p class="source-code">insert_sorted(v, "Ella");</p><p class="source-code">insert_sorted(v, "Stones");</p></li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">sorted: Beatles Ella Hendrix Miles Shostakovich Stones Zappa</strong></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>How it works…</h2>
			<p>The <strong class="source-inline">insert_sorted()</strong> function is used to insert elements into a sorted vector while maintaining<a id="_idIndexMarker216"/> its order:</p>
			<p class="source-code">void insert_sorted(Vstr&amp; v, const string&amp; s) {</p>
			<p class="source-code">    const auto pos{ <strong class="bold">std::ranges::lower_bound(v, s)</strong> };</p>
			<p class="source-code">    v.insert(pos, s);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">lower_bound()</strong> algorithm finds the first element <em class="italic">not less than</em> the argument. We then use the iterator returned by <strong class="source-inline">lower_bound()</strong> to insert an element at the correct position.</p>
			<p>In this case we're using the ranges version of <strong class="source-inline">lower_bound()</strong>, but either version will work.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>There's more…</h2>
			<p>The <strong class="source-inline">insert_sorted()</strong> function can be made more generic by using a template. This version will work with other container types, such as <strong class="source-inline">set</strong>, <strong class="source-inline">deque</strong>, and <strong class="source-inline">list</strong>.</p>
			<p class="source-code"><strong class="bold">template&lt;typename C, typename E&gt;</strong></p>
			<p class="source-code">void insert_sorted(C&amp; c, const E&amp; e) {</p>
			<p class="source-code">    const auto pos{ std::ranges::lower_bound(c, e) };</p>
			<p class="source-code">    c.insert(pos, e);</p>
			<p class="source-code">}</p>
			<p>Keep in mind that the <strong class="source-inline">std::sort()</strong> algorithm (and its derivatives) requires a container that <a id="_idIndexMarker217"/>supports random access. Not all STL containers fulfill this requirement. Notably, <strong class="source-inline">std::list</strong> does not.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Efficiently insert elements into a map</h1>
			<p>The <strong class="source-inline">map</strong> class is an<a id="_idIndexMarker218"/> associative container that holds <em class="italic">key-value pairs</em>, where<a id="_idIndexMarker219"/> keys must be unique within the container.</p>
			<p>There are a number of ways to populate a map container. Consider a <strong class="source-inline">map</strong> defined like this:</p>
			<p class="source-code">map&lt;string, string&gt; m;</p>
			<p>You can add an element with the <strong class="source-inline">[]</strong> operator:</p>
			<p class="source-code">m["Miles"] = "Trumpet"</p>
			<p>You can use the <strong class="source-inline">insert()</strong> member function:</p>
			<p class="source-code">m.insert(pair&lt;string,string&gt;("Hendrix", "Guitar"));</p>
			<p>Or, you can use the <strong class="source-inline">emplace()</strong> member function:</p>
			<p class="source-code">m.emplace("Krupa", "Drums");</p>
			<p>I tend to gravitate toward the <strong class="source-inline">emplace()</strong> function. Introduced with C++11, <strong class="source-inline">emplace()</strong> uses <em class="italic">perfect forwarding</em> to <strong class="bold">emplace</strong> (create in place) the new element for the container. The<a id="_idIndexMarker220"/> parameters are forwarded directly to the element constructors. This is quick, efficient, and easy to code.</p>
			<p>Though it's certainly an improvement over the other options, the problem with <strong class="source-inline">emplace()</strong> is that it constructs an object even when it's not needed. This involves calling the constructors, allocating memory, and moving data around, and then discarding that temporary object.</p>
			<p>To solve this problem, C++17 provides the new <strong class="source-inline">try_emplace()</strong> function which only constructs the <em class="italic">value object</em> if it's needed. This is especially important with large objects or many emplacements.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Each element of a <em class="italic">map</em> is a key-value <em class="italic">pair</em>. Within the pair structure, the elements are named, <strong class="source-inline">first</strong> and <strong class="source-inline">second</strong>, but their purpose in the map is <em class="italic">key</em> and <em class="italic">value</em>. I tend to think of the value object as the <em class="italic">payload</em>, as this is usually the point of the map. To search for an existing key, the <strong class="source-inline">try_emplace()</strong> function must construct the key object; this cannot be avoided. But it need not construct the payload object unless and until it's needed for insertion into the map.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>How to do it…</h2>
			<p>The new <strong class="source-inline">try_emplace()</strong> function avoids the overhead of constructing the <em class="italic">payload object</em> unless and until it is needed. This creates a valuable efficiency in the case of key collisions, especially<a id="_idIndexMarker221"/> with <a id="_idIndexMarker222"/>large payloads. Let's take a look:</p>
			<ul>
				<li>First, we create a payload class. For demonstration purposes, this class has a simple <strong class="source-inline">std::string</strong> payload and displays a message when constructed:<p class="source-code">struct BigThing {</p><p class="source-code">    string v_;</p><p class="source-code">    BigThing(const char * v) : v_(v) {</p><p class="source-code">        cout &lt;&lt; format("BigThing constructed {}\n", v_);</p><p class="source-code">    }</p><p class="source-code">};</p><p class="source-code">using Mymap = map&lt;string, BigThing&gt;;</p></li>
			</ul>
			<p>This <strong class="source-inline">BigThing</strong> class has only one member function, a constructor that displays a message when the object is constructed. We'll use this to keep track of how often a <strong class="source-inline">BigThing</strong> object is constructed. In practice, of course, this class would be bigger, and use more resources.</p>
			<p>Each map element will consist of a pair of objects, a <strong class="source-inline">std::string</strong> for the key and a <strong class="source-inline">BigThing</strong> object for the payload. <strong class="source-inline">Mymap</strong> is just a convenience alias. This allows us to focus on function rather than form.</p>
			<ul>
				<li>We'll also create a <strong class="source-inline">printm()</strong> function to print the contents of the map:<p class="source-code">void printm(Mymap&amp; m) {</p><p class="source-code">    for(auto&amp; [k, v] : m) {</p><p class="source-code">        cout &lt;&lt; format("[{}:{}] ", k, v.v_);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; "\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>This uses <a id="_idIndexMarker223"/>the C++20 <strong class="source-inline">format()</strong> function to print out the map, so <a id="_idIndexMarker224"/>we can keep track of the elements as we insert them.</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function we create the map object and insert some elements:<p class="source-code">int main() {</p><p class="source-code">    Mymap m;</p><p class="source-code">    m.emplace("Miles", "Trumpet");</p><p class="source-code">    m.emplace("Hendrix", "Guitar");</p><p class="source-code">    m.emplace("Krupa", "Drums");</p><p class="source-code">    m.emplace("Zappa", "Guitar");</p><p class="source-code">    m.emplace("Liszt", "Piano");</p><p class="source-code">    printm(m);</p><p class="source-code">} </p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">BigThing constructed Trumpet</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Guitar</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Drums</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Guitar</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Piano</strong></p>
			<p class="source-code"><strong class="bold">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]</strong></p>
			<p>Our output shows the construction of each of the payload objects, and then the output from the <strong class="source-inline">printm()</strong> function call.</p>
			<ul>
				<li>I used the <strong class="source-inline">emplace()</strong> function to add the elements to the map, and each payload element was constructed just once. We can use the <strong class="source-inline">try_emplace()</strong> function<a id="_idIndexMarker225"/> and<a id="_idIndexMarker226"/> the result will be the same:<p class="source-code">Mymap m;</p><p class="source-code">m.try_emplace("Miles", "Trumpet");</p><p class="source-code">m.try_emplace("Hendrix", "Guitar");</p><p class="source-code">m.try_emplace("Krupa", "Drums");</p><p class="source-code">m.try_emplace("Zappa", "Guitar");</p><p class="source-code">m.try_emplace("Liszt", "Piano");</p><p class="source-code">printm(m);</p></li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">BigThing constructed Trumpet</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Guitar</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Drums</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Guitar</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Piano</strong></p>
			<p class="source-code"><strong class="bold">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]</strong></p>
			<ul>
				<li>The difference between <strong class="source-inline">emplace()</strong> and <strong class="source-inline">try_emplace()</strong> shows up when we try to insert new elements with duplicate keys:<p class="source-code">cout &lt;&lt; "emplace(Hendrix)\n";</p><p class="source-code">m.emplace("Hendrix", "Singer");</p><p class="source-code">cout &lt;&lt; "try_emplace(Zappa)\n";</p><p class="source-code">m.try_emplace("Zappa", "Composer"); </p><p class="source-code">printm(m); </p></li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">emplace(Hendrix)</strong></p>
			<p class="source-code"><strong class="bold">BigThing constructed Singer</strong></p>
			<p class="source-code"><strong class="bold">try_emplace(Zappa)</strong></p>
			<p class="source-code"><strong class="bold">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Guitar]</strong> </p>
			<p>The <strong class="source-inline">emplace()</strong> function<a id="_idIndexMarker227"/> tried to add an element with a <a id="_idIndexMarker228"/>duplicate key (<strong class="source-inline">"Hendrix"</strong>). It failed but <em class="italic">still constructed</em> the payload object (<strong class="source-inline">"Singer"</strong>). The <strong class="source-inline">try_emplace()</strong> function also tried to add an element with a duplicate key (<strong class="source-inline">"Zappa"</strong>). It failed and <em class="italic">did not</em> construct the payload object.</p>
			<p>This example demonstrates the distinction between <strong class="source-inline">emplace()</strong> and <strong class="source-inline">try_emplace()</strong>.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>How it works…</h2>
			<p>The <strong class="source-inline">try_emplace()</strong> function signature is similar to that of <strong class="source-inline">emplace()</strong>, so it should be easy to retrofit legacy code. Here's the <strong class="source-inline">try_emplace()</strong> function signature:</p>
			<p class="source-code">pair&lt;iterator, bool&gt; try_emplace( const Key&amp; k, Args&amp;&amp;... args );</p>
			<p>At first glance, this looks different from the <strong class="source-inline">emplace()</strong> signature:</p>
			<p class="source-code">pair&lt;iterator,bool&gt; emplace( Args&amp;&amp;... args );</p>
			<p>The distinction is that <strong class="source-inline">try_emplace()</strong> uses a separate parameter for the <em class="italic">key</em> argument, which allows it to be isolated for construction. Functionally, if you're using <em class="italic">template argument deduction</em>, <strong class="source-inline">try_emplace()</strong> can be a drop-in replacement:</p>
			<p class="source-code">m.emplace("Miles", "Trumpet");</p>
			<p class="source-code">m.try_emplace("Miles", "Trumpet");</p>
			<p>The return value of <strong class="source-inline">try_emplace()</strong> is the same as that of <strong class="source-inline">emplace()</strong>, a pair representing <a id="_idIndexMarker229"/>an <a id="_idIndexMarker230"/>iterator and a bool:</p>
			<p class="source-code">const char * key{"Zappa"};</p>
			<p class="source-code">const char * payload{"Composer"};</p>
			<p class="source-code">if(auto [it, success] = m.try_emplace(key, payload);</p>
			<p class="source-code">        !success) {</p>
			<p class="source-code">    cout &lt;&lt; "update\n";</p>
			<p class="source-code">    it-&gt;second = payload;</p>
			<p class="source-code">}</p>
			<p class="source-code">printm(m);</p>
			<p>Output: </p>
			<p class="source-code">update</p>
			<p class="source-code">BigThing constructed Composer</p>
			<p class="source-code">[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet] [Zappa:Composer]</p>
			<p>Here I used <em class="italic">structured binding</em> (<strong class="source-inline">auto [it, success] =</strong>) with an <strong class="source-inline">if</strong> <em class="italic">initializer statement</em> to test the return value and conditionally update the payload. Notice that it still just constructs the payload object once.</p>
			<p>It's worth noting that the <strong class="source-inline">try_emplace()</strong> function also works with <strong class="source-inline">unordered_map</strong>. We change our alias and everything works the same except unordered:</p>
			<p class="source-code">using Mymap = unordered_map&lt;string, BigThing&gt;; </p>
			<p>The advantage of <strong class="source-inline">try_emplace()</strong> is that it only constructs the payload object <em class="italic">if and when</em> it's ready to store it in the map. In practice, this should save significant resources at run-time. You <a id="_idIndexMarker231"/>should<a id="_idIndexMarker232"/> always favor <strong class="source-inline">try_emplace()</strong> over <strong class="source-inline">emplace()</strong>.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Efficiently modify the keys of map items</h1>
			<p>A <strong class="source-inline">map</strong> is an <a id="_idIndexMarker233"/>associative container that stores key-value pairs. The container is <a id="_idIndexMarker234"/>ordered by the keys. The keys must be unique and they are <strong class="source-inline">const</strong>-qualified, so they cannot be changed.</p>
			<p>For example, if I populate a <strong class="source-inline">map</strong> and attempt to change the key, I'll get an error at compilation time:</p>
			<p class="source-code">map&lt;int, string&gt; mymap {</p>
			<p class="source-code">    {1, "foo"}, {2, "bar"}, {3, "baz"}</p>
			<p class="source-code">};</p>
			<p class="source-code">auto it = mymap.begin(); </p>
			<p class="source-code">it-&gt;first = 47;</p>
			<p>Output:</p>
			<p class="source-code">error: assignment of read-only member ...</p>
			<p class="source-code">    5 |     it-&gt;first = 47;</p>
			<p class="source-code">      |     ~~~~~~~~~~^~~~</p>
			<p>If you need to re-order a map container, you may do so by swapping keys using the <strong class="source-inline">extract()</strong> method.</p>
			<p>New with C++17, <strong class="source-inline">extract()</strong> is a member function in the <strong class="source-inline">map</strong> class and its derivatives. It allows elements of a map to be extracted from the sequence without touching the payload. Once extracted, the key is no longer <strong class="source-inline">const</strong>-qualified and may be modified.</p>
			<p>Let's look at an example.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>How to do it…</h2>
			<p>In this example we'll define a map that represents contestants in a race. At some point during the race, the order changes and we need to modify the keys of the map.</p>
			<ul>
				<li>We'll start by defining an alias for the <strong class="source-inline">map</strong> type:<p class="source-code">using Racermap = map&lt;unsigned int, string&gt;;</p></li>
			</ul>
			<p>This allows us to use the type consistently throughout our code.</p>
			<ul>
				<li>We'll write <a id="_idIndexMarker235"/>a <a id="_idIndexMarker236"/>function for printing out the map:<p class="source-code">void printm(const Racermap &amp;m)</p><p class="source-code">{</p><p class="source-code">    cout &lt;&lt; "Rank:\n";</p><p class="source-code">    for (const auto&amp; [rank, racer] : m) {</p><p class="source-code">        cout &lt;&lt; format("{}:{}\n", rank, racer);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>We can pass the map to this function at any time to print out the current rankings of our contestants.</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function we define a <strong class="source-inline">map</strong> with the initial state of our racers:<p class="source-code">int main() {</p><p class="source-code">    Racermap racers {</p><p class="source-code">        {1, "Mario"}, {2, "Luigi"}, {3, "Bowser"},</p><p class="source-code">        {4, "Peach"}, {5, "Donkey Kong Jr"}</p><p class="source-code">    };</p><p class="source-code">    printm(racers);</p><p class="source-code">    node_swap(racers, 3, 5);</p><p class="source-code">    printm(racers);</p><p class="source-code">}</p></li>
			</ul>
			<p>The key is an <strong class="source-inline">int</strong> indicating the rank of the racer. The value is a <strong class="source-inline">string</strong> with the name of the racer.</p>
			<p>We then call <strong class="source-inline">printm()</strong> to print the current rank. The call to <strong class="source-inline">node_swap()</strong> will swap the keys of two racers, then we print gain.</p>
			<ul>
				<li>At some point, one of the racers falls behind and another racer takes the opportunity to<a id="_idIndexMarker237"/> move up in the rankings. The <strong class="source-inline">node_swap()</strong> function <a id="_idIndexMarker238"/>will swap the ranking of two racers:<p class="source-code">template&lt;typename M, typename K&gt;</p><p class="source-code">bool node_swap(M &amp; m, K k1, K k2) {</p><p class="source-code">    auto node1{ m.extract(k1) };</p><p class="source-code">    auto node2{ m.extract(k2) };</p><p class="source-code">    if(node1.empty() || node2.empty()) {</p><p class="source-code">        return false;</p><p class="source-code">    }</p><p class="source-code">    swap(node1.key(), node2.key());</p><p class="source-code">    m.insert(move(node1));</p><p class="source-code">    m.insert(move(node2));</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
			</ul>
			<p>This function uses the <strong class="source-inline">map.extract()</strong> method to extract the specified elements from the map. These extracted elements are called <em class="italic">nodes</em>.</p>
			<p>A <em class="italic">node</em> is a new concept beginning with C++17. This allows an element to be extracted from a map-type structure without touching the element itself. The node is unlinked, and a <em class="italic">node handle</em> is returned. Once extracted, the node handle provides <em class="italic">writable</em> access to the key via the node's <strong class="source-inline">key()</strong> function. We can then swap the keys and insert them back into the map, without ever having to copy or manipulate the payload.</p>
			<ul>
				<li>When we run this code we get a printout of the map, before and after the node swap:</li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">Rank:</strong></p>
			<p class="source-code"><strong class="bold">1:Mario</strong></p>
			<p class="source-code"><strong class="bold">2:Luigi</strong></p>
			<p class="source-code"><strong class="bold">3:Bowser</strong></p>
			<p class="source-code"><strong class="bold">4:Peach</strong></p>
			<p class="source-code"><strong class="bold">5:Donkey Kong Jr</strong></p>
			<p class="source-code"><strong class="bold">Rank:</strong></p>
			<p class="source-code"><strong class="bold">1:Mario</strong></p>
			<p class="source-code"><strong class="bold">2:Luigi</strong></p>
			<p class="source-code"><strong class="bold">3:Donkey Kong Jr</strong></p>
			<p class="source-code"><strong class="bold">4:Peach</strong></p>
			<p class="source-code"><strong class="bold">5:Bowser</strong></p>
			<p>This is all made<a id="_idIndexMarker239"/> possible<a id="_idIndexMarker240"/> by the <strong class="source-inline">extract()</strong> method and the new <strong class="source-inline">node_handle</strong> class. Let's take a closer look at how this works.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>How it works…</h2>
			<p>This technique uses the new <strong class="source-inline">extract()</strong> function, which returns a <strong class="source-inline">node_handle</strong> object. As the name suggests, a <strong class="source-inline">node_handle</strong> is a handle to a <em class="italic">node</em>, which consists of an associative element and its related structures. The extract function <em class="italic">disassociates</em> the node while leaving it in place, and returns a <strong class="source-inline">node_handle</strong> object. This has the effect of removing the node from the associative container without touching the data itself. The <strong class="source-inline">node_handle</strong> allows you to access the disassociated node.</p>
			<p>The <strong class="source-inline">node_handle</strong> has a member function, <strong class="source-inline">key()</strong>, which returns a <em class="italic">writable</em> reference to the node key. This allows you to change the key, while it's disassociated from <a id="_idIndexMarker241"/>the <a id="_idIndexMarker242"/>container.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>There's more…</h2>
			<p>There are a few things to keep in mind when using <strong class="source-inline">extract()</strong> and a <strong class="source-inline">node_handle</strong>:</p>
			<ul>
				<li>If the key is not found, the <strong class="source-inline">extract()</strong> function returns an <em class="italic">empty</em> node handle. You can test if a node handle is empty with the <strong class="source-inline">empty()</strong> function:<p class="source-code">auto node{ mapthing.extract(key) };</p><p class="source-code">if(node.empty()) {</p><p class="source-code">    // node handle is empty</p><p class="source-code">}</p></li>
				<li>There are two overloads of the <strong class="source-inline">exract()</strong> function:<p class="source-code">node_type extract(const key_type&amp; x);</p><p class="source-code">node_type extract(const_iterator position);</p></li>
			</ul>
			<p>We used the first form, by passing a key. You may also use an iterator, which should not require a lookup.</p>
			<ul>
				<li>Keep in mind that you cannot make a reference from a literal, so a call like <strong class="source-inline">extract(1)</strong> will usually crash with a segmentation fault.</li>
				<li>Keys must remain unique when inserted into a <strong class="source-inline">map</strong>.</li>
			</ul>
			<p>For example, if I try to change a key to a value already in the map:</p>
			<p class="source-code">auto node_x{ racers.extract(racers.begin()) };</p>
			<p class="source-code">node_x.key() = 5;  // 5 is Donkey Kong Jr</p>
			<p class="source-code">auto status = racers.insert(move(node_x));</p>
			<p class="source-code">if(!status.inserted) {</p>
			<p class="source-code">    cout &lt;&lt; format("insert failed, dup key: {}",</p>
			<p class="source-code">        status.position-&gt;second);</p>
			<p class="source-code">    exit(1);</p>
			<p class="source-code">}</p>
			<p>The insert fails and we get our error message:</p>
			<p class="source-code">insert failed, dup key: Donkey Kong Jr</p>
			<p>In this example I've passed the <strong class="source-inline">begin()</strong> iterator to <strong class="source-inline">extract()</strong>. I then assigned the key a value that's already in use (5, <em class="italic">Donkey Kong Jr</em>). The insert failed and the<a id="_idIndexMarker243"/> resulting <strong class="source-inline">status.inserted</strong> is <a id="_idIndexMarker244"/>false. <strong class="source-inline">status.position</strong> is an iterator to the found key. In the <strong class="source-inline">if()</strong> block, I used <strong class="source-inline">format()</strong> to print the value the found key.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Use unordered_map with custom keys</h1>
			<p>With an<a id="_idIndexMarker245"/> ordered <strong class="source-inline">map</strong>, the type of the key must be<a id="_idIndexMarker246"/> sortable, which means it must at least support the less-than <strong class="source-inline">&lt;</strong> comparison operator. Suppose you want to use an associative container with a custom type that is not sortable. For example, a vector where <strong class="source-inline">(0, 1)</strong> is not smaller or larger than <strong class="source-inline">(1, 0)</strong>, it simply points in a different direction. In such cases, you may still use the <strong class="source-inline">unordered_map</strong> type. Let's look at how to do this.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>How to do it…</h2>
			<p>For this recipe we'll create an <strong class="source-inline">unordered_map</strong> object that uses <em class="italic">x</em>/<em class="italic">y</em> coordinates for the key. We will need a few support functions for this.</p>
			<ul>
				<li>First, we'll define a structure for the coordinates:<p class="source-code">struct Coord {</p><p class="source-code">    int x{};</p><p class="source-code">    int y{};</p><p class="source-code">};</p></li>
			</ul>
			<p>This is a simple structure with two members, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, for the coordinates.</p>
			<ul>
				<li>Our map will<a id="_idIndexMarker247"/> use the <strong class="source-inline">Coord</strong> structure for the<a id="_idIndexMarker248"/> key, and an <strong class="source-inline">int</strong> for the value:<p class="source-code">using Coordmap = unordered_map&lt;Coord, int&gt;;</p></li>
			</ul>
			<p>We use a <strong class="source-inline">using</strong> alias to make it convenient to use our map.</p>
			<ul>
				<li>To use the <strong class="source-inline">Coord</strong> struct as a key, we need a couple of overloads. These are required for use with an <strong class="source-inline">unordered_map</strong>. First, we'll define an equality comparison operator:<p class="source-code">bool operator==(const Coord&amp; lhs, const Coord&amp; rhs) {</p><p class="source-code">    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;</p><p class="source-code">}</p></li>
			</ul>
			<p>It's a simple function that compares the <strong class="source-inline">x</strong> members with each other, and the <strong class="source-inline">y</strong> members with each other.</p>
			<ul>
				<li>We also need a <strong class="source-inline">std::hash</strong> class specialization. This makes it possible to retrieve map elements with the key:<p class="source-code">namespace std {</p><p class="source-code">    template&lt;&gt;</p><p class="source-code">    struct hash&lt;Coord&gt; {</p><p class="source-code">        size_t operator()(const Coord&amp; c) const {</p><p class="source-code">            return static_cast&lt;size_t&gt;(c.x)</p><p class="source-code">                 + static_cast&lt;size_t&gt;(c.y);</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">}</p></li>
			</ul>
			<p>This provides a specialization for the default <strong class="source-inline">hash</strong> class used by the <strong class="source-inline">std::unordered_map</strong> class. It must be in the <strong class="source-inline">std</strong> namespace.</p>
			<ul>
				<li>We'll also write <a id="_idIndexMarker249"/>a print function to print <a id="_idIndexMarker250"/>a <strong class="source-inline">Coordmap</strong> object:<p class="source-code">void print_Coordmap(const Coordmap&amp; m) {</p><p class="source-code">    for (const auto&amp; [key, value] : m) {</p><p class="source-code">        cout &lt;&lt; format("{{ ({}, {}): {} }} ",</p><p class="source-code">            key.x, key.y, value);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This uses the C++20 <strong class="source-inline">format()</strong> function to print the <em class="italic">x</em>/<em class="italic">y</em> key and the value. Notice the use of the double braces, <strong class="source-inline">{{</strong> and <strong class="source-inline">}}</strong>, to print single braces.</p>
			<ul>
				<li>Now that we have all our support functions, we can write the <strong class="source-inline">main()</strong> function.<p class="source-code">int main() {</p><p class="source-code">    Coordmap m {</p><p class="source-code">        { {0, 0}, 1 },</p><p class="source-code">        { {0, 1}, 2 },</p><p class="source-code">        { {2, 1}, 3 } </p><p class="source-code">    };</p><p class="source-code">    print_Coordmap(m);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">{ (2, 1): 3 } { (0, 1): 2 } { (0, 0): 1 }</strong></p>
			<p>At this point, we've defined a <strong class="source-inline">Coordmap</strong> object that accepts <strong class="source-inline">Coord</strong> objects for the keys and maps them to arbitrary values.</p>
			<ul>
				<li>We can also access individual members based on the <strong class="source-inline">Coord</strong> keys:<p class="source-code">Coord k{ 0, 1 };</p><p class="source-code">cout &lt;&lt; format("{{ ({}, {}): {} }}\n", k.x, k.y, m.at(k));</p></li>
			</ul>
			<p>Output: </p>
			<p class="source-code"><strong class="bold">{ (0, 1): 2 }</strong></p>
			<p>Here we <a id="_idIndexMarker251"/>define a <strong class="source-inline">Coord</strong> object named <strong class="source-inline">k</strong>, and we <a id="_idIndexMarker252"/>use that with the <strong class="source-inline">at()</strong> function to retrieve a value from the <strong class="source-inline">unordered_map</strong>.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>How it works…</h2>
			<p>The <strong class="source-inline">unordered_map</strong> class relies on a hash class to lookup elements from the key. We normally instantiate an object like this:</p>
			<p class="source-code">std::unordered_map&lt;key_type, value_type&gt; my_map;</p>
			<p>What's not obvious here is that, because we haven't one, it's using a <em class="italic">default hash class</em>. The full template type definition of the <strong class="source-inline">unordered_map</strong> class looks like this:</p>
			<p class="source-code">template&lt;</p>
			<p class="source-code">    class Key,</p>
			<p class="source-code">    class T,</p>
			<p class="source-code">    class Hash = std::hash&lt;Key&gt;,</p>
			<p class="source-code">    class KeyEqual = std::equal_to&lt;Key&gt;,</p>
			<p class="source-code">    class Allocator = std::allocator&lt; std::pair&lt;const Key, </p>
			<p class="source-code">      T&gt; &gt;</p>
			<p class="source-code">&gt; class unordered_map;</p>
			<p>The template provides default values for <strong class="source-inline">Hash</strong>, <strong class="source-inline">KeyEqual</strong>, and <strong class="source-inline">Allocator</strong>, so we don't normally include them in our definitions. In our example, we've provided a specialization for the default <strong class="source-inline">std::hash</strong> class.</p>
			<p>The STL contains specializations of <strong class="source-inline">std::hash</strong> for most of the standard types, like <strong class="source-inline">string</strong>, <strong class="source-inline">int</strong>, and so on. For it to work with our class, it needs a specialization.</p>
			<p>We could have<a id="_idIndexMarker253"/> passed a function to the template parameter, like<a id="_idIndexMarker254"/> this:</p>
			<p class="source-code">std::unordered_map&lt;coord, value_type, my_hash_type&gt; my_map;</p>
			<p>That certainly would work. In my view, the specialization is more general.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Use set to sort and filter user input</h1>
			<p>The <strong class="source-inline">set</strong> container <a id="_idIndexMarker255"/>is an associative container <a id="_idIndexMarker256"/>where each <a id="_idIndexMarker257"/>element<a id="_idIndexMarker258"/> is a <em class="italic">single value</em>, which is used as the key. Elements in a <strong class="source-inline">set</strong> are maintained in sorted order and duplicate keys are not allowed.</p>
			<p>The <strong class="source-inline">set</strong> container is often misunderstood, and it does have fewer and more specific uses than more general containers such as <strong class="source-inline">vector</strong> and <strong class="source-inline">map</strong>. One common use for a <strong class="source-inline">set</strong> is to filter duplicates from a set of values.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>How to do it…</h2>
			<p>In this recipe we will read words from the <em class="italic">standard input</em> and filter out the duplicates.</p>
			<ul>
				<li>We'll start by defining an alias for an <strong class="source-inline">istream</strong> iterator. We'll use this to get input from the command line.<p class="source-code">using input_it = istream_iterator&lt;string&gt;;</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we'll define a <strong class="source-inline">set</strong> for our words:<p class="source-code">int main() {</p><p class="source-code">    set&lt;string&gt; words;</p></li>
			</ul>
			<p>The <strong class="source-inline">set</strong> is defined as a set of <strong class="source-inline">string</strong> elements.</p>
			<ul>
				<li>We define a pair of iterators for use with the <strong class="source-inline">inserter()</strong> function:<p class="source-code">input_it it{ cin };</p><p class="source-code">input_it end{};</p></li>
			</ul>
			<p>The <strong class="source-inline">end</strong> iterator is <a id="_idIndexMarker259"/>initialized<a id="_idIndexMarker260"/> with<a id="_idIndexMarker261"/> its default <a id="_idIndexMarker262"/>constructor. This is known as the <em class="italic">end-of-stream</em> iterator. When our input ends, this iterator will compare equal with the <strong class="source-inline">cin</strong> iterator.</p>
			<ul>
				<li>The <strong class="source-inline">inserter()</strong> function is used to insert elements into the <strong class="source-inline">set</strong> container:<p class="source-code">copy(it, end, inserter(words, words.end()));</p></li>
			</ul>
			<p>We use <strong class="source-inline">std::copy()</strong> to conveniently copy words from the input stream.</p>
			<ul>
				<li>Now we can print out our <strong class="source-inline">set</strong> to see the results:<p class="source-code">for(const string &amp; w : words) {</p><p class="source-code">    cout &lt;&lt; format("{} ", w);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
				<li>We can run the program by piping a bunch of words to its input:<p class="source-code">$ echo "a a a b c this that this foo foo foo" | ./set-words</p><p class="source-code">a b c foo that this</p></li>
			</ul>
			<p>The <strong class="source-inline">set</strong> has eliminated the duplicates and retained a sorted list of the words that were inserted.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>How it works…</h2>
			<p>The <strong class="source-inline">set</strong> container is the heart of this recipe. It only holds unique elements. When you insert a duplicate, that insert will fail. So, you end up with a sorted list of each unique element.</p>
			<p>But that's not the only interesting part of this recipe.</p>
			<p>The <strong class="source-inline">istream_iterator</strong> is an input iterator that reads objects from a stream. We instantiated the input iterator like this:</p>
			<p class="source-code">istream_iterator&lt;string&gt; it{ cin };</p>
			<p>Now we have an input iterator of type <strong class="source-inline">string</strong> from the <strong class="source-inline">cin</strong> stream. Every time we dereference this iterator, it will return one word from the input stream.</p>
			<p>We also instantiated another <strong class="source-inline">istream_iterator</strong>:</p>
			<p class="source-code">istream_iterator&lt;string&gt; end{};</p>
			<p>This calls the default constructor, which gives us a special <em class="italic">end-of-stream </em>iterator. When the input iterator reaches the end of the stream, it will become equal to the <em class="italic">end-of-stream </em>iterator. This is convenient for ending loops, such as the one created by the <strong class="source-inline">copy()</strong> algorithm.</p>
			<p>The <strong class="source-inline">copy()</strong> algorithm takes three iterators, the beginning and end of the range to copy, and a destination iterator:</p>
			<p class="source-code">copy(it, end, inserter(words, words.end()));</p>
			<p>The <strong class="source-inline">inserter()</strong> function<a id="_idIndexMarker263"/> takes a container <a id="_idIndexMarker264"/>and<a id="_idIndexMarker265"/> an<a id="_idIndexMarker266"/> iterator for the insertion point, and returns an <strong class="source-inline">insert_iterator</strong> of the appropriate type for the container and its elements.</p>
			<p>This combination of <strong class="source-inline">copy()</strong> and <strong class="source-inline">inserter()</strong> makes it easy to copy elements from a stream into the <strong class="source-inline">set</strong> container.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>A simple RPN calculator with deque</h1>
			<p>An <strong class="bold">RPN</strong> (<strong class="bold">Reverse Polish Notation</strong>) calculator is a stack-based calculator that uses postfix <a id="_idIndexMarker267"/>notation, where the operator follows<a id="_idIndexMarker268"/> the operands. It's commonly used in printing calculators and, notably, the HP 12C, the most popular electronic calculator of all time.</p>
			<p>After becoming familiar with its operational modality, many people prefer an RPN calculator. (I've been using the HP 12C and 16C since they were first introduced in the early 1980s.) For example, using conventional algebraic notation, to add 1 and 2 you would type <strong class="source-inline">1 + 2</strong>. Using RPN, you would type <strong class="source-inline">1 2 +</strong>. The operator comes <em class="italic">after</em> the operands.</p>
			<p>Using an algebraic calculator, you would need to press an <strong class="source-inline">=</strong> key to indicate that you want a result. With an RPN calculator this is unnecessary because the operator processes immediately, serving a double purpose. On the other hand, an RPN calculator often requires an <em class="italic">Enter</em> keypress to push an operand onto the stack.</p>
			<p>We can easily implement an RPN calculator using a stack-based data structure. For example, consider an RPN calculator with a four-position stack:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B18267_03_05.jpg" alt="Figure 3.5 – RPN addition operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – RPN addition operation</p>
			<p>Each operand is pushed onto the stack as they are entered. When the operator is entered, the operands are popped off, operated upon, and the result is pushed back onto the stack. The result may then be used in the next operation. For example, consider the case of <strong class="source-inline">(3+2)×3</strong>:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B18267_03_06.jpg" alt="Figure 3.6 – RPN stack operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – RPN stack operations</p>
			<p>One advantage of <a id="_idIndexMarker269"/>RPN is that you can leave <a id="_idIndexMarker270"/>operands on the stack for future calculations, reducing the need for separate memory registers. Consider the case of <strong class="source-inline">(9×6)+(2×3)</strong>:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B18267_03_07.jpg" alt="Figure 3.7 – RPN multiple stack operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – RPN multiple stack operations</p>
			<p>Notice that we first perform the operations within the parentheses, then the final operation on the intermediate results. This may seem more complex at first, but it makes a lot of sense once you get used to it.</p>
			<p>Now, let's build a simple RPN calculator using the STL <strong class="source-inline">deque</strong> container.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>How to do it…</h2>
			<p>For this implementation, we'll use a <strong class="source-inline">deque</strong> container for our stack. Why not use a <strong class="source-inline">stack</strong> container? The <strong class="source-inline">stack</strong> class is a container-adapter, which uses another container (usually a <strong class="source-inline">deque</strong>) for its storage. For our purposes, <strong class="source-inline">stack</strong> doesn't provide any tangible advantage over <strong class="source-inline">deque</strong>. And <strong class="source-inline">deque</strong> allows us to iterate over and display the RPN stack, like a paper tape calculator.</p>
			<ul>
				<li>We'll encapsulate our RPN calculator in a class. There are a few advantages to using a<a id="_idIndexMarker271"/> class <a id="_idIndexMarker272"/>here. <em class="italic">Encapsulation</em> provides <em class="italic">safety</em>, <em class="italic">reusability</em>, <em class="italic">extensibility</em>, and a <em class="italic">clean interface</em>. We'll call our class <strong class="source-inline">RPN</strong>:<p class="source-code">class RPN {</p><p class="source-code">    deque&lt;double&gt; deq_{};</p><p class="source-code">    constexpr static double zero_{0.0};</p><p class="source-code">    constexpr static double inf_ </p><p class="source-code">        { std::numeric_limits&lt;double&gt;::infinity() };</p><p class="source-code">...  // public and private members go here</p><p class="source-code">};</p></li>
			</ul>
			<p>The <strong class="source-inline">deque</strong> data store, named <strong class="source-inline">deq_</strong>, is in the private area of the class to protect it. This is where we store the RPN stack.</p>
			<p>The <strong class="source-inline">zero_</strong> constant is used throughout the class, both as a return value and as a comparison operand. The <strong class="source-inline">inf_</strong> constant is used for a divide-by-zero error. These constants are declared <strong class="source-inline">constexpr static</strong> so they don't take up space in every instance.</p>
			<p>I like to name private data members with a trailing underscore to remind me that they're private.</p>
			<ul>
				<li>We don't need an explicit constructor or destructor because the <strong class="source-inline">deque</strong> class manages its own resources. So, our public interface consists of just three functions:<p class="source-code">public:</p><p class="source-code">    // process an operand/operator</p><p class="source-code">    double op(const string &amp; s) {</p><p class="source-code">        if(is_numeric(s)) {</p><p class="source-code">            double v{stod(s, nullptr)};</p><p class="source-code">            deq_.push_front(v);</p><p class="source-code">            return v;</p><p class="source-code">        }</p><p class="source-code">        else return optor(s);</p><p class="source-code">    }</p><p class="source-code">    // empty the stack</p><p class="source-code">    void clear() {</p><p class="source-code">        deq_.clear();</p><p class="source-code">    }</p><p class="source-code">    // print the stack</p><p class="source-code">    string get_stack_string() const {</p><p class="source-code">        string s{};</p><p class="source-code">        for(auto v : deq_) {</p><p class="source-code">            s += format("{} ", v);</p><p class="source-code">        }</p><p class="source-code">        return s;</p><p class="source-code">    }</p></li>
			</ul>
			<p>The <strong class="source-inline">double op()</strong> function is the main entry point for the RPN class. It takes a <strong class="source-inline">string</strong>, with either a number or an operator. If it's a number, it's converted into a <strong class="source-inline">double</strong> and pushed onto the stack. If it's an operator, we call <strong class="source-inline">optor()</strong> to perform the operation. This is the main logic of the class.</p>
			<p>The <strong class="source-inline">void clear()</strong> function simply calls <strong class="source-inline">clear()</strong> on the <strong class="source-inline">deque</strong> to empty the stack.</p>
			<p>And finally, the <strong class="source-inline">string get_stack_string()</strong> function returns the contents of the stack in a <strong class="source-inline">string</strong>.</p>
			<ul>
				<li>In the <strong class="source-inline">private</strong> section, we have the supporting utilities that make the interface<a id="_idIndexMarker273"/> work. The <strong class="source-inline">pop_get2()</strong> function<a id="_idIndexMarker274"/> pops two operands from the stack and returns them as a pair. We use this as operands for the operators:<p class="source-code">    pair&lt;double, double&gt; pop_get2() {</p><p class="source-code">        if(deq_.size() &lt; 2) return {zero_, zero_};</p><p class="source-code">        double v1{deq_.front()};</p><p class="source-code">        deq_.pop_front();</p><p class="source-code">        double v2{deq_.front()};</p><p class="source-code">        deq_.pop_front();</p><p class="source-code">        return {v2, v1};</p><p class="source-code">    }</p></li>
				<li>The <strong class="source-inline">is_numeric()</strong> function checks to see if the string is entirely numeric. We also allow the decimal <strong class="source-inline">.</strong> character.<p class="source-code">    bool is_numeric(const string&amp; s) {</p><p class="source-code">        for(const char c : s) {</p><p class="source-code">            if(c != '.' &amp;&amp; !std::isdigit(c)) return </p><p class="source-code">              false;</p><p class="source-code">        }</p><p class="source-code">        return true;</p><p class="source-code">    }</p></li>
				<li>The <strong class="source-inline">optor()</strong> function performs the operators. We use a <strong class="source-inline">map</strong> container to map an operator to<a id="_idIndexMarker275"/> a corresponding<a id="_idIndexMarker276"/> lambda function.<p class="source-code">double optor(const string&amp; op) {</p><p class="source-code">    map&lt;string, double (*)(double, double)&gt; opmap {</p><p class="source-code">        {"+", [](double l, double r){ return l + r; }},</p><p class="source-code">        {"-", [](double l, double r){ return l - r; }},</p><p class="source-code">        {"*", [](double l, double r){ return l * r; }},</p><p class="source-code">        {"/", [](double l, double r){ return l / r; }},</p><p class="source-code">        {"^", [](double l, double r)</p><p class="source-code">            { return pow(l, r); }},</p><p class="source-code">        {"%", [](double l, double r)</p><p class="source-code">            { return fmod(l, r); }}</p><p class="source-code">    };</p><p class="source-code">    if(opmap.find(op) == m.end()) return zero_;</p><p class="source-code">    auto [l, r] = pop_get2();</p><p class="source-code">    // don’t divide by zero</p><p class="source-code">    if(op == "/" &amp;&amp; r == zero_) deq_.push_front(inf_);</p><p class="source-code">    else deq_.push_front(opmap.at(op)(l, r));</p><p class="source-code">    return deq_.front();</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">map</strong> container with lambda functions makes a quick and easy jump table.</p>
			<p>We use the <strong class="source-inline">find()</strong> function in <strong class="source-inline">map</strong> to test if we have a valid operator.</p>
			<p>After a test for divide-by-zero, the <strong class="source-inline">map</strong> is dereferenced, and the operator is called.</p>
			<p>The result of the operation is pushed onto the stack and returned.</p>
			<ul>
				<li>Those are all the <a id="_idIndexMarker277"/>function members <a id="_idIndexMarker278"/>of the <strong class="source-inline">RPN</strong> class. Now we can use it in our <strong class="source-inline">main()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    RPN rpn;</p><p class="source-code">    for(string o{}; cin &gt;&gt; o; ) {</p><p class="source-code">        rpn.op(o);</p><p class="source-code">        auto stack_str{rpn.get_stack_string()};</p><p class="source-code">        cout &lt;&lt; format("{}: {}\n", o, stack_str);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>We'll test this is by piping a string into the program from the command line. We use a <strong class="source-inline">for</strong> loop to fetch each word from the <strong class="source-inline">cin</strong> stream and pass it to <strong class="source-inline">rpn.op()</strong>. I like the <strong class="source-inline">for</strong> loop here, as it's easy to contain the scope of the <strong class="source-inline">o</strong> variable. We then print the stack using the <strong class="source-inline">get_stack_string()</strong> function after each command line item.</p>
			<ul>
				<li>We can run the program by piping in an expression like this:<p class="source-code">$ echo "9 6 * 2 3 * +" | ./rpn</p><p class="source-code">9: 9</p><p class="source-code">6: 6 9</p><p class="source-code">*: 54</p><p class="source-code">2: 2 54</p><p class="source-code">3: 3 2 54</p><p class="source-code">*: 6 54</p><p class="source-code">+: 60</p></li>
			</ul>
			<p>This looks like a lot of coding but it's actually quite simple. With the comments, the <strong class="source-inline">RPN</strong> class is less than 70 lines of code. The full <strong class="source-inline">rpn.cpp</strong> source code is in the GitHub repository.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>How it works…</h2>
			<p>The <strong class="source-inline">RPN</strong> class operates by first determining the nature of each chunk of input. If it's a number, we push it onto the stack. If it's an operator, we pop two operands off the top of the stack, apply the operation, and push the result back on the stack. If we don't recognize the input, we just ignore it.</p>
			<p>The <strong class="source-inline">deque</strong> class is a double-ended queue. To use it as a stack, we pick an end and both push and pop from<a id="_idIndexMarker279"/> that same end. I chose <a id="_idIndexMarker280"/>the <strong class="source-inline">front</strong> end of the deque, but it would work just as well from the <strong class="source-inline">back</strong>. We just need to do everything from the same end.</p>
			<p>If we determine that an input is numeric, we convert it to a <strong class="source-inline">double</strong> and push it onto the front of the <strong class="source-inline">deque</strong> using <strong class="source-inline">push_front()</strong>.</p>
			<p class="source-code">    if(is_numeric(s)) {</p>
			<p class="source-code">        double v{stod(s, nullptr)};</p>
			<p class="source-code">        deq_.push_front(v);</p>
			<p class="source-code">        return v;</p>
			<p class="source-code">    }</p>
			<p>When we need to use values from the stack, we pop them off the front of the deque. We use <strong class="source-inline">front()</strong> to get the value, and then <strong class="source-inline">pop_front()</strong> to pop it off the stack.</p>
			<p class="source-code">    pair&lt;double, double&gt; pop_get2() {</p>
			<p class="source-code">        if(deq_.size() &lt; 2) return {zero_, zero_};</p>
			<p class="source-code">        double v1{deq_.front()};</p>
			<p class="source-code">        deq_.pop_front();</p>
			<p class="source-code">        double v2{deq_.front()};</p>
			<p class="source-code">        deq_.pop_front();</p>
			<p class="source-code">        return {v2, v1};</p>
			<p class="source-code">    }</p>
			<p>Using a map for our operators makes it easy to both check if an operator is valid, and to execute the operation.</p>
			<p class="source-code">    map&lt;string, double (*)(double, double)&gt; opmap {</p>
			<p class="source-code">        {"+", [](double l, double r){ return l + r; }},</p>
			<p class="source-code">        {"-", [](double l, double r){ return l - r; }},</p>
			<p class="source-code">        {"*", [](double l, double r){ return l * r; }},</p>
			<p class="source-code">        {"/", [](double l, double r){ return l / r; }},</p>
			<p class="source-code">        {"^", [](double l, double r){ return pow(l, r); }},</p>
			<p class="source-code">        {"%", [](double l, double r){ return fmod(l, r); }}</p>
			<p class="source-code">    };</p>
			<p>We can test for the <a id="_idIndexMarker281"/>validity of an operator by <a id="_idIndexMarker282"/>using the <strong class="source-inline">find()</strong> function:</p>
			<p class="source-code">    if(opmap.find(op) == opmap.end()) return zero_;</p>
			<p>And we can call the operator by dereferencing the <strong class="source-inline">map</strong> with the <strong class="source-inline">at()</strong> function:</p>
			<p class="source-code">    opmap.at(op)(l, r)</p>
			<p>We both call the operator lambda and push the result onto the <strong class="source-inline">deque</strong> in one statement:</p>
			<p class="source-code">    deq_.push_front(opmap.at(op)(l, r));</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>There's more…</h2>
			<p>In this recipe, we use the <strong class="source-inline">cin</strong> stream to feed operations to the RPN calculator. It would be just as easy to do this with an STL container.</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    RPN rpn;</p>
			<p class="source-code">    vector&lt;string&gt; opv{ "9", "6", "*", "2", "3", "*", "+" </p>
			<p class="source-code">      };</p>
			<p class="source-code">    for(auto o : opv) {</p>
			<p class="source-code">        rpn.op(o);</p>
			<p class="source-code">        auto stack_str{rpn.get_stack_string()};</p>
			<p class="source-code">        cout &lt;&lt; format("{}: {}\n", o, stack_str);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">9: 9</p>
			<p class="source-code">6: 6 9</p>
			<p class="source-code">*: 54</p>
			<p class="source-code">2: 2 54</p>
			<p class="source-code">3: 3 2 54</p>
			<p class="source-code">*: 6 54</p>
			<p class="source-code">+: 60</p>
			<p>By putting the RPN calculator in a class with a clean interface, we've created a flexible tool that can be used in many different contexts.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>A word frequency counter with map</h1>
			<p>This recipe uses <a id="_idIndexMarker283"/>the unique key property of the <strong class="source-inline">map</strong> container <a id="_idIndexMarker284"/>to count duplicate words from a stream of text.</p>
			<p>The STL <strong class="source-inline">map</strong> container is an <em class="italic">associative</em> container. It consists of elements organized in <em class="italic">key-value pairs</em>. The keys are used for lookup and must be unique.</p>
			<p>In this recipe, we will leverage the unique key requirement of the STL <strong class="source-inline">map</strong> container to count the number of occurrences of each word in a text file.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>How to do it…</h2>
			<p>There are a few parts to this task that we can solve separately:</p>
			<ol>
				<li>We need to get the text from a file. We'll use the <strong class="source-inline">cin</strong> stream for this.</li>
				<li>We need to separate words from punctuation and other non-word content. We'll use the <strong class="source-inline">regex</strong> (Regular Expression) library for this.</li>
				<li>We need to count the frequency of each word. This is the main objective of the recipe. We'll use the STL <strong class="source-inline">map</strong> container for this.</li>
				<li>Finally, we need to sort the results, first by frequency and then alphabetically by word within frequency. For this we'll use a the STL <strong class="source-inline">sort</strong> algorithm with a <strong class="source-inline">vector</strong> container.</li>
			</ol>
			<p>Even with all those tasks, the resulting code is relatively short, just about 70 lines with headers and all. Let's dive in:</p>
			<ul>
				<li>We'll start with some aliases for convenience:<p class="source-code">namespace ranges = std::ranges;</p><p class="source-code">namespace regex_constants = std::regex_constants;</p></li>
			</ul>
			<p>For namespaces within the <strong class="source-inline">std::</strong> space, I like to make aliases that are shorter, but still let me know that I'm using a token in a particular namespace. Especially with the <strong class="source-inline">ranges</strong> namespace, which often re-uses the names of existing algorithms.</p>
			<ul>
				<li>We store the regular expression in a constant. I don't like to clutter up the global namespace because that can lead to collisions. I tend to use a namespace based on my initials for things like this:<p class="source-code">namespace bw {</p><p class="source-code">    constexpr const char * re{"(\\w+)"};</p><p class="source-code">}</p></li>
			</ul>
			<p>It's easy enough to get it later using <strong class="source-inline">bw::re</strong>, and that tells me exactly what it is.</p>
			<ul>
				<li>At the top of <strong class="source-inline">main()</strong>, we define our data structures:<p class="source-code">int main() {</p><p class="source-code">    map&lt;string, int&gt; <strong class="bold">wordmap</strong>{};    </p><p class="source-code">    vector&lt;pair&lt;string, int&gt;&gt; <strong class="bold">wordvec</strong>{};</p><p class="source-code">    regex <strong class="bold">word_re</strong>(bw::re);</p><p class="source-code">    size_t total_words{};</p></li>
			</ul>
			<p>Our<a id="_idIndexMarker285"/> main <strong class="source-inline">map</strong> is called <strong class="source-inline">wordmap</strong>. We <a id="_idIndexMarker286"/>have a <strong class="source-inline">vector</strong> named <strong class="source-inline">wordvec</strong> that we'll use as a sorting container. And finally, our <strong class="source-inline">regex</strong> class, <strong class="source-inline">word_re</strong>.</p>
			<ul>
				<li>The <strong class="source-inline">for</strong> loop is where most of the work happens. We read text from the <strong class="source-inline">cin</strong> stream, apply the <strong class="source-inline">regex</strong>, and store words in the <strong class="source-inline">map</strong>:<p class="source-code">for(string s{}; cin &gt;&gt; s; ) {</p><p class="source-code">    auto <strong class="bold">words_begin</strong>{</p><p class="source-code">        sregex_iterator(s.begin(), s.end(), word_re) };</p><p class="source-code">    auto <strong class="bold">words_end</strong>{ sregex_iterator() };</p><p class="source-code">    for(auto <strong class="bold">r_it</strong>{words_begin}; <strong class="bold">r_it</strong> != words_end; </p><p class="source-code">      <strong class="bold">++r_it</strong>) {</p><p class="source-code">        <strong class="bold">smatch</strong> match{ *r_it };</p><p class="source-code">        auto <strong class="bold">word_str</strong>{match.str()};</p><p class="source-code">        <strong class="bold">ranges::transform</strong>(word_str, word_str.begin(),</p><p class="source-code">            [](unsigned char c){ return <strong class="bold">tolower</strong>(c); });</p><p class="source-code">        auto [map_it, result] =</p><p class="source-code">            <strong class="bold">wordmap.try_emplace</strong>(word_str, 0);</p><p class="source-code">        auto &amp; [w, count] = *map_it;</p><p class="source-code">        ++total_words;</p><p class="source-code">        <strong class="bold">++count</strong>;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>I like a <strong class="source-inline">for</strong> loop for<a id="_idIndexMarker287"/> this because it allows me to <a id="_idIndexMarker288"/>contain the scope of the <strong class="source-inline">s</strong> variable.</p>
			<p>We start by defining iterators for the <strong class="source-inline">regex</strong> results. This allows us to distinguish multiple words even when surrounded only by punctuation. The <strong class="source-inline">for(r_it...)</strong> loop returns individual words from the <strong class="source-inline">cin</strong> string.</p>
			<p>The <strong class="source-inline">smatch</strong> type is a specialization of a <strong class="source-inline">regex</strong> string match class. It gives us the next word from our <strong class="source-inline">regex</strong>.</p>
			<p>We then use the <strong class="source-inline">transform</strong> algorithm to make the words lowercase – so we can count words regardless of case. (For example, "The" is the same word as "the".)</p>
			<p>Next, we use <strong class="source-inline">try_emplace()</strong> to add the word to the map. If it's already there, it will not be replaced.</p>
			<p>Finally, we increment the count for the word in the <strong class="source-inline">map</strong> with <strong class="source-inline">++count</strong>.</p>
			<ul>
				<li>Now we have the words and their frequency counts in our <strong class="source-inline">map</strong>. But they're in alphabetical order and we want them in descending order of frequency. For this, we put them in a vector and sort them:<p class="source-code">    auto unique_words = wordmap.size();</p><p class="source-code">    wordvec.reserve(unique_words);</p><p class="source-code">    ranges::move(wordmap, back_inserter(wordvec));</p><p class="source-code">    ranges::sort(wordvec, [](const auto&amp; a, const </p><p class="source-code">      auto&amp; b) { </p><p class="source-code">        if(a.second != b.second)</p><p class="source-code">            return (a.second &gt; b.second);</p><p class="source-code">        return (a.first &lt; b.first);</p><p class="source-code">    });</p><p class="source-code">    cout &lt;&lt; format("unique word count: {}\n", </p><p class="source-code">      total_words);</p><p class="source-code">    cout &lt;&lt; format("unique word count: {}\n", </p><p class="source-code">      unique_words);</p></li>
			</ul>
			<p><strong class="source-inline">wordvec</strong> is a <a id="_idIndexMarker289"/>vector of pairs, with the word<a id="_idIndexMarker290"/> and the frequency count. We use the <strong class="source-inline">ranges::move()</strong> algorithm to populate the <strong class="source-inline">vector</strong>, then the <strong class="source-inline">ranges::sort()</strong> algorithm to sort the <strong class="source-inline">vector</strong>. Notice that the <em class="italic">predicate lambda function</em> sorts first by the count (descending) and then by the word (ascending).</p>
			<ul>
				<li>Finally, we print the results:<p class="source-code">    for(int limit{20}; auto&amp; [w, count] : wordvec) {</p><p class="source-code">        cout &lt;&lt; format("{}: {}\n", count, w);</p><p class="source-code">        if(--limit == 0) break;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>I set a limit to print only the first 20 entries. You can comment out the <strong class="source-inline">if(--limit == 0) break;</strong> line to print the whole list.</p>
			<ul>
				<li>In the example files, I've included a text file with a copy of <em class="italic">The Raven</em>, by Edgar Allen Poe. The<a id="_idIndexMarker291"/> poem is in the public domain. We <a id="_idIndexMarker292"/>can use this to test the program:<p class="source-code"><strong class="bold">$ ./word-count &lt; the-raven.txt</strong></p><p class="source-code"><strong class="bold">total word count: 1098</strong></p><p class="source-code"><strong class="bold">unique word count: 439</strong></p><p class="source-code"><strong class="bold">56: the</strong></p><p class="source-code"><strong class="bold">38: and</strong></p><p class="source-code"><strong class="bold">32: i</strong></p><p class="source-code"><strong class="bold">24: my</strong></p><p class="source-code"><strong class="bold">21: of</strong></p><p class="source-code"><strong class="bold">17: that</strong></p><p class="source-code"><strong class="bold">17: this</strong></p><p class="source-code"><strong class="bold">15: a</strong></p><p class="source-code"><strong class="bold">14: door</strong></p><p class="source-code"><strong class="bold">11: chamber</strong></p><p class="source-code"><strong class="bold">11: is</strong></p><p class="source-code"><strong class="bold">11: nevermore</strong></p><p class="source-code"><strong class="bold">10: bird</strong></p><p class="source-code"><strong class="bold">10: on</strong></p><p class="source-code"><strong class="bold">10: raven</strong></p><p class="source-code"><strong class="bold">9: me</strong></p><p class="source-code"><strong class="bold">8: at</strong></p><p class="source-code"><strong class="bold">8: from</strong></p><p class="source-code"><strong class="bold">8: in</strong></p><p class="source-code"><strong class="bold">8: lenore</strong></p></li>
			</ul>
			<p>The poem has 1,098 words total, and 439 of them are unique.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>How it works…</h2>
			<p>The core of the recipe is the use of a <strong class="source-inline">map</strong> object to count duplicate words. But there are other parts that merit consideration.</p>
			<p>We use the <strong class="source-inline">cin</strong> stream to read text from the <em class="italic">standard input</em>. By default, <strong class="source-inline">cin</strong> will skip <em class="italic">whitespace</em> when reading into a <strong class="source-inline">string</strong> object. By putting a string object on the right-hand side of the <strong class="source-inline">&gt;&gt;</strong> operator (<strong class="source-inline">cin &gt;&gt; s</strong>) we get chunks of text separated by whitespace. This is a good enough definition of a word-at-a-time for many purposes, but we need linguistic <a id="_idIndexMarker293"/>words. And for that we will use a regular <a id="_idIndexMarker294"/>expression.</p>
			<p>The <strong class="source-inline">regex</strong> class provides a choice of regular expression <em class="italic">grammars</em> and it defaults to <em class="italic">ECMA</em> grammar. In the ECMA grammar, the regular expression <strong class="source-inline">"(\w+)"</strong> is a shortcut for <strong class="source-inline">"([A-Za-z0-9_]+)"</strong>. This will select words that include these characters.</p>
			<p>Regular expressions are a language unto themselves. To learn more about regular expressions, I recommend the book <em class="italic">Mastering Regular Expressions</em> by Jeffrey Friedl.</p>
			<p>As we get each word from the <strong class="source-inline">regex</strong> engine, we use the map object's <strong class="source-inline">try_emplace()</strong> method to conditionally add the word to our <strong class="source-inline">wordmap</strong>. If the word is not in the map, we add it with a count of <strong class="source-inline">0</strong>. If the word is already in the map, the count is untouched. We increment the count later in the loop, so it's always correct.</p>
			<p>After the map is populated with all the unique words from the file, we transfer it to a vector using the <strong class="source-inline">ranges::move()</strong> algorithm. The <strong class="source-inline">move()</strong> algorithm makes this transfer quick <a id="_idIndexMarker295"/>and efficient. Then we can sort it in the vector <a id="_idIndexMarker296"/>using <strong class="source-inline">ranges::sort()</strong>. The <em class="italic">predicate lambda function</em> for sorting includes comparisons for both sides of the pair, so we end up with a result that's sorted by both word count (descending) and the word.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Find long sentences with a vector of vectors</h1>
			<p>It can be useful for<a id="_idIndexMarker297"/> a writer to make sure they are using variety of sentence lengths, or to ensure none of their sentences are too long. Let's build a tool that evaluates a text file for sentence length.</p>
			<p>Choosing the appropriate container is key when using the STL. If you need something ordered, it's often best to use an associative container, such as <strong class="source-inline">map</strong> or <strong class="source-inline">multimap</strong>. In this case, however, since we need a custom sort, it's easier to sort a <strong class="source-inline">vector</strong>.</p>
			<p>The <strong class="source-inline">vector</strong> is generally the most flexible of the STL containers. Whenever another container type seems appropriate, but is missing one important capability, the <strong class="source-inline">vector</strong> is often an effective solution. In this case, where we need a custom sort, the vector works great.</p>
			<p>This recipe uses a <em class="italic">vector of vectors</em>. The inner <strong class="source-inline">vector</strong> stores the words of a sentence, and the outer <strong class="source-inline">vector</strong> stores the inner <strong class="source-inline">vector</strong>s. As you'll see, this affords a lot of flexibility while retaining all the relevant data.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>How to do it…</h2>
			<p>This program needs to read in words, find the ends of sentences, store and sort the sentences, then print out the results.</p>
			<ul>
				<li>We'll start by writing a little function to tell us when we've hit the end of a sentence:<p class="source-code">bool is_eos(const string_view &amp; str) {</p><p class="source-code">    constexpr const char * <strong class="bold">end_punct</strong>{ ".!?" };</p><p class="source-code">    for(auto c : str) {</p><p class="source-code">        if(<strong class="bold">strchr</strong>(end_punct, c) != nullptr) return </p><p class="source-code">          true;</p><p class="source-code">    }</p><p class="source-code">    return false;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">is_eos()</strong> function uses <strong class="source-inline">string_view</strong> because it's efficient and we don't need anything more. Then we use the <strong class="source-inline">strchr()</strong> library function to check if a word<a id="_idIndexMarker298"/> contains one of the end-of-sentence punctuation characters (<strong class="source-inline">".!?"</strong>). These are the three possible characters to end a sentence in the English language.</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we start by defining the <em class="italic">vector of vectors</em>:<p class="source-code">vector&lt;vector&lt;string&gt;&gt; vv_sentences{vector&lt;string&gt;{}};</p></li>
			</ul>
			<p>This defines a <strong class="source-inline">vector</strong> of elements typed <strong class="source-inline">vector&lt;string&gt;</strong> named <strong class="source-inline">vv_sentences</strong>. The <strong class="source-inline">vv_sentences</strong> object is initialized with one empty vector for the first sentence.</p>
			<p>This creates a vector that contains other vectors. The inner vectors will each hold a sentence of words.</p>
			<ul>
				<li>Now we can process the stream of words:<p class="source-code">for(string s{}; cin &gt;&gt; s; ) {</p><p class="source-code">    vv_sentences.<strong class="bold">back()</strong>.emplace_back(s);</p><p class="source-code">    if(<strong class="bold">is_eos(s)</strong>) {</p><p class="source-code">      vv_sentences.<strong class="bold">emplace_back(vector&lt;string&gt;{})</strong>;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">for</strong> loop returns one word at a time from the input stream. The <strong class="source-inline">back()</strong> method on the <strong class="source-inline">vv_sentences</strong> object is used to access the current vector of words, and the current word is added using <strong class="source-inline">emplace_back()</strong>. Then we call <strong class="source-inline">is_eos()</strong> to see if this was the end of a sentence. If so, we add a new empty vector to <strong class="source-inline">vv_sentences</strong> to start the next sentence.</p>
			<ul>
				<li>Because we always add a new empty vector to the end of <strong class="source-inline">vv_sentences</strong> after each end-of-sentence character, we will usually end up with an empty sentence vector at the end. Here we check for this, and delete it if necessary:<p class="source-code">    // delete back if empty</p><p class="source-code">    if(vv_sentences.back().empty()) </p><p class="source-code">        vv_sentences.pop_back();</p></li>
				<li>Now we can <a id="_idIndexMarker299"/>sort the <strong class="source-inline">vv_sentences</strong> vector by the size of the sentences:<p class="source-code">    sort(vv_sentences, [](const auto&amp; l, </p><p class="source-code">        const auto&amp; r) {</p><p class="source-code">            <strong class="bold">return l.size() &gt; r.size();</strong></p><p class="source-code">        });</p></li>
			</ul>
			<p>This is why the <strong class="source-inline">vector</strong> is so convenient for this project. It's quick and easy to sort using the <strong class="source-inline">ranges::sort()</strong> algorithm with a simple <em class="italic">predicate</em> for sorting by size in descending order.</p>
			<ul>
				<li>Now we can print our result: <p class="source-code">    constexpr int WLIMIT{10};</p><p class="source-code">    <strong class="bold">for(auto&amp; v : vv_sentences)</strong> {</p><p class="source-code">        size_t size = v.size();</p><p class="source-code">        size_t limit{WLIMIT};</p><p class="source-code">        cout &lt;&lt; <strong class="bold">format("{}: ", size)</strong>;</p><p class="source-code">        <strong class="bold">for(auto&amp; s : v)</strong> {</p><p class="source-code">            cout &lt;&lt; <strong class="bold">format("{} ", s)</strong>;</p><p class="source-code">            if(--limit == 0) {</p><p class="source-code">                <strong class="bold">if(size &gt; WLIMIT) cout &lt;&lt; "...";</strong></p><p class="source-code">                break;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        cout &lt;&lt; '\n';</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>The outer loop and the inner loop correspond to the outer and inner vectors. We simply loop <a id="_idIndexMarker300"/>through the vectors and print out the size of the inner vector with <strong class="source-inline">format("{}: ", size)</strong> and then each word with <strong class="source-inline">format("{} ", s)</strong>. We don't want to print the very long sentences in their entirety, so we define a limit of 10 words and print an ellipsis if there's more.</p>
			<ul>
				<li>The output looks like this, using the first few paragraphs of this recipe for input:<p class="source-code"><strong class="bold">$ ./sentences &lt; sentences.txt</strong></p><p class="source-code"><strong class="bold">27: It can be useful for a writer to make sure ...</strong></p><p class="source-code"><strong class="bold">19: Whenever another container type seems appropriate, but is missing one ...</strong></p><p class="source-code"><strong class="bold">18: If you need something ordered, it's often best to use ...</strong></p><p class="source-code"><strong class="bold">17: The inner vector stores the words of a sentence, and ...</strong></p><p class="source-code"><strong class="bold">16: In this case, however, since we need a descending sort, ...</strong></p><p class="source-code"><strong class="bold">16: In this case, where we need our output sorted in ...</strong></p><p class="source-code"><strong class="bold">15: As you'll see, this affords a lot of flexibility while ...</strong></p><p class="source-code"><strong class="bold">12: Let's build a tool that evaluates a text file for ...</strong></p><p class="source-code"><strong class="bold">11: The vector is generally the most flexible of the STL ...</strong></p><p class="source-code"><strong class="bold">9: Choosing the appropriate container key when using the STL.</strong></p><p class="source-code"><strong class="bold">7: This recipe uses a vector of vectors.</strong></p></li>
			</ul>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>How it works…</h2>
			<p>Finding punctuation is simple using the <strong class="source-inline">strchr()</strong> function from the C Standard Library. Remember, all<a id="_idIndexMarker301"/> of C and its Standard Library are included in the definition of the C++ language. There's no reason not to use it where appropriate.</p>
			<p class="source-code">bool is_eos(const string_view &amp; str) {</p>
			<p class="source-code">    constexpr const char * end_punct{ ".!?" };</p>
			<p class="source-code">    for(auto c : str) {</p>
			<p class="source-code">        if(<strong class="bold">strchr(end_punct, c) != nullptr</strong>) return true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">}</p>
			<p>This function will fail to properly separate sentences if there's punctuation in the middle of words. That may happen in some forms of poetry or in a badly formatted text file. I've seen this done with <strong class="source-inline">std::string</strong> iterators, and with regular expressions, but for our purposes this is quick and easy.</p>
			<p>We read the text file one word at a time using <strong class="source-inline">cin</strong>:</p>
			<p class="source-code">for(string s{}; <strong class="bold">cin &gt;&gt; s</strong>; ) {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>This avoids the overhead of reading a large file into memory all at once. The <strong class="source-inline">vector</strong> will already be large, containing all the words of the file. It's not necessary to also hold the entire text file in memory. In the rare case that a file is too large, it would be necessary to find another strategy, or use a database.</p>
			<p>The <em class="italic">vector of vectors</em> may look complex at first glance, but it's no more complicated than using two separate vectors.</p>
			<p class="source-code"><strong class="bold">vector&lt;vector&lt;string&gt;&gt;</strong> vv_sentences{<strong class="bold">vector&lt;string&gt;{}</strong>};</p>
			<p>This declares an <em class="italic">outer</em> <strong class="source-inline">vector</strong>, with <em class="italic">inner</em> elements of type <strong class="source-inline">vector&lt;string&gt;</strong>. The <em class="italic">outer</em> vector is named <strong class="source-inline">vv_sentences</strong>. The <em class="italic">inner</em> vectors are anonymous; they require no<a id="_idIndexMarker302"/> name. This definition initializes the <strong class="source-inline">vv_sentences</strong> object with one element, an empty <strong class="source-inline">vector&lt;string&gt;</strong> object.</p>
			<p>The <em class="italic">current</em> inner vector will always be available as <strong class="source-inline">vv_senteces.back()</strong>:</p>
			<p class="source-code"><strong class="bold">vv_sentences.back()</strong>.emplace_back(s);</p>
			<p>When we've completed one inner vector, we simply create a new one with:</p>
			<p class="source-code">vv_sentences.emplace_back(vector&lt;string&gt;{});</p>
			<p>This creates a new anonymous <strong class="source-inline">vector&lt;string&gt;</strong> object and <em class="italic">emplaces</em> it at the back of the <strong class="source-inline">vv_sentences</strong> object.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>A ToDo list using multimap</h1>
			<p>An ordered <a id="_idIndexMarker303"/>task list (or a <em class="italic">ToDo list</em>) is a common computing <a id="_idIndexMarker304"/>application. Formally stated, it's a list of tasks associated with a priority, sorted in reverse numerical order.</p>
			<p>You may be tempted to use a <strong class="source-inline">priority_queue</strong> for this, because as the name implies, it's already sorted in priority (reverse numerical) order. The disadvantage of a <strong class="source-inline">priority_queue</strong> is that it has no iterators, so it's difficult to operate on it without pushing and popping items to and from the queue.</p>
			<p>For this recipe, we'll use a <strong class="source-inline">multimap</strong> for the ordered list. The <strong class="source-inline">multimap</strong> <em class="italic">associative container</em> keeps items in order, and it can be accessed using <em class="italic">reverse iterators</em> for the proper sort order.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>How to do it…</h2>
			<p>This is a short and simple recipe that initializes a <strong class="source-inline">multimap</strong> and prints it in reverse order.</p>
			<ul>
				<li>We start with a type alias for our <strong class="source-inline">multimap</strong>:<p class="source-code">using todomap = multimap&lt;int, string&gt;;</p></li>
			</ul>
			<p>Our <strong class="source-inline">todomap</strong> is a <strong class="source-inline">multimap</strong> with an <strong class="source-inline">int</strong> key and a <strong class="source-inline">string</strong> payload.</p>
			<ul>
				<li>We have<a id="_idIndexMarker305"/> a<a id="_idIndexMarker306"/> small utility function for printing the <strong class="source-inline">todomap</strong> in reverse order:<p class="source-code">void rprint(todomap&amp; todo) {</p><p class="source-code">    for(auto it = todo.rbegin(); it != todo.rend(); </p><p class="source-code">      ++it) {</p><p class="source-code">        cout &lt;&lt; format("{}: {}\n", it-&gt;first, </p><p class="source-code">          it-&gt;second);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This uses reverse iterators to print the <strong class="source-inline">todomap</strong>.</p>
			<ul>
				<li>The <strong class="source-inline">main()</strong> function is short and sweet:<p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    todomap todo {</p><p class="source-code">        {1, "wash dishes"},</p><p class="source-code">        {0, "watch teevee"},</p><p class="source-code">        {2, "do homework"},</p><p class="source-code">        {0, "read comics"}</p><p class="source-code">    };</p><p class="source-code">    <strong class="bold">rprint</strong>(todo);</p><p class="source-code">}</p></li>
			</ul>
			<p>We initialize the <strong class="source-inline">todomap</strong> with tasks. Notice that the tasks are not in any particular order, but they do have priorities in the keys. The <strong class="source-inline">rprint()</strong> function<a id="_idIndexMarker307"/> will<a id="_idIndexMarker308"/> print them in priority order.</p>
			<ul>
				<li>The output looks like this:<p class="source-code"><strong class="bold">$ ./todo</strong></p><p class="source-code"><strong class="bold">2: do homework</strong></p><p class="source-code"><strong class="bold">1: wash dishes</strong></p><p class="source-code"><strong class="bold">0: read comics</strong></p><p class="source-code"><strong class="bold">0: watch teevee</strong></p></li>
			</ul>
			<p>The ToDo list prints out in priority order, just as we need it.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>How it works…</h2>
			<p>It's a short and simple recipe. It uses the <strong class="source-inline">multimap</strong> container to hold items for a prioritized list.</p>
			<p>The only trick is in the <strong class="source-inline">rprint()</strong> function:</p>
			<p class="source-code">void rprint(todomap&amp; todo) {</p>
			<p class="source-code">    for(auto it = todo.<strong class="bold">rbegin()</strong>; it != todo.<strong class="bold">rend()</strong>; ++it) {</p>
			<p class="source-code">        cout &lt;&lt; format("{}: {}\n", it-&gt;first, it-&gt;second);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    cout &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>Notice the<a id="_idIndexMarker309"/> reverse<a id="_idIndexMarker310"/> iterators, <strong class="source-inline">rbegin()</strong> and <strong class="source-inline">rend()</strong>. It's not possible to change the sort order of a <strong class="source-inline">multimap</strong>, but it does provide reverse iterators. This makes the <strong class="source-inline">multimap</strong> behave exactly as we need it for our prioritized list.</p>
		</div>
	</body></html>