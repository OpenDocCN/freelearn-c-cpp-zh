["```cpp\n//stacklinkedlist.c\n\n#include<stdio.h>\n\n#include <stdlib.h>\n\nstruct node {\n  int data;\n  struct node * next;\n};\n\nvoid push(struct node * NewNode, struct node ** Top);\nstruct node * pop(struct node ** Top);\n\nint main() {\n  struct node * newNode, * top, * recNode;\n  int n = 0;\n  top = NULL;\n  while (n != 3) {\n    printf(\"\\n1\\. Pushing an element into the stack\\n\");\n    printf(\"2\\. Popping out an element from the stack\\n\");\n    printf(\"3\\. Quit\\n\");\n    printf(\"Enter your choice 1/2/3:\");\n    scanf(\"%d\", & n);\n    switch (n) {\n    case 1:\n      newNode = (struct node * ) malloc(sizeof(struct node));\n      printf(\"Enter the value to push: \");\n      scanf(\"%d\", & newNode - > data);\n      push(newNode, & top);\n      printf(\"Value %d is pushed to stack\\n\", newNode - > data);\n      break;\n    case 2:\n      recNode = pop( & top);\n      if (recNode == NULL) printf(\"Stack is empty\\n\");\n      else\n        printf(\"The value popped is %d\\n\", recNode - > data);\n      break;\n    }\n  }\n  return 0;\n}\nvoid push(struct node * NewNode, struct node ** Top) {\n  NewNode - > next = * Top;\n  * Top = NewNode;\n}\n\nstruct node * pop(struct node ** Top) {\n  struct node * temp;\n  if ( * Top == NULL) return (NULL);\n  else {\n    temp = * Top;\n    ( * Top) = ( * Top) - > next;\n    return (temp);\n  }\n}\n```", "```cpp\n//doublylinkedlist.c\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\nstruct node {\n  int data;\n  struct node * next, * prev;\n};\n\nstruct node * startList, * endList;\nvoid createdoubly();\nvoid list_lifo();\nvoid list_fifo();\n\nint main() {\n  int n = 0;\n  while (n != 4) {\n    printf(\"\\n1\\. Creating a doubly linked list\\n\");\n    printf(\"2\\. Displaying elements in L.I.F.O. order\\n\");\n    printf(\"3\\. Displaying elements in F.I.F.O. order\\n\");\n    printf(\"4\\. Quit\\n\");\n    printf(\"Enter your choice 1/2/3/4: \");\n    scanf(\"%d\", & n);\n    switch (n) {\n    case 1:\n      createdoubly();\n      break;\n    case 2:\n      list_lifo();\n      break;\n    case 3:\n      list_fifo();\n      break;\n    }\n  }\n  return 0;\n}\n\nvoid createdoubly() {\n  char k[10];\n  struct node * newNode;\n  startList = NULL;\n  strcpy(k, \"yes\");\n  while (strcmp(k, \"yes\") == 0 || strcmp(k, \"Yes\") == 0) {\n    if (startList == NULL) {\n      newNode = (struct node * ) malloc(sizeof(struct node));\n      printf(\"Enter the value to add: \");\n      scanf(\"%d\", & newNode - > data);\n      newNode - > next = NULL;\n      newNode - > prev = NULL;\n      startList = newNode;\n      endList = startList;\n    } else {\n      newNode = (struct node * ) malloc(sizeof(struct node));\n      printf(\"Enter the value to add: \");\n      scanf(\"%d\", & newNode - > data);\n      newNode - > next = NULL;\n      newNode - > prev = endList;\n      endList - > next = newNode;\n      endList = newNode;\n    }\n    printf(\"Want to add more yes/no? \");\n    scanf(\"%s\", k);\n  }\n  printf(\"Doubly linked list is created\\n\");\n}\nvoid list_lifo() {\n  struct node * temp;\n  temp = endList;\n  if (temp != NULL) {\n    printf(\"The elements of the doubly linked list in L.I.F.O. order :\\n\");\n    while (temp != NULL) {\n      printf(\"%d\\n\", temp - > data);\n      temp = temp - > prev;\n    }\n  } else\n    printf(\"The doubly linked list is empty\\n\");\n}\n\nvoid list_fifo() {\n  struct node * temp;\n  temp = startList;\n  printf(\"The elements of the doubly linked list in F.I.F.O. order: \\n\");\n  while (temp != NULL) {\n    printf(\"%d\\n\", temp - > data);\n    temp = temp - > next;\n  }\n}\n```", "```cpp\n//circularlinkedlist.c\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\nstruct node {\n  int data;\n  struct node * next;\n};\n\nstruct node * startList = NULL;\n\nvoid addlist(struct node ** h);\nvoid disp();\n\nint main() {\n  struct node * newNode;\n  int n = 0, i, k;\n  while (n != 3) {\n    printf(\"\\n1\\. Adding elements to the circular linked list\\n\");\n    printf(\"2\\. Displaying elements of the circular linked list\\n\");\n    printf(\"3\\. Quit\\n\");\n    printf(\"Enter your choice 1/2/3: \");\n    scanf(\"%d\", & n);\n    switch (n) {\n    case 1:\n      printf(\"How many values are there \");\n      scanf(\"%d\", & k);\n      printf(\"Enter %d values\\n\", k);\n      for (i = 1; i <= k; i++) {\n        newNode = (struct node * ) malloc(sizeof(struct node));\n        scanf(\"%d\", & newNode - > data);\n        addlist( & newNode);\n      }\n      printf(\"Values added in Circular Linked List \\n\");\n      break;\n    case 2:\n      disp();\n      break;\n    }\n  }\n  return 0;\n}\n\nvoid addlist(struct node ** NewNode) {\n  struct node * temp;\n  if (startList == NULL) {\n    startList = * NewNode;\n    startList - > next = startList;\n  } else {\n    temp = startList;\n    while (temp - > next != startList)\n      temp = temp - > next;\n    temp - > next = * NewNode;\n    temp = * NewNode;\n    temp - > next = startList;\n  }\n}\n\nvoid disp() {\n  struct node * temp;\n  if (startList == NULL)\n    printf(\"The circular linked list is empty\\n\");\n  else {\n    printf(\"Following are the elements in circular linked list:\\n\");\n    printf(\"%d\\n\", startList - > data);\n    temp = startList - > next;\n    while (temp != startList) {\n      printf(\"%d\\n\", temp - > data);\n      temp = temp - > next;\n    }\n  }\n}\n```", "```cpp\ninorder(node)\n```", "```cpp\ncall inorder(node->leftchild)\n```", "```cpp\ndisplay node->info\n```", "```cpp\n   call inorder(node->rightchild)\n```", "```cpp\n//binarysearchtree.c\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#define max 20\nstruct tree {\n  int data;\n  struct tree * right;\n  struct tree * left;\n};\nvoid build(int Arr[], int Len);\nstruct tree * makeroot(int val);\nvoid rightchild(struct tree * rootNode, int val);\nvoid leftchild(struct tree * rootNode, int val);\nvoid travino(struct tree * node);\nint main() {\n  int arr[max], i, len;\n  printf(\"How many elements are there for making the binary search tree? \");\n  scanf(\"%d\", & len);\n  printf(\"Enter %d elements in array \\n\", len);\n  for (i = 0; i < len; i++)\n    scanf(\"%d\", & arr[i]);\n  build(arr, len);\n  return 0;\n}\n\nvoid build(int Arr[], int Len) {\n  struct tree * temp, * rootNode;\n  int j;\n  rootNode = makeroot(Arr[0]);\n  for (j = 1; j < Len; j++) {\n    temp = rootNode;\n    while (1) {\n      if (Arr[j] < temp - > data) {\n        if (temp - > left != NULL) {\n          temp = temp - > left;\n          continue;\n        }\n        leftchild(temp, Arr[j]);\n      }\n      if (Arr[j] > temp - > data) {\n        if (temp - > right != NULL) {\n          temp = temp - > right;\n          continue;\n        }\n        rightchild(temp, Arr[j]);\n      }\n      break;\n    }\n  }\n  printf(\"Binary Search Tree is created\\n\");\n  printf(\"The inorder traversal of the tree is as follows:\\n\");\n  travino(rootNode);\n}\n\nstruct tree * makeroot(int val) {\n  struct tree * rootNode;\n  rootNode = (struct tree * ) malloc(sizeof(struct tree));\n  rootNode - > data = val;\n  rootNode - > right = NULL;\n  rootNode - > left = NULL;\n  return rootNode;\n}\n\nvoid leftchild(struct tree * rootNode, int val) {\n  struct tree * newNode;\n  newNode = (struct tree * ) malloc(sizeof(struct tree));\n  newNode - > data = val;\n  newNode - > left = NULL;\n  newNode - > right = NULL;\n  rootNode - > left = newNode;\n}\n\nvoid rightchild(struct tree * rootNode, int val) {\n  struct tree * newNode;\n  newNode = (struct tree * ) malloc(sizeof(struct tree));\n  newNode - > data = val;\n  newNode - > left = NULL;\n  newNode - > right = NULL;\n  rootNode - > right = newNode;\n}\n\nvoid travino(struct tree * node) {\n  if (node != NULL) {\n    travino(node - > left);\n    printf(\"%d\\t\", node - > data);\n    travino(node - > right);\n  }\n}\n```", "```cpp\nD:\\CAdvBook>GCC binarysearchtree.c - binarysearchtree\n```", "```cpp\n//postordernonrec.c\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\nstruct tree {\n  int data;\n  struct tree * right;\n  struct tree * left;\n};\n\nstruct stackstruc {\n  int valueArray[15];\n  struct tree * nodeArray[15];\n};\n\nstruct stackstruc stack;\nint top = -1;\n\nstruct tree * makeroot(int val);\nvoid rightchild(struct tree * rootNode, int val);\nvoid leftchild(struct tree * rootNode, int val);\nvoid nontravpost(struct tree * node);\nvoid pushNode(struct tree * node, int val);\nstruct tree * popNode();\nint popVal();\n\nint main() {\n  struct tree * temp, * rootNode;\n  int val;\n  printf(\"Enter elements of tree and 0 to quit\\n\");\n  scanf(\"%d\", & val);\n  rootNode = makeroot(val);\n  scanf(\"%d\", & val);\n  while (val != 0) {\n    temp = rootNode;\n    while (1) {\n      if (val < temp - > data) {\n        if (temp - > left != NULL) {\n          temp = temp - > left;\n          continue;\n        }\n        leftchild(temp, val);\n      }\n      if (val > temp - > data) {\n        if (temp - > right != NULL) {\n          temp = temp - > right;\n          continue;\n        }\n        rightchild(temp, val);\n      }\n      break;\n    }\n    scanf(\"%d\", & val);\n  }\n  printf(\"\\nTraversal of tree in Postorder without using recursion: \\n\");\n  nontravpost(rootNode);\n}\n\nstruct tree * makeroot(int val) {\n  struct tree * rootNode;\n  rootNode = (struct tree * ) malloc(sizeof(struct tree));\n  rootNode - > data = val;\n  rootNode - > right = NULL;\n  rootNode - > left = NULL;\n  return rootNode;\n}\n\nvoid leftchild(struct tree * rootNode, int val) {\n  struct tree * newNode;\n  newNode = (struct tree * ) malloc(sizeof(struct tree));\n  newNode - > data = val;\n  newNode - > left = NULL;\n  newNode - > right = NULL;\n  rootNode - > left = newNode;\n}\n\nvoid rightchild(struct tree * rootNode, int val) {\n  struct tree * newNode;\n  newNode = (struct tree * ) malloc(sizeof(struct tree));\n  newNode - > data = val;\n  newNode - > left = NULL;\n  newNode - > right = NULL;\n  rootNode - > right = newNode;\n}\n\nvoid nontravpost(struct tree * node) {\n  struct tree * temp;\n  int val;\n  temp = node;\n  while (1) {\n    while (temp != NULL) {\n      pushNode(temp, 0);\n      temp = temp - > left;\n    }\n    while (top >= 0) {\n      temp = popNode();\n      val = popVal();\n      if (val == 0) {\n        if (temp - > right != NULL) {\n          pushNode(temp, 1);\n          temp = temp - > right;\n          break;\n        }\n      }\n      printf(\"%d\\n\", temp - > data);\n      continue;\n    }\n    if ((temp == NULL) || (top < 0)) break;\n    else continue;\n  }\n}\n\nvoid pushNode(struct tree * node, int val) {\n  top++;\n  stack.nodeArray[top] = node;\n  stack.valueArray[top] = val;\n}\n\nstruct tree * popNode() {\n  return (stack.nodeArray[top]);\n}\n\nint popVal() {\n  return (stack.valueArray[top--]);\n}\n```", "```cpp\nD:\\CAdvBook>GCC postordernonrec.c - postordernonrec\n```"]