["```cpp\n    #include <boost/filesystem/operations.hpp>\n    #include <iostream>\n    ```", "```cpp\n    int main() {\n        boost::filesystem::directory_iterator begin(\"./\");\n    ```", "```cpp\n        boost::filesystem::directory_iterator end;\n        for (; begin != end; ++ begin) {\n    ```", "```cpp\n            boost::filesystem::file_status fs =\n                boost::filesystem::status(*begin);\n    ```", "```cpp\n            switch (fs.type()) {\n            case boost::filesystem::regular_file:\n                std::cout << \"FILE       \"; \n                break;\n            case boost::filesystem::symlink_file:\n                std::cout << \"SYMLINK    \"; \n                break;\n            case boost::filesystem::directory_file:\n                std::cout << \"DIRECTORY  \"; \n                break;\n            default:\n                std::cout << \"OTHER      \"; \n                break;\n            }\n            if (fs.permissions() & boost::filesystem::owner_write) {\n                std::cout << \"W \";\n            } else {\n                std::cout << \"  \";\n            }\n    ```", "```cpp\n            std::cout << *begin << '\\n';\n        } /*for*/\n    } /*main*/\n    ```", "```cpp\nFILE W \"./main.o\"\nFILE W \"./listing_files\"\nDIRECTORY W \"./some_directory\"\nFILE W \"./Makefile\"\n```", "```cpp\nboost::filesystem::file_status fs = begin->status();\n```", "```cpp\nstd::cout << begin->path() << '\\n';\n```", "```cpp\n    std::ofstream ofs(\"dir/subdir/file.txt\");\n    ofs << \"Boost.Filesystem is fun!\";\n```", "```cpp\n    #include <boost/filesystem/operations.hpp>\n    #include <cassert>\n    #include <fstream>\n    ```", "```cpp\n    int main() {\n        boost::system::error_code error;\n    ```", "```cpp\n        boost::filesystem::create_directories(\n            \"dir/subdir\", error);\n        assert(!error);\n    ```", "```cpp\n        std::ofstream ofs(\"dir/subdir/file.txt\");\n        ofs << \"Boost.Filesystem is fun!\";\n        assert(ofs);\n        ofs.close();\n    ```", "```cpp\n        boost::filesystem::create_directory_symlink(\"dir/subdir\", \"symlink\", error);\n    ```", "```cpp\n        if (!error) {\n            std::cerr << \"Symlink created\\n\";\n            assert(boost::filesystem::exists(\"symlink/file.txt\"));\n    ```", "```cpp\n        } else {\n            std::cerr << \"Failed to create a symlink\\n\";\n            boost::filesystem::remove(\"dir/subdir/file.txt\", error);\n            assert(!error);\n        } /*if (!error)*/\n    } /*main*/\n    ```", "```cpp\n    #include <boost/interprocess/managed_shared_memory.hpp>\n    ```", "```cpp\n    #include <boost/atomic.hpp>\n\n    typedef boost::atomic<int> atomic_t;\n    #if (BOOST_ATOMIC_INT_LOCK_FREE != 2)\n    #error \"This code requires lock-free boost::atomic<int>\"\n    #endif\n    ```", "```cpp\n    boost::interprocess::managed_shared_memory \n         segment(boost::interprocess::open_or_create, \"shm-cache\", 1024);\n    ```", "```cpp\n      atomic_t& atomic \n          = *segment.find_or_construct<atomic_t> //1\n              (\"shm-counter\") // 2\n              (0)             // 3\n      ;\n    ```", "```cpp\n        std::cout << \"I have index \" << ++ atomic \n            << \"\\nPress any key...\";\n        std::cin.get();\n    ```", "```cpp\n        int snapshot = -- atomic;\n        if (!snapshot) {\n            segment.destroy<atomic_t>(\"shm-counter\");\n            boost::interprocess::shared_memory_object\n                    ::remove(\"shm-cache\");\n        }\n    } /*main*/\n    ```", "```cpp\n    #include <boost/interprocess/managed_shared_memory.hpp>\n    #include <boost/interprocess/containers/deque.hpp>\n    #include <boost/interprocess/allocators/allocator.hpp>\n    #include <boost/interprocess/sync/interprocess_mutex.hpp>\n    #include <boost/interprocess/sync/interprocess_condition.hpp>\n    #include <boost/interprocess/sync/scoped_lock.hpp>\n\n    #include <boost/optional.hpp>\n    ```", "```cpp\n    struct task_structure {\n        // ...\n    };\n    ```", "```cpp\n    class work_queue {\n    public:\n        typedef task_structure task_type;\n        typedef boost::interprocess::managed_shared_memory\n            managed_shared_memory_t;\n\n        typedef boost::interprocess::allocator<\n            task_type, \n            managed_shared_memory_t::segment_manager\n        > allocator_t;\n    ```", "```cpp\n    private:\n        managed_shared_memory_t segment_;\n        const allocator_t allocator_;\n\n        typedef boost::interprocess::deque<task_type, allocator_t>\n            deque_t;\n\n        typedef boost::interprocess::interprocess_mutex mutex_t;\n        typedef boost::interprocess::interprocess_condition\n            condition_t;\n        typedef boost::interprocess::scoped_lock<mutex_t>\n            scoped_lock_t;\n\n        deque_t& tasks_;\n        mutex_t& mutex_;\n        boost::interprocess::interprocess_condition& cond_;\n    ```", "```cpp\n    public:\n        explicit work_queue()\n            : segment_(\n                  boost::interprocess::open_or_create,\n                  \"work-queue\",\n                  1024 * 1024 * 64\n            )\n            , allocator_(segment_.get_segment_manager())\n            , tasks_(\n                *segment_.find_or_construct<deque_t>\n                  (\"work-queue:deque\")(allocator_)\n            )\n            , mutex_(\n                *segment_.find_or_construct<mutex_t>\n                  (\"work-queue:mutex\")()\n            )\n            , cond_(\n                *segment_.find_or_construct<condition_t>\n                  (\"work-queue:condition\")()\n            )\n        {}\n    ```", "```cpp\n        boost::optional<task_type> try_pop_task() {\n            boost::optional<task_type> ret;\n            scoped_lock_t lock(mutex_);\n            if (!tasks_.empty()) {\n                ret = tasks_.front();\n                tasks_.pop_front();\n            }\n            return ret;\n        }\n    ```", "```cpp\nnamespace boost { namespace interprocess {\n    using boost::container::vector;\n}}\n```", "```cpp\nstruct with_pointer {\n    int* pointer_;\n    // ...\n    int value_holder_;\n};\n```", "```cpp\n#include <boost/interprocess/offset_ptr.hpp>\nstruct correct_struct {\n    boost::interprocess::offset_ptr<int> pointer_;\n    // ...\n    int value_holder_;\n};\n```", "```cpp\ncorrect_struct& ref = *segment\n    .construct<correct_struct>(\"structure\")();\n\nref.pointer_ = &ref.value_holder_;\nassert(ref.pointer_ == &ref.value_holder_);\nassert(*ref.pointer_ == ref.value_holder_);\n\nref.value_holder_ = ethalon_value;\nassert(*ref.pointer_ == ethalon_value);\n```", "```cpp\n    #include <boost/interprocess/file_mapping.hpp>\n    #include <boost/interprocess/mapped_region.hpp>\n    ```", "```cpp\n    const boost::interprocess::mode_t mode = boost::interprocess::read_only;\n    boost::interprocess::file_mapping fm(filename, mode);\n    ```", "```cpp\n    boost::interprocess::mapped_region region(fm, mode, 0, 0);\n    ```", "```cpp\n    const char* begin\n       = reinterpret_cast<const char*>(region.get_address());\n    ```", "```cpp\nconst char* pos = std::find(begin, begin + region.get_size(), '\\1');\n```", "```cpp\n$ TIME=\"%E\" time ./reading_files m\n\nmapped_region: 0:00.08\n\n$ TIME=\"%E\" time ./reading_files r\n\nifstream: 0:00.09\n\n$ TIME=\"%E\" time ./reading_files a\n\nC:\n 0:00.09\n\n```", "```cpp\nstd::ifstream f(filename, std::ifstream::binary);\n// ...\nchar c[kilobyte];\nf.read(c, kilobyte);\n```", "```cpp\n    #include <boost/coroutine/coroutine.hpp>\n    ```", "```cpp\n    typedef boost::coroutines::coroutine< \n        std::string&(std::size_t max_characters_to_process) \n    > corout_t;\n    ```", "```cpp\n    void coroutine_task(corout_t::caller_type& caller);\n\n    int main() {\n        corout_t coroutine(coroutine_task);\n    ```", "```cpp\n        // Doing some work\n        // ...    \n        while (!spinlock.try_lock()) {\n            // We may do some useful work, before \n            // attempting to lock a spinlock once more\n            coroutine(10); // Small delays\n        }\n        // Spinlock is locked\n\n        // ...\n        while (!port.block_ready()) {\n            // We may do some useful work, before \n            // attempting to get block of data once more\n            coroutine(300);  // Bigger delays\n            std::string& s = coroutine.get();\n            // ...\n        }\n    ```", "```cpp\n    void coroutine_task(corout_t::caller_type& caller) {\n        std::string result;\n\n        // Returning back to main program\n        caller(result);\n\n        while (1) {\n            std::size_t max_characters_to_process = caller.get();\n            // Do process some characters\n            // ...\n\n            // Returning result, switching back\n            // to main program\n            caller(result);\n        } /*while*/\n    }\n    ```"]