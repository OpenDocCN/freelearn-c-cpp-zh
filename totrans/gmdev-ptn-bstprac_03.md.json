["```cpp\nstruct GameObject \n{ \n  //using vectors from the Mach 5 Engine \n  M5Vec2 pos; \n  M5Vec2 scale; \n  float rotation; \n};\n\n```", "```cpp\nstruct Object \n{ \n  //using vectors from the Mach 5 Engine \n  M5Vec2 pos; \n  M5Vec2 scale; \n  float rotation; \n  float damage; \n  int health; \n  int textureID;      //for drawing \n  float textureCoords[4]; //for sprite animation \n  unsignedchar color[4]; //the color of our image \n};\n\n```", "```cpp\nstruct GameObject \n{ \n M5Vec2    pos; \n M5Vec2    scale; \n M5Vec2    vel; \n float     rotation;  \n ObjectType  type;     //Our object type enum \n int       objectID;   //So the missile can target \n int       lives; \n int       shieldHealth; //For Player and SuperBomber \n int       health; \n float     playerLaserDamage; \n float     playerIonDamage; \n float     playerWaveCannonDamage; \n float     superRaiderDamage; \n float     superRaiderAbilityDamage; \n float     superRaiderAbilityCoolDownTime; \n float     superBomberDamage; \n float     superBomberAbilityDamage; \n float     superBomberAbilityCoolDownTime; \n int       bombCount; \n float     bombRadius; \n int       missileCount; \n int       missileTargetID; \n int       textureID;    //the object image \n float     textureCoords[4];//for sprite animation \n unsigned  char color[4];    //the color of our image \n Command*  command;     //The command to do \n};\n\n```", "```cpp\n//Create our objects \nObject gameObjects[MAX_COUNT]; \n\n//initialization code here \n//... \n\n//Update loop \nfor(int i = 0; i < objectInUse; ++i) \n{ \n  switch(gameObjects[i].type) \n  { \n    case OT_PLAYER: \n      //Update based on input \n      break; \n    case OT_SUPER_RAIDER: \n      //Add intercept code here \n      break; \n    case OT_SUPER_BOMBER: \n      //Add case code here \n      break; \n    case OT_MISSILE: \n      //Add find target and chase code here \n      break; \n    case OT_BOMB: \n      //add grow to max radius code here \n      break; \n    default: \n      M5DEBUG_ASSERT(true, \"Incorrect Object Type\"); \n  } \n}\n\n```", "```cpp\nvoid Graphics::SetTexture(int textureID); \nvoid Graphics::SetTextureCoords(const float* coordArray); \nvoid Graphics::Draw(const M5Mtx44& worldMtx); \nvs \nvoid Graphics::Draw(const Object& obj);\n\n```", "```cpp\n//Inheritance Based Object: \nclass Object \n{ \n  public: \n    Object(void); \n    virtual ~Object(void);//virtual destructor is important \n    virtual void Update(float dt); \n    virtual void CollisionReaction(Object* pCollidedWith); \n  protected: \n    //We still need the basic data in all object \n    M5Vec2 m_pos; \n    M5Vec2 m_scale; \n    float m_rotation; \n    int m_textureID; \n}; \n\n//Inheritance Based derived class \nclass Unit: public Object \n{ \n  public: \n    Unit(void); \n    virtual ~Unit(void);   \n    virtual void Update(float dt); \n    virtual void CollisionReaction(Object* pCollidedWith); \n  protected: \n    M5Vec2 m_vel;//So that Units can move \n    float m_maxSpeed; \n    float m_health; \n    float m_damage; \n}; \n\nclass Enemy: public Unit \n{ \n  public: \n    Enemy(void); \n    virtual ~Enemy(void); \n    virtual void Update(float dt); \n    virtual void CollisionReaction(Object* pCollidedWith); \n  protected: \n    unsigned char m_color[4]; \n    float m_textureCoords[4];//For animation \n};\n\n```", "```cpp\n//Create our objects \nObject gameObjects[MAX_COUNT]; \n\n//initialization code here \n//... \n\nfor(int i = 0; i < objectsInUse; ++i) \n{ \n switch(gameObjects[i].type) \n { \n  case OT_PLAYER: \n   //Update based on input \n  break; \n  case OT_PLANET: \n   //Add intercept code here \n  break; \n  case OT_ENEMY_SPAWNER: \n   //Add case code here \n  break; \n  case OT_RAIDER: \n   //Add find target and chase code here \n  break; \n  case OT_BOMBER: \n   //Move slowly and do large damage code here \n  break; \n  default: \n   M5DEBUG_ASSERT(true, \"Incorrect Object Type\"); \n } \n}\n\n```", "```cpp\n//Create our objects \nObject* gameObjects[MAX_COUNT];//array of pointers \n\n//initialization code here \n//... \n\nfor(int i = 0; i < objectsInUse; ++i) \ngameObjects[i]->Update(dt);\n\n```", "```cpp\nclass Enemy: public Unit \n{ \n  public: \n    Enemy(void); \n    virtual ~Enemy(void); \n    virtual void Update(float dt); \n    virtual void CollisionReaction(Object* pCollidedWith); \n  protected: \n    unsigned char m_color[4]; \n    FlightAI*   m_flight; \n    AttackAI*   m_attack; \n};\n\n```", "```cpp\nclass Object \n{ \n  public: \n    //Same as before... \n  protected: \n     //Other Object Strategies \n     //... \n     Damage* m_damage. \n};\n\n```", "```cpp\nclass Component //Our base interface \n{ \n  public: \n    virtual ~Component(void) {} \n    virtual std::string Describe(void) const = 0; \n}; \n\nclass Object: public Component //Our core class to decorate \n{ \n  public: \n    Object(const std::string& name):m_name(name){} \n    virtual std::string Describe(void) const \n  { \n    return m_name; \n  } \n  private: \n    std::string m_name; \n}; \n\n//Our base and derived Decorators \nclass Decorator: public Component \n{ \n  public: \n    Decorator(Component* comp):m_comp(comp){} \n    virtual ~Decorator(void) { delete m_comp; } \n  protected: \n    Component* m_comp; \n}; \n\nclass RocketBoosters: public Decorator \n{ \n  public: \n    RocketBoosters(Component* comp) : Decorator(comp) {} \n    virtual std::string Describe(void) const \n  { \n    return m_comp->Describe() + \" with RocketBoosters\"; \n  } \n}; \n\nclass LaserCannons: public Decorator \n{ \n  public: \n    LaserCannons(Component* comp) : Decorator(comp) {} \n    virtual std::string Describe(void) const \n  { \n    return m_comp->Describe() + \" with LaserCannons\"; \n  } \n};\n\n```", "```cpp\n//Using this code: \nint main(void) \n{ \n  Component* ship = new Object(\"Player\"); \n  std::cout << ship->Describe() << std::endl; \n  delete ship; \n\n  Component* rocketShip = new RocketBoosters(new \n     GameObject(\"Enemy\")); \n  std::cout << rocketShip->Describe() << std::endl; \n  delete rocketShip; \n\n  Component* laserRocketShip = new LaserCannons(new \n     RocketBoosters(new GameObject(\"Boss\"))); \n  std::cout << laserRocketShip->Describe() << std::endl; \n  delete laserRocketShip; \n}\n\n```", "```cpp\n//Using only Strategy Pattern \nclass Object \n{ \n  public: \n    void Update(float dt);//Non virtual function to update \n       Strategies \n //Other interface here \n //... \n  private://Lots of different Strategies \n    GfxComp*   m_gfx; \n    BehaviorComp* m_behavior; \n    ColliderComp* m_collider; \n}; \n\n//Using Flexible Component Object Model \nclass Object \n{ \n  public: \n    void Update(float dt);//Non virtual function to update \n       Components \n    //Other interface here \n //... \n  private: \n    std::vector<Component*> m_components. \n}; \n\n//Our Base Component \nclass Component \n{ \n  public: \n    virtual void Update(float dt) = 0; \n  protected: \n    Object* m_obj; \n};\n\n```", "```cpp\n//Component based Game object used in the Mach 5 Engine \nclass M5Object \n{ \n  public: \n    M5Object(M5ArcheTypes type); \n    ~M5Object(void); \n\n    //Public interface \n    void     Update(float dt); \n    void     AddComponent(M5Component* pComponent); \n    void     RemoveComponent(M5Component* pComponent); \n    void     RemoveAllComponents(void); \n    void     RemoveAllComponents(M5ComponentTypes type); \n    int     GetID(void) const; \n    M5ArcheTypes GetType(void) const; \n    M5Object*  Clone(void) const; \n    template<typename T> \n    void GetComponent(M5ComponentTypes type, T*& pComp); \n    template<typename T> \n    void GetAllComponents(M5ComponentTypes type,\n       std::vector<T*>& comps); \n\n    M5Vec2    pos;    \n    M5Vec2    scale;    \n    M5Vec2    vel;    \n    float    rotation;  \n    float    rotationVel; \n    bool     isDead; \n  private: \n    //Shorter name for my vector \n    typedef std::vector<M5Component*> ComponentVec; \n    //Shorter name for my iterator \n    typedef ComponentVec::iterator  VecItor; \n\n    ComponentVec m_components; \n    M5ArcheTypes m_type;      \n    int     m_id;       \n    static int  s_objectIDCounter; \n};\n\n```", "```cpp\nM5Object::M5Object(M5ArcheTypes type) : \npos(0, 0), \n  scale(1, 1), \n  vel(0, 0), \n  rotation(0), \n  rotationVel(0), \n  isDead(false), \n  m_components(), \n  m_type(type), \n  m_id(++s_objectIDCounter) \n{ \n  m_components.reserve(START_SIZE); \n}\n\n```", "```cpp\nM5Object::~M5Object(void) \n{ \n  RemoveAllComponents(); \n}\n\n```", "```cpp\nvoid M5Object::AddComponent(M5Component* pToAdd) \n{  \n  //Make sure this component doesn't already exist \n  VecItor found = std::find(m_components.begin(), \n     m_components.end(), pComponent); \n\n  if (found != m_components.end()) \n   return; \n\n  //Set this object as the parent \n  pComponent->SetParent(this); \n  m_components.push_back(pComponent); \n}\n\n```", "```cpp\nvoid M5Object::Update(float dt) \n{ \n  int endIndex = m_components.size() - 1; \n  for (; endIndex >= 0; --endIndex) \n  { \n    if (m_components[endIndex]->isDead) \n    { \n      delete m_components[endIndex]; \n      m_components[endIndex] = m_components[m_components.size() \n         - 1]; \n      m_components.pop_back(); \n    } \n    else \n    { \n      m_components[endIndex]->Update(dt); \n    } \n  } \n//Update object data \n  pos.x  += vel.x * dt; \n  pos.y  += vel.y * dt; \n  rotation += rotationVel * dt; \n}\n\n```", "```cpp\nvoid M5Object::RemoveComponent(M5Component* pComponent) \n{ \n  //Make the sure the instance exists in this object \n  VecItor end = m_components.end(); \n  VecItor itor = std::find(m_components.begin(), end, pToRemove); \n\n  if (itor != end) \n    return; \n\n  (*itor)->isDead = true; \n}\n\n```", "```cpp\nvoid M5Object::RemoveAllComponents(void) \n  { \n  VecItor itor = m_components.begin(); \n  VecItor end = m_components.end(); \n  while (itor != end) \n  { \n    delete (*itor); \n    ++itor; \n  } \n  m_components.clear(); \n}\n\n```", "```cpp\nvoid M5Object::RemoveAllComponents(M5ComponentTypes type) \n{ \n   for (size_t i = 0; i < m_components.size(); ++i)  \n   { \n    if (m_components[i]->GetType() == type) \n     m_components[i]->isDead = true; \n  } \n}\n\n```", "```cpp\ntemplate<typename T> \nvoid M5Object::GetComponent(M5ComponentTypes type, T*& pComp) \n{ \n  size_t size = m_components.size(); \n  for (size_t i = 0; i < size; ++i) \n  { \n    //if we found the correct type, set and return \n    if (m_components[i]->GetType() == type) \n    { \n      pComp = static_cast<T*>(m_components[i]); \n      return; \n    } \n  } \n  pComp = 0; \n} \n\ntemplate<typename T> \nvoid GetAllComponent(M5ComponentTypes type, std::vector<T*>& comps) \n{ \n  size_t size = m_components.size(); \n  for (size_t i = 0; i < size; ++i) \n  { \n    //if we found the correct type, add to vector \n    if (m_components[i]->GetType() == type) \n    comps.push_back(static_cast<T*>(m_components[i])); \n  } \n}\n\n```", "```cpp\nclass M5Component \n{ \n  public: \n    M5Component(M5ComponentTypes type); \n    virtual ~M5Component(void); \n    virtual M5Component* Clone(void) = 0; \n    virtual void Update(float dt)= 0; \n    virtual void FromFile(M5IniFile&); \n    void SetParent(M5Object* pParent); \n    M5ComponentTypes GetType(void) const; \n    int GetID(void) const; \n //public data \n    bool isDead; \n  protected: \n    M5Object* m_pObj; \n  private: \n    int m_id; \n    M5ComponentTypes m_type; \n    staticint    s_compIDCounter; \n};\n\n```", "```cpp\nM5Component::M5Component(M5ComponentTypes type): \n  isDead(false), \n  m_pObj(0), \n  m_type(type), \n  m_id(++s_componentID) \n{ \n}\n\n```", "```cpp\nM5Component::~M5Component(void) \n{ \n  //Empty Base Class virtual destructor \n}\n\n```", "```cpp\nvoid M5Component::FromFile(M5IniFile&) \n{ \n  //Empty for the base class \n}\n\n```", "```cpp\nM5Object* pObj = new M5Object(AT_Player); \nGfxComponent* pGfxComp = new GfxComponent; \nPlayerInputComponent* pInput = new PlayerInputComponent; \nClampComponent* pClamp = new ClampComponent; \npObj->AddComponent(pGfxComp); \npObj->AddComponent(pInput); \npObj->AddComponent(pClamp ); \n//Set position, rotation, scale here \n//... \nM5ObjectManager::AddObject(pObj);\n\n```", "```cpp\nM5Object* M5ObjectManager::CreateObject(M5ArcheTypes type) \n{ \n  switch(type) \n  { \n    case AT_Player: \n    M5Object* pObj = new M5Object(AT_Player); \n    GfxComponent* pGfxComp = new GfxComponent; \n    PlayerInputComponent* pInput = new PlayerInputComponent; \n    ClampComponent* pClamp = new ClampComponent; \n    pObj->AddComponent(pGfxComp); \n    pObj->AddComponent(pInput); \n    pObj->AddComponent(pClamp ); \n    AddObject(pObj); \n    //Set position, rotation, scale here \n    //... \n    return pObj; \n    break; \n    case AT_Bullet: \n     //...More Code here\n\n```", "```cpp\nM5Object* pObj = M5ObjectManager::CreateObject(AT_Splash); \n//Set additional data here if needed\n\n```", "```cpp\nposX  = 0 \nposY  = 0 \nvelX  = 0 \nvelY  = 0 \nscaleX = 10 \nscaleY = 10 \nrot  = 0 \nrotVel = 0 \ncomponents = GfxComponent PlayerInputComponent ClampComponent \n\n[GfxComponent] \ntexture = playerShip.tga \n\n[PlayerInputComponent] \nforwardSpeed = 100 \nbulletSpeed = 7000 \nrotationSpeed = 10\n\n```"]