- en: Working with Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs show information in pictorial format. In graphs, certain information
    is plotted and then those plotted points are connected through lines or bars.
    Each plotted point is called a **vertex** (the plural of this is vertices), and
    the lines connecting them are called **edges**. Graphs have the ability to display
    large volumes of data in an easy-to-understand manner. Therefore, when comparing
    huge or enormous data, graphs are generally preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs can be used in several applications that include displaying a certain
    route of transmission or flow of data packets. Graphs can also be used to represent
    a kind of connection between two cities or stations, where stations can be represented
    by vertices and the route can be represented by edges. On social media, even friends
    can be connected in the form of graphs where each person can be represented by
    vertices and the edges between them ensure that they are friends. Similarly, graphs
    can be used for representing different networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to represent graphs using different data
    structures. We will also learn to traverse the graphs and create a minimum spanning
    tree from graphs. To be able to do so, we are going to look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an adjacency matrix representation of a directed graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an adjacency matrix representation of an undirected graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an adjacency list representation of a directed graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carrying out the breadth-first traversal of a graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carrying out the depth-first traversal of a graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating minimum spanning trees using Prim's algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating minimum spanning trees using Kruskal's algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin with the recipes, let's have a quick introduction to the two
    main types of graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on directions, graphs can be of two types: directed and undirected. Let''s
    review both of them briefly.'
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a directed graph, the edges clearly show the direction from one vertex to
    another. An edge in a directed graph is usually represented as (v1, v2), which
    means that the edge is pointing from vertex v1 toward vertex v2\. In other words,
    a (v1, v2) pair indicates that v1 is the starting vertex and v2 is the ending
    vertex. A directed graph is very useful in real-world applications and is used
    in the **World Wide Web** (**WWW**), Google''s PageRank algorithm, and more. Consider
    the following directed graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5062c4e-8e1e-4a55-96f2-713e32046883.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see an edge between vertices **a** and **b**. Because the edge
    is pointing from vertex **a** toward **b**, vertex **a** is considered to be the
    starting vertex and vertex **b** is considered the ending vertex. This edge can
    be represented as (**a**,**b**). Similarly, there is an edge from vertices **a**
    to **c**, which, in turn, can be represented as (**a**,**c**). Therefore, we can
    say that the preceding graph has the following set of vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the graph has the following set of edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Undirected graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An undirected graph is one in which the edges are present between vertices,
    but there is no specific direction identified – that is, there are no arrows at
    the end of the edges. Therefore, we cannot know which is the starting vertex and
    which one is the ending vertex. Undirected graphs are widely used in real-world
    applications such as Facebook and neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'An edge between two vertices, **a** and **b**, in an undirected graph will
    mean that either of them can be a starting or ending vertex. Such an edge can
    be written as (**a**,**b**), that is, from **a** to **b**, as well as (**b**,**a**),
    that is, from **b** to **a**. The following diagram shows an undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/349dc9df-61a5-4b5d-9893-77c97c494847.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for this undirected graph, the following is the set of vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the graph will have the following set of edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's begin with the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an adjacency matrix representation of a directed graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An adjacency matrix is a square matrix that is used to represent a graph. The
    rows and columns of the matrix are labeled as per the graph vertices. So, if the
    graph vertices are **1**,**2**,...**5**, then the rows and columns of the adjacency
    matrix will be labeled as **1**,**2**,...**5**. Initially, the matrix is filled
    with all zeros (0). Then, the 0 at the `mat[i][j]` location (where `i` and `j`
    refer to the vertices) is replaced by 1 if there is an edge between the vertices
    of `i` and `j`. For example, if there is an edge from vertex **2** to vertex **3**,
    then at the `mat[2][3]` index location, the value of 0 will be replaced by **1**.
    In short, the elements of the adjacency matrix indicate whether pairs of vertices
    are adjacent or not in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following directed graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3baf581-8851-47ee-9edf-036a6dc43230.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Its adjacency matrix representation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first row and the first column represent the vertices. If there is an edge
    between two vertices, then there will be a `1` value at the intersection of their
    respective row and column. The absence of an edge between them will be represented
    by `0`. The number of nonzero elements of an adjacency matrix indicates the number
    of edges in a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two drawbacks of adjacency matrix representation:'
  prefs: []
  type: TYPE_NORMAL
- en: This representation requires *n²* elements to represent a graph having *n* vertices.
    If a directed graph has *e* edges, then (*n²-e*) elements in the matrix would
    be zeros. Therefore, for graphs with a very low number of edges, the matrix becomes
    very sparse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel edges cannot be represented by an adjacency matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make an adjacency matrix representation
    of a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create an adjacency matrix representation of
    a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the user for the number of vertices in the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a square matrix that is equal to the number of vertices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize all the elements of the matrix to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user to enter the edges. For each edge (`i`,`j`) entered by the user,
    replace 0 at the `mat[i][j]` index location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the edges are entered, display all of the elements of the adjacency
    matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for creating an adjacency matrix representation of a graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming that the directed graphs the user will specify in this program will
    not be of more than 10 vertices, define a macro called `max` of value `10` and
    a two-dimensional matrix called `edg`, consisting of max rows and max columns.
    However, you can always increase the size of the macro if you think the user can
    specify a graph of more than 10 vertices.
  prefs: []
  type: TYPE_NORMAL
- en: In order to initialize all of the elements of the `edg` matrix to 0, define
    it as a static matrix. Thereafter, the user will be prompted to specify how many
    vertices there are in the graph. Suppose the user enters 5 to indicate that there
    are 5 vertices in the graph, then that value will be assigned to the `numb` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To make the recipe easy to understand, we assume that the vertices are sequentially
    numbered from 1 to 5\. The user is prompted to specify the edges between the vertices.
    This means that if there is an edge between vertices 1 and 3, then the user is
    supposed to enter the edge as 1,3\. The vertices entered representing these edges
    are then assigned to the vertices of v1 and v2\. Because the user is asked to
    specify the edges of the graph and to enter `0 0` when over, when the edge is
    assigned to the vertices of v1 and v2, we first ensure that the vertices are not
    0 and 0\. If they are, the program will stop asking for more edges and will branch
    to the statement from where the display of the adjacency matrix begins. If the
    vertices in the edge are not zero, then a value, 1, is assigned in the two-dimensional
    `edg` matrix at the index location of `[v1][v2]`. So, if there is an edge between
    vertices 1 and 2, then value 1 will be assigned at the `edg[1][2]` index location,
    replacing the value 0 that was initially there.
  prefs: []
  type: TYPE_NORMAL
- en: When all the edges of the graph are entered, the user will enter the vertices
    as `0 0` to indicate that all the edges have been entered. In that case, a nested
    `for` loop is executed and all the elements of the `edg` matrix are displayed
    on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `adjmatdirect.c` program has
    successfully compiled into the `adjmatdirect.exe` file. On executing the file,
    the user will be prompted to specify the number of vertices and its edges. Once
    the vertices and edges are entered, the program will display the adjacency matrix
    representation of the graph (take a look at the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0108a289-b589-44a0-8bba-4528db949081.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to do the same thing for an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an adjacency matrix representation of an undirected graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By adding one more statement in this recipe's code, the same program can be
    used for creating the adjacency matrix representation of an undirected graph as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We refer to the same graph that was in the previous recipe; however, this time,
    there are no edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23fcc3bf-4b99-4c22-8808-f609381d5611.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5
  prefs: []
  type: TYPE_NORMAL
- en: 'Its adjacency matrix representation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between the programs of the directed and undirected graphs
    is that, in the latter, the edge is simply repeated. That is, if there is an edge
    between a and b, then it is considered to be two edges: one from a to b and the
    other from b to a.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program for creating an adjacency matrix representation of an undirected
    graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you compare the preceding program with that of the directed graph, you
    will notice that only one extra statement has been added (marked in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is, in the case of an edge from `v1` to `v2`, an edge in reverse is also
    assumed, that is, from `v2` to `v1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `adjmatundirect.c` program has
    successfully compiled into the `adjmatundirect.exe` file. As expected, on running
    the file, the user will be prompted to specify the number of vertices and their
    edges. Once the number of vertices and edges are entered, the program will display
    the adjacency matrix representation of the undirected graph, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e870eb0c-3c29-4a96-81a2-ba2d39eb63fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an adjacency list representation of a directed graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an adjacency list representation, linked lists are used to represent the
    adjacent vertices of a vertex. That is, a separate linked list is made for the
    adjacent vertices of each vertex, and, in the end, all the vertices of the graph
    are connected. Because linked lists are used, this way of representing a graph
    uses memory in a more optimized manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following directed graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcfe1d39-0202-4cff-a19a-44e462f07844.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7
  prefs: []
  type: TYPE_NORMAL
- en: 'Its adjacency list representation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9282884-cdbe-41d8-a7d1-a427cd450009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding diagram that the adjacent vertices of vertex **1**
    are connected in the form of a linked list. Because there are no adjacent vertices
    for vertex **2**, its pointer is pointing to **NULL**. Similarly, the adjacent
    vertices of vertex **3**, that is, vertices **4** and **5**, are connected to
    vertex **3** in the form of a linked list. Once a linked list of all the vertices
    of the entire graph is created, all the vertices become connected through a link.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create the adjacency list representation
    of a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create an adjacency list representation of a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure called `node` that contains three members. One member, `nme`,
    is for storing the vertex of the graph; another member, `vrt`, is for connecting
    vertices of the graph; and, finally, `edg` is for connecting the adjacent vertices
    of the vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is asked to specify the count of the vertices in the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A linked list is created where the `nme` member of each node contains the vertex
    of the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the nodes representing vertices of the graph are connected to each other
    using the `vrt` pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the vertices are entered, the user is prompted to enter the edges of
    the graph. The user can enter any number of edges and to indicate that all the
    edges are entered, the user can enter `0 0` for the edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an edge is entered, for example, `b`, a `temp1` pointer is used and is
    set to point to vertex `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new node is created called `newNode`, and the vertex name `b` is assigned
    to the `nme` member of `newNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One more pointer is used, called `temp2`, and is set to point to the last node
    that is connected to vertex `a`. Once `temp2` reaches the end of vertex `a`, the
    `edg` member of the `temp2` node is set to point to `newNode`, and hence establishing
    an edge between `a` and `b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for creating the adjacency list representation of a directed graph
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume we are working with the following directed graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/555ca202-5a0e-491e-97f8-b069cbaeddd8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency list representation of this graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/908066b7-5c0f-4b4b-8aaa-54f7933bfa76.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a structure called "node" comprising the following three members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nme`: This is for storing the vertex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vrt`: A pointer to connect all the vertices of the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edg`: A pointer that connects all the vertices that are connected to the current
    vertex:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/256393a7-3cbe-400f-9ecc-85b6f50aa46c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11
  prefs: []
  type: TYPE_NORMAL
- en: The user is prompted to specify the number of vertices. Assuming the user enters
    the value of 5, the value of 5 will be assigned to the `numb` variable. A `startList`
    pointer is defined as `NULL`. The whole adjacency list will be accessed through
    this `startList` pointer and it will be set to point to the first vertex of the
    graph. The user is first asked to enter the names of the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the `startList` pointer is `NULL`, so a new node called `newNode`
    is created and the vertex name, say `a`, entered by the user is assigned to the
    `nme` member of `newNode`. The `startList` pointer is set to point to `newNode`.
    To connect more vertices with `newNode`, the `temp1` pointer is set to point to `newNode`.
    Initially, both the pointers, `vrt` and `edg`, are also set to `NULL`. Later,
    the `vrt` pointer will be set to point to other vertices and the `edg` pointer
    will be set to point to the vertices in which this current vertex is connected
    to. After the first iteration of the `for` loop, the node of the graph will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2d8f1c3-3240-490c-9c6a-34c34e92ec21.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second iteration of the `for` loop, because the `startList` pointer
    is no longer `NULL`, the `else` block will execute and, again, a new node is created,
    called `newNode`. Next, the vertex name is assigned to the named member of the
    `newNode`. Again, the `vrt` and `edg` pointers of `newNode` are set to `NULL`.
    To connect `newNode` to the earlier vertex, we will take the help of the `temp1`
    pointer. The `vrt` pointer of the node, which is pointed to by the `temp1` pointer,
    is set to point to `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/879493c2-998a-4f4d-97ae-6d741419e422.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `temp1` pointer is set to point to `newNode`, and the process is
    repeated for the rest of the vertices. Essentially, the `temp1` pointer is used
    for connecting more vertices. At the end of the `for` loop, the nodes will appear
    connected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22e98e49-d848-47c9-89d1-804949f6a2fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14
  prefs: []
  type: TYPE_NORMAL
- en: Once all the vertices of the graphs are entered, the user is asked to specify
    the edges between the vertices. Additionally, the user is asked to enter `0 0`
    when all the edges of the graph are entered. Suppose that the user enters `a b`
    to indicate there is an edge from vertex `a` to vertex `b`. The vertices are assigned
    to the `v1` and `v2` variables, respectively. We first ensure that the data in
    `v1` and `v2` is not 0\. If yes, that means all the edges of the graph are entered
    and the program will jump to the statement from where the display of the adjacency
    list begins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to connect the `a` and `b` vertices, first, the `temp1` pointer is set
    to point to `startList`. The `temp1` pointer is set to find the node whose `nme`
    member is equal to the vertex entered in variable `v1`, that is, `a`. The `temp1`
    pointer is already pointing to vertex `a`. Thereafter, you need to find the last
    node that is connected to `temp1`. The `temp2` pointer is used for finding the
    last node connected to the node pointed to by `temp1`. Because this is the first
    edge being entered of vertex `a`, the `edg` member of the node pointed to by `temp2`
    is already `NULL`. So, a new node is created called `newNode`, and the vertex
    name in variable `v2`, that is, `b` is assigned to the `nme` variable of `newNode`.
    The `edg` and `vrt` members of `newNode` are set to `NULL`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66abaa9d-3396-47a0-a427-035b56e28639.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15
  prefs: []
  type: TYPE_NORMAL
- en: 'The `edg` member of `temp2` is set to point to `newNode` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42b65eb4-af47-4abc-97ec-d3a6f0f27cbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16
  prefs: []
  type: TYPE_NORMAL
- en: The procedure is repeated for the rest of the edges entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `adjlistdirect.c` program has
    successfully compiled into the `adjlistdirect.exe` file. On executing the executable
    file, the user will be prompted to specify the number of vertices and their edges.
    Once the vertices and edges are entered, the program will display the adjacency
    list representation of the directed graph, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b880d52-cd82-4e36-aa24-4ed14c6d2226.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Carrying out the breadth-first traversal of a graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traversal of a graph refers to when you visit each of the vertices of a
    graph exactly once in a well-defined order. To ensure that each vertex of the
    graph is visited only once and to know which vertices have already been visited,
    the best way is to mark them. We will also look at how vertices are marked in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first traversal tends to create very short and wide trees. It operates
    by vertices in layers, that is, the vertices closest to the start are evaluated
    first, and the most distant vertices are evaluated last. Hence, it is referred
    to as the level-by-level traversal of the tree. The breadth-first traversal of
    a graph is very popularly used for finding the shortest path between two locations
    (vertices), that is, the path with the least number of edges. It is also used
    to find the linked pages of a web page, broadcasting information, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to carry out the breadth-first traversal of
    a graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to carry out the breadth-first traversal of a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the first vertex of the graph into the queue. Any vertex can be chosen as
    a starting vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, repeat the following *steps 3* to *8* until the queue is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take out the vertex from the queue and store it in a variable, say `v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark it as visited (the marking is done so that this vertex should not be traversed
    again).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the marked vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the adjacency vertices of the vertex `v`, and then perform *steps 7*
    to *8* on each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of the adjacency vertices of `v` are not marked, mark it as visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the adjacency vertex to the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for the breadth-first traversal of a graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are using the adjacency list representation of the directed graph from the
    previous recipe, *Creating an adjacency list representation of a directed graph*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c4d94a8-b74d-4637-b21f-172779bab61c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18
  prefs: []
  type: TYPE_NORMAL
- en: 'The `temp1` pointer is set to point to `startList`. That is, `temp1` is pointing
    to the node with vertex `a`. If `temp1` is not `NULL`, the node pointed to by
    the `temp1` pointer is added to the queue. The rear variable, which is -1 at the
    moment, is incremented to 0 and the `a` node is added to the array of `que` nodes at
    index location `0`. Because the value of the front index location is -1 currently,
    the front is also set to 0, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b33f87ad-50e3-4754-8199-16b074cef499.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, the dequeue function is invoked to remove a node from the queue.
    Unsurprisingly, the node at the `que[0]` index location, that is, `a`, is returned
    and, because the values of **front** and **rear** are the same, the values of
    the **front** and **rear** indices are set to -1, to indicate that the queue is
    empty again.
  prefs: []
  type: TYPE_NORMAL
- en: The node containing vertex `a` is returned from the queue and is assigned to
    the `temp3` pointer. The `temp1` pointer is set to point to the `startList` pointer.
    The marked member of the `temp3` node, that is, vertex `a`, is set to `N` initially.
    The vertex name stored in the `nme` member of the node is displayed, that is,
    vertex `a` is displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After displaying vertex `a`, its marked member is set to `Y` to indicate that
    the node is visited and should not be traversed again. The next step is to find
    the adjacent vertices of vertex `a`. To do so, the `temp2` pointer is set to point
    to where the `edg` pointer of `temp3` is pointing. The `edg` pointer of `temp3`
    is pointing at vertex `b`, so `temp2` is set to point at vertex `b`. Again, the
    procedure is repeated. If `temp2` is not `NULL`, the `b` node is queued, that
    is, it is added to the `que[0]` index location. Because all of the nodes that
    are connected to vertex `a` have to be queued, the `temp2` pointer is set to point
    to the location where its `edg` pointer is pointing. The `edg` pointer of node
    `b` (in the adjacency list) is pointing to node `c`, so node `c` is also inserted
    into the queue at the `que[1]` index location as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20e1aa1d-add2-48e9-b146-f0e7da5c9efd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20
  prefs: []
  type: TYPE_NORMAL
- en: In the queue, nodes `b` and `c` are present. Now, again, the dequeue function
    is invoked; node `b` is removed from the queue and the `temp3` pointer is set
    to point to it. The `temp1` pointer is initially set to point to `startList` and,
    thereafter, by making use of its `vrt` pointer, the `temp1` pointer is set to
    point to vertex `b`. Because the marked member of node `b` is `N`, its vertex
    name, `b`, is displayed on screen followed by setting its marked member to `Y`.
    A `temp2` pointer is set to point to where the `edg` member of node `b` is pointing.
    The `edg` member of node `b` is pointing to `NULL`, so the next node in the queue
    is accessed, that is, node `c` is removed from the queue and the `temp3` pointer
    is set to point to it. Because the queue is again empty, the values of the `front`
    and `rear` variables are set to -1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the `temp1` pointer is set to point at vertex `c`, and the `c` node is
    displayed on screen, that is, it is traversed and its marked member is set to
    `Y`. So, up until now, nodes `a`, `b`, and `c` are displayed on screen. And the
    node that is attached to the `edg` member of `c` is added to the queue, that is,
    node `d` is added to the queue at the `que[0]` index location. Additionally, the
    node pointed to by the `edg` pointer of node `d` is accessed, that is, node `e` is
    also queued or, in other words, added at the `que[1]` index location as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44d849e-75b0-467d-9350-d19cd652d4df.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21
  prefs: []
  type: TYPE_NORMAL
- en: Node `d` is removed from the queue and displayed (traversed). The nodes pointed
    to by their `edg` member are accessed and, if any of them is marked, then `N`
    is added to the queue. The whole procedure is repeated until the queue becomes
    empty. The sequence in which the vertices are displayed on screen forms the breadth-first
    traversal of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `breadthfirsttrav.c` program has
    successfully compiled into the `breadthfirsttrav.exe` file. On executing the file,
    the user will be prompted to specify the count of vertices in the graph, followed
    by entering the vertices'' names. Thereafter, the user is asked to enter the edges
    of the graph and to enter `0 0` when completed. After the edges of the graph have
    been entered, the adjacency list representation of the graph will be displayed,
    followed by the breadth-first traversal of the graph, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9a64beb-e5b1-4991-8b86-cda91f9a5c98.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Carrying out the depth-first traversal of a graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In depth-first traversal (also called depth-first search), all nodes of a graph are
    visited by taking a path and going as deep as possible down that path. On reaching
    the end, you go back, pick up another path, and then repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to carry out the depth-first traversal of
    the graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps for the depth-first traversal of a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Push the first vertex of the graph into the stack. You can choose any vertex
    of the graph as the starting vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, repeat the following *steps 3* to *7* until the stack is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop the vertex from the stack and call it by any name, say, `v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the popped vertex as visited. This marking is done so that this vertex
    should not be traversed again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the marked vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out the adjacency vertices of the `v` vertex, and then perform *step 7*
    on each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of the adjacency vertices of `v` are not marked, mark them as visited
    and push them on to the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for the depth-first traversal of a graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are using the adjacency list representation of the directed graph from the
    previous recipe, *Creating an adjacency list representation of a directed graph*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b647493-abe4-4f75-ae85-9c4d161e9069.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23
  prefs: []
  type: TYPE_NORMAL
- en: 'The `temp1` pointer is set to point to `startList`, that is, at node `a`, which
    we have assumed as the starting vertex of the graph. We then ensure that if `temp1`
    is not `NULL`, then the node pointed to by the `temp1` pointer is pushed to the
    stack. The value of `top`, which is initially -1, is incremented to 0 and node
    `a` is added to the array of the nodes stack at index location **0**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33f8dbd6-9d25-46ba-a115-a37ab55a1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, the `pop` function is invoked to remove the node from the stack.
    The node at the `stack[0]` index location is returned and the value of `top` is
    again decremented to -1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The node containing vertex `a` is returned to the `temp3` pointer. The `temp1`
    pointer is set to point to the `startList` pointer. The marked member of the `temp3`
    node, that is, vertex `a`, is set to `N` initially. The vertex name stored in
    the `nme` member of the node is displayed, that is, vertex `a`, is displayed on
    screen. After displaying vertex `a`, its marked member is set to `Y` to indicate
    that the node is visited and should not be traversed again. The `temp2` pointer is
    set to point to where the `edg` pointer of `temp3` is pointing. The `edg` pointer
    of `temp3` is pointing to vertex `b`, so `temp2` is set to point to vertex `b`.
    Again, the procedure is repeated, that is, we check whether `temp2` is not `NULL`,
    and then node `b` is pushed to the stack at the `stack[0]` index location. Because
    all of the nodes that are connected to vertex `a` have to be pushed to the stack,
    the `temp2` pointer is set to point to the location that its `edg` pointer is
    pointing to. The `edg` pointer of node `b` (in the adjacency list) is pointing
    to node `c`, so node `c` is also pushed to the stack at the `stack[1]` index location,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eea4b1f6-f2e8-4c38-92e6-0441a041ad3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25
  prefs: []
  type: TYPE_NORMAL
- en: In the stack, nodes `b` and `c` are present. Now, again, the `pop` function
    is invoked, and the node, `c`, is popped from the stack and the `temp3` pointer
    is set to point to it. The `temp1` pointer is initially set to point to `startList`
    and, thereafter, by making use of its `vrt` pointer, the `temp1` pointer is set
    to point to vertex `c`. Because the marked member of node `c` is *N*, its vertex
    name, `c`, is displayed on screen and its marked member is set to `Y`. So, up
    until now, nodes `a` and `c` are displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `temp2` pointer is set to point to where the `edg` member of node `c` is
    pointing. The `edg` member of node `c` is pointing to node `d`, so the `d` node is
    pushed to the stack and the next adjacent node of `c` is accessed. The next adjacent
    node of node `c` is node `e`, which is also pushed to the stack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74775bfa-0ce9-4bea-9daf-c4b00b786233.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the topmost node from the stack, node `e`, is popped, and the `temp3`
    pointer is set to point to it. Again, the `temp1` pointer is set to point to vertex
    `e`, and node `e` is displayed on screen, that is, it is traversed. Then, its
    marked member is set to `Y`, and the node that is attached to the `edg` member
    of `e` is pushed to the stack, that is, node `a` is pushed to the stack, followed
    by node `b`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/644d22ba-f55e-42ad-bf63-44aa20e7507f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27
  prefs: []
  type: TYPE_NORMAL
- en: 'Node `b` is popped and the `temp3` pointer is set to point to it. The `temp1`
    pointer is set to point to node `b`. Because the marked member of node `b` is
    `N`, stating that it is not yet traversed, vertex `b` is displayed on screen and
    its marked member is set to `Y`. Since there is no adjacent member of vertex `b`,
    the next node, `a`, in the stack is popped. Because vertex `a` has already been
    visited, the next node from the stack is popped: node `d`. The procedure is repeated,
    and the sequence of vertices displayed is considered as the depth-traversal of
    the graph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `depthfirsttrav.c` program has
    successfully compiled into the `depthfirsttrav.exe` file. On executing the file,
    the user will be prompted to specify the count of vertices in the graph, followed
    by entering the vertices'' names. Thereafter, the user is asked to enter the edges
    of the graph and enter `0 0` when completed. After the edges of the graph are
    entered, the adjacency list representation of the graph will be displayed, followed
    by the depth-first traversal of the graph, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/795862d3-4917-42cd-94e8-e6245c4d90a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Creating minimum spanning trees using Prim's algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a minimum spanning tree. A minimum
    spanning tree of a graph with *n* number of nodes will have *n* nodes. In a connected
    weighted graph, each edge of the graph is assigned a non-negative number called
    the "weight of the edge." Then, any spanning tree of the graph is assigned a total
    weight obtained by adding the weights of the edges in the tree. A minimum spanning
    tree of a graph is a spanning tree whose total weight is as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of techniques that you can use to create a minimum spanning
    tree for a weighted graph. One of these methods is called Prim's algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Prim's algorithm is part of the category of greedy algorithms, where vertices
    are connected with edges that have the lowest weights. An arbitrary node is chosen
    initially as the tree root. In an undirected graph, any node can be considered
    as the tree root and the nodes adjacent to it as its children. The nodes of the
    graph are then appended to the tree, one at a time, until all of the nodes of
    the graph are included. The node of the graph added to the tree at each point
    is adjacent to a node of the tree by an arc of minimum weight. The arc of minimum
    weight becomes a tree arc connecting this new node to the tree. When all the nodes
    of the graph have been added to the tree, a minimum spanning tree is said to be
    made for the graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement Prim''s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose any vertex from the graph as the root of the minimum spanning tree. It
    can be any random vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the edges from the vertex (or vertices in the tree) to other vertices
    in the graph. From those vertices, choose the vertex that has the edge with the
    minimum weight and add that vertex to the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 2* until all the vertices of the graph are added to the minimum
    spanning tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following weighted graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b0c7bf8-8cc4-42ca-b881-c5fb106e5356.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to get the minimum spanning tree of this graph, we connect the vertices
    starting from vertex `a` (you can consider any vertex as the starting vertex of
    the graph). From the starting vertex, choose the nearest vertex having the lowest
    weight, and then repeat the procedure until all of the vertices are connected.
    In that way, we get the minimum spanning tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/524adce9-751f-4e6f-a5b8-5a0f23a813a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graph is called a tree because it is acyclic; it is called spanning
    because it covers every vertex.
  prefs: []
  type: TYPE_NORMAL
- en: The number of edges in a minimum spanning tree is *v-1*, where *v* is the number
    of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program for creating a minimum spanning tree using Prim''s algorithm is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user is prompted to specify the number of vertices. Assuming the user enters
    `5`, the value of `5` will be assigned to variable `n`. The vertices will be automatically
    named `1`, `2`, `3`, `4`, and `5` for convenience. A `startList` pointer of the
    node type is defined and is set to `NULL` initially. The `startList` pointer will
    be pointing to the first node of the adjacency linked list that will be created
    from the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two structures are defined: one is called `node` and the other is called `lst`.
    The `node` structure is for making the adjacency list representation of the graph
    and the `lst` structure is for creating a minimum spanning tree. Two pointers, `pq`
    and `tr`, are defined of the `lst` type and are defined as `NULL`.'
  prefs: []
  type: TYPE_NORMAL
- en: To make the adjacency linked list representation, the first step is to create
    a linked list of the nodes, where each node represents a vertex of the graph.
    Because there are five vertices in the graph, a `for` loop is set to execute five
    times. Within the `for` loop, a node is created, called `newNode`, and the vertex
    number, `1`, is assigned to its `nme` member. The `startList` pointer is set to
    point to `newNode`. The `vrt` and `edg` members of `newNode` are set to `NULL`.
    The `temp1` pointer is also set to point to `newNode`. The `startList` pointer
    will keep pointing to the first node of the linked list, whereas the `temp1` pointer
    will be used for connecting other nodes, that is, other vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next iteration of the `for` loop, again, a new node is created, called `newNode`,
    and the vertex number, `2`, will be assigned to it. The `vrt` and `edg` members
    of `newNode` are set to `NULL`. To connect with the existing vertices, `1`, the
    `vrt` member of `temp1` is set to point to `newNode`. Thereafter, `temp1` is set
    to point to `NewNode`. The `for` loop will execute for the time equal to the number
    of vertices, that is, five, hence creating five nodes that contain their respective
    vertex numbers. By the time the `for` loop terminates, the vertices will be created
    and will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5159fa84-fbf8-4a76-bf99-4be637354681.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.31
  prefs: []
  type: TYPE_NORMAL
- en: Once the vertices are created, the next step is to ask the user for the edges
    between the vertices. A graph having *n* vertices can, at most, have *n * (n-1)*
    edges. Because the number of vertices is five, so the node, that is, the number
    of edges variable, is initialized to *5*4=20*. A `for` loop, `j`, is set to execute
    from 1 to 20, asking the user to enter the edges and their respective weights.
    Suppose that the user enters an edge as `1 2`, which will be assigned to the `a`
    and `b` variables, respectively; the weight entered is `1`, which is assigned
    to the `w` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To create this edge, the `temp1` pointer is set to point to `startList`. To
    create a (*1*,*2*) edge, the `temp1` pointer is set to point to the node whose
    `nme` member is equal to 1\. Currently, `temp1` is already pointing to vertex
    `1`. The next step is to add vertex `2` at the end of vertex `1`. To find the
    end of a vertex, we will take the help of another pointer, called `temp2`. The
    `temp2` pointer is first set to point to the node that the `temp1` pointer is
    pointing to. Thereafter, using its `edg` pointer, `temp2` is set to point to the
    last node of vertex `1`. Then, a new node is created, called `newNode`, and the
    value of `2` is assigned to the `nme` member of `newNode`. The weight, `1`, in
    the `w` variable is assigned to the `wt` member of `newNode`. The `edge` and `vrt`
    pointers of `newNode` are set to `NULL`. And, finally, the `edg` member of `temp2`
    is set to point to `newNode`. Therefore, vertices `1` and `2` are now connected.
  prefs: []
  type: TYPE_NORMAL
- en: This is an undirected graph, and edge (*1*,*2*) can also mean an edge from `2`
    to `1`. So, we need an edge from vertex `2` to `1`. The `temp1` pointer is set
    to point to `startList`. Using its `vrt` pointer, the `temp1` pointer is set to
    move further until it reaches vertex `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Once `temp1` reaches vertex `2`, the next step is to set the `temp2` pointer
    to point to the last node of vertex `2`. After doing so, a new node, called `newNode`,
    is created and the value of `1` is assigned to its `nme` member. Additionally,
    the weight in the `w` variable is assigned to the `wt` member of `newNode`. To
    connect these nodes that contain vertices `2` and `1`, the edge pointer of `temp2`
    is set to point to `newNode`. The `edg` and `vrt` pointers of `newNode` are set
    to `NULL`. Therefore, vertices `2` and `1` are connected now too.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the adjacency linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After entering all of the edges along with their weights, the adjacency list
    has to be displayed. To do this, a `temp1` pointer is set to point to `startList`.
    A `while` loop will execute until the `temp1` pointer reaches `NULL`. So, the `temp1`
    pointer will point to vertex `1` initially. Thereafter, by taking the help of
    the second pointer, `temp2`, all the edges of the `temp1` pointer (that is, vertex
    `1`) are accessed and displayed on screen. After displaying all the edges of vertex
    `1`, by making use of the `vrt` member, the `temp1` pointer is set to point to
    the next vertex, that is, to vertex `2`. Again, the `temp2` pointer is set to
    point at vertex `2`, and, using its `edg` member, all the edges of vertex `2`
    are displayed. The procedure is repeated for all the vertices of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency list will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f1a953c-745e-4efc-b4b6-7dcd4f3f6e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.32
  prefs: []
  type: TYPE_NORMAL
- en: Creating the minimum spanning tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make the minimum spanning tree, we need to adjust the edges of the vertices
    in ascending order. The `temp1` pointer is set to point at `startList`, that is,
    vertex `1`. The `temp2` pointer is set to point to where the `edg` pointer of
    `temp1` is pointing to, that is, vertex `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, until `temp2` becomes `NULL`, the `addpqu` function is invoked and vertices
    `1` and `2`, and their weight, `1`, are passed to it. In the `addpqu` function,
    a structure is created called `lstNode` of the `lst` type. The `1` and `2` vertices and
    their weight, `1`, are assigned to the `u`, `v`, and `wt` members, respectively.
    The next pointer of `lstNode` is set to `NULL`. Additionally, a pointer, `pq`,
    is set to point to `lstNode`.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, the `temp2` pointer is set to point to where its `edg` pointer
    is pointing, that is, vertex `3`. Again, the `addpqu` function is called and vertices
    `1` and `3` and weight `3` are passed to it. In the `addpqu` function, again,
    a new node is creating, called `lstNode`, and vertices `1` and `3` and weight
    `3` are assigned to its `u`, `v`, and `wt` members, respectively. The next pointer
    of `lstNode` is set to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Because the nodes have to be arranged in ascending order of their weights, the
    `wt` member of `lstNode` and the previous node, `pq`, are compared. The `wt` member
    of `lstNode` is 3, which is greater than the `wt` member of the `pq` node, which
    is 1\. So, the help of two pointers, `findloc1` and `findloc2`, is taken. One
    pointer is set to point to the weights of `lstNode`, and the `pq` nodes are compared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s choose a vertex, `1`, and add it to the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb496930-0a18-4b6d-8c2d-f9c16e428d00.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.33
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from vertex `1`, there are edges to the vertices of `3`, `2`, and `5`,
    but the edge with the minimum weight is to vertex `2`. So, vertex `2` is also
    added to the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5423d76-6f09-47cc-b12f-159128ef27e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.34
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, from vertices `1` and `2` in the minimum spanning tree, we search for
    all the edges that lead to other vertices. We find that edges (**1**,**5**) and
    (**2**,**5**) have the same weight, so we can choose either of the vertices. Let''s
    add edge (**2**,**5**) to the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/933474db-e3fa-44d4-9bb2-ac8265cf25b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.35
  prefs: []
  type: TYPE_NORMAL
- en: 'From the vertices of `1`, `2`, and `5` in the minimum spanning tree, we search
    for the edges with the lowest weights. Edge (**5**,**3**) has the minimum weight
    of `1`, so edge (**5**,**3**) is added to the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24884208-c29b-4c57-b327-771c88b032dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.36
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to find the edge that leads to vertex `4` from the existing vertices
    in the minimum spanning tree. Edge (**3**,**4**) has the lowest weight and is,
    therefore, added to the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/886fbfc6-e0d7-46d2-9723-68671d6940fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.37
  prefs: []
  type: TYPE_NORMAL
- en: 'On compiling and running the program, you should get an output that is similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39c364df-efd7-4d91-b77d-7f45731f6473.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.38
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Creating minimum spanning trees using Kruskal's algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make a minimum spanning tree using Kruskal's
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A minimum/minimal spanning tree of an undirected graph is a tree that is formed
    from graph edges that connect all of the vertices of the graph at the lowest total
    cost. A minimum spanning tree can exist if, and only if, the graph is connected.
    A graph is said to be connected if there exists a path between any two vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the nodes of the graph are initially considered as *n* distinct partial
    trees with one node each. At each step of the algorithm, two distinct partial
    trees are connected into a single partial tree by an edge of the graph. When only
    one partial tree exists (for instance, after *n-1* such steps), it is a minimum
    spanning tree.
  prefs: []
  type: TYPE_NORMAL
- en: The connecting arc of minimum cost is used to connect two distinct trees. To
    do this, the arcs can be placed in a priority queue based on weight. The arc of
    lowest weight is then examined to see whether it connects two distinct trees.
    To determine whether an arc *(x, y)* connects two distinct trees, we can implement
    the trees with a father field in each node. Then, we can traverse all the ancestors
    of *x* and *y* to obtain the root of the tree connecting them. If the root of
    the two trees is the same node, and *x* and *y* are already in the same tree,
    then arc *(x, y)* is discarded, and the arc of the next lowest weight is examined.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a minimum spanning tree using Kruskal''s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the edge list in ascending order of their weights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick up the edge at the top of the edge list (with the smallest weight).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove this edge from the edge list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the two vertices with the given edge. If, by connecting the vertices,
    a cycle is made in the graph, then discard the edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the preceding *steps 2* to *4* until *n-1* edges are added or the list
    of edges is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for creating a minimum spanning tree using Kruskal''s algorithm
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e060dfd4-857c-4bee-8c2b-a4227ffa6368.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.39
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the graph has five vertices, the minimum spanning tree will have four
    edges. The first step in Kruskal''s algorithm is that the edges of the graph are
    first sorted in ascending order of their weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will pick up one edge at a time from the preceding table, and, if it
    does not make a cycle, we will include it in the minimum spanning tree. We begin
    with edge (**1**,**2**). There is no cycle in this edge; therefore, it is included
    in the minimum spanning tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0498f249-59d5-454c-9e36-7bc7a2c18def.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.40
  prefs: []
  type: TYPE_NORMAL
- en: 'The next edge in the table is (**3**,**5**). This edge also does not make a
    cycle, so it included in the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4804d6e5-ff89-4c34-b7d8-7a852bb5a93a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.41
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, pick edge (**1**,**5**). Again, no cycle is made with this edge, so it
    is included in the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89b8c93c-7e07-4359-8216-e79bcd431954.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.42
  prefs: []
  type: TYPE_NORMAL
- en: 'The next edge in the table is (**2**,**5**) but it does make a cycle, so it
    is discarded. The next edge in the table is (**3**,**4**). Edge (**3**,**4**)
    does not make a cycle; therefore, it is added to the minimum spanning tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbbf0062-1f58-453c-bdf6-38f165e9c773.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.43
  prefs: []
  type: TYPE_NORMAL
- en: The number of vertices is 5, so the number of edges will be *v-1*, that is,
    4, and we have 4 edges, so our minimum spanning tree is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'On compiling and running the `kruskal.c` program, we get an output that is
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36d6d6ef-83f6-4a64-bb0e-fa68d2ac2538.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.44
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get the adjacency list representation and the minimal spanning
    tree using Kruskal's algorithm in the output.
  prefs: []
  type: TYPE_NORMAL
