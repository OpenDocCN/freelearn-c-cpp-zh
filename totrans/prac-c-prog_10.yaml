- en: Working with Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图
- en: Graphs show information in pictorial format. In graphs, certain information
    is plotted and then those plotted points are connected through lines or bars.
    Each plotted point is called a **vertex** (the plural of this is vertices), and
    the lines connecting them are called **edges**. Graphs have the ability to display
    large volumes of data in an easy-to-understand manner. Therefore, when comparing
    huge or enormous data, graphs are generally preferred.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图表以图形格式展示信息。在图表中，某些信息被绘制出来，然后通过线条或条形连接这些绘制点。每个绘制点被称为**顶点**（复数形式为vertices），连接它们的线条被称为**边**。图表能够以易于理解的方式展示大量数据。因此，在比较大量或巨大的数据时，图表通常更受欢迎。
- en: Graphs can be used in several applications that include displaying a certain
    route of transmission or flow of data packets. Graphs can also be used to represent
    a kind of connection between two cities or stations, where stations can be represented
    by vertices and the route can be represented by edges. On social media, even friends
    can be connected in the form of graphs where each person can be represented by
    vertices and the edges between them ensure that they are friends. Similarly, graphs
    can be used for representing different networks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以在多个应用中使用，包括显示某种传输路线或数据包的流动。图也可以用来表示两个城市或站点之间的一种连接，其中站点可以用顶点表示，路线可以用边表示。在社交媒体上，甚至可以将朋友以图的形式连接起来，其中每个人可以表示为一个顶点，他们之间的边确保他们是朋友。同样，图可以用来表示不同的网络。
- en: 'In this chapter, we will learn how to represent graphs using different data
    structures. We will also learn to traverse the graphs and create a minimum spanning
    tree from graphs. To be able to do so, we are going to look at the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用不同的数据结构来表示图。我们还将学习遍历图并从图中创建最小生成树。为了能够做到这一点，我们将查看以下食谱：
- en: Creating an adjacency matrix representation of a directed graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有向图的邻接矩阵表示
- en: Creating an adjacency matrix representation of an undirected graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无向图的邻接矩阵表示
- en: Creating an adjacency list representation of a directed graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有向图的邻接表表示
- en: Carrying out the breadth-first traversal of a graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行图的广度优先遍历
- en: Carrying out the depth-first traversal of a graph
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行图的深度优先遍历
- en: Creating minimum spanning trees using Prim's algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用普里姆算法创建最小生成树
- en: Creating minimum spanning trees using Kruskal's algorithm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用克鲁斯卡尔算法创建最小生成树
- en: Before we begin with the recipes, let's have a quick introduction to the two
    main types of graphs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始食谱之前，让我们快速介绍两种主要的图类型。
- en: Types of graphs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表类型
- en: 'Based on directions, graphs can be of two types: directed and undirected. Let''s
    review both of them briefly.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据方向，图可以分为两种类型：有向和无向。让我们简要回顾一下这两种类型。
- en: Directed graphs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向图
- en: 'In a directed graph, the edges clearly show the direction from one vertex to
    another. An edge in a directed graph is usually represented as (v1, v2), which
    means that the edge is pointing from vertex v1 toward vertex v2\. In other words,
    a (v1, v2) pair indicates that v1 is the starting vertex and v2 is the ending
    vertex. A directed graph is very useful in real-world applications and is used
    in the **World Wide Web** (**WWW**), Google''s PageRank algorithm, and more. Consider
    the following directed graph:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边清楚地显示了从一个顶点到另一个顶点的方向。有向图中的边通常表示为（v1，v2），这意味着边是从顶点v1指向顶点v2。换句话说，（v1，v2）对表示v1是起始顶点，v2是结束顶点。有向图在现实世界的应用中非常有用，并被用于**万维网**（**WWW**）、谷歌的PageRank算法等。考虑以下有向图：
- en: '![](img/a5062c4e-8e1e-4a55-96f2-713e32046883.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5062c4e-8e1e-4a55-96f2-713e32046883.png)'
- en: Figure 10.1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1
- en: 'Here, you can see an edge between vertices **a** and **b**. Because the edge
    is pointing from vertex **a** toward **b**, vertex **a** is considered to be the
    starting vertex and vertex **b** is considered the ending vertex. This edge can
    be represented as (**a**,**b**). Similarly, there is an edge from vertices **a**
    to **c**, which, in turn, can be represented as (**a**,**c**). Therefore, we can
    say that the preceding graph has the following set of vertices:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到顶点**a**和**b**之间的边。因为边是从顶点**a**指向**b**，所以顶点**a**被认为是起始顶点，顶点**b**被认为是结束顶点。这条边可以表示为（**a**，**b**）。同样，从顶点**a**到顶点**c**也存在一条边，它可以表示为（**a**，**c**）。因此，我们可以说前面的图有以下顶点集：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, the graph has the following set of edges:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该图有以下一组边：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Undirected graphs
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无向图
- en: An undirected graph is one in which the edges are present between vertices,
    but there is no specific direction identified – that is, there are no arrows at
    the end of the edges. Therefore, we cannot know which is the starting vertex and
    which one is the ending vertex. Undirected graphs are widely used in real-world
    applications such as Facebook and neural networks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图是一种在顶点之间存在边，但没有特定方向标识的图——也就是说，边的末端没有箭头。因此，我们无法知道哪个是起始顶点，哪个是结束顶点。无向图在现实世界的应用中非常广泛，例如Facebook和神经网络。
- en: 'An edge between two vertices, **a** and **b**, in an undirected graph will
    mean that either of them can be a starting or ending vertex. Such an edge can
    be written as (**a**,**b**), that is, from **a** to **b**, as well as (**b**,**a**),
    that is, from **b** to **a**. The following diagram shows an undirected graph:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图中，两个顶点**a**和**b**之间的边意味着它们中的任何一个都可以是起始顶点或结束顶点。这样的边可以写成(**a**,**b**)，即从**a**到**b**，也可以写成(**b**,**a**)，即从**b**到**a**。以下图显示了无向图：
- en: '![](img/349dc9df-61a5-4b5d-9893-77c97c494847.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/349dc9df-61a5-4b5d-9893-77c97c494847.png)'
- en: Figure 10.2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2
- en: 'So, for this undirected graph, the following is the set of vertices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个无向图，以下是一组顶点：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Additionally, the graph will have the following set of edges:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该图将包含以下一组边：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's begin with the recipes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从这些方法开始。
- en: Creating an adjacency matrix representation of a directed graph
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建有向图的邻接矩阵表示法
- en: An adjacency matrix is a square matrix that is used to represent a graph. The
    rows and columns of the matrix are labeled as per the graph vertices. So, if the
    graph vertices are **1**,**2**,...**5**, then the rows and columns of the adjacency
    matrix will be labeled as **1**,**2**,...**5**. Initially, the matrix is filled
    with all zeros (0). Then, the 0 at the `mat[i][j]` location (where `i` and `j`
    refer to the vertices) is replaced by 1 if there is an edge between the vertices
    of `i` and `j`. For example, if there is an edge from vertex **2** to vertex **3**,
    then at the `mat[2][3]` index location, the value of 0 will be replaced by **1**.
    In short, the elements of the adjacency matrix indicate whether pairs of vertices
    are adjacent or not in the graph.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵是一个用于表示图的方阵。矩阵的行和列按照图中的顶点进行标记。因此，如果图顶点是**1**、**2**、...**5**，那么邻接矩阵的行和列将标记为**1**、**2**、...**5**。最初，矩阵用所有零（0）填充。然后，如果顶点`i`和`j`之间存在边，则将`mat[i][j]`位置的0替换为1（其中`i`和`j`指的是顶点）。例如，如果从顶点**2**到顶点**3**存在边，那么在`mat[2][3]`索引位置，0的值将被替换为**1**。简而言之，邻接矩阵的元素表示图中顶点对是否相邻。
- en: 'Consider the following directed graph:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下有向图：
- en: '![](img/a3baf581-8851-47ee-9edf-036a6dc43230.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3baf581-8851-47ee-9edf-036a6dc43230.png)'
- en: Figure 10.3
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3
- en: 'Its adjacency matrix representation is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其邻接矩阵表示法如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first row and the first column represent the vertices. If there is an edge
    between two vertices, then there will be a `1` value at the intersection of their
    respective row and column. The absence of an edge between them will be represented
    by `0`. The number of nonzero elements of an adjacency matrix indicates the number
    of edges in a directed graph.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和第一列代表顶点。如果两个顶点之间存在边，则它们各自行和列的交点处将有一个`1`值。它们之间没有边的情况将用`0`表示。邻接矩阵中非零元素的数量表示有向图中边的数量。
- en: 'Here are two drawbacks of adjacency matrix representation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用邻接矩阵表示法有以下两个缺点：
- en: This representation requires *n²* elements to represent a graph having *n* vertices.
    If a directed graph has *e* edges, then (*n²-e*) elements in the matrix would
    be zeros. Therefore, for graphs with a very low number of edges, the matrix becomes
    very sparse.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种表示法需要*n²*个元素来表示具有*n*个顶点的图。如果一个有向图有*e*条边，那么矩阵中的(*n²-e*)个元素将是零。因此，对于边数非常少的图，矩阵会变得非常稀疏。
- en: Parallel edges cannot be represented by an adjacency matrix.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平行边不能由邻接矩阵表示。
- en: In this recipe, we will learn how to make an adjacency matrix representation
    of a directed graph.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将学习如何制作有向图的邻接矩阵表示法。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to create an adjacency matrix representation of
    a graph:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建图的邻接矩阵表示法：
- en: Ask the user for the number of vertices in the graph.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户图中顶点的数量。
- en: Define a square matrix that is equal to the number of vertices.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个等于顶点数的正方形矩阵。
- en: Initialize all the elements of the matrix to 0.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩阵的所有元素初始化为0。
- en: Ask the user to enter the edges. For each edge (`i`,`j`) entered by the user,
    replace 0 at the `mat[i][j]` index location.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请用户输入边。对于用户输入的每条边（`i`,`j`），在`mat[i][j]`索引位置替换0。
- en: Once all the edges are entered, display all of the elements of the adjacency
    matrix.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有边都输入完毕，显示邻接矩阵的所有元素。
- en: 'The code for creating an adjacency matrix representation of a graph is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图邻接矩阵表示的代码如下：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Assuming that the directed graphs the user will specify in this program will
    not be of more than 10 vertices, define a macro called `max` of value `10` and
    a two-dimensional matrix called `edg`, consisting of max rows and max columns.
    However, you can always increase the size of the macro if you think the user can
    specify a graph of more than 10 vertices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户将在本程序中指定的有向图不会超过10个顶点，定义一个名为`max`的宏，其值为`10`，以及一个名为`edg`的二维矩阵，由最大行数和最大列数组成。然而，如果你认为用户可以指定超过10个顶点的图，你可以始终增加宏的大小。
- en: In order to initialize all of the elements of the `edg` matrix to 0, define
    it as a static matrix. Thereafter, the user will be prompted to specify how many
    vertices there are in the graph. Suppose the user enters 5 to indicate that there
    are 5 vertices in the graph, then that value will be assigned to the `numb` variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化`edg`矩阵的所有元素为0，将其定义为静态矩阵。之后，将提示用户指定图中顶点的数量。假设用户输入5来表示图中存在5个顶点，那么这个值将被分配给`numb`变量。
- en: To make the recipe easy to understand, we assume that the vertices are sequentially
    numbered from 1 to 5\. The user is prompted to specify the edges between the vertices.
    This means that if there is an edge between vertices 1 and 3, then the user is
    supposed to enter the edge as 1,3\. The vertices entered representing these edges
    are then assigned to the vertices of v1 and v2\. Because the user is asked to
    specify the edges of the graph and to enter `0 0` when over, when the edge is
    assigned to the vertices of v1 and v2, we first ensure that the vertices are not
    0 and 0\. If they are, the program will stop asking for more edges and will branch
    to the statement from where the display of the adjacency matrix begins. If the
    vertices in the edge are not zero, then a value, 1, is assigned in the two-dimensional
    `edg` matrix at the index location of `[v1][v2]`. So, if there is an edge between
    vertices 1 and 2, then value 1 will be assigned at the `edg[1][2]` index location,
    replacing the value 0 that was initially there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使食谱易于理解，我们假设顶点按顺序编号为1到5。将提示用户指定顶点之间的边。这意味着如果顶点1和3之间存在边，则用户应输入边为1,3。表示这些边的输入顶点随后被分配给v1和v2顶点。因为用户被要求指定图的边，并在完成时输入`0
    0`，所以在将边分配给v1和v2顶点时，我们首先确保顶点不是0和0。如果是，程序将停止请求更多边，并转到显示邻接矩阵的语句。如果边的顶点不是零，则在二维`edg`矩阵的`[v1][v2]`索引位置分配一个值，1。因此，如果顶点1和2之间存在边，则将在`edg[1][2]`索引位置分配值1，替换最初那里的值0。
- en: When all the edges of the graph are entered, the user will enter the vertices
    as `0 0` to indicate that all the edges have been entered. In that case, a nested
    `for` loop is executed and all the elements of the `edg` matrix are displayed
    on screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有图的边都输入完毕后，用户将输入顶点作为`0 0`来表示所有边都已输入。在这种情况下，将执行嵌套的`for`循环，并在屏幕上显示`edg`矩阵的所有元素。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `adjmatdirect.c` program has
    successfully compiled into the `adjmatdirect.exe` file. On executing the file,
    the user will be prompted to specify the number of vertices and its edges. Once
    the vertices and edges are entered, the program will display the adjacency matrix
    representation of the graph (take a look at the following screenshot):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。因为没有错误出现在编译过程中，这意味着`adjmatdirect.c`程序已成功编译成`adjmatdirect.exe`文件。在执行文件时，将提示用户指定顶点数及其边。一旦输入了顶点和边，程序将显示图的邻接矩阵表示（请参阅下面的截图）：
- en: '![](img/0108a289-b589-44a0-8bba-4528db949081.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0108a289-b589-44a0-8bba-4528db949081.png)'
- en: Figure 10.4
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4
- en: Now, let's explore how to do the same thing for an undirected graph.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何对无向图做同样的事情。
- en: Creating an adjacency matrix representation of an undirected graph
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建无向图的邻接矩阵表示
- en: By adding one more statement in this recipe's code, the same program can be
    used for creating the adjacency matrix representation of an undirected graph as
    well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的代码中增加一条语句，就可以使用相同的程序来创建无向图的邻接矩阵表示。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We refer to the same graph that was in the previous recipe; however, this time,
    there are no edges:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们参考的是前面食谱中的相同图；然而，这次没有边：
- en: '![](img/23fcc3bf-4b99-4c22-8808-f609381d5611.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23fcc3bf-4b99-4c22-8808-f609381d5611.png)'
- en: Figure 10.5
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5
- en: 'Its adjacency matrix representation is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它的邻接矩阵表示如下：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only difference between the programs of the directed and undirected graphs
    is that, in the latter, the edge is simply repeated. That is, if there is an edge
    between a and b, then it is considered to be two edges: one from a to b and the
    other from b to a.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图和无向图的程序之间唯一的区别是，在后者中，边被简单地重复。也就是说，如果a和b之间存在边，那么它被认为是两条边：一条从a到b，另一条从b到a。
- en: 'The program for creating an adjacency matrix representation of an undirected
    graph is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建无向图邻接矩阵表示的程序如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you compare the preceding program with that of the directed graph, you
    will notice that only one extra statement has been added (marked in bold):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将前面的程序与有向图的程序进行比较时，你会注意到只增加了一条额外的语句（加粗标记）：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is, in the case of an edge from `v1` to `v2`, an edge in reverse is also
    assumed, that is, from `v2` to `v1`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在`v1`到`v2`的边的情况下，还假设了反向边，即从`v2`到`v1`。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `adjmatundirect.c` program has
    successfully compiled into the `adjmatundirect.exe` file. As expected, on running
    the file, the user will be prompted to specify the number of vertices and their
    edges. Once the number of vertices and edges are entered, the program will display
    the adjacency matrix representation of the undirected graph, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下所示截图。因为没有错误出现在编译过程中，这意味着`adjmatundirect.c`程序已成功编译成`adjmatundirect.exe`文件。正如预期的那样，运行该文件时，用户将被提示指定顶点的数量和它们的边。一旦输入了顶点的数量和边的数量，程序将显示无向图的邻接矩阵表示，如下所示截图：
- en: '![](img/e870eb0c-3c29-4a96-81a2-ba2d39eb63fe.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e870eb0c-3c29-4a96-81a2-ba2d39eb63fe.png)'
- en: Figure 10.6
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6
- en: Now, let's move on to the next recipe!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到下一个食谱！
- en: Creating an adjacency list representation of a directed graph
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建有向图的邻接表表示
- en: In an adjacency list representation, linked lists are used to represent the
    adjacent vertices of a vertex. That is, a separate linked list is made for the
    adjacent vertices of each vertex, and, in the end, all the vertices of the graph
    are connected. Because linked lists are used, this way of representing a graph
    uses memory in a more optimized manner.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在邻接表表示中，使用链表来表示顶点的相邻顶点。也就是说，为每个顶点的相邻顶点创建一个单独的链表，最后，图中所有顶点都连接起来。因为使用了链表，所以这种表示图的方式在内存使用上更加优化。
- en: 'Consider the following directed graph:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下有向图：
- en: '![](img/fcfe1d39-0202-4cff-a19a-44e462f07844.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fcfe1d39-0202-4cff-a19a-44e462f07844.png)'
- en: Figure 10.7
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7
- en: 'Its adjacency list representation is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它的邻接表表示如下：
- en: '![](img/a9282884-cdbe-41d8-a7d1-a427cd450009.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9282884-cdbe-41d8-a7d1-a427cd450009.png)'
- en: Figure 10.8
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8
- en: You can see in the preceding diagram that the adjacent vertices of vertex **1**
    are connected in the form of a linked list. Because there are no adjacent vertices
    for vertex **2**, its pointer is pointing to **NULL**. Similarly, the adjacent
    vertices of vertex **3**, that is, vertices **4** and **5**, are connected to
    vertex **3** in the form of a linked list. Once a linked list of all the vertices
    of the entire graph is created, all the vertices become connected through a link.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的图中看到，顶点**1**的相邻顶点以链表的形式连接。因为顶点**2**没有相邻顶点，所以它的指针指向**NULL**。同样，顶点**3**的相邻顶点，即顶点**4**和**5**，以链表的形式连接到顶点**3**。一旦创建了整个图的顶点的所有链表，所有顶点都通过链接连接起来。
- en: In this recipe, we will learn how to create the adjacency list representation
    of a directed graph.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何创建有向图的邻接表表示。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to create an adjacency list representation of a graph:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建图的邻接表表示：
- en: Define a structure called `node` that contains three members. One member, `nme`,
    is for storing the vertex of the graph; another member, `vrt`, is for connecting
    vertices of the graph; and, finally, `edg` is for connecting the adjacent vertices
    of the vertex.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`node`的结构，它包含三个成员。一个成员`nme`用于存储图的顶点；另一个成员`vrt`用于连接图的顶点；最后，`edg`用于连接顶点的相邻顶点。
- en: The user is asked to specify the count of the vertices in the graph.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户指定图中顶点的数量。
- en: A linked list is created where the `nme` member of each node contains the vertex
    of the graph.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个链表，其中每个节点的`nme`成员包含图的顶点。
- en: All the nodes representing vertices of the graph are connected to each other
    using the `vrt` pointer.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vrt`指针将表示图中顶点的所有节点相互连接。
- en: Once all the vertices are entered, the user is prompted to enter the edges of
    the graph. The user can enter any number of edges and to indicate that all the
    edges are entered, the user can enter `0 0` for the edge.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦输入所有顶点，用户将被提示输入图的边。用户可以输入任意数量的边，并且为了表示所有边都已输入，用户可以输入`0 0`作为边。
- en: When an edge is entered, for example, `b`, a `temp1` pointer is used and is
    set to point to vertex `a`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当进入一个边，例如，`b`，使用一个`temp1`指针，并将其设置为指向顶点`a`。
- en: A new node is created called `newNode`, and the vertex name `b` is assigned
    to the `nme` member of `newNode`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的节点称为`newNode`，并将顶点名称`b`分配给`newNode`的`nme`成员。
- en: One more pointer is used, called `temp2`, and is set to point to the last node
    that is connected to vertex `a`. Once `temp2` reaches the end of vertex `a`, the
    `edg` member of the `temp2` node is set to point to `newNode`, and hence establishing
    an edge between `a` and `b`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一个指针，称为`temp2`，并将其设置为指向连接到顶点`a`的最后一个节点。一旦`temp2`到达顶点`a`的末尾，`temp2`节点的`edg`成员被设置为指向`newNode`，从而在`a`和`b`之间建立一条边。
- en: 'The program for creating the adjacency list representation of a directed graph
    is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有向图的邻接表表示的程序如下：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以更好地理解它。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s assume we are working with the following directed graph:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理以下有向图：
- en: '![](img/555ca202-5a0e-491e-97f8-b069cbaeddd8.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/555ca202-5a0e-491e-97f8-b069cbaeddd8.png)'
- en: Figure 10.9
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9
- en: 'The adjacency list representation of this graph is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该图的邻接表表示如下：
- en: '![](img/908066b7-5c0f-4b4b-8aaa-54f7933bfa76.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/908066b7-5c0f-4b4b-8aaa-54f7933bfa76.png)'
- en: Figure 10.10
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10
- en: 'We define a structure called "node" comprising the following three members:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个名为“node”的结构，包含以下三个成员：
- en: '`nme`: This is for storing the vertex.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nme`：这是用于存储顶点。'
- en: '`vrt`: A pointer to connect all the vertices of the graph.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vrt`：一个指向连接图中所有顶点的指针。'
- en: '`edg`: A pointer that connects all the vertices that are connected to the current
    vertex:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edg`：一个连接当前顶点所连接的所有顶点的指针：'
- en: '![](img/256393a7-3cbe-400f-9ecc-85b6f50aa46c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/256393a7-3cbe-400f-9ecc-85b6f50aa46c.png)'
- en: Figure 10.11
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11
- en: The user is prompted to specify the number of vertices. Assuming the user enters
    the value of 5, the value of 5 will be assigned to the `numb` variable. A `startList`
    pointer is defined as `NULL`. The whole adjacency list will be accessed through
    this `startList` pointer and it will be set to point to the first vertex of the
    graph. The user is first asked to enter the names of the vertices.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被提示指定顶点的数量。假设用户输入值为5，则5的值将被分配给`numb`变量。定义一个`startList`指针为`NULL`。整个邻接表将通过这个`startList`指针访问，并且它将被设置为指向图的第一个顶点。首先，用户被要求输入顶点的名称。
- en: 'Initially, the `startList` pointer is `NULL`, so a new node called `newNode`
    is created and the vertex name, say `a`, entered by the user is assigned to the
    `nme` member of `newNode`. The `startList` pointer is set to point to `newNode`.
    To connect more vertices with `newNode`, the `temp1` pointer is set to point to `newNode`.
    Initially, both the pointers, `vrt` and `edg`, are also set to `NULL`. Later,
    the `vrt` pointer will be set to point to other vertices and the `edg` pointer
    will be set to point to the vertices in which this current vertex is connected
    to. After the first iteration of the `for` loop, the node of the graph will look
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`startList`指针为`NULL`，因此创建了一个新节点`newNode`，并将用户输入的顶点名称，例如`a`，分配给`newNode`的`nme`成员。`startList`指针被设置为指向`newNode`。为了使用`newNode`连接更多顶点，将`temp1`指针设置为指向`newNode`。最初，两个指针`vrt`和`edg`也都设置为`NULL`。在`for`循环的第一次迭代之后，图中的节点将如下所示：
- en: '![](img/c2d8f1c3-3240-490c-9c6a-34c34e92ec21.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2d8f1c3-3240-490c-9c6a-34c34e92ec21.png)'
- en: Figure 10.12
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12
- en: 'In the second iteration of the `for` loop, because the `startList` pointer
    is no longer `NULL`, the `else` block will execute and, again, a new node is created,
    called `newNode`. Next, the vertex name is assigned to the named member of the
    `newNode`. Again, the `vrt` and `edg` pointers of `newNode` are set to `NULL`.
    To connect `newNode` to the earlier vertex, we will take the help of the `temp1`
    pointer. The `vrt` pointer of the node, which is pointed to by the `temp1` pointer,
    is set to point to `newNode`, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的第二次迭代中，因为`startList`指针不再为`NULL`，将执行`else`块，并再次创建一个新节点，称为`newNode`。接下来，将顶点名称分配给`newNode`的命名成员。再次，将`newNode`的`vrt`和`edg`指针设置为`NULL`。为了将`newNode`连接到前面的顶点，我们将借助`temp1`指针。将`temp1`指针指向的节点的`vrt`指针设置为指向`newNode`，如下所示：
- en: '![](img/879493c2-998a-4f4d-97ae-6d741419e422.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/879493c2-998a-4f4d-97ae-6d741419e422.png)'
- en: Figure 10.13
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13
- en: 'Then, the `temp1` pointer is set to point to `newNode`, and the process is
    repeated for the rest of the vertices. Essentially, the `temp1` pointer is used
    for connecting more vertices. At the end of the `for` loop, the nodes will appear
    connected as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`temp1`指针设置为指向`newNode`，并对其余顶点重复此过程。本质上，`temp1`指针用于连接更多顶点。在`for`循环结束时，节点将如下所示连接：
- en: '![](img/22e98e49-d848-47c9-89d1-804949f6a2fb.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22e98e49-d848-47c9-89d1-804949f6a2fb.png)'
- en: Figure 10.14
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14
- en: Once all the vertices of the graphs are entered, the user is asked to specify
    the edges between the vertices. Additionally, the user is asked to enter `0 0`
    when all the edges of the graph are entered. Suppose that the user enters `a b`
    to indicate there is an edge from vertex `a` to vertex `b`. The vertices are assigned
    to the `v1` and `v2` variables, respectively. We first ensure that the data in
    `v1` and `v2` is not 0\. If yes, that means all the edges of the graph are entered
    and the program will jump to the statement from where the display of the adjacency
    list begins.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有图的顶点都输入完毕，用户将被要求指定顶点之间的边。此外，当所有图的边都输入完毕时，用户需要输入`0 0`。假设用户输入`a b`来表示从顶点`a`到顶点`b`存在一条边。顶点分别被分配给`v1`和`v2`变量。我们首先确保`v1`和`v2`中的数据不是0。如果是，这意味着所有图的边都已输入，程序将跳转到显示邻接表开始的语句。
- en: 'Then, to connect the `a` and `b` vertices, first, the `temp1` pointer is set
    to point to `startList`. The `temp1` pointer is set to find the node whose `nme`
    member is equal to the vertex entered in variable `v1`, that is, `a`. The `temp1`
    pointer is already pointing to vertex `a`. Thereafter, you need to find the last
    node that is connected to `temp1`. The `temp2` pointer is used for finding the
    last node connected to the node pointed to by `temp1`. Because this is the first
    edge being entered of vertex `a`, the `edg` member of the node pointed to by `temp2`
    is already `NULL`. So, a new node is created called `newNode`, and the vertex
    name in variable `v2`, that is, `b` is assigned to the `nme` variable of `newNode`.
    The `edg` and `vrt` members of `newNode` are set to `NULL`, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了连接顶点`a`和`b`，首先，将`temp1`指针设置为指向`startList`。`temp1`指针被设置为找到其`nme`成员等于变量`v1`中输入的顶点的节点，即`a`。`temp1`指针已经指向顶点`a`。之后，你需要找到与`temp1`连接的最后一个节点。`temp2`指针用于找到由`temp1`指针指向的节点的最后一个连接节点。因为这是顶点`a`的第一个输入边，所以`temp2`指针指向的节点的`edg`成员已经是`NULL`。因此，创建一个新的节点称为`newNode`，并将变量`v2`中的顶点名称，即`b`，分配给`newNode`的`nme`变量。`newNode`的`edg`和`vrt`成员被设置为`NULL`，如下所示：
- en: '![](img/66abaa9d-3396-47a0-a427-035b56e28639.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66abaa9d-3396-47a0-a427-035b56e28639.png)'
- en: Figure 10.15
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15
- en: 'The `edg` member of `temp2` is set to point to `newNode` as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将`temp2`的`edg`成员设置为指向`newNode`，如下所示：
- en: '![](img/42b65eb4-af47-4abc-97ec-d3a6f0f27cbf.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42b65eb4-af47-4abc-97ec-d3a6f0f27cbf.png)'
- en: Figure 10.16
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16
- en: The procedure is repeated for the rest of the edges entered by the user.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程会重复应用于用户输入的其余边。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `adjlistdirect.c` program has
    successfully compiled into the `adjlistdirect.exe` file. On executing the executable
    file, the user will be prompted to specify the number of vertices and their edges.
    Once the vertices and edges are entered, the program will display the adjacency
    list representation of the directed graph, as shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下所示。因为没有错误出现在编译过程中，这意味着`adjlistdirect.c`程序已成功编译成`adjlistdirect.exe`文件。在执行可执行文件时，用户将被提示指定顶点的数量及其边。一旦输入了顶点和边，程序将显示有向图的邻接表表示，如下所示截图：
- en: '![](img/1b880d52-cd82-4e36-aa24-4ed14c6d2226.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b880d52-cd82-4e36-aa24-4ed14c6d2226.png)'
- en: Figure 10.17
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17
- en: Now, let's move on to the next recipe!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Carrying out the breadth-first traversal of a graph
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行图的广度优先遍历
- en: The traversal of a graph refers to when you visit each of the vertices of a
    graph exactly once in a well-defined order. To ensure that each vertex of the
    graph is visited only once and to know which vertices have already been visited,
    the best way is to mark them. We will also look at how vertices are marked in
    this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图的遍历是指按照一个良好的定义顺序访问图的每个顶点正好一次。为了确保图中的每个顶点只被访问一次，并知道哪些顶点已经被访问，最好的方法是标记它们。我们还将在此菜谱中查看如何标记顶点。
- en: Breadth-first traversal tends to create very short and wide trees. It operates
    by vertices in layers, that is, the vertices closest to the start are evaluated
    first, and the most distant vertices are evaluated last. Hence, it is referred
    to as the level-by-level traversal of the tree. The breadth-first traversal of
    a graph is very popularly used for finding the shortest path between two locations
    (vertices), that is, the path with the least number of edges. It is also used
    to find the linked pages of a web page, broadcasting information, and more.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先遍历倾向于创建非常短而宽的树。它通过层来操作顶点，即首先评估离起始点最近的顶点，最后评估最远的顶点。因此，它被称为树的层遍历。图的广度优先遍历在寻找两个位置（顶点）之间的最短路径（即边数最少的路径）方面非常流行。它也用于查找网页的链接页面、广播信息等。
- en: In this recipe, we will learn how to carry out the breadth-first traversal of
    a graph.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何执行图的广度优先遍历。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to carry out the breadth-first traversal of a graph:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行图的广度优先遍历：
- en: Add the first vertex of the graph into the queue. Any vertex can be chosen as
    a starting vertex.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图的第一顶点添加到队列中。任何顶点都可以作为起始顶点。
- en: Then, repeat the following *steps 3* to *8* until the queue is empty.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重复以下*步骤3*到*8*，直到队列为空。
- en: Take out the vertex from the queue and store it in a variable, say `v`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从队列中取出顶点并将其存储在一个变量中，例如 `v`。
- en: Mark it as visited (the marking is done so that this vertex should not be traversed
    again).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其标记为已访问（标记是为了确保这个顶点不应再次被遍历）。
- en: Display the marked vertex.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示标记的顶点。
- en: Find out the adjacency vertices of the vertex `v`, and then perform *steps 7*
    to *8* on each of them.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出顶点 `v` 的相邻顶点，然后对每个顶点执行 *步骤 7* 到 *8*。
- en: If any of the adjacency vertices of `v` are not marked, mark it as visited.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `v` 的任何相邻顶点未被标记，则将其标记为已访问。
- en: Add the adjacency vertex to the queue.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相邻顶点添加到队列中。
- en: Exit.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出。
- en: 'The program for the breadth-first traversal of a graph is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图的广度优先遍历程序如下：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We are using the adjacency list representation of the directed graph from the
    previous recipe, *Creating an adjacency list representation of a directed graph*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用之前菜谱中创建的邻接表表示的有向图，*创建有向图的邻接表表示*：
- en: '![](img/1c4d94a8-b74d-4637-b21f-172779bab61c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c4d94a8-b74d-4637-b21f-172779bab61c.png)'
- en: Figure 10.18
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18
- en: 'The `temp1` pointer is set to point to `startList`. That is, `temp1` is pointing
    to the node with vertex `a`. If `temp1` is not `NULL`, the node pointed to by
    the `temp1` pointer is added to the queue. The rear variable, which is -1 at the
    moment, is incremented to 0 and the `a` node is added to the array of `que` nodes at
    index location `0`. Because the value of the front index location is -1 currently,
    the front is also set to 0, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`temp1` 指针被设置为指向 `startList`。也就是说，`temp1` 正在指向具有顶点 `a` 的节点。如果 `temp1` 不是 `NULL`，则由
    `temp1` 指针指向的节点被添加到队列中。当前为 -1 的尾变量被增加到 0，并将 `a` 节点添加到 `que` 节点数组中的索引位置 `0`。因为当前前索引位置值为
    -1，所以前指针也被设置为 0，如下所示：'
- en: '![](img/b33f87ad-50e3-4754-8199-16b074cef499.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b33f87ad-50e3-4754-8199-16b074cef499.png)'
- en: Figure 10.19
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19
- en: Thereafter, the dequeue function is invoked to remove a node from the queue.
    Unsurprisingly, the node at the `que[0]` index location, that is, `a`, is returned
    and, because the values of **front** and **rear** are the same, the values of
    the **front** and **rear** indices are set to -1, to indicate that the queue is
    empty again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，调用 dequeue 函数从队列中删除一个节点。不出所料，`que[0]` 索引位置的节点，即 `a`，被返回，因为 **front** 和 **rear**
    的值相同，所以 **front** 和 **rear** 索引的值被设置为 -1，以指示队列再次为空。
- en: The node containing vertex `a` is returned from the queue and is assigned to
    the `temp3` pointer. The `temp1` pointer is set to point to the `startList` pointer.
    The marked member of the `temp3` node, that is, vertex `a`, is set to `N` initially.
    The vertex name stored in the `nme` member of the node is displayed, that is,
    vertex `a` is displayed on screen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 包含顶点 `a` 的节点从队列中返回，并分配给 `temp3` 指针。`temp1` 指针被设置为指向 `startList` 指针。`temp3` 节点的标记成员，即顶点
    `a`，最初被设置为 `N`。节点中存储在 `nme` 成员中的顶点名称被显示，即顶点 `a` 在屏幕上显示。
- en: 'After displaying vertex `a`, its marked member is set to `Y` to indicate that
    the node is visited and should not be traversed again. The next step is to find
    the adjacent vertices of vertex `a`. To do so, the `temp2` pointer is set to point
    to where the `edg` pointer of `temp3` is pointing. The `edg` pointer of `temp3`
    is pointing at vertex `b`, so `temp2` is set to point at vertex `b`. Again, the
    procedure is repeated. If `temp2` is not `NULL`, the `b` node is queued, that
    is, it is added to the `que[0]` index location. Because all of the nodes that
    are connected to vertex `a` have to be queued, the `temp2` pointer is set to point
    to the location where its `edg` pointer is pointing. The `edg` pointer of node
    `b` (in the adjacency list) is pointing to node `c`, so node `c` is also inserted
    into the queue at the `que[1]` index location as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示顶点 `a` 后，其标记成员被设置为 `Y` 以指示节点已被访问且不应再次遍历。下一步是找到顶点 `a` 的相邻顶点。为此，将 `temp2` 指针设置为指向
    `temp3` 的 `edg` 指针所指向的位置。`temp3` 的 `edg` 指针指向顶点 `b`，因此 `temp2` 被设置为指向顶点 `b`。再次重复该过程。如果
    `temp2` 不是 `NULL`，则 `b` 节点被排队，即被添加到 `que[0]` 索引位置。因为所有连接到顶点 `a` 的节点都必须排队，所以 `temp2`
    指针被设置为指向其 `edg` 指针所指向的位置。节点 `b`（在邻接表中）的 `edg` 指针指向节点 `c`，因此节点 `c` 也被插入到队列中的 `que[1]`
    索引位置，如下所示：
- en: '![](img/20e1aa1d-add2-48e9-b146-f0e7da5c9efd.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20e1aa1d-add2-48e9-b146-f0e7da5c9efd.png)'
- en: Figure 10.20
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20
- en: In the queue, nodes `b` and `c` are present. Now, again, the dequeue function
    is invoked; node `b` is removed from the queue and the `temp3` pointer is set
    to point to it. The `temp1` pointer is initially set to point to `startList` and,
    thereafter, by making use of its `vrt` pointer, the `temp1` pointer is set to
    point to vertex `b`. Because the marked member of node `b` is `N`, its vertex
    name, `b`, is displayed on screen followed by setting its marked member to `Y`.
    A `temp2` pointer is set to point to where the `edg` member of node `b` is pointing.
    The `edg` member of node `b` is pointing to `NULL`, so the next node in the queue
    is accessed, that is, node `c` is removed from the queue and the `temp3` pointer
    is set to point to it. Because the queue is again empty, the values of the `front`
    and `rear` variables are set to -1.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中，节点 `b` 和 `c` 存在。现在，再次调用出队函数；从队列中移除节点 `b`，并将 `temp3` 指针设置为指向它。`temp1` 指针最初设置为指向
    `startList`，然后通过使用其 `vrt` 指针，将 `temp1` 指针设置为指向顶点 `b`。因为节点 `b` 的标记成员是 `N`，其顶点名称
    `b` 显示在屏幕上，随后将其标记成员设置为 `Y`。将 `temp2` 指针设置为指向节点 `b` 的 `edg` 成员所指向的位置。节点 `b` 的 `edg`
    成员指向 `NULL`，因此访问队列中的下一个节点，即从队列中移除节点 `c` 并将 `temp3` 指针设置为指向它。因为队列再次为空，所以将 `front`
    和 `rear` 变量的值设置为 -1。
- en: 'Again, the `temp1` pointer is set to point at vertex `c`, and the `c` node is
    displayed on screen, that is, it is traversed and its marked member is set to
    `Y`. So, up until now, nodes `a`, `b`, and `c` are displayed on screen. And the
    node that is attached to the `edg` member of `c` is added to the queue, that is,
    node `d` is added to the queue at the `que[0]` index location. Additionally, the
    node pointed to by the `edg` pointer of node `d` is accessed, that is, node `e` is
    also queued or, in other words, added at the `que[1]` index location as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，将 `temp1` 指针设置为指向顶点 `c`，并在屏幕上显示 `c` 节点，即遍历它并设置其标记成员为 `Y`。因此，到目前为止，节点 `a`、`b`
    和 `c` 已在屏幕上显示。将连接到 `c` 的 `edg` 成员的节点添加到队列中，即节点 `d` 被添加到队列的 `que[0]` 索引位置。此外，访问节点
    `d` 的 `edg` 指针所指向的节点，即节点 `e` 也被排队或换句话说，添加到 `que[1]` 索引位置如下：
- en: '![](img/c44d849e-75b0-467d-9350-d19cd652d4df.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c44d849e-75b0-467d-9350-d19cd652d4df.png)'
- en: Figure 10.21
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21
- en: Node `d` is removed from the queue and displayed (traversed). The nodes pointed
    to by their `edg` member are accessed and, if any of them is marked, then `N`
    is added to the queue. The whole procedure is repeated until the queue becomes
    empty. The sequence in which the vertices are displayed on screen forms the breadth-first
    traversal of the graph.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中移除节点 `d` 并显示（遍历）。访问它们 `edg` 成员所指向的节点，如果其中任何一个被标记，则将 `N` 添加到队列中。整个过程重复进行，直到队列为空。在屏幕上显示顶点的顺序形成图的广度优先遍历。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `breadthfirsttrav.c` program has
    successfully compiled into the `breadthfirsttrav.exe` file. On executing the file,
    the user will be prompted to specify the count of vertices in the graph, followed
    by entering the vertices'' names. Thereafter, the user is asked to enter the edges
    of the graph and to enter `0 0` when completed. After the edges of the graph have
    been entered, the adjacency list representation of the graph will be displayed,
    followed by the breadth-first traversal of the graph, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 GCC 编译，如以下截图所示。因为在编译过程中没有出现错误，这意味着 `breadthfirsttrav.c` 程序已成功编译成 `breadthfirsttrav.exe`
    文件。执行文件时，用户将被提示指定图中的顶点数量，然后输入顶点名称。之后，用户被要求输入图的边，并在完成后输入 `0 0`。输入图的边后，将显示图的邻接表表示，然后显示图的广度优先遍历，如以下截图所示：
- en: '![](img/a9a64beb-e5b1-4991-8b86-cda91f9a5c98.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9a64beb-e5b1-4991-8b86-cda91f9a5c98.png)'
- en: Figure 10.22
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22
- en: Now, let's move on to the next recipe!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Carrying out the depth-first traversal of a graph
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行图的深度优先遍历
- en: In depth-first traversal (also called depth-first search), all nodes of a graph are
    visited by taking a path and going as deep as possible down that path. On reaching
    the end, you go back, pick up another path, and then repeat the process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度优先遍历（也称为深度优先搜索）中，通过取一条路径并尽可能深入地沿着该路径遍历，访问图中的所有节点。到达末端后，返回，选择另一条路径，然后重复该过程。
- en: In this recipe, we will learn how to carry out the depth-first traversal of
    the graph.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何执行图的深度优先遍历。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps for the depth-first traversal of a graph:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤进行图的深度优先遍历：
- en: Push the first vertex of the graph into the stack. You can choose any vertex
    of the graph as the starting vertex.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图的第一个顶点推入栈中。您可以选择图的任何顶点作为起始顶点。
- en: Then, repeat the following *steps 3* to *7* until the stack is empty.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重复以下*步骤3*到*7*，直到栈为空。
- en: Pop the vertex from the stack and call it by any name, say, `v`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从栈中弹出顶点并按任何名称调用它，例如，`v`。
- en: Mark the popped vertex as visited. This marking is done so that this vertex
    should not be traversed again.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出的顶点标记为已访问。这种标记是为了确保该顶点不应再次遍历。
- en: Display the marked vertex.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示标记的顶点。
- en: Find out the adjacency vertices of the `v` vertex, and then perform *step 7*
    on each of them.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出`v`顶点的邻接顶点，然后对每个顶点执行*步骤7*。
- en: If any of the adjacency vertices of `v` are not marked, mark them as visited
    and push them on to the stack.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`v`的任何邻接顶点未标记，则将其标记为已访问并将它们推入栈中。
- en: Exit.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出。
- en: 'The program for the depth-first traversal of a graph is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图的深度优先遍历程序如下：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We are using the adjacency list representation of the directed graph from the
    previous recipe, *Creating an adjacency list representation of a directed graph*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用从上一个菜谱中创建的**有向图的邻接表表示**：
- en: '![](img/7b647493-abe4-4f75-ae85-9c4d161e9069.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b647493-abe4-4f75-ae85-9c4d161e9069.png)'
- en: Figure 10.23
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23
- en: 'The `temp1` pointer is set to point to `startList`, that is, at node `a`, which
    we have assumed as the starting vertex of the graph. We then ensure that if `temp1`
    is not `NULL`, then the node pointed to by the `temp1` pointer is pushed to the
    stack. The value of `top`, which is initially -1, is incremented to 0 and node
    `a` is added to the array of the nodes stack at index location **0**, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将`temp1`指针设置为指向`startList`，即节点`a`，我们假设它是图的起始顶点。然后我们确保如果`temp1`不是`NULL`，则`temp1`指针指向的节点被推入栈中。初始值为-1的`top`值增加到0，节点`a`被添加到节点栈的索引位置**0**，如下所示：
- en: '![](img/33f8dbd6-9d25-46ba-a115-a37ab55a1701.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33f8dbd6-9d25-46ba-a115-a37ab55a1701.png)'
- en: Figure 10.24
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24
- en: Thereafter, the `pop` function is invoked to remove the node from the stack.
    The node at the `stack[0]` index location is returned and the value of `top` is
    again decremented to -1.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，调用`pop`函数从栈中删除节点。返回`stack[0]`索引位置的节点，并将`top`的值再次减少到-1。
- en: 'The node containing vertex `a` is returned to the `temp3` pointer. The `temp1`
    pointer is set to point to the `startList` pointer. The marked member of the `temp3`
    node, that is, vertex `a`, is set to `N` initially. The vertex name stored in
    the `nme` member of the node is displayed, that is, vertex `a`, is displayed on
    screen. After displaying vertex `a`, its marked member is set to `Y` to indicate
    that the node is visited and should not be traversed again. The `temp2` pointer is
    set to point to where the `edg` pointer of `temp3` is pointing. The `edg` pointer
    of `temp3` is pointing to vertex `b`, so `temp2` is set to point to vertex `b`.
    Again, the procedure is repeated, that is, we check whether `temp2` is not `NULL`,
    and then node `b` is pushed to the stack at the `stack[0]` index location. Because
    all of the nodes that are connected to vertex `a` have to be pushed to the stack,
    the `temp2` pointer is set to point to the location that its `edg` pointer is
    pointing to. The `edg` pointer of node `b` (in the adjacency list) is pointing
    to node `c`, so node `c` is also pushed to the stack at the `stack[1]` index location,
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 包含顶点`a`的节点被返回到`temp3`指针。将`temp1`指针设置为指向`startList`指针。`temp3`节点的标记成员，即顶点`a`，最初设置为`N`。节点中存储的顶点名称`nme`成员被显示，即顶点`a`被显示在屏幕上。显示顶点`a`后，其标记成员被设置为`Y`以指示该节点已被访问且不应再次遍历。将`temp2`指针设置为指向`temp3`的`edg`指针指向的位置。`temp3`的`edg`指针指向顶点`b`，因此`temp2`被设置为指向顶点`b`。再次重复该过程，即我们检查`temp2`是否不是`NULL`，然后将节点`b`推入栈的`stack[0]`索引位置。因为所有连接到顶点`a`的节点都必须推入栈中，所以将`temp2`指针设置为指向其`edg`指针指向的位置。节点`b`（在邻接表中）的`edg`指针指向节点`c`，因此节点`c`也被推入栈的`stack[1]`索引位置，如下所示：
- en: '![](img/eea4b1f6-f2e8-4c38-92e6-0441a041ad3c.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eea4b1f6-f2e8-4c38-92e6-0441a041ad3c.png)'
- en: Figure 10.25
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25
- en: In the stack, nodes `b` and `c` are present. Now, again, the `pop` function
    is invoked, and the node, `c`, is popped from the stack and the `temp3` pointer
    is set to point to it. The `temp1` pointer is initially set to point to `startList`
    and, thereafter, by making use of its `vrt` pointer, the `temp1` pointer is set
    to point to vertex `c`. Because the marked member of node `c` is *N*, its vertex
    name, `c`, is displayed on screen and its marked member is set to `Y`. So, up
    until now, nodes `a` and `c` are displayed on screen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈中，存在节点 `b` 和 `c`。现在，再次调用 `pop` 函数，从栈中弹出节点 `c`，并将 `temp3` 指针设置为指向它。`temp1`
    指针最初设置为指向 `startList`，然后通过使用其 `vrt` 指针，将 `temp1` 指针设置为指向顶点 `c`。因为节点 `c` 的标记成员是
    *N*，所以其顶点名称 `c` 在屏幕上显示，并将其标记成员设置为 `Y`。因此，到目前为止，节点 `a` 和 `c` 已在屏幕上显示。
- en: 'A `temp2` pointer is set to point to where the `edg` member of node `c` is
    pointing. The `edg` member of node `c` is pointing to node `d`, so the `d` node is
    pushed to the stack and the next adjacent node of `c` is accessed. The next adjacent
    node of node `c` is node `e`, which is also pushed to the stack as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `temp2` 指针设置为指向节点 `c` 的 `edg` 成员所指向的位置。节点 `c` 的 `edg` 成员指向节点 `d`，因此将节点 `d`
    推入栈中，并访问节点 `c` 的下一个相邻节点。节点 `c` 的下一个相邻节点是节点 `e`，它也被按如下方式推入栈中：
- en: '![](img/74775bfa-0ce9-4bea-9daf-c4b00b786233.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74775bfa-0ce9-4bea-9daf-c4b00b786233.png)'
- en: Figure 10.26
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26
- en: 'Again, the topmost node from the stack, node `e`, is popped, and the `temp3`
    pointer is set to point to it. Again, the `temp1` pointer is set to point to vertex
    `e`, and node `e` is displayed on screen, that is, it is traversed. Then, its
    marked member is set to `Y`, and the node that is attached to the `edg` member
    of `e` is pushed to the stack, that is, node `a` is pushed to the stack, followed
    by node `b`, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从栈中弹出的最顶层节点是节点 `e`，将 `temp3` 指针设置为指向它。再次，将 `temp1` 指针设置为指向顶点 `e`，并在屏幕上显示节点
    `e`，即进行遍历。然后，将其标记成员设置为 `Y`，并将连接到 `e` 的 `edg` 成员的节点推入栈中，即节点 `a` 被推入栈中，随后是节点 `b`，如下所示：
- en: '![](img/644d22ba-f55e-42ad-bf63-44aa20e7507f.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/644d22ba-f55e-42ad-bf63-44aa20e7507f.png)'
- en: Figure 10.27
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27
- en: 'Node `b` is popped and the `temp3` pointer is set to point to it. The `temp1`
    pointer is set to point to node `b`. Because the marked member of node `b` is
    `N`, stating that it is not yet traversed, vertex `b` is displayed on screen and
    its marked member is set to `Y`. Since there is no adjacent member of vertex `b`,
    the next node, `a`, in the stack is popped. Because vertex `a` has already been
    visited, the next node from the stack is popped: node `d`. The procedure is repeated,
    and the sequence of vertices displayed is considered as the depth-traversal of
    the graph.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出节点 `b`，并将 `temp3` 指针设置为指向它。将 `temp1` 指针设置为指向节点 `b`。因为节点 `b` 的标记成员是 `N`，表示它尚未被遍历，所以在屏幕上显示顶点
    `b` 并将其标记成员设置为 `Y`。由于顶点 `b` 没有相邻成员，栈中的下一个节点 `a` 被弹出。因为顶点 `a` 已经被访问，所以从栈中弹出的下一个节点是节点
    `d`。重复此过程，显示的顶点序列被认为是图的深度遍历。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during the compilation, this means the `depthfirsttrav.c` program has
    successfully compiled into the `depthfirsttrav.exe` file. On executing the file,
    the user will be prompted to specify the count of vertices in the graph, followed
    by entering the vertices'' names. Thereafter, the user is asked to enter the edges
    of the graph and enter `0 0` when completed. After the edges of the graph are
    entered, the adjacency list representation of the graph will be displayed, followed
    by the depth-first traversal of the graph, as shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 GCC 编译，如下截图所示。因为没有在编译过程中出现错误，这意味着 `depthfirsttrav.c` 程序已成功编译成 `depthfirsttrav.exe`
    文件。执行该文件时，用户将被提示指定图中顶点的数量，然后输入顶点的名称。之后，用户被要求输入图的边，完成输入后输入 `0 0`。输入图的边后，将显示图的邻接表表示，然后是图的深度优先遍历，如下截图所示：
- en: '![](img/795862d3-4917-42cd-94e8-e6245c4d90a6.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/795862d3-4917-42cd-94e8-e6245c4d90a6.png)'
- en: Figure 10.28
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28
- en: Now, let's move on to the next recipe!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Creating minimum spanning trees using Prim's algorithm
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prim 算法创建最小生成树
- en: In this recipe, we will learn how to create a minimum spanning tree. A minimum
    spanning tree of a graph with *n* number of nodes will have *n* nodes. In a connected
    weighted graph, each edge of the graph is assigned a non-negative number called
    the "weight of the edge." Then, any spanning tree of the graph is assigned a total
    weight obtained by adding the weights of the edges in the tree. A minimum spanning
    tree of a graph is a spanning tree whose total weight is as small as possible.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建最小生成树。具有*n*个节点的图的 minimum spanning tree 将有*n*个节点。在一个加权连通图中，每个图的边被分配一个非负数，称为“边的权重”。然后，将图中的任何生成树分配一个通过将树中边的权重相加得到的总权重。一个图的
    minimum spanning tree 是一个总权重尽可能小的生成树。
- en: There are a number of techniques that you can use to create a minimum spanning
    tree for a weighted graph. One of these methods is called Prim's algorithm.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种技术可以用来为加权图创建最小生成树。其中一种方法称为Prim算法。
- en: Prim's algorithm is part of the category of greedy algorithms, where vertices
    are connected with edges that have the lowest weights. An arbitrary node is chosen
    initially as the tree root. In an undirected graph, any node can be considered
    as the tree root and the nodes adjacent to it as its children. The nodes of the
    graph are then appended to the tree, one at a time, until all of the nodes of
    the graph are included. The node of the graph added to the tree at each point
    is adjacent to a node of the tree by an arc of minimum weight. The arc of minimum
    weight becomes a tree arc connecting this new node to the tree. When all the nodes
    of the graph have been added to the tree, a minimum spanning tree is said to be
    made for the graph.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Prim算法是贪心算法类别的一部分，其中顶点通过具有最低权重的边连接。最初选择一个任意节点作为树的根节点。在无向图中，任何节点都可以被认为是树的根节点，与其相邻的节点作为其子节点。然后，将图中的节点逐个添加到树中，直到包含图中的所有节点。在每次添加到树中的图节点都是通过最小权重的弧与树的节点相邻。最小权重的弧成为连接新节点到树的树弧。当图中的所有节点都已添加到树中时，可以说已经为图创建了一个最小生成树。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement Prim''s algorithm:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现Prim算法：
- en: Choose any vertex from the graph as the root of the minimum spanning tree. It
    can be any random vertex.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图中选择任何顶点作为最小生成树的根。它可以是一个任意顶点。
- en: Find all of the edges from the vertex (or vertices in the tree) to other vertices
    in the graph. From those vertices, choose the vertex that has the edge with the
    minimum weight and add that vertex to the tree.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶点（或树中的顶点）找到到图中其他顶点的所有边。从那些顶点中，选择具有最小权重的边，并将该顶点添加到树中。
- en: Repeat *step 2* until all the vertices of the graph are added to the minimum
    spanning tree.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 2*，直到将图中的所有顶点添加到最小生成树中。
- en: 'Consider the following weighted graph:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下加权图：
- en: '![](img/1b0c7bf8-8cc4-42ca-b881-c5fb106e5356.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b0c7bf8-8cc4-42ca-b881-c5fb106e5356.png)'
- en: Figure 10.29
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29
- en: 'Now, to get the minimum spanning tree of this graph, we connect the vertices
    starting from vertex `a` (you can consider any vertex as the starting vertex of
    the graph). From the starting vertex, choose the nearest vertex having the lowest
    weight, and then repeat the procedure until all of the vertices are connected.
    In that way, we get the minimum spanning tree as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了得到这个图的最小生成树，我们从顶点`a`（你可以将任何顶点视为图的起始顶点）开始连接顶点。从起始顶点开始，选择具有最低权重的最近顶点，然后重复此过程，直到所有顶点都连接起来。这样，我们得到以下最小生成树：
- en: '![](img/524adce9-751f-4e6f-a5b8-5a0f23a813a0.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/524adce9-751f-4e6f-a5b8-5a0f23a813a0.png)'
- en: Figure 10.30
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30
- en: The preceding graph is called a tree because it is acyclic; it is called spanning
    because it covers every vertex.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图被称为树，因为它是无环的；它被称为生成树，因为它覆盖了每个顶点。
- en: The number of edges in a minimum spanning tree is *v-1*, where *v* is the number
    of vertices.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树中的边数是*v-1*，其中*v*是顶点的数量。
- en: 'The program for creating a minimum spanning tree using Prim''s algorithm is
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Prim算法创建最小生成树的程序如下：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The user is prompted to specify the number of vertices. Assuming the user enters
    `5`, the value of `5` will be assigned to variable `n`. The vertices will be automatically
    named `1`, `2`, `3`, `4`, and `5` for convenience. A `startList` pointer of the
    node type is defined and is set to `NULL` initially. The `startList` pointer will
    be pointing to the first node of the adjacency linked list that will be created
    from the graph.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被提示指定顶点的数量。假设用户输入`5`，则`5`的值将被分配给变量`n`。为了方便，顶点将被自动命名为`1`、`2`、`3`、`4`和`5`。定义了一个节点类型的`startList`指针，并初始设置为`NULL`。`startList`指针将指向从图中创建的邻接链表的第一节点。
- en: 'Two structures are defined: one is called `node` and the other is called `lst`.
    The `node` structure is for making the adjacency list representation of the graph
    and the `lst` structure is for creating a minimum spanning tree. Two pointers, `pq`
    and `tr`, are defined of the `lst` type and are defined as `NULL`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两个结构：一个称为`node`，另一个称为`lst`。`node`结构用于创建图的邻接表表示，而`lst`结构用于创建最小生成树。定义了两个`lst`类型的指针，`pq`和`tr`，并定义为`NULL`。
- en: To make the adjacency linked list representation, the first step is to create
    a linked list of the nodes, where each node represents a vertex of the graph.
    Because there are five vertices in the graph, a `for` loop is set to execute five
    times. Within the `for` loop, a node is created, called `newNode`, and the vertex
    number, `1`, is assigned to its `nme` member. The `startList` pointer is set to
    point to `newNode`. The `vrt` and `edg` members of `newNode` are set to `NULL`.
    The `temp1` pointer is also set to point to `newNode`. The `startList` pointer
    will keep pointing to the first node of the linked list, whereas the `temp1` pointer
    will be used for connecting other nodes, that is, other vertices.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建邻接链表表示，第一步是创建一个节点链表，其中每个节点代表图中的一个顶点。因为图中包含五个顶点，所以设置了一个`for`循环执行五次。在`for`循环内，创建了一个名为`newNode`的节点，并将顶点号`1`分配给其`nme`成员。将`startList`指针设置为指向`newNode`。`newNode`的`vrt`和`edg`成员被设置为`NULL`。`temp1`指针也设置为指向`newNode`。`startList`指针将始终指向链表的第一节点，而`temp1`指针将用于连接其他节点，即其他顶点。
- en: 'In the next iteration of the `for` loop, again, a new node is created, called `newNode`,
    and the vertex number, `2`, will be assigned to it. The `vrt` and `edg` members
    of `newNode` are set to `NULL`. To connect with the existing vertices, `1`, the
    `vrt` member of `temp1` is set to point to `newNode`. Thereafter, `temp1` is set
    to point to `NewNode`. The `for` loop will execute for the time equal to the number
    of vertices, that is, five, hence creating five nodes that contain their respective
    vertex numbers. By the time the `for` loop terminates, the vertices will be created
    and will appear as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的下一个迭代中，再次创建一个新的节点，称为`newNode`，并将顶点号`2`分配给它。`newNode`的`vrt`和`edg`成员被设置为`NULL`。为了与现有顶点连接，将`temp1`的`vrt`成员设置为指向`newNode`。之后，将`temp1`设置为指向`NewNode`。`for`循环将执行与顶点数量相等的时间，即五个，因此创建了包含各自顶点号的五个节点。当`for`循环结束时，顶点将被创建，并如下所示：
- en: '![](img/5159fa84-fbf8-4a76-bf99-4be637354681.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5159fa84-fbf8-4a76-bf99-4be637354681.png)'
- en: Figure 10.31
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31
- en: Once the vertices are created, the next step is to ask the user for the edges
    between the vertices. A graph having *n* vertices can, at most, have *n * (n-1)*
    edges. Because the number of vertices is five, so the node, that is, the number
    of edges variable, is initialized to *5*4=20*. A `for` loop, `j`, is set to execute
    from 1 to 20, asking the user to enter the edges and their respective weights.
    Suppose that the user enters an edge as `1 2`, which will be assigned to the `a`
    and `b` variables, respectively; the weight entered is `1`, which is assigned
    to the `w` variable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了顶点，下一步就是询问用户顶点之间的边。具有*n*个顶点的图最多可以有*n * (n-1)*条边。因为顶点数量是五个，所以节点，即边的数量变量，被初始化为*5*4=20*。设置了一个`for`循环，`j`，从1执行到20，要求用户输入边及其相应的权重。假设用户输入的边为`1
    2`，分别被分配给`a`和`b`变量；输入的权重是`1`，被分配给`w`变量。
- en: To create this edge, the `temp1` pointer is set to point to `startList`. To
    create a (*1*,*2*) edge, the `temp1` pointer is set to point to the node whose
    `nme` member is equal to 1\. Currently, `temp1` is already pointing to vertex
    `1`. The next step is to add vertex `2` at the end of vertex `1`. To find the
    end of a vertex, we will take the help of another pointer, called `temp2`. The
    `temp2` pointer is first set to point to the node that the `temp1` pointer is
    pointing to. Thereafter, using its `edg` pointer, `temp2` is set to point to the
    last node of vertex `1`. Then, a new node is created, called `newNode`, and the
    value of `2` is assigned to the `nme` member of `newNode`. The weight, `1`, in
    the `w` variable is assigned to the `wt` member of `newNode`. The `edge` and `vrt`
    pointers of `newNode` are set to `NULL`. And, finally, the `edg` member of `temp2`
    is set to point to `newNode`. Therefore, vertices `1` and `2` are now connected.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此边，将`temp1`指针设置为指向`startList`。要创建一个(*1*,*2*)边，将`temp1`指针设置为指向其`nme`成员等于1的节点。目前，`temp1`已经指向顶点`1`。下一步是在顶点`1`的末尾添加顶点`2`。为了找到顶点的末尾，我们将使用另一个名为`temp2`的指针。首先，将`temp2`指针设置为指向`temp1`指针指向的节点。然后，使用其`edg`指针，将`temp2`设置为指向顶点`1`的最后一个节点。然后，创建一个新的节点，称为`newNode`，并将值`2`分配给其`nme`成员。将`w`变量中的权重`1`分配给`newNode`的`wt`成员。将`newNode`的`edge`和`vrt`指针设置为`NULL`。最后，将`temp2`的`edg`成员设置为指向`newNode`。因此，现在顶点`1`和`2`已经连接在一起了。
- en: This is an undirected graph, and edge (*1*,*2*) can also mean an edge from `2`
    to `1`. So, we need an edge from vertex `2` to `1`. The `temp1` pointer is set
    to point to `startList`. Using its `vrt` pointer, the `temp1` pointer is set to
    move further until it reaches vertex `2`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无向图，边(*1*,*2*)也可以表示从`2`到`1`的边。因此，我们需要一个从顶点`2`到`1`的边。将`temp1`指针设置为指向`startList`。使用其`vrt`指针，将`temp1`指针移动到顶点`2`。
- en: Once `temp1` reaches vertex `2`, the next step is to set the `temp2` pointer
    to point to the last node of vertex `2`. After doing so, a new node, called `newNode`,
    is created and the value of `1` is assigned to its `nme` member. Additionally,
    the weight in the `w` variable is assigned to the `wt` member of `newNode`. To
    connect these nodes that contain vertices `2` and `1`, the edge pointer of `temp2`
    is set to point to `newNode`. The `edg` and `vrt` pointers of `newNode` are set
    to `NULL`. Therefore, vertices `2` and `1` are connected now too.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当`temp1`到达顶点`2`时，下一步是将`temp2`指针设置为指向顶点`2`的最后一个节点。完成此操作后，创建一个新的节点，称为`newNode`，并将值`1`分配给其`nme`成员。此外，将`w`变量中的权重分配给`newNode`的`wt`成员。为了连接包含顶点`2`和`1`的这些节点，将`temp2`的边指针设置为指向`newNode`。将`newNode`的`edg`和`vrt`指针设置为`NULL`。因此，现在顶点`2`和`1`也连接在一起了。
- en: Displaying the adjacency linked list
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示邻接链表
- en: After entering all of the edges along with their weights, the adjacency list
    has to be displayed. To do this, a `temp1` pointer is set to point to `startList`.
    A `while` loop will execute until the `temp1` pointer reaches `NULL`. So, the `temp1`
    pointer will point to vertex `1` initially. Thereafter, by taking the help of
    the second pointer, `temp2`, all the edges of the `temp1` pointer (that is, vertex
    `1`) are accessed and displayed on screen. After displaying all the edges of vertex
    `1`, by making use of the `vrt` member, the `temp1` pointer is set to point to
    the next vertex, that is, to vertex `2`. Again, the `temp2` pointer is set to
    point at vertex `2`, and, using its `edg` member, all the edges of vertex `2`
    are displayed. The procedure is repeated for all the vertices of the graph.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入所有边及其权重后，必须显示邻接表。为此，设置一个名为`temp1`的指针指向`startList`。一个`while`循环将执行，直到`temp1`指针达到`NULL`。因此，`temp1`指针最初将指向顶点`1`。之后，通过第二个指针`temp2`的帮助，访问并显示`temp1`指针的所有边（即顶点`1`）。显示顶点`1`的所有边后，利用`vrt`成员，将`temp1`指针设置为指向下一个顶点，即顶点`2`。再次，将`temp2`指针设置为指向顶点`2`，并使用其`edg`成员显示顶点`2`的所有边。对于图中的所有顶点，重复此过程。
- en: 'The adjacency list will appear as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接表将如下所示：
- en: '![](img/0f1a953c-745e-4efc-b4b6-7dcd4f3f6e3b.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f1a953c-745e-4efc-b4b6-7dcd4f3f6e3b.png)'
- en: Figure 10.32
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32
- en: Creating the minimum spanning tree
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建最小生成树
- en: To make the minimum spanning tree, we need to adjust the edges of the vertices
    in ascending order. The `temp1` pointer is set to point at `startList`, that is,
    vertex `1`. The `temp2` pointer is set to point to where the `edg` pointer of
    `temp1` is pointing to, that is, vertex `2`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建最小生成树，我们需要按顶点边的权重顺序调整。将`temp1`指针设置为指向`startList`，即顶点`1`。将`temp2`指针设置为指向`temp1`的`edg`指针所指向的位置，即顶点`2`。
- en: Now, until `temp2` becomes `NULL`, the `addpqu` function is invoked and vertices
    `1` and `2`, and their weight, `1`, are passed to it. In the `addpqu` function,
    a structure is created called `lstNode` of the `lst` type. The `1` and `2` vertices and
    their weight, `1`, are assigned to the `u`, `v`, and `wt` members, respectively.
    The next pointer of `lstNode` is set to `NULL`. Additionally, a pointer, `pq`,
    is set to point to `lstNode`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直到`temp2`变为`NULL`，调用`addpqu`函数，并将顶点`1`、`2`及其权重`1`传递给它。在`addpqu`函数中，创建了一个名为`lstNode`的`lst`类型结构。将顶点`1`和`2`及其权重`1`分别分配给其`u`、`v`和`wt`成员。将`lstNode`的下一个指针设置为`NULL`。另外，设置一个指针`pq`指向`lstNode`。
- en: Following this, the `temp2` pointer is set to point to where its `edg` pointer
    is pointing, that is, vertex `3`. Again, the `addpqu` function is called and vertices
    `1` and `3` and weight `3` are passed to it. In the `addpqu` function, again,
    a new node is creating, called `lstNode`, and vertices `1` and `3` and weight
    `3` are assigned to its `u`, `v`, and `wt` members, respectively. The next pointer
    of `lstNode` is set to `NULL`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`temp2`指针设置为指向其`edg`指针所指向的位置，即顶点`3`。再次调用`addpqu`函数，并将顶点`1`、`3`和权重`3`传递给它。在`addpqu`函数中，再次创建一个新的节点，称为`lstNode`，并将顶点`1`、`3`和权重`3`分别分配给其`u`、`v`和`wt`成员。将`lstNode`的下一个指针设置为`NULL`。
- en: Because the nodes have to be arranged in ascending order of their weights, the
    `wt` member of `lstNode` and the previous node, `pq`, are compared. The `wt` member
    of `lstNode` is 3, which is greater than the `wt` member of the `pq` node, which
    is 1\. So, the help of two pointers, `findloc1` and `findloc2`, is taken. One
    pointer is set to point to the weights of `lstNode`, and the `pq` nodes are compared.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因为节点必须按其权重升序排列，所以比较`lstNode`的`wt`成员和前一个节点`pq`的`wt`成员。`lstNode`的`wt`成员是`3`，大于`pq`节点的`wt`成员`1`。因此，使用两个指针`findloc1`和`findloc2`的帮助。一个指针设置为指向`lstNode`的权重，并与`pq`节点进行比较。
- en: 'Let''s choose a vertex, `1`, and add it to the minimum spanning tree:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一个顶点`1`并将其添加到最小生成树中：
- en: '![](img/eb496930-0a18-4b6d-8c2d-f9c16e428d00.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb496930-0a18-4b6d-8c2d-f9c16e428d00.png)'
- en: Figure 10.33
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33
- en: 'Now, from vertex `1`, there are edges to the vertices of `3`, `2`, and `5`,
    but the edge with the minimum weight is to vertex `2`. So, vertex `2` is also
    added to the minimum spanning tree:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从顶点`1`出发，有边通向顶点`3`、`2`和`5`，但权重最低的是通向顶点`2`的边。因此，顶点`2`也被添加到最小生成树中：
- en: '![](img/f5423d76-6f09-47cc-b12f-159128ef27e1.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5423d76-6f09-47cc-b12f-159128ef27e1.png)'
- en: Figure 10.34
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34
- en: 'Again, from vertices `1` and `2` in the minimum spanning tree, we search for
    all the edges that lead to other vertices. We find that edges (**1**,**5**) and
    (**2**,**5**) have the same weight, so we can choose either of the vertices. Let''s
    add edge (**2**,**5**) to the minimum spanning tree:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从最小生成树中的顶点`1`和`2`出发，我们寻找通向其他顶点的所有边。我们发现边（**1**，**5**）和（**2**，**5**）具有相同的权重，因此我们可以选择任一顶点。让我们将边（**2**，**5**）添加到最小生成树中：
- en: '![](img/933474db-e3fa-44d4-9bb2-ac8265cf25b4.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/933474db-e3fa-44d4-9bb2-ac8265cf25b4.png)'
- en: Figure 10.35
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.35
- en: 'From the vertices of `1`, `2`, and `5` in the minimum spanning tree, we search
    for the edges with the lowest weights. Edge (**5**,**3**) has the minimum weight
    of `1`, so edge (**5**,**3**) is added to the minimum spanning tree:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从最小生成树中的顶点`1`、`2`和`5`出发，我们寻找具有最低权重的边。边（**5**，**3**）具有最低的权重`1`，因此边（**5**，**3**）被添加到最小生成树中：
- en: '![](img/24884208-c29b-4c57-b327-771c88b032dc.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24884208-c29b-4c57-b327-771c88b032dc.png)'
- en: Figure 10.36
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36
- en: 'Now, we need to find the edge that leads to vertex `4` from the existing vertices
    in the minimum spanning tree. Edge (**3**,**4**) has the lowest weight and is,
    therefore, added to the minimum spanning tree:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从现有的最小生成树中的顶点中找到通向顶点`4`的边。边（**3**，**4**）具有最低的权重，因此被添加到最小生成树中：
- en: '![](img/886fbfc6-e0d7-46d2-9723-68671d6940fa.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/886fbfc6-e0d7-46d2-9723-68671d6940fa.png)'
- en: Figure 10.37
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37
- en: 'On compiling and running the program, you should get an output that is similar
    to the following screenshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行程序后，你应该得到一个类似于以下屏幕截图的输出：
- en: '![](img/39c364df-efd7-4d91-b77d-7f45731f6473.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39c364df-efd7-4d91-b77d-7f45731f6473.png)'
- en: Figure 10.38
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38
- en: Now, let's move on to the next recipe!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Creating minimum spanning trees using Kruskal's algorithm
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用克鲁斯卡尔算法创建最小生成树
- en: In this recipe, we will learn how to make a minimum spanning tree using Kruskal's
    algorithm.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用克鲁斯卡尔算法制作最小生成树。
- en: A minimum/minimal spanning tree of an undirected graph is a tree that is formed
    from graph edges that connect all of the vertices of the graph at the lowest total
    cost. A minimum spanning tree can exist if, and only if, the graph is connected.
    A graph is said to be connected if there exists a path between any two vertices.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图的最小/最小生成树是由连接图中所有顶点的最低总成本的边形成的树。如果且仅当图是连通的，最小生成树才存在。如果存在任何两个顶点之间的路径，则称图是连通的。
- en: Here, the nodes of the graph are initially considered as *n* distinct partial
    trees with one node each. At each step of the algorithm, two distinct partial
    trees are connected into a single partial tree by an edge of the graph. When only
    one partial tree exists (for instance, after *n-1* such steps), it is a minimum
    spanning tree.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，图中的节点最初被认为是具有一个节点的**n**个不同的部分树。算法的每一步，两个不同的部分树通过图中的一条边连接成一个部分树。当只有一个部分树存在时（例如，经过**n-1**次这样的步骤后），它就是一个最小生成树。
- en: The connecting arc of minimum cost is used to connect two distinct trees. To
    do this, the arcs can be placed in a priority queue based on weight. The arc of
    lowest weight is then examined to see whether it connects two distinct trees.
    To determine whether an arc *(x, y)* connects two distinct trees, we can implement
    the trees with a father field in each node. Then, we can traverse all the ancestors
    of *x* and *y* to obtain the root of the tree connecting them. If the root of
    the two trees is the same node, and *x* and *y* are already in the same tree,
    then arc *(x, y)* is discarded, and the arc of the next lowest weight is examined.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最低成本的连接弧连接两个不同的树。为此，可以根据权重将弧放置在优先队列中。然后检查权重最低的弧是否连接了两个不同的树。为了确定弧（x，y）是否连接了两个不同的树，我们可以在每个节点中实现一个父字段来表示树。然后，我们可以遍历x和y的所有祖先以获得连接它们的树的根。如果两个树的根是同一个节点，并且x和y已经在同一个树中，那么弧（x，y）将被丢弃，然后检查下一个最低权重的弧。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a minimum spanning tree using Kruskal''s algorithm:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用克鲁斯卡尔算法创建最小生成树：
- en: Sort the edge list in ascending order of their weights.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照边的权重升序对边列表进行排序。
- en: Pick up the edge at the top of the edge list (with the smallest weight).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从边列表的顶部（权重最小的边）取出边。
- en: Remove this edge from the edge list.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从边列表中删除这条边。
- en: Connect the two vertices with the given edge. If, by connecting the vertices,
    a cycle is made in the graph, then discard the edge.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的边连接两个顶点。如果通过连接顶点，在图中形成了一个环，那么就丢弃这条边。
- en: Repeat the preceding *steps 2* to *4* until *n-1* edges are added or the list
    of edges is complete.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复先前的**步骤 2**到**4**，直到添加了**n-1**条边或边列表完整。
- en: 'The program for creating a minimum spanning tree using Kruskal''s algorithm
    is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用克鲁斯卡尔算法创建最小生成树的程序如下：
- en: '[PRE13]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以便更好地理解。
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Consider the following undirected graph:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下无向图：
- en: '![](img/e060dfd4-857c-4bee-8c2b-a4227ffa6368.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e060dfd4-857c-4bee-8c2b-a4227ffa6368.png)'
- en: Figure 10.39
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39
- en: 'Because the graph has five vertices, the minimum spanning tree will have four
    edges. The first step in Kruskal''s algorithm is that the edges of the graph are
    first sorted in ascending order of their weights:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因为图有五个顶点，所以最小生成树将有四条边。克鲁斯卡尔算法的第一步是将图的边按照它们的权重升序排序：
- en: '[PRE14]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we will pick up one edge at a time from the preceding table, and, if it
    does not make a cycle, we will include it in the minimum spanning tree. We begin
    with edge (**1**,**2**). There is no cycle in this edge; therefore, it is included
    in the minimum spanning tree as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从先前的表中逐条取出一条边，如果它不会形成环，我们将它包含在最小生成树中。我们首先从边（**1**，**2**）开始。这条边中没有环；因此，它被包含在以下最小生成树中：
- en: '![](img/0498f249-59d5-454c-9e36-7bc7a2c18def.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0498f249-59d5-454c-9e36-7bc7a2c18def.png)'
- en: Figure 10.40
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40
- en: 'The next edge in the table is (**3**,**5**). This edge also does not make a
    cycle, so it included in the minimum spanning tree:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的下一个边是（**3**，**5**）。这条边也不会形成环，所以它被包含在最小生成树中：
- en: '![](img/4804d6e5-ff89-4c34-b7d8-7a852bb5a93a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4804d6e5-ff89-4c34-b7d8-7a852bb5a93a.png)'
- en: Figure 10.41
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41
- en: 'Next, pick edge (**1**,**5**). Again, no cycle is made with this edge, so it
    is included in the minimum spanning tree:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择边缘（**1**，**5**）。同样，这个边缘也没有形成循环，所以它被包含在最小生成树中：
- en: '![](img/89b8c93c-7e07-4359-8216-e79bcd431954.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89b8c93c-7e07-4359-8216-e79bcd431954.png)'
- en: Figure 10.42
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42
- en: 'The next edge in the table is (**2**,**5**) but it does make a cycle, so it
    is discarded. The next edge in the table is (**3**,**4**). Edge (**3**,**4**)
    does not make a cycle; therefore, it is added to the minimum spanning tree:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的下一个边缘是（**2**，**5**），但它确实形成了一个循环，所以被舍弃了。表格中的下一个边缘是（**3**，**4**）。边缘（**3**，**4**）没有形成循环；因此，它被添加到最小生成树中：
- en: '![](img/bbbf0062-1f58-453c-bdf6-38f165e9c773.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bbbf0062-1f58-453c-bdf6-38f165e9c773.png)'
- en: Figure 10.43
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43
- en: The number of vertices is 5, so the number of edges will be *v-1*, that is,
    4, and we have 4 edges, so our minimum spanning tree is complete.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点的数量是5，所以边的数量将是*v-1*，即4，我们已经有4条边，所以我们的最小生成树是完整的。
- en: 'On compiling and running the `kruskal.c` program, we get an output that is
    similar to the following screenshot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译并运行`kruskal.c`程序后，我们得到一个类似于以下截图的输出：
- en: '![](img/36d6d6ef-83f6-4a64-bb0e-fa68d2ac2538.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36d6d6ef-83f6-4a64-bb0e-fa68d2ac2538.png)'
- en: Figure 3.44
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.44
- en: As you can see, we get the adjacency list representation and the minimal spanning
    tree using Kruskal's algorithm in the output.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在输出中使用了克鲁斯卡尔算法得到了邻接表表示和最小生成树。
