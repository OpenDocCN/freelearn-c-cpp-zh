- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: General-Purpose Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library contains many general-purpose utilities and libraries
    beyond the containers, algorithms, and iterators discussed in the previous chapter.
    This chapter is focused on three areas: the `chrono` library for working with
    dates, times, calendars, and time zones; type traits, which provide meta-information
    about other types; and utility types in newer versions of the standard, `std::any`,
    `std::optional`, and `std::variant` in C++17, `std::span` and `std::source_location`
    in C++20, and `std::mdspan` and `std::expected` in C++23.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressing time intervals with `chrono::duration`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with calendars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting times between time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring function execution time with a standard clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating hash values for custom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::any` to store any value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::optional` to store optional values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining together computations that may or may not produce a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::variant` as a type-safe union
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visiting a `std::variant`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::expected` to return a value or an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::span` for contiguous sequences of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::mdspan` for multi-dimensional views of sequences of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a function to be called when a program exits normally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using type traits to query properties of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own type traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::conditional` to choose between types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing logging details with `source_location`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `stacktrace` library to print the call sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part of the chapter focuses on the `chrono` library, which provides
    time and date utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing time intervals with chrono::duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with times and dates is a common operation, regardless of the programming
    language. C++11 provides a flexible date and time library as part of the standard
    library that enables us to define time points and time intervals. This library,
    called `chrono`, is a general-purpose utility library designed to work with a
    timer and clocks that can be different on different systems and, therefore, precision-neutral.
    The library is available in the `<chrono>` header in the `std::chrono` namespace
    and defines and implements several components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Durations*, which represent time intervals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time points*, which present a duration of time since the epoch of a clock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clocks*, which define an epoch (that is, the start of time) and a tick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to work with durations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is not intended as a complete reference to the `duration` class.
    It is recommended that you consult additional resources for that purpose (the
    library reference documentation is available at [http://en.cppreference.com/w/cpp/chrono](http://en.cppreference.com/w/cpp/chrono)).
  prefs: []
  type: TYPE_NORMAL
- en: In the `chrono` library, a time interval is represented by the `std::chrono::duration`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with time intervals, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::chrono::duration` typedefs for hours, minutes, seconds, milliseconds,
    microseconds, and nanoseconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the standard user-defined literal operators from C++14, available in the
    namespace `std::chrono_literals`, to create durations of hours, minutes, seconds,
    milliseconds, microseconds, and nanoseconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use direct conversion from a lower precision duration to a higher precision
    duration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::chrono::duration_cast` to convert from a higher precision to a lower
    precision duration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the chrono conversion functions `floor()`, `round()`, and `ceil()` available
    in the `std::chrono` namespace in C++17 when rounding is necessary (not to be
    confused with the `std::floor()`, `std::round()`, and `std::ceil()` functions
    from the `<cmath>` header):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use arithmetic operations, compound assignments, and comparison operations
    to modify and compare time intervals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::chrono::duration` class defines a number of ticks (the increment between
    two moments in time) over a unit of time. The default unit is the second, and
    for expressing other units, such as minutes or milliseconds, we need to use a
    ratio. For units greater than a second, the ratio is greater than one, such as
    `ratio<60>` for minutes. For units smaller than a second, the ratio is smaller
    than one, such as `ratio<1, 1000>` for milliseconds. The number of ticks can be
    retrieved with the `count()` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library defines several type synonyms for durations of nanoseconds,
    microseconds, milliseconds, seconds, minutes, and hours, which we used in the
    first example in the previous section. The following code shows how these durations
    are defined in the `chrono` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with this flexible definition, we can express time intervals such
    as *1.2 sixths of a minute* (which means 12 seconds), where 1.2 is the number
    of ticks of the duration and `ratio<10>` (as in 60/6) is the time unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In C++14, several standard user-defined literal operators have been added to
    the namespace `std::chrono_literals`. This makes it easier to define durations,
    but you must include the namespace in the scope where you want to use the literal
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: You should only include namespaces for user-defined literal operators in the
    scope where you want to use them, and not in larger scopes, in order to avoid
    conflict with other operators with the same name from different libraries and
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: All arithmetic operations are available for the `duration` class. It is possible
    to add and subtract durations, multiply or divide them by a value, or apply the
    `modulo` operation. However, it is important to note that when two durations of
    different time units are added or subtracted, the result is a duration of the
    greatest common divisor of the two time units. This means that if you add a duration
    representing seconds and a duration representing minutes, the result is a duration
    representing seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion from a duration with a less precise time unit to a duration with
    a more precise time unit is done implicitly. On the other hand, conversion from
    a more precise to a less precise time unit requires an explicit cast. This is
    done with the non-member function `std::chrono::duration_cast()`. In the *How
    to do it...* section, you saw an example for determining the number of hours,
    minutes, and seconds of a given duration expressed in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++17 has added several more non-member conversion functions that perform duration
    casting with rounding: `floor()` to round down, `ceil()` to round up, and `round()`
    to round to the nearest. Also, C++17 added a non-member function called `abs()`
    to retain the absolute value of a duration.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`chrono` is a general-purpose library that, before C++20, lacked many useful
    features, such as expressing a date with the year, month, and day parts, working
    with time zones and calendars, and others. The C++20 standard added support for
    calendars and time zones, which we will see in the following recipes. If you use
    a compiler that doesn’t support these C++20 additions, then third-party libraries
    can implement these features, and a recommended one is Howard Hinnant’s `date`
    library, available under the MIT license at [https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date).
    This library was the foundation for the C++20 `chrono` additions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Measuring function execution time with a standard clock*, to see how you can
    determine the execution time of a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with calendars*, to discover the C++20 additions to the `chrono` library
    for working with dates and calendars'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting times between time zones*, to learn how you can convert time points
    between different time zones in C++20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with calendars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chrono` library, available in C++11, offered support for clocks, time
    points, and durations but did not make it easy to express times and dates, especially
    with respect to calendars and time zones. The new C++20 standard corrects this
    by extending the existing `chrono` library with:'
  prefs: []
  type: TYPE_NORMAL
- en: More clocks, such as a UTC clock, an International Atomic Time clock, a GPS
    clock, a file time clock, and a pseudo-clock representing local time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time of day, representing the time elapsed since midnight split into hours,
    minutes, and seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calendars, which enable us to express dates with year, month, and day parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time zones, which enable us to express time points with respect to a time zone
    and make it possible to convert times between different time zones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O support for parsing chrono objects from a stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn about working with calendar objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the new chrono functionalities are available in the same `std::chrono` and
    `std::chrono_literals` namespaces in the `<chrono>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the C++20 chrono calendar functionalities to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Represent Gregorian calendar dates with year, month, and day, as instances
    of the `year_month_day` type. Use the standard user-defined literals, constants,
    and the overloaded operator `/` to construct such objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Represent the *n*th weekday of a specific year and month as instances of the
    `year_month_weekday` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the current date, as well as compute other dates from it, such as
    the dates for tomorrow and yesterday:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the first and last day of a specific month and year:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the number of days between two dates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether a date is valid:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Represent the time of day with hour, minutes, and seconds using the `hh_mm_ss<Duration>`
    class template, where `Duration` determines the precision used to split a time
    interval. In the next example, `std::chrono::seconds` defines a split precision
    of 1 second:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create time points with date and time parts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the current time of day and express it with various precisions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `year_month_day` and `year_month_weekday` types we have seen in the examples
    here are only some of the many new types added to the `chrono` library for calendar
    support. The following table lists all these types in the `std::chrono` namespace
    and what they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Represents** |'
  prefs: []
  type: TYPE_TB
- en: '| `day` | A day of a month |'
  prefs: []
  type: TYPE_TB
- en: '| `month` | A month of a year |'
  prefs: []
  type: TYPE_TB
- en: '| `year` | A year in the Gregorian calendar |'
  prefs: []
  type: TYPE_TB
- en: '| `weekday` | A day of the week in the Gregorian calendar |'
  prefs: []
  type: TYPE_TB
- en: '| `weekday_indexed` | The *n*th weekday of a month, where *n* is in the range
    [1, 5] (1 is the 1st weekday of the month and 5 is the 5th—if it exists—weekday
    of the month) |'
  prefs: []
  type: TYPE_TB
- en: '| `weekday_last` | The last weekday of a month |'
  prefs: []
  type: TYPE_TB
- en: '| `month_day` | A specific day of a specific month |'
  prefs: []
  type: TYPE_TB
- en: '| `month_day_last` | The last day of a specific month |'
  prefs: []
  type: TYPE_TB
- en: '| `month_weekday` | The *n*th weekday of a specific month |'
  prefs: []
  type: TYPE_TB
- en: '| `month_weekday_last` | The last weekday of a specific month |'
  prefs: []
  type: TYPE_TB
- en: '| `year_month` | A specific month of a specific year |'
  prefs: []
  type: TYPE_TB
- en: '| `year_month_day` | A specific year, month, and day |'
  prefs: []
  type: TYPE_TB
- en: '| `year_month_day_last` | The last day of a specific year and month |'
  prefs: []
  type: TYPE_TB
- en: '| `year_month_weekday` | The *n*th weekday of a specific year and month |'
  prefs: []
  type: TYPE_TB
- en: '| `year_month_weekday_last` | The last weekday of a specific year and month
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: C++20 chrono types for working with dates'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the types listed in this table have:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor that leaves the member fields uninitialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Member functions to access the parts of the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A member function called `ok()` that checks if the stored value is valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-member comparison operators to compare values of the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded `operator<<` to output a value of the type to a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded function template called `from_stream()` that parses a value from
    a stream according to the provided format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A specialization of the `std::formatter<T, CharT>` class template for the text
    formatting library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the `operator/` is overloaded for many of these types to enable
    us to easily create Gregorian calendar dates. When you create a date (with year,
    month, and day), you can choose between three different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**year/month/day** (used in countries such as China, Japan, Korea, and Canada,
    but others too, sometimes together with the day/month/year format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**month/day/year** (used in the USA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**day/month/year** (used in most parts of the world)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In these cases, **day** can be either:'
  prefs: []
  type: TYPE_NORMAL
- en: An actual day of the month (values from 1 to 31)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std:chrono::last` to indicate the last day of the month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weekday[n]`, to indicate the *n*th weekday of the month (where *n* can take
    values from 1 to 5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weekday[std::chrono::last]`, to indicate the last weekday of the month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to disambiguate between integers that represent the day, month, and
    year, the library provides two user-defined literals: `""y` to construct a literal
    of the type `std::chrono::year`, and `""d` to construct a literal of the type
    `std::chrono::day`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are constants that represent:'
  prefs: []
  type: TYPE_NORMAL
- en: A `std::chrono::month`, named `January`, `February`, up to `December`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `std::chrono::weekday`, named `Sunday`, `Monday`, `Tuesday`, `Wednesday`,
    `Thursday`, `Friday`, or `Saturday`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use all these to construct dates such as `2025y/April/1`, `25d/December/2025`,
    or `Sunday[last]/May/2025`.
  prefs: []
  type: TYPE_NORMAL
- en: The `year_month_day` type provides implicit conversion to and from `std::chrono::sys_days`.
    This type is a `std::chrono::time_point` with the precision of a day (24 hours).
    There is a companion type called `std::chrono::sys_seconds`, which is a `time_point`
    with a precision of one second. Explicit conversion between `time_point` and `sys_days`
    / `sys_seconds` can be performed using `std::chrono::time_point_cast()` or `std::chrono::floor()`.
  prefs: []
  type: TYPE_NORMAL
- en: To represent a moment of time during a day, we can use the `std::chrono::hh_mm_ss`
    type. This class represents the time elapsed since midnight, broken down into
    hours, minutes, seconds, and sub-seconds. This type is mostly intended as a formatting
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also several utility functions for translating between 12h/24h formats.
    These functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_am()` and `is_pm()` that check whether a 24-hour formatted time (provided
    as a `std::chrono::hours` value) is A.M. (before midday) or, respectively, P.M.
    (before midnight):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`make12()` and `make24()` that return the 12-hour equivalent of a 24-hour format
    time and, respectively, vice versa. They both take the input time as a `std::chrono::hours`
    value, but `make24()` has an additional parameter, a Boolean indicating whether
    the time is P.M.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from these examples, these four functions only work with an hour
    value, since only the hour part of a moment of time determines its format as 12h
    or 24h or whether it’s an A.M. or P.M. time.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of publishing the second edition of this book, the chrono changes
    were not completed. The `hh_mm_ss` type was called `time_of_day`, and the `make12()`/`make_24()`
    functions were members of it. This edition reflects the changes and utilizes the
    standardized API.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The date and time facilities described here are all based on the `std::chrono::system_clock`.
    Since C++20, this clock is defined to measure the Unix time, which is the time
    since 00:00:00 UTC on 1 January 1970\. This means the implicit time zone is UTC.
    However, in most cases, you might be interested in the local time of a specific
    time zone. To help with that, the `chrono` library added support for time zones,
    which is what we will learn about in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Expressing time intervals with chrono::duration*, to familiarize yourself
    with the fundamentals of the C++11 `chrono` library and to work with durations,
    time points, and points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting times between time zones*, to learn how you can convert time points
    between different time zones in C++20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting times between time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we talked about C++20 support for working with calendars
    and expressing dates in the Gregorian calendar with the `year_month_day` type
    and others from the `chrono` library.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to represent times of day with the `hh_mm_ss` type. However,
    in all these examples, we worked with the time points using the system clock,
    which measures Unix time and, therefore, uses UTC as the default time zone. However,
    we are usually interested in the local time and, sometimes, in the time in some
    other time zone. This is possible with the facilities added to the `chrono` library
    to support time zones. In this recipe, you will learn about the most important
    functionalities of chrono’s time zones.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before continuing with this recipe, it is recommended that you read the previous
    one, *Working with calendars*, if you have not done so already.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can do the following using the C++20 `chrono` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `std::chrono::current_zone()` to retrieve the local time zone from the
    time zone database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::chrono::locate_zone()` to retrieve a particular time zone, using its
    name, from the time zone database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Represent a time point in a particular time zone using the `std::chrono::zoned_time`
    class template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retrieve and display the current local time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve and display the current time in another time zone. In the following
    example, we use the time in Italy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the current local time with proper locale formatting. In this example,
    the current time is Romanian time, and the locale being used is for Romania:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Represent a time point in a particular time zone and display it. In the following
    example, this is New York’s time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert a time point in a particular time zone into a time point in another
    time zone. In the following example, we convert the time from New York into the
    time in Los Angeles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The system maintains a copy of the IANA Time Zone (TZ) database (which is available
    online at [https://www.iana.org/time-zones](https://www.iana.org/time-zones)).
    As a user, you cannot create or alter the database but only retrieve a read-only
    copy of it with functions such as `std::chrono::tzdb()` or `std::chrono::get_tzdb_list()`.
    Information about a time zone is stored in a `std::chrono::time_zone` object.
    Instances of this class cannot be created directly; they are only created by the
    library when initializing the time zone database. However, it is possible to obtain
    constant access to these instances, using two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::chrono::current_zone()` retrieves the `time_zone` object representing
    the local time zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::locate_zone()`retrieves the `time_zone` object representing the
    specified time zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of time zone names include Europe/Berlin, Asia/Dubai, and America/Los_Angeles.
    When the name of the location contains multiple words, spaces are replaced by
    an underscore (`_`), such as in the preceding example where Los Angeles is written
    as Los_Angeles.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the time zones from the IANA TZ database can be found at [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two sets of types in the C++20 `chrono` library to represent time
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sys_days` and `sys_seconds` (having day and second precision) represent a
    time point in the system’s time zone, which is UTC. These are type aliases for
    `std::chrono::sys_time`, which, in turn, is an alias for `std::chrono::time_point`,
    which is using the `std::chrono::system_clock`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local_days` and `local_seconds` (having also day and second precision) represent
    a time point with respect to a time zone that has not yet been specified. These
    are type aliases for `std::chrono::local_time`, which is, in turn, a type alias
    for a `std::chrono::time_point` using the `std::chrono::local_t` pseudo-clock.
    The sole purpose of this clock is to indicate a not-yet-specified time zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `std::chrono::zoned_time` class template represents a pairing of a time
    zone with a time point. It can be created from either a `sys_time`, a `local_time`,
    or another `zoned_time` object. Examples of all these cases are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this sample code, the times in the comments are based on the Romanian time
    zone. Notice that, in the first example, the time is expressed with `sys_days`,
    which uses the UTC time zone. Since Romanian time is UTC+3 on 10 May 2024 (because
    of Daylight Saving Time), the local time is 17:20:30\. In the second example,
    the time is specified with `local_days`, which is time zone-agnostic. For this
    reason, when pairing with the current time zone, the time is actually 14:20:30\.
    In the third and last example, the local Romanian time is converted to the time
    in Paris, which is 13:20:30 (because on that day, the time in Paris was UTC+2).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Expressing time intervals with chrono::duration*, to familiarize yourself
    with the fundamentals of the C++11 `chrono` library and to work with durations,
    time points, and points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with calendars*, to discover the C++20 additions to the `chrono` library
    for working with dates and calendars'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring function execution time with a standard clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to work with time intervals using the `chrono`
    standard library. However, we also often need to handle time points. The `chrono`
    library provides such a component, representing a duration of time since the epoch
    of a clock (that is, the beginning of time as defined by a clock). In this recipe,
    we will learn how to use the `chrono` library and time points to measure the execution
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is tightly related to a preceding one, *Expressing time intervals
    with chrono::duration*. If you did not go through that recipe previously, you
    should do that before continuing with this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the examples in this recipe, we will consider the following function, which
    does nothing but pause the execution of the current thread for a given interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It should go without saying that this function is only meant for testing purposes
    and does nothing valuable. In practice, you will use the counting utility provided
    here to test your own functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To measure the execution of a function, you must perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the current moment of time using a standard clock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the function you want to measure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the current moment of time again; the difference between the two is
    the execution time of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the difference (which is expressed in nanoseconds) to the actual resolution
    you are interested in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement this pattern in a reusable component, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class template parameterized with the resolution and the clock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a static variadic function template that takes a function and its arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the pattern shown previously, invoking the function with its arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a duration, not the number of ticks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is exemplified in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A clock is a component that defines two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A beginning of time called an *epoch*; there is no constraint regarding what
    the epoch is, but typical implementations use January 1, 1970.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *tick rate* that defines the increment between two time points (such as a
    millisecond or nanosecond).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A time point is a duration of time since the epoch of a clock. There are several
    time points that are of particular importance:'
  prefs: []
  type: TYPE_NORMAL
- en: The current time, returned by the clock’s static member `now()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The epoch, or the beginning of time; this is the time point created by the default
    constructor of `time_point` for a particular clock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum time that can be represented by a clock, returned by the static
    member `min()` of `time_point`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum time that can be represented with a clock, returned by the static
    member `max()` of a `time point`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standard defines several clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_clock`: This uses the real-time clock of the current system to represent
    time points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`high_resolution_clock`: This represents a clock that uses the shortest possible
    tick period on the current system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`steady_clock`: This indicates a clock that is never adjusted. This means that,
    unlike the other clocks, as time advances, the difference between two time points
    is always positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utc_clock`: This is a C++20 clock for Coordinated Universal Time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tai_clock`: This is a C++20 clock for International Atomic Time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gps_clock`: This is a C++20 clock for GPS time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file_clock`: This is a C++20 clock used for expressing file times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example prints the precision of the first three clocks in this
    list (the ones available in C++11), regardless of whether it is steady (or monotone)
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `system_clock` has a resolution of 0.1 microseconds and
    is not a monotone clock. On the other hand, the other two clocks, `high_resolution_clock`
    and `steady_clock`, both have a resolution of 1 nanosecond and are monotone clocks.
  prefs: []
  type: TYPE_NORMAL
- en: The steadiness of a clock is important when measuring the execution time of
    a function because, if the clock is adjusted while the function runs, the result
    will not yield the actual execution time, and values can even be negative. You
    should rely on a steady clock to measure the function execution time. The typical
    choice for that is the `high_resolution_clock`, and that was the clock we used
    in the examples in the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: When we measure the execution time, we need to retrieve the current time before
    making the call and after the call returns. For that, we use the clock’s `now()`
    static method. The result is a `time_point`; when we subtract two time points,
    the result is a `duration`, defined by the duration of the clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a reusable component that can be used to measure the execution
    time of any function, we have defined a class template called `perf_timer`. This
    class template is parameterized with the resolution we are interested in (which,
    by default, is microseconds) and the clock we want to use (which, by default,
    is `high_resolution_clock`). The class template has a single static member called
    `duration()`—a variadic function template—that takes a function to execute and
    its variable number of arguments. The implementation is relatively simple: we
    retrieve the current time, invoke the function using `std::invoke` (so that it
    handles the different mechanisms for invoking anything callable), and then retrieve
    the current time again. The return value is a `duration` (with the defined resolution).
    The following snippet shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that we are not returning a number of ticks from the
    `duration()` function, but an actual `duration` value. The reason is that by returning
    a number of ticks, we lose the resolution and won’t know what they actually represent.
    It is better to call `count()` only when the actual count of ticks is necessary.
    This is exemplified here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we measure the execution of three different functions, using
    three different resolutions (nanoseconds, microseconds, and milliseconds). The
    values `t1`, `t2`, and `t3` represent durations. These make it possible to easily
    add them together and convert the result to microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Expressing time intervals with chrono::duration*, to familiarize yourself
    with the fundamentals of the C++11 `chrono` library and how to work with durations,
    time points, and points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Uniformly invoking anything callable*, to learn how to use `std::invoke()`
    to call functions and any callable object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating hash values for custom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library provides several unordered associative containers: `std::unordered_set`,
    `std::unordered_multiset`, `std::unordered_map`, and `std::unordered_map`. These
    containers do not store their elements in a particular order; instead, they are
    grouped in buckets. The bucket an element belongs to depends on the hash value
    of the element. These standard containers use, by default, the `std::hash` class
    template to compute the hash value. The specialization for all basic types and
    also some library types is available. However, for custom types, you must specialize
    the class template yourself. This recipe will show you how to do that and also
    explain how a good hash value can be computed. A good hash value can be computed
    fast and is uniformly dispersed across the value domain, therefore minimizing
    the chances of duplicate values (collisions) existing.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the examples in this recipe, we will use the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This recipe covers hashing functionalities from the standard library. You should
    be familiar with the concepts of hashes and hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use your custom types with the unordered associative containers,
    you must perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Specialize the `std::hash` class template for your custom type; the specialization
    must be done in the `std` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define synonyms for the argument and result type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the call operator so that it takes a constant reference to your type
    and returns a hash value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To compute a good hash value, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with an initial value, which should be a prime number (for example, 17).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each field that is used to determine whether two instances of the class
    are equal, adjust the hash value according to the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use the same prime number for all fields with the preceding formula,
    but it is recommended to have a different value than the initial value (for instance,
    31).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a specialization of `std::hash` to determine the hash value for class data
    members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the steps described here, the `std::hash` specialization for the `Item`
    class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This specialization makes it possible to use the `Item` class with unordered
    associative containers, such as `std::unordered_set`. An example is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class template `std::hash` is a function object template whose call operator
    defines a hash function with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes an argument of the template parameter type and returns a `size_t` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not throw any exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For two arguments that are equal, it returns the same hash value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For two arguments that are not equal, the probability of returning the same
    value is very small (should be close to `1.0/std::numeric_limits<size_t>::max()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard provides specialization for all basic types, such as `bool`, `char`,
    `int`, `long`, `float`, `double` (along with all the possible `unsigned` and `long`
    variations), and the pointer type, but also library types including the `basic_string`
    and `basic_string_view` types, `unique_ptr` and `shared_ptr`, `bitset` and `vector<bool>`,
    `optional` and `variant` (in C++17), and several other types. However, for custom
    types, you have to provide your own specialization. This specialization must be
    in the namespace `std` (because that is the namespace where the class template
    `hash` is defined) and must meet the requirements enumerated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The standard does not specify how hash values should be computed. You can use
    any function you want as long as it returns the same value for equal objects,
    and also has a very small chance of returning the same value for non-equal objects.
    The algorithm described in this recipe was presented in the book *Effective Java,
    Second Edition* by Joshua Bloch.
  prefs: []
  type: TYPE_NORMAL
- en: When computing the hash value, consider only the fields that participate in
    determining whether two instances of the class are equal (in other words, fields
    that are used in `operator==`). However, you must use all these fields that are
    used with `operator==`. In our example, all three fields of the `Item` class are
    used to determine the equality of two objects; therefore, we must use them all
    to compute the hash. The initial hash value should be nonzero, and in our example,
    we picked the prime number 17\.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is that these values should not be zero; otherwise, the
    initial fields (that is, the first in the order of processing) that produce the
    hash value zero will not alter the hash (which remains zero since `x * 0 + 0 =
    0`). For every field used to compute the hash, we alter the current hash by multiplying
    its previous value with a prime number and adding the hash of the current field.
    For this purpose, we use specializations of the class template `std::hash`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the prime number 31 is advantageous for performance optimizations
    because `31 * x` can be replaced by the compiler with `(x << 5) - x`, which is
    faster. Similarly, you can use 127 because `127 * x` is equal to `(x << 7) - x`
    or 8191, because `8191 * x` is equal to `(x << 13) - x`.
  prefs: []
  type: TYPE_NORMAL
- en: If your custom type contains an array and is used to determine the equality
    of two objects and, therefore, needs to be used to compute the hash, then treat
    the array as if its elements were data members of the class. In other words, apply
    the same algorithm described earlier to all elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Limits and other properties of numeric types*, to learn about
    the minimum and maximum values, as well as the other properties of numerical types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::any to store any value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ does not have a hierarchical type system like other languages (such as C#
    or Java) and, therefore, it can’t store multiple types of a value in a single
    variable like it is possible to with the type `Object` in .NET and Java or natively
    in JavaScript. Developers have long used `void*` for that purpose, but this only
    helps us store pointers to anything and is not type-safe. Depending on the end
    goal, alternatives can include templates or overloaded functions. However, C++17
    has introduced a standard type-safe container, called `std::any`, that can hold
    a single value of any type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::any` has been designed based on `boost::any` and is available in the
    `<any>` header. If you are familiar with `boost::any` and have used it in your
    code, you can migrate it seamlessly to `std::any`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following operations to work with `std::any`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store values, use the constructor or assign them directly to a `std::any`
    variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read values, use the non-member function `std::any_cast()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the type of the stored value, use the member function `type()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether the container stores a value, use the `has_value()` member
    function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the stored value, use the member functions `emplace()`, `reset()`,
    or `swap()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::any` is a type-safe container that can hold values of any type that is
    (or rather, whose decayed type is) copy constructible. Storing values in the container
    is very simple—you can either use one of the available constructors (the default
    constructor creates a container that stores no value) or the assignment operator.
    However, reading values is not directly possible, and you need to use the non-member
    function `std::any_cast()`, which casts the stored value to the specified type.
    This function throws `std::bad_any_cast` if the stored value has a different type
    than the one you are casting to. Casting between implicitly convertible types,
    such as `int` and `long`, is not possible either. `std::bad_any_cast` is derived
    from `std::bad_cast`; therefore, you can catch any of these two exception types.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to check the type of the stored value using the `type()` member
    function, which returns a `type_info` constant reference. If the container is
    empty, this function returns `typeid(void)`. To check whether the container stores
    a value, you can use the member function `has_value()`, which returns `true` if
    there is a value or `false` if the container is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to check whether the container has any value,
    how to check the type of the stored value, and how to read the value from the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to store multiple values of any type, use a standard container
    such as `std::vector` to hold values of the type `std::any`. An example is presented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::variant as a type-safe union*, to learn how to use the C++17 `std::variant`
    class to represent type-safe unions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::optional to store optional values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is useful to be able to store either a value or a null pointer
    if a specific value is not available. A typical example of such a case is the
    return value of a function that may fail to produce a return value, but this failure
    is not an error. For instance, think of a function that finds and returns values
    from a dictionary by specifying a key. Not finding a value is a probable case
    and, therefore, the function would either return a Boolean (or an integer value,
    if more error codes are necessary) and have a reference argument to hold the return
    value or return a pointer (raw or smart pointer). In C++17, `std::optional` is
    a better alternative to these solutions. The class template `std::optional` is
    a template container for storing a value that may or may not exist. In this recipe,
    we will see how to use this container and its typical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class template `std::optional<T>` was designed based on `boost::optional`
    and is available in the `<optional>` header. If you are familiar with `boost::optional`
    and have used it in your code, you can migrate it seamlessly to `std::optional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippets, we will refer to the following `foo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following operations to work with `std::optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store a value, use the constructor or assign the value directly to a `std::optional`
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read the stored value, use `operator*` or `operator->`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the member functions `value()` and `value_or()` to read
    the stored value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether the container stores a value, use a conversion operator to
    `bool` or the member function `has_value()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the stored value, use the member functions `emplace()`, `reset()`,
    or `swap()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::optional` to model any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return values from functions that may fail to produce a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parameters to functions that are optional:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Class data members that are optional:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class template `std::optional` is a class template that represents a container
    for an optional value. If the container does have a value, that value is stored
    as part of the `optional` object; no heap allocations and pointers are involved.
    The `std::optional` class template is conceptually implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `std::aligned_storage_t` alias template allows us to create uninitialized
    chunks of memory that can hold objects of a given type. The class template `std::optional`
    does not contain a value if it was default constructed, or if it was copy constructed
    or copy assigned from another empty optional object or from a `std::nullopt_t`
    value. Such a value is `std::nullopt`, a `constexpr` value used to indicate an
    optional object with an uninitialized state. This is a helper type, implemented
    as an empty class, that indicates an optional object with an uninitialized state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical use for an `optional` type (called *nullable* in other programming
    languages) is the return type from a function that may fail. Possible solutions
    for this situation include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a `std::pair<T, bool>`, where `T` is the type of the return value; the
    second element of the pair is a Boolean flag that indicates whether the value
    of the first element is valid or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a `bool`, take an extra parameter of the type `T&`, and assign a value
    to this parameter only if the function succeeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a raw or smart pointer type, and use `nullptr` to indicate a failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class template `std::optional` is a better approach because, on the one
    hand, it does not involve output parameters to the function (which, outside of
    C and C++, is not the canonical form for returning values) and does not require
    working with pointers, and on the other hand, it better encapsulates the details
    of a `std::pair<T, bool>`.
  prefs: []
  type: TYPE_NORMAL
- en: However, optional objects can also be used for class data members, and compilers
    are able to optimize the memory layout for efficient storage.
  prefs: []
  type: TYPE_NORMAL
- en: The class template `std::optional` cannot be used to return polymorphic types.
    If you write, for instance, a factory method that needs to return different types
    from a hierarchy of types, you cannot rely on `std::optional` and need to return
    a pointer, preferably a `std::unique_ptr` or `std::shared_ptr` (depending on whether
    ownership of the object needs to be shared or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use `std::optional` to pass optional arguments to a function, you
    need to understand that it may incur creating copies, which can be a performance
    issue if large objects are involved. Let’s consider the following example of a
    function that has a constant reference to the `std::optional` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `process()` does not involve any additional object construction
    because we pass a `std::optional<bar>` object. The second call, however, will
    involve the copy construction of a `bar` object, because `b2` is a `bar` and needs
    to be copied to a `std::optional<bar>`; a copy is made even if `bar` has move
    semantics implemented. If `bar` is a small object, this shouldn’t be of great
    concern, but for large objects, it can prove to be a performance issue. The solution
    to avoid this depends on the context and can involve creating a second overload
    that takes a constant reference to `bar`, or entirely avoiding using `std::optional`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `std::optional` makes it easier to return a value from a function that
    may also fail, chaining together multiple such functions produces code that can
    be cumbersome or at least too repetitive. To ease this scenario, in C++23, `std::optional`
    has several additional members (`transform()`, `and_then()`, and `or_else()`)
    called monadic operations. We will learn about these in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::any to store any value*, to learn how to use the C++17 class `std::any`,
    which represents a type-safe container for single values of any type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::variant as a type-safe union*, to learn how to use the C++17 `std::variant`
    class to represent type-safe unions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chaining together computations that may or may not produce a value*, to see
    how the new C++23 monadic operations of `std::optional` simplify scenarios where
    multiple functions returning `std::optional` are called sequentially'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining together computations that may or may not produce a value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have seen how to use the `std::optional` class for
    storing a value that may or may not exist. Its use cases include optional parameters
    to functions and return values from functions that may fail to produce a result.
    When multiple such functions need to be chained together, the code can become
    cumbersome and verbose. For this reason, the C++23 standard has added several
    new methods to the `std::optional` class. They are referred to by the term **monadic
    operations**. These methods are `transform()`, `and_then()`, and `or_else()`.
    In this recipe, we’ll see what they are useful for.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, in functional programming, a **monad** is a container that
    encapsulates some functionality on top of a value that it wraps. Such an example
    is `std::optional` in C++. On the other hand, a **monadic operation** is a function
    from a domain *D* into *D* itself. For instance, the **identity function** (a
    function that returns its argument) is a monadic operation. The newly added functions
    `transform()`, `and_then()`, and `or_else()` are monadic because they take a `std::optional`
    and return a `std::optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following sections, we will refer to the definitions shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following monadic operations as per your use case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an `optional` value and want to apply a function `f` and return
    the value of that invocation, then use `transform()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have an `optional` value and want to apply a function `f` that returns
    an `optional` and then return the value of that invocation, then use `and_then()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have an `optional` value that could be empty, in which case you want
    to invoke a function to handle the situation (such as to log or throw an exception)
    and return another `optional` (either an alternative value or an empty `optional`),
    then use `or_else()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A larger example is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `and_then()` and `transform()` member functions are very similar. They actually
    have the same number of overloads with the same signature. They take a single
    argument that is a function or callable object and they both return an `optional`.
    If the `optional` does not hold a value, then both `and_then()` and `transform()`
    return an empty `optional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, if the `optional` does hold a value, then it invokes the function
    or callable with the stored value. Here is where they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: The function/callable passed to `and_then()` must itself return a value of a
    type that is a specialization of `std::optional`. This will be the value returned
    by `and_then()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function/callable passed to `transform()` may have any return type that
    is not a reference type. However, the value it returns will itself be wrapped
    in a `std::optional` before being returned from `transform()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To exemplify this better, let’s consider the following function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, we have seen this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `p` has the type `std::optional<double>`. This is because `calculate_price()`
    returns a `double`, and, therefore, `transform()` will return a `std::optional<double>`.
    Let’s change the signature of `calculate_price()` to return a `std::optional<double>`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The variable `p` will now have the type `std::optional<std::optional<double>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third monadic function, `or_else()`, is the opposite of `and_then()`/`transform()`:
    if the `optional` object contains a value, it returns the `optional` without doing
    anything. Otherwise, it invokes its single argument, which is a function or callable
    without any argument, and returns the value from this invocation. The return type
    of the function/callable must be `std::optional<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `or_else()` function is typically used for handling erroneous situations
    when an expected value is missing. The supplied function could perhaps add an
    entry to a log, throw an exception, or do something else. Unless this callable
    throws an exception, it must return a value. This can be an empty `optional` or
    an `optional` holding a default value or some alternative to the missing value.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important use cases for `std::optional` is to return a value
    from a function that may or may not produce one. However, when a value is missing,
    we probably need to know the reason for the failure. This is not directly possible
    with optional, unless the stored type is a compound of a value and an error, or
    if we use additional parameters to the function to retrieve the error. For this
    reason, the C++23 standard includes an alternative for these use cases for `std::optional`,
    the `std::expected` type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::expected to return a value or an error*, to see how this C++23
    type allows us to return a value or an error code from a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::variant as a type-safe union
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, a union type is a special class type that, at any point, holds a value
    of one of its data members. Unlike regular classes, unions cannot have base classes,
    nor can they be derived, and they cannot contain virtual functions (that would
    not make sense anyway). Unions are mostly used to define different representations
    of the same data. However, unions only work for types that are **Plain Old Data**
    (**POD**). If a union contains values of non-POD types, then these members require
    explicit construction with a placement `new` and explicit destruction, which is
    cumbersome and error-prone. In C++17, a type-safe union is available in the form
    of a standard library class template called `std::variant`. In this recipe, you
    will learn how to use it to model alternative values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::variant` type implements a type-safe **discriminated union**. Although
    discussing these in detail is beyond the scope of this recipe, we will introduce
    them briefly here. Being familiar with discriminated unions will help us better
    understand the design of `variant` and the way it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discriminated unions are also called **tagged unions** or **disjoint unions**.
    A discriminated union is a data type that is able to store one value of a collection
    of types and offer type-safe access for that value. In C++, this is typically
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: For Windows programmers, a well-known discriminated union is the `VARIANT` structure
    used in **Component Object Model** (**COM)** programming.
  prefs: []
  type: TYPE_NORMAL
- en: The class template `std::variant` was designed based on `boost::variant`, and
    is available in the `<variant>` header. If you are familiar with `boost::variant`
    and have used it in your code, you can migrate your code with little effort to
    use the standard `variant` class template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following operations to work with `std::variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the stored value, use the member functions `emplace()` or `swap()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read the stored values, use the non-member functions `std::get` or `std::get_if`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To store a value, use the constructor or assign a value directly to a `variant`
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check what is the stored alternative, use the member function `index()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether a variant holds an alternative, use the non-member function
    `std::holds_alternative()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To define a variant whose first alternative is not default constructible, use
    `std::monostate` as the first alternative (in this example, `foo` is the same
    class we used earlier):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To process the stored value of a variant and do something depending on the
    type of the alternative, use `std::visit()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::variant` is a class template that models a type-safe union, holding a
    value of one of its possible alternatives at any given time. In some rare cases,
    though, it is possible that a variant object does not store any value. `std::variant`
    has a member function called `valueless_by_exception()` that returns `true` if
    the variant does not hold a value, which is possible only in case of an exception
    during initialization—therefore, the name of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: The size of a `std::variant` object is as large as its largest alternative.
    A variant does not store additional data. The value stored by the variant is allocated
    within the memory representation of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variant can hold multiple alternatives of the same type and also hold different
    constant- and volatile-qualified versions at the same time. In this case, you
    cannot assign a value of the type used multiple types, but use the `emplace()`
    member function instead, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `std::holds_alternative()` function mentioned earlier, which checks whether
    a variant holds an alternative type `T`, cannot be used in this case. You should
    avoid defining variants holding multiple alternatives of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a variant cannot hold an alternative of the type `void`,
    or alternatives of array and reference types. Moreover, the first alternative
    must always be default constructible. The reason for this is that, just like discriminated
    unions, a variant is default initialized with the value of its first alternative.
    If the first alternative type is not default constructible, then the variant must
    use `std::monostate` as the first alternative. This is an empty type indented
    for making variants default constructible.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to query a `variant` at compile time for its size (that is, the
    number of alternatives it defines) and for the type of an alternative specified
    by its zero-based index. On the other hand, you can query the index of the currently
    held alternative at runtime using the member function `index()`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical way of manipulating the content of a variant is through visitation.
    This is basically the execution of an action based on the alternative held by
    the variant. Since it is a larger topic, it is addressed separately in the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::any to store any value*, to learn how to use the C++17 class `std::any`,
    which represents a type-safe container for single values of any type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visiting a std::variant*, to understand how to perform type matching and execute
    different actions based on the type of a variant’s alternatives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visiting a std::variant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::variant` is a new standard container that was added to C++17 based on
    the `boost.variant` library. A variant is a type-safe union that holds the value
    of one of its alternative types. Although, in the previous recipe, we have seen
    various operations with variants, the variants we used were rather simple, with
    POD types mostly, which is not the actual purpose for which `std::variant` was
    created. Variants are intended to be used for holding alternatives of similar
    non-polymorphic and non-POD types. In this recipe, we will see a more real-world
    example of using variants and will learn how to visit variants.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you should be familiar with the `std::variant` type. It is
    recommended that you first read the previous recipe, *Using std::variant as a
    type-safe union*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain how variant visitation can be done, we will consider a variant for
    representing a media DVD. Let’s suppose we want to model a store or library that
    has DVDs that could contain either music, a movie, or software. However, these
    options are not modeled as a hierarchy with common data and virtual functions,
    but rather as non-related types that may have similar properties, such as a title.
    For simplicity, we’ll consider the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a movie: Title and length (in minutes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an album: Title, artist name, and a list of tracks (each track having a
    title and length in seconds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For software: Title and manufacturer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows a simple implementation of these types, without any
    functions, because that is not relevant to the visitation of a variant holding
    alternatives of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we will utilize the following function to convert text to
    uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: With these defined, let’s start looking at how visiting variants should be performed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To visit a variant, you must provide one or more actions for the possible alternatives
    of the variant. There are several types of visitors, which are used for different
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A void visitor that does not return anything but has side effects. The following
    example prints the title of each DVD to the console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A visitor that returns a value; the value should have the same type, regardless
    of the current alternative of the variant, or can itself be a variant. In the
    following example, we visit a variant and return a new variant of the same type
    that has the `title` property from any of its alternatives transformed to uppercase
    letters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A visitor that does type matching (which can either be a void or a value-returning
    visitor) implemented by providing a function object that has an overloaded call
    operator for each alternative type of the variant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A visitor that does type matching that is implemented by providing a lambda
    expression that performs an action based on the type of the alternative:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A visitor is a callable object (a function, a lambda expression, or a function
    object) that accepts every possible alternative from a variant. Visitation is
    done by invoking `std::visit()` with the visitor and one or more variant objects.
    The variants do not have to be of the same type, but the visitor must be able
    to accept every possible alternative from all the variants it is invoked for.
    In the examples earlier, we visited a single variant object, but visiting multiple
    variants does not imply anything more than passing them as arguments to `std::visit()`.
  prefs: []
  type: TYPE_NORMAL
- en: When you visit a variant, the callable object is invoked with the value currently
    stored in the variant. If the visitor does not accept an argument of the type
    stored in the variant, the program is ill-formed. If the visitor is a function
    object, then it must overload its call operator for all the possible alternative
    types of the variant. If the visitor is a lambda expression, it should be a generic
    lambda, which is basically a function object with a call operator template, instantiated
    by the compiler with the actual type that it is invoked with.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of both approaches were shown in the previous section for a type-matching
    visitor. The function object in the first example is straightforward and should
    not require additional explanations. On the other hand, the generic lambda expression
    uses *constexpr if* to select a particular `if` branch based on the type of the
    argument at compile time. The result is that the compiler will create a function
    object with an operator call template and a body that contains *constexpr if*
    statements; when it instantiates that function template, it will produce an overload
    for each possible alternative type of the variant and, in each of these overloads,
    it will select only the *constexpr if* branch that matches the type of the call
    operator argument. The result is conceptually equivalent to the implementation
    of the `visitor_functor` class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::any to store any value*, to learn how to use the C++17 class `std::any`,
    which represents a type-safe container for single values of any type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::variant as a type-safe union*, to see how to use the C++17 `std::variant`
    class to represent type-safe unions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::expected to return a value or an error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to write a function that returns both some data and an indication
    of success or failure (either as a `bool` for the simplest case or an error code
    for more complex cases). Typically, this can be solved either by returning a status
    code and using a parameter passed by reference for returning the data or by returning
    the actual data but throwing exceptions in the case of failure. In recent times,
    the availability of `std::optional` and `std::variant` gave way to new solutions
    for this problem. However, the C++23 standard provides a new approach with the
    `std::expected` type, a sort of combination of the two types previously mentioned.
    Such a type is present in other programming languages, such as `Result` in Rust
    and `Either` in Haskell. In this recipe, we will learn how to use this new `std::expected`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples shown in this recipe, we will use the data types defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `std::expected<T, E>` type from the new `<expected>` header,
    as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When returning data from a function, return either `std::unexpected<E>` to
    indicate an error, or the data (a value of `T`) when everything is executed successfully:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When checking the result of a function that returns `std::expected<T, E>`,
    use the `bool` operator (or the `has_value()` method) to check if the object holds
    the expected value, and the `value()` and `error()` methods to return the expected
    value or the unexpected error, respectively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can compose a chain of operations from functions that return a `std::expected`
    value using the monadic operations `and_then()`, `or_else()`, `transform()`, and
    `transform_error()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::expected<T, E>` class template is available in the new C++23 header
    called `<expected>`. This class is a mixture of the `std::variant` and the `std::optional`
    types (introduced in C++17) but designed for the purpose of returning data or
    an unexpected value from a function. It has the logical structure of a discriminated
    union since it either holds the value of an expected type `T`, or the value of
    an unexpected type (error) `E`. However, its interface is very similar to the
    `std::optional` class, as it features the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `has_value()` | Returns a Boolean value that indicates whether the object
    contains the expected value or not. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator bool` | Same as `has_value()`. Provided for simpler usage in `if`
    statements (`if(result)` as opposed to `if(result.has_value()`). |'
  prefs: []
  type: TYPE_TB
- en: '| `value()` | Returns the expected value, unless the object contains an unexpected
    value. In this case, it throws a `std::bad_expected_access<E>` exception, containing
    the unexpected value. |'
  prefs: []
  type: TYPE_TB
- en: '| `value_or()` | Similar to `value()` but, instead of throwing an exception
    if an unexpected value is stored in the object, it returns the supplied, alternative
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `error()` | Returns the unexpected value. If the object holds an expected
    value, then the behavior is undefined. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator->` and `operator*` | Accesses the expected value. If the object
    holds an unexpected value, then the behavior is undefined. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: A listing of the most important members of std::expected'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it was previously mentioned that the `std::expected` type is a discriminated
    union of two `T` (expected) and `E` (error) types, it is not entirely correct.
    The actual types it holds are either `T` or `std::unexpected<E>`. This latter
    type is a helper class that holds an object of type `E`. There are some restrictions
    on the possible types used for `T` and `E`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` can be either `void` or a destructible type (a type for which a destructor
    can be invoked). Arrays and reference types cannot be substituted for `T`. If
    the type `T` is the `void` type, then the `value_or()` method is not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E` must be a destructible type. Arrays, reference types, and `const` and `volatile`
    qualified types cannot be substituted for `E`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are cases when you want to apply multiple operations to a value. In our
    example, this could be applying different filters in a row to an image. But it
    could be other things such as resizing the image, changing the format/type, flipping
    in different directions, and so on. Each of these operations could return a `std::expected`
    value. In this case, we can write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error occurs, then the result of running this program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: However, if an error occurs in the `ApplyFilter()` function, invoking the `value()`
    method in the subsequent call would result in a `std::bad_expected_access` exception.
    We actually have to check the result after each operation. This can be improved
    using monadic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `std::expected` type is very similar to the `std::optional` type,
    the monadic operations available in C++23 for `std::optional` are also available
    to `std::expected`. These are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `and_then()` | If the `std::expected` object contains an expected value (of
    type `T`), then it applies a given function on it and returns the result. Otherwise,
    it returns the `std::expected` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `or_else()` | If the `std::expected` object contains an unexpected value
    (of type `E`), then it applies a given function on the unexpected value and returns
    the result. Otherwise, it returns the `std::expected` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `transform()` | This is similar to `and_then()`, except that the returned
    value is also wrapped in a `std::expected` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `transform_error()` | This is similar to `or_else()`, except that the returned
    value is also wrapped in a `std::expected` value. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: Monadic operations of std::expected'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the code from the last snippet using monadic operations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error occurs, then the output is the one we already saw. However, if
    an error occurs, let’s say when applying the sepia filter, then the output changes
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows only two of the available monadic operations, `and_then()`
    and `or_else()`. The other two, `transform()` and `transform_or()`, are similar
    but they are intended to transform (as the name implies) either the expected or
    the unexpected value into another value. In the following snippet (a modification
    of the previous one), we chain a transform operation for both the expected and
    unexpected value, in either case returning a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error occurs during the execution of this program, then the following
    output will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if an error occurs during the execution, such as when applying the
    sepia filter, then the output becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In the `or_else()` function above, you’ll have noticed the use of `std::unexpected`.
    This is a helper class that acts as a tag for the constructor of `std::expected`
    in order to indicate the construction of an unexpected value. As a result, the
    argument is perfectly forwarded to the constructor of the `E` type (the unexpected
    type). The `has_value()` method will return `false` for the newly created `std::expected`
    value, indicating that it holds an unexpected value.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::variant as a type-safe union*, to learn how to use the C++17 `std::variant`
    class to represent type-safe unions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::span for contiguous sequences of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++17, the `std::string_view` type was added to the standard library. This
    is an object that represents a view over a constant contiguous sequence of characters.
    The view is typically implemented with a pointer to the first element of the sequence
    and a length. Strings are one of the most used data types in any programming language.
    They have a non-owning view that does not allocate memory, avoids copies, and
    performs some operations faster than `std::string`, which is an important benefit.
    However, a string is just a special vector of characters with operations specific
    to text. Therefore, it makes sense to have a type that is a view of a contiguous
    sequence of objects, regardless of their type. This is what the `std::span` class
    template in C++20 represents. We could say that `std::span` is to `std::vector`
    and array types what `std::string_view` is to `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::span` class template is available in the header `<span>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `std::span<T>` instead of a pointer and size pair as you typically would
    with C-like interfaces. In other words, replace functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with `std::span`, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a span with a compile-time length (called *static extent*) by specifying
    the number of elements in the span:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a span with a runtime length (called *dynamic extent*) by not specifying
    the number of elements in the span:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use a span in a range-based for loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can access the elements of a span using the methods `front()`, `back()`,
    and `data()`, and the `operator[]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can obtain sub-spans of a span with the methods `first()`, `last()`, and
    `subspan()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::span` class template is not a container of objects but a lightweight
    wrapper that defines a view of a contiguous sequence of objects. Initially, the
    span was called `array_view`, which some argue was a better name, both because
    it clearly indicates that the type is a non-owning view of a sequence and because
    it would be consistent with the name of `string_view`. However, the type was adopted
    in the standard library under the name *span*.
  prefs: []
  type: TYPE_NORMAL
- en: Although the standard does not specify the implementation details, the span
    is typically implemented by storing a pointer to the first element of the sequence
    and a length, representing the number of elements in the view. Therefore, a span
    can be used to define a non-owning view over (but not only) a `std::vector`, `std::array`,
    `T[]`, or `T*`. However, it cannot be used with lists or associative containers
    (for instance, `std::list`, `std::map`, or `std::set`) because these are not containers
    for a contiguous sequence of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The span can have either a compile-time size or a runtime size. When the number
    of elements in the span is specified at compile-time, we have a span with a static
    extent (compile-time size). If the number of elements is not specified but determined
    at runtime, we have a dynamic extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::span` class has a simple interface, mainly consisting of the following
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `begin()`, `end()``cbegin()`, `cend()` | Mutable and constant iterators to
    the first and the one-past-last element of the sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| `rbegin()`, `rend()``cbegin()`, `crend()` | Mutable and constant reverse
    iterators to the beginning and end of the sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| `front()`, `back()` | Accesses the first and last element of the sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `data()` | Returns a pointer to the beginning of the sequence of elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `operator[]` | Accesses an element of the sequence specified by its index.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | Retrieves the number of elements in the sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| `size_bytes()` | Retrieves the size of the sequence in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | Checks whether the sequence is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `first()` | Retrieves a sub-span with the first *N* elements of the sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `last()` | Retrieves a sub-span with the last *N* elements of the sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `subspan()` | Retrieves a sub-span with *N* elements starting from a specified
    offset. If the count *N* is not specified, it returns a span with all the elements
    from offset until the end of the sequence. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: A listing of the most important member functions of std::span'
  prefs: []
  type: TYPE_NORMAL
- en: A span is not intended to be used with general-purpose algorithms that work
    with a pair of iterators to the beginning and the end of a range (such as `sort`,
    `copy`, `find_if`, and so on), nor as a replacement for standard containers. Its
    main purpose is to build better interfaces than the C-like ones where a pointer
    and a size are passed to a function. The user may pass a wrong value for the size,
    which could end in accessing memory beyond the bounds of the sequence. The span
    provides safety and bounds checking. It is also a good alternative to passing
    a constant reference as an argument to a function to `std::vector<T>` (`std::vector<T>
    const &`). The span does not own its elements and is small enough to be passed
    by value (you should not pass spans by reference or constant reference).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `std::string_view`, which does not support changing the value of the
    elements in the sequence, `std::span` defines a mutable view and supports modifying
    its elements. For this purpose, functions such as `front()`, `back()`, and `operator[]`
    return a reference.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Using string_view instead of constant string references*, to
    learn how to use `std::string_view` to improve performance in some scenarios when
    working with strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::mdspan for multidimensional views of sequences of objects*, to
    learn about the C++23 span class for multi-dimensional sequences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::mdspan for multi-dimensional views of sequences of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, *Using std::span for contiguous sequences of objects*,
    we learned about the C++20 class called `std::span`, which represents a view (a
    non-owning wrapper) over a contiguous sequence of elements. This is similar to
    the C++17 `std::string_view` class, which does the same but for a sequence of
    characters. Both of these are views of one-dimensional sequences. However, sometimes
    we need to work with multi-dimensional sequences. These could be implemented in
    many ways, such as C-like arrays (`int[2][3][4]`), pointer-of-pointers (`int**`
    or `int***`), arrays of arrays (or vectors of vectors, such as `vector<vector<vector<int>>>`).
    A different approach is to use a one-dimensional sequence of objects but define
    operations that present it as a logical multi-dimensional sequence. This is what
    the C++23 `std::mdspan` class does: it represents a non-owning view of a contiguous
    sequence of objects presented as a multi-dimensional sequence. We could say that
    `std::mdspan` is an extension of the `std::span` class for multi-dimensional views.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will refer to the following simple implementation of a two-dimensional
    matrix (whose size is known at compile time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In C++23, you should prefer to use `operator[]` instead of `operator()` to access
    elements of a multi-dimensional data structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prefer to use `std::mdspan` over multi-dimensional C-like arrays, pointer-of-pointers,
    or vector-of-vector/array-of-array implementations. In other words, replace functions
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with `std::mdspan`, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `mdspan` with a compile-time length (called **static extent**) by
    specifying the number of elements of each dimension of the span:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `mdspan` with a runtime length (called **dynamic extent**) by not
    specifying the number of elements of a dimension of the span at compile-time,
    and instead providing it at runtime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To control the mapping of the multi-dimensional indexes of an `mdspan` to the
    one-dimensional index of the underlying (contiguous) sequence of data, use a layout
    policy, which is the third template argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name implies, `mdspan` is a multi-dimensional span. That is a non-owning
    view of a one-dimensional sequence of values that is projected as a logical multi-dimensional
    structure. This is what we saw in the *Getting ready* section, where we defined
    a class called `matrix` that represents a two-dimensional matrix. The operations
    it defines (such as `operator()` and/or `operator[]` in C++23) are specific to
    a 2D data structure. However, internally, the data is laid out in a contiguous
    sequence, a `std::array` in our implementation. We can use this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This for-in-for sequence sets the values of the matrix elements to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++23, we can simply replace this entire class with the `std::mdspan` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that changes here is the use of the `extent()` method, which
    previously was a function template member of the `matrix` class. However, this
    is simply a minor detail. We can actually define `matrix` as an alias template
    for `std::mdspan`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `mdspan` is two-dimensional, but it can be defined on
    any number of dimensions. The interface of the `mdspan` type includes the following
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `operator[]` | Provides access to the elements of the underlying data. |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | Returns the number of elements. |'
  prefs: []
  type: TYPE_TB
- en: '| `empty()` | Indicates whether the number of elements is zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `stride()` | Returns the stride of the specified dimension. Unless explicitly
    customized, this is implicitly 1. |'
  prefs: []
  type: TYPE_TB
- en: '| `extents()` | Returns the size (extent) of the specified dimension. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.5: A listing of some member functions of mdspan'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the definition of the `std::mdspan` class, you will see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two template arguments are the type of the elements and the extents
    (size) of each dimension. We saw these in the previous examples. The last two,
    however, are customization points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout policies control how the multi-dimensional index of an `mdspan`
    maps to the offset in the one-dimensional underlying data. There are several options
    available: `layout_right` (the default) where the rightmost index gives stride-one
    access to the underlying memory (this is the C/C++ style); `layout_left` where
    the leftmost index gives stride-one access to the underlying memory (this is the
    Fortran and Matlab style); and `layout_stride`, which generalizes the previous
    two and allows customizing the stride on each extent. The reasons for having layout
    policies are interoperability with other languages and to change an algorithm’s
    data access pattern without changing the structure of its loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accessor policy defines how the underlying sequence stores its elements
    and how to use the offset from the layout policy to get a reference to a stored
    element. These are mostly intended for third-party libraries. It’s unlikely you
    need to implement an accessor policy for `std::mdspan`, just as it is unlikely
    you need to define an allocator for `std::vector`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s exemplify the layout policies to understand how they work. The default
    one is `std::layout_right`. We can consider this example, which explicitly specifies
    the policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The two-dimensional matrix defined here has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we change the layout policy to `std::layout_left`, then the content
    also changes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'However, different strides provide different results. Several examples are
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strides** | **Matrix** |'
  prefs: []
  type: TYPE_TB
- en: '| {0, 0} | 1 1 11 1 1 |'
  prefs: []
  type: TYPE_TB
- en: '| {0, 1} | 1 2 31 2 3 |'
  prefs: []
  type: TYPE_TB
- en: '| {1, 0} | 1 1 12 2 2 |'
  prefs: []
  type: TYPE_TB
- en: '| {1, 1} | 1 2 32 3 4 |'
  prefs: []
  type: TYPE_TB
- en: '| {2, 1} | 1 2 33 4 5 |'
  prefs: []
  type: TYPE_TB
- en: '| {1, 2} | 1 3 52 4 6 |'
  prefs: []
  type: TYPE_TB
- en: '| {2, 3} | 1 4 73 6 9 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.6: Examples of custom strides and the content of resulting views'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the last example, which is perhaps a bit more general. The stride
    of the first extent represents the offset increment for rows. The first element
    is at index 0 in the underlying sequence. Therefore, a stride of 2, as in this
    case, indicates that rows are read from indexes 0, 2, 4, and so on. The stride
    of the second extent represents the offset increment for columns. The first element
    is at the index of the corresponding row. In this example, the index for the first
    row is 0, so a stride of 3 for columns means that the elements of the first row
    will be read from the index 0, 3, and 6\. The second row starts at index 2\. Therefore,
    the elements of the second row will be read from the indexes 2, 5, and 8\. This
    is the last example shown in the previous table.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original proposal for `mdspan` included a free function called `submdspan()`.
    This function creates a slice of an `mdspan`, or, in other words, a view of a
    subset of an `mdspan`. In order to make it possible for `mdspan` to be included
    in C++23, this function was removed and moved to C++26\. At the time of writing
    this book, it has already been included in C++26, although no compiler supports
    it yet.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::span for contiguous sequences of objects*, to learn how to use
    non-owning views over contiguous sequences of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a function to be called when a program exits normally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common that a program, upon exit, must clean up code to release resources,
    write something to a log, or do some other end operation. The standard library
    provides two utility functions that enable us to register functions to be called
    when a program terminates normally, either by returning from `main()` or through
    a call to `std::exit()` or `std::quick_exit()`. This is particularly useful for
    libraries that need to perform an action before the program is terminated, without
    relying on the user to explicitly call an end function. In this recipe, you will
    learn how to install exit handlers and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the functions discussed in this recipe, `exit()`, `quick_exit()`, `atexit()`,
    and `at_quick_exit()`, are available in the namespace `std` in the header `<cstdlib>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register functions to be called upon termination of a program, you should
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::atexit()` to register functions to be invoked when they return from `main()`
    or when a call to `std::exit()` is made:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::at_quick_exit()` to register functions to be invoked when a call to `std::quick_exit()`
    is made:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exit handlers, regardless of the method they are registered with, are called
    only when the program terminates normally or quickly. If termination is done in
    an abnormal way, via a call to `std::terminate()` or `std::abort()`, none of them
    are called. If any of these handlers exits via an exception, then `std::terminate()`
    is called. Exit handlers must not have any parameters and must return `void`.
    Once registered, an exit handler cannot be unregistered.
  prefs: []
  type: TYPE_NORMAL
- en: A program can install multiple handlers. The standard guarantees that at least
    32 handlers can be registered with each method, although actual implementations
    can support any higher number. Both `std::atexit()` and `std::at_quick_exit()`
    are thread-safe and, therefore, can be called simultaneously from different threads
    without incurring race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If multiple handlers are registered, then they are called in the reverse order
    of their registration. The following table shows the output of a program that
    registered the exit handlers, as shown in the previous section, when the program
    terminates via a `std::exit()` call and a `std::quick_exit()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `std::exit(0);` | `std::quick_exit(0);` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.7: Output of the previous snippet when exiting because of a call to
    exit() and quick_exit()'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, on normal termination of the program, destruction of objects
    with local storage duration, destruction of objects with static storage duration,
    and calls to registered exit handlers are done concurrently. However, it is guaranteed
    that exit handlers registered before the construction of a static object are called
    after the destruction of that static object, and exit handlers registered after
    the construction of a static object are called before the destruction of that
    static object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better exemplify this, let’s consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, we will refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Lambda expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exit_handler_2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destructor of `static_foo`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exit_handler_1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output for the preceding program is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: When `std::at_quick_exit()` is used, the registered functions are not called
    in the case of normal program termination. If a function needs to be called in
    that case, you must register it with `std::atexit()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Using lambdas with standard algorithms*, to explore the basics
    of lambda expressions and how you can utilize them with the standard algorithms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using type traits to query properties of types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template metaprogramming is a powerful feature of the language that enables
    us to write and reuse generic code that works with all types. In practice, however,
    it is often necessary that generic code should work differently, or not at all,
    with different types, either through intent or for semantic correctness, performance,
    or other reasons. For example, you may want a generic algorithm to be implemented
    differently for POD and non-POD types or a function template to be instantiated
    only with integral types. C++11 provides a set of type traits to help with this.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits are basically meta-types that provide information about other types.
    The type traits library contains a long list of traits for querying type properties
    (such as checking whether a type is an integral type or whether two types are
    the same), but also for performing type transformation (such as removing the `const`
    and `volatile` qualifiers or adding a pointer to a type). We have used type traits
    in several recipes earlier in this book; however, in this recipe, we will look
    into what the type traits are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All type traits introduced in C++11 are available in the namespace `std` in
    the `<type_traits>` header.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits can be used in many metaprogramming contexts, and throughout this
    book, we have seen them used in various situations. In this recipe, we will summarize
    some of these use cases and see how type traits work.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss full and partial template specialization. Familiarity
    with these concepts will help you better understand the way type traits work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following list shows various situations where type traits are used to achieve
    various design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `enable_if` to define preconditions for the types a function template
    can be instantiated with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `static_assert` to ensure that invariants are met:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `std::conditional` to select between types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `constexpr if` to enable the compiler to generate different code based
    on the type the template is instantiated with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type traits are classes that provide meta-information about types or can be
    used to modify types. There are actually two categories of type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: Traits that provide information about types, their properties, or their relations
    (such as `is_integer`, `is_arithmetic`, `is_array`, `is_enum`, `is_class`, `is_const`,
    `is_trivial`, `is_standard_layout`, `is_constructible`, `is_same`, and so on).
    These traits provide a constant `bool` member called `value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits that modify properties of types (such as `add_const`, `remove_const`,
    `add_pointer`, `remove_pointer`, `make_signed`, `make_unsigned`, and so on). These
    traits provide a member typedef called `type` that represents the transformed
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of these categories of types have been shown in the *How to do it...*
    section; examples have been discussed and explained in detail in other recipes.
    For convenience, a short summary is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, the function template `multiply()` is allowed to be instantiated
    only with arithmetic types (that is, integral or floating point); when instantiated
    with a different kind of type, `enable_if` does not define a typedef member called
    `type`, which produces a compilation error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second example, `pod_wrapper` is a class template that is supposed to
    be instantiated only with POD types. A `static_assert` declaration produces a
    compilation error if a non-POD type is used (it is either not trivial or not in
    the standard layout).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third example, `const_wrapper` is a class template that provides a typedef
    member called `const_type` that represents a constant-qualified type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we used `std::conditional` to select between two types at
    compile time: if the type parameter `T` is already a const type, then we just
    select `T`. Otherwise, we use the `add_const` type trait to qualify the type with
    the `const` specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the fourth example, `process()` is a function template that contains a series
    of `if constexpr` branches. Based on the category of type, queried at compile
    time with various type traits (`is_same`, `is_integer`, `is_floating_point`),
    the compiler selects one branch only to be put into the generated code and discards
    the rest. Therefore, a call such as `process(42)` will produce the following instantiation
    of the function template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type traits are implemented by providing a class template and a partial or
    full specialization for it. The following represent conceptual implementations
    for some type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is_void()` method indicates whether a type is `void`; this uses full specialization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `is_pointer()` method indicates whether a type is a pointer to an object
    or a pointer to a function; this uses partial specialization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `enable_if()` type trait defines a type alias for its type template parameter
    if and only if its non-type template parameter is an expression that evaluates
    to `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the use of the `bool` member `value` for the traits of query properties
    (such as `std::is_integer<int>::value`), or for the member types alias called
    `type` for traits that modify type properties (such as `std::enable_if<true, T>::type`)
    is too verbose (and long), the C++14 and C++17 standards have introduced some
    helpers to simplify the use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable template of the form `std::trait_v<T>` for `std::trait<T>::value`.
    An example is `std::is_integer_v<T>`, which is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An alias template of the form `std::trait_t<T>` for `std::trait<T>::type`.
    An example is `std::enable_if_t<B, T>`, which is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that, in C++20, the concept of the POD type has been deprecated. This also
    includes the deprecation of the `std::is_pod` type trait. A POD type is a type
    that is both *trivial* (has special members that are compiler-provided or explicitly
    defaulted and occupy a contiguous memory area) and has a *standard layout* (a
    class that does not contain language features, such as virtual functions, which
    are incompatible with the C language, and all members have the same access control).
    Therefore, as of C++20, the more fine-grained concepts of trivial and standard
    layout types are preferred. This also implies that you should no longer use `std::is_pod`,
    but `std::is_trivial` and, respectively, `std::is_standard_layout`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type traits are not limited to what the standard library provides. Using similar
    techniques, you can define your own type traits to achieve various goals. In the
    next recipe, *Writing your own type traits*, we will learn how to define and use
    our own type traits.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Selecting branches at compile time with constexpr if*, to learn
    how to compile only parts of your code with *constexpr if* statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Conditionally compiling classes and functions with enable_if*,
    to learn about SFINAE and how to use it to specify type constraints for templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Performing compile-time assertion checks with static_assert*,
    to see how to define assertions that are verified at compile time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing your own type traits*, to learn how to define your own type traits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::conditional to choose between types*, to understand how to perform
    a compile-time selection of types on a compile-time Boolean expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned what type traits are, what traits the standard
    provides, and how they can be used for various purposes. In this recipe, we’ll
    go a step further and take a look at how to define our own custom traits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to solve the following problem: we have several
    classes that support serialization. Without getting into any details, let’s suppose
    some provide a “plain” serialization to a string (regardless of what that can
    mean), whereas others do it based on a specified encoding. The end goal is to
    create a single, uniform API for serializing the objects of any of these types.
    For this, we will consider the following two classes: `foo`, which provides a
    simple serialization, and `bar`, which provides serialization with encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you read the preceding *Using type traits to query properties
    of types* recipe first before you continue with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the following class and function templates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A class template called `is_serializable_with_encoding` containing a `static`
    `const` `bool` variable set to `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A full specialization of the `is_serializable_with_encoding` template for the
    class `bar` that has the `static` `const` `bool` variable set to `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A class template called `serializer` containing a static template method called
    `serialize`, which takes an argument of the template type `T` and calls `serialize()`
    for that object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A full specialization class template for `true`, whose `serialize()` static
    method calls `serialize_with_encoding()` for the argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A function template called `serialize()`, which uses the `serializer` class
    templates defined previously and the `is_serializable_with_encoding` type trait,
    to select which of the actual serialization methods (plain or with encoding) should
    be called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`is_serializable_with_encoding` is a type trait that checks whether a type
    `T` is serializable with (a specified) encoding. It provides a static member of
    the type `bool` called `value` that is equal to `true` if `T` supports serialization
    with encoding, or `false` otherwise. It is implemented as a class template with
    a single type template parameter `T`; this class template is fully specialized
    for the types that support encoded serialization—in this particular example—for
    the class `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The `serialize()` method is a function template that represents a common API
    for serializing objects that support either type of serialization. It takes a
    single argument of the type template parameter `T` and uses a helper class template
    `serializer` to call either the `serialize()` or `serialize_with_encoding()` method
    of its argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `serializer` type is a class template with a single, non-type template parameter
    of the type `bool`. This class template contains a static function template called
    `serialize()`. This function template takes a single parameter of the type template
    parameter `T`, calls `serialize()` on the argument, and returns the value returned
    from that call. The `serializer` class template has a full specialization for
    the value `true` of its non-type template parameter. In this specialization, the
    function template `serialize()` has an unchanged signature, but calls `serialize_with_encoding()`
    instead of `serialize()`.
  prefs: []
  type: TYPE_NORMAL
- en: The selection between using the generic or the fully specialized class template
    is done in the `serialize()` function template using the `is_serializable_with_encoding`
    type trait. The static member `value` of the type trait is used as the argument
    for the non-type template parameter of `serializer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that defined, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using type traits to query properties of types*, to explore a C++ meta-programming
    technique that allows us to inspect and transform properties of types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using std::conditional to choose between types*, to understand how to perform
    a compile-time selection of types on a compile-time Boolean expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::conditional to choose between types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we looked at some of the features from the type support
    library, and type traits in particular. Related topics have been discussed in
    other parts of this book, such as using `std::enable_if` to hide function overloads
    in *Chapter 4*, *Preprocessing and Compilation*, and `std::decay` to remove `const`
    and `volatile` qualifiers when we discussed visiting variants, also in this chapter.
    Another type transformation feature worth discussing to a larger extent is `std::conditional`,
    which enables us to choose between two types at compile time, based on a compile-time
    Boolean expression. In this recipe, you will learn how it works and how to use
    it through several examples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is recommended that you first read the *Using type traits to query properties
    of types* recipe, earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of examples that show you how to use `std::conditional`
    (and `std::conditional_t`), available in the `<type_traits>` header, to choose
    between two types at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a type alias or typedef to select between a 32-bit and 64-bit integer type,
    based on the platform (the pointer size is 4 bytes on 32-bit platforms and 8 bytes
    on 64-bit platforms):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In an alias template to select between an 8-, 16-, 32-, or 64-bit integer type,
    based on the user specification (as a non-type template parameter):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a type template parameter to select between an integer and real uniform
    distribution, depending on whether the type template parameter is of an integral
    or floating-point type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::conditional` is a class template that defines a member called `type`
    as either one or the other of its two type template parameters. This selection
    is done based on a compile-time constant Boolean expression provided as an argument
    for a non-type template parameter. Its implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s summarize the examples from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, if the platform is 32-bit, then the size of the pointer
    type is 4 bytes and, therefore, the compile-time expression `sizeof(void*) <=
    4` is `true`; as a result, `std::conditional` defines its member type as `long`.
    If the platform is 64-bit, then the condition evaluates to `false` because the
    size of the pointer type is 8 bytes; therefore, the member type is defined as
    `long long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A similar situation is encountered in the second example, where `std::conditional`
    is used multiple times to emulate a series of `if...else` statements to select
    an appropriate type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third example, we used the alias template `std::conditional_t` to simplify
    the declaration of the function template `GenerateRandom`. Here, `std::conditional`
    is used to define the default value for a type template parameter representing
    a statistical distribution. Depending on whether the first type template parameter
    `T` is an integral or floating-point type, the default distribution type is chosen
    between `std::uniform_int_distribution<T>` and `std::uniform_real_distribution<T>`.
    The use of other types is disabled by employing `std::enable_if` with a third
    template parameter, as we have seen in other recipes already.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To help simplify the use of `std::conditional`, C++14 provides an alias template
    called `std::conditional_t`, which we have seen in the examples here, and which
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: The use of this helper class (and the many others that are similar and from
    the standard library) is optional but helps with writing more concise code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using type traits to query properties of types*, to explore a C++ metaprogramming
    technique that allows us to inspect and transform properties of types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing your own type traits*, to learn how to define your own type traits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Conditionally compiling classes and functions with enable_if*,
    to learn about SFINAE and how to use it to specify type constraints for templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing logging details with source_location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is an essential part of software development. No matter how simple
    or complex it is, no program works as intended from the first shot. Therefore,
    developers spend a considerable amount of time debugging their code, employing
    various tools and techniques from debuggers to messages printed to a console or
    a text file. Sometimes, we want to provide detailed information about the source
    of a message in a log, including the file, the line, and maybe the function name.
    Although this was possible with some standard macros, in C++20, a new utility
    type called `std::source_location` allows us to do it in a modern way. In this
    recipe, we will learn how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To log information including the file name, line number, and function name,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a logging function with parameters for all information that you need
    to provide (such as message, severity, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add one additional parameter of the type `std::source_location` (for which you
    have to include the `<source_location>` header) with the default value `std::source_location::current()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use member functions `file_name()`, `line()`, `column()`, and `function_name()`
    to retrieve information about the source of the invocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of such a logging function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before C++20, logging information such as source file, line, and function name
    was only possible with the help of several macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__FILE__`, which expands to the name of the current file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__LINE__`, which expands to the source file line number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, all compilers supported non-standard macros including `__func__`
    / `__FUNCTION__`, which provide the name of the current function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these macros, one could write the following logging function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The macros, however, must be used from the context of the function execution,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running this function would look as follows on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++20 `std::source_line` is a better alternative for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You no longer have to rely on macros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes information about the column, not just the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used in the logging function signature, simplifying the invocation
    of the call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `log()` function defined in the *How to do it…* section can be invoked
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Although a default constructor exists, it initializes the data with default
    values. To get the correct values, you must invoke the static member function
    `current()`. This function works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When invoked directly in a function call, it initializes the data with information
    about the location of the call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used in a default member initializer, it initializes the data with information
    about the location of the constructor aggregate initialization that initializes
    the data member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used in a default argument (such as in the example shown here), it initializes
    the data with the location of the call site (function invocation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used in another context, the behavior is undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be noted that the preprocessor directive `#line` changes the source
    code line number and the file name. This affects the value returned by the macros
    `__FILE__` and `__LINE__`. The `std::source_location` is affected in the same
    manner as the standard macros by the `#line` directive.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using the stacktrace library to print the call stack*, to learn how to walk
    or print the content of the current stack trace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the stacktrace library to print the call sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to use the C++20 `std::source_location` to
    provide information about a source location for logging, testing, and debugging
    purposes. Another mechanism for debugging is represented by asserts but these
    are not always enough because we often need to know the sequence of calls that
    led to a point of execution. This is called the stack trace. The C++23 standard
    contains a new library with diagnostics utilities. This allows us to print the
    stack trace. In this recipe, you will learn how to use these diagnostics utilities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the C++23 stacktrace library to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the entire content of the stack trace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over each frame in the stack trace and print it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over each frame in the stack trace and retrieve information about it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new diagnostic utilities are available in a separate header called `<stacktrace>`.
    This header contains the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::basic_stacktrace`, which is a class template that represents a sequence
    container of stack trace entries. A type alias called `std::stacktrace` is defined
    as `std::basic_stacktrace<std::allocator<std::stacktrace_entry>>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stacktrace_entry`, which represents an evaluation in a stack trace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When discussing the call sequence, there are two terms that need to be correctly
    understood: **call stack** and **stack trace**. A call stack is the data structure
    used to store information about the active frames (calls) in a running program.
    A stack trace is a snapshot, at some moment in time, of the call stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `std::basic_stacktrace` is a container, it is not meant to be instantiated
    and filled with stack entries by the user. There are no member functions for adding
    or removing elements to the stack trace sequence; however, there are member functions
    for element access (`at()` and `operator[]`) and checking the size (`capacity()`,
    `size()`, and `max_size()`). In order to get a snapshot of the call stack, you
    must invoke the static member function `current()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The current trace can be printed in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To an output stream using the overloaded `operator<<`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To a `std::string` using the `to_string()` member function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using a formatting function such as `std::format()`. Keep in mind that no formatting
    specifier is allowed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following snippet shows an example of how a stack trace can be printed
    to the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running this program would look different based on the compiler
    and target system, but the following is an example of possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'For an entry in the trace, as seen above, we can identify three parts: the
    source file, the line number, and a description of the evaluation. These are highlighted
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: These parts can be obtained independently, using the member functions `source_file()`,
    `source_line()`, and `description()` of `std::stacktrace_entry`. The sequence
    of stack trace entries from a `stacktrace` container can be iterated using iterators
    or accessed with the member functions `at()` and `operator[]`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Providing logging details with source_location*, to learn how to use the C++20
    `source_location` class to display information about the source file, line, and
    function name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_06.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
