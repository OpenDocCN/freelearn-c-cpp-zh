- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: General-Purpose Utilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用工具
- en: 'The standard library contains many general-purpose utilities and libraries
    beyond the containers, algorithms, and iterators discussed in the previous chapter.
    This chapter is focused on three areas: the `chrono` library for working with
    dates, times, calendars, and time zones; type traits, which provide meta-information
    about other types; and utility types in newer versions of the standard, `std::any`,
    `std::optional`, and `std::variant` in C++17, `std::span` and `std::source_location`
    in C++20, and `std::mdspan` and `std::expected` in C++23.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含许多通用工具和库，这些工具和库超出了上一章中讨论的容器、算法和迭代器。本章重点介绍三个领域：用于处理日期、时间、日历和时区的 `chrono`
    库；类型特性，它提供有关其他类型的元信息；以及标准库中新版本中的实用类型，包括 C++17 中的 `std::any`、`std::optional` 和
    `std::variant`，C++20 中的 `std::span` 和 `std::source_location`，以及 C++23 中的 `std::mdspan`
    和 `std::expected`。
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的食谱如下：
- en: Expressing time intervals with `chrono::duration`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `chrono::duration` 表达时间间隔
- en: Working with calendars
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与日历一起工作
- en: Converting times between time zones
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在时区之间转换时间
- en: Measuring function execution time with a standard clock
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准时钟测量函数执行时间
- en: Generating hash values for custom types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义类型生成哈希值
- en: Using `std::any` to store any value
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::any` 存储任何值
- en: Using `std::optional` to store optional values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::optional` 存储可选值
- en: Chaining together computations that may or may not produce a value
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接可能或可能不产生值的计算
- en: Using `std::variant` as a type-safe union
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::variant` 作为类型安全的联合体
- en: Visiting a `std::variant`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 `std::variant`
- en: Using `std::expected` to return a value or an error
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::expected` 返回值或错误
- en: Using `std::span` for contiguous sequences of objects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::span` 处理对象的连续序列
- en: Using `std::mdspan` for multi-dimensional views of sequences of objects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::mdspan` 处理对象序列的多维视图
- en: Registering a function to be called when a program exits normally
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个在程序正常退出时调用的函数
- en: Using type traits to query properties of types
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型特性查询类型的属性
- en: Writing your own type traits
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的类型特性
- en: Using `std::conditional` to choose between types
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::conditional` 在类型之间进行选择
- en: Providing logging details with `source_location`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `source_location` 提供日志细节
- en: Using the `stacktrace` library to print the call sequence
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `stacktrace` 库打印调用序列
- en: The first part of the chapter focuses on the `chrono` library, which provides
    time and date utilities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分重点介绍 `chrono` 库，它提供了时间和日期工具。
- en: Expressing time intervals with chrono::duration
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `chrono::duration` 表达时间间隔
- en: 'Working with times and dates is a common operation, regardless of the programming
    language. C++11 provides a flexible date and time library as part of the standard
    library that enables us to define time points and time intervals. This library,
    called `chrono`, is a general-purpose utility library designed to work with a
    timer and clocks that can be different on different systems and, therefore, precision-neutral.
    The library is available in the `<chrono>` header in the `std::chrono` namespace
    and defines and implements several components, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论编程语言如何，处理时间和日期都是一项常见操作。C++11 提供了一个灵活的日期和时间库作为标准库的一部分，使我们能够定义时间点和时间间隔。这个名为
    `chrono` 的库是一个通用工具库，旨在与不同系统上可能不同的计时器和时钟一起工作，因此是精度中立的。该库在 `<chrono>` 头文件中的 `std::chrono`
    命名空间中可用，并定义和实现了以下组件：
- en: '*Durations*, which represent time intervals'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续时间*，表示时间间隔'
- en: '*Time points*, which present a duration of time since the epoch of a clock'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间点*，表示自时钟纪元以来的时间长度'
- en: '*Clocks*, which define an epoch (that is, the start of time) and a tick'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时钟*，定义了一个纪元（即时间的开始）和一个滴答'
- en: In this recipe, we will learn how to work with durations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何处理持续时间。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is not intended as a complete reference to the `duration` class.
    It is recommended that you consult additional resources for that purpose (the
    library reference documentation is available at [http://en.cppreference.com/w/cpp/chrono](http://en.cppreference.com/w/cpp/chrono)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱并非 `duration` 类的完整参考。建议您咨询其他资源以获取相关信息（库参考文档可在 [http://en.cppreference.com/w/cpp/chrono](http://en.cppreference.com/w/cpp/chrono)
    获取）。
- en: In the `chrono` library, a time interval is represented by the `std::chrono::duration`
    class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chrono` 库中，时间间隔由 `std::chrono::duration` 类表示。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To work with time intervals, use the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理时间间隔，请使用以下方法：
- en: '`std::chrono::duration` typedefs for hours, minutes, seconds, milliseconds,
    microseconds, and nanoseconds:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::duration` 的小时、分钟、秒、毫秒、微秒和纳秒类型别名：'
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the standard user-defined literal operators from C++14, available in the
    namespace `std::chrono_literals`, to create durations of hours, minutes, seconds,
    milliseconds, microseconds, and nanoseconds:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++14 中可用的标准用户定义字面量运算符，在 `std::chrono_literals` 命名空间中创建小时、分钟、秒、毫秒、微秒和纳秒的持续时间：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use direct conversion from a lower precision duration to a higher precision
    duration:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从低精度持续时间到高精度持续时间的直接转换：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use `std::chrono::duration_cast` to convert from a higher precision to a lower
    precision duration:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::chrono::duration_cast` 将高精度持续时间转换为低精度持续时间：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the chrono conversion functions `floor()`, `round()`, and `ceil()` available
    in the `std::chrono` namespace in C++17 when rounding is necessary (not to be
    confused with the `std::floor()`, `std::round()`, and `std::ceil()` functions
    from the `<cmath>` header):'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++17 中，当需要四舍五入时，使用 `std::chrono` 命名空间中可用的 `floor()`、`round()` 和 `ceil()`
    转换函数（不要与 `<cmath>` 头文件中的 `std::floor()`、`std::round()` 和 `std::ceil()` 函数混淆）：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use arithmetic operations, compound assignments, and comparison operations
    to modify and compare time intervals:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用算术运算、复合赋值和比较运算来修改和比较时间间隔：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::chrono::duration` class defines a number of ticks (the increment between
    two moments in time) over a unit of time. The default unit is the second, and
    for expressing other units, such as minutes or milliseconds, we need to use a
    ratio. For units greater than a second, the ratio is greater than one, such as
    `ratio<60>` for minutes. For units smaller than a second, the ratio is smaller
    than one, such as `ratio<1, 1000>` for milliseconds. The number of ticks can be
    retrieved with the `count()` member function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::duration` 类定义了时间单位上的多个刻度（两个时间点之间的增量）。默认单位是秒，对于表示其他单位，如分钟或毫秒，我们需要使用一个比率。对于大于秒的单位，比率大于一，例如
    `ratio<60>` 用于分钟。对于小于秒的单位，比率小于一，例如 `ratio<1, 1000>` 用于毫秒。刻度的数量可以通过 `count()` 成员函数检索。'
- en: 'The standard library defines several type synonyms for durations of nanoseconds,
    microseconds, milliseconds, seconds, minutes, and hours, which we used in the
    first example in the previous section. The following code shows how these durations
    are defined in the `chrono` namespace:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库为纳秒、微秒、毫秒、秒、分钟和小时的持续时间定义了几个类型别名，我们在上一节的第一例中使用了这些别名。以下代码显示了这些持续时间在 `chrono`
    命名空间中的定义：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, with this flexible definition, we can express time intervals such
    as *1.2 sixths of a minute* (which means 12 seconds), where 1.2 is the number
    of ticks of the duration and `ratio<10>` (as in 60/6) is the time unit:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有了这种灵活的定义，我们可以表示像 *1.2 六分之一的分钟*（这意味着 12 秒）这样的时间间隔，其中 1.2 是持续时间的刻度数，`ratio<10>`（如
    60/6）是时间单位：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In C++14, several standard user-defined literal operators have been added to
    the namespace `std::chrono_literals`. This makes it easier to define durations,
    but you must include the namespace in the scope where you want to use the literal
    operators.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++14 中，`std::chrono_literals` 命名空间中添加了几个标准用户定义字面量运算符。这使得定义持续时间变得更容易，但您必须将命名空间包含在您想要使用字面量运算符的作用域中。
- en: You should only include namespaces for user-defined literal operators in the
    scope where you want to use them, and not in larger scopes, in order to avoid
    conflict with other operators with the same name from different libraries and
    namespaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该只将用户定义字面量运算符的作用域包含在您想要使用它们的作用域中，而不是在更大的作用域中，以避免与其他库和命名空间中具有相同名称的运算符冲突。
- en: All arithmetic operations are available for the `duration` class. It is possible
    to add and subtract durations, multiply or divide them by a value, or apply the
    `modulo` operation. However, it is important to note that when two durations of
    different time units are added or subtracted, the result is a duration of the
    greatest common divisor of the two time units. This means that if you add a duration
    representing seconds and a duration representing minutes, the result is a duration
    representing seconds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有算术运算都适用于 `duration` 类。可以添加和减去持续时间，将它们乘以或除以一个值，或者应用 `modulo` 操作。然而，需要注意的是，当两个不同时间单位的持续时间相加或相减时，结果是这两个时间单位最大公约数的持续时间。这意味着如果您将表示秒的持续时间和表示分钟的持续时间相加，结果是表示秒的持续时间。
- en: Conversion from a duration with a less precise time unit to a duration with
    a more precise time unit is done implicitly. On the other hand, conversion from
    a more precise to a less precise time unit requires an explicit cast. This is
    done with the non-member function `std::chrono::duration_cast()`. In the *How
    to do it...* section, you saw an example for determining the number of hours,
    minutes, and seconds of a given duration expressed in seconds.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从具有较不精确时间单位的持续时间到具有更精确时间单位的持续时间的转换是隐式进行的。另一方面，从更精确的时间单位到较不精确的时间单位的转换需要一个显式的转换。这可以通过非成员函数
    `std::chrono::duration_cast()` 来完成。在 *如何做...* 部分中，您看到了一个确定以秒为单位的给定持续时间的小时、分钟和秒数的示例。
- en: 'C++17 has added several more non-member conversion functions that perform duration
    casting with rounding: `floor()` to round down, `ceil()` to round up, and `round()`
    to round to the nearest. Also, C++17 added a non-member function called `abs()`
    to retain the absolute value of a duration.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 添加了几个更多的非成员转换函数，它们执行带有舍入的持续时间转换：`floor()` 用于向下舍入，`ceil()` 用于向上舍入，`round()`
    用于四舍五入到最接近的。此外，C++17 还添加了一个名为 `abs()` 的非成员函数，用于保留持续时间的绝对值。
- en: There’s more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: '`chrono` is a general-purpose library that, before C++20, lacked many useful
    features, such as expressing a date with the year, month, and day parts, working
    with time zones and calendars, and others. The C++20 standard added support for
    calendars and time zones, which we will see in the following recipes. If you use
    a compiler that doesn’t support these C++20 additions, then third-party libraries
    can implement these features, and a recommended one is Howard Hinnant’s `date`
    library, available under the MIT license at [https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date).
    This library was the foundation for the C++20 `chrono` additions.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，`chrono` 是一个通用库，它缺乏许多有用的功能，例如使用年、月和日部分表达日期，处理时区和日历，以及其他功能。C++20 标准添加了对日历和时区的支持，我们将在下面的食谱中看到。如果您使用不支持这些
    C++20 新增功能的编译器，那么第三方库可以实现这些功能，其中一个推荐的是 Howard Hinnant 的 `date` 库，可在 MIT 许可证下在
    [https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date)
    找到。这个库是 C++20 `chrono` 新增功能的基础。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Measuring function execution time with a standard clock*, to see how you can
    determine the execution time of a function'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标准时钟测量函数执行时间*，了解您如何确定函数的执行时间'
- en: '*Working with calendars*, to discover the C++20 additions to the `chrono` library
    for working with dates and calendars'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用日历*，发现 C++20 对 `chrono` 库在处理日期和日历方面的新增功能'
- en: '*Converting times between time zones*, to learn how you can convert time points
    between different time zones in C++20'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在时区之间转换时间*，了解如何在 C++20 中转换不同时区的时间点'
- en: Working with calendars
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日历
- en: 'The `chrono` library, available in C++11, offered support for clocks, time
    points, and durations but did not make it easy to express times and dates, especially
    with respect to calendars and time zones. The new C++20 standard corrects this
    by extending the existing `chrono` library with:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 中可用的 `chrono` 库提供了对时钟、时间点和持续时间的支持，但并没有使表达时间和日期变得容易，尤其是在日历和时区方面。新的 C++20
    标准通过扩展现有的 `chrono` 库来纠正这一点，包括：
- en: More clocks, such as a UTC clock, an International Atomic Time clock, a GPS
    clock, a file time clock, and a pseudo-clock representing local time.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多时钟，例如 UTC 时钟、国际原子时时钟、GPS 时钟、文件时间时钟以及表示本地时间的伪时钟。
- en: Time of day, representing the time elapsed since midnight split into hours,
    minutes, and seconds.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白天时间，表示从午夜开始经过的小时、分钟和秒。
- en: Calendars, which enable us to express dates with year, month, and day parts.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历，它使我们能够使用年、月和日部分来表达日期。
- en: Time zones, which enable us to express time points with respect to a time zone
    and make it possible to convert times between different time zones.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区，它使我们能够根据时区表达时间点，并使在不同时区之间转换时间成为可能。
- en: I/O support for parsing chrono objects from a stream.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对从流中解析 chrono 对象的 I/O 支持。
- en: In this recipe, we will learn about working with calendar objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用日历对象。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the new chrono functionalities are available in the same `std::chrono` and
    `std::chrono_literals` namespaces in the `<chrono>` header.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的 chrono 功能都可在 `<chrono>` 头文件中的相同 `std::chrono` 和 `std::chrono_literals`
    命名空间中找到。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'You can use the C++20 chrono calendar functionalities to:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 C++20 的 chrono 日历功能来：
- en: 'Represent Gregorian calendar dates with year, month, and day, as instances
    of the `year_month_day` type. Use the standard user-defined literals, constants,
    and the overloaded operator `/` to construct such objects:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `year_month_day` 类型的实例表示格里高利日历日期。使用标准用户定义的文法、常量和重载的运算符 `/` 来构造这样的对象：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Represent the *n*th weekday of a specific year and month as instances of the
    `year_month_weekday` type:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `year_month_weekday` 类型的实例表示特定年份和月份的第 *n* 个工作日：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Determine the current date, as well as compute other dates from it, such as
    the dates for tomorrow and yesterday:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定当前日期，并从中计算其他日期，例如明天和昨天的日期：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Determine the first and last day of a specific month and year:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定特定月份和年份的第一天和最后一天：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compute the number of days between two dates:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个日期之间的天数：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Check whether a date is valid:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查一个日期是否有效：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Represent the time of day with hour, minutes, and seconds using the `hh_mm_ss<Duration>`
    class template, where `Duration` determines the precision used to split a time
    interval. In the next example, `std::chrono::seconds` defines a split precision
    of 1 second:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `hh_mm_ss<Duration>` 类模板以小时、分钟和秒表示一天中的时间，其中 `Duration` 决定了分割时间间隔的精度。在下一个示例中，`std::chrono::seconds`
    定义了1秒的分割精度：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create time points with date and time parts:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含日期和时间部分的时点：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Determine the current time of day and express it with various precisions:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定当前一天的时间并使用各种精度表示它：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `year_month_day` and `year_month_weekday` types we have seen in the examples
    here are only some of the many new types added to the `chrono` library for calendar
    support. The following table lists all these types in the `std::chrono` namespace
    and what they represent:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里示例中看到的 `year_month_day` 和 `year_month_weekday` 类型只是添加到 `chrono` 库以支持日历的许多新类型中的一部分。以下表格列出了
    `std::chrono` 命名空间中的所有这些类型以及它们所表示的内容：
- en: '| **Type** | **Represents** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **表示** |'
- en: '| `day` | A day of a month |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `day` | 一个月中的某一天 |'
- en: '| `month` | A month of a year |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `month` | 年份中的月份 |'
- en: '| `year` | A year in the Gregorian calendar |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `year` | 格里高利日历中的年份 |'
- en: '| `weekday` | A day of the week in the Gregorian calendar |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `weekday` | 格里高利日历中的星期几 |'
- en: '| `weekday_indexed` | The *n*th weekday of a month, where *n* is in the range
    [1, 5] (1 is the 1st weekday of the month and 5 is the 5th—if it exists—weekday
    of the month) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `weekday_indexed` | 一个月中的第 *n* 个工作日，其中 *n* 在范围 [1, 5] 内（1是月份的第一天，5是月份的第5天——如果存在的话）|'
- en: '| `weekday_last` | The last weekday of a month |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `weekday_last` | 一个月中的最后一个工作日 |'
- en: '| `month_day` | A specific day of a specific month |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `month_day` | 特定月份的特定一天 |'
- en: '| `month_day_last` | The last day of a specific month |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `month_day_last` | 特定月份的最后一天 |'
- en: '| `month_weekday` | The *n*th weekday of a specific month |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `month_weekday` | 特定月份的第 *n* 个工作日 |'
- en: '| `month_weekday_last` | The last weekday of a specific month |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `month_weekday_last` | 特定月份的最后一个工作日 |'
- en: '| `year_month` | A specific month of a specific year |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `year_month` | 特定年份的特定月份 |'
- en: '| `year_month_day` | A specific year, month, and day |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `year_month_day` | 特定年份、月份和日期 |'
- en: '| `year_month_day_last` | The last day of a specific year and month |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `year_month_day_last` | 特定年份和月份的最后一天 |'
- en: '| `year_month_weekday` | The *n*th weekday of a specific year and month |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `year_month_weekday` | 特定年份和月份的第 *n* 个工作日 |'
- en: '| `year_month_weekday_last` | The last weekday of a specific year and month
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `year_month_weekday_last` | 特定年份和月份的最后一个工作日 |'
- en: 'Table 6.1: C++20 chrono types for working with dates'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：C++20用于处理日期的chrono类型
- en: 'All the types listed in this table have:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中列出的所有类型都具有：
- en: A default constructor that leaves the member fields uninitialized
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数，该构造函数将成员字段初始化为未初始化状态
- en: Member functions to access the parts of the entity
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员函数用于访问实体的各个部分
- en: A member function called `ok()` that checks if the stored value is valid
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `ok()` 的成员函数，用于检查存储的值是否有效
- en: Non-member comparison operators to compare values of the type
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非成员比较运算符，用于比较该类型值的比较
- en: An overloaded `operator<<` to output a value of the type to a stream
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重载的 `operator<<` 运算符，用于将类型的值输出到流中
- en: An overloaded function template called `from_stream()` that parses a value from
    a stream according to the provided format
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重载的函数模板 `from_stream()`，它根据提供的格式从流中解析值
- en: A specialization of the `std::formatter<T, CharT>` class template for the text
    formatting library
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文本格式化库的 `std::formatter<T, CharT>` 类模板进行特化
- en: 'In addition, the `operator/` is overloaded for many of these types to enable
    us to easily create Gregorian calendar dates. When you create a date (with year,
    month, and day), you can choose between three different formats:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些类型的许多操作符被重载，以便我们能够轻松创建格里高利日历日期。当创建日期（包含年、月和日）时，您可以选择三种不同的格式：
- en: '**year/month/day** (used in countries such as China, Japan, Korea, and Canada,
    but others too, sometimes together with the day/month/year format)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**年/月/日**（在中国、日本、韩国、加拿大等国家使用，但还有其他国家，有时与月/日/年格式一起使用）'
- en: '**month/day/year** (used in the USA)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**月/日/年**（在美国使用）'
- en: '**day/month/year** (used in most parts of the world)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**月/日/年**（在世界上大多数地区使用）'
- en: 'In these cases, **day** can be either:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，**日**可以是：
- en: An actual day of the month (values from 1 to 31)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的月份中的某一天（值从 1 到 31）
- en: '`std:chrono::last` to indicate the last day of the month'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::last`，表示月份的最后一天'
- en: '`weekday[n]`, to indicate the *n*th weekday of the month (where *n* can take
    values from 1 to 5)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weekday[n]`，表示月份的第 *n* 个工作日（其中 *n* 可以取 1 到 5 的值）'
- en: '`weekday[std::chrono::last]`, to indicate the last weekday of the month'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weekday[std::chrono::last]`，表示月份的最后一天'
- en: 'In order to disambiguate between integers that represent the day, month, and
    year, the library provides two user-defined literals: `""y` to construct a literal
    of the type `std::chrono::year`, and `""d` to construct a literal of the type
    `std::chrono::day`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分表示日期、月份和年份的整数，库提供了两个用户定义的文法：`""y` 用于构造 `std::chrono::year` 类型的文法，`""d` 用于构造
    `std::chrono::day` 类型的文法。
- en: 'In addition, there are constants that represent:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些表示以下内容的常量：
- en: A `std::chrono::month`, named `January`, `February`, up to `December`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::month`，命名为 `January`、`February` 一直到 `December`。'
- en: A `std::chrono::weekday`, named `Sunday`, `Monday`, `Tuesday`, `Wednesday`,
    `Thursday`, `Friday`, or `Saturday`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::weekday`，命名为 `Sunday`、`Monday`、`Tuesday`、`Wednesday`、`Thursday`、`Friday`
    或 `Saturday`。'
- en: You can use all these to construct dates such as `2025y/April/1`, `25d/December/2025`,
    or `Sunday[last]/May/2025`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用所有这些来构造日期，例如 `2025y/April/1`、`25d/December/2025` 或 `Sunday[last]/May/2025`。
- en: The `year_month_day` type provides implicit conversion to and from `std::chrono::sys_days`.
    This type is a `std::chrono::time_point` with the precision of a day (24 hours).
    There is a companion type called `std::chrono::sys_seconds`, which is a `time_point`
    with a precision of one second. Explicit conversion between `time_point` and `sys_days`
    / `sys_seconds` can be performed using `std::chrono::time_point_cast()` or `std::chrono::floor()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`year_month_day` 类型提供了到 `std::chrono::sys_days` 的隐式转换。这种类型是一个精度为一天的 `std::chrono::time_point`。有一个伴随类型称为
    `std::chrono::sys_seconds`，它是一个精度为一秒的 `time_point`。可以使用 `std::chrono::time_point_cast()`
    或 `std::chrono::floor()` 来执行 `time_point` 和 `sys_days` / `sys_seconds` 之间的显式转换。'
- en: To represent a moment of time during a day, we can use the `std::chrono::hh_mm_ss`
    type. This class represents the time elapsed since midnight, broken down into
    hours, minutes, seconds, and sub-seconds. This type is mostly intended as a formatting
    tool.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一天中的某个时刻，我们可以使用 `std::chrono::hh_mm_ss` 类型。这个类表示自午夜以来经过的时间，分解为小时、分钟、秒和毫秒。这个类型主要用作格式化工具。
- en: 'There are also several utility functions for translating between 12h/24h formats.
    These functions are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些实用函数用于在 12 小时/24 小时格式之间转换。这些函数包括：
- en: '`is_am()` and `is_pm()` that check whether a 24-hour formatted time (provided
    as a `std::chrono::hours` value) is A.M. (before midday) or, respectively, P.M.
    (before midnight):'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_am()` 和 `is_pm()` 函数用于检查以 24 小时格式表示的时间（作为 `std::chrono::hours` 值提供）是上午（中午之前）还是下午（午夜之前）：'
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`make12()` and `make24()` that return the 12-hour equivalent of a 24-hour format
    time and, respectively, vice versa. They both take the input time as a `std::chrono::hours`
    value, but `make24()` has an additional parameter, a Boolean indicating whether
    the time is P.M.:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make12()` 和 `make24()` 函数返回 24 小时格式的 12 小时等效时间，反之亦然。它们都接受输入时间作为 `std::chrono::hours`
    值，但 `make24()` 有一个额外的参数，一个布尔值，表示时间是否为下午：'
- en: '[PRE18]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from these examples, these four functions only work with an hour
    value, since only the hour part of a moment of time determines its format as 12h
    or 24h or whether it’s an A.M. or P.M. time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些示例中看到的，这四个函数仅适用于小时值，因为只有时间点的小时部分决定了其格式为 12 小时或 24 小时，或者是否为上午或下午时间。
- en: At the time of publishing the second edition of this book, the chrono changes
    were not completed. The `hh_mm_ss` type was called `time_of_day`, and the `make12()`/`make_24()`
    functions were members of it. This edition reflects the changes and utilizes the
    standardized API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书第二版出版时，chrono的变化尚未完成。`hh_mm_ss`类型被称为`time_of_day`，而`make12()`/`make_24()`函数是其成员。这一版反映了这些变化并利用了标准化的API。
- en: There’s more…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The date and time facilities described here are all based on the `std::chrono::system_clock`.
    Since C++20, this clock is defined to measure the Unix time, which is the time
    since 00:00:00 UTC on 1 January 1970\. This means the implicit time zone is UTC.
    However, in most cases, you might be interested in the local time of a specific
    time zone. To help with that, the `chrono` library added support for time zones,
    which is what we will learn about in the next recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的日期和时间功能都是基于`std::chrono::system_clock`。自C++20起，此时钟被定义为测量Unix时间，即自1970年1月1日00:00:00
    UTC以来的时间。这意味着隐含的时间区域是UTC。然而，在大多数情况下，你可能对特定时区的地方时间感兴趣。为了帮助解决这个问题，`chrono`库增加了对时区的支持，这是我们将在下一个菜谱中学习的。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Expressing time intervals with chrono::duration*, to familiarize yourself
    with the fundamentals of the C++11 `chrono` library and to work with durations,
    time points, and points'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用chrono::duration表示时间间隔*，以熟悉C++11 `chrono`库的基本原理，并处理持续时间、时间点和时间点'
- en: '*Converting times between time zones*, to learn how you can convert time points
    between different time zones in C++20'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同时区之间转换时间*，了解如何在C++20中转换不同时区之间的时间点'
- en: Converting times between time zones
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同时区之间转换时间
- en: In the previous recipe, we talked about C++20 support for working with calendars
    and expressing dates in the Gregorian calendar with the `year_month_day` type
    and others from the `chrono` library.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们讨论了C++20对处理日历以及使用`year_month_day`类型和其他来自`chrono`库的类型在格里高利历中表示日期的支持。
- en: We also saw how to represent times of day with the `hh_mm_ss` type. However,
    in all these examples, we worked with the time points using the system clock,
    which measures Unix time and, therefore, uses UTC as the default time zone. However,
    we are usually interested in the local time and, sometimes, in the time in some
    other time zone. This is possible with the facilities added to the `chrono` library
    to support time zones. In this recipe, you will learn about the most important
    functionalities of chrono’s time zones.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用`hh_mm_ss`类型表示一天中的时间。然而，在所有这些示例中，我们使用系统时钟处理时间点，该时钟测量Unix时间，因此默认使用UTC作为时区。然而，我们通常对本地时间感兴趣，有时对其他时区的时间感兴趣。这是通过添加到`chrono`库以支持时区的功能实现的。在本菜谱中，你将了解chrono时区最重要的功能。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before continuing with this recipe, it is recommended that you read the previous
    one, *Working with calendars*, if you have not done so already.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本菜谱之前，如果你还没有阅读，建议你阅读上一个菜谱，*处理日历*。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You can do the following using the C++20 `chrono` library:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用C++20的`chrono`库执行以下操作：
- en: Use the `std::chrono::current_zone()` to retrieve the local time zone from the
    time zone database.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::chrono::current_zone()`从时区数据库中检索本地时区。
- en: Use `std::chrono::locate_zone()` to retrieve a particular time zone, using its
    name, from the time zone database.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::chrono::locate_zone()`通过其名称从时区数据库中检索特定时区。
- en: Represent a time point in a particular time zone using the `std::chrono::zoned_time`
    class template.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::chrono::zoned_time`类模板在特定时区中表示时间点。
- en: 'Retrieve and display the current local time:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索并显示当前本地时间：
- en: '[PRE19]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Retrieve and display the current time in another time zone. In the following
    example, we use the time in Italy:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索并显示另一个时区的当前时间。在以下示例中，我们使用意大利的时间：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Display the current local time with proper locale formatting. In this example,
    the current time is Romanian time, and the locale being used is for Romania:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的区域设置格式显示当前本地时间。在这个例子中，当前时间是罗马尼亚时间，使用的区域设置是为罗马尼亚设计的：
- en: '[PRE21]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Represent a time point in a particular time zone and display it. In the following
    example, this is New York’s time:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定时区中表示一个时间点并显示它。在以下示例中，这是纽约的时间：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Convert a time point in a particular time zone into a time point in another
    time zone. In the following example, we convert the time from New York into the
    time in Los Angeles:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特定时区的时间点转换为另一个时区的时间点。在以下示例中，我们将纽约的时间转换为洛杉矶的时间：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The system maintains a copy of the IANA Time Zone (TZ) database (which is available
    online at [https://www.iana.org/time-zones](https://www.iana.org/time-zones)).
    As a user, you cannot create or alter the database but only retrieve a read-only
    copy of it with functions such as `std::chrono::tzdb()` or `std::chrono::get_tzdb_list()`.
    Information about a time zone is stored in a `std::chrono::time_zone` object.
    Instances of this class cannot be created directly; they are only created by the
    library when initializing the time zone database. However, it is possible to obtain
    constant access to these instances, using two functions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 系统维护 IANA 时间区域（TZ）数据库的副本（可在[https://www.iana.org/time-zones](https://www.iana.org/time-zones)在线找到）。作为用户，您不能创建或修改数据库，但可以使用
    `std::chrono::tzdb()` 或 `std::chrono::get_tzdb_list()` 等函数检索其只读副本。时间区域的信息存储在 `std::chrono::time_zone`
    对象中。这个类的实例不能直接创建；它们仅在库初始化时间区域数据库时创建。然而，可以使用两个函数获得对这些实例的常量访问：
- en: '`std::chrono::current_zone()` retrieves the `time_zone` object representing
    the local time zone.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::current_zone()` 获取表示本地时间区域的 `time_zone` 对象。'
- en: '`std::chrono::locate_zone()`retrieves the `time_zone` object representing the
    specified time zone.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::locate_zone()` 获取表示指定时间区域的 `time_zone` 对象。'
- en: Examples of time zone names include Europe/Berlin, Asia/Dubai, and America/Los_Angeles.
    When the name of the location contains multiple words, spaces are replaced by
    an underscore (`_`), such as in the preceding example where Los Angeles is written
    as Los_Angeles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 时间区域名称的示例包括 Europe/Berlin、Asia/Dubai 和 America/Los_Angeles。当位置名称包含多个单词时，空格被下划线（`_`）替换，例如在先前的示例中，洛杉矶被写作
    Los_Angeles。
- en: A list of all the time zones from the IANA TZ database can be found at [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自 IANA TZ 数据库的时间区域列表可以在[https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)找到。
- en: 'There are two sets of types in the C++20 `chrono` library to represent time
    points:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 的 `chrono` 库中有两套类型来表示时间点：
- en: '`sys_days` and `sys_seconds` (having day and second precision) represent a
    time point in the system’s time zone, which is UTC. These are type aliases for
    `std::chrono::sys_time`, which, in turn, is an alias for `std::chrono::time_point`,
    which is using the `std::chrono::system_clock`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys_days` 和 `sys_seconds`（具有天和秒的精度）表示系统时间区域中的时间点，该时间区域是 UTC。这些是 `std::chrono::sys_time`
    的类型别名，而 `std::chrono::sys_time` 又是 `std::chrono::time_point` 的别名，它使用 `std::chrono::system_clock`。'
- en: '`local_days` and `local_seconds` (having also day and second precision) represent
    a time point with respect to a time zone that has not yet been specified. These
    are type aliases for `std::chrono::local_time`, which is, in turn, a type alias
    for a `std::chrono::time_point` using the `std::chrono::local_t` pseudo-clock.
    The sole purpose of this clock is to indicate a not-yet-specified time zone.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_days` 和 `local_seconds`（也具有天和秒的精度）表示相对于尚未指定的时间区域的时间点。这些是 `std::chrono::local_time`
    的类型别名，而 `std::chrono::local_time` 又是使用 `std::chrono::local_t` 伪时钟的 `std::chrono::time_point`
    的类型别名。这个时钟的唯一目的是指示尚未指定的时间区域。'
- en: 'The `std::chrono::zoned_time` class template represents a pairing of a time
    zone with a time point. It can be created from either a `sys_time`, a `local_time`,
    or another `zoned_time` object. Examples of all these cases are shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::zoned_time` 类模板表示时间区域与时间点的配对。它可以由 `sys_time`、`local_time` 或另一个
    `zoned_time` 对象创建。这里展示了所有这些情况的示例：'
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this sample code, the times in the comments are based on the Romanian time
    zone. Notice that, in the first example, the time is expressed with `sys_days`,
    which uses the UTC time zone. Since Romanian time is UTC+3 on 10 May 2024 (because
    of Daylight Saving Time), the local time is 17:20:30\. In the second example,
    the time is specified with `local_days`, which is time zone-agnostic. For this
    reason, when pairing with the current time zone, the time is actually 14:20:30\.
    In the third and last example, the local Romanian time is converted to the time
    in Paris, which is 13:20:30 (because on that day, the time in Paris was UTC+2).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例代码中，注释中的时间基于罗马尼亚时间区域。请注意，在第一个示例中，时间使用 `sys_days` 表示，它使用 UTC 时间区域。由于罗马尼亚时间在
    2024 年 5 月 10 日（因为夏令时）是 UTC+3，所以本地时间是 17:20:30。在第二个示例中，时间使用 `local_days` 指定，它是与时间区域无关的。因此，当与当前时间区域配对时，实际时间是
    14:20:30。在第三个和最后一个示例中，将本地罗马尼亚时间转换为巴黎时间，巴黎时间是 13:20:30（因为那天巴黎的时间是 UTC+2）。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Expressing time intervals with chrono::duration*, to familiarize yourself
    with the fundamentals of the C++11 `chrono` library and to work with durations,
    time points, and points'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 chrono::duration 表达时间间隔*，以熟悉 C++11 `chrono` 库的基本知识，并处理持续时间、时间点和点'
- en: '*Working with calendars*, to discover the C++20 additions to the `chrono` library
    for working with dates and calendars'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用日历*，以发现 C++20 对 `chrono` 库中用于处理日期和日历的添加'
- en: Measuring function execution time with a standard clock
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准时钟测量函数执行时间
- en: In the previous recipe, we saw how to work with time intervals using the `chrono`
    standard library. However, we also often need to handle time points. The `chrono`
    library provides such a component, representing a duration of time since the epoch
    of a clock (that is, the beginning of time as defined by a clock). In this recipe,
    we will learn how to use the `chrono` library and time points to measure the execution
    of a function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们看到了如何使用 `chrono` 标准库处理时间间隔。然而，我们还需要处理时间点。`chrono` 库提供了一个这样的组件，表示自时钟纪元以来的时间长度（即，时钟定义的时间的起点）。在这个菜谱中，我们将学习如何使用
    `chrono` 库和时间点来测量函数的执行时间。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is tightly related to a preceding one, *Expressing time intervals
    with chrono::duration*. If you did not go through that recipe previously, you
    should do that before continuing with this one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱与前面的一个菜谱紧密相关，*使用 chrono::duration 表达时间间隔*。如果你之前没有完成那个菜谱，你应该在继续这个菜谱之前先完成它。
- en: 'For the examples in this recipe, we will consider the following function, which
    does nothing but pause the execution of the current thread for a given interval:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱中的示例，我们将考虑以下函数，它什么也不做，只是暂停当前线程的执行给定的时间间隔：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It should go without saying that this function is only meant for testing purposes
    and does nothing valuable. In practice, you will use the counting utility provided
    here to test your own functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这个函数仅用于测试目的，并没有做任何有价值的事情。在实际应用中，你将使用这里提供的计数工具来测试你自己的函数。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To measure the execution of a function, you must perform the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要测量函数的执行时间，你必须执行以下步骤：
- en: 'Retrieve the current moment of time using a standard clock:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准时钟获取当前时间点：
- en: '[PRE26]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call the function you want to measure:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用你想要测量的函数：
- en: '[PRE27]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Retrieve the current moment of time again; the difference between the two is
    the execution time of the function:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取当前时间点；两个时间点之间的差值是函数的执行时间：
- en: '[PRE28]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Convert the difference (which is expressed in nanoseconds) to the actual resolution
    you are interested in:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将差异（以纳秒表示）转换为你感兴趣的分辨率：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To implement this pattern in a reusable component, perform the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在可重用组件中实现此模式，请执行以下步骤：
- en: Create a class template parameterized with the resolution and the clock.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由分辨率和时钟参数化的类模板。
- en: Create a static variadic function template that takes a function and its arguments.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个静态变长函数模板，它接受一个函数及其参数。
- en: Implement the pattern shown previously, invoking the function with its arguments.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现之前显示的模式，使用其参数调用函数。
- en: Return a duration, not the number of ticks.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个持续时间，而不是滴答数。
- en: 'This is exemplified in the following snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码片段中得到了体现：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A clock is a component that defines two things:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟是一个定义了两件事的组件：
- en: A beginning of time called an *epoch*; there is no constraint regarding what
    the epoch is, but typical implementations use January 1, 1970.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个称为 *纪元* 的时间起点；关于纪元没有约束，但典型的实现使用 1970 年 1 月 1 日。
- en: A *tick rate* that defines the increment between two time points (such as a
    millisecond or nanosecond).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *滴答率*，它定义了两个时间点之间的增量（例如毫秒或纳秒）。
- en: 'A time point is a duration of time since the epoch of a clock. There are several
    time points that are of particular importance:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 时间点是从时钟纪元以来的时间长度。有几个特别重要的时间点：
- en: The current time, returned by the clock’s static member `now()`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前时间，由时钟的静态成员 `now()` 返回。
- en: The epoch, or the beginning of time; this is the time point created by the default
    constructor of `time_point` for a particular clock.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纪元，或时间的起点；这是由特定时钟的 `time_point` 的默认构造函数创建的时间点。
- en: The minimum time that can be represented by a clock, returned by the static
    member `min()` of `time_point`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟可以表示的最小时间，由 `time_point` 的静态成员 `min()` 返回。
- en: The maximum time that can be represented with a clock, returned by the static
    member `max()` of a `time point`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟可以表示的最大时间，由`time_point`的静态成员`max()`返回。
- en: 'The standard defines several clocks:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 标准定义了几个时钟：
- en: '`system_clock`: This uses the real-time clock of the current system to represent
    time points.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_clock`: 这使用当前系统的实时时钟来表示时间点。'
- en: '`high_resolution_clock`: This represents a clock that uses the shortest possible
    tick period on the current system.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`high_resolution_clock`: 这代表一个使用当前系统最短可能的滴答周期的时钟。'
- en: '`steady_clock`: This indicates a clock that is never adjusted. This means that,
    unlike the other clocks, as time advances, the difference between two time points
    is always positive.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steady_clock`: 这表示一个永远不会调整的时钟。这意味着，与其它时钟不同，随着时间的推移，两个时间点之间的差异总是正的。'
- en: '`utc_clock`: This is a C++20 clock for Coordinated Universal Time.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utc_clock`: 这是一个用于协调世界时（UTC）的C++20时钟。'
- en: '`tai_clock`: This is a C++20 clock for International Atomic Time.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tai_clock`: 这是一个用于国际原子时（TAI）的C++20时钟。'
- en: '`gps_clock`: This is a C++20 clock for GPS time.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps_clock`: 这是一个用于GPS时间的C++20时钟。'
- en: '`file_clock`: This is a C++20 clock used for expressing file times.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_clock`: 这是一个用于表示文件时间的C++20时钟。'
- en: 'The following example prints the precision of the first three clocks in this
    list (the ones available in C++11), regardless of whether it is steady (or monotone)
    or not:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例打印了列表中前三个时钟（C++11中可用的）的精度，无论它们是否稳定（或单调）：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A possible output is the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that the `system_clock` has a resolution of 0.1 microseconds and
    is not a monotone clock. On the other hand, the other two clocks, `high_resolution_clock`
    and `steady_clock`, both have a resolution of 1 nanosecond and are monotone clocks.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`system_clock`的分辨率为0.1微秒，并且不是一个单调时钟。另一方面，其它两个时钟`high_resolution_clock`和`steady_clock`都具有1纳秒的分辨率，并且是单调时钟。
- en: The steadiness of a clock is important when measuring the execution time of
    a function because, if the clock is adjusted while the function runs, the result
    will not yield the actual execution time, and values can even be negative. You
    should rely on a steady clock to measure the function execution time. The typical
    choice for that is the `high_resolution_clock`, and that was the clock we used
    in the examples in the *How to do it...* section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在测量函数的执行时间时，时钟的稳定性很重要，因为如果在函数运行时调整时钟，结果将不会给出实际的执行时间，甚至可能得到负值。您应该依赖一个稳定的时钟来测量函数执行时间。典型的选择是`high_resolution_clock`，这正是我们在*如何做...*部分示例中使用的时钟。
- en: When we measure the execution time, we need to retrieve the current time before
    making the call and after the call returns. For that, we use the clock’s `now()`
    static method. The result is a `time_point`; when we subtract two time points,
    the result is a `duration`, defined by the duration of the clock.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测量执行时间时，需要在调用之前和调用返回之后检索当前时间。为此，我们使用时钟的`now()`静态方法。结果是`time_point`；当我们从两个时间点中减去时，结果是`duration`，由时钟的持续时间定义。
- en: 'In order to create a reusable component that can be used to measure the execution
    time of any function, we have defined a class template called `perf_timer`. This
    class template is parameterized with the resolution we are interested in (which,
    by default, is microseconds) and the clock we want to use (which, by default,
    is `high_resolution_clock`). The class template has a single static member called
    `duration()`—a variadic function template—that takes a function to execute and
    its variable number of arguments. The implementation is relatively simple: we
    retrieve the current time, invoke the function using `std::invoke` (so that it
    handles the different mechanisms for invoking anything callable), and then retrieve
    the current time again. The return value is a `duration` (with the defined resolution).
    The following snippet shows an example of this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可重用的组件，可以用来测量任何函数的执行时间，我们定义了一个名为`perf_timer`的类模板。这个类模板以我们感兴趣的分辨率（默认为微秒）和想要使用的时钟（默认为`high_resolution_clock`）作为参数。该类模板有一个名为`duration()`的单个静态成员——一个变参函数模板——它接受一个要执行的功能及其可变数量的参数。实现相对简单：我们检索当前时间，使用`std::invoke`调用函数（以便它处理调用任何可调用对象的不同机制），然后再次检索当前时间。返回值是一个`duration`（具有定义的分辨率）。以下代码片段展示了这个示例：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is important to note that we are not returning a number of ticks from the
    `duration()` function, but an actual `duration` value. The reason is that by returning
    a number of ticks, we lose the resolution and won’t know what they actually represent.
    It is better to call `count()` only when the actual count of ticks is necessary.
    This is exemplified here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们不是从`duration()`函数返回滴答数，而是返回实际的`duration`值。原因是，通过返回滴答数，我们失去了分辨率，也不知道它们实际上代表什么。仅在需要实际滴答数时调用`count()`更好。这里举例说明：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we measure the execution of three different functions, using
    three different resolutions (nanoseconds, microseconds, and milliseconds). The
    values `t1`, `t2`, and `t3` represent durations. These make it possible to easily
    add them together and convert the result to microseconds.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用三种不同的分辨率（纳秒、微秒和毫秒）来测量三个不同函数的执行情况。`t1`、`t2`和`t3`的值代表持续时间。这使得它们可以轻松相加，并将结果转换为微秒。
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Expressing time intervals with chrono::duration*, to familiarize yourself
    with the fundamentals of the C++11 `chrono` library and how to work with durations,
    time points, and points'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用chrono::duration表达时间间隔*，以便熟悉C++11 `chrono`库的基本知识以及如何处理持续时间、时间点和点'
- en: '*Chapter 3*, *Uniformly invoking anything callable*, to learn how to use `std::invoke()`
    to call functions and any callable object'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*，*统一调用任何可调用对象*，学习如何使用`std::invoke()`调用函数和任何可调用对象'
- en: Generating hash values for custom types
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义类型生成哈希值
- en: 'The standard library provides several unordered associative containers: `std::unordered_set`,
    `std::unordered_multiset`, `std::unordered_map`, and `std::unordered_map`. These
    containers do not store their elements in a particular order; instead, they are
    grouped in buckets. The bucket an element belongs to depends on the hash value
    of the element. These standard containers use, by default, the `std::hash` class
    template to compute the hash value. The specialization for all basic types and
    also some library types is available. However, for custom types, you must specialize
    the class template yourself. This recipe will show you how to do that and also
    explain how a good hash value can be computed. A good hash value can be computed
    fast and is uniformly dispersed across the value domain, therefore minimizing
    the chances of duplicate values (collisions) existing.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几个无序关联容器：`std::unordered_set`、`std::unordered_multiset`、`std::unordered_map`和`std::unordered_map`。这些容器不按特定顺序存储它们的元素；相反，它们被分组在桶中。一个元素所属的桶取决于该元素的哈希值。这些标准容器默认使用`std::hash`类模板来计算哈希值。所有基本类型和一些库类型的特化都是可用的。然而，对于自定义类型，您必须自己特化类模板。本食谱将向您展示如何做到这一点，并解释如何计算一个好的哈希值。一个好的哈希值可以快速计算，并且在值域内均匀分布，因此最小化重复值（冲突）存在的可能性。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the examples in this recipe, we will use the following class:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的示例中，我们将使用以下类：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This recipe covers hashing functionalities from the standard library. You should
    be familiar with the concepts of hashes and hash functions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱涵盖了标准库中的哈希功能。您应该熟悉哈希和哈希函数的概念。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to use your custom types with the unordered associative containers,
    you must perform the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用自定义类型与无序关联容器一起使用，你必须执行以下步骤：
- en: Specialize the `std::hash` class template for your custom type; the specialization
    must be done in the `std` namespace.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的自定义类型特化`std::hash`类模板；特化必须在`std`命名空间中完成。
- en: Define synonyms for the argument and result type.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义参数和结果类型的同义词。
- en: Implement the call operator so that it takes a constant reference to your type
    and returns a hash value.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现调用操作符，使其接受对您的类型的常量引用并返回一个哈希值。
- en: 'To compute a good hash value, you should do the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算一个好的哈希值，您应该做以下事情：
- en: Start with an initial value, which should be a prime number (for example, 17).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个初始值开始，这个值应该是一个素数（例如，17）。
- en: 'For each field that is used to determine whether two instances of the class
    are equal, adjust the hash value according to the following formula:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个用于确定两个类的实例是否相等的字段，根据以下公式调整哈希值：
- en: '[PRE36]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can use the same prime number for all fields with the preceding formula,
    but it is recommended to have a different value than the initial value (for instance,
    31).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用相同的素数对所有字段使用前面的公式，但建议使用一个不同于初始值的值（例如，31）。
- en: Use a specialization of `std::hash` to determine the hash value for class data
    members.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::hash`的特化来确定类数据成员的哈希值。
- en: 'Based on the steps described here, the `std::hash` specialization for the `Item`
    class looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这里描述的步骤，`Item`类的`std::hash`特化看起来如下：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This specialization makes it possible to use the `Item` class with unordered
    associative containers, such as `std::unordered_set`. An example is provided here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个专业使您能够使用`Item`类与无序关联容器，例如`std::unordered_set`一起使用。这里提供了一个示例：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The class template `std::hash` is a function object template whose call operator
    defines a hash function with the following properties:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板`std::hash`是一个函数对象模板，其调用操作符定义了一个具有以下属性的哈希函数：
- en: Takes an argument of the template parameter type and returns a `size_t` value.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受模板参数类型的参数并返回一个`size_t`值。
- en: Does not throw any exceptions.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会抛出任何异常。
- en: For two arguments that are equal, it returns the same hash value.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于相等的两个参数，它返回相同的哈希值。
- en: For two arguments that are not equal, the probability of returning the same
    value is very small (should be close to `1.0/std::numeric_limits<size_t>::max()`).
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不相等的两个参数，返回相同值的概率非常小（应接近`1.0/std::numeric_limits<size_t>::max()`）。
- en: The standard provides specialization for all basic types, such as `bool`, `char`,
    `int`, `long`, `float`, `double` (along with all the possible `unsigned` and `long`
    variations), and the pointer type, but also library types including the `basic_string`
    and `basic_string_view` types, `unique_ptr` and `shared_ptr`, `bitset` and `vector<bool>`,
    `optional` and `variant` (in C++17), and several other types. However, for custom
    types, you have to provide your own specialization. This specialization must be
    in the namespace `std` (because that is the namespace where the class template
    `hash` is defined) and must meet the requirements enumerated earlier.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 标准为所有基本类型提供了特化，例如`bool`、`char`、`int`、`long`、`float`、`double`（以及所有可能的`unsigned`和`long`变体），以及指针类型，但也包括库类型，如`basic_string`和`basic_string_view`类型、`unique_ptr`和`shared_ptr`、`bitset`和`vector<bool>`、`optional`和`variant`（在C++17中），以及几种其他类型。然而，对于自定义类型，您必须提供自己的特化。这个特化必须在`std`命名空间中（因为类模板`hash`是在这个命名空间中定义的），并且必须满足前面列举的要求。
- en: The standard does not specify how hash values should be computed. You can use
    any function you want as long as it returns the same value for equal objects,
    and also has a very small chance of returning the same value for non-equal objects.
    The algorithm described in this recipe was presented in the book *Effective Java,
    Second Edition* by Joshua Bloch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 标准没有指定如何计算哈希值。只要它为相等的对象返回相同的值，并且对于不相等的对象有非常小的概率返回相同的值，您可以使用任何想要的函数。本食谱中描述的算法在Joshua
    Bloch所著的《Effective Java，第二版》一书中提出。
- en: When computing the hash value, consider only the fields that participate in
    determining whether two instances of the class are equal (in other words, fields
    that are used in `operator==`). However, you must use all these fields that are
    used with `operator==`. In our example, all three fields of the `Item` class are
    used to determine the equality of two objects; therefore, we must use them all
    to compute the hash. The initial hash value should be nonzero, and in our example,
    we picked the prime number 17\.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算哈希值时，仅考虑参与确定两个类的实例是否相等的字段（换句话说，用于`operator==`的字段）。但是，您必须使用与`operator==`一起使用的所有这些字段。在我们的例子中，`Item`类的所有三个字段都用于确定两个对象的相等性；因此，我们必须使用它们来计算哈希。初始哈希值不应为零，在我们的例子中，我们选择了素数17。
- en: The important thing is that these values should not be zero; otherwise, the
    initial fields (that is, the first in the order of processing) that produce the
    hash value zero will not alter the hash (which remains zero since `x * 0 + 0 =
    0`). For every field used to compute the hash, we alter the current hash by multiplying
    its previous value with a prime number and adding the hash of the current field.
    For this purpose, we use specializations of the class template `std::hash`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这些值不应为零；否则，产生哈希值为零的初始字段（即处理顺序中的第一个）将不会改变哈希值（由于`x * 0 + 0 = 0`，哈希值保持为零）。对于用于计算哈希的每个字段，我们通过将其前一个值乘以一个素数并加上当前字段的哈希值来改变当前哈希值。为此，我们使用类模板`std::hash`的特化。
- en: The use of the prime number 31 is advantageous for performance optimizations
    because `31 * x` can be replaced by the compiler with `(x << 5) - x`, which is
    faster. Similarly, you can use 127 because `127 * x` is equal to `(x << 7) - x`
    or 8191, because `8191 * x` is equal to `(x << 13) - x`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用素数 31 对于性能优化是有利的，因为 `31 * x` 可以被编译器替换为 `(x << 5) - x`，这更快。同样，你也可以使用 127，因为
    `127 * x` 等于 `(x << 7) - x` 或 8191，因为 `8191 * x` 等于 `(x << 13) - x`。
- en: If your custom type contains an array and is used to determine the equality
    of two objects and, therefore, needs to be used to compute the hash, then treat
    the array as if its elements were data members of the class. In other words, apply
    the same algorithm described earlier to all elements of the array.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的自定义类型包含一个数组，并且用于确定两个对象的相等性，因此需要用于计算哈希，那么将数组视为其元素是类的数据成员。换句话说，将前面描述的相同算法应用于数组的所有元素。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 2*, *Limits and other properties of numeric types*, to learn about
    the minimum and maximum values, as well as the other properties of numerical types'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*数值类型的限制和其他属性*，了解数值类型的最大值和最小值，以及其他数值类型的属性'
- en: Using std::any to store any value
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::any` 存储任何值
- en: C++ does not have a hierarchical type system like other languages (such as C#
    or Java) and, therefore, it can’t store multiple types of a value in a single
    variable like it is possible to with the type `Object` in .NET and Java or natively
    in JavaScript. Developers have long used `void*` for that purpose, but this only
    helps us store pointers to anything and is not type-safe. Depending on the end
    goal, alternatives can include templates or overloaded functions. However, C++17
    has introduced a standard type-safe container, called `std::any`, that can hold
    a single value of any type.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 没有像其他语言（如 C# 或 Java）那样的层次类型系统，因此它不能像 .NET 和 Java 中的 `Object` 类型或 JavaScript
    中的原生类型那样在单个变量中存储多个类型的值。长期以来，开发者一直使用 `void*` 来实现这个目的，但这只能帮助我们存储指向任何东西的指针，并且不是类型安全的。根据最终目标，替代方案可以包括模板或重载函数。然而，C++17
    引入了一个标准类型安全的容器，称为 `std::any`，它可以存储任何类型的单个值。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`std::any` has been designed based on `boost::any` and is available in the
    `<any>` header. If you are familiar with `boost::any` and have used it in your
    code, you can migrate it seamlessly to `std::any`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any` 是基于 `boost::any` 设计的，并在 `<any>` 头文件中可用。如果你熟悉 `boost::any` 并已在代码中使用它，你可以无缝地将它迁移到
    `std::any`。'
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the following operations to work with `std::any`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下操作来处理 `std::any`：
- en: 'To store values, use the constructor or assign them directly to a `std::any`
    variable:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储值，请使用构造函数或将它们直接赋值给 `std::any` 变量：
- en: '[PRE39]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To read values, use the non-member function `std::any_cast()`:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取值，请使用非成员函数 `std::any_cast()`：
- en: '[PRE40]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To check the type of the stored value, use the member function `type()`:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查存储值的类型，请使用 `type()` 成员函数：
- en: '[PRE41]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To check whether the container stores a value, use the `has_value()` member
    function:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查容器是否存储了值，请使用 `has_value()` 成员函数：
- en: '[PRE42]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To modify the stored value, use the member functions `emplace()`, `reset()`,
    or `swap()`:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改存储的值，请使用 `emplace()`、`reset()` 或 `swap()` 成员函数：
- en: '[PRE43]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::any` is a type-safe container that can hold values of any type that is
    (or rather, whose decayed type is) copy constructible. Storing values in the container
    is very simple—you can either use one of the available constructors (the default
    constructor creates a container that stores no value) or the assignment operator.
    However, reading values is not directly possible, and you need to use the non-member
    function `std::any_cast()`, which casts the stored value to the specified type.
    This function throws `std::bad_any_cast` if the stored value has a different type
    than the one you are casting to. Casting between implicitly convertible types,
    such as `int` and `long`, is not possible either. `std::bad_any_cast` is derived
    from `std::bad_cast`; therefore, you can catch any of these two exception types.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any` 是一个类型安全的容器，可以存储任何类型（或者更确切地说，其退化类型是可复制的）的值。在容器中存储值非常简单——你可以使用可用的构造函数之一（默认构造函数创建一个不存储任何值的容器）或者赋值运算符。然而，直接读取值是不可能的，你需要使用非成员函数
    `std::any_cast()`，该函数将存储的值转换为指定的类型。如果存储的值与你要转换的类型不同，该函数会抛出 `std::bad_any_cast`
    异常。在隐式可转换的类型之间进行转换，例如 `int` 和 `long`，也是不可能的。`std::bad_any_cast` 是从 `std::bad_cast`
    派生的；因此，你可以捕获这两种异常类型中的任何一种。'
- en: It is possible to check the type of the stored value using the `type()` member
    function, which returns a `type_info` constant reference. If the container is
    empty, this function returns `typeid(void)`. To check whether the container stores
    a value, you can use the member function `has_value()`, which returns `true` if
    there is a value or `false` if the container is empty.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `type()` 成员函数检查存储值的类型，它返回一个 `type_info` 常量引用。如果容器为空，此函数返回 `typeid(void)`。要检查容器是否存储了值，可以使用成员函数
    `has_value()`，如果容器中有值则返回 `true`，如果容器为空则返回 `false`。
- en: 'The following example shows how to check whether the container has any value,
    how to check the type of the stored value, and how to read the value from the
    container:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何检查容器是否有任何值，如何检查存储值的类型，以及如何从容器中读取值：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you want to store multiple values of any type, use a standard container
    such as `std::vector` to hold values of the type `std::any`. An example is presented
    here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想存储任何类型的多个值，可以使用标准容器，如 `std::vector` 来持有 `std::any` 类型的值。以下是一个示例：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::optional` 存储可选值*，了解 C++17 类模板 `std::optional`，它管理可能存在或可能不存在的值'
- en: '*Using std::variant as a type-safe union*, to learn how to use the C++17 `std::variant`
    class to represent type-safe unions'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::variant` 作为类型安全的联合体*，了解如何使用 C++17 的 `std::variant` 类来表示类型安全的联合体'
- en: Using std::optional to store optional values
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::optional` 存储可选值
- en: Sometimes, it is useful to be able to store either a value or a null pointer
    if a specific value is not available. A typical example of such a case is the
    return value of a function that may fail to produce a return value, but this failure
    is not an error. For instance, think of a function that finds and returns values
    from a dictionary by specifying a key. Not finding a value is a probable case
    and, therefore, the function would either return a Boolean (or an integer value,
    if more error codes are necessary) and have a reference argument to hold the return
    value or return a pointer (raw or smart pointer). In C++17, `std::optional` is
    a better alternative to these solutions. The class template `std::optional` is
    a template container for storing a value that may or may not exist. In this recipe,
    we will see how to use this container and its typical use cases.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果某个特定值不可用，能够存储一个值或一个空指针是有用的。这种情况的一个典型例子是函数的返回值，该函数可能无法生成返回值，但这种失败不是错误。例如，考虑一个通过指定键从字典中查找并返回值的函数。找不到值是一个可能的情况，因此该函数要么返回一个布尔值（或如果需要更多错误代码，则返回整数值），并有一个引用参数来保存返回值，要么返回一个指针（原始指针或智能指针）。在
    C++17 中，`std::optional` 是这些解决方案的更好替代。类模板 `std::optional` 是一个用于存储可能存在或不存在值的模板容器。在本食谱中，我们将了解如何使用此容器及其典型用例。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The class template `std::optional<T>` was designed based on `boost::optional`
    and is available in the `<optional>` header. If you are familiar with `boost::optional`
    and have used it in your code, you can migrate it seamlessly to `std::optional`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::optional<T>` 是基于 `boost::optional` 设计的，并在 `<optional>` 头文件中提供。如果你熟悉
    `boost::optional` 并已在代码中使用它，你可以无缝地将它迁移到 `std::optional`。
- en: 'In the following snippets, we will refer to the following `foo` class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将参考以下 `foo` 类：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following operations to work with `std::optional`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下操作来处理 `std::optional`：
- en: 'To store a value, use the constructor or assign the value directly to a `std::optional`
    object:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储一个值，使用构造函数或将值直接赋给 `std::optional` 对象：
- en: '[PRE47]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To read the stored value, use `operator*` or `operator->`:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取存储的值，使用 `operator*` 或 `operator->`：
- en: '[PRE48]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, use the member functions `value()` and `value_or()` to read
    the stored value:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，使用成员函数 `value()` 和 `value_or()` 来读取存储的值：
- en: '[PRE49]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To check whether the container stores a value, use a conversion operator to
    `bool` or the member function `has_value()`:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查容器是否存储了值，可以使用转换运算符到 `bool` 或成员函数 `has_value()`：
- en: '[PRE50]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To modify the stored value, use the member functions `emplace()`, `reset()`,
    or `swap()`:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改存储的值，使用成员函数 `emplace()`、`reset()` 或 `swap()`：
- en: '[PRE51]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use `std::optional` to model any of the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::optional` 来模拟以下任何一种情况：
- en: 'Return values from functions that may fail to produce a value:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能无法生成值的函数的返回值：
- en: '[PRE52]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Parameters to functions that are optional:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的函数参数：
- en: '[PRE53]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Class data members that are optional:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的类数据成员：
- en: '[PRE54]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The class template `std::optional` is a class template that represents a container
    for an optional value. If the container does have a value, that value is stored
    as part of the `optional` object; no heap allocations and pointers are involved.
    The `std::optional` class template is conceptually implemented like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::optional` 是一个表示可选值容器的类模板。如果容器包含值，则该值作为 `optional` 对象的一部分存储；不涉及堆分配和指针。`std::optional`
    类模板的概念性实现如下：
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `std::aligned_storage_t` alias template allows us to create uninitialized
    chunks of memory that can hold objects of a given type. The class template `std::optional`
    does not contain a value if it was default constructed, or if it was copy constructed
    or copy assigned from another empty optional object or from a `std::nullopt_t`
    value. Such a value is `std::nullopt`, a `constexpr` value used to indicate an
    optional object with an uninitialized state. This is a helper type, implemented
    as an empty class, that indicates an optional object with an uninitialized state.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::aligned_storage_t` 别名模板允许我们创建未初始化的内存块，这些内存块可以存储特定类型的对象。类模板 `std::optional`
    如果是默认构造的，或者是从另一个空的 `std::optional` 对象或从 `std::nullopt_t` 值复制构造或复制赋值而来，则不包含值。这样的值是
    `std::nullopt`，一个用于表示具有未初始化状态的 `std::optional` 对象的 `constexpr` 值。这是一个辅助类型，实现为一个空类，用于指示具有未初始化状态的
    `std::optional` 对象。'
- en: 'The typical use for an `optional` type (called *nullable* in other programming
    languages) is the return type from a function that may fail. Possible solutions
    for this situation include the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional` 类型（在其他编程语言中称为 *nullable*）的典型用途是从可能失败的功能返回。这种情况的可能解决方案包括以下几种：'
- en: Return a `std::pair<T, bool>`, where `T` is the type of the return value; the
    second element of the pair is a Boolean flag that indicates whether the value
    of the first element is valid or not.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个 `std::pair<T, bool>`，其中 `T` 是返回值的类型；对的数据是布尔标志，指示第一个元素的有效性。
- en: Return a `bool`, take an extra parameter of the type `T&`, and assign a value
    to this parameter only if the function succeeds.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个 `bool`，接受一个额外的类型为 `T&` 的参数，并且仅在函数成功时将值赋给此参数。
- en: Return a raw or smart pointer type, and use `nullptr` to indicate a failure.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回原始指针或智能指针类型，并使用 `nullptr` 来指示失败。
- en: The class template `std::optional` is a better approach because, on the one
    hand, it does not involve output parameters to the function (which, outside of
    C and C++, is not the canonical form for returning values) and does not require
    working with pointers, and on the other hand, it better encapsulates the details
    of a `std::pair<T, bool>`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::optional` 是一种更好的方法，因为一方面，它不涉及函数的输出参数（这在 C 和 C++ 之外不是返回值的规范形式），也不需要处理指针，另一方面，它更好地封装了
    `std::pair<T, bool>` 的细节。
- en: However, optional objects can also be used for class data members, and compilers
    are able to optimize the memory layout for efficient storage.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可选对象也可以用于类的数据成员，并且编译器能够优化内存布局以实现高效的存储。
- en: The class template `std::optional` cannot be used to return polymorphic types.
    If you write, for instance, a factory method that needs to return different types
    from a hierarchy of types, you cannot rely on `std::optional` and need to return
    a pointer, preferably a `std::unique_ptr` or `std::shared_ptr` (depending on whether
    ownership of the object needs to be shared or not).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::optional` 不能用于返回多态类型。例如，如果你编写了一个需要从类型层次结构返回不同类型的工厂方法，你不能依赖于 `std::optional`，需要返回一个指针，最好是
    `std::unique_ptr` 或 `std::shared_ptr`（取决于是否需要共享对象的所有权）。
- en: 'When you use `std::optional` to pass optional arguments to a function, you
    need to understand that it may incur creating copies, which can be a performance
    issue if large objects are involved. Let’s consider the following example of a
    function that has a constant reference to the `std::optional` parameter:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `std::optional` 将可选参数传递给函数时，你需要理解它可能会产生复制，如果涉及到大型对象，这可能会成为性能问题。让我们考虑以下具有对
    `std::optional` 参数的常量引用的函数的例子：
- en: '[PRE56]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first call to `process()` does not involve any additional object construction
    because we pass a `std::optional<bar>` object. The second call, however, will
    involve the copy construction of a `bar` object, because `b2` is a `bar` and needs
    to be copied to a `std::optional<bar>`; a copy is made even if `bar` has move
    semantics implemented. If `bar` is a small object, this shouldn’t be of great
    concern, but for large objects, it can prove to be a performance issue. The solution
    to avoid this depends on the context and can involve creating a second overload
    that takes a constant reference to `bar`, or entirely avoiding using `std::optional`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`process()`不涉及任何额外的对象构造，因为我们传递了一个`std::optional<bar>`对象。然而，第二次调用将涉及`bar`对象的复制构造，因为`b2`是一个`bar`，需要被复制到一个`std::optional<bar>`中；即使`bar`实现了移动语义，也会进行复制。如果`bar`是一个小对象，这不应该引起太大的关注，但对于大对象，这可能会成为一个性能问题。避免这种情况的解决方案取决于上下文，可能包括创建一个接受`bar`常量引用的第二个重载，或者完全避免使用`std::optional`。
- en: There’s more…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Although `std::optional` makes it easier to return a value from a function that
    may also fail, chaining together multiple such functions produces code that can
    be cumbersome or at least too repetitive. To ease this scenario, in C++23, `std::optional`
    has several additional members (`transform()`, `and_then()`, and `or_else()`)
    called monadic operations. We will learn about these in the next recipe.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::optional`使得从可能失败的函数中返回值变得更加容易，但将多个此类函数链式连接起来会产生冗长或至少过于重复的代码。为了简化这种情况，在C++23中，`std::optional`有多个额外的成员（`transform()`、`and_then()`和`or_else()`），被称为单子操作。我们将在下一道菜谱中了解它们。
- en: See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::any to store any value*, to learn how to use the C++17 class `std::any`,
    which represents a type-safe container for single values of any type'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用std::any存储任何值*，了解如何使用C++17类`std::any`，它代表任何类型的单值类型安全容器'
- en: '*Using std::variant as a type-safe union*, to learn how to use the C++17 `std::variant`
    class to represent type-safe unions'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用std::variant作为类型安全的联合体*，了解如何使用C++17类`std::variant`来表示类型安全的联合体'
- en: '*Chaining together computations that may or may not produce a value*, to see
    how the new C++23 monadic operations of `std::optional` simplify scenarios where
    multiple functions returning `std::optional` are called sequentially'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将可能或可能不产生值的计算链式连接起来*，以了解新的C++23单子操作`std::optional`如何简化多个返回`std::optional`的函数依次调用的场景'
- en: Chaining together computations that may or may not produce a value
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将可能或可能不产生值的计算链式连接起来
- en: In the previous recipe, we have seen how to use the `std::optional` class for
    storing a value that may or may not exist. Its use cases include optional parameters
    to functions and return values from functions that may fail to produce a result.
    When multiple such functions need to be chained together, the code can become
    cumbersome and verbose. For this reason, the C++23 standard has added several
    new methods to the `std::optional` class. They are referred to by the term **monadic
    operations**. These methods are `transform()`, `and_then()`, and `or_else()`.
    In this recipe, we’ll see what they are useful for.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何使用`std::optional`类来存储可能存在或不存在的数据。它的用例包括函数的可选参数和可能无法产生结果的函数的返回值。当需要将多个此类函数链式连接起来时，代码可能会变得冗长且啰嗦。因此，C++23标准为`std::optional`类添加了几个新方法。它们被称为**单子操作**。这些方法包括`transform()`、`and_then()`和`or_else()`。在本菜谱中，我们将了解它们有什么用。
- en: In simple terms, in functional programming, a **monad** is a container that
    encapsulates some functionality on top of a value that it wraps. Such an example
    is `std::optional` in C++. On the other hand, a **monadic operation** is a function
    from a domain *D* into *D* itself. For instance, the **identity function** (a
    function that returns its argument) is a monadic operation. The newly added functions
    `transform()`, `and_then()`, and `or_else()` are monadic because they take a `std::optional`
    and return a `std::optional`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在函数式编程中，一个**单子**是一个封装在其包装值之上的一些功能的容器。例如，C++中的`std::optional`就是一个这样的例子。另一方面，一个**单子操作**是一个从域
    *D* 到 *D* 自身的函数。例如，**恒等函数**（返回其参数的函数）就是一个单子操作。新添加的函数`transform()`、`and_then()`和`or_else()`是单子操作，因为它们接受一个`std::optional`并返回一个`std::optional`。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the following sections, we will refer to the definitions shown here:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将参考此处所示的定义：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How to do it…
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'You can use the following monadic operations as per your use case:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的使用情况，您可以使用以下单子操作：
- en: 'If you have an `optional` value and want to apply a function `f` and return
    the value of that invocation, then use `transform()`:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果你有一个`可选`值，并想应用一个函数`f`并返回该调用的值，那么请使用`transform()`:'
- en: '[PRE58]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you have an `optional` value and want to apply a function `f` that returns
    an `optional` and then return the value of that invocation, then use `and_then()`:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果你有一个`可选`值，并想应用一个返回`可选`值的函数`f`，然后返回该调用的值，那么请使用`and_then()`:'
- en: '[PRE59]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you have an `optional` value that could be empty, in which case you want
    to invoke a function to handle the situation (such as to log or throw an exception)
    and return another `optional` (either an alternative value or an empty `optional`),
    then use `or_else()`:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果你有一个可能为空的`可选`值，在这种情况下，你想调用一个函数来处理这种情况（例如记录日志或抛出异常），并返回另一个`可选`（一个替代值或一个空的`可选`），那么请使用`or_else()`:'
- en: '[PRE60]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A larger example is shown in the following snippet:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段展示了更大的例子：
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works…
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `and_then()` and `transform()` member functions are very similar. They actually
    have the same number of overloads with the same signature. They take a single
    argument that is a function or callable object and they both return an `optional`.
    If the `optional` does not hold a value, then both `and_then()` and `transform()`
    return an empty `optional`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`and_then()`和`transform()`成员函数非常相似。它们实际上具有相同数量的重载，具有相同的签名。它们接受一个参数，该参数是一个函数或可调用对象，并且它们都返回一个`可选`。如果`可选`不包含值，那么`and_then()`和`transform()`都返回一个空的`可选`。'
- en: 'Otherwise, if the `optional` does hold a value, then it invokes the function
    or callable with the stored value. Here is where they differ:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果`可选`确实包含一个值，那么它将使用存储的值调用该函数或可调用对象。这里就是它们的不同之处：
- en: The function/callable passed to `and_then()` must itself return a value of a
    type that is a specialization of `std::optional`. This will be the value returned
    by `and_then()`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`and_then()`的函数/可调用对象必须返回一个`std::optional`类型的值。这将是由`and_then()`返回的值。
- en: The function/callable passed to `transform()` may have any return type that
    is not a reference type. However, the value it returns will itself be wrapped
    in a `std::optional` before being returned from `transform()`.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`transform()`的函数/可调用对象可以返回任何非引用类型的返回类型。然而，它在返回之前将自身包裹在一个`std::optional`中。
- en: 'To exemplify this better, let’s consider the following function again:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这一点，让我们再次考虑以下函数：
- en: '[PRE62]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Previously, we have seen this snippet:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经看到了这个片段：
- en: '[PRE63]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, `p` has the type `std::optional<double>`. This is because `calculate_price()`
    returns a `double`, and, therefore, `transform()` will return a `std::optional<double>`.
    Let’s change the signature of `calculate_price()` to return a `std::optional<double>`
    instead:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`p`具有`std::optional<double>`类型。这是因为`calculate_price()`返回一个`double`，因此`transform()`将返回一个`std::optional<double>`。让我们将`calculate_price()`的签名更改为返回`std::optional<double>`：
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The variable `p` will now have the type `std::optional<std::optional<double>>`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`p`现在将具有`std::optional<std::optional<double>>`的类型。
- en: 'The third monadic function, `or_else()`, is the opposite of `and_then()`/`transform()`:
    if the `optional` object contains a value, it returns the `optional` without doing
    anything. Otherwise, it invokes its single argument, which is a function or callable
    without any argument, and returns the value from this invocation. The return type
    of the function/callable must be `std::optional<T>`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种单子函数`or_else()`是`and_then()`/`transform()`的对立面：如果`可选`对象包含一个值，它将不做任何操作并返回该`可选`。否则，它将调用其单个参数，即一个不带任何参数的函数或可调用对象，并从这次调用返回值。函数/可调用对象的返回类型必须是`std::optional<T>`。
- en: The `or_else()` function is typically used for handling erroneous situations
    when an expected value is missing. The supplied function could perhaps add an
    entry to a log, throw an exception, or do something else. Unless this callable
    throws an exception, it must return a value. This can be an empty `optional` or
    an `optional` holding a default value or some alternative to the missing value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`or_else()`函数通常用于处理预期值缺失时的错误情况。提供的函数可能向日志中添加条目、抛出异常或执行其他操作。除非这个可调用对象抛出异常，否则它必须返回一个值。这可以是一个空的`可选`，或者是一个包含默认值或替代缺失值的`可选`。'
- en: There’s more…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One of the most important use cases for `std::optional` is to return a value
    from a function that may or may not produce one. However, when a value is missing,
    we probably need to know the reason for the failure. This is not directly possible
    with optional, unless the stored type is a compound of a value and an error, or
    if we use additional parameters to the function to retrieve the error. For this
    reason, the C++23 standard includes an alternative for these use cases for `std::optional`,
    the `std::expected` type.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional` 的一个最重要的用例是从可能产生也可能不产生值的函数中返回值。然而，当值缺失时，我们可能需要知道失败的原因。使用可选类型时，这并不直接可行，除非存储的类型是一个值和错误的复合体，或者如果我们在函数中使用了额外的参数来检索错误。因此，C++23
    标准为这些用例提供了 `std::optional` 的替代方案，即 `std::expected` 类型。'
- en: See also
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::expected to return a value or an error*, to see how this C++23
    type allows us to return a value or an error code from a function'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::expected` 返回值或错误，以了解这种 C++23 类型如何使我们能够从函数中返回值或错误代码*'
- en: Using std::variant as a type-safe union
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `std::variant` 作为类型安全的联合使用
- en: In C++, a union type is a special class type that, at any point, holds a value
    of one of its data members. Unlike regular classes, unions cannot have base classes,
    nor can they be derived, and they cannot contain virtual functions (that would
    not make sense anyway). Unions are mostly used to define different representations
    of the same data. However, unions only work for types that are **Plain Old Data**
    (**POD**). If a union contains values of non-POD types, then these members require
    explicit construction with a placement `new` and explicit destruction, which is
    cumbersome and error-prone. In C++17, a type-safe union is available in the form
    of a standard library class template called `std::variant`. In this recipe, you
    will learn how to use it to model alternative values.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，联合类型是一种特殊类类型，在任何时刻，它都持有其数据成员中的一个值。与常规类不同，联合不能有基类，也不能被派生，并且不能包含虚拟函数（这本来就没有意义）。联合主要用于定义相同数据的不同表示。然而，联合仅适用于
    **纯旧数据** (**POD**) 类型。如果一个联合包含非 POD 类型的值，那么这些成员需要使用带位置的 `new` 进行显式构造和显式销毁，这很麻烦且容易出错。在
    C++17 中，类型安全的联合以标准库类模板 `std::variant` 的形式提供。在本食谱中，您将学习如何使用它来建模替代值。
- en: Getting ready
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `std::variant` type implements a type-safe **discriminated union**. Although
    discussing these in detail is beyond the scope of this recipe, we will introduce
    them briefly here. Being familiar with discriminated unions will help us better
    understand the design of `variant` and the way it works.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant` 类型实现了一个类型安全的 **区分联合**。尽管详细讨论这些内容超出了本食谱的范围，但我们将在这里简要介绍它们。熟悉区分联合将帮助我们更好地理解
    `variant` 的设计和其工作方式。'
- en: 'Discriminated unions are also called **tagged unions** or **disjoint unions**.
    A discriminated union is a data type that is able to store one value of a collection
    of types and offer type-safe access for that value. In C++, this is typically
    implemented as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合也称为 **标记联合** 或 **不相交联合**。区分联合是一种能够存储一组类型中的一个值并提供对该值类型安全访问的数据类型。在 C++ 中，这通常如下实现：
- en: '[PRE65]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For Windows programmers, a well-known discriminated union is the `VARIANT` structure
    used in **Component Object Model** (**COM)** programming.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 程序员来说，一个众所周知的区分联合是用于 **组件对象模型** (**COM**) 编程的 `VARIANT` 结构。
- en: The class template `std::variant` was designed based on `boost::variant`, and
    is available in the `<variant>` header. If you are familiar with `boost::variant`
    and have used it in your code, you can migrate your code with little effort to
    use the standard `variant` class template.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::variant` 是基于 `boost::variant` 设计的，并在 `<variant>` 头文件中可用。如果您熟悉 `boost::variant`
    并已在代码中使用它，您可以通过少量努力将代码迁移到使用标准的 `variant` 类模板。
- en: How to do it...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following operations to work with `std::variant`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下操作来处理 `std::variant`：
- en: 'To modify the stored value, use the member functions `emplace()` or `swap()`:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改存储的值，请使用成员函数 `emplace()` 或 `swap()`：
- en: '[PRE66]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To read the stored values, use the non-member functions `std::get` or `std::get_if`:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取存储的值，请使用非成员函数 `std::get` 或 `std::get_if`：
- en: '[PRE67]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To store a value, use the constructor or assign a value directly to a `variant`
    object:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储一个值，请使用构造函数或将值直接赋给 `variant` 对象：
- en: '[PRE68]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To check what is the stored alternative, use the member function `index()`:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查存储的替代项，请使用成员函数 `index()`：
- en: '[PRE69]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To check whether a variant holds an alternative, use the non-member function
    `std::holds_alternative()`:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查变体是否持有替代方案，请使用非成员函数`std::holds_alternative()`：
- en: '[PRE70]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To define a variant whose first alternative is not default constructible, use
    `std::monostate` as the first alternative (in this example, `foo` is the same
    class we used earlier):'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定义一个第一个替代方案不是默认可构造的变体，请使用`std::monostate`作为第一个替代方案（在这个例子中，`foo`是我们之前使用的相同类）：
- en: '[PRE71]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To process the stored value of a variant and do something depending on the
    type of the alternative, use `std::visit()`:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要处理变体存储的值并根据替代方案的类型执行某些操作，请使用`std::visit()`：
- en: '[PRE72]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::variant` is a class template that models a type-safe union, holding a
    value of one of its possible alternatives at any given time. In some rare cases,
    though, it is possible that a variant object does not store any value. `std::variant`
    has a member function called `valueless_by_exception()` that returns `true` if
    the variant does not hold a value, which is possible only in case of an exception
    during initialization—therefore, the name of the function.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant`是一个类模板，它模拟了一个类型安全的联合，在任何给定时间持有其可能的替代方案之一。然而，在某些罕见的情况下，变体对象可能不存储任何值。`std::variant`有一个名为`valueless_by_exception()`的成员函数，如果变体不持有值，则返回`true`，这只有在初始化期间发生异常的情况下才可能，因此函数的名称。'
- en: The size of a `std::variant` object is as large as its largest alternative.
    A variant does not store additional data. The value stored by the variant is allocated
    within the memory representation of the object itself.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant`对象的大小与其最大的替代方案一样大。变体不存储额外的数据。变体存储的值是在对象的内存表示内部分配的。'
- en: 'A variant can hold multiple alternatives of the same type and also hold different
    constant- and volatile-qualified versions at the same time. In this case, you
    cannot assign a value of the type used multiple types, but use the `emplace()`
    member function instead, as shown in the following snippet:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 变体可以持有相同类型的多个替代方案，并且还可以同时持有不同常量和易失性资格的版本。在这种情况下，您不能分配多个类型的值，而应使用`emplace()`成员函数，如下面的代码片段所示：
- en: '[PRE73]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `std::holds_alternative()` function mentioned earlier, which checks whether
    a variant holds an alternative type `T`, cannot be used in this case. You should
    avoid defining variants holding multiple alternatives of the same type.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的`std::holds_alternative()`函数，它检查变体是否持有替代类型`T`，在此情况下不能使用。您应该避免定义持有相同类型多个替代方案的变体。
- en: On the other hand, a variant cannot hold an alternative of the type `void`,
    or alternatives of array and reference types. Moreover, the first alternative
    must always be default constructible. The reason for this is that, just like discriminated
    unions, a variant is default initialized with the value of its first alternative.
    If the first alternative type is not default constructible, then the variant must
    use `std::monostate` as the first alternative. This is an empty type indented
    for making variants default constructible.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，变体不能持有类型`void`的替代方案，或者数组和引用类型的替代方案。此外，第一个替代方案必须始终是默认可构造的。这是因为，就像区分联合一样，变体使用其第一个替代方案的值进行默认初始化。如果第一个替代方案类型不是默认可构造的，那么变体必须使用`std::monostate`作为第一个替代方案。这是一个空类型，旨在使变体默认可构造。
- en: It is possible to query a `variant` at compile time for its size (that is, the
    number of alternatives it defines) and for the type of an alternative specified
    by its zero-based index. On the other hand, you can query the index of the currently
    held alternative at runtime using the member function `index()`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在编译时查询`variant`的大小（即它定义的替代方案的数量）以及通过其零基索引指定的替代方案类型。另一方面，您可以使用成员函数`index()`在运行时查询当前持有的替代方案的索引。
- en: There’s more...
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: A typical way of manipulating the content of a variant is through visitation.
    This is basically the execution of an action based on the alternative held by
    the variant. Since it is a larger topic, it is addressed separately in the next
    recipe.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 操作变体内容的一种典型方式是通过访问。这基本上是基于变体持有的替代方案执行一个动作。由于这是一个较大的主题，它将在下一个菜谱中单独讨论。
- en: See also
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::any to store any value*, to learn how to use the C++17 class `std::any`,
    which represents a type-safe container for single values of any type'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`std::any`存储任何值*，了解如何使用C++17类`std::any`，它代表任何类型的单值类型安全容器'
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 std::optional 存储可选值*，了解 C++17 类模板 `std::optional`，它管理可能存在或不存在的一个值'
- en: '*Visiting a std::variant*, to understand how to perform type matching and execute
    different actions based on the type of a variant’s alternatives'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问 std::variant*，了解如何执行类型匹配并根据变体替代的类型执行不同的操作'
- en: Visiting a std::variant
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 std::variant
- en: '`std::variant` is a new standard container that was added to C++17 based on
    the `boost.variant` library. A variant is a type-safe union that holds the value
    of one of its alternative types. Although, in the previous recipe, we have seen
    various operations with variants, the variants we used were rather simple, with
    POD types mostly, which is not the actual purpose for which `std::variant` was
    created. Variants are intended to be used for holding alternatives of similar
    non-polymorphic and non-POD types. In this recipe, we will see a more real-world
    example of using variants and will learn how to visit variants.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant` 是一个新标准容器，它基于 `boost.variant` 库添加到 C++17 中。变体是一个类型安全的联合体，它持有其替代类型之一的值。尽管在之前的食谱中，我们已经看到了各种变体的操作，但我们使用的变体相当简单，主要是
    POD 类型，这并不是 `std::variant` 被创建的实际目的。变体旨在用于持有类似非多态和非 POD 类型的替代项。在这个食谱中，我们将看到一个更实际的变体使用示例，并学习如何访问变体。'
- en: Getting ready
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should be familiar with the `std::variant` type. It is
    recommended that you first read the previous recipe, *Using std::variant as a
    type-safe union*.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你应该熟悉 `std::variant` 类型。建议你首先阅读之前的食谱，*使用 std::variant 作为类型安全的联合体*。
- en: 'To explain how variant visitation can be done, we will consider a variant for
    representing a media DVD. Let’s suppose we want to model a store or library that
    has DVDs that could contain either music, a movie, or software. However, these
    options are not modeled as a hierarchy with common data and virtual functions,
    but rather as non-related types that may have similar properties, such as a title.
    For simplicity, we’ll consider the following properties:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释如何进行变体访问，我们将考虑一个用于表示媒体 DVD 的变体。假设我们想要模拟一个商店或图书馆，其中包含可能包含音乐、电影或软件的 DVD。然而，这些选项不是作为具有公共数据和虚拟函数的层次结构来建模，而是作为可能具有类似属性（如标题）的非相关类型。为了简单起见，我们将考虑以下属性：
- en: 'For a movie: Title and length (in minutes)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于电影：标题和长度（以分钟为单位）
- en: 'For an album: Title, artist name, and a list of tracks (each track having a
    title and length in seconds)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个专辑：标题、艺术家姓名以及曲目列表（每首曲目都有一个标题和以秒为单位的长度）
- en: 'For software: Title and manufacturer'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于软件：标题和制造商
- en: 'The following code shows a simple implementation of these types, without any
    functions, because that is not relevant to the visitation of a variant holding
    alternatives of these types:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这些类型的简单实现，没有包含任何函数，因为这与访问包含这些类型变体的变体无关：
- en: '[PRE74]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On the other hand, we will utilize the following function to convert text to
    uppercase:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们将使用以下函数将文本转换为大写：
- en: '[PRE75]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With these defined, let’s start looking at how visiting variants should be performed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好这些之后，让我们开始探讨如何执行访问变体。
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To visit a variant, you must provide one or more actions for the possible alternatives
    of the variant. There are several types of visitors, which are used for different
    purposes:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个变体，你必须为变体的可能替代提供一个或多个动作。有几种类型的访问者，用于不同的目的：
- en: 'A void visitor that does not return anything but has side effects. The following
    example prints the title of each DVD to the console:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不返回任何内容但具有副作用的无返回值访问者。以下示例将每张 DVD 的标题打印到控制台：
- en: '[PRE76]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A visitor that returns a value; the value should have the same type, regardless
    of the current alternative of the variant, or can itself be a variant. In the
    following example, we visit a variant and return a new variant of the same type
    that has the `title` property from any of its alternatives transformed to uppercase
    letters:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的访问者；值应该与当前变体的任何替代类型相同，或者本身可以是一个变体。在以下示例中，我们访问一个变体并返回一个具有相同类型的新的变体，其 `title`
    属性从任何替代类型转换为大写字母：
- en: '[PRE77]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'A visitor that does type matching (which can either be a void or a value-returning
    visitor) implemented by providing a function object that has an overloaded call
    operator for each alternative type of the variant:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供具有为变体的每种替代类型重载的调用操作符的函数对象来实现类型匹配的访问者（这可以是空返回值或返回值的访问者）：
- en: '[PRE78]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A visitor that does type matching that is implemented by providing a lambda
    expression that performs an action based on the type of the alternative:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供执行基于替代类型动作的lambda表达式来实现类型匹配的访问者：
- en: '[PRE79]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A visitor is a callable object (a function, a lambda expression, or a function
    object) that accepts every possible alternative from a variant. Visitation is
    done by invoking `std::visit()` with the visitor and one or more variant objects.
    The variants do not have to be of the same type, but the visitor must be able
    to accept every possible alternative from all the variants it is invoked for.
    In the examples earlier, we visited a single variant object, but visiting multiple
    variants does not imply anything more than passing them as arguments to `std::visit()`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者是一个可调用对象（一个函数、一个lambda表达式或一个函数对象），它接受来自变体的所有可能的替代项。通过使用访问者和一个或多个变体对象调用 `std::visit()`
    来进行访问。变体不必是相同的类型，但访问者必须能够接受所有被调用的变体的所有可能的替代项。在先前的示例中，我们访问了一个单个的变体对象，但访问多个变体并不意味着比将它们作为参数传递给
    `std::visit()` 更多的事情。
- en: When you visit a variant, the callable object is invoked with the value currently
    stored in the variant. If the visitor does not accept an argument of the type
    stored in the variant, the program is ill-formed. If the visitor is a function
    object, then it must overload its call operator for all the possible alternative
    types of the variant. If the visitor is a lambda expression, it should be a generic
    lambda, which is basically a function object with a call operator template, instantiated
    by the compiler with the actual type that it is invoked with.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问一个变体时，可调用对象会使用当前存储在变体中的值来调用。如果访问者不接受变体中存储的类型作为参数，则程序是不规范的。如果访问者是一个函数对象，那么它必须为变体的所有可能的替代类型重载其调用操作符。如果访问者是一个lambda表达式，它应该是一个泛型lambda，这基本上是一个具有调用操作符模板的函数对象，由编译器根据实际调用的类型实例化。
- en: Examples of both approaches were shown in the previous section for a type-matching
    visitor. The function object in the first example is straightforward and should
    not require additional explanations. On the other hand, the generic lambda expression
    uses *constexpr if* to select a particular `if` branch based on the type of the
    argument at compile time. The result is that the compiler will create a function
    object with an operator call template and a body that contains *constexpr if*
    statements; when it instantiates that function template, it will produce an overload
    for each possible alternative type of the variant and, in each of these overloads,
    it will select only the *constexpr if* branch that matches the type of the call
    operator argument. The result is conceptually equivalent to the implementation
    of the `visitor_functor` class.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中展示了两种方法类型的访问者示例。第一个示例中的函数对象很简单，不需要额外的解释。另一方面，泛型lambda表达式使用 `constexpr if`
    来根据编译时参数的类型选择特定的 `if` 分支。结果是编译器将创建一个具有操作符调用模板和包含 `constexpr if` 语句的体的函数对象；当它实例化该函数模板时，它将为变体的每种可能的替代类型生成一个重载，并且在每个这些重载中，它将只选择与调用操作符参数类型匹配的
    `constexpr if` 分支。结果是概念上等同于 `visitor_functor` 类的实现。
- en: See also
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::any to store any value*, to learn how to use the C++17 class `std::any`,
    which represents a type-safe container for single values of any type'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::any` 存储任何值*，了解如何使用C++17类 `std::any`，它代表一个类型安全的容器，用于存储任何类型的单个值'
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::optional` 存储可选值*，了解关于C++17类模板 `std::optional` 的信息，该模板管理可能存在或不存在的一个值'
- en: '*Using std::variant as a type-safe union*, to see how to use the C++17 `std::variant`
    class to represent type-safe unions'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::variant` 作为类型安全的联合*，了解如何使用C++17 `std::variant` 类来表示类型安全的联合'
- en: Using std::expected to return a value or an error
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::expected` 返回值或错误
- en: We often need to write a function that returns both some data and an indication
    of success or failure (either as a `bool` for the simplest case or an error code
    for more complex cases). Typically, this can be solved either by returning a status
    code and using a parameter passed by reference for returning the data or by returning
    the actual data but throwing exceptions in the case of failure. In recent times,
    the availability of `std::optional` and `std::variant` gave way to new solutions
    for this problem. However, the C++23 standard provides a new approach with the
    `std::expected` type, a sort of combination of the two types previously mentioned.
    Such a type is present in other programming languages, such as `Result` in Rust
    and `Either` in Haskell. In this recipe, we will learn how to use this new `std::expected`
    class.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要编写一个函数，该函数既返回一些数据，又返回成功或失败的指示（对于最简单的情况，可以是 `bool`，对于更复杂的情况，可以是错误代码）。通常，这可以通过返回状态码并使用通过引用传递的参数来返回数据来解决，或者在实际数据返回失败的情况下抛出异常。近年来，`std::optional`
    和 `std::variant` 的可用性为解决这个问题提供了新的解决方案。然而，C++23 标准通过 `std::expected` 类型提供了一种新的方法，这是一种两种先前提及类型的组合。这种类型存在于其他编程语言中，如
    Rust 中的 `Result` 和 Haskell 中的 `Either`。在本食谱中，我们将学习如何使用这个新的 `std::expected` 类。
- en: Getting ready
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the examples shown in this recipe, we will use the data types defined here:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中展示的示例中，我们将使用在此处定义的数据类型：
- en: '[PRE80]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How to do it…
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You can use the `std::expected<T, E>` type from the new `<expected>` header,
    as shown in the following examples:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用来自新 `<expected>` 头文件的 `std::expected<T, E>` 类型，如下面的示例所示：
- en: 'When returning data from a function, return either `std::unexpected<E>` to
    indicate an error, or the data (a value of `T`) when everything is executed successfully:'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从函数返回数据时，返回 `std::unexpected<E>` 以指示错误，或者在一切执行成功时返回数据（`T` 类型的值）：
- en: '[PRE81]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When checking the result of a function that returns `std::expected<T, E>`,
    use the `bool` operator (or the `has_value()` method) to check if the object holds
    the expected value, and the `value()` and `error()` methods to return the expected
    value or the unexpected error, respectively:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检查返回 `std::expected<T, E>` 的函数的结果时，使用 `bool` 操作符（或 `has_value()` 方法）来检查对象是否包含预期的值，并使用
    `value()` 和 `error()` 方法分别返回预期的值或意外的错误：
- en: '[PRE82]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can compose a chain of operations from functions that return a `std::expected`
    value using the monadic operations `and_then()`, `or_else()`, `transform()`, and
    `transform_error()`:'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用返回 `std::expected` 值的函数通过单调操作 `and_then()`、`or_else()`、`transform()` 和
    `transform_error()` 组成操作链：
- en: '[PRE83]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `std::expected<T, E>` class template is available in the new C++23 header
    called `<expected>`. This class is a mixture of the `std::variant` and the `std::optional`
    types (introduced in C++17) but designed for the purpose of returning data or
    an unexpected value from a function. It has the logical structure of a discriminated
    union since it either holds the value of an expected type `T`, or the value of
    an unexpected type (error) `E`. However, its interface is very similar to the
    `std::optional` class, as it features the following members:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::expected<T, E>` 类模板可在新的 C++23 头文件 `<expected>` 中找到。这个类是 `std::variant`
    和 `std::optional` 类型（C++17 中引入）的混合体，但旨在从函数返回数据或意外值。由于它要么持有预期类型 `T` 的值，要么持有意外类型（错误）`E`
    的值，因此它具有判别联合的逻辑结构。然而，它的接口与 `std::optional` 类非常相似，因为它具有以下成员：'
- en: '| **Function** | **Description** |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `has_value()` | Returns a Boolean value that indicates whether the object
    contains the expected value or not. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `has_value()` | 返回一个布尔值，指示对象是否包含预期的值。|'
- en: '| `operator bool` | Same as `has_value()`. Provided for simpler usage in `if`
    statements (`if(result)` as opposed to `if(result.has_value()`). |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `operator bool` | 与 `has_value()` 相同。提供用于在 `if` 语句中更简单使用的功能（`if(result)`
    相对于 `if(result.has_value())`）。|'
- en: '| `value()` | Returns the expected value, unless the object contains an unexpected
    value. In this case, it throws a `std::bad_expected_access<E>` exception, containing
    the unexpected value. |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `value()` | 返回预期的值，除非对象包含意外的值。在这种情况下，它抛出一个包含意外值的 `std::bad_expected_access<E>`
    异常。|'
- en: '| `value_or()` | Similar to `value()` but, instead of throwing an exception
    if an unexpected value is stored in the object, it returns the supplied, alternative
    value. |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `value_or()` | 与 `value()` 类似，但如果对象中存储了意外的值，它不会抛出异常，而是返回提供的替代值。|'
- en: '| `error()` | Returns the unexpected value. If the object holds an expected
    value, then the behavior is undefined. |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `error()` | 返回意外的值。如果对象包含期望值，则行为未定义。|'
- en: '| `operator->` and `operator*` | Accesses the expected value. If the object
    holds an unexpected value, then the behavior is undefined. |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `operator->` 和 `operator*` | 访问期望值。如果对象包含意外的值，则行为未定义。|'
- en: 'Table 6.2: A listing of the most important members of std::expected'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2：`std::expected` 最重要成员的列表
- en: 'Although it was previously mentioned that the `std::expected` type is a discriminated
    union of two `T` (expected) and `E` (error) types, it is not entirely correct.
    The actual types it holds are either `T` or `std::unexpected<E>`. This latter
    type is a helper class that holds an object of type `E`. There are some restrictions
    on the possible types used for `T` and `E`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前提到 `std::expected` 类型是两个 `T`（期望）和 `E`（错误）类型的区分联合，但这并不完全正确。它实际持有的类型要么是 `T`，要么是
    `std::unexpected<E>`。后者是一个辅助类，用于持有类型为 `E` 的对象。对 `T` 和 `E` 可用类型的有些限制：
- en: '`T` can be either `void` or a destructible type (a type for which a destructor
    can be invoked). Arrays and reference types cannot be substituted for `T`. If
    the type `T` is the `void` type, then the `value_or()` method is not available.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 可以是 `void` 或可销毁的类型（可以调用析构函数的类型）。不能替换 `T` 的类型是数组和引用类型。如果类型 `T` 是 `void`
    类型，则 `value_or()` 方法不可用。'
- en: '`E` must be a destructible type. Arrays, reference types, and `const` and `volatile`
    qualified types cannot be substituted for `E`.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E` 必须是可销毁的类型。数组、引用类型以及 `const` 和 `volatile` 标记的类型不能替换 `E`。'
- en: 'There are cases when you want to apply multiple operations to a value. In our
    example, this could be applying different filters in a row to an image. But it
    could be other things such as resizing the image, changing the format/type, flipping
    in different directions, and so on. Each of these operations could return a `std::expected`
    value. In this case, we can write code as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要对一个值应用多个操作。在我们的例子中，这可能是对图像连续应用不同的过滤器。但这也可能是其他事情，比如调整图像大小、更改格式/类型、在不同方向上翻转等。每个这些操作都可能返回一个
    `std::expected` 值。在这种情况下，我们可以编写如下代码：
- en: '[PRE84]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If no error occurs, then the result of running this program is the following:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，则运行此程序的结果如下：
- en: '[PRE85]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: However, if an error occurs in the `ApplyFilter()` function, invoking the `value()`
    method in the subsequent call would result in a `std::bad_expected_access` exception.
    We actually have to check the result after each operation. This can be improved
    using monadic operations.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在 `ApplyFilter()` 函数中发生错误，后续调用中调用 `value()` 方法将导致 `std::bad_expected_access`
    异常。实际上，我们必须在每次操作后检查结果。这可以使用单一操作来改进。
- en: 'Since the `std::expected` type is very similar to the `std::optional` type,
    the monadic operations available in C++23 for `std::optional` are also available
    to `std::expected`. These are the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::expected` 类型与 `std::optional` 类型非常相似，C++23 中为 `std::optional` 提供的单一操作也适用于
    `std::expected`。以下是一些操作：
- en: '| **Function** | **Description** |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `and_then()` | If the `std::expected` object contains an expected value (of
    type `T`), then it applies a given function on it and returns the result. Otherwise,
    it returns the `std::expected` value. |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| `and_then()` | 如果 `std::expected` 对象包含期望值（类型为 `T`），则对它应用给定的函数并返回结果。否则，返回
    `std::expected` 值。|'
- en: '| `or_else()` | If the `std::expected` object contains an unexpected value
    (of type `E`), then it applies a given function on the unexpected value and returns
    the result. Otherwise, it returns the `std::expected` value. |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| `or_else()` | 如果 `std::expected` 对象包含意外的值（类型为 `E`），则对意外的值应用给定的函数并返回结果。否则，返回
    `std::expected` 值。|'
- en: '| `transform()` | This is similar to `and_then()`, except that the returned
    value is also wrapped in a `std::expected` value. |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| `transform()` | 这与 `and_then()` 类似，但返回的值也被封装在一个 `std::expected` 值中。|'
- en: '| `transform_error()` | This is similar to `or_else()`, except that the returned
    value is also wrapped in a `std::expected` value. |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `transform_error()` | 这与 `or_else()` 类似，但返回的值也被封装在一个 `std::expected` 值中。|'
- en: 'Table 6.3: Monadic operations of std::expected'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3：`std::expected` 的单一操作
- en: 'We can rewrite the code from the last snippet using monadic operations as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单一操作重写上一个代码片段，如下所示：
- en: '[PRE86]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If no error occurs, then the output is the one we already saw. However, if
    an error occurs, let’s say when applying the sepia filter, then the output changes
    to the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，则输出将是我们已经看到的那个。然而，如果发生错误，比如说在应用棕褐色滤镜时，输出将变为以下内容：
- en: '[PRE87]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This example shows only two of the available monadic operations, `and_then()`
    and `or_else()`. The other two, `transform()` and `transform_or()`, are similar
    but they are intended to transform (as the name implies) either the expected or
    the unexpected value into another value. In the following snippet (a modification
    of the previous one), we chain a transform operation for both the expected and
    unexpected value, in either case returning a string:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅展示了可用的两种单子操作，`and_then()` 和 `or_else()`。其他两种，`transform()` 和 `transform_or()`，功能相似，但它们旨在将（正如其名称所暗示的）预期值或意外值转换为另一个值。在以下代码片段（对上一个代码片段的修改）中，我们为预期值和意外值都链式调用了转换操作，在任一情况下都返回一个字符串：
- en: '[PRE88]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If no error occurs during the execution of this program, then the following
    output will be printed:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序执行过程中没有发生错误，则将打印以下输出：
- en: '[PRE89]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'However, if an error occurs during the execution, such as when applying the
    sepia filter, then the output becomes the following:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在执行过程中发生错误，例如在应用棕褐色滤镜时，输出将变为以下内容：
- en: '[PRE90]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the `or_else()` function above, you’ll have noticed the use of `std::unexpected`.
    This is a helper class that acts as a tag for the constructor of `std::expected`
    in order to indicate the construction of an unexpected value. As a result, the
    argument is perfectly forwarded to the constructor of the `E` type (the unexpected
    type). The `has_value()` method will return `false` for the newly created `std::expected`
    value, indicating that it holds an unexpected value.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的 `or_else()` 函数中，你会注意到 `std::unexpected` 的使用。这是一个辅助类，它作为 `std::expected`
    构造函数的标签，以指示意外值的构造。因此，参数被完美转发到 `E` 类型（意外类型）的构造函数中。`has_value()` 方法将返回 `false` 对于新创建的
    `std::expected` 值，表示它包含一个意外值。
- en: See also
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::optional to store optional values*, to learn about the C++17 class
    template `std::optional`, which manages a value that may or may not exist'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::optional` 存储可选值*，了解 C++17 类模板 `std::optional`，它管理可能存在或不存在的数据值'
- en: '*Using std::variant as a type-safe union*, to learn how to use the C++17 `std::variant`
    class to represent type-safe unions'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::variant` 作为类型安全的联合体*，了解如何使用 C++17 `std::variant` 类来表示类型安全的联合体'
- en: Using std::span for contiguous sequences of objects
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::span` 对象的连续序列
- en: In C++17, the `std::string_view` type was added to the standard library. This
    is an object that represents a view over a constant contiguous sequence of characters.
    The view is typically implemented with a pointer to the first element of the sequence
    and a length. Strings are one of the most used data types in any programming language.
    They have a non-owning view that does not allocate memory, avoids copies, and
    performs some operations faster than `std::string`, which is an important benefit.
    However, a string is just a special vector of characters with operations specific
    to text. Therefore, it makes sense to have a type that is a view of a contiguous
    sequence of objects, regardless of their type. This is what the `std::span` class
    template in C++20 represents. We could say that `std::span` is to `std::vector`
    and array types what `std::string_view` is to `std::string`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，`std::string_view` 类型被添加到标准库中。这是一个表示对字符连续序列视图的对象。视图通常使用指向序列第一个元素的指针和长度来实现。字符串是任何编程语言中最常用的数据类型之一。它们有一个非拥有视图，不分配内存，避免复制，并且比
    `std::string` 执行某些操作更快，这是一个重要的好处。然而，字符串只是一个具有特定于文本操作的字符特殊向量。因此，有一个类型，它是对连续序列对象的视图，无论它们的类型如何，这是有意义的。这就是
    C++20 中的 `std::span` 类模板所代表的。我们可以这样说，`std::span` 对于 `std::vector` 和数组类型来说，就像 `std::string_view`
    对于 `std::string` 一样。
- en: Getting ready
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `std::span` class template is available in the header `<span>`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 类模板在头文件 `<span>` 中可用。'
- en: How to do it…
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Use `std::span<T>` instead of a pointer and size pair as you typically would
    with C-like interfaces. In other words, replace functions like this:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::span<T>` 而不是指针和大小对，就像在 C 类接口中通常所做的那样。换句话说，替换如下函数：
- en: '[PRE91]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'with this:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如此：
- en: '[PRE92]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'When working with `std::span`, you can do the following:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `std::span` 时，你可以做以下操作：
- en: 'Create a span with a compile-time length (called *static extent*) by specifying
    the number of elements in the span:'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定跨度中的元素数量来创建具有编译时长度（称为*静态范围*）的跨度：
- en: '[PRE93]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create a span with a runtime length (called *dynamic extent*) by not specifying
    the number of elements in the span:'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不指定跨度中的元素数量来创建具有运行时长度（称为 *动态范围*）的跨度：
- en: '[PRE94]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can use a span in a range-based for loop:'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用跨度在基于范围的 for 循环中：
- en: '[PRE95]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can access the elements of a span using the methods `front()`, `back()`,
    and `data()`, and the `operator[]`:'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `front()`、`back()`、`data()` 方法和 `operator[]` 来访问跨度的元素：
- en: '[PRE96]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can obtain sub-spans of a span with the methods `first()`, `last()`, and
    `subspan()`:'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `first()`、`last()` 和 `subspan()` 方法从跨度中获取子跨度：
- en: '[PRE97]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works…
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::span` class template is not a container of objects but a lightweight
    wrapper that defines a view of a contiguous sequence of objects. Initially, the
    span was called `array_view`, which some argue was a better name, both because
    it clearly indicates that the type is a non-owning view of a sequence and because
    it would be consistent with the name of `string_view`. However, the type was adopted
    in the standard library under the name *span*.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 类模板不是一个对象的容器，而是一个轻量级包装器，它定义了一个连续对象序列的视图。最初，跨度被称为 `array_view`，有人认为这是一个更好的名称，因为它清楚地表明该类型是序列的非拥有视图，并且它与
    `string_view` 的名称保持一致。然而，该类型是在标准库中以 *span* 的名称采用的。'
- en: Although the standard does not specify the implementation details, the span
    is typically implemented by storing a pointer to the first element of the sequence
    and a length, representing the number of elements in the view. Therefore, a span
    can be used to define a non-owning view over (but not only) a `std::vector`, `std::array`,
    `T[]`, or `T*`. However, it cannot be used with lists or associative containers
    (for instance, `std::list`, `std::map`, or `std::set`) because these are not containers
    for a contiguous sequence of elements.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标准没有指定实现细节，跨度通常通过存储指向序列第一个元素的指针和一个长度来实现，该长度表示视图中的元素数量。因此，跨度可以用来定义对（但不限于）`std::vector`、`std::array`、`T[]`
    或 `T*` 的非拥有视图。然而，它不能与列表或关联容器（例如，`std::list`、`std::map` 或 `std::set`）一起使用，因为这些不是连续元素序列的容器。
- en: The span can have either a compile-time size or a runtime size. When the number
    of elements in the span is specified at compile-time, we have a span with a static
    extent (compile-time size). If the number of elements is not specified but determined
    at runtime, we have a dynamic extent.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度可以具有编译时大小或运行时大小。当跨度的元素数量在编译时指定时，我们有一个具有静态范围（编译时大小）的跨度。如果元素数量未指定但在运行时确定，我们有一个动态范围。
- en: 'The `std::span` class has a simple interface, mainly consisting of the following
    members:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span` 类具有简单的接口，主要由以下成员组成：'
- en: '| **Member function** | **Description** |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| **成员函数** | **描述** |'
- en: '| `begin()`, `end()``cbegin()`, `cend()` | Mutable and constant iterators to
    the first and the one-past-last element of the sequence. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `begin()`, `end()`, `cbegin()`, `cend()` | 可变和常量迭代器，分别指向序列的第一个元素和最后一个元素之后的元素。
    |'
- en: '| `rbegin()`, `rend()``cbegin()`, `crend()` | Mutable and constant reverse
    iterators to the beginning and end of the sequence. |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `rbegin()`, `rend()`, `cbegin()`, `crend()` | 可变和常量反向迭代器，分别指向序列的开始和结束。 |'
- en: '| `front()`, `back()` | Accesses the first and last element of the sequence.
    |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `front()`, `back()` | 访问序列的第一个和最后一个元素。 |'
- en: '| `data()` | Returns a pointer to the beginning of the sequence of elements.
    |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `data()` | 返回指向序列元素开头的指针。 |'
- en: '| `operator[]` | Accesses an element of the sequence specified by its index.
    |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `operator[]` | 通过其索引访问序列中的元素。 |'
- en: '| `size()` | Retrieves the number of elements in the sequence. |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 获取序列中的元素数量。 |'
- en: '| `size_bytes()` | Retrieves the size of the sequence in bytes. |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `size_bytes()` | 获取序列的字节数。 |'
- en: '| `empty()` | Checks whether the sequence is empty. |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 检查序列是否为空。 |'
- en: '| `first()` | Retrieves a sub-span with the first *N* elements of the sequence.
    |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `first()` | 获取序列中前 *N* 个元素的子跨度。 |'
- en: '| `last()` | Retrieves a sub-span with the last *N* elements of the sequence.
    |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `last()` | 获取序列中最后 *N* 个元素的子跨度。 |'
- en: '| `subspan()` | Retrieves a sub-span with *N* elements starting from a specified
    offset. If the count *N* is not specified, it returns a span with all the elements
    from offset until the end of the sequence. |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `subspan()` | 从指定的偏移量开始获取具有 *N* 个元素的子跨度。如果未指定计数 *N*，则返回从偏移量到序列末尾的所有元素的跨度。
    |'
- en: 'Table 6.4: A listing of the most important member functions of std::span'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4：std::span 最重要成员函数列表
- en: A span is not intended to be used with general-purpose algorithms that work
    with a pair of iterators to the beginning and the end of a range (such as `sort`,
    `copy`, `find_if`, and so on), nor as a replacement for standard containers. Its
    main purpose is to build better interfaces than the C-like ones where a pointer
    and a size are passed to a function. The user may pass a wrong value for the size,
    which could end in accessing memory beyond the bounds of the sequence. The span
    provides safety and bounds checking. It is also a good alternative to passing
    a constant reference as an argument to a function to `std::vector<T>` (`std::vector<T>
    const &`). The span does not own its elements and is small enough to be passed
    by value (you should not pass spans by reference or constant reference).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Span 不适用于使用一对迭代器（指向范围的开始和结束）的通用算法（如 `sort`、`copy`、`find_if` 等），也不适用于标准容器的替代品。其主要目的是构建比传递指针和大小到函数的
    C 类接口更好的接口。用户可能会传递错误的大小值，这可能导致访问序列之外的内存。Span 提供了安全和边界检查。它也是将常量引用作为函数参数传递给 `std::vector<T>`
    (`std::vector<T> const &`) 的良好替代品。Span 不拥有其元素，足够小，可以按值传递（你不应该通过引用或常量引用传递 Span）。
- en: Unlike `std::string_view`, which does not support changing the value of the
    elements in the sequence, `std::span` defines a mutable view and supports modifying
    its elements. For this purpose, functions such as `front()`, `back()`, and `operator[]`
    return a reference.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 与不支持更改序列中元素值的 `std::string_view` 不同，`std::span` 定义了一个可变视图，并支持修改其元素。为此，函数如 `front()`、`back()`
    和 `operator[]` 返回一个引用。
- en: See also
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 2*, *Using string_view instead of constant string references*, to
    learn how to use `std::string_view` to improve performance in some scenarios when
    working with strings'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*使用 `std::string_view` 而不是常量字符串引用*，了解如何使用 `std::string_view` 在处理字符串时在某些场景中提高性能'
- en: '*Using std::mdspan for multidimensional views of sequences of objects*, to
    learn about the C++23 span class for multi-dimensional sequences'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `std::mdspan` 对对象序列的多维视图进行操作*，了解 C++23 的多维序列 span 类'
- en: Using std::mdspan for multi-dimensional views of sequences of objects
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::mdspan` 对对象序列的多维视图
- en: 'In the previous recipe, *Using std::span for contiguous sequences of objects*,
    we learned about the C++20 class called `std::span`, which represents a view (a
    non-owning wrapper) over a contiguous sequence of elements. This is similar to
    the C++17 `std::string_view` class, which does the same but for a sequence of
    characters. Both of these are views of one-dimensional sequences. However, sometimes
    we need to work with multi-dimensional sequences. These could be implemented in
    many ways, such as C-like arrays (`int[2][3][4]`), pointer-of-pointers (`int**`
    or `int***`), arrays of arrays (or vectors of vectors, such as `vector<vector<vector<int>>>`).
    A different approach is to use a one-dimensional sequence of objects but define
    operations that present it as a logical multi-dimensional sequence. This is what
    the C++23 `std::mdspan` class does: it represents a non-owning view of a contiguous
    sequence of objects presented as a multi-dimensional sequence. We could say that
    `std::mdspan` is an extension of the `std::span` class for multi-dimensional views.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，*使用 `std::span` 对连续对象序列进行操作*，我们学习了 C++20 类 `std::span`，它表示一个连续元素序列的视图（一个非拥有包装器）。这与
    C++17 类 `std::string_view` 类似，它执行相同的操作，但针对字符序列。这两个都是一维序列的视图。然而，有时我们需要处理多维序列。这些可以通过多种方式实现，例如
    C 类数组 (`int[2][3][4]`)、指针的指针 (`int**` 或 `int***`)、数组数组（或向量向量，如 `vector<vector<vector<int>>>`）。另一种方法是使用一维对象序列，但定义操作将其呈现为逻辑上的多维序列。这正是
    C++23 `std::mdspan` 类所做的：它表示一个作为多维序列呈现的连续对象序列的非拥有视图。我们可以这样说，`std::mdspan` 是 `std::span`
    类的多维视图扩展。
- en: Getting ready
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will refer to the following simple implementation of a two-dimensional
    matrix (whose size is known at compile time):'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将参考以下二维矩阵（其大小在编译时已知）的简单实现：
- en: '[PRE98]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In C++23, you should prefer to use `operator[]` instead of `operator()` to access
    elements of a multi-dimensional data structure.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，你应该优先使用 `operator[]` 而不是 `operator()` 来访问多维数据结构的元素。
- en: How to do it…
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Prefer to use `std::mdspan` over multi-dimensional C-like arrays, pointer-of-pointers,
    or vector-of-vector/array-of-array implementations. In other words, replace functions
    like this:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 更倾向于使用 `std::mdspan` 而不是多维 C 样式的数组、指针的指针或向量-向量/数组-数组实现。换句话说，替换如下函数：
- en: '[PRE99]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'with this:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法：
- en: '[PRE100]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'When working with `std::mdspan`, you can do the following:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `std::mdspan` 一起工作时，你可以做以下操作：
- en: 'Create an `mdspan` with a compile-time length (called **static extent**) by
    specifying the number of elements of each dimension of the span:'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定跨度每个维度的元素数量来创建具有编译时长度（称为**静态范围**）的 `mdspan`：
- en: '[PRE101]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Create an `mdspan` with a runtime length (called **dynamic extent**) by not
    specifying the number of elements of a dimension of the span at compile-time,
    and instead providing it at runtime:'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不在编译时指定跨度维度中元素的数量，而是在运行时提供它来创建具有运行时长度（称为**动态范围**）的 `mdspan`：
- en: '[PRE102]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: or
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE103]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: or
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE104]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To control the mapping of the multi-dimensional indexes of an `mdspan` to the
    one-dimensional index of the underlying (contiguous) sequence of data, use a layout
    policy, which is the third template argument:'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要控制 `mdspan` 的多维索引到底层（连续）数据序列的一维索引的映射，请使用布局策略，这是第三个模板参数：
- en: '[PRE105]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: or
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE106]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: or
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE107]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How it works…
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'As the name implies, `mdspan` is a multi-dimensional span. That is a non-owning
    view of a one-dimensional sequence of values that is projected as a logical multi-dimensional
    structure. This is what we saw in the *Getting ready* section, where we defined
    a class called `matrix` that represents a two-dimensional matrix. The operations
    it defines (such as `operator()` and/or `operator[]` in C++23) are specific to
    a 2D data structure. However, internally, the data is laid out in a contiguous
    sequence, a `std::array` in our implementation. We can use this class as follows:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`mdspan` 是一个多维跨度。这是一个非拥有视图，它将一维值序列投影为逻辑的多维结构。这是我们之前在 *准备就绪* 部分看到的内容，在那里我们定义了一个名为
    `matrix` 的类，它表示一个二维矩阵。它定义的操作（如 C++23 中的 `operator()` 和/或 `operator[]`）是特定于 2D
    数据结构的。然而，在内部，数据以连续序列的形式排列，在我们的实现中是一个 `std::array`。我们可以如下使用这个类：
- en: '[PRE108]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This for-in-for sequence sets the values of the matrix elements to the following:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 for-in-for 循环将矩阵元素的值设置为以下：
- en: '[PRE109]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In C++23, we can simply replace this entire class with the `std::mdspan` class:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，我们可以简单地用 `std::mdspan` 类替换整个类：
- en: '[PRE110]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The only thing that changes here is the use of the `extent()` method, which
    previously was a function template member of the `matrix` class. However, this
    is simply a minor detail. We can actually define `matrix` as an alias template
    for `std::mdspan`, as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一改变的是 `extent()` 方法的使用，它之前是 `matrix` 类的一个函数模板成员。然而，这只是一个细节。实际上，我们可以将 `matrix`
    定义为一个别名模板，如下所示：
- en: '[PRE111]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In this example, the `mdspan` is two-dimensional, but it can be defined on
    any number of dimensions. The interface of the `mdspan` type includes the following
    members:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mdspan` 是二维的，但它可以定义在任何数量的维度上。`mdspan` 类型的接口包括以下成员：
- en: '| **Name** | **Description** |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `operator[]` | Provides access to the elements of the underlying data. |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| `operator[]` | 提供对底层数据的访问。 |'
- en: '| `size()` | Returns the number of elements. |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 返回元素的数量。 |'
- en: '| `empty()` | Indicates whether the number of elements is zero. |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 指示元素数量是否为零。 |'
- en: '| `stride()` | Returns the stride of the specified dimension. Unless explicitly
    customized, this is implicitly 1. |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| `stride()` | 返回指定维度的步长。除非明确自定义，否则默认为 1。 |'
- en: '| `extents()` | Returns the size (extent) of the specified dimension. |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| `extents()` | 返回指定维度的尺寸（范围）。 |'
- en: 'Table 6.5: A listing of some member functions of mdspan'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5：mdspan 的一些成员函数列表
- en: 'If you look at the definition of the `std::mdspan` class, you will see the
    following:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `std::mdspan` 类的定义，你会看到以下内容：
- en: '[PRE112]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The first two template arguments are the type of the elements and the extents
    (size) of each dimension. We saw these in the previous examples. The last two,
    however, are customization points:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个模板参数是元素类型和每个维度的范围（大小）。我们在前面的例子中看到了这些。然而，最后两个是定制点：
- en: 'The layout policies control how the multi-dimensional index of an `mdspan`
    maps to the offset in the one-dimensional underlying data. There are several options
    available: `layout_right` (the default) where the rightmost index gives stride-one
    access to the underlying memory (this is the C/C++ style); `layout_left` where
    the leftmost index gives stride-one access to the underlying memory (this is the
    Fortran and Matlab style); and `layout_stride`, which generalizes the previous
    two and allows customizing the stride on each extent. The reasons for having layout
    policies are interoperability with other languages and to change an algorithm’s
    data access pattern without changing the structure of its loop.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局策略控制`mdspan`的多维索引如何映射到一维底层数据的偏移量。有几种选项可供选择：`layout_right`（默认）表示最右边的索引提供对底层内存的步长为1的访问（这是C/C++风格）；`layout_left`表示最左边的索引提供对底层内存的步长为1的访问（这是Fortran和Matlab风格）；以及`layout_stride`，它泛化了前两种，并允许在每个范围上自定义步长。拥有布局策略的原因是与其他语言互操作以及在不改变算法循环结构的情况下更改算法的数据访问模式。
- en: The accessor policy defines how the underlying sequence stores its elements
    and how to use the offset from the layout policy to get a reference to a stored
    element. These are mostly intended for third-party libraries. It’s unlikely you
    need to implement an accessor policy for `std::mdspan`, just as it is unlikely
    you need to define an allocator for `std::vector`.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问策略定义了底层序列如何存储其元素以及如何使用布局策略的偏移量来获取存储元素的引用。这些主要用于第三方库。对于`std::mdspan`实现访问策略的可能性不大，正如定义`std::vector`的分配器一样不太可能。
- en: 'Let’s exemplify the layout policies to understand how they work. The default
    one is `std::layout_right`. We can consider this example, which explicitly specifies
    the policy:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举例说明布局策略，以了解它们是如何工作的。默认的是`std::layout_right`。我们可以考虑这个例子，它明确指定了策略：
- en: '[PRE113]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The two-dimensional matrix defined here has the following content:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的二维矩阵具有以下内容：
- en: '[PRE114]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'However, if we change the layout policy to `std::layout_left`, then the content
    also changes to the following:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将布局策略更改为`std::layout_left`，那么内容也会更改为以下：
- en: '[PRE115]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'However, different strides provide different results. Several examples are
    shown in the following table:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不同的步长提供不同的结果。以下表格中显示了几个示例：
- en: '| **Strides** | **Matrix** |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| **步长** | **矩阵** |'
- en: '| {0, 0} | 1 1 11 1 1 |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| {0, 0} | 1 1 11 1 1 |'
- en: '| {0, 1} | 1 2 31 2 3 |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| {0, 1} | 1 2 31 2 3 |'
- en: '| {1, 0} | 1 1 12 2 2 |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| {1, 0} | 1 1 12 2 2 |'
- en: '| {1, 1} | 1 2 32 3 4 |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| {1, 1} | 1 2 32 3 4 |'
- en: '| {2, 1} | 1 2 33 4 5 |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| {2, 1} | 1 2 33 4 5 |'
- en: '| {1, 2} | 1 3 52 4 6 |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| {1, 2} | 1 3 52 4 6 |'
- en: '| {2, 3} | 1 4 73 6 9 |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| {2, 3} | 1 4 73 6 9 |'
- en: 'Table 6.6: Examples of custom strides and the content of resulting views'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.6：自定义步长和结果视图的内容示例
- en: Let’s discuss the last example, which is perhaps a bit more general. The stride
    of the first extent represents the offset increment for rows. The first element
    is at index 0 in the underlying sequence. Therefore, a stride of 2, as in this
    case, indicates that rows are read from indexes 0, 2, 4, and so on. The stride
    of the second extent represents the offset increment for columns. The first element
    is at the index of the corresponding row. In this example, the index for the first
    row is 0, so a stride of 3 for columns means that the elements of the first row
    will be read from the index 0, 3, and 6\. The second row starts at index 2\. Therefore,
    the elements of the second row will be read from the indexes 2, 5, and 8\. This
    is the last example shown in the previous table.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论最后一个例子，它可能更为通用。第一个范围步长代表行的偏移增量。第一个元素在底层序列中的索引为0。因此，步长为2，如本例所示，表示从索引0、2、4等读取行。第二个范围步长代表列的偏移增量。第一个元素对应行的索引。在这个例子中，第一行的索引为0，因此列的步长为3意味着第一行的元素将从索引0、3和6读取。第二行从索引2开始。因此，第二行的元素将从索引2、5和8读取。这是前表中显示的最后一个例子。
- en: There’s more…
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The original proposal for `mdspan` included a free function called `submdspan()`.
    This function creates a slice of an `mdspan`, or, in other words, a view of a
    subset of an `mdspan`. In order to make it possible for `mdspan` to be included
    in C++23, this function was removed and moved to C++26\. At the time of writing
    this book, it has already been included in C++26, although no compiler supports
    it yet.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`mdspan`的原始提案包括一个名为`submdspan()`的免费函数。此函数创建一个`mdspan`的切片，或者说，是`mdspan`子集的视图。为了使`mdspan`能够包含在C++23中，此函数被移除并移至C++26。在撰写本书时，它已经包含在C++26中，尽管还没有编译器支持它。'
- en: See also
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::span for contiguous sequences of objects*, to learn how to use
    non-owning views over contiguous sequences of elements'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`std::span`处理连续对象序列*，了解如何使用对连续元素序列的非拥有视图'
- en: Registering a function to be called when a program exits normally
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册在程序正常退出时被调用的函数
- en: It is common that a program, upon exit, must clean up code to release resources,
    write something to a log, or do some other end operation. The standard library
    provides two utility functions that enable us to register functions to be called
    when a program terminates normally, either by returning from `main()` or through
    a call to `std::exit()` or `std::quick_exit()`. This is particularly useful for
    libraries that need to perform an action before the program is terminated, without
    relying on the user to explicitly call an end function. In this recipe, you will
    learn how to install exit handlers and how they work.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在退出时通常需要清理代码以释放资源，向日志中写入内容，或者执行其他结束操作。标准库提供了两个实用函数，使我们能够注册在程序正常终止时被调用的函数，无论是通过从`main()`返回还是通过调用`std::exit()`或`std::quick_exit()`。这对于需要在程序终止前执行操作而无需用户显式调用结束函数的库特别有用。在本食谱中，你将学习如何安装退出处理程序以及它们是如何工作的。
- en: Getting ready
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the functions discussed in this recipe, `exit()`, `quick_exit()`, `atexit()`,
    and `at_quick_exit()`, are available in the namespace `std` in the header `<cstdlib>`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中讨论的所有函数，`exit()`、`quick_exit()`、`atexit()`和`at_quick_exit()`，都可在`<cstdlib>`头文件中`std`命名空间中找到。
- en: How to do it...
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To register functions to be called upon termination of a program, you should
    use the following:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册在程序终止时被调用的函数，你应该使用以下方法：
- en: '`std::atexit()` to register functions to be invoked when they return from `main()`
    or when a call to `std::exit()` is made:'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::atexit()`注册在从`main()`返回或调用`std::exit()`时被调用的函数：
- en: '[PRE117]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`std::at_quick_exit()` to register functions to be invoked when a call to `std::quick_exit()`
    is made:'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::at_quick_exit()`注册在调用`std::quick_exit()`时被调用的函数：
- en: '[PRE118]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How it works...
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The exit handlers, regardless of the method they are registered with, are called
    only when the program terminates normally or quickly. If termination is done in
    an abnormal way, via a call to `std::terminate()` or `std::abort()`, none of them
    are called. If any of these handlers exits via an exception, then `std::terminate()`
    is called. Exit handlers must not have any parameters and must return `void`.
    Once registered, an exit handler cannot be unregistered.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 不论使用何种方法注册的退出处理程序，只有在程序正常或快速终止时才会被调用。如果以异常方式终止，通过调用`std::terminate()`或`std::abort()`，则它们都不会被调用。如果任何处理程序通过异常退出，则调用`std::terminate()`。退出处理程序不得有任何参数，并且必须返回`void`。一旦注册，退出处理程序就不能取消注册。
- en: A program can install multiple handlers. The standard guarantees that at least
    32 handlers can be registered with each method, although actual implementations
    can support any higher number. Both `std::atexit()` and `std::at_quick_exit()`
    are thread-safe and, therefore, can be called simultaneously from different threads
    without incurring race conditions.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以安装多个处理程序。标准保证每种方法至少可以注册32个处理程序，尽管实际实现可以支持任何更高的数字。`std::atexit()`和`std::at_quick_exit()`都是线程安全的，因此可以从不同的线程同时调用，而不会产生竞争条件。
- en: 'If multiple handlers are registered, then they are called in the reverse order
    of their registration. The following table shows the output of a program that
    registered the exit handlers, as shown in the previous section, when the program
    terminates via a `std::exit()` call and a `std::quick_exit()` call:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册了多个处理程序，则它们将按照注册的相反顺序被调用。以下表格显示了注册了退出处理程序的程序（如前节所示）在通过`std::exit()`调用和`std::quick_exit()`调用终止时的输出：
- en: '| `std::exit(0);` | `std::quick_exit(0);` |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| `std::exit(0);` | `std::quick_exit(0);` |'
- en: '|'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE119]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '|'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE120]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '|'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Table 6.7: Output of the previous snippet when exiting because of a call to
    exit() and quick_exit()'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.7：当由于调用exit()和quick_exit()而退出时，前一个代码片段的输出
- en: On the other hand, on normal termination of the program, destruction of objects
    with local storage duration, destruction of objects with static storage duration,
    and calls to registered exit handlers are done concurrently. However, it is guaranteed
    that exit handlers registered before the construction of a static object are called
    after the destruction of that static object, and exit handlers registered after
    the construction of a static object are called before the destruction of that
    static object.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在程序正常终止时，具有局部存储期的对象的析构、具有静态存储期的对象的析构以及调用已注册的退出处理程序是并发执行的。然而，可以保证在静态对象的构造之前注册的退出处理程序将在该静态对象析构之后调用，而在静态对象构造之后注册的退出处理程序将在该静态对象析构之前调用。
- en: 'To better exemplify this, let’s consider the following class:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这一点，让我们考虑以下类：
- en: '[PRE121]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In this context, we will refer to the following code snippet:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，我们将引用以下代码片段：
- en: '[PRE122]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Lambda expression
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: '`exit_handler_2`'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exit_handler_2`'
- en: Destructor of `static_foo`
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static_foo`的析构函数'
- en: '`exit_handler_1`'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exit_handler_1`'
- en: 'The output for the preceding program is listed here:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 上一程序的输出如下所示：
- en: '[PRE123]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: When `std::at_quick_exit()` is used, the registered functions are not called
    in the case of normal program termination. If a function needs to be called in
    that case, you must register it with `std::atexit()`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`std::at_quick_exit()`时，在正常程序终止的情况下，不会调用已注册的函数。如果需要在那种情况下调用函数，您必须使用`std::atexit()`来注册它。
- en: See also
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 3*, *Using lambdas with standard algorithms*, to explore the basics
    of lambda expressions and how you can utilize them with the standard algorithms'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三章*，*使用标准算法与lambda表达式*，以探索lambda表达式的基础知识以及如何利用它们与标准算法'
- en: Using type traits to query properties of types
  id: totrans-649
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型特性查询类型的属性
- en: Template metaprogramming is a powerful feature of the language that enables
    us to write and reuse generic code that works with all types. In practice, however,
    it is often necessary that generic code should work differently, or not at all,
    with different types, either through intent or for semantic correctness, performance,
    or other reasons. For example, you may want a generic algorithm to be implemented
    differently for POD and non-POD types or a function template to be instantiated
    only with integral types. C++11 provides a set of type traits to help with this.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程是语言的一个强大功能，它使我们能够编写和重用适用于所有类型的通用代码。在实践中，通常有必要使通用代码对不同的类型工作方式不同，或者根本不工作，无论是出于意图还是为了语义正确性、性能或其他原因。例如，您可能希望通用算法对POD和非POD类型有不同的实现，或者函数模板仅对整数类型进行实例化。C++11提供了一套类型特性来帮助解决这个问题。
- en: Type traits are basically meta-types that provide information about other types.
    The type traits library contains a long list of traits for querying type properties
    (such as checking whether a type is an integral type or whether two types are
    the same), but also for performing type transformation (such as removing the `const`
    and `volatile` qualifiers or adding a pointer to a type). We have used type traits
    in several recipes earlier in this book; however, in this recipe, we will look
    into what the type traits are and how they work.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性基本上是元类型，它们提供了关于其他类型的信息。类型特性库包含了一个用于查询类型属性（例如检查一个类型是否是整数类型或两个类型是否相同）的特性和类型转换（例如移除`const`和`volatile`限定符或向类型添加指针）的长列表。我们已经在本书的几个配方中使用了类型特性；然而，在这个配方中，我们将探讨类型特性是什么以及它们是如何工作的。
- en: Getting ready
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All type traits introduced in C++11 are available in the namespace `std` in
    the `<type_traits>` header.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中引入的所有类型特性都在`<type_traits>`头文件中的`std`命名空间中可用。
- en: Type traits can be used in many metaprogramming contexts, and throughout this
    book, we have seen them used in various situations. In this recipe, we will summarize
    some of these use cases and see how type traits work.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性可以在许多元编程上下文中使用，并且在这本书中，我们已经看到它们在各种情况下被使用。在这个配方中，我们将总结一些这些用例，并了解类型特性是如何工作的。
- en: In this recipe, we will discuss full and partial template specialization. Familiarity
    with these concepts will help you better understand the way type traits work.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将讨论完全和部分模板特化。对这些概念的了解将帮助您更好地理解类型特性的工作方式。
- en: How to do it...
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following list shows various situations where type traits are used to achieve
    various design goals:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用类型特性实现各种设计目标的各种情况：
- en: 'With `enable_if` to define preconditions for the types a function template
    can be instantiated with:'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `enable_if` 来定义函数模板可以实例化的类型的先决条件：
- en: '[PRE124]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'With `static_assert` to ensure that invariants are met:'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `static_assert` 来确保满足不变性：
- en: '[PRE125]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'With `std::conditional` to select between types:'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::conditional` 在类型之间进行选择：
- en: '[PRE126]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'With `constexpr if` to enable the compiler to generate different code based
    on the type the template is instantiated with:'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `constexpr if` 来使编译器能够根据模板实例化的类型生成不同的代码：
- en: '[PRE127]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: How it works...
  id: totrans-666
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Type traits are classes that provide meta-information about types or can be
    used to modify types. There are actually two categories of type traits:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性是提供关于类型或可以用来修改类型的元信息的类。实际上有两种类型的类型特性：
- en: Traits that provide information about types, their properties, or their relations
    (such as `is_integer`, `is_arithmetic`, `is_array`, `is_enum`, `is_class`, `is_const`,
    `is_trivial`, `is_standard_layout`, `is_constructible`, `is_same`, and so on).
    These traits provide a constant `bool` member called `value`.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有关类型、其属性或其关系信息（如 `is_integer`、`is_arithmetic`、`is_array`、`is_enum`、`is_class`、`is_const`、`is_trivial`、`is_standard_layout`、`is_constructible`、`is_same`
    等）的特性。这些特性提供了一个名为 `value` 的 `const bool` 成员。
- en: Traits that modify properties of types (such as `add_const`, `remove_const`,
    `add_pointer`, `remove_pointer`, `make_signed`, `make_unsigned`, and so on). These
    traits provide a member typedef called `type` that represents the transformed
    type.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改类型属性的特性（如 `add_const`、`remove_const`、`add_pointer`、`remove_pointer`、`make_signed`、`make_unsigned`
    等）。这些特性提供了一个名为 `type` 的成员 typedef，它表示转换后的类型。
- en: 'Both of these categories of types have been shown in the *How to do it...*
    section; examples have been discussed and explained in detail in other recipes.
    For convenience, a short summary is provided here:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这两类类型已经在 *如何做...* 部分中展示过；示例在其他菜谱中已经详细讨论和解释。为了方便，这里提供了一个简短的总结：
- en: In the first example, the function template `multiply()` is allowed to be instantiated
    only with arithmetic types (that is, integral or floating point); when instantiated
    with a different kind of type, `enable_if` does not define a typedef member called
    `type`, which produces a compilation error.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个示例中，函数模板 `multiply()` 只允许用算术类型（即整数或浮点数）实例化；当用不同类型的类型实例化时，`enable_if` 不会定义一个名为
    `type` 的 typedef 成员，这将产生编译错误。
- en: In the second example, `pod_wrapper` is a class template that is supposed to
    be instantiated only with POD types. A `static_assert` declaration produces a
    compilation error if a non-POD type is used (it is either not trivial or not in
    the standard layout).
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个示例中，`pod_wrapper` 是一个类模板，它应该只使用 POD 类型实例化。如果使用非 POD 类型（它既不是平凡的也不是标准布局），`static_assert`
    声明将产生编译错误。
- en: In the third example, `const_wrapper` is a class template that provides a typedef
    member called `const_type` that represents a constant-qualified type.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三个示例中，`const_wrapper` 是一个类模板，它提供了一个名为 `const_type` 的 typedef 成员，它表示一个常量合格类型。
- en: 'In this example, we used `std::conditional` to select between two types at
    compile time: if the type parameter `T` is already a const type, then we just
    select `T`. Otherwise, we use the `add_const` type trait to qualify the type with
    the `const` specifier.'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了 `std::conditional` 在编译时选择两种类型：如果类型参数 `T` 已经是一个 const 类型，那么我们只选择
    `T`。否则，我们使用 `add_const` 类型特性用 `const` 说明符修饰类型。
- en: 'If the fourth example, `process()` is a function template that contains a series
    of `if constexpr` branches. Based on the category of type, queried at compile
    time with various type traits (`is_same`, `is_integer`, `is_floating_point`),
    the compiler selects one branch only to be put into the generated code and discards
    the rest. Therefore, a call such as `process(42)` will produce the following instantiation
    of the function template:'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第四个示例中，`process()` 是一个包含一系列 `if constexpr` 分支的函数模板。根据在编译时通过各种类型特性（如 `is_same`、`is_integer`、`is_floating_point`）查询到的类型类别，编译器只会选择一个分支放入生成的代码中，其余的将被丢弃。因此，像
    `process(42)` 这样的调用将产生以下函数模板的实例化：
- en: '[PRE128]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Type traits are implemented by providing a class template and a partial or
    full specialization for it. The following represent conceptual implementations
    for some type traits:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性是通过提供一个类模板及其部分或完全特化来实现的。以下是一些类型特性的概念实现示例：
- en: 'The `is_void()` method indicates whether a type is `void`; this uses full specialization:'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_void()`方法指示一个类型是否为`void`；这使用了完全特化：'
- en: '[PRE129]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The `is_pointer()` method indicates whether a type is a pointer to an object
    or a pointer to a function; this uses partial specialization:'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_pointer()`方法指示一个类型是否是指向对象的指针或指向函数的指针；这使用了部分特化：'
- en: '[PRE130]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The `enable_if()` type trait defines a type alias for its type template parameter
    if and only if its non-type template parameter is an expression that evaluates
    to `true`:'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable_if()`类型特质仅在非类型模板参数是一个评估为`true`的表达式时，为其类型模板参数定义一个类型别名：'
- en: '[PRE131]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Because the use of the `bool` member `value` for the traits of query properties
    (such as `std::is_integer<int>::value`), or for the member types alias called
    `type` for traits that modify type properties (such as `std::enable_if<true, T>::type`)
    is too verbose (and long), the C++14 and C++17 standards have introduced some
    helpers to simplify the use:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询属性（如`std::is_integer<int>::value`）的特质或修改类型属性的特质（如`std::enable_if<true, T>::type`）中使用的`bool`成员`value`太冗长（且长），C++14和C++17标准引入了一些辅助工具以简化使用：
- en: 'A variable template of the form `std::trait_v<T>` for `std::trait<T>::value`.
    An example is `std::is_integer_v<T>`, which is defined as follows:'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式为`std::trait_v<T>`的变量模板是`std::trait<T>::value`的别名。一个例子是`std::is_integer_v<T>`，其定义如下：
- en: '[PRE132]'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'An alias template of the form `std::trait_t<T>` for `std::trait<T>::type`.
    An example is `std::enable_if_t<B, T>`, which is defined as follows:'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::trait_t<T>`形式的别名模板是`std::trait<T>::type`的别名。一个例子是`std::enable_if_t<B,
    T>`，其定义如下：'
- en: '[PRE133]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note that, in C++20, the concept of the POD type has been deprecated. This also
    includes the deprecation of the `std::is_pod` type trait. A POD type is a type
    that is both *trivial* (has special members that are compiler-provided or explicitly
    defaulted and occupy a contiguous memory area) and has a *standard layout* (a
    class that does not contain language features, such as virtual functions, which
    are incompatible with the C language, and all members have the same access control).
    Therefore, as of C++20, the more fine-grained concepts of trivial and standard
    layout types are preferred. This also implies that you should no longer use `std::is_pod`,
    but `std::is_trivial` and, respectively, `std::is_standard_layout`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在C++20中，POD类型的概念已被弃用。这还包括`std::is_pod`类型特质的弃用。POD类型是一种既是*平凡的*（具有编译器提供的或显式默认的特殊成员，并占用连续的内存区域）又具有*标准布局*（不包含与C语言不兼容的语言特性，如虚函数，并且所有成员具有相同的访问控制）的类型。因此，从C++20开始，更精细的平凡和标准布局类型概念更受欢迎。这也意味着您不应再使用`std::is_pod`，而应使用`std::is_trivial`和`std::is_standard_layout`。
- en: There’s more...
  id: totrans-690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Type traits are not limited to what the standard library provides. Using similar
    techniques, you can define your own type traits to achieve various goals. In the
    next recipe, *Writing your own type traits*, we will learn how to define and use
    our own type traits.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特质不仅限于标准库提供的。使用类似的技术，您可以定义自己的类型特质以实现各种目标。在下一道菜谱*编写自己的类型特质*中，我们将学习如何定义和使用自己的类型特质。
- en: See also
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 4*, *Selecting branches at compile time with constexpr if*, to learn
    how to compile only parts of your code with *constexpr if* statements'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*使用constexpr if在编译时选择分支*，了解如何仅使用`constexpr if`语句编译代码的一部分'
- en: '*Chapter 4*, *Conditionally compiling classes and functions with enable_if*,
    to learn about SFINAE and how to use it to specify type constraints for templates'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*使用enable_if条件编译类和函数*，了解SFINAE以及如何使用它为模板指定类型约束'
- en: '*Chapter 4*, *Performing compile-time assertion checks with static_assert*,
    to see how to define assertions that are verified at compile time'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*使用static_assert进行编译时断言检查*，了解如何定义在编译时验证的断言'
- en: '*Writing your own type traits*, to learn how to define your own type traits'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写自己的类型特质*，了解如何定义自己的类型特质'
- en: '*Using std::conditional to choose between types*, to understand how to perform
    a compile-time selection of types on a compile-time Boolean expression'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`std::conditional`在类型之间进行选择*，了解如何在编译时布尔表达式中执行类型的编译时选择'
- en: Writing your own type traits
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的类型特质
- en: In the previous recipe, we learned what type traits are, what traits the standard
    provides, and how they can be used for various purposes. In this recipe, we’ll
    go a step further and take a look at how to define our own custom traits.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们学习了类型特质是什么，标准提供了哪些特质，以及它们如何用于各种目的。在本菜谱中，我们将更进一步，看看如何定义我们自己的自定义特质。
- en: Getting ready
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will learn how to solve the following problem: we have several
    classes that support serialization. Without getting into any details, let’s suppose
    some provide a “plain” serialization to a string (regardless of what that can
    mean), whereas others do it based on a specified encoding. The end goal is to
    create a single, uniform API for serializing the objects of any of these types.
    For this, we will consider the following two classes: `foo`, which provides a
    simple serialization, and `bar`, which provides serialization with encoding.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何解决以下问题：我们有一些支持序列化的类。不深入细节，假设其中一些提供了一种“纯”序列化到字符串的方式（无论这意味着什么），而其他一些基于指定的编码进行序列化。最终目标是创建一个单一、统一的
    API 来序列化任何这些类型的对象。为此，我们将考虑以下两个类：提供简单序列化的 `foo` 类，以及提供带编码序列化的 `bar` 类。
- en: 'Let’s look at the code:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE134]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: It is recommended that you read the preceding *Using type traits to query properties
    of types* recipe first before you continue with this one.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在继续阅读本菜谱之前，首先阅读前面的 *使用类型特性查询类型的属性* 菜谱。
- en: How to do it...
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Implement the following class and function templates:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 实现以下类和函数模板：
- en: 'A class template called `is_serializable_with_encoding` containing a `static`
    `const` `bool` variable set to `false`:'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `is_serializable_with_encoding` 的类模板，其中包含一个设置为 `false` 的 `static const
    bool` 变量：
- en: '[PRE135]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'A full specialization of the `is_serializable_with_encoding` template for the
    class `bar` that has the `static` `const` `bool` variable set to `true`:'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_serializable_with_encoding` 模板对类 `bar` 的完全特化，其中 `static const bool` 变量设置为
    `true`：'
- en: '[PRE136]'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'A class template called `serializer` containing a static template method called
    `serialize`, which takes an argument of the template type `T` and calls `serialize()`
    for that object:'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `serializer` 的类模板，其中包含一个名为 `serialize` 的静态模板方法，它接受一个模板类型 `T` 的参数，并调用该对象的
    `serialize()`：
- en: '[PRE137]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'A full specialization class template for `true`, whose `serialize()` static
    method calls `serialize_with_encoding()` for the argument:'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `true` 的完全特化类模板，其 `serialize()` 静态方法为参数调用 `serialize_with_encoding()`：
- en: '[PRE138]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'A function template called `serialize()`, which uses the `serializer` class
    templates defined previously and the `is_serializable_with_encoding` type trait,
    to select which of the actual serialization methods (plain or with encoding) should
    be called:'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `serialize()` 的函数模板，它使用之前定义的 `serializer` 类模板和 `is_serializable_with_encoding`
    类型特性，来选择应该调用实际的哪种序列化方法（纯或带编码）：
- en: '[PRE139]'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works...
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`is_serializable_with_encoding` is a type trait that checks whether a type
    `T` is serializable with (a specified) encoding. It provides a static member of
    the type `bool` called `value` that is equal to `true` if `T` supports serialization
    with encoding, or `false` otherwise. It is implemented as a class template with
    a single type template parameter `T`; this class template is fully specialized
    for the types that support encoded serialization—in this particular example—for
    the class `bar`:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_serializable_with_encoding` 是一个类型特性，用于检查类型 `T` 是否可以使用（指定的）编码进行序列化。它提供了一个类型
    `bool` 的静态成员，名为 `value`，如果 `T` 支持使用编码进行序列化，则其值等于 `true`，否则为 `false`。它被实现为一个具有单个类型模板参数
    `T` 的类模板；这个类模板对支持编码序列化的类型进行了完全特化——在这个特定例子中，对类 `bar` 进行了特化：'
- en: '[PRE140]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The `serialize()` method is a function template that represents a common API
    for serializing objects that support either type of serialization. It takes a
    single argument of the type template parameter `T` and uses a helper class template
    `serializer` to call either the `serialize()` or `serialize_with_encoding()` method
    of its argument.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize()` 方法是一个函数模板，它代表了一个支持两种序列化方式的对象的通用 API。它接受一个类型模板参数 `T` 的单个参数，并使用辅助类模板
    `serializer` 来调用其参数的 `serialize()` 或 `serialize_with_encoding()` 方法。'
- en: The `serializer` type is a class template with a single, non-type template parameter
    of the type `bool`. This class template contains a static function template called
    `serialize()`. This function template takes a single parameter of the type template
    parameter `T`, calls `serialize()` on the argument, and returns the value returned
    from that call. The `serializer` class template has a full specialization for
    the value `true` of its non-type template parameter. In this specialization, the
    function template `serialize()` has an unchanged signature, but calls `serialize_with_encoding()`
    instead of `serialize()`.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`serializer`类型是一个只有一个非类型模板参数（类型为`bool`）的类模板。这个类模板包含一个名为`serialize()`的静态函数模板。这个函数模板接受一个类型模板参数`T`的单个参数，对参数调用`serialize()`，并返回该调用返回的值。`serializer`类模板对其非类型模板参数的值`true`有一个完全特化。在这个特化中，函数模板`serialize()`具有未更改的签名，但调用`serialize_with_encoding()`而不是`serialize()`。'
- en: The selection between using the generic or the fully specialized class template
    is done in the `serialize()` function template using the `is_serializable_with_encoding`
    type trait. The static member `value` of the type trait is used as the argument
    for the non-type template parameter of `serializer`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在`serialize()`函数模板中使用`is_serializable_with_encoding`类型特性来完成使用泛型或完全特化的类模板之间的选择。类型特性中的静态成员`value`用作`serializer`的非类型模板参数的参数。
- en: 'With all that defined, we can write the following code:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有这些之后，我们可以编写以下代码：
- en: '[PRE141]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: See also
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using type traits to query properties of types*, to explore a C++ meta-programming
    technique that allows us to inspect and transform properties of types'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用类型特性查询类型的属性*，探索一种C++元编程技术，允许我们检查和转换类型的属性'
- en: '*Using std::conditional to choose between types*, to understand how to perform
    a compile-time selection of types on a compile-time Boolean expression'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用std::conditional在类型之间进行选择*，了解如何在编译时基于编译时布尔表达式执行类型的编译时选择'
- en: Using std::conditional to choose between types
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::conditional在类型之间进行选择
- en: In the previous recipes, we looked at some of the features from the type support
    library, and type traits in particular. Related topics have been discussed in
    other parts of this book, such as using `std::enable_if` to hide function overloads
    in *Chapter 4*, *Preprocessing and Compilation*, and `std::decay` to remove `const`
    and `volatile` qualifiers when we discussed visiting variants, also in this chapter.
    Another type transformation feature worth discussing to a larger extent is `std::conditional`,
    which enables us to choose between two types at compile time, based on a compile-time
    Boolean expression. In this recipe, you will learn how it works and how to use
    it through several examples.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们查看了一些类型支持库的功能，特别是类型特性。相关主题在其他部分的本章中有所讨论，例如在*第4章*，*预处理和编译*中使用`std::enable_if`来隐藏函数重载，以及在本章讨论访问变体时使用的`std::decay`来移除`const`和`volatile`限定符。另一个值得更深入讨论的类型转换功能是`std::conditional`，它允许我们根据编译时布尔表达式在编译时选择两种类型。在本配方中，您将通过几个示例了解它是如何工作的以及如何使用它。
- en: Getting ready
  id: totrans-730
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended that you first read the *Using type traits to query properties
    of types* recipe, earlier in this chapter.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您首先阅读本章前面提到的*使用类型特性查询类型的属性*配方。
- en: How to do it...
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a list of examples that show you how to use `std::conditional`
    (and `std::conditional_t`), available in the `<type_traits>` header, to choose
    between two types at compile time:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，展示了如何使用在`<type_traits>`头文件中可用的`std::conditional`（以及`std::conditional_t`），在编译时选择两种类型：
- en: 'In a type alias or typedef to select between a 32-bit and 64-bit integer type,
    based on the platform (the pointer size is 4 bytes on 32-bit platforms and 8 bytes
    on 64-bit platforms):'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型别名或typedef中，根据平台选择32位和64位整数类型（在32位平台上指针大小为4字节，在64位平台上为8字节）：
- en: '[PRE142]'
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In an alias template to select between an 8-, 16-, 32-, or 64-bit integer type,
    based on the user specification (as a non-type template parameter):'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在别名模板中，根据用户指定（作为一个非类型模板参数）选择8位、16位、32位或64位整数类型：
- en: '[PRE143]'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'In a type template parameter to select between an integer and real uniform
    distribution, depending on whether the type template parameter is of an integral
    or floating-point type:'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型模板参数中，根据类型模板参数是整数类型还是实数均匀分布类型来选择，具体取决于类型模板参数是否为整数类型：
- en: '[PRE144]'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: How it works...
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::conditional` is a class template that defines a member called `type`
    as either one or the other of its two type template parameters. This selection
    is done based on a compile-time constant Boolean expression provided as an argument
    for a non-type template parameter. Its implementation looks like this:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::conditional`是一个类模板，它定义了一个名为`type`的成员，该成员可以是它的两个类型模板参数之一。这个选择是基于作为非类型模板参数的编译时常量布尔表达式提供的。它的实现如下所示：'
- en: '[PRE145]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Let’s summarize the examples from the previous section:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下上一节中的例子：
- en: In the first example, if the platform is 32-bit, then the size of the pointer
    type is 4 bytes and, therefore, the compile-time expression `sizeof(void*) <=
    4` is `true`; as a result, `std::conditional` defines its member type as `long`.
    If the platform is 64-bit, then the condition evaluates to `false` because the
    size of the pointer type is 8 bytes; therefore, the member type is defined as
    `long long`.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个例子中，如果平台是32位的，那么指针类型的大小是4字节，因此编译时表达式`sizeof(void*) <= 4`是`true`；因此，`std::conditional`将其成员类型定义为`long`。如果平台是64位的，那么条件评估为`false`，因为指针类型的大小是8字节；因此，成员类型被定义为`long
    long`。
- en: A similar situation is encountered in the second example, where `std::conditional`
    is used multiple times to emulate a series of `if...else` statements to select
    an appropriate type.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个例子中，也遇到了类似的情况，其中多次使用`std::conditional`来模拟一系列`if...else`语句以选择合适的数据类型。
- en: In the third example, we used the alias template `std::conditional_t` to simplify
    the declaration of the function template `GenerateRandom`. Here, `std::conditional`
    is used to define the default value for a type template parameter representing
    a statistical distribution. Depending on whether the first type template parameter
    `T` is an integral or floating-point type, the default distribution type is chosen
    between `std::uniform_int_distribution<T>` and `std::uniform_real_distribution<T>`.
    The use of other types is disabled by employing `std::enable_if` with a third
    template parameter, as we have seen in other recipes already.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三个例子中，我们使用了别名模板`std::conditional_t`来简化函数模板`GenerateRandom`的声明。在这里，`std::conditional`用于定义表示统计分布的类型模板参数的默认值。根据第一个类型模板参数`T`是整数类型还是浮点类型，默认分布类型将在`std::uniform_int_distribution<T>`和`std::uniform_real_distribution<T>`之间选择。通过使用带有第三个模板参数的`std::enable_if`来禁用其他类型的使用，正如我们在其他菜谱中已经看到的那样。
- en: 'To help simplify the use of `std::conditional`, C++14 provides an alias template
    called `std::conditional_t`, which we have seen in the examples here, and which
    is defined as follows:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助简化`std::conditional`的使用，C++14提供了一个名为`std::conditional_t`的别名模板，我们在这里已经看到过，其定义如下：
- en: '[PRE146]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The use of this helper class (and the many others that are similar and from
    the standard library) is optional but helps with writing more concise code.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个辅助类（以及许多其他类似的标准库中的类）是可选的，但有助于编写更简洁的代码。
- en: See also
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using type traits to query properties of types*, to explore a C++ metaprogramming
    technique that allows us to inspect and transform properties of types'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用类型特性查询类型的属性*，探索一种C++元编程技术，该技术允许我们检查和转换类型的属性'
- en: '*Writing your own type traits*, to learn how to define your own type traits'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写自己的类型特性*，学习如何定义自己的类型特性'
- en: '*Chapter 4*, *Conditionally compiling classes and functions with enable_if*,
    to learn about SFINAE and how to use it to specify type constraints for templates'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*使用enable_if条件编译类和函数*，学习SFINAE及其如何用于指定模板的类型约束'
- en: Providing logging details with source_location
  id: totrans-754
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用source_location提供日志细节
- en: Debugging is an essential part of software development. No matter how simple
    or complex it is, no program works as intended from the first shot. Therefore,
    developers spend a considerable amount of time debugging their code, employing
    various tools and techniques from debuggers to messages printed to a console or
    a text file. Sometimes, we want to provide detailed information about the source
    of a message in a log, including the file, the line, and maybe the function name.
    Although this was possible with some standard macros, in C++20, a new utility
    type called `std::source_location` allows us to do it in a modern way. In this
    recipe, we will learn how.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是软件开发的一个基本部分。无论它多么简单或复杂，没有程序会从第一次尝试就按预期工作。因此，开发者会花费大量时间调试他们的代码，使用从调试器到打印到控制台或文本文件的多种工具和技术。有时，我们希望在日志中提供有关消息来源的详细信息，包括文件、行号和可能的功能名。尽管这可以通过一些标准宏实现，但在
    C++20 中，一个新的实用类型 `std::source_location` 允许我们以现代方式完成它。在本食谱中，我们将学习如何实现。
- en: How to do it…
  id: totrans-756
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To log information including the file name, line number, and function name,
    do the following:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录包括文件名、行号和函数名的信息，请执行以下操作：
- en: Define a logging function with parameters for all information that you need
    to provide (such as message, severity, etc.).
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个带有所有需要提供的信息（如消息、严重性等）参数的日志函数。
- en: Add one additional parameter of the type `std::source_location` (for which you
    have to include the `<source_location>` header) with the default value `std::source_location::current()`.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个类型为 `std::source_location` 的额外参数（您必须包含 `<source_location>` 头文件），默认值为 `std::source_location::current()`。
- en: Use member functions `file_name()`, `line()`, `column()`, and `function_name()`
    to retrieve information about the source of the invocation.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用成员函数 `file_name()`、`line()`、`column()` 和 `function_name()` 来检索调用源的信息。
- en: 'An example of such a logging function is shown here:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个这样的日志函数的例子：
- en: '[PRE147]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: How it works…
  id: totrans-763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Before C++20, logging information such as source file, line, and function name
    was only possible with the help of several macros:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，如源文件、行和函数名之类的日志信息只能通过几个宏来实现：
- en: '`__FILE__`, which expands to the name of the current file'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__FILE__`，它展开为当前文件的名称'
- en: '`__LINE__`, which expands to the source file line number'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__LINE__`，它展开为源文件行号'
- en: In addition, all compilers supported non-standard macros including `__func__`
    / `__FUNCTION__`, which provide the name of the current function.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有支持的编译器都包括非标准宏，如 `__func__` / `__FUNCTION__`，它们提供当前函数的名称。
- en: 'Using these macros, one could write the following logging function:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些宏，可以编写以下日志函数：
- en: '[PRE148]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The macros, however, must be used from the context of the function execution,
    as shown in the following snippet:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须从函数执行的上下文中使用这些宏，如下面的代码片段所示：
- en: '[PRE149]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The result of running this function would look as follows on the console:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此函数的结果在控制台上看起来如下：
- en: '[PRE150]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The C++20 `std::source_line` is a better alternative for several reasons:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 的 `std::source_line` 由于以下几个原因是一个更好的替代方案：
- en: You no longer have to rely on macros.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不再需要依赖于宏。
- en: It includes information about the column, not just the line.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括关于列的信息，而不仅仅是行。
- en: It can be used in the logging function signature, simplifying the invocation
    of the call.
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用在日志函数签名中，简化调用过程。
- en: 'The `log()` function defined in the *How to do it…* section can be invoked
    as follows:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做…* 部分定义的 `log()` 函数可以这样调用：
- en: '[PRE151]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'This results in the following output:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE152]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Although a default constructor exists, it initializes the data with default
    values. To get the correct values, you must invoke the static member function
    `current()`. This function works as follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在默认构造函数，但它使用默认值初始化数据。要获取正确的值，必须调用静态成员函数 `current()`。此函数的工作方式如下：
- en: When invoked directly in a function call, it initializes the data with information
    about the location of the call.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在函数调用中直接调用时，它使用调用位置的信息初始化数据。
- en: When used in a default member initializer, it initializes the data with information
    about the location of the constructor aggregate initialization that initializes
    the data member.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用作默认成员初始化器时，它使用初始化数据成员的构造函数聚合初始化的数据位置信息初始化数据。
- en: When used in a default argument (such as in the example shown here), it initializes
    the data with the location of the call site (function invocation).
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在默认参数（如这里所示的示例）中使用时，它使用调用点的位置初始化数据。
- en: When used in another context, the behavior is undefined.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他上下文中使用时，行为是未定义的。
- en: It must be noted that the preprocessor directive `#line` changes the source
    code line number and the file name. This affects the value returned by the macros
    `__FILE__` and `__LINE__`. The `std::source_location` is affected in the same
    manner as the standard macros by the `#line` directive.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，预处理器指令 `#line` 会改变源代码的行号和文件名。这会影响宏 `__FILE__` 和 `__LINE__` 返回的值。`std::source_location`
    也以相同的方式受到 `#line` 指令的影响。
- en: See also
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the stacktrace library to print the call stack*, to learn how to walk
    or print the content of the current stack trace'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用堆栈跟踪库打印调用栈*，了解如何遍历或打印当前堆栈跟踪的内容'
- en: Using the stacktrace library to print the call sequence
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用堆栈跟踪库打印调用序列
- en: In the previous recipe, we saw how to use the C++20 `std::source_location` to
    provide information about a source location for logging, testing, and debugging
    purposes. Another mechanism for debugging is represented by asserts but these
    are not always enough because we often need to know the sequence of calls that
    led to a point of execution. This is called the stack trace. The C++23 standard
    contains a new library with diagnostics utilities. This allows us to print the
    stack trace. In this recipe, you will learn how to use these diagnostics utilities.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们看到了如何使用 C++20 `std::source_location` 为日志记录、测试和调试目的提供源位置信息。另一种调试机制由断言表示，但它们并不总是足够，因为我们经常需要知道导致执行点的调用序列。这被称为堆栈跟踪。C++23
    标准包含一个新的诊断实用工具库。这允许我们打印堆栈跟踪。在本菜谱中，您将学习如何使用这些诊断实用工具。
- en: How to do it…
  id: totrans-792
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can use the C++23 stacktrace library to:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 C++23 堆栈跟踪库来：
- en: 'Print the entire content of the stack trace:'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印堆栈跟踪的整个内容：
- en: '[PRE153]'
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Iterate over each frame in the stack trace and print it:'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历堆栈跟踪中的每一帧并打印它：
- en: '[PRE154]'
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Iterate over each frame in the stack trace and retrieve information about it:'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历堆栈跟踪中的每一帧并检索其信息：
- en: '[PRE155]'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: How it works…
  id: totrans-800
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The new diagnostic utilities are available in a separate header called `<stacktrace>`.
    This header contains the following two classes:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 新的诊断实用工具包含在一个名为 `<stacktrace>` 的单独头文件中。此头文件包含以下两个类：
- en: '`std::basic_stacktrace`, which is a class template that represents a sequence
    container of stack trace entries. A type alias called `std::stacktrace` is defined
    as `std::basic_stacktrace<std::allocator<std::stacktrace_entry>>`.'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::basic_stacktrace`，这是一个表示堆栈跟踪条目序列的类模板。定义了一个类型别名 `std::stacktrace`，作为 `std::basic_stacktrace<std::allocator<std::stacktrace_entry>>`。'
- en: '`std::stacktrace_entry`, which represents an evaluation in a stack trace.'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stacktrace_entry`，它表示堆栈跟踪中的一个评估。'
- en: 'When discussing the call sequence, there are two terms that need to be correctly
    understood: **call stack** and **stack trace**. A call stack is the data structure
    used to store information about the active frames (calls) in a running program.
    A stack trace is a snapshot, at some moment in time, of the call stack.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论调用序列时，有两个术语需要正确理解：**调用栈**和**堆栈跟踪**。调用栈是用于存储运行程序中活动帧（调用）信息的数结构。堆栈跟踪是在某个时间点对调用栈的快照。
- en: 'Although `std::basic_stacktrace` is a container, it is not meant to be instantiated
    and filled with stack entries by the user. There are no member functions for adding
    or removing elements to the stack trace sequence; however, there are member functions
    for element access (`at()` and `operator[]`) and checking the size (`capacity()`,
    `size()`, and `max_size()`). In order to get a snapshot of the call stack, you
    must invoke the static member function `current()`:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::basic_stacktrace` 是一个容器，但它不是由用户实例化并填充堆栈条目的。堆栈跟踪序列中没有用于添加或删除元素的成员函数；然而，有用于元素访问的成员函数（`at()`
    和 `operator[]`）以及检查大小（`capacity()`、`size()` 和 `max_size()`）。为了获取调用栈的快照，您必须调用静态成员函数
    `current()`：
- en: '[PRE156]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The current trace can be printed in several ways:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 当前跟踪可以以多种方式打印：
- en: 'To an output stream using the overloaded `operator<<`:'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重载的 `operator<<` 操作符到一个输出流：
- en: '[PRE157]'
  id: totrans-809
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'To a `std::string` using the `to_string()` member function:'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用成员函数 `to_string()` 将其转换为 `std::string`：
- en: '[PRE158]'
  id: totrans-811
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Using a formatting function such as `std::format()`. Keep in mind that no formatting
    specifier is allowed:'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用格式化函数，如 `std::format()`。请注意，不允许使用任何格式化说明符：
- en: '[PRE159]'
  id: totrans-813
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The following snippet shows an example of how a stack trace can be printed
    to the standard output:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将堆栈跟踪打印到标准输出：
- en: '[PRE160]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The result of running this program would look different based on the compiler
    and target system, but the following is an example of possible output:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序的结果会根据编译器和目标系统而有所不同，但以下是一个可能的输出示例：
- en: '[PRE161]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'For an entry in the trace, as seen above, we can identify three parts: the
    source file, the line number, and a description of the evaluation. These are highlighted
    below:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如上所示的跟踪条目，我们可以识别出三个部分：源文件、行号和评估的描述。这些内容如下所示：
- en: '[PRE162]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: These parts can be obtained independently, using the member functions `source_file()`,
    `source_line()`, and `description()` of `std::stacktrace_entry`. The sequence
    of stack trace entries from a `stacktrace` container can be iterated using iterators
    or accessed with the member functions `at()` and `operator[]`.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分可以独立获取，使用 `std::stacktrace_entry` 的成员函数 `source_file()`、`source_line()`
    和 `description()`。可以从 `stacktrace` 容器迭代堆栈跟踪条目的序列，或者使用成员函数 `at()` 和 `operator[]`
    访问。
- en: See also
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Providing logging details with source_location*, to learn how to use the C++20
    `source_location` class to display information about the source file, line, and
    function name'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `source_location` 提供日志详细信息*，了解如何使用 C++20 的 `source_location` 类来显示有关源文件、行和函数名称的信息'
- en: Learn more on Discord
  id: totrans-823
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_06.xhtml)'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_06.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-826
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
