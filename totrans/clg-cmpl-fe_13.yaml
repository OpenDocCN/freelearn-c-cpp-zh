- en: Appendix 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build Speed Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clang has implemented several features with the goal of improving build speed
    for large projects. One of the most interesting features is precompiled headers
    and modules. They can be considered techniques that allow caching some parts of
    the AST and reusing it for different compiler invocations. Caching can significantly
    improve build speed for your project, and some of these features can be used to
    speed up different Clang tool executions. For instance, precompiled headers are
    used as the primary Clangd optimization for document editing.
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix, we will cover two primary topics
  prefs: []
  type: TYPE_NORMAL
- en: Precompiled headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for this appendix is located in the `chapter10` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Precompiled headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Precompiled headers PCH**, are a Clang feature designed to improve Clang’s
    frontend performance. The basic idea is to create an AST (Abstract Syntax Tree)
    for a header file and reuse this AST during compilation for sources that include
    the header file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a precompiled header file is simple [[5](B19722_Bib.xhtml#Xclang_user_manual)].
    Suppose you have the following header file, `header.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.1**: Header file to be compiled to PCH'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate a PCH for it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `-x c++-header` option to specify that the header file should
    be treated as a C++ header file. The output file will be named `header.pch` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply generating precompiled headers is not enough; you need to start using
    them. A typical C++ source file that includes the header may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.2**: Source file that includes header.h'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the header is included as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.3**: Header header.h inclusion'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Clang will not use a PCH, and you have to specify it explicitly
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `-include-pch` to specify the included precompiled header: `header.pch`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check this command with a debugger, and it will give you the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.4**: Loading precompiled header at clang::ASTReader::ReadAST'
  prefs: []
  type: TYPE_NORMAL
- en: From this example, you can see that Clang reads the AST from the precompiled
    header file. It’s important to note that the precompiled header is read before
    parsing, allowing Clang to obtain all symbols from the header file before parsing
    the main source file. This makes explicit header inclusion unnecessary. Therefore,
    you can remove the `#``include` `"``header``.``h``"` directive from the source
    file and achieve successful compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is impossible without precompiled headers, where you would encounter the
    following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.5**: Compilation error generated due to missing includes'
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that only the first `--include-pch` option will be processed;
    all others will be ignored. This reflects the fact that there can be only one
    precompiled header for a translation unit. On the other hand, a precompiled header
    can include another precompiled header. This functionality is known as chained
    precompiled headers [[3](B19722_Bib.xhtml#Xllvm_pchinternals)], as it creates
    a chain of dependencies where one precompiled header depends on another precompiled
    header.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of precompiled headers is not limited to regular compilation. As we
    saw in [*Figure** 8.38*](B19722_08.xhtml#x1-1760001)*, AST build at Clangd*, precompiled
    headers are actively used for performance optimizations in Clangd as placeholders
    for a cache for the preamble that contains included headers.
  prefs: []
  type: TYPE_NORMAL
- en: Precompiled headers are a technique that has been used for a long time, but
    they have some limitations. One of the most important limitations is that there
    can be only one precompiled header, which significantly limits the usage of PCH
    in real projects. Modules address some of the problems related to precompiled
    header. Lets explore them.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Clang modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules, or **Precompiled Modules** (**PCMs**), can be considered the next step
    in the evolution of precompiled headers. They also represent a parsed AST in binary
    form but form a DAG (tree), meaning one module can include more than one other
    module.
  prefs: []
  type: TYPE_NORMAL
- en: This is a major improvement compared to precompiled headers, where only one
    precompiled header can be introduced for each compilation unit.
  prefs: []
  type: TYPE_NORMAL
- en: The C++20 standard [[21](B19722_Bib.xhtml#Xstandard_cpp20)] introduced two concepts
    related to modules. The first one is ordinary modules, described in *section 10*
    of [[21](B19722_Bib.xhtml#Xstandard_cpp20)]. The other one is the so-called header
    unit , mostly described in *section 15.5*. Header units can be considered an intermediate
    step between ordinary headers and modules and allow the use of the `import` directive
    to import ordinary headers.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on Clang modules, which can be considered an implementation of
    header units from the C++ standard. There are two different options to use Clang
    modules. The first one is called **explicit modules**. The second is called **implicit
    modules**. We will explore both cases but will start with a description of a test
    project for which we want to use the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Test project description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For experiments with modules, we will consider an example with two header files:
    `header1.h` and `header2.h` , which define the `void` `foo1``()` and `void` `foo2``()`
    functions, respectively, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Header file: header1.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE8]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header file: header2.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 10.6**: Header files to be used for the tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'These header files will be used in the following source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.7**: Source file: main.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to organize our header files into modules. Clang uses a special
    file that contains the logical structure, which is called a **modulemap** file.
    Let’s see what the file looks like for our test project.
  prefs: []
  type: TYPE_NORMAL
- en: Modulemap file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The modulemap file for our project will be named `module.modulemap` and has
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.8**: Modulemap file: module.modulemap'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10.8](#x1-195012r8), we have defined two modules, **header1**
    and **header2**.
  prefs: []
  type: TYPE_NORMAL
- en: Each of them contains only one header and exports all symbols from it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have collected all the necessary parts, we are ready to build and
    use the modules. Modules can be built explicitly or implicitly. Let’s start with
    explicit builds.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The module’s structure is described by the modulemap file, as seen in [Figure 10.8](#x1-195012r8).
    Each of our modules has only one header, but a real module might include several
    headers. Thus, to build a module, we have to specify the structure of the modules
    (the modulemap file) and the module name we want to build. For instance, for the
    **header1** module, we can use the following build command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several important aspects in the compile command. The first one is
    the **-cc1** option, which indicates that we are calling only the compiler frontend.
    For more information, please refer to [*Section** 2.3*](B19722_02.xhtml#x1-410003)*,
    Clang driver overview*. Additionally, we specify that we want to create a build
    artifact (module) named `header1.pcm` by using the following option: `-emit-module
    -o header1.pcm` . The logical structure and the required modules to be built are
    specified in the `module.modulemap` file, which has to be specified as a compile
    argument with the `-fmodule-name=header1` option. Enabling the modules functionality
    is done using the `-fmodules` flag, and we also specify that our headers are C++
    headers with the `-x c++-header` option. To explicitly disable implicit modules,
    we include `-fno-implicit-modules` in the command because implicit modules, which
    we will investigate later in [*Figure** 10.9*](#x1-1970003)*, Implicit* *modules*,
    are enabled by default, but we don’t want to use them at the moment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second module (`header2` ) has a similar compilation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to compile `main.cpp` using the generated modules, which can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, both the module name and build artifacts (PCM files) are specified
    using the `-fmodule-file` compile option. The format used, such as `header1=header1.pcm`
    , indicates that `header1.pcm` corresponds to the `header1` module. We also specify
    the modulemap file with the `-fmodule-map-file` option. It’s worth noting that
    we created two build artifacts: `header1.pcm` and `header2.pcm` , and used them
    together for the compilation. This is impossible in the case of precompiled headers
    because only one precompiled header is allowed, as mentioned in [*Section** 10.2*](#x1-1920002)*,
    Precompiled* *headers*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We emitted an object file, `main.o` , as a result of the compilation command.
    The object file can be linked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s verify that the modules were loaded during compilation. This can be done
    with LLDB as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.9**: Explicit module load'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set a breakpoint at `clang``::``CompilerInstance``::``findOrCompileModuleAndReadAST`,
    as shown in *Line 3* of [Figure 10.9](#x1-196022r9). We hit the breakpoint twice:
    first at *Line 9* for the module named `header1` , and then at *Line 14* for the
    module named `header2` .'
  prefs: []
  type: TYPE_NORMAL
- en: You must explicitly define the build artifacts and specify the path where they
    will be stored in all compile commands when using explicit modules, as we have
    just discovered. However, all the required information is stored within the modulemap
    file (refer to [Figure 10.8](#x1-195012r8)). The compiler can utilize this information
    to create all the necessary build artifacts automatically. The answer to the question
    is affirmative, and this functionality is provided by implicit modules. Let’s
    explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the modulemap file contains all the information required
    to build all modules (`header1` and `header2` ) and use them for dependent file
    (`main.cpp` ) building. Thus, we have to specify a path to the modulemap file
    and a folder where the build artifacts will be stored. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we didn’t specify `-fno-implicit-modules` , and we also specified
    the path for build artifacts with `-fmodules-cache-path=./cache` . If we examine
    the path, we will be able to see the created modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.10**: The cache generated by Clang for implicit modules'
  prefs: []
  type: TYPE_NORMAL
- en: Clang will monitor the cache folder (`./cache` in our case) and delete build
    artifacts that have not been used for a long time. It will also rebuild the modules
    if their dependencies (for instance, included headers) have changed.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are a very powerful tool, but like every powerful tool, they can introduce
    non-trivial problems. Let’s explore the most interesting problem that can be caused
    by modules.
  prefs: []
  type: TYPE_NORMAL
- en: Some problems related to modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code that uses modules can introduce some non-trivial behavior into your
    program. Consider a project that consists of two headers, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Header file: header1.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE19]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header file: header2.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 10.11**: Header files that will be used for the test'
  prefs: []
  type: TYPE_NORMAL
- en: The only `header1.h` is included in `main.cpp` , as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.12**: Source file: main.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.13**: Compilation error generated due to a missing header file'
  prefs: []
  type: TYPE_NORMAL
- en: The error is obvious because we didn’t include the second header that contains
    a definition for the `h2` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation would be different if we were using implicit modules. Consider
    the following `module.modulemap` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.14**: Modulemap file that introduces implicit dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: This file creates two modules, `h1` and `h2` . The second module is included
    within the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile it as follows, the compilation will be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 10.15**: Successful compilation for a file with a missing header but
    with implicit modules enabled'
  prefs: []
  type: TYPE_NORMAL
- en: The compilation completed without any errors because the modulemap implicitly
    added `header2.h` to the used module (`h1` ). We also exported all symbols using
    the `export *` directive. Thus, when Clang encounters `#``include` `"``header1``.``h``"`,
    it loads the corresponding `h1` module, and therefore implicitly loads symbols
    defined in the `h2` module and `header2.h` header.
  prefs: []
  type: TYPE_NORMAL
- en: The example illustrates how the visibility scope can be leaked when modules
    are used in the project. This can lead to unexpected behavior for the project
    build, when it builds with modules enabled and disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang modules: [https://clang.llvm.org/docs/Modules.html](https://clang.llvm.org/docs/Modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precompiled header and modules internals: [https://clang.llvm.org/docs/PCHInternals.html](https://clang.llvm.org/docs/PCHInternals.html)********'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
