- en: Appendix 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build Speed Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clang has implemented several features with the goal of improving build speed
    for large projects. One of the most interesting features is precompiled headers
    and modules. They can be considered techniques that allow caching some parts of
    the AST and reusing it for different compiler invocations. Caching can significantly
    improve build speed for your project, and some of these features can be used to
    speed up different Clang tool executions. For instance, precompiled headers are
    used as the primary Clangd optimization for document editing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix, we will cover two primary topics
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Precompiled headers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.1 Technical requirements
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for this appendix is located in the `chapter10` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Precompiled headers
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Precompiled headers PCH**, are a Clang feature designed to improve Clang’s
    frontend performance. The basic idea is to create an AST (Abstract Syntax Tree)
    for a header file and reuse this AST during compilation for sources that include
    the header file.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a precompiled header file is simple [[5](B19722_Bib.xhtml#Xclang_user_manual)].
    Suppose you have the following header file, `header.h` :'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Figure 10.1**: Header file to be compiled to PCH'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate a PCH for it with the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we use the `-x c++-header` option to specify that the header file should
    be treated as a C++ header file. The output file will be named `header.pch` .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply generating precompiled headers is not enough; you need to start using
    them. A typical C++ source file that includes the header may look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Figure 10.2**: Source file that includes header.h'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the header is included as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Figure 10.3**: Header header.h inclusion'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Clang will not use a PCH, and you have to specify it explicitly
    with the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we use `-include-pch` to specify the included precompiled header: `header.pch`
    .'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check this command with a debugger, and it will give you the following
    output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 10.4**: Loading precompiled header at clang::ASTReader::ReadAST'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: From this example, you can see that Clang reads the AST from the precompiled
    header file. It’s important to note that the precompiled header is read before
    parsing, allowing Clang to obtain all symbols from the header file before parsing
    the main source file. This makes explicit header inclusion unnecessary. Therefore,
    you can remove the `#``include` `"``header``.``h``"` directive from the source
    file and achieve successful compilation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'This is impossible without precompiled headers, where you would encounter the
    following compilation error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Figure 10.5**: Compilation error generated due to missing includes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that only the first `--include-pch` option will be processed;
    all others will be ignored. This reflects the fact that there can be only one
    precompiled header for a translation unit. On the other hand, a precompiled header
    can include another precompiled header. This functionality is known as chained
    precompiled headers [[3](B19722_Bib.xhtml#Xllvm_pchinternals)], as it creates
    a chain of dependencies where one precompiled header depends on another precompiled
    header.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The usage of precompiled headers is not limited to regular compilation. As we
    saw in [*Figure** 8.38*](B19722_08.xhtml#x1-1760001)*, AST build at Clangd*, precompiled
    headers are actively used for performance optimizations in Clangd as placeholders
    for a cache for the preamble that contains included headers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Precompiled headers are a technique that has been used for a long time, but
    they have some limitations. One of the most important limitations is that there
    can be only one precompiled header, which significantly limits the usage of PCH
    in real projects. Modules address some of the problems related to precompiled
    header. Lets explore them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Clang modules
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules, or **Precompiled Modules** (**PCMs**), can be considered the next step
    in the evolution of precompiled headers. They also represent a parsed AST in binary
    form but form a DAG (tree), meaning one module can include more than one other
    module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: This is a major improvement compared to precompiled headers, where only one
    precompiled header can be introduced for each compilation unit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The C++20 standard [[21](B19722_Bib.xhtml#Xstandard_cpp20)] introduced two concepts
    related to modules. The first one is ordinary modules, described in *section 10*
    of [[21](B19722_Bib.xhtml#Xstandard_cpp20)]. The other one is the so-called header
    unit , mostly described in *section 15.5*. Header units can be considered an intermediate
    step between ordinary headers and modules and allow the use of the `import` directive
    to import ordinary headers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on Clang modules, which can be considered an implementation of
    header units from the C++ standard. There are two different options to use Clang
    modules. The first one is called **explicit modules**. The second is called **implicit
    modules**. We will explore both cases but will start with a description of a test
    project for which we want to use the modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Test project description
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For experiments with modules, we will consider an example with two header files:
    `header1.h` and `header2.h` , which define the `void` `foo1``()` and `void` `foo2``()`
    functions, respectively, as shown:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Header file: header1.h**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Header file: header2.h**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 10.6**: Header files to be used for the tests'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'These header files will be used in the following source file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Figure 10.7**: Source file: main.cpp'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We are going to organize our header files into modules. Clang uses a special
    file that contains the logical structure, which is called a **modulemap** file.
    Let’s see what the file looks like for our test project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Modulemap file
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The modulemap file for our project will be named `module.modulemap` and has
    the following content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 10.8**: Modulemap file: module.modulemap'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10.8](#x1-195012r8), we have defined two modules, **header1**
    and **header2**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Each of them contains only one header and exports all symbols from it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have collected all the necessary parts, we are ready to build and
    use the modules. Modules can be built explicitly or implicitly. Let’s start with
    explicit builds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Explicit modules
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The module’s structure is described by the modulemap file, as seen in [Figure 10.8](#x1-195012r8).
    Each of our modules has only one header, but a real module might include several
    headers. Thus, to build a module, we have to specify the structure of the modules
    (the modulemap file) and the module name we want to build. For instance, for the
    **header1** module, we can use the following build command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are several important aspects in the compile command. The first one is
    the **-cc1** option, which indicates that we are calling only the compiler frontend.
    For more information, please refer to [*Section** 2.3*](B19722_02.xhtml#x1-410003)*,
    Clang driver overview*. Additionally, we specify that we want to create a build
    artifact (module) named `header1.pcm` by using the following option: `-emit-module
    -o header1.pcm` . The logical structure and the required modules to be built are
    specified in the `module.modulemap` file, which has to be specified as a compile
    argument with the `-fmodule-name=header1` option. Enabling the modules functionality
    is done using the `-fmodules` flag, and we also specify that our headers are C++
    headers with the `-x c++-header` option. To explicitly disable implicit modules,
    we include `-fno-implicit-modules` in the command because implicit modules, which
    we will investigate later in [*Figure** 10.9*](#x1-1970003)*, Implicit* *modules*,
    are enabled by default, but we don’t want to use them at the moment.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The second module (`header2` ) has a similar compilation command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to compile `main.cpp` using the generated modules, which can
    be done as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, both the module name and build artifacts (PCM files) are specified
    using the `-fmodule-file` compile option. The format used, such as `header1=header1.pcm`
    , indicates that `header1.pcm` corresponds to the `header1` module. We also specify
    the modulemap file with the `-fmodule-map-file` option. It’s worth noting that
    we created two build artifacts: `header1.pcm` and `header2.pcm` , and used them
    together for the compilation. This is impossible in the case of precompiled headers
    because only one precompiled header is allowed, as mentioned in [*Section** 10.2*](#x1-1920002)*,
    Precompiled* *headers*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'We emitted an object file, `main.o` , as a result of the compilation command.
    The object file can be linked as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s verify that the modules were loaded during compilation. This can be done
    with LLDB as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Figure 10.9**: Explicit module load'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'We set a breakpoint at `clang``::``CompilerInstance``::``findOrCompileModuleAndReadAST`,
    as shown in *Line 3* of [Figure 10.9](#x1-196022r9). We hit the breakpoint twice:
    first at *Line 9* for the module named `header1` , and then at *Line 14* for the
    module named `header2` .'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: You must explicitly define the build artifacts and specify the path where they
    will be stored in all compile commands when using explicit modules, as we have
    just discovered. However, all the required information is stored within the modulemap
    file (refer to [Figure 10.8](#x1-195012r8)). The compiler can utilize this information
    to create all the necessary build artifacts automatically. The answer to the question
    is affirmative, and this functionality is provided by implicit modules. Let’s
    explore it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Implicit modules
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the modulemap file contains all the information required
    to build all modules (`header1` and `header2` ) and use them for dependent file
    (`main.cpp` ) building. Thus, we have to specify a path to the modulemap file
    and a folder where the build artifacts will be stored. This can be done as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, we didn’t specify `-fno-implicit-modules` , and we also specified
    the path for build artifacts with `-fmodules-cache-path=./cache` . If we examine
    the path, we will be able to see the created modules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Figure 10.10**: The cache generated by Clang for implicit modules'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Clang will monitor the cache folder (`./cache` in our case) and delete build
    artifacts that have not been used for a long time. It will also rebuild the modules
    if their dependencies (for instance, included headers) have changed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Modules are a very powerful tool, but like every powerful tool, they can introduce
    non-trivial problems. Let’s explore the most interesting problem that can be caused
    by modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Some problems related to modules
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code that uses modules can introduce some non-trivial behavior into your
    program. Consider a project that consists of two headers, as shown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Header file: header1.h**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Header file: header2.h**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 10.11**: Header files that will be used for the test'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The only `header1.h` is included in `main.cpp` , as follows
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Figure 10.12**: Source file: main.cpp'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will not compile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 10.13**: Compilation error generated due to a missing header file'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The error is obvious because we didn’t include the second header that contains
    a definition for the `h2` variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation would be different if we were using implicit modules. Consider
    the following `module.modulemap` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Figure 10.14**: Modulemap file that introduces implicit dependencies'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: This file creates two modules, `h1` and `h2` . The second module is included
    within the first one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile it as follows, the compilation will be successful:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照以下方式编译，编译将成功：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Figure 10.15**: Successful compilation for a file with a missing header but
    with implicit modules enabled'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.15**: 成功编译一个缺少头文件但启用了隐式模块的文件'
- en: The compilation completed without any errors because the modulemap implicitly
    added `header2.h` to the used module (`h1` ). We also exported all symbols using
    the `export *` directive. Thus, when Clang encounters `#``include` `"``header1``.``h``"`,
    it loads the corresponding `h1` module, and therefore implicitly loads symbols
    defined in the `h2` module and `header2.h` header.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后没有出现任何错误，因为modulemap隐式地将`header2.h`添加到使用的模块（`h1`）。我们还使用`export *`指令导出了所有符号。因此，当Clang遇到`#include
    "header1.h"`时，它加载相应的`h1`模块，因此隐式地加载了在`h2`模块和`header2.h`头文件中定义的符号。
- en: The example illustrates how the visibility scope can be leaked when modules
    are used in the project. This can lead to unexpected behavior for the project
    build, when it builds with modules enabled and disabled.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例说明了当在项目中使用模块时，可见作用域可能会泄露。当项目启用和禁用模块时构建，这可能导致项目构建出现意外的行为。
- en: 10.4 Further reading
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 进一步阅读
- en: 'Clang modules: [https://clang.llvm.org/docs/Modules.html](https://clang.llvm.org/docs/Modules.html)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang模块: [https://clang.llvm.org/docs/Modules.html](https://clang.llvm.org/docs/Modules.html)'
- en: 'Precompiled header and modules internals: [https://clang.llvm.org/docs/PCHInternals.html](https://clang.llvm.org/docs/PCHInternals.html)********'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '预编译头文件和模块内部结构: [https://clang.llvm.org/docs/PCHInternals.html](https://clang.llvm.org/docs/PCHInternals.html)'
