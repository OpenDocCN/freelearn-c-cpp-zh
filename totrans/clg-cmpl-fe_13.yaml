- en: Appendix 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录2
- en: Build Speed Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建速度优化
- en: Clang has implemented several features with the goal of improving build speed
    for large projects. One of the most interesting features is precompiled headers
    and modules. They can be considered techniques that allow caching some parts of
    the AST and reusing it for different compiler invocations. Caching can significantly
    improve build speed for your project, and some of these features can be used to
    speed up different Clang tool executions. For instance, precompiled headers are
    used as the primary Clangd optimization for document editing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 实现了多项功能，旨在提高大型项目的构建速度。其中最有趣的功能之一是预编译头文件和模块。它们可以被视为允许缓存 AST 的某些部分并重新用于不同编译调用的技术。缓存可以显著提高项目的构建速度，并且可以使用这些功能来加速不同的
    Clang 工具执行。例如，预编译头文件被用作 Clangd 文档编辑的主要优化。
- en: In this appendix, we will cover two primary topics
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将涵盖两个主要主题
- en: Precompiled headers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译头文件
- en: Modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: 10.1 Technical requirements
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 技术要求
- en: 'The source code for this appendix is located in the `chapter10` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的源代码位于本书 GitHub 仓库的 `chapter10` 文件夹中：[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter10)。
- en: 10.2 Precompiled headers
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 预编译头文件
- en: '**Precompiled headers PCH**, are a Clang feature designed to improve Clang’s
    frontend performance. The basic idea is to create an AST (Abstract Syntax Tree)
    for a header file and reuse this AST during compilation for sources that include
    the header file.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**预编译头文件 PCH** 是 Clang 的一项功能，旨在提高 Clang 前端性能。基本思路是为头文件创建一个 AST（抽象语法树），并在编译过程中重用此
    AST，用于包含头文件的源文件。'
- en: 'Generating a precompiled header file is simple [[5](B19722_Bib.xhtml#Xclang_user_manual)].
    Suppose you have the following header file, `header.h` :'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 生成预编译头文件很简单 [[5](B19722_Bib.xhtml#Xclang_user_manual)]。假设您有以下头文件，`header.h`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Figure 10.1**: Header file to be compiled to PCH'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.1**：要编译为 PCH 的头文件'
- en: 'You can generate a PCH for it with the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令为其生成 PCH：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we use the `-x c++-header` option to specify that the header file should
    be treated as a C++ header file. The output file will be named `header.pch` .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `-x c++-header` 选项指定头文件应被视为 C++ 头文件。输出文件将被命名为 `header.pch`。
- en: 'Simply generating precompiled headers is not enough; you need to start using
    them. A typical C++ source file that includes the header may look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仅生成预编译头文件是不够的；您需要开始使用它们。一个典型的 C++ 源文件，包含头文件可能看起来像这样：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Figure 10.2**: Source file that includes header.h'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.2**：包含 header.h 的源文件'
- en: 'As you can see, the header is included as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，头文件包含如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Figure 10.3**: Header header.h inclusion'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.3**：包含 header.h'
- en: 'By default, Clang will not use a PCH, and you have to specify it explicitly
    with the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Clang 不会使用 PCH，您必须使用以下命令显式指定：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we use `-include-pch` to specify the included precompiled header: `header.pch`
    .'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `-include-pch` 指定包含的预编译头文件：`header.pch`。
- en: 'You can check this command with a debugger, and it will give you the following
    output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用调试器检查此命令，并将给出以下输出：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 10.4**: Loading precompiled header at clang::ASTReader::ReadAST'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.4**：在 clang::ASTReader::ReadAST 中加载预编译头文件'
- en: From this example, you can see that Clang reads the AST from the precompiled
    header file. It’s important to note that the precompiled header is read before
    parsing, allowing Clang to obtain all symbols from the header file before parsing
    the main source file. This makes explicit header inclusion unnecessary. Therefore,
    you can remove the `#``include` `"``header``.``h``"` directive from the source
    file and achieve successful compilation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，您可以看到 Clang 从预编译头文件中读取 AST。需要注意的是，预编译头文件是在解析之前读取的，这使得 Clang 在解析主源文件之前能够获取头文件中的所有符号。这使得显式包含头文件变得不必要。因此，您可以从源文件中删除
    `#include "header.h"` 指令并成功编译。
- en: 'This is impossible without precompiled headers, where you would encounter the
    following compilation error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 没有预编译头文件，您将遇到以下编译错误：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Figure 10.5**: Compilation error generated due to missing includes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.5**：由于缺少包含而引发的编译错误'
- en: It’s worth noting that only the first `--include-pch` option will be processed;
    all others will be ignored. This reflects the fact that there can be only one
    precompiled header for a translation unit. On the other hand, a precompiled header
    can include another precompiled header. This functionality is known as chained
    precompiled headers [[3](B19722_Bib.xhtml#Xllvm_pchinternals)], as it creates
    a chain of dependencies where one precompiled header depends on another precompiled
    header.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，只有第一个`--include-pch`选项将被处理；所有其他选项将被忽略。这反映了翻译单元只能有一个预编译头文件的事实。另一方面，一个预编译头文件可以包含另一个预编译头文件。这种功能被称为链式预编译头文件[[3](B19722_Bib.xhtml#Xllvm_pchinternals)]，因为它创建了一个依赖链，其中一个预编译头文件依赖于另一个预编译头文件。
- en: The usage of precompiled headers is not limited to regular compilation. As we
    saw in [*Figure** 8.38*](B19722_08.xhtml#x1-1760001)*, AST build at Clangd*, precompiled
    headers are actively used for performance optimizations in Clangd as placeholders
    for a cache for the preamble that contains included headers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译头文件的使用不仅限于常规编译。正如我们在[*图** 8.38*](B19722_08.xhtml#x1-1760001)*中看到的那样，Clangd中的AST构建，预编译头文件在Clangd中作为包含头文件的序言缓存占位符，被积极用于性能优化。
- en: Precompiled headers are a technique that has been used for a long time, but
    they have some limitations. One of the most important limitations is that there
    can be only one precompiled header, which significantly limits the usage of PCH
    in real projects. Modules address some of the problems related to precompiled
    header. Lets explore them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译头文件是一种长期使用的技术，但它有一些限制。其中最重要的限制是只能有一个预编译头文件，这显著限制了PCH在实际项目中的使用。模块解决了与预编译头文件相关的一些问题。让我们来探讨这些问题。
- en: 10.3 Clang modules
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 Clang模块
- en: Modules, or **Precompiled Modules** (**PCMs**), can be considered the next step
    in the evolution of precompiled headers. They also represent a parsed AST in binary
    form but form a DAG (tree), meaning one module can include more than one other
    module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模块，或称为**预编译模块**（**PCMs**），可以被认为是预编译头文件演化的下一步。它们也代表了一种以二进制形式解析的抽象语法树（AST），但形成了一个有向无环图（DAG，树），这意味着一个模块可以包含多个其他模块。
- en: This is a major improvement compared to precompiled headers, where only one
    precompiled header can be introduced for each compilation unit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与只能为每个编译单元引入一个预编译头文件的预编译头文件相比，这是一个重大的改进。
- en: The C++20 standard [[21](B19722_Bib.xhtml#Xstandard_cpp20)] introduced two concepts
    related to modules. The first one is ordinary modules, described in *section 10*
    of [[21](B19722_Bib.xhtml#Xstandard_cpp20)]. The other one is the so-called header
    unit , mostly described in *section 15.5*. Header units can be considered an intermediate
    step between ordinary headers and modules and allow the use of the `import` directive
    to import ordinary headers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准[[21](B19722_Bib.xhtml#Xstandard_cpp20)]引入了与模块相关的两个概念。第一个是普通模块，在[[21](B19722_Bib.xhtml#Xstandard_cpp20)]的第*10节*中描述。另一个是所谓的头单元，主要在第*15.5节*中描述。头单元可以被认为是普通头文件和模块之间的一个中间步骤，并允许使用`import`指令来导入普通头文件。
- en: We will focus on Clang modules, which can be considered an implementation of
    header units from the C++ standard. There are two different options to use Clang
    modules. The first one is called **explicit modules**. The second is called **implicit
    modules**. We will explore both cases but will start with a description of a test
    project for which we want to use the modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注Clang模块，这可以被认为是C++标准中头单元的实现。使用Clang模块有两种不同的选项。第一个被称为**显式模块**。第二个被称为**隐式模块**。我们将探讨这两种情况，但将从我们想要使用模块的测试项目的描述开始。
- en: Test project description
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试项目描述
- en: 'For experiments with modules, we will consider an example with two header files:
    `header1.h` and `header2.h` , which define the `void` `foo1``()` and `void` `foo2``()`
    functions, respectively, as shown:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模块的实验，我们将考虑一个包含两个头文件`header1.h`和`header2.h`的例子，分别定义了`void foo1()`和`void foo2()`函数，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Header file: header1.h**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**头文件：header1.h**'
- en: '**[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE8]'
- en: '**Header file: header2.h**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**头文件：header2.h**'
- en: '****Figure 10.6**: Header files to be used for the tests'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '****图 10.6**：用于测试的头文件'
- en: 'These header files will be used in the following source file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头文件将在以下源文件中使用：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Figure 10.7**: Source file: main.cpp'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.7**：源文件：main.cpp'
- en: We are going to organize our header files into modules. Clang uses a special
    file that contains the logical structure, which is called a **modulemap** file.
    Let’s see what the file looks like for our test project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的头文件组织成模块。Clang使用一个包含逻辑结构的特殊文件，称为**模块映射文件**。让我们看看我们的测试项目中的文件看起来像什么。
- en: Modulemap file
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块映射文件
- en: 'The modulemap file for our project will be named `module.modulemap` and has
    the following content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的模块映射文件将被命名为`module.modulemap`，其内容如下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 10.8**: Modulemap file: module.modulemap'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.8**：模块映射文件：module.modulemap'
- en: As shown in [Figure 10.8](#x1-195012r8), we have defined two modules, **header1**
    and **header2**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图10.8](#x1-195012r8)所示，我们定义了两个模块，**header1**和**header2**。
- en: Each of them contains only one header and exports all symbols from it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块只包含一个头文件，并导出其所有符号。
- en: Now that we have collected all the necessary parts, we are ready to build and
    use the modules. Modules can be built explicitly or implicitly. Let’s start with
    explicit builds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了所有必要的部分，我们准备构建和使用模块。模块可以是显式构建或隐式构建。让我们从显式构建开始。
- en: Explicit modules
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显式模块
- en: 'The module’s structure is described by the modulemap file, as seen in [Figure 10.8](#x1-195012r8).
    Each of our modules has only one header, but a real module might include several
    headers. Thus, to build a module, we have to specify the structure of the modules
    (the modulemap file) and the module name we want to build. For instance, for the
    **header1** module, we can use the following build command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的结构由模块映射文件描述，如[图10.8](#x1-195012r8)所示。我们每个模块只有一个头文件，但一个真实的模块可能包含多个头文件。因此，为了构建一个模块，我们必须指定模块的结构（模块映射文件）和我们想要构建的模块名称。例如，对于**header1**模块，我们可以使用以下构建命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are several important aspects in the compile command. The first one is
    the **-cc1** option, which indicates that we are calling only the compiler frontend.
    For more information, please refer to [*Section** 2.3*](B19722_02.xhtml#x1-410003)*,
    Clang driver overview*. Additionally, we specify that we want to create a build
    artifact (module) named `header1.pcm` by using the following option: `-emit-module
    -o header1.pcm` . The logical structure and the required modules to be built are
    specified in the `module.modulemap` file, which has to be specified as a compile
    argument with the `-fmodule-name=header1` option. Enabling the modules functionality
    is done using the `-fmodules` flag, and we also specify that our headers are C++
    headers with the `-x c++-header` option. To explicitly disable implicit modules,
    we include `-fno-implicit-modules` in the command because implicit modules, which
    we will investigate later in [*Figure** 10.9*](#x1-1970003)*, Implicit* *modules*,
    are enabled by default, but we don’t want to use them at the moment.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编译命令中有几个重要方面。第一个是**-cc1**选项，它表示我们只调用编译器前端。有关更多信息，请参阅[*第2.3节*](B19722_02.xhtml#x1-410003)“Clang驱动程序概述”。此外，我们指定要创建一个名为`header1.pcm`的构建工件（模块），使用以下选项：`-emit-module
    -o header1.pcm`。逻辑结构和要构建的所需模块在`module.modulemap`文件中指定，该文件必须使用`-fmodule-name=header1`选项作为编译参数指定。启用模块功能是通过使用`-fmodules`标志完成的，我们还使用`-x
    c++-header`选项指定我们的头文件是C++头文件。为了显式禁用隐式模块，我们在命令中包含`-fno-implicit-modules`，因为隐式模块默认启用，但我们目前不想使用它们。
- en: 'The second module (`header2` ) has a similar compilation command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块（`header2`）有类似的编译命令：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to compile `main.cpp` using the generated modules, which can
    be done as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用生成的模块编译`main.cpp`，可以按照以下方式完成：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, both the module name and build artifacts (PCM files) are specified
    using the `-fmodule-file` compile option. The format used, such as `header1=header1.pcm`
    , indicates that `header1.pcm` corresponds to the `header1` module. We also specify
    the modulemap file with the `-fmodule-map-file` option. It’s worth noting that
    we created two build artifacts: `header1.pcm` and `header2.pcm` , and used them
    together for the compilation. This is impossible in the case of precompiled headers
    because only one precompiled header is allowed, as mentioned in [*Section** 10.2*](#x1-1920002)*,
    Precompiled* *headers*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，模块名称和构建工件（PCM文件）都是通过使用`-fmodule-file`编译选项指定的。使用的格式，例如`header1=header1.pcm`，表示`header1.pcm`对应于`header1`模块。我们还使用`-fmodule-map-file`选项指定模块映射文件。值得注意的是，我们创建了两个构建工件：`header1.pcm`和`header2.pcm`，并将它们一起用于编译。这与预编译头文件的情况不同，因为如[*第10.2节*](#x1-1920002)所述，只允许一个预编译头文件，我们将在[*图10.9*](#x1-1970003)中稍后研究隐式模块。
- en: 'We emitted an object file, `main.o` , as a result of the compilation command.
    The object file can be linked as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过编译命令生成了一个目标文件`main.o`。该目标文件可以链接如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s verify that the modules were loaded during compilation. This can be done
    with LLDB as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证模块在编译期间是否被加载。这可以通过LLDB完成，如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Figure 10.9**: Explicit module load'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.9**：显式模块加载'
- en: 'We set a breakpoint at `clang``::``CompilerInstance``::``findOrCompileModuleAndReadAST`,
    as shown in *Line 3* of [Figure 10.9](#x1-196022r9). We hit the breakpoint twice:
    first at *Line 9* for the module named `header1` , and then at *Line 14* for the
    module named `header2` .'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`clang::CompilerInstance::findOrCompileModuleAndReadAST`处设置了一个断点，如图10.9中的*第3行*所示。我们两次触发了断点：第一次是在名为`header1`的模块的*第9行*，然后是在名为`header2`的模块的*第14行*。
- en: You must explicitly define the build artifacts and specify the path where they
    will be stored in all compile commands when using explicit modules, as we have
    just discovered. However, all the required information is stored within the modulemap
    file (refer to [Figure 10.8](#x1-195012r8)). The compiler can utilize this information
    to create all the necessary build artifacts automatically. The answer to the question
    is affirmative, and this functionality is provided by implicit modules. Let’s
    explore it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用显式模块时，必须在所有编译命令中明确定义构建工件并指定它们将被存储的路径，正如我们刚刚发现的。然而，所有必需的信息都存储在模块映射文件中（参见图10.8）。编译器可以利用这些信息自动创建所有必要的构建工件。对于这个问题的答案是肯定的，并且这种功能由隐式模块提供。让我们来探索一下。
- en: Implicit modules
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隐式模块
- en: 'As mentioned earlier, the modulemap file contains all the information required
    to build all modules (`header1` and `header2` ) and use them for dependent file
    (`main.cpp` ) building. Thus, we have to specify a path to the modulemap file
    and a folder where the build artifacts will be stored. This can be done as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模块映射文件包含构建所有模块（`header1`和`header2`）以及用于依赖文件（`main.cpp`）构建所需的所有信息。因此，我们必须指定模块映射文件的路径以及构建工件将存储的文件夹。这可以通过以下方式完成：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, we didn’t specify `-fno-implicit-modules` , and we also specified
    the path for build artifacts with `-fmodules-cache-path=./cache` . If we examine
    the path, we will be able to see the created modules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们没有指定`-fno-implicit-modules`，并且我们也指定了构建工件路径为`-fmodules-cache-path=./cache`。如果我们检查路径，我们将能够看到创建的模块：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Figure 10.10**: The cache generated by Clang for implicit modules'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.10**：Clang为隐式模块生成的缓存'
- en: Clang will monitor the cache folder (`./cache` in our case) and delete build
    artifacts that have not been used for a long time. It will also rebuild the modules
    if their dependencies (for instance, included headers) have changed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Clang将监控缓存文件夹（在我们的例子中是`./cache`），并删除长时间未使用的构建工件。如果它们的依赖项（例如，包含的标题）已更改，它还将重新构建模块。
- en: Modules are a very powerful tool, but like every powerful tool, they can introduce
    non-trivial problems. Let’s explore the most interesting problem that can be caused
    by modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个非常强大的工具，但就像每个强大的工具一样，它们可以引入非平凡的问题。让我们来探索由模块可能引起的最有趣的问题。
- en: Some problems related to modules
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一些与模块相关的问题
- en: 'The code that uses modules can introduce some non-trivial behavior into your
    program. Consider a project that consists of two headers, as shown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块的代码可能会向你的程序引入一些非平凡的行为。考虑一个由两个标题组成的工程，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Header file: header1.h**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**标题文件：header1.h**'
- en: '**[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE19**]'
- en: '**Header file: header2.h**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**标题文件：header2.h**'
- en: '****Figure 10.11**: Header files that will be used for the test'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '****图10.11**：用于测试的标题文件'
- en: The only `header1.h` is included in `main.cpp` , as follows
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`中只包含了`header1.h`，如下所示'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Figure 10.12**: Source file: main.cpp'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.12**：源文件：main.cpp'
- en: 'The code will not compile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将无法编译：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 10.13**: Compilation error generated due to a missing header file'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.13**：由于缺少标题文件而引发的编译错误'
- en: The error is obvious because we didn’t include the second header that contains
    a definition for the `h2` variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 错误很明显，因为我们没有包含包含`h2`变量定义的第二部分标题。
- en: 'The situation would be different if we were using implicit modules. Consider
    the following `module.modulemap` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用隐式模块，情况将不同。考虑以下`module.modulemap`文件：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Figure 10.14**: Modulemap file that introduces implicit dependencies'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.14**：引入隐式依赖的模块映射文件'
- en: This file creates two modules, `h1` and `h2` . The second module is included
    within the first one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件创建了两个模块，`h1`和`h2`。第二个模块包含在第一个模块中。
- en: 'If we compile it as follows, the compilation will be successful:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照以下方式编译，编译将成功：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Figure 10.15**: Successful compilation for a file with a missing header but
    with implicit modules enabled'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.15**: 成功编译一个缺少头文件但启用了隐式模块的文件'
- en: The compilation completed without any errors because the modulemap implicitly
    added `header2.h` to the used module (`h1` ). We also exported all symbols using
    the `export *` directive. Thus, when Clang encounters `#``include` `"``header1``.``h``"`,
    it loads the corresponding `h1` module, and therefore implicitly loads symbols
    defined in the `h2` module and `header2.h` header.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后没有出现任何错误，因为modulemap隐式地将`header2.h`添加到使用的模块（`h1`）。我们还使用`export *`指令导出了所有符号。因此，当Clang遇到`#include
    "header1.h"`时，它加载相应的`h1`模块，因此隐式地加载了在`h2`模块和`header2.h`头文件中定义的符号。
- en: The example illustrates how the visibility scope can be leaked when modules
    are used in the project. This can lead to unexpected behavior for the project
    build, when it builds with modules enabled and disabled.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例说明了当在项目中使用模块时，可见作用域可能会泄露。当项目启用和禁用模块时构建，这可能导致项目构建出现意外的行为。
- en: 10.4 Further reading
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 进一步阅读
- en: 'Clang modules: [https://clang.llvm.org/docs/Modules.html](https://clang.llvm.org/docs/Modules.html)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang模块: [https://clang.llvm.org/docs/Modules.html](https://clang.llvm.org/docs/Modules.html)'
- en: 'Precompiled header and modules internals: [https://clang.llvm.org/docs/PCHInternals.html](https://clang.llvm.org/docs/PCHInternals.html)********'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '预编译头文件和模块内部结构: [https://clang.llvm.org/docs/PCHInternals.html](https://clang.llvm.org/docs/PCHInternals.html)'
