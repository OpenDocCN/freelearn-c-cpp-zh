- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Actors in a Multiplayer Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To properly set up a multiplayer environment in UE5, it’s important that you
    understand how an Actor’s connection is managed, as well as how its attributes
    are relevant during a game session.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will begin enhancing the player character (which currently
    is just an empty shell) to gain a comprehensive understanding of the previously
    mentioned concepts. To do this, you’ll add more components to the Character class
    (a camera is something you will absolutely need!) and implement the player input
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will learn why it is important to know who owns an Actor in
    a multiplayer environment and how it behaves depending on how it is relevant in
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have solid knowledge of how to manage an
    Actor within an Unreal multiplayer game, allowing you to create more robust and
    efficient multiplayer experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, I will present you with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the connection of an Actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Actor relevancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous chapter and understood its content.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you would prefer to begin with the code from the companion
    repository for this book, you can download the `.zip` project files at [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 04``End` link.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before I start writing about topics such as connections, authority, and roles,
    I need you to properly set up the player character – at the moment, our poor hero
    is just represented by an empty class!
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, you will add a camera and some user input and set up the
    main functionalities that will allow the thief character to move around the level
    in search of treasures and gold!
  prefs: []
  type: TYPE_NORMAL
- en: Adding basic settings to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the next few steps, you’ll add the components that will make up the third-person
    camera behavior and implement their logic. After that, you’ll set some default
    values for the components that are already available in the Character class: the
    Arrow, Capsule, and SkeletalMesh components.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Camera component to the character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started, open the `US_Character.h` header class. You will be adding
    a Camera component and a Spring component that will connect the camera to the
    Capsule component available in the Character class. To do this, add these two
    component declarations after the `GENERATED_BODY()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code block, we are declaring a Camera component and a Spring
    component that will create the camera system. First, you will notice the `UPROPERTY()`
    declaration on both variables with some property specifiers. Let me explain them:'
  prefs: []
  type: TYPE_NORMAL
- en: The `VisibleAnywhere` property indicates that this property is visible in all
    related windows of the Unreal Engine Editor but cannot be edited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BlueprintReadOnly` property indicates that this property can be read by
    Blueprints but not modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Category` property specifies the category of the property when displayed
    in the **Blueprint** **Details** panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will also notice a `meta` declaration that lets you control how the property
    interacts with various aspects of Unreal Engine and the Editor: in this case,
    `AllowPrivateAccess` indicates that a private member should be accessible from
    a Blueprint. We need this as these properties’ accessibility is not explicitly
    declared, and so they default to `private`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For an exhaustive list of property specifiers, please check the official Epic
    Games documentation, which can be found here: [https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/](https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, look at the `class` keyword before the type – this is a C++ **class forward
    declaration**. If you are unfamiliar with this, it is a way to declare the class
    name and its members without providing the full class definition. This can be
    useful in situations where you want to use a class in a header file but do not
    want to include the entire class definition, which can make compilation slower
    and create unnecessary dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you will notice the `TObjectPtr<T>` template – this is a new addition
    in UE5 and has been introduced to replace raw pointers (for example, `USpringComponent*`)
    in header files with UProperties. The `TObjectPtr<T>` template is intended only
    for member properties declared in the headers of your code. For functions and
    short-lived scope within your C++ code in `.cpp` files, using `TObjectPtr<T>`
    provides no additional advantages over using raw pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Camera and Spring components are private, you need to add two getter
    methods for them. Inside the `public` declaration of the header, locate this line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below this line, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These two methods will let you access the pointer components, and the `FORCEINLINE`
    macro forces the code to be inlined; this is going to give your code some performance
    benefits as you will avoid a function call when using this method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the camera behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that your properties have been added, it’s time to add some code logic
    to handle them. Open the `.cpp` file and add the following includes at its top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the constructor (i.e., `AUS_Character::AUS_Character()`), add
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CreateDefaultSubobject()<T>` is a function that is used to create a new
    subobject of a class that will be owned by another object. A **Subobject** is
    essentially a component or a member variable of an object, and the method is typically
    called within an object’s constructor to initialize its subobjects (in this case,
    the components).
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupAttachment()` method will reparent a component to another one. In
    this case, you are attaching the Camera component to `RootComponent`, which is
    actually the Capsule component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give the camera a similar treatment. Add this code block just after the
    previous lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only real difference here is that you are reparenting the camera to the
    Spring component instead of the root one.
  prefs: []
  type: TYPE_NORMAL
- en: You have just created some sort of “chain of command” where the camera is connected
    to the Spring component that is connected to the root of the Actor – this will
    let the camera follow the character with a “springy” behavior whenever the camera
    hits an obstacle and provide a better feel for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the default component properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a last step, you’ll be modifying some properties to create a default setup
    for your Character class. In the constructor, add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are just changing some of the default values of the character Actor
    and its components. The only thing to note is that you are getting the character
    model and assigning it to `SkeletalMeshComponent` by means of the `FObjectFinder()`
    utility method available in the `ConstructorHelpers` class you’ve used before.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Character Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s time to compile your project, just to check that you don’t have any
    syntax errors and that the character has been properly set up. To do this, save
    your files, go back to the Unreal Editor, and click the **Compile** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the compilation phase has finished, open the **BP_Character** Blueprint,
    and you should notice that your changes didn’t show up. This happens because the
    Blueprint has not been updated. To fix this, select **File** | **Refresh All nodes**.
    You should now see the **Camera Boom** and **Follow Camera** elements added to
    the hierarchy in the **Components** panel, as depicted in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The newly added character components](img/Figure_05_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The newly added character components
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably still won’t see the updated mesh in the SkeletalMesh component.
    To fix this, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Mesh** elements in the **Components** panel and look for the **Skeletal
    Mesh Asset** field in the **Details** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If **Skeletal Mesh Asset** shows a value of **None**, click on the **Reset
    Property** arrow next to it, as shown in *Figure 5**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The Reset Property button](img/Figure_05_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The Reset Property button
  prefs: []
  type: TYPE_NORMAL
- en: Double-check the **Use Controller Rotation Yaw Y** property, as it may also
    need a reset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you should be able to see the viewport updated with the selected mesh added
    to it, as shown in *Figure 5**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The updated character Blueprint](img/Figure_05_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The updated character Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: With your character set up, it’s time to make it move by adding some user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interaction to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will add input settings for the character. To do this, we will be using
    the new **Enhanced Input System** that has been introduced in UE5\. This new system
    provides developers with more advanced features than the previous one (known simply
    as the Input System), such as complex input handling and runtime control remapping.
    As the old system is being deprecated, it will probably be removed from Unreal
    Engine sooner or later, so it is best to stay updated on the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing to know about the Enhanced Input System is how it
    communicates with your code: this is achieved through **Input Actions** that represent
    what the character can do during play (i.e., walk, jump, or attack). A group of
    Input Actions can be collected inside an **Input Mapping Context** that represents
    a set of rules for what will trigger the included actions.'
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, UE5 will check a list of **Input Triggers** to determine how user
    input activated an Input Action, validating patterns such as long presses, release
    events, or double-clicks. Before triggering inputs, the system can pre-process
    the raw input through a list of **Input Modifiers** that will alter the data,
    such as setting a custom dead zone for the thumbstick or getting a negative value
    from the input itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll create some basic interaction for your character, which
    needs to move, sprint, and interact with objects (we’ll leave the attack actions
    to later chapters). The sprint and interact actions will be activated by pressing
    a button, while the move action will be controlled by a keyboard/mouse combo or
    by the controller thumbsticks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to explore the full range of possibilities offered by the Enhanced
    Input System, you can check the official documentation by visiting this web page:
    [https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Input Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start creating Input Actions, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `Input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the folder, right-click and select **Input** | **Input Action** to create
    an Input Action asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `IA_Interact`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three other Input Actions and name them `IA_Look`, `IA_Move`, and `IA_Sprint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s begin editing the **IA_Interact** action – we need it to be activated
    by a single press of a button (or key), and this action should be dispatched the
    moment the button has been pressed. To do so, double-click on the asset to open
    it and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **+** button next to the **Triggers** field to add a trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the dropdown that should have been created and select **Pressed** – this
    option will avoid dispatching multiple events if the player holds the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the rest as it is – just check that **Value Type** has been set to the
    default value of **Digital (bool)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the interact action asset is shown in *Figure 5**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The interact action settings](img/Figure_05_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The interact action settings
  prefs: []
  type: TYPE_NORMAL
- en: The **IA_Sprint** action is pretty similar to the interact one but needs to
    trigger a press event when the character starts sprinting and trigger a release
    event when the character stops sprinting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the **IA_Sprint** asset to open it and change the settings
    as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two triggers by clicking the **+** button next to the **Triggers** field
    twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the first dropdown that should have been created and select **Pressed**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the second dropdown and select **Released**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the rest as it is, checking that **Value Type** has been set to the default
    value of **Digital (bool)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the sprint action asset is shown in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The sprint action settings](img/Figure_05_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The sprint action settings
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to set up the **IA_Move** asset, so open it and simply change **Value
    Type** to **Axis2D (Vector2D)** as shown in *Figure 5**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The move action settings](img/Figure_05_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The move action settings
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, open the **AI_Look** asset and change **Value Type** to **Axis2D
    (Vector2D)**, as shown in *Figure 5**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The look action settings](img/Figure_05_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The look action settings
  prefs: []
  type: TYPE_NORMAL
- en: Now that the basic actions have been defined, it’s time to create the Mapping
    Context and set its properties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Input Mapping Context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As explained already, a Mapping Context refers to a set of Input Actions that
    identifies a specific situation in which the player may find themselves. The “context”
    you need to create here is the base actions a character can do (move, look around,
    and interact), so it’s time to open the **Content Browser** and create this asset:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Input` folder and select **Input** | **Input** **Mapping
    Context**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset `IMC_Default` and double-click on it to start editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+** button next to the **Mappings** field. In the drop-down menu,
    select **IA_Interact**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this step three more times to add **IA_Sprint**, **IA_Move**, and **IA_Look**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By the end of these steps, you should have something similar to *Figure 5**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The Input Mapping Context panel](img/Figure_05_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The Input Mapping Context panel
  prefs: []
  type: TYPE_NORMAL
- en: Now that the context has been created, it’s time to map the input the player
    will be using. As I have stated before, we’ll let them use a controller or a mix
    of keyboard and mouse interaction. At the moment, all mappings should be set to
    **None**; this means that no input will pass through this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s solve this by starting with the **IA_Interact** mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the keyboard icon below **IA_Interact** and press the *I* (for Interact)
    key on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click on the **+** button to the right of the **IA_Interact** field to
    add another mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down menu, select **Gamepad** | **Gamepad Face Button Bottom**.
    Alternatively, if you have a game controller connected to your PC, you can simply
    click on the keyboard icon and then press the corresponding button (for instance,
    the *A* button for an Xbox controller).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we are going to set the mapping for **IA_Sprint**:'
  prefs: []
  type: TYPE_NORMAL
- en: Set **Left Shift** for if the player is using the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Gamepad** | **Gamepad Left Thumbstick Button** for if the player is using
    the controller (this second option will allow the player to press the thumbstick
    to sprint).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, **IA_Move** will let the player use the left thumbstick controller or
    the usual WASD keys – this means you will add five interactions: one for the thumbstick
    and then four for the up, down, left, and right directions. Let’s add them to
    the Mapping Context, starting with the thumbstick settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Add **Gamepad** | **Gamepad Left Thumbstick 2D-Axis** to the mappings. Additionally,
    add a modifier from the **Modifiers** list with the value **Dead Zone**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving on to the directions, for the right direction (mapped on your keyboard
    as *D*), add a **Keyboard** | **D** mapping with no modifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the left direction (mapped on your keyboard as *A*), add a **Keyboard**
    | **A** mapping. Then add a modifier with the value **Negate**. This will grant
    negative values from this interaction (i.e., movements to the right are positive,
    while movements to the left are negative).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the forward direction (mapped on your keyboard as *W*), add a **Keyboard**
    | **W** mapping. Then, add a modifier with the value **Swizzle Input Axis Values**,
    which will convert *x* values into *y* (and vice versa), so you’ll get a “forward”
    value for your character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, for the backward direction (mapped on your keyboard as *S*), add a **Keyboard**
    | **S** mapping. Then, add a modifier with the value **Swizzle Input Axis Values**
    and an additional one with the value **Negate**. This will grant negative values
    from this interaction in a similar way to the left movement explained for the
    *A* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the **IA_Look** mapping is going to be controlled by the right thumbstick
    of the controller or by the movement of the mouse. To add such settings, take
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the drop-down menu, select **Gamepad** | **Gamepad Right Thumbstick 2D-Axis**
    for the controller. Additionally, add a modifier from the **Modifiers** list with
    a value of **Dead Zone**, so the thumbstick won’t send data when in the rest position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a **Mouse** | **Mouse XY 2D-Axis** interaction for the mouse. Then add
    a modifier from the **Modifiers** list with the value **Negate** and uncheck the
    **X** and **Z** checkboxes, leaving just the **Y** value selected. This will grant
    negative values for the mouse interaction – for instance, moving it forward will
    let the character move the camera down, and moving it backward will move the camera
    up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have a Mapping Context similar to the one shown in *Figure 5**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The complete Mapping Context](img/Figure_05_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The complete Mapping Context
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Mapping Context has been defined, it’s time to set up the character
    so that it can receive input from the player.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Enhanced Input Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s get back to the IDE, as you are now ready to add some components and code
    logic to your character. As we are using the Enhanced Input System, the first
    thing you will need to do is to add it to the module declaration in the `Build.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, open `UnrealShadows_LOTL.Build.cs` in the `Source` folder of your
    C++ project (the name may vary slightly if your project was named in a different
    way). Then locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it by adding the Enhanced Input module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will make the Enhanced Input module available to your project, and you’ll
    be ready to start implementing the user interaction, something that you’ll do
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user interaction to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add user interaction to the character, you will need to declare the Enhanced
    Input assets you created just a few moments ago.
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, you will declare the Mapping Context and action references
    to your code, along with the corresponding methods. After that, you’ll implement
    the code logic needed to handle all actions. Finally, you’ll declare these actions
    inside the character Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring input properties and functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing to do is to add the needed asset references for the Mapping
    Context and the actions that should be added to the `US_Character.h` header file.
    Open the header file, which should already include the following lines of code
    (if not, add it as a public declaration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare a pointer to the Input Mapping Context and a pointer for each
    Input Action. To do this, add the following code in the class implicit `private`
    section (i.e., just after the `GENERATED_BODY()` macro), just after the components
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last step for the header declarations, add the following methods in the
    `protected` section, just after the `BeginPlay()` method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you added a method for each of the interactions you defined
    before. Just remember that in the `SprintStart()` and `SprintEnd()`).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Mapping Context for the character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next steps, you’ll implement the Mapping Context by initializing it and
    binding each input action to the corresponding methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `US_Character.ccp` and add the following block of code, which includes
    all the classes you’ll be using in the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, look for the `BeginPlay()` method and, after the `Super` declaration,
    add this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code checks that the Controller is a `PlayerController` by
    means of a `Cast<T>` template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working in Unreal Engine, it is common to perform casts to specific classes
    frequently (as you already did in the previous chapters with Blueprints). You
    may already be used to casts in pure C++, but you should be aware that Unreal
    has slightly different behavior, as it is possible to safely cast to types that
    may not be valid. If you are used to regular C++ crashes in such cases, you’ll
    be happy to know that Unreal will simply return a safer `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code will try to get an Enhanced Input Subsystem from the player and,
    if successful, will add a Mapping Context to it. From this point on, all the actions
    declared inside the context will be “tracked” by the input system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you will need to bind these actions to a corresponding method implementation
    (i.e., move, sprint, interact, etc.). To do this, look for the `SetupPlayerInputComponent()`
    method and, after the `Super()` declaration, add this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are calling the `BindAction()` method on the input component
    pointer to bind each action to the corresponding method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you are ready to implement the methods for each action. Let’s start with
    the `Move` method. Add the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first thing that this code does is to get the 2D vector
    from the `Value` parameter. This vector contains the *x* and *y* directions for
    the left thumbstick (or the keyboard) and indicates the direction in which the
    character should move. I have added an onscreen message to keep track of this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if there is a Controller possessing this Actor, we compute the forward
    and right directions of the Character and move it in the corresponding direction
    (this is something you should already be familiar with if you’ve ever tried the
    Unreal Third Person template).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method you’ll be implementing is the `Look()` one, so add these lines
    just after the `Move()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are getting the 2D vector from the `Value` parameter that,
    this time, will come from the right thumbstick or the mouse. After that, we add
    a yaw/pitch to the Controller; this will cause the Spring component and, consequently,
    the Camera component, to rotate around the character.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sprint action, the character has two methods available – one for starting
    the sprint and one for ending it. Add this code block after the previous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code simply increases the maximum speed of the character when it is sprinting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The walk and sprint values are hardcoded; we will need to get these values from
    a dataset later on as we progress through the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method you need to implement is the `Interact()` one but, at the moment,
    we don’t have anything to interact with! So, you’ll just add an onscreen message
    inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The last thing you need to do to make the character fully functional is to add
    the input assets to the Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the character Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To update the Blueprint, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Save all the files you have modified and get back to the Unreal Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Compile** button and wait for the success message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your **BP_Character** Blueprint and select the **Class** **Defaults** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the **Input** category in the **Details** panel. You should get the
    **Default Mapping Context** property along with the four actions that have been
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the drop-down button for **Default Mapping Context** and select the corresponding
    asset (there should be only one to choose).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each action property, select the corresponding action asset from the drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result of the previous steps is depicted in *Figure 5**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The Blueprint input settings](img/Figure_05_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The Blueprint input settings
  prefs: []
  type: TYPE_NORMAL
- en: The character is finally complete! It’s been hard, but you are now ready to
    test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the character’s movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the base user interaction has been implemented, it’s time to start
    testing it on a playable level. Open the **Level_01** map and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for the **SP 1** (for *SpawnPoint 1*) label in the level and add a **Player
    Start** Actor near it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Net Mode** to **Listen Server** with **3** players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the **Play** button to test the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to move the characters and make them sprint and look around.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering how it is possible that you are already playing a networked
    game even though you did not add any multiplayer code logic. The answer is in
    the Character class, which is already set to be replicated – just open the `true`.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that while the character on the server window moves
    and sprints smoothly, on the client’s window, movements seem a bit jumpy when
    you are running. This is happening because you are trying to execute the sprint
    action on the client, but the server is the one who is actually in command – as
    a result, the client will make the character move faster, but the server will
    bring it back to its move position. Basically, at the moment, we are trying to
    “cheat” on the client, but the server, which is authoritative, will forbid you
    from doing this. Obviously, this is a bug in our code, but we still have to understand
    the full meaning of replication and how to execute functions from the server.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this bug, you will need to know more about replication. Just be patient
    – I will give you more detailed information about this topic in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties* *O**ver the Network*, and [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147),
    *Using Remote Procedure* *Calls (RPCs)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have created your own hero character from scratch, it’s time to
    get some knowledge on how an Actor connection is controlled: I will introduce
    this topic in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the connection of an Actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have created a fully working character, it’s time to understand
    how a connection is handled inside Unreal Engine (to quickly refresh your understanding
    of how connections work, you can refer back to [*Chapter 2*](B18203_02.xhtml#_idTextAnchor041),
    *Understanding* *Networking Basics*).
  prefs: []
  type: TYPE_NORMAL
- en: Each connection has its own `PlayerController` that has been created expressly
    for it; in this case, we say that the `PlayerController` is “owned” by that connection.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, Actors can have an `PlayerController`, then the `PlayerController`
    becomes the Owner of that Actor. This means that the first Actor is also owned
    by the same connection that owns the `PlayerController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of ownership is used during Actor replication to determine which
    connections receive updates for each Actor: for instance, an Actor may be flagged
    so that only the connection that owns that Actor will be sent property updates
    for it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s imagine that your thief character (which is basically
    an Actor) is possessed by a `PlayerController` – this `PlayerController` will
    be the Owner of the character. During gameplay, the thief gets a pickup that grants
    a magical dagger: once equipped, this weapon will be owned by the Character. This
    means that the `PlayerController` will also own the dagger. In the end, both the
    thief Actor and the dagger will be owned by the `PlayerController` connection.
    As soon as the thief Actor is no longer possessed by the Player Controller, it
    will cease to be owned by the connection, and so will the weapon.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have developed standalone games, you may be used to retrieving the Player
    Controller or the character by using nodes such as `Get Player Controller` or
    `Get Player Character` (or their corresponding C++ versions, `UGameplayStatics::GetPlayerController()`
    and `UGameplayStatics::GetPlayerCharacter()`). Using these functions in a networked
    environment may be the cause of many issues if you don’t know what you are doing,
    as you will get different results depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, calling the `Get Player Controller` function with `Player Index`
    equal to `0` will give you the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: The listen server’s `PlayerController` if you are calling it from a listen server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first client’s `PlayerController` if you are calling it from a dedicated
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client’s `PlayerController` if you are calling it from a client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If things seem confusing, they will become even more so, considering that the
    index will not be consistent across the server and different clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why, when developing multiplayer games in Unreal Engine, you will most
    probably use some of the following functions (or their corresponding nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: '`AActor::GetOwner()`, which returns the Owner of an Actor instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APawn::GetController()`, which returns the Controller for the Pawn or Character
    instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AController::GetPawn()`, which returns the Pawn possessed by the Controller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APlayerState::GetPlayerController()`, which will return the Player Controller
    that created the Player State instance (remote clients will return a null value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding components, you should be aware that they have their own way of determining
    their owning connection – they will start by following the component’s outer chain
    until they find the Actor that owns them. From there, the system will proceed,
    as explained previously, to determine the owning connection of that Actor. To
    get the Owner of the component, you’ll use the `UActorComponent::GetOwner()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we have just “scratched the surface” of what an Owner is and
    how to get info about it, but you should be aware that connection ownership is
    so important that it will be pervasive throughout the rest of the book: in other
    words, the idea of owning a connection is deemed crucial enough to be addressed
    throughout the multiplayer project we are developing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, I’m going to introduce a topic that is deeply connected
    with connection ownership: relevancy.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Actor relevancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relevancy is the process of determining which objects in a scene should be visible
    or updated based on their importance to the player. This is an important concept
    in Unreal Engine, and by understanding how it works, you can make sure your game
    runs efficiently. In this section, we will explore this topic and show an example
    of how it works depending on its settings.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding relevancy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unreal Engine, the term **relevancy** refers to how the Engine determines
    which Actors in the game world should be replicated to which clients, based on
    their current locations, and which Actors are relevant to the player’s current
    view or area.
  prefs: []
  type: TYPE_NORMAL
- en: A game level can have a size varying from very small to really huge. This may
    pose a problem in updating everything on the network and for every client connected
    to the server. As the playing character may not need to know every single thing
    that’s happening in the level, most of the time, it’s just enough to let it know
    what is near.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence, the Engine uses several factors to let the player know if
    something has changed on an Actor: these factors span from the distance to the
    Actor itself, its visibility, and whether the Actor is currently active in the
    game world. An Actor that is deemed irrelevant will not be replicated to the player’s
    client, and this will reduce network traffic and improve game performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unreal uses a virtual function named `AActor::IsNetRelevantFor()` to test the
    relevancy of an Actor. This test evaluates a set of properties that is intended
    to provide a reliable estimate of the Actors that can actually influence a client.
    The tests can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bAlwaysRelevant` flag is set to `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, it is owned by the `Pawn` or `PlayerController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, it is the `Pawn` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, the `Pawn` object is the instigator of an action such as noise or damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bNetUseOwnerRelevancy` property is `true` and the Actor itself has an Owner,
    the owner’s relevancy will be used.*   `bOnlyRelevantToOwner` property set to
    `true` and does not pass the first check, then it is not relevant.*   **Fourth
    Check**: If the Actor is attached to another Actor’s skeleton, then its relevancy
    is determined by the relevancy of its parent.*   `bHidden` property is set to
    `true` and the root component is not colliding with the checking Actor, then the
    Actor is not relevant.*   `AGameNetworkManager` is set to use distance-based relevancy,
    the Actor is relevant if it is closer than the net cull distance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Pawn`/`Character` and `PlayerController` classes have slightly different
    relevancy checks as they need to consider additional information, such as the
    movement component.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this system is not perfect, as the distance check may
    give a false negative when dealing with large Actors. Additionally, the system
    does not take into account sound occlusion or other complexities related to ambient
    sounds. Nevertheless, the approximation is precise enough to get good results
    during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: After presenting all this theory, it is time to shift our focus back to the
    project and begin implementing a tangible example. In the following subsection,
    you will see relevancy in action by testing your character.
  prefs: []
  type: TYPE_NORMAL
- en: Testing relevancy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the effect of relevancy during gameplay, you’ll create a simple pickup
    and play around with its settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Pickup Actor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start by creating a new C++ class inheriting from `US_BasePickup`. Then, open
    the generated header file and add these two component declarations in the `private`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with the previous code – we are just declaring the Collision
    component for triggering the pickup and the Mesh component for its visual aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `protected` section, just after the `BeginPlay()` declaration,
    add a declaration that will handle the character overlap with the Actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after that, add the declaration for the pickup action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We need this function to be callable inside a Blueprint, so we use the `BlueprintCallable`
    specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `BlueprintNativeEvent` specifier states that the function can be overwritten
    by a Blueprint, but it also has a default native C++ implementation that will
    be called if the Blueprint does not implement anything.
  prefs: []
  type: TYPE_NORMAL
- en: To natively implement the method, in the `US_BasePickup.cpp` file, we will need
    to implement a C++ function with the same name as the primary function but with
    `_Implementation` added to the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to the `public` section – and after the corresponding properties,
    in order to avoid forward declarations – add two getters for the components we
    declared previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the header has been fully declared, open the `US_BasePickup.cpp` file
    to start adding code logic to your Actor. First of all, add the necessary includes
    at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the constructor, add the following block of code, which creates
    the two components and attaches them to the Actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after that, set `bReplicates` to `true` (as Actors do not replicate
    by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `BeginPlay()` function, add a dynamic multi-cast delegate for the
    overlap event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To give proper attention and focus to replication, I have designated [*Chapter
    6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties* *O**ver the Network*,
    for an in-depth exploration of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the overlap handler just after the closing bracket of the `BeginPlay()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous block of code is quite straightforward: after having checked that
    the overlapping Actor is `AUS_Character` (i.e., our multiplayer hero), we simply
    call the `Pickup()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the pickup logic, you will now add the `Pickup()` C++ implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The code logic of this method can be implemented inside the inheriting Blueprints,
    but for the sake of demonstration, we are just setting the Owner of this Actor
    to the overlapping one: this is an important step in making things work in the
    next relevancy tests.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to get back to the Unreal Engine Editor and do some “magic” –
    after all, this is a book about creating a fantasy game!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pickup Blueprint class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the effects of relevancy in action, you’ll create a Blueprint pickup...
    Well, sort of. Upon first examination, relevancy can exhibit some peculiar tendencies.
    This is precisely why we’ll be conjuring up a marvelously mystical tome that hovers
    in mid-air!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Unreal Engine Editor and take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile your project to add the pickup to the available classes of your Blueprints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your `Blueprints` folder, create a new `BP_SpellBook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Blueprint Details** panel, select a mesh for the **Static Mesh** property
    – I opted for the **spellBook** model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the book float, we are going to move the mesh up and down by using
    a **Timeline** node. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Blueprint Event Graph, right-click on the canvas, and add a `Float`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the node to open the corresponding editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `Alpha`. The button is shown in *Figure 5**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The Track button](img/Figure_05_11_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The Track button
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Loop** button to enable the loop mode. The button is shown in
    *Figure 5**.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The Loop button](img/Figure_05_12_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The Loop button
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the curve panel and select the **Add key to...** option. Then,
    set **Time** to **0** and **Value** to **0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another key, but this time set **Time** to **2.5** and **Value** to **0.5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one last key, this time with **Time** equal to **5** and **Value** equal
    to **0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on each of the keys and set the **Key Interpolation** value to **Auto**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the **Timeline** node is shown in *Figure 5**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The Timeline node settings](img/Figure_05_13_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – The Timeline node settings
  prefs: []
  type: TYPE_NORMAL
- en: 'You have just created a sinusoidal value that will indefinitely loop between
    0 and 1 values; you’ll use this floating value to move the book up and down. To
    implement this floating movement, return to the Event Graph and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **Event Begin Play** node to the **Timeline** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Mesh** component from the **Components** panel onto the Event Graph
    canvas. Click and drag from its outgoing pin to add a **Set Relative** **Location**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Set Relative Location** incoming execution pin to the **Update**
    execution pin of the **Timeline** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Timeline** node **Alpha** pin to a **Multiply** node and set the
    second parameter of this last node to **100**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **New Location** pin of the **Set Relative Location** node
    and select **Split Struct Pin** to expose the X, Y, and Z values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Result** pin of the **Multiply** node to **New Location Z** of
    the **Set Relative** **Location** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete graph is shown in *Figure 5**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The floating book graph](img/Figure_05_14_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – The floating book graph
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this floating animation is purely a visual effect, so we just
    won’t worry about whether it is synchronized over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Blueprint item has been created, it’s time to add it to the level
    and test its pickup functionality – something we are going to do in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the relevancy settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s now time to test how the spell book behaves in a multiplayer environment
    when relevancy settings are changed.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, drag an instance of the **BP_SpellBook** Blueprint into the level,
    near the PlayerStart Actor, so that the player will be in the line of sight once
    it has been spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **PB_SpeelBook** Blueprint and, with the **Class Defaults** panel
    selected, look for the **Replication** category. The default settings should be
    similar to the ones shown in *Figure 5**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The Replication category](img/Figure_05_15_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The Replication category
  prefs: []
  type: TYPE_NORMAL
- en: Try playing the game as a listen server with three players, and every player
    should see the book as expected. Things are going to get a bit trickier in a moment...
  prefs: []
  type: TYPE_NORMAL
- en: Stop the application from playing and get back to the **BP_SpellBook** Blueprint.
    Look for the **Net Load on Client** property and uncheck it. As this property
    will load the Actor during map loading, we need to disable it, so the Actor will
    be loaded only when it becomes relevant for the client.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to test different situations, depending on the properties
    you change in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the net cull distance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first situation you will be testing is about distance culling – at the
    moment, your object is set to be relevant at a very far distance. To check this,
    run the game again, and you should see no difference since your last gameplay.
    But what happens if you lower **Net Cull Distance Squared** to a very low number,
    for instance, **500**? You will get really “weird” behavior: the server window
    will show the book, while the two clients will not!'
  prefs: []
  type: TYPE_NORMAL
- en: With one of the client windows active, try walking near the zone where the book
    should be, and it will immediately pop up! Didn’t I already warn you that this
    book was nothing short of magical?
  prefs: []
  type: TYPE_NORMAL
- en: The property you just changed sets the square of the distance that will be used
    to make the Actor relevant to the client. This means that the spell book will
    “magically” appear as soon as the character is within the square root of this
    distance. As the server is authoritative (i.e., knows everything), it will always
    show the Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now test a way to set the Actor as always relevant and, as such, always
    visible.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Actor as always relevant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Return to the spell book Blueprint and set the **Always Relevant** property
    to **True**, leaving the rest as it was in the previous example. When you play
    the game, you will notice that every client will be able to see the book from
    the start. This happens because the book has now been marked as something that
    should be relevant no matter where the character is in the level; as a consequence,
    it will be immediately loaded by the client and visible to the players.
  prefs: []
  type: TYPE_NORMAL
- en: This is obviously not a desirable situation – getting a continuous update for
    every Actor in the level is something we don’t want to happen, considering that
    there could be a multitude of moving elements in our game. But you probably already
    imagined that, didn’t you?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s avoid this issue by setting relevancy based on the Owner of the Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the relevancy for the Owner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may remember that the C++ code for the `Pickup()` function assigns the
    Owner of the pickup to the character overlapping it. Instead, in this Blueprint,
    we’ll see what happens if the Actor is relevant only to the Owner:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **Only Relevant to Owner** property to **True**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Always Relevant** property to **False**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Net Cull Distance Squared** to a really low number, say **10**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the last step, we are setting the spell book so that it won’t be relevant
    to any client unless it is directly on the object; this will let us test who is
    the Owner of the Actor.
  prefs: []
  type: TYPE_NORMAL
- en: The clients won’t be able to see the book unless they enter its collision zone,
    which is when the character becomes the Owner of the pickup. Once another character
    enters the pickup zone, it will become the new Owner and the book will become
    relevant. After a few moments, the first client will see the book disappear as
    the character is no longer the Owner of the pickup, and so it is no longer relevant
    to it!
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note, there is one last property you should be aware of: **Net Use
    Owner Relevancy** will return the relevancy of an Actor depending on its owner
    relevancy. This will come in handy once you assign a weapon to a character or
    to an enemy!'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have now unlocked the mystical secrets of relevancy and
    witnessed it in action. This concept will prove invaluable as you begin optimizing
    your game, but it’s always best to lay a strong foundation and set the right course
    from the very beginning. The following section will introduce another significant
    concept, namely authority.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing authority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned in [*Chapter 2*](B18203_02.xhtml#_idTextAnchor041), *Understanding
    Networking Basics*, the term **authority** refers to which instance of the game
    has the final say over certain aspects of the game state. In an Unreal Engine
    multiplayer environment, the server is authoritative over the game state: this
    means that the server makes the final decisions about things such as player movement,
    damage calculation, and other game mechanics.'
  prefs: []
  type: TYPE_NORMAL
- en: When a client requests to perform an action that affects the game state, it
    sends a message to the server requesting permission to perform that action. The
    server then determines whether the action is valid and, if so, updates the game
    state accordingly. Once the server has updated the game state, it sends a message
    to all clients to inform them of the updated state.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, Actors can be either locally or remotely controlled, and the
    concept of authority is important in determining which controls are valid. Actors
    that are locally controlled have authority over their own actions, while those
    that are remotely controlled receive commands from the server and follow those
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the concept of authority ensures that all players see a consistent
    game state and that no one player has an unfair advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling authority with the Role and Remote Role properties of an Actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unreal Engine, there are two properties that return important information
    about Actor replication: **Role** and **Remote Role**. These two properties provide
    information about who has authority over the Actor, whether the Actor is replicated
    or not, and the method of replication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine, an Actor can have one of four possible roles during network
    play:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ROLE_Authority`: The running instance has authoritative control over the Actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROLE_AutonomousProxy`: The running instance is an autonomous proxy of the
    Actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROLE_SimulatedProxy`: The running instance is a locally simulated proxy of
    the Actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROLE_None`: In this case, the role is not relevant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the `Role` and `RemoteRole` properties are used to control how an Actor
    behaves during network play in Unreal Engine, and their values can differ depending
    on the Actor’s ownership and replication settings. In particular, the `Role` property
    specifies the Actor’s role on the local machine, while the `RemoteRole` property
    specifies the Actor’s role on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if `Role` is set to `ROLE_Authority` and `RemoteRole` is set
    to either `ROLE_SimulatedProxy` or `ROLE_AutonomousProxy`, then the current instance
    of the game is responsible for replicating this Actor to remote connections.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that only the server replicates Actors to connected clients
    as clients will never replicate Actors to the server. This means that only the
    server will have `Role` set to `ROLE_Authority` and `RemoteRole` set to `ROLE_SimulatedProxy`
    or `ROLE_AutonomousProxy`.
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous and simulated proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While testing the spell book pickup (well, it was not strictly a “pickup,” but
    you get the point), you may have noticed that once the Actor’s Owner changed,
    the book did seem to stay relevant to both the old and the new Owner for a moment.
    To avoid using excessive amounts of CPU resources and bandwidth, the server does
    not replicate Actors during every update but at a frequency that is determined
    by the `AActor::NetUpdateFrequency` property.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing will happen when updating any Actor during movement, and the
    client will receive data at predefined intervals; as a consequence, the player
    may get seemingly erratic updates on an Actor. To avoid these kinds of issues,
    the Engine will try to extrapolate movement based on the latest data available.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior relies on predicting the movement and is governed by a
    `ROLE_SimulatedProxy`. In this mode, the client continuously updates the location
    of the Actor based on the latest velocity received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: When an Actor is controlled by a `PlayerController` object, you may use an `ROLE_AutonomousProxy`.
    In this case, the system will receive additional information directly from the
    human player, making the process of predicting future actions smoother.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ve gained some insight into the realms of authority and
    Actor roles. These notions shall undoubtedly come in handy in future chapters,
    especially as you delve into the complexities of topics such as character weaponry
    and enemy AI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you made further progress in developing your multiplayer project
    by updating your character with the required movement and interaction features
    – this was achieved with the help of the Enhanced Input System provided by Unreal
    Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you gained some clarity on who’s pulling the strings of an Actor in a
    multiplayer environment by understanding what an Owner is.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you started to see the light on the all-important role of relevancy
    in gaming. As you discovered for yourself, it’s crucial to know how properties
    are set, or things will start to take a big turn for the weird.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you gained some valuable insights into the different roles that make
    up an Unreal Engine multiplayer game and why they play a crucial role in replicating
    an Actor’s behavior across multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to a final question: what does “replicating” an object mean
    exactly? Well, I guess it’s time to take a stroll or indulge in a cup of coffee
    to recharge your batteries. You will need to summon all your energy and focus,
    for I will unveil (almost) all the secrets of replication in the next chapter!'
  prefs: []
  type: TYPE_NORMAL
