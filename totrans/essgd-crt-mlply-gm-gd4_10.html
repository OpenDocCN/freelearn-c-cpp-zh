<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor260"/>10</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor261"/>Debugging and Profiling the Network</h1>
			<p>With <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em>, we concluded <em class="italic">Part 2</em>, <em class="italic">Creating Online Multiplayer Mechanics</em>, of our journey, where we learned how we can use Godot Engine’s High-Level Network API to turn local gameplay mechanics into online multiplayer mechanics. Now, it’s time to go beyond implementation and start the optimization of our mechanics. This chapter inaugurates <em class="italic">Part 3</em>, <em class="italic">Optimizing the Online Experience</em>, of our journey through creating online multiplayer games with Godot Engine.</p>
			<p>It’s important that you have read, understood, and implemented the content provided in <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a><em class="italic">, Creating an Online Adventure Prototype,</em> because we are going to use the final project as our main subject through the following chapters in <em class="italic">Part 3</em>.</p>
			<p>In this specific chapter, we are going to understand how we can use Godot Engine’s built-in <code>MultiplayerSynchronizers</code> are performing, giving us a good overview of potential issues in our network implementation. Finally, we are going to learn how to use the Debugger dock’s <code>Performance</code> singleton to figure out potential bottlenecks in our game and gather data to design potential solutions.</p>
			<p>By the end of this chapter, you will understand how to use the powerful Debugger tools, and the elements in the following figure won’t scare you anymore; instead, they will be some of your most reliable allies:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img alt="Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom) showing and plotting profiling data" src="img/Figure_10.1_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom) showing and plotting profiling data</p>
			<p>Don’t be surprised if you come back to this figure at the end of the chapter and understand what each of those graphs and charts means. You will get used to them, as they will appear in abundance throughout the next chapters, especially <a href="B18527_11.xhtml#_idTextAnchor276"><em class="italic">Chapter 11</em></a><em class="italic">,</em> <em class="italic">Optimizing </em><em class="italic">Data Requests</em>.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>As mentioned previously, it’s crucial that you’ve read and followed the instructions provided in <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em>. Here, in this chapter, we are going to use the final product you should have by the end of the previous chapter. You can access the resources for this chapter in the repository provided in the following link:</p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a></p>
			<p>With the result of <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a><em class="italic">, </em><em class="italic">Creating an Online Adventure Prototype,</em> ready, we can move on to understanding how we can improve it.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor263"/>Introducing Godot’s Debugger</h1>
			<p>The <a id="_idIndexMarker364"/>Debugger is a developer’s best friend. Most of the work we do doesn’t have anything to do with creating and implementing features; instead, it has everything to do with assessing potential problems these implementations cause and fixing them. The <strong class="bold">Debugger</strong> dock is where Godot Engine talks to us, showing errors, warnings, resource consumption, object count, and more. So, we should listen carefully and properly address the issues and data it shows us. We can even ask it to track custom data, as we are going to see in the <em class="italic">Using the Monitors </em><em class="italic">tab</em> section.</p>
			<p>If you have been developing games with Godot Engine for enough time to run into errors, you have probably stumbled on the <strong class="bold">Debugger</strong> dock more than you’d like to, right? In this section, we will go in-depth to understand how to turn it into our best friend and actually wish it pops up. Let’s start by understanding each of its tabs, how to read them, and what to expect from them, starting with the most common and probably the one you’ve already had a hard time with: the <strong class="bold">Stack </strong><strong class="bold">Trace</strong> tab.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor264"/>Mastering the Stack Trace tab</h2>
			<p>When you <a id="_idIndexMarker365"/>click on the <strong class="bold">Debugger</strong> dock, Godot Engine’s editor will open the <strong class="bold">Stack Trace</strong> tab. Let’s use the following figure to navigate it and understand what each of its elements does.</p>
			<div><div><img alt="Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements" src="img/Figure_10.2_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements</p>
			<p>You can see that each element of the <strong class="bold">Stack Trace</strong> tab in the figure is associated with a number, which will facilitate a better understanding. In the following list, we have the element’s name and a brief explanation about it:</p>
			<ul>
				<li>The <strong class="bold">Stack Frames</strong> panel is the stack of functions that leads to an error or a breakpoint (highlighted and marked with <strong class="bold">1</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Filter Stack Variables</strong> field is where you can filter variable names to display them in the panel below (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Members</strong> panel is where you can find the variables within a given script including temporary variables and scope-specific variables. Here, you can also see and edit their values (highlighted and marked with <strong class="bold">3</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Breakpoints</strong> panel is where you can see information about a breakpoint reached in the script of a given instance (highlighted and marked with <strong class="bold">4</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Skip Breakpoints</strong> button, when toggled on, allows the execution of the game to run ignoring breakpoints (highlighted and marked with <strong class="bold">5</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Copy Error</strong> button copies the current error, if any, to your clipboard (highlighted and marked with <strong class="bold">6</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>Clicking on the <strong class="bold">Step Into</strong> button when the application is paused, including when it reaches a breakpoint, will execute the next script instruction (i.e., line). It will enter in indented blocks it would naturally go into, executing the whole code (highlighted and marked with <strong class="bold">7</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>Clicking on the <strong class="bold">Step Over</strong> button when the application is paused, including when it reaches a breakpoint, will execute the next script instruction (i.e., line) but skip indented blocks (highlighted and marked with <strong class="bold">8</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Break</strong> button pauses the application as if it reached a breakpoint (highlighted and marked with <strong class="bold">9</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
				<li>The <strong class="bold">Continue</strong> button resumes the <a id="_idIndexMarker366"/>application if it was paused (highlighted and marked with <strong class="bold">10</strong> in <em class="italic">Figure 10</em><em class="italic">.2</em>).</li>
			</ul>
			<p>With these elements at our disposal, we have the ability to experiment with our scripts and gather invaluable information about our game. For instance, we can see step by step how Godot Engine processes a given set of instructions using the <strong class="bold">Step Into</strong> button and see the stack of functions it executes and how the objects’ variables change with each step.</p>
			<p>A cool tip to use this to its fullest is to not be afraid to add breakpoints all over your scripts to understand when, what, how, and why your objects change and the whole chain of events that caused such changes.</p>
			<p>In this section, we’ve gone through the <strong class="bold">Stack Trace</strong> tab, which gives us an overview of our game’s flow and provides us with multiple ways of gathering information about the changes that happen through this flow, allowing us to understand the whole chain of cause-effects that led to a given change. This is especially helpful together with our next tab, the <strong class="bold">Errors</strong> tab. Let’s talk about it in the next section.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor265"/>Debugging with the Errors tab</h2>
			<p>It may sound weird but, in many situations, you might <a id="_idIndexMarker367"/>wish for Godot Engine to prompt an error, especially when dealing with network features, as sometimes you are left waiting for something to happen. And if the packets sent don’t reach their destination, you will be hanging there waiting for an error to pop up, but packets not reaching their destination isn’t an error in itself. Still, it’s an undesired situation that can leave you confused.</p>
			<p>The <strong class="bold">Errors</strong> tab is where you work with thousands of other developers, who worked on the development of Godot Engine’s core and identified thousands of errors and documented them so that when they happen, you have some light on the issue and are able to fix it.</p>
			<p>However, not only <a id="_idIndexMarker368"/>errors are displayed in this tab. The <strong class="bold">Errors</strong> tab also shows warnings about your script. They don’t necessarily break your application but are something you should be aware of and make a decision on. For instance, it’s common to get warnings about arguments in a function that are not being used in the function’s implementation. The following figure displays the <strong class="bold">Error</strong> tab and its elements associated with numbers, just like in the <em class="italic">Mastering the Stack Trace </em><em class="italic">tab</em> section:</p>
			<div><div><img alt="Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements" src="img/Figure_10.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements</p>
			<p>Now, let’s understand what each of these elements is and how they can be useful for us:</p>
			<ul>
				<li>The <strong class="bold">Errors and Warnings</strong> panel is where all the warnings and fatal and non-fatal errors are displayed. You can click on an error or warning to expand it and go to the script line that triggered it. You can also double-click to expand an error or warning and display the code stack that led to the error. When you double-click an expanded error or warning, you collapse it (highlighted and marked with <strong class="bold">1</strong> in <em class="italic">Figure 10</em><em class="italic">.3</em>).</li>
				<li>The <strong class="bold">Expand All</strong> button expands all the errors and warnings (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.3</em>).</li>
				<li>The <strong class="bold">Collapse All</strong> button collapses all the errors and warnings (highlighted and marked with <strong class="bold">3</strong> in <em class="italic">Figure 10</em><em class="italic">.3</em>).</li>
				<li>The <strong class="bold">Clear</strong> button empties the <strong class="bold">Errors and Warnings</strong> panel (highlighted and marked with <strong class="bold">4</strong> in <em class="italic">Figure 10</em><em class="italic">.3</em>).</li>
			</ul>
			<p>Something <a id="_idIndexMarker369"/>interesting about dealing with errors and warnings is that you can create your own error or warning messages. This is especially good when working with your teammates, but also, since we are working with more than one instance of the game running, it’s a good way to compartmentalize messages to their instance’s <code>print()</code> statement is coming from. So you can use the <code>push_error()</code> and <code>push_warning()</code> built-in methods instead and Godot will only show them in the game session’s <strong class="bold">Debugger</strong> dock that triggered the error or warning. The following figure showcases the <strong class="bold">Error</strong> tab of <strong class="bold">Session 3</strong> with a custom warning expanded so we can see where it comes from:</p>
			<div><div><img alt="Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among other built-in warnings" src="img/Figure_10.4_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among other built-in warnings</p>
			<p>Notice that the <strong class="bold">Debugger</strong> button at the bottom tells us there’s a total of 20 errors and warnings, but when we open the <strong class="bold">Errors</strong> tab in <strong class="bold">Session 3</strong>, there are only 13. This is because the other errors come from other sessions and are in their respective <strong class="bold">Errors</strong> tabs.</p>
			<p>With this powerful tool in our arsenal, we can trigger all sorts of errors and warnings in each individual game session, allowing us to distinguish which session is the server, which ones are players if any peer is getting a specific error that others aren’t, and so on. In the next section, we will talk about our first performance-based debugging tab, the <strong class="bold">Profiler</strong> tab, where we can see how our game is performing, how many resources it is taking, and which objects and functions are taking the most out of our computer.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor266"/>Exploring the Profiler tab</h2>
			<p>Most <a id="_idIndexMarker370"/>developers are always looking for the most efficient, cheap, and ingenious optimizations to make their code run in a toaster. Well, while this is a nice and beautiful fantasy, the reality is that you shouldn’t be so focused on optimizing your code unless you really need it. There’s a saying in the industry that states, “<em class="italic">Premature optimization is the doom of </em><em class="italic">an application</em>.”</p>
			<p>Focus on the <em class="italic">premature</em> word here.</p>
			<p>So, if premature optimization is something bad, but optimization in itself is something good, when is the right time to optimize your game or application? The answer is not set in stone and there’s no clear point that we can just point out and say “<em class="italic">Here, after X days of development, it’s time to optimize</em>,” or “<em class="italic">After you reach 80% of production, it’s the sign to optimize</em>.” No, instead, you should address issues as they show up and create the habit of diagnosing your game’s performance and deciding whether, based on your audience’s computers’ specs, you are going to need to squeeze some resources or not. This can happen on production day 1, or years after launching the game.</p>
			<p>So, you need to engage in the habit of looking at how your game is performing and looking for areas of improvement regularly.</p>
			<p>The <strong class="bold">Profiler</strong> tab is one of <a id="_idIndexMarker371"/>your best allies in optimization. It is in this tab that you will see rendering time, physics simulation time, audio processing time, and even how much time each of your custom script functions is taking to process and how many times they were called. Let’s take a look at the following figure and understand how the <strong class="bold">Profiler</strong> tab displays all this information.</p>
			<div><div><img alt="Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements" src="img/Figure_10.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements</p>
			<p>Let’s understand the role of each of these elements, again, following their number in the figure:</p>
			<ul>
				<li>The <strong class="bold">Functions</strong> panel displays the currently available functions that the profiler can track (highlighted and marked with <strong class="bold">1</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>).</li>
				<li>The <strong class="bold">Start</strong> button initializes the measurement. Note that without toggling this on, the profiler won’t do anything. Profiling is quite resource-intensive, so by default, it’s off (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>).</li>
				<li>The <strong class="bold">Clear</strong> button clears the current data gathered and displayed (highlighted and marked with <strong class="bold">3</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>).</li>
				<li>The <strong class="bold">Measure</strong> drop-down menu allows us to change the type of data we want to measure (highlighted and marked with <strong class="bold">4</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>). The current options are as follows:<ul><li><strong class="bold">Frame Time (ms)</strong> is how many milliseconds Godot Engine takes to process a frame.</li><li><strong class="bold">Average Time (ms)</strong> is how long a function takes to process. This averages the time of each call of any given function.</li><li><strong class="bold">Frame %</strong> is the percentage a given function takes to process relative to the frame’s rendering time. For instance, functions that are more resource-intensive take a bigger percentage.</li><li><strong class="bold">Physics Frame %</strong> is the same as <strong class="bold">Frame %</strong> but relative to the physics frame process.</li></ul></li>
				<li>The <strong class="bold">Time Scope</strong> drop-down menu allows us to change the functions’ time scope that we want to measure (highlighted and marked with <strong class="bold">5</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>), and it has the following options:<ul><li><strong class="bold">Inclusive</strong>, which will take into account the time a function and all its nested functions took to render</li><li><strong class="bold">Self</strong>, which will only take into account the individual time of each function without considering the function calls that the measured function made</li></ul></li>
				<li>The <strong class="bold">Frame #</strong> stepper, or spinbox, marks the frame you are currently assessing (highlighted and marked with <strong class="bold">6</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>). Changing the frame number will allow you to accurately see the function’s measurements related to this frame in the <strong class="bold">Functions</strong> panel.</li>
				<li>The <strong class="bold">Measurement Graph</strong> panel is where the data is plotted so we can see it and access any unusual data. Each measured function has its own color to make it easy to see it on the graph (highlighted and marked with <strong class="bold">7</strong> in <em class="italic">Figure 10</em><em class="italic">.5</em>).</li>
			</ul>
			<p>The Profiler is a <a id="_idIndexMarker372"/>powerful ally ready to give us access to important data regarding resource management. Now that we understand how to use it, let’s move on to the second profiler on the <strong class="bold">Debugger</strong> dock, <strong class="bold">Visual Profiler</strong>.</p>
			<p>This one specializes in visual resources and potential bottlenecks so that we can improve our game’s visuals regarding rendering and other visual procedures.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor267"/>Exploring the Visual Profiler tab</h2>
			<p>On top of knowing how <a id="_idIndexMarker373"/>many processing resources your functions are taking from the CPU, it’s also important to assess how much the rendering-related tasks (such as culling, lightning, and draw calls) are taking from the GPU. The <strong class="bold">Visual Profiler</strong> tool can help you keep track of what is causing the most delay in rendering a frame on the CPU and GPU. By identifying these sources of potential bottlenecks caused by rendering, you can optimize your CPU and GPU performance.</p>
			<p>The <strong class="bold">Visual Profiler</strong> tab is quite <a id="_idIndexMarker374"/>similar to the <strong class="bold">Profiler</strong> tab but specializes in tracking and measuring rendering-related tasks. Take a look at the following figure to understand how the <strong class="bold">Visual Profiler</strong> tab displays all of this information.</p>
			<p class="IMG---Figure"> </p>
			<div><div><img alt="Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements" src="img/Figure_10.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements</p>
			<p>In order to gain a deeper understanding of each of these elements, let us take a closer look at their individual roles. Again, we are going to follow the elements in the numeric order:</p>
			<ul>
				<li>The <strong class="bold">Tasks</strong> panel displays the rendering-related tasks divided into categories. Note that they are broken down into elements such as the related viewport and canvas layer (highlighted and marked with <strong class="bold">1</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>).</li>
				<li>The <strong class="bold">Start</strong> button, just like in the <strong class="bold">Profiler</strong> tab, initializes the profiling. Visual profiling is also turned off by default (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>).</li>
				<li>The <strong class="bold">Clear</strong> button clears the current data gathered in the profiling session (highlighted and marked with <strong class="bold">3</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>).</li>
				<li>The <strong class="bold">Measure</strong> drop-down menu (highlighted and marked with <strong class="bold">4</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>) allows us to select two measurement options:<ul><li><strong class="bold">Frame Time (ms)</strong> is the time taken to render a frame in milliseconds</li><li><strong class="bold">Frame %</strong> is the percentage a given procedure takes from the rendering time of a given frame</li></ul></li>
				<li>The <strong class="bold">Fit to Frame</strong> checkbox will fit the graph to the default frame scale (highlighted and marked with <strong class="bold">5</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>). Disable it to fit the graph onto over 60 <strong class="bold">Frames Per Second </strong>(<strong class="bold">FPS</strong>) portions.</li>
				<li>The <strong class="bold">Linked</strong> checkbox zooms the CPU and the GPU graphs to fit the same scale (highlighted and marked with <strong class="bold">6</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>).</li>
				<li>The <strong class="bold">Frame #</strong> stepper, just like in the <strong class="bold">Profiler</strong> tab, marks the current frame you are assessing. Rendering tasks displayed in the <strong class="bold">Tasks</strong> panel relate to this frame (highlighted and marked with <strong class="bold">7</strong> in <em class="italic">Figure 10</em><em class="italic">.6</em>).</li>
			</ul>
			<p><strong class="bold">Visual Profiler</strong> is yet another <a id="_idIndexMarker375"/>powerful ally when optimizing the rendering performance of your game and is a game-changing tool that can help you assess what may be causing lags and frame drops in your game. In the next section, we are going to understand yet another powerful tool available for us to assess our game’s health, the <strong class="bold">Monitors</strong> tab, where we can find all sorts of interesting information regarding our game.</p>
			<p>Well, let’s dive into it so we understand how each of these, among other available data, will help us address potential issues in our game’s performance.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor268"/>Exploring the Monitors tab</h2>
			<p>Here is the part where you can <a id="_idIndexMarker376"/>really feel like a game doctor. <strong class="bold">Monitors</strong> allows us to assess important data as graphs and see the game’s overall health. In this tab, we can track performance-related data in graphs. By default, it presents some useful data, such as the following:</p>
			<ul>
				<li>Time-related data, such as <strong class="bold">FPS</strong>, process time, and physics process time</li>
				<li>Memory-related data, such as static memory, dynamic memory, and message buffers</li>
				<li>Object-related data, such as the total object count, resource count, node count, and orphan nodes</li>
			</ul>
			<p>There’s a series of properties you can track and plot into graphs so you can analyze your game’s health and spot potential areas for improvement. In the following figure, you can see the Debugger <strong class="bold">Monitors</strong> tab with some properties being tracked and plotted. Note that these properties are toggled on in the left panel by default. The <strong class="bold">Monitors</strong> tab will only plot charts for properties we toggle on in the left panel:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img alt="Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements" src="img/Figure_10.7_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements</p>
			<p>The <strong class="bold">Monitors</strong> tab seems to be the simplest of the tabs we’ve seen so far, but it is still very powerful, so let’s understand the two core elements that build it up:</p>
			<ul>
				<li>The <strong class="bold">Monitor</strong> panel is where we can find the available monitors. A monitor is data marked for tracking. Note that there are plenty of monitors by default. By using them, we can obtain some valuable information about our project’s health (highlighted and marked with <strong class="bold">1</strong> in <em class="italic">Figure 10</em><em class="italic">.7</em>).</li>
				<li>The <strong class="bold">Graphs</strong> panel is where the monitors are plotted as graphs, and each monitor has its own graph and measures. Only the monitors checked in the <strong class="bold">Monitor</strong> panel are plotted in the <strong class="bold">Graphs</strong> panel (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.7</em>).</li>
			</ul>
			<p>Note that there is no <em class="italic">start</em>, <em class="italic">stop</em>, or <em class="italic">clear</em> button on the <strong class="bold">Monitors</strong> tab. This is because Godot will always track the monitorable data.</p>
			<p>Something <a id="_idIndexMarker377"/>interesting about the <code>Performance</code> singleton. We are going to talk about that in the <em class="italic">Identifying the project’s bottlenecks</em> section, where we will also talk about the <strong class="bold">Monitors</strong> panel in depth. In the next section, we will talk about the <strong class="bold">Video RAM</strong> tab, where we can assess our video-related resources.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor269"/>Getting to know the Video RAM tab</h2>
			<p>The <strong class="bold">Video RAM</strong> tab is <a id="_idIndexMarker378"/>useful when you want to understand what resources are causing the most impact on your video memory. This is of great help, especially in 3D games, but it can also be useful for 2D games – for instance, when we want to assess whether we need to pack more sprites into a single texture.</p>
			<p>The <strong class="bold">Video RAM</strong> tab is quite a simple panel with the essential information you need to assess video-related memory consumption. In the following figure, we can see it is made of a single table with four columns inside a panel:</p>
			<div><div><img alt="Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel" src="img/Figure_10.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel</p>
			<p>This is an intuitive panel with the necessary data we need to understand the video memory usage of our resources. Let’s understand the type of information each of these columns presents:</p>
			<ul>
				<li><strong class="bold">Resource Path</strong> is the path in our Godot Engine’s project to the resource.</li>
				<li><code>AtlasTexture</code> Resource or a set of simple textures, for instance.</li>
				<li>The <strong class="bold">Format</strong> column is where we can find the data regarding the file’s format.</li>
				<li><strong class="bold">Usage</strong> is what we actually want in the end. It answers an important question: Given all the previous information, how much memory does this resource take?</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There’s an option to save the table as a CSV file if you want to export it and make some table operations or create charts. This can be very useful for presentations, for instance.</p>
			<p>The <code>Control</code> node during the debugging section.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor270"/>Grasping the Misc tab</h2>
			<p>As <a id="_idIndexMarker380"/>mentioned previously, the Debugger <code>Control</code> node clicked in the <code>Control</code> node is consuming inputs, and fix that in case we can have another <code>Control</code> node responsible for that. For instance, this is common when you have a <code>ColorRect</code> node that you use to fade the screen. If you don’t set <strong class="bold">Mouse Filter</strong> to <strong class="bold">Ignore</strong>, it will consume mouse events and prevent the player from interacting with other UI elements. In the following figure, we have the <strong class="bold">Misc</strong> tab for our game:</p>
			<div><div><img alt="Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements" src="img/Figure_10.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements</p>
			<p>The <strong class="bold">Misc</strong> tab is quite simple, and we can’t do a lot with it. Still, it’s a good <a id="_idIndexMarker381"/>companion when we want to address interface-related issues, so let’s understand the elements that build up this debugging tool:</p>
			<ul>
				<li>The <code>Control</code> node in the debugging section (highlighted and marked with <strong class="bold">1</strong> in <em class="italic">Figure 10</em><em class="italic">.9</em>).</li>
				<li>The <strong class="bold">Clicked Control Type</strong> row displays the type of the clicked control (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.9</em>).</li>
				<li>The <code>SceneTree</code> instance (highlighted and marked with <strong class="bold">3</strong> in <em class="italic">Figure 10</em><em class="italic">.9</em>).</li>
				<li>The <strong class="bold">Set From Tree</strong> button has no official documentation and it seems to be disabled all the time, so we couldn’t test what this button does (highlighted and marked with <strong class="bold">4</strong> in <em class="italic">Figure 10</em><em class="italic">.9</em>).</li>
				<li>The <strong class="bold">Clear</strong> button clears the data in the previously mentioned rows (highlighted and marked with <strong class="bold">5</strong> in <em class="italic">Figure 10</em><em class="italic">.9</em>).</li>
				<li>The <strong class="bold">Export measures as CSV</strong> button allows you to export a CSV file with the data in the aforementioned rows. It might be useful for keeping track of how the game flows based on the interactions with its controls (highlighted and marked with <strong class="bold">6</strong> in <em class="italic">Figure 10</em><em class="italic">.9</em>).</li>
			</ul>
			<p>A good use case for this tab might be <em class="italic">Point ‘n’ Click</em> games. Since most interactions in this game happen with mouse clicks, we can use the Debugger <strong class="bold">Misc</strong> tab to identify which element led to a specific event. For instance, when clicking on a menu while a dialogue is being displayed, which one should consume the mouse click? Well, if the one you chose isn’t consuming the input, you can use the Debugger <strong class="bold">Misc</strong> tab to see what’s happening.</p>
			<p>We just finished covering almost all the tools we can use to debug and profile our game. The only missing one is, for you, our fake studio’s network engineer, the most important one. The Network Profiler is where you are going to find the impact of your RPCs and synchronizers, along with other relevant information related to the High-Level Network API. Let’s get right into it!</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor271"/>Understanding the Network Profiler</h1>
			<p>It’s time to meet your best ally, the one that will help you address issues related to your craft as the network engineer of our fake studio and come up with potential solutions for the problems that appear along your journey. The <a id="_idIndexMarker382"/>Network Profiler, as the name suggests, is a profiler specialized in network-related profiling. It displays information about RPCs’ size and count, both sent and received, the node making and receiving the RPCs, <code>MultiplayerSynchronizer</code> nodes’ network consumption and syncing count, and even a bandwidth meter, which are all we need to assess the impact of our network code.</p>
			<p>Note that the Network Profiler, by default, only tracks the High-Level Network API bandwidth. So, if you are using low-level approaches, such as <code>PacketPeerUDP</code>, <code>UDPServer</code>, <code>StreamPeerTCP</code>, and <code>TCPServer</code>, their consumption may not be taken into account by the Network Profiler by default. We are going to see how we can address that in the <em class="italic">Using the Monitors </em><em class="italic">tab</em> section.</p>
			<p>Let’s dive into the features we <a id="_idIndexMarker383"/>have available in the <strong class="bold">Network Profiler</strong> tab. Again, each element in this interface will be numbered for further reference.</p>
			<div><div><img alt="Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements" src="img/Figure_10.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements</p>
			<p>Although the Network Profiler has fewer elements than the other profilers, each of its elements is more complex as well. You may have also noticed that there’s no graph element, right? So, assessing this data can be a bit less natural. But let’s understand what each of these elements does and how we can use them:</p>
			<ul>
				<li>The RPC panel displays each node that sends and receives RPCs (highlighted and marked with <code>Asteroid</code> nodes have an <code>3</code>, which is probably because they receive 3 calls to process damage and are destroyed right after the third one.</li><li>The <code>Weapon2D</code> has a big <strong class="bold">Outgoing RPC</strong> value because it’s constantly telling its peers’ instances to fire bullets.</li></ul></li>
				<li>The <strong class="bold">Start</strong> button. Just like in the previous profilers, network profiling is turned off by default; by pressing this button, we can start profiling (highlighted and marked with <strong class="bold">2</strong> in <em class="italic">Figure 10</em><em class="italic">.10</em>).</li>
				<li>The <strong class="bold">Clear</strong> button clears the current data gathered in the profiling session (highlighted and marked with <strong class="bold">3</strong> in <em class="italic">Figure 10</em><em class="italic">.10</em>).</li>
				<li>The <strong class="bold">Bandwidth</strong> meter displays the total bandwidth consumption in bytes per second of the current profiling session (highlighted and marked with <strong class="bold">4</strong> in <em class="italic">Figure 10</em><em class="italic">.10</em>):<ul><li><strong class="bold">Down</strong> displays how many bytes per second it downloaded in this profiling session</li><li><strong class="bold">Up</strong> displays how many bytes per second it uploaded during this profiling session</li></ul></li>
				<li>The <code>MultiplayerSynchronizer</code> nodes, their <code>SceneReplicationConfig</code> resource, which is always built-in by default, the sync count, and sync size in bytes (highlighted and marked with <code>MultiplayerSynchronizer</code> node’s scene</li><li>The <code>MultiplayerSynchronizer</code></li><li>The <code>SceneReplicationConfig</code> resource associated with <code>MultiplayerSynchronizer</code></li><li>The <code>MultiplayerSynchronizer</code> node synced its replication data</li><li>The <strong class="bold">Size</strong> column displays the total amount of data the synchronization took, in bytes, during the current profiling session</li></ul></li>
			</ul>
			<p>With all this information in <a id="_idIndexMarker384"/>our hands, we can make sense of how our work is having an impact on the project’s overall performance. Knowing how many times a node calls its RPCs, how many times other nodes call its RPCs, the amount of data exchanged, and more can help us properly address the necessary bandwidth a player needs to play the game properly, and also optimize the game to embrace players with lower network profiles.</p>
			<p>In the next section, we are going to learn how we can use the powerful tools we’ve seen so far to spot the bottlenecks in our network approach using the Network Profiler, but also extend our profiling by adding custom monitors to the <strong class="bold">Monitors</strong> tab. With that, we can pinpoint what we want Godot to report to us.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor272"/>Identifying the project’s bottlenecks</h1>
			<p>With all the tools we’ve seen so far in this chapter at our disposal, it’s time to use them to assess our project’s health and look for areas of improvement. Since your focus here is on networking, we are going to concentrate on features related to this area. In this section, we will use the final version of the <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em>, project to look for areas of improvement using <strong class="bold">Network Profiler</strong> and the <strong class="bold">Monitors</strong> debugging tools. You will learn how to do the following:</p>
			<ul>
				<li>Analyze the incoming and outgoing RPC count and size to identify potential bottlenecks in the network code</li>
				<li>Use the bandwidth meter to track the total bandwidth consumption and come up with possible solutions</li>
				<li>Assess the synchronization count and size of <code>MultiplayerSynchronizer</code> nodes to optimize replication data</li>
				<li>Create custom monitors to analyze relevant data specific to your project and track potential issues</li>
			</ul>
			<p>Let’s get started with the tool that will be our reliable companion through the process of identifying the issues related to the High-Level Network API, the Network Profiler.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor273"/>Using the Network Profiler</h2>
			<p>In the previous section, we saw the <a id="_idIndexMarker385"/>Network Profiler, one of the most powerful tools available to us for identifying issues related to the High-Level Network API. In this section, we will dive deeper into using the Network Profiler to identify bottlenecks related to RPCs and <code>MultiplayerSynchronizer</code> nodes. To accomplish this, we will be using the final version of the <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure </em><em class="italic">Prototype</em>, project.</p>
			<p>As mentioned before, we can use the Network Profiler to gather information about the size and count of a node’s incoming and outgoing RPCs, <code>MultiplayerSynchronizer</code> nodes’ network consumption, syncing count, and even a bandwidth meter. By understanding and analyzing this data, we can identify potential issues in our network code and come up with possible solutions.</p>
			<p>To start, let’s take a closer look at the incoming and outgoing RPC count and size to identify potential bottlenecks in our network code. We will also use the bandwidth meter to track the total bandwidth consumption and come up with possible improvements.</p>
			<p>After that, we will assess the synchronization count and size of <code>MultiplayerSynchronizer</code> syncing to optimize replication data.</p>
			<p>By the end of this section, you will have a better understanding of how to use the Network Profiler to identify and address issues related to your game’s network performance. So, let’s get started!</p>
			<p>RPCs are a straightforward and efficient way to pass data and trigger remote events over the network. However, it’s important to use them judiciously to avoid overloading the network.</p>
			<p>In this section, we will analyze the data related to our project’s RPCs and explore potential improvements. We will be implementing solutions in the next chapters, but for now, our focus is on learning how to look at the data critically and make informed decisions.</p>
			<p>We start by playing the <code>res://09.prototyping-space- adventure/MainMenu.tscn</code> scene with three game sessions opened. Let’s start the Network Profiler on all three of them.</p>
			<p class="IMG---Figure"> </p>
			<div><div><img alt="Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling" src="img/Figure_10.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling</p>
			<p>Then, let’s pick one to be the <a id="_idIndexMarker386"/>server while using the others as clients, in other words, as players. To enable multiple game sessions, you can select the <strong class="bold">Run 3 Instances</strong> option in the <strong class="bold">Debug</strong> → <strong class="bold">Run Multiple </strong><strong class="bold">Instances</strong> menu.</p>
			<p>With all three sessions opened, let’s identify which one is the server. For that, open the Debugger <code>ServerButton</code>. In my case, it’s the <strong class="bold">Session 2</strong> game instance, as shown in the following figure.</p>
			<div><div><img alt="Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game instance" src="img/Figure_10.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game instance</p>
			<p>Now that we know that <code>QuestDatabase</code>.</p>
			<p>To test whether this modification worked, I destroyed the <em class="italic">Asteroids</em> with one of the players’ game instances, so go ahead and do the same. After destroying all 30 <em class="italic">Asteroids</em>, let’s analyze the data that the Network Profiler collected. At this point, you can stop the Network Profiler if you want. In the following figure, we have the <strong class="bold">Session 1</strong> data, so we can assume it’s a client.</p>
			<p class="IMG---Figure"> </p>
			<div><div><img alt="Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data it gathered" src="img/Figure_10.13_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data it gathered</p>
			<p>Let’s start with a brief analysis of the RPC counts and size. You can see that in the first row, we have a player <code>Spaceship/Weapon2D</code> with a high <code>fire()</code> method being called from another client’s game instance, so we can assume the player that destroyed the <em class="italic">Asteroids</em> used <strong class="bold">Session 3</strong>.</p>
			<p>This client called this method 693 times. The <code>fire()</code> method doesn’t rely on any data that would require streaming it this many times. <code>Weapon2D</code> essentially has two major states:</p>
			<ul>
				<li>Firing</li>
				<li>Not firing</li>
			</ul>
			<p>This means that we could improve this RPC count by sending a Boolean value through the network once when the player presses the firing action and when they release the firing action. In the meantime, <code>Weapon2D</code> itself would just toggle between these two states, firing and not firing, and use <code>process()</code> to spawn <em class="italic">Bullets</em> based on their fire rate. This would reduce this RPC count by a lot.</p>
			<p>Did you notice how important this assessment can be as you build your project and adjust it along the way? Pretty cool, right?</p>
			<p>Next, let’s take a look at the <code>QuestDatabase</code> node in the fourth row. It’s the only node that has an outgoing RPC count, right? So, it’s making requests to the server’s game instance. It made a total of 30 RPCs, but notice that their size is comparatively bigger than the 693 incoming <code>fire()</code> RPCs. This means that the data transmitted through this RPC is bigger. We should pay attention to it. This is likely to be the <code>update_player_progress()</code> method. Notice that we have 30 <em class="italic">Asteroids</em>, and every time we destroy one of them, we make an RPC to the <code>update_player_progress()</code> method. The count is correct and I can’t see a clear area of improvement in this regard. It has a ratio of 1:1 – one event, one trigger. So, we are likely to figure out a way to improve the data; maybe compress it somehow to decrease the overall bandwidth.</p>
			<p>Finally, let’s take a look at the <em class="italic">Asteroids’</em> RPC count. Every single one of them receives only 3 RPCs; this is probably due to the server’s <em class="italic">Bullets</em> hitting the <em class="italic">Asteroids</em>, which leads to the server calling the <code>hit()</code> method twice on the clients’ instances. Then, it calls the <code>explode()</code> method the third time a <em class="italic">Bullet</em> hits</p>
			<p>the <em class="italic">Asteroid</em>. It seems that this class is pretty healthy regarding its RPC counts on the client’s side. There’s nothing to improve on this side of the relationship. Let’s take a look at the server’s side. The following figure showcases the server’s Network Profiler. Note that, in this playtest, the server is represented by the <strong class="bold">Session 3</strong> instance of the game.</p>
			<div><div><img alt="Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data it gathered" src="img/Figure_10.14_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data it gathered</p>
			<p>The server has outgoing<a id="_idIndexMarker387"/> RPCs on its <em class="italic">Asteroids</em> instances, and they also have a total count of <code>SceneTree</code> instance, so there’s no reason to play animations on the server. Ideally, the server will be a headless instance, so there’s really no reason to play animations on it. But we won’t dwell in these lands yet. What we can do in the current project is to change the <code>hit()</code> method’s RPC annotation to only call it remotely and not locally. This way, at least the hit animation will only play on the client’s side.</p>
			<p>Let’s take the chance that we are working with the <em class="italic">Asteroids</em> and also make an analysis of their <code>MultiplayerSynchronizer</code> nodes. You can see on the right panel’s <code>World</code> node calls its <code>sync_world()</code> method. After that, there’s no reason to keep updating the asteroids’ properties. So, we can use the asteroids <code>MultiplayerSynchronizer</code> <code>update_visibility()</code> method inside the <code>sync_world()</code> method and decrease this bandwidth consumption as well.</p>
			<p>By using the <a id="_idIndexMarker388"/>Network Profiler, we already identified areas for improvement, such as reducing the number of RPCs sent to the <code>Weapon2D.fire()</code> method and manually calling the <code>MultiplayerSynchronizer</code> syncing to decrease overall bandwidth. We also saw that we can change the RPC annotation of <code>Asteroid.hit()</code> to only call it remotely and not locally to reduce unnecessary animations on the server side.</p>
			<p>Well, with just a brief analysis, we spotted some clear areas for improvement, didn’t we? And we haven’t even finished our assessment yet! In the next section, we will see how we can use the <code>Performance</code> singleton to create custom monitors and track them in the monitors track.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor274"/>Using the Monitors tab</h2>
			<p>In the previous section, we learned<a id="_idIndexMarker389"/> about the Network Profiler and how it can help us identify potential bottlenecks in our game’s network performance. In this section, we will focus on another powerful debugging tool in Godot Engine: the <strong class="bold">Monitors</strong> tab.</p>
			<p>The <strong class="bold">Monitors</strong> tab allows us to track and analyze specific data points in real time. We can use it to keep track of variables, functions, and even custom data points that we define ourselves. By monitoring these data points, we can gain insight into how our project is performing and identify areas for improvement.</p>
			<p>In addition to the built-in monitors, we can also create custom monitors to track specific variables or functions in our project. To do this, we need to use the <code>Performance.add_custom_monitor()</code> method, passing an ID, a <code>callable</code> instance, and, optionally, an array as arguments. Godot will create a monitor in the <code>id</code> argument and track the data using the <code>Callable</code> instance passed in the <code>callable</code> argument. This means that every time we trigger an event that should count for the data tracking, we need to execute the <code>callable</code> instance.</p>
			<p>During the current section, we will use the <code>QuestDatabase</code> node and the <code>QuestSingleton</code> node. By monitoring these data points, we will gain some insights into how our quest system is performing and identify potential areas for improvement.</p>
			<p>Let’s start by opening the <code>res://09.prototyping-spaceadventure/Quests/QuestDatabase.gd</code> script. We are going to create a member variable to keep track of how many times the <code>QuestDatabase.update_player_progress()</code> method was called. We can name this variable <code>quest_update_count</code> and set its default value to <code>0</code>. Then, we need to create a method that returns its current value; let’s call this method <code>get_quest_update_count()</code>:</p>
			<pre class="source-code">
func get_quest_update_count():
     return quest_update_count</pre>			<p>To update <code>quest_update_count</code>, let’s increment its value after the server successfully updates the player’s progress in a given quest. So, in the <code>update_player_progress()</code> method, add a line inside the <code>if multiplayer.is_server()</code> statement incrementing <code>quest_update_count</code> by <code>1</code> :</p>
			<pre class="source-code">
@rpc("any_peer", "call_remote")
func update_player_progress(quest_id, current_amount, completed, user):
     if multiplayer.is_server():
          progress_database[user][quest_id]["progress"] = current_amount
          progress_database[user][quest_id]["completed"] = completed
          quest_update_count += 1</pre>			<p>With that, we have<a id="_idIndexMarker390"/> everything ready to add <code>get_quest_update_count()</code> to our <code>_ready()</code> callback, create a <code>Callable</code> variable pointing to <code>QuestDatabase</code> using the <code>self</code> keyword, and pointing to <code>"get_quest_update_count"</code>. We can name this <code>Callable</code> variable <code>callable</code> to simplify the process:</p>
			<pre class="source-code">
func _ready():
     if multiplayer.is_server():
          load_database()
          var callable = Callable(self, "get_quest_update_count")</pre>			<p>Then, let’s call the <code>Performance.add_custom_monitor()</code> method. To keep things organized, we will use a category named <code>"Network"</code> for our custom monitors. So, in the <code>id</code> argument, we will pass <code>"Network/Quests Updates"</code> and pass <code>callable</code> as the second argument:</p>
			<pre class="source-code">
func _ready():
     if multiplayer.is_server():
          load_database()
         var callable = Callable(self, "get_quest_update_count")
          Performance.add_custom_monitor("Network/Quests Updates", callable)</pre>			<p>Let’s start by opening the <code>res://09.prototyping-space- adventure/Quests/QuestDatabase.gd</code> script. We are going to create a member variable to keep track of how many times the method was called.</p>
			<p>Now, to test whether this custom monitor is working and assess the data it will provide, let’s test the game using<a id="_idIndexMarker391"/> three debugging sessions and use one of the clients to destroy some <em class="italic">Asteroids</em>. This time around, my server is on <strong class="bold">Session 2</strong>. The following figure showcases <strong class="bold">Session 2</strong>’s <strong class="bold">Monitors</strong> tab. You can find the <strong class="bold">Quests Updates</strong> monitor at the very bottom of the <strong class="bold">Monitor</strong> panel; tick the checkbox and Godot will display the tracked data.</p>
			<div><div><img alt="Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests Updates tracked data" src="img/Figure_10.15_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests Updates tracked data</p>
			<p>Notice that Godot counted only 58 quest updates. So I may have missed one asteroid. Interesting, right? Why does one <em class="italic">Asteroid</em> trigger two calls to the <code>QuestDatabase.update_player_progress()</code> method? Well, remember that currently the quest progress is shared among all peers, so this can grow exponentially. If there were 3 players, there would be 96 calls to <code>QuestDatabase.update_player_progress()</code>. We need to figure out a way to limit that. One quick solution is to check whether the quest is already completed, and if it is, stop updating it. This would limit this particular quest to 10 calls per player, which would be a good improvement.</p>
			<p>Let’s make this comparison, just for testing purposes. Open <code>res://09.prototyping-space-adventure/Quests/QuestSingleton.gd</code> and let’s create a monitor that would only increment until the quest reaches the target amount required to complete the quest. To do that, let’s create a new member variable called <code>increase_count</code> and set its value to <code>0</code> by default:</p>
			<pre class="source-code">
var increase_count = 0</pre>			<p>Then, let’s create a method called <code>get_quest_increases()</code> that will return this variable:</p>
			<pre class="source-code">
func get_quest_increases():
  return increase_count</pre>			<p>In the <code>_ready()</code> callback, if<a id="_idIndexMarker392"/> this is a client instance, we will add a new custom monitor using the previous method as <code>callable</code>, just like we did with <code>QuestDatabase.get_quest_update_count()</code>:</p>
			<pre class="source-code">
func _ready():
  if not multiplayer.is_server():
    var callable = Callable(self, "get_quest_increases")
    Performance.add_custom_monitor("Network/Quest Increases", callable)</pre>			<p>Now, inside the <code>increase_quest_progress()</code> method, we will create an <code>if</code> statement that will only increment <code>increase_count</code> while <code>quest.current_amount</code> is less than <code>quest.target_amount</code>:</p>
			<pre class="source-code">
func increase_quest_progress(quest_id, amount):
  if not quest_id in quests.keys():
    return
  var quest = quests[quest_id]
  quest.current_amount += amount
  QuestDatabase.rpc_id(1, "update_player_progress", quest_id, quest.current_am
ount, quest.completed, AuthenticationCredentials.user)
  if quest.current_amount &lt; quest.target_amount:
increase_count += 1</pre>			<p>Let’s test the game again and see what happens in the clients’ <strong class="bold">Monitors</strong> tab. In the following figure, there’s something very interesting happening.</p>
			<div><div><img alt="Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests Increases tracked data" src="img/Figure_10.16_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests Increases tracked data</p>
			<p>This time around, <code>user2</code> credentials. Why this is relevant? Notice that there were only four increments to <code>increase_count</code> in this game instance. This is due to the fact that, in the <code>res://09.prototypingspace-adventure/Quests/QuestDatabase.json</code> file, <code>user2</code> already destroyed five asteroids, so it only needed five more to complete the quest. This means that we can improve this aspect of our game even between play sessions. The more progress a player makes in a game session, the fewer RPCs we will need to make to the server if we implement this approach; pretty cool, isn’t it?</p>
			<p>Throughout this <a id="_idIndexMarker394"/>section, we learned how we can use the <code>Performance</code> singleton to create new monitors in the <code>Performance.add_custom_monitor()</code> method. We also saw how we can create methods to collect data about potential bottlenecks in our game. Finally, we saw some potential fixes to the issues we found while debugging the game in order to optimize it.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor275"/>Summary</h1>
			<p>With that, we conclude our chapter! Throughout this chapter, we introduced the <strong class="bold">Debugger</strong> dock, which is a powerful tool for assessing and debugging potential problems in our game, as well as for optimizing its performance.</p>
			<p>We explored the <strong class="bold">Stack Trace</strong> tab, which gives us an overview of our game’s flow and provides us with multiple ways to gather information about the changes that happen throughout this flow, allowing us to understand the whole chain of cause and effect that led to a given change. We also talked about the <strong class="bold">Errors</strong> tab, which is where we work together with thousands of other developers who worked on the development of Godot Engine’s core and identified thousands of errors and documented them so that when they happen, we have some light on the issue and can fix it.</p>
			<p>On top of that, we explored two powerful performance-based debugging tabs: the <strong class="bold">Profiler</strong> tab and the <strong class="bold">Visual Profiler</strong> tab. The <strong class="bold">Profiler</strong> tab is one of your best allies in this task, as it allows you to see rendering time, physics simulation time, audio processing time, and even how much time each of your custom script functions is taking to process and how many times they were called. The <strong class="bold">Visual Profiler</strong> tab specializes in tracking and measuring rendering-related tasks and can help you keep track of what is causing the most delay in rendering a frame on the CPU and GPU.</p>
			<p>However, the protagonists of the chapter were the <code>MultiplayerSynchronizer</code> nodes by analyzing data gathered by the tool. By understanding and analyzing this data, we came up with possible solutions to optimize network code. In addition to that, we learned how to use the <code>Performance</code> singleton and create custom monitors to track specific data points in real time in the <strong class="bold">Monitors</strong> tab. By monitoring these data points, we gained insights into how our project is performing and even made a test for a potential improvement.</p>
			<p>In the next chapter, we are going to optimize data requests, especially regarding the quests data from the <code>QuestDatabase.get_player_quests()</code> method.</p>
			<p>By optimizing the way we request and handle data, we can improve our game’s performance and provide a better experience for our users. See you there!</p>
		</div>
	</body></html>