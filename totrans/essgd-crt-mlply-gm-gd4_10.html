<html><head></head><body>
		<div id="_idContainer128">
			<h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor260"/>10</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor261"/>Debugging and Profiling the Network</h1>
			<p>With <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure Prototype</em>, we concluded <em class="italic">Part 2</em>, <em class="italic">Creating Online Multiplayer Mechanics</em>, of our journey, where we learned how we can use Godot Engine’s High-Level Network API to turn local gameplay mechanics into online multiplayer mechanics. Now, it’s time to go beyond implementation and start the optimization of our mechanics. This chapter inaugurates <em class="italic">Part 3</em>, <em class="italic">Optimizing the Online Experience</em>, of our journey through creating online multiplayer games with <span class="No-Break">Godot Engine.</span></p>
			<p>It’s important that you have read, understood, and implemented the content provided in <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><em class="italic">, Creating an Online Adventure Prototype,</em> because we are going to use the final project as our main subject through the following chapters in <span class="No-Break"><em class="italic">Part 3</em></span><span class="No-Break">.</span></p>
			<p>In this specific chapter, we are going to understand how we can use Godot Engine’s built-in <strong class="bold">Debugger</strong> dock to assess and profile our game performance. For that, we are going to understand and use tools such as the <strong class="bold">Profiler</strong> tab, which helps us understand the rendering time of each frame by showing how many resources each function takes and how this impacts the processing time. We are also going to see one of the most important tools for our network craft, the <strong class="bold">Network Profiler</strong> tab, which helps us understand how many network resources each node’s <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) functions are taking and how our <strong class="source-inline">MultiplayerSynchronizers</strong> are performing, giving us a good overview of potential issues in our network implementation. Finally, we are going to learn how to use the Debugger dock’s <strong class="bold">Monitors</strong> tab and the <strong class="source-inline">Performance</strong> singleton to figure out potential bottlenecks in our game and gather data to design <span class="No-Break">potential solutions.</span></p>
			<p>By the end of this chapter, you will understand how to use the powerful Debugger tools, and the elements in the following figure won’t scare you anymore; instead, they will be some of your most <span class="No-Break">reliable allies:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer112">
					<img alt="Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom) showing and plotting profiling data" src="image/Figure_10.1_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom) showing and plotting profiling data</p>
			<p>Don’t be surprised if you come back to this figure at the end of the chapter and understand what each of those graphs and charts means. You will get used to them, as they will appear in abundance throughout the next chapters, especially <a href="B18527_11.xhtml#_idTextAnchor276"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><em class="italic">,</em> <em class="italic">Optimizing </em><span class="No-Break"><em class="italic">Data Requests</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>As mentioned previously, it’s crucial that you’ve read and followed the instructions provided in <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure Prototype</em>. Here, in this chapter, we are going to use the final product you should have by the end of the previous chapter. You can access the resources for this chapter in the repository provided in the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a></p>
			<p>With the result of <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><em class="italic">, </em><em class="italic">Creating an Online Adventure Prototype,</em> ready, we can move on to understanding how we can <span class="No-Break">improve it.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor263"/>Introducing Godot’s Debugger</h1>
			<p>The <a id="_idIndexMarker364"/>Debugger is a developer’s best friend. Most of the work we do doesn’t have anything to do with creating and implementing features; instead, it has everything to do with assessing potential problems these implementations cause and fixing them. The <strong class="bold">Debugger</strong> dock is where Godot Engine talks to us, showing errors, warnings, resource consumption, object count, and more. So, we should listen carefully and properly address the issues and data it shows us. We can even ask it to track custom data, as we are going to see in the <em class="italic">Using the Monitors </em><span class="No-Break"><em class="italic">tab</em></span><span class="No-Break"> section.</span></p>
			<p>If you have been developing games with Godot Engine for enough time to run into errors, you have probably stumbled on the <strong class="bold">Debugger</strong> dock more than you’d like to, right? In this section, we will go in-depth to understand how to turn it into our best friend and actually wish it pops up. Let’s start by understanding each of its tabs, how to read them, and what to expect from them, starting with the most common and probably the one you’ve already had a hard time with: the <strong class="bold">Stack </strong><span class="No-Break"><strong class="bold">Trace</strong></span><span class="No-Break"> tab.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor264"/>Mastering the Stack Trace tab</h2>
			<p>When you <a id="_idIndexMarker365"/>click on the <strong class="bold">Debugger</strong> dock, Godot Engine’s editor will open the <strong class="bold">Stack Trace</strong> tab. Let’s use the following figure to navigate it and understand what each of its <span class="No-Break">elements does.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer113">
					<img alt="Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements" src="image/Figure_10.2_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements</p>
			<p>You can see that each element of the <strong class="bold">Stack Trace</strong> tab in the figure is associated with a number, which will facilitate a better understanding. In the following list, we have the element’s name and a brief explanation <span class="No-Break">about it:</span></p>
			<ul>
				<li>The <strong class="bold">Stack Frames</strong> panel is the stack of functions that leads to an error or a breakpoint (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Filter Stack Variables</strong> field is where you can filter variable names to display them in the panel below (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Members</strong> panel is where you can find the variables within a given script including temporary variables and scope-specific variables. Here, you can also see and edit their values (highlighted and marked with <strong class="bold">3</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Breakpoints</strong> panel is where you can see information about a breakpoint reached in the script of a given instance (highlighted and marked with <strong class="bold">4</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Skip Breakpoints</strong> button, when toggled on, allows the execution of the game to run ignoring breakpoints (highlighted and marked with <strong class="bold">5</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Copy Error</strong> button copies the current error, if any, to your clipboard (highlighted and marked with <strong class="bold">6</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>Clicking on the <strong class="bold">Step Into</strong> button when the application is paused, including when it reaches a breakpoint, will execute the next script instruction (i.e., line). It will enter in indented blocks it would naturally go into, executing the whole code (highlighted and marked with <strong class="bold">7</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>Clicking on the <strong class="bold">Step Over</strong> button when the application is paused, including when it reaches a breakpoint, will execute the next script instruction (i.e., line) but skip indented blocks (highlighted and marked with <strong class="bold">8</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Break</strong> button pauses the application as if it reached a breakpoint (highlighted and marked with <strong class="bold">9</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Continue</strong> button resumes the <a id="_idIndexMarker366"/>application if it was paused (highlighted and marked with <strong class="bold">10</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
			</ul>
			<p>With these elements at our disposal, we have the ability to experiment with our scripts and gather invaluable information about our game. For instance, we can see step by step how Godot Engine processes a given set of instructions using the <strong class="bold">Step Into</strong> button and see the stack of functions it executes and how the objects’ variables change with <span class="No-Break">each step.</span></p>
			<p>A cool tip to use this to its fullest is to not be afraid to add breakpoints all over your scripts to understand when, what, how, and why your objects change and the whole chain of events that caused <span class="No-Break">such changes.</span></p>
			<p>In this section, we’ve gone through the <strong class="bold">Stack Trace</strong> tab, which gives us an overview of our game’s flow and provides us with multiple ways of gathering information about the changes that happen through this flow, allowing us to understand the whole chain of cause-effects that led to a given change. This is especially helpful together with our next tab, the <strong class="bold">Errors</strong> tab. Let’s talk about it in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor265"/>Debugging with the Errors tab</h2>
			<p>It may sound weird but, in many situations, you might <a id="_idIndexMarker367"/>wish for Godot Engine to prompt an error, especially when dealing with network features, as sometimes you are left waiting for something to happen. And if the packets sent don’t reach their destination, you will be hanging there waiting for an error to pop up, but packets not reaching their destination isn’t an error in itself. Still, it’s an undesired situation that can leave <span class="No-Break">you confused.</span></p>
			<p>The <strong class="bold">Errors</strong> tab is where you work with thousands of other developers, who worked on the development of Godot Engine’s core and identified thousands of errors and documented them so that when they happen, you have some light on the issue and are able to <span class="No-Break">fix it.</span></p>
			<p>However, not only <a id="_idIndexMarker368"/>errors are displayed in this tab. The <strong class="bold">Errors</strong> tab also shows warnings about your script. They don’t necessarily break your application but are something you should be aware of and make a decision on. For instance, it’s common to get warnings about arguments in a function that are not being used in the function’s implementation. The following figure displays the <strong class="bold">Error</strong> tab and its elements associated with numbers, just like in the <em class="italic">Mastering the Stack Trace </em><span class="No-Break"><em class="italic">tab</em></span><span class="No-Break"> section:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer114">
					<img alt="Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements" src="image/Figure_10.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements</p>
			<p>Now, let’s understand what each of these elements is and how they can be useful <span class="No-Break">for us:</span></p>
			<ul>
				<li>The <strong class="bold">Errors and Warnings</strong> panel is where all the warnings and fatal and non-fatal errors are displayed. You can click on an error or warning to expand it and go to the script line that triggered it. You can also double-click to expand an error or warning and display the code stack that led to the error. When you double-click an expanded error or warning, you collapse it (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Expand All</strong> button expands all the errors and warnings (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Collapse All</strong> button collapses all the errors and warnings (highlighted and marked with <strong class="bold">3</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Clear</strong> button empties the <strong class="bold">Errors and Warnings</strong> panel (highlighted and marked with <strong class="bold">4</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
			</ul>
			<p>Something <a id="_idIndexMarker369"/>interesting about dealing with errors and warnings is that you can create your own error or warning messages. This is especially good when working with your teammates, but also, since we are working with more than one instance of the game running, it’s a good way to compartmentalize messages to their instance’s <strong class="bold">Error</strong> tab. As the <strong class="bold">Output</strong> dock is shared between all instances, it may get really confusing to identify where a <strong class="source-inline">print()</strong> statement is coming from. So you can use the <strong class="source-inline">push_error()</strong> and <strong class="source-inline">push_warning()</strong> built-in methods instead and Godot will only show them in the game session’s <strong class="bold">Debugger</strong> dock that triggered the error or warning. The following figure showcases the <strong class="bold">Error</strong> tab of <strong class="bold">Session 3</strong> with a custom warning expanded so we can see where it <span class="No-Break">comes from:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer115">
					<img alt="Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among other built-in warnings" src="image/Figure_10.4_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among other built-in warnings</p>
			<p>Notice that the <strong class="bold">Debugger</strong> button at the bottom tells us there’s a total of 20 errors and warnings, but when we open the <strong class="bold">Errors</strong> tab in <strong class="bold">Session 3</strong>, there are only 13. This is because the other errors come from other sessions and are in their respective <span class="No-Break"><strong class="bold">Errors</strong></span><span class="No-Break"> tabs.</span></p>
			<p>With this powerful tool in our arsenal, we can trigger all sorts of errors and warnings in each individual game session, allowing us to distinguish which session is the server, which ones are players if any peer is getting a specific error that others aren’t, and so on. In the next section, we will talk about our first performance-based debugging tab, the <strong class="bold">Profiler</strong> tab, where we can see how our game is performing, how many resources it is taking, and which objects and functions are taking the most out of <span class="No-Break">our computer.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor266"/>Exploring the Profiler tab</h2>
			<p>Most <a id="_idIndexMarker370"/>developers are always looking for the most efficient, cheap, and ingenious optimizations to make their code run in a toaster. Well, while this is a nice and beautiful fantasy, the reality is that you shouldn’t be so focused on optimizing your code unless you really need it. There’s a saying in the industry that states, “<em class="italic">Premature optimization is the doom of </em><span class="No-Break"><em class="italic">an application</em></span><span class="No-Break">.”</span></p>
			<p>Focus on the <em class="italic">premature</em> <span class="No-Break">word here.</span></p>
			<p>So, if premature optimization is something bad, but optimization in itself is something good, when is the right time to optimize your game or application? The answer is not set in stone and there’s no clear point that we can just point out and say “<em class="italic">Here, after X days of development, it’s time to optimize</em>,” or “<em class="italic">After you reach 80% of production, it’s the sign to optimize</em>.” No, instead, you should address issues as they show up and create the habit of diagnosing your game’s performance and deciding whether, based on your audience’s computers’ specs, you are going to need to squeeze some resources or not. This can happen on production day 1, or years after launching <span class="No-Break">the game.</span></p>
			<p>So, you need to engage in the habit of looking at how your game is performing and looking for areas of <span class="No-Break">improvement regularly.</span></p>
			<p>The <strong class="bold">Profiler</strong> tab is one of <a id="_idIndexMarker371"/>your best allies in optimization. It is in this tab that you will see rendering time, physics simulation time, audio processing time, and even how much time each of your custom script functions is taking to process and how many times they were called. Let’s take a look at the following figure and understand how the <strong class="bold">Profiler</strong> tab displays all <span class="No-Break">this information.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer116">
					<img alt="Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements" src="image/Figure_10.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements</p>
			<p>Let’s understand the role of each of these elements, again, following their number in <span class="No-Break">the figure:</span></p>
			<ul>
				<li>The <strong class="bold">Functions</strong> panel displays the currently available functions that the profiler can track (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Start</strong> button initializes the measurement. Note that without toggling this on, the profiler won’t do anything. Profiling is quite resource-intensive, so by default, it’s off (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Clear</strong> button clears the current data gathered and displayed (highlighted and marked with <strong class="bold">3</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Measure</strong> drop-down menu allows us to change the type of data we want to measure (highlighted and marked with <strong class="bold">4</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em>). The current options are <span class="No-Break">as follows:</span><ul><li><strong class="bold">Frame Time (ms)</strong> is how many milliseconds Godot Engine takes to process <span class="No-Break">a frame.</span></li><li><strong class="bold">Average Time (ms)</strong> is how long a function takes to process. This averages the time of each call of any <span class="No-Break">given function.</span></li><li><strong class="bold">Frame %</strong> is the percentage a given function takes to process relative to the frame’s rendering time. For instance, functions that are more resource-intensive take a <span class="No-Break">bigger percentage.</span></li><li><strong class="bold">Physics Frame %</strong> is the same as <strong class="bold">Frame %</strong> but relative to the physics <span class="No-Break">frame process.</span></li></ul></li>
				<li>The <strong class="bold">Time Scope</strong> drop-down menu allows us to change the functions’ time scope that we want to measure (highlighted and marked with <strong class="bold">5</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em>), and it has the <span class="No-Break">following options:</span><ul><li><strong class="bold">Inclusive</strong>, which will take into account the time a function and all its nested functions took <span class="No-Break">to render</span></li><li><strong class="bold">Self</strong>, which will only take into account the individual time of each function without considering the function calls that the measured <span class="No-Break">function made</span></li></ul></li>
				<li>The <strong class="bold">Frame #</strong> stepper, or spinbox, marks the frame you are currently assessing (highlighted and marked with <strong class="bold">6</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em>). Changing the frame number will allow you to accurately see the function’s measurements related to this frame in the <span class="No-Break"><strong class="bold">Functions</strong></span><span class="No-Break"> panel.</span></li>
				<li>The <strong class="bold">Measurement Graph</strong> panel is where the data is plotted so we can see it and access any unusual data. Each measured function has its own color to make it easy to see it on the graph (highlighted and marked with <strong class="bold">7</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
			</ul>
			<p>The Profiler is a <a id="_idIndexMarker372"/>powerful ally ready to give us access to important data regarding resource management. Now that we understand how to use it, let’s move on to the second profiler on the <strong class="bold">Debugger</strong> dock, <span class="No-Break"><strong class="bold">Visual Profiler</strong></span><span class="No-Break">.</span></p>
			<p>This one specializes in visual resources and potential bottlenecks so that we can improve our game’s visuals regarding rendering and other <span class="No-Break">visual procedures.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor267"/>Exploring the Visual Profiler tab</h2>
			<p>On top of knowing how <a id="_idIndexMarker373"/>many processing resources your functions are taking from the CPU, it’s also important to assess how much the rendering-related tasks (such as culling, lightning, and draw calls) are taking from the GPU. The <strong class="bold">Visual Profiler</strong> tool can help you keep track of what is causing the most delay in rendering a frame on the CPU and GPU. By identifying these sources of potential bottlenecks caused by rendering, you can optimize your CPU and <span class="No-Break">GPU performance.</span></p>
			<p>The <strong class="bold">Visual Profiler</strong> tab is quite <a id="_idIndexMarker374"/>similar to the <strong class="bold">Profiler</strong> tab but specializes in tracking and measuring rendering-related tasks. Take a look at the following figure to understand how the <strong class="bold">Visual Profiler</strong> tab displays all of <span class="No-Break">this information.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer117">
					<img alt="Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements" src="image/Figure_10.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements</p>
			<p>In order to gain a deeper understanding of each of these elements, let us take a closer look at their individual roles. Again, we are going to follow the elements in the <span class="No-Break">numeric order:</span></p>
			<ul>
				<li>The <strong class="bold">Tasks</strong> panel displays the rendering-related tasks divided into categories. Note that they are broken down into elements such as the related viewport and canvas layer (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Start</strong> button, just like in the <strong class="bold">Profiler</strong> tab, initializes the profiling. Visual profiling is also turned off by default (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Clear</strong> button clears the current data gathered in the profiling session (highlighted and marked with <strong class="bold">3</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Measure</strong> drop-down menu (highlighted and marked with <strong class="bold">4</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.6</em>) allows us to select two <span class="No-Break">measurement options:</span><ul><li><strong class="bold">Frame Time (ms)</strong> is the time taken to render a frame <span class="No-Break">in milliseconds</span></li><li><strong class="bold">Frame %</strong> is the percentage a given procedure takes from the rendering time of a <span class="No-Break">given frame</span></li></ul></li>
				<li>The <strong class="bold">Fit to Frame</strong> checkbox will fit the graph to the default frame scale (highlighted and marked with <strong class="bold">5</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.6</em>). Disable it to fit the graph onto over 60 <strong class="bold">Frames Per Second </strong>(<span class="No-Break"><strong class="bold">FPS</strong></span><span class="No-Break">) portions.</span></li>
				<li>The <strong class="bold">Linked</strong> checkbox zooms the CPU and the GPU graphs to fit the same scale (highlighted and marked with <strong class="bold">6</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Frame #</strong> stepper, just like in the <strong class="bold">Profiler</strong> tab, marks the current frame you are assessing. Rendering tasks displayed in the <strong class="bold">Tasks</strong> panel relate to this frame (highlighted and marked with <strong class="bold">7</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
			</ul>
			<p><strong class="bold">Visual Profiler</strong> is yet another <a id="_idIndexMarker375"/>powerful ally when optimizing the rendering performance of your game and is a game-changing tool that can help you assess what may be causing lags and frame drops in your game. In the next section, we are going to understand yet another powerful tool available for us to assess our game’s health, the <strong class="bold">Monitors</strong> tab, where we can find all sorts of interesting information regarding <span class="No-Break">our game.</span></p>
			<p>Well, let’s dive into it so we understand how each of these, among other available data, will help us address potential issues in our <span class="No-Break">game’s performance.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor268"/>Exploring the Monitors tab</h2>
			<p>Here is the part where you can <a id="_idIndexMarker376"/>really feel like a game doctor. <strong class="bold">Monitors</strong> allows us to assess important data as graphs and see the game’s overall health. In this tab, we can track performance-related data in graphs. By default, it presents some useful data, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Time-related data, such as <strong class="bold">FPS</strong>, process time, and physics <span class="No-Break">process time</span></li>
				<li>Memory-related data, such as static memory, dynamic memory, and <span class="No-Break">message buffers</span></li>
				<li>Object-related data, such as the total object count, resource count, node count, and <span class="No-Break">orphan nodes</span></li>
			</ul>
			<p>There’s a series of properties you can track and plot into graphs so you can analyze your game’s health and spot potential areas for improvement. In the following figure, you can see the Debugger <strong class="bold">Monitors</strong> tab with some properties being tracked and plotted. Note that these properties are toggled on in the left panel by default. The <strong class="bold">Monitors</strong> tab will only plot charts for properties we toggle on in the <span class="No-Break">left panel:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer118">
					<img alt="Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements" src="image/Figure_10.7_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements</p>
			<p>The <strong class="bold">Monitors</strong> tab seems to be the simplest of the tabs we’ve seen so far, but it is still very powerful, so let’s understand the two core elements that build <span class="No-Break">it up:</span></p>
			<ul>
				<li>The <strong class="bold">Monitor</strong> panel is where we can find the available monitors. A monitor is data marked for tracking. Note that there are plenty of monitors by default. By using them, we can obtain some valuable information about our project’s health (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Graphs</strong> panel is where the monitors are plotted as graphs, and each monitor has its own graph and measures. Only the monitors checked in the <strong class="bold">Monitor</strong> panel are plotted in the <strong class="bold">Graphs</strong> panel (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">).</span></li>
			</ul>
			<p>Note that there is no <em class="italic">start</em>, <em class="italic">stop</em>, or <em class="italic">clear</em> button on the <strong class="bold">Monitors</strong> tab. This is because Godot will always track the <span class="No-Break">monitorable data.</span></p>
			<p>Something <a id="_idIndexMarker377"/>interesting about the <strong class="bold">Monitors</strong> tab is that, on top of the default monitors, we can also create custom monitors using the <strong class="source-inline">Performance</strong> singleton. We are going to talk about that in the <em class="italic">Identifying the project’s bottlenecks</em> section, where we will also talk about the <strong class="bold">Monitors</strong> panel in depth. In the next section, we will talk about the <strong class="bold">Video RAM</strong> tab, where we can assess our <span class="No-Break">video-related resources.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor269"/>Getting to know the Video RAM tab</h2>
			<p>The <strong class="bold">Video RAM</strong> tab is <a id="_idIndexMarker378"/>useful when you want to understand what resources are causing the most impact on your video memory. This is of great help, especially in 3D games, but it can also be useful for 2D games – for instance, when we want to assess whether we need to pack more sprites into a <span class="No-Break">single texture.</span></p>
			<p>The <strong class="bold">Video RAM</strong> tab is quite a simple panel with the essential information you need to assess video-related memory consumption. In the following figure, we can see it is made of a single table with four columns inside <span class="No-Break">a panel:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer119">
					<img alt="Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel" src="image/Figure_10.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel</p>
			<p>This is an intuitive panel with the necessary data we need to understand the video memory usage of our resources. Let’s understand the type of information each of these <span class="No-Break">columns presents:</span></p>
			<ul>
				<li><strong class="bold">Resource Path</strong> is the path in our Godot Engine’s project to <span class="No-Break">the resource.</span></li>
				<li><strong class="bold">Type</strong> is the type of the tracked resource. In the preceding figure, all the resources are of the <strong class="bold">Texture</strong> type, but this can be a variety of other types. It can be useful to compare whether it’s worth making an <strong class="source-inline">AtlasTexture</strong> Resource or a set of simple textures, <span class="No-Break">for instance.</span></li>
				<li>The <strong class="bold">Format</strong> column is where we can find the data regarding the <span class="No-Break">file’s format.</span></li>
				<li><strong class="bold">Usage</strong> is what we actually want in the end. It answers an important question: Given all the previous information, how much memory does this <span class="No-Break">resource take?</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There’s an option to save the table as a CSV file if you want to export it and make some table operations or create charts. This can be very useful for presentations, <span class="No-Break">for instance.</span></p>
			<p>The <strong class="bold">Video RAM</strong> tab in <a id="_idIndexMarker379"/>Godot Engine’s <strong class="bold">Debugger</strong> dock is useful for assessing video-related memory consumption in games. It presents information on the resource path, type, format, and usage of video memory for each resource, helping us understand which resources we can improve, combine, remove, mix, and match to squeeze our available memory and open space for more resources. This kind of optimization is also good for low-end devices as, by using this, we can decrease the necessary specs to run the game. In the next section, we will talk about the <strong class="bold">Misc</strong> tab, where we can find the last clicked <strong class="source-inline">Control</strong> node during the <span class="No-Break">debugging section.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor270"/>Grasping the Misc tab</h2>
			<p>As <a id="_idIndexMarker380"/>mentioned previously, the Debugger <strong class="bold">Misc</strong> tab allows us to see the last <strong class="source-inline">Control</strong> node clicked in the <strong class="bold">Debugging</strong> section; note that this updates in runtime. This can be helpful to address crashes, screen flow, and most likely, which <strong class="source-inline">Control</strong> node is consuming inputs, and fix that in case we can have another <strong class="source-inline">Control</strong> node responsible for that. For instance, this is common when you have a <strong class="source-inline">ColorRect</strong> node that you use to fade the screen. If you don’t set <strong class="bold">Mouse Filter</strong> to <strong class="bold">Ignore</strong>, it will consume mouse events and prevent the player from interacting with other UI elements. In the following figure, we have the <strong class="bold">Misc</strong> tab for <span class="No-Break">our game:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer120">
					<img alt="Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements" src="image/Figure_10.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements</p>
			<p>The <strong class="bold">Misc</strong> tab is quite simple, and we can’t do a lot with it. Still, it’s a good <a id="_idIndexMarker381"/>companion when we want to address interface-related issues, so let’s understand the elements that build up this <span class="No-Break">debugging tool:</span></p>
			<ul>
				<li>The <strong class="bold">Clicked Control</strong> row displays the last clicked <strong class="source-inline">Control</strong> node in the debugging section (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Clicked Control Type</strong> row displays the type of the clicked control (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Live Edit Root</strong> row displays the current root node in the live <strong class="source-inline">SceneTree</strong> instance (highlighted and marked with <strong class="bold">3</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Set From Tree</strong> button has no official documentation and it seems to be disabled all the time, so we couldn’t test what this button does (highlighted and marked with <strong class="bold">4</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Clear</strong> button clears the data in the previously mentioned rows (highlighted and marked with <strong class="bold">5</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Export measures as CSV</strong> button allows you to export a CSV file with the data in the aforementioned rows. It might be useful for keeping track of how the game flows based on the interactions with its controls (highlighted and marked with <strong class="bold">6</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></li>
			</ul>
			<p>A good use case for this tab might be <em class="italic">Point ‘n’ Click</em> games. Since most interactions in this game happen with mouse clicks, we can use the Debugger <strong class="bold">Misc</strong> tab to identify which element led to a specific event. For instance, when clicking on a menu while a dialogue is being displayed, which one should consume the mouse click? Well, if the one you chose isn’t consuming the input, you can use the Debugger <strong class="bold">Misc</strong> tab to see <span class="No-Break">what’s happening.</span></p>
			<p>We just finished covering almost all the tools we can use to debug and profile our game. The only missing one is, for you, our fake studio’s network engineer, the most important one. The Network Profiler is where you are going to find the impact of your RPCs and synchronizers, along with other relevant information related to the High-Level Network API. Let’s get right <span class="No-Break">into it!</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor271"/>Understanding the Network Profiler</h1>
			<p>It’s time to meet your best ally, the one that will help you address issues related to your craft as the network engineer of our fake studio and come up with potential solutions for the problems that appear along your journey. The <a id="_idIndexMarker382"/>Network Profiler, as the name suggests, is a profiler specialized in network-related profiling. It displays information about RPCs’ size and count, both sent and received, the node making and receiving the RPCs, <strong class="source-inline">MultiplayerSynchronizer</strong> nodes’ network consumption and syncing count, and even a bandwidth meter, which are all we need to assess the impact of our <span class="No-Break">network code.</span></p>
			<p>Note that the Network Profiler, by default, only tracks the High-Level Network API bandwidth. So, if you are using low-level approaches, such as <strong class="source-inline">PacketPeerUDP</strong>, <strong class="source-inline">UDPServer</strong>, <strong class="source-inline">StreamPeerTCP</strong>, and <strong class="source-inline">TCPServer</strong>, their consumption may not be taken into account by the Network Profiler by default. We are going to see how we can address that in the <em class="italic">Using the Monitors </em><span class="No-Break"><em class="italic">tab</em></span><span class="No-Break"> section.</span></p>
			<p>Let’s dive into the features we <a id="_idIndexMarker383"/>have available in the <strong class="bold">Network Profiler</strong> tab. Again, each element in this interface will be numbered for <span class="No-Break">further reference.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer121">
					<img alt="Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements" src="image/Figure_10.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements</p>
			<p>Although the Network Profiler has fewer elements than the other profilers, each of its elements is more complex as well. You may have also noticed that there’s no graph element, right? So, assessing this data can be a bit less natural. But let’s understand what each of these elements does and how we can <span class="No-Break">use them:</span></p>
			<ul>
				<li>The RPC panel displays each node that sends and receives RPCs (highlighted and marked with <strong class="bold">1</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.10</em>). On the right, we can see the <strong class="bold">Incoming RPC</strong> count and size and the <strong class="bold">Outgoing RPC</strong> count and size <span class="No-Break">in bytes:</span><ul><li>The <strong class="bold">Node</strong> column displays the node path to the node sending and <span class="No-Break">receiving RPCs.</span></li><li>The <strong class="bold">Incoming RPC</strong> column displays the count and size of RPCs this node is receiving in bytes. This means other nodes in the network are calling RPCs in this particular node. Note that all <strong class="source-inline">Asteroid</strong> nodes have an <strong class="bold">Incoming RPC</strong> value of <strong class="source-inline">3</strong>, which is probably because they receive 3 calls to process damage and are destroyed right after the <span class="No-Break">third one.</span></li><li>The <strong class="bold">Outgoing RPC</strong> column displays the count and size, in bytes, of RPCs this node is sending. This means it is calling RPCs on other nodes. Notice that <strong class="source-inline">Weapon2D</strong> has a big <strong class="bold">Outgoing RPC</strong> value because it’s constantly telling its peers’ instances to <span class="No-Break">fire bullets.</span></li></ul></li>
				<li>The <strong class="bold">Start</strong> button. Just like in the previous profilers, network profiling is turned off by default; by pressing this button, we can start profiling (highlighted and marked with <strong class="bold">2</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Clear</strong> button clears the current data gathered in the profiling session (highlighted and marked with <strong class="bold">3</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">).</span></li>
				<li>The <strong class="bold">Bandwidth</strong> meter displays the total bandwidth consumption in bytes per second of the current profiling session (highlighted and marked with <strong class="bold">4</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">):</span><ul><li><strong class="bold">Down</strong> displays how many bytes per second it downloaded in this <span class="No-Break">profiling session</span></li><li><strong class="bold">Up</strong> displays how many bytes per second it uploaded during this <span class="No-Break">profiling session</span></li></ul></li>
				<li>The <strong class="bold">Synchronization</strong> panel displays all the <strong class="source-inline">MultiplayerSynchronizer</strong> nodes, their <strong class="source-inline">SceneReplicationConfig</strong> resource, which is always built-in by default, the sync count, and sync size in bytes (highlighted and marked with <strong class="bold">5</strong> in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">):</span><ul><li>The <strong class="bold">Root</strong> column displays the root node of the <strong class="source-inline">MultiplayerSynchronizer</strong> <span class="No-Break">node’s scene</span></li><li>The <strong class="bold">Synchronizer</strong> column displays the <span class="No-Break">tracked </span><span class="No-Break"><strong class="source-inline">MultiplayerSynchronizer</strong></span></li><li>The <strong class="bold">Config</strong> column displays the <strong class="source-inline">SceneReplicationConfig</strong> resource associated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">MultiplayerSynchronizer</strong></span></li><li>The <strong class="bold">Count</strong> column displays how many times this particular <strong class="source-inline">MultiplayerSynchronizer</strong> node synced its <span class="No-Break">replication data</span></li><li>The <strong class="bold">Size</strong> column displays the total amount of data the synchronization took, in bytes, during the current <span class="No-Break">profiling session</span></li></ul></li>
			</ul>
			<p>With all this information in <a id="_idIndexMarker384"/>our hands, we can make sense of how our work is having an impact on the project’s overall performance. Knowing how many times a node calls its RPCs, how many times other nodes call its RPCs, the amount of data exchanged, and more can help us properly address the necessary bandwidth a player needs to play the game properly, and also optimize the game to embrace players with lower <span class="No-Break">network profiles.</span></p>
			<p>In the next section, we are going to learn how we can use the powerful tools we’ve seen so far to spot the bottlenecks in our network approach using the Network Profiler, but also extend our profiling by adding custom monitors to the <strong class="bold">Monitors</strong> tab. With that, we can pinpoint what we want Godot to report <span class="No-Break">to us.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor272"/>Identifying the project’s bottlenecks</h1>
			<p>With all the tools we’ve seen so far in this chapter at our disposal, it’s time to use them to assess our project’s health and look for areas of improvement. Since your focus here is on networking, we are going to concentrate on features related to this area. In this section, we will use the final version of the <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure Prototype</em>, project to look for areas of improvement using <strong class="bold">Network Profiler</strong> and the <strong class="bold">Monitors</strong> debugging tools. You will learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Analyze the incoming and outgoing RPC count and size to identify potential bottlenecks in the <span class="No-Break">network code</span></li>
				<li>Use the bandwidth meter to track the total bandwidth consumption and come up with <span class="No-Break">possible solutions</span></li>
				<li>Assess the synchronization count and size of <strong class="source-inline">MultiplayerSynchronizer</strong> nodes to optimize <span class="No-Break">replication data</span></li>
				<li>Create custom monitors to analyze relevant data specific to your project and track <span class="No-Break">potential issues</span></li>
			</ul>
			<p>Let’s get started with the tool that will be our reliable companion through the process of identifying the issues related to the High-Level Network API, the <span class="No-Break">Network Profiler.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor273"/>Using the Network Profiler</h2>
			<p>In the previous section, we saw the <a id="_idIndexMarker385"/>Network Profiler, one of the most powerful tools available to us for identifying issues related to the High-Level Network API. In this section, we will dive deeper into using the Network Profiler to identify bottlenecks related to RPCs and <strong class="source-inline">MultiplayerSynchronizer</strong> nodes. To accomplish this, we will be using the final version of the <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure </em><span class="No-Break"><em class="italic">Prototype</em></span><span class="No-Break">, project.</span></p>
			<p>As mentioned before, we can use the Network Profiler to gather information about the size and count of a node’s incoming and outgoing RPCs, <strong class="source-inline">MultiplayerSynchronizer</strong> nodes’ network consumption, syncing count, and even a bandwidth meter. By understanding and analyzing this data, we can identify potential issues in our network code and come up with <span class="No-Break">possible solutions.</span></p>
			<p>To start, let’s take a closer look at the incoming and outgoing RPC count and size to identify potential bottlenecks in our network code. We will also use the bandwidth meter to track the total bandwidth consumption and come up with <span class="No-Break">possible improvements.</span></p>
			<p>After that, we will assess the synchronization count and size of <strong class="source-inline">MultiplayerSynchronizer</strong> syncing to optimize <span class="No-Break">replication data.</span></p>
			<p>By the end of this section, you will have a better understanding of how to use the Network Profiler to identify and address issues related to your game’s network performance. So, let’s <span class="No-Break">get started!</span></p>
			<p>RPCs are a straightforward and efficient way to pass data and trigger remote events over the network. However, it’s important to use them judiciously to avoid overloading <span class="No-Break">the network.</span></p>
			<p>In this section, we will analyze the data related to our project’s RPCs and explore potential improvements. We will be implementing solutions in the next chapters, but for now, our focus is on learning how to look at the data critically and make <span class="No-Break">informed decisions.</span></p>
			<p>We start by playing the <strong class="source-inline">res://09.prototyping-space- adventure/MainMenu.tscn</strong> scene with three game sessions opened. Let’s start the Network Profiler on all three <span class="No-Break">of them.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer122">
					<img alt="Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling" src="image/Figure_10.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling</p>
			<p>Then, let’s pick one to be the <a id="_idIndexMarker386"/>server while using the others as clients, in other words, as players. To enable multiple game sessions, you can select the <strong class="bold">Run 3 Instances</strong> option in the <strong class="bold">Debug</strong> → <strong class="bold">Run Multiple </strong><span class="No-Break"><strong class="bold">Instances</strong></span><span class="No-Break"> menu.</span></p>
			<p>With all three sessions opened, let’s identify which one is the server. For that, open the Debugger <strong class="bold">Misc</strong> tab and look for the one where the last <strong class="bold">Clicked Control</strong> is <strong class="source-inline">ServerButton</strong>. In my case, it’s the <strong class="bold">Session 2</strong> game instance, as shown in the <span class="No-Break">following figure.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer123">
					<img alt="Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game instance" src="image/Figure_10.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game instance</p>
			<p>Now that we know that <strong class="bold">Session 2</strong> corresponds to the server, we can infer that the other two sessions are the clients. With this information in mind, we can start debugging with some premises. For instance, we can expect that the server will have a higher count of RPCs, especially the <span class="No-Break">server’s </span><span class="No-Break"><strong class="source-inline">QuestDatabase</strong></span><span class="No-Break">.</span></p>
			<p>To test whether this modification worked, I destroyed the <em class="italic">Asteroids</em> with one of the players’ game instances, so go ahead and do the same. After destroying all 30 <em class="italic">Asteroids</em>, let’s analyze the data that the Network Profiler collected. At this point, you can stop the Network Profiler if you want. In the following figure, we have the <strong class="bold">Session 1</strong> data, so we can assume it’s <span class="No-Break">a client.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer124">
					<img alt="Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data it gathered" src="image/Figure_10.13_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data it gathered</p>
			<p>Let’s start with a brief analysis of the RPC counts and size. You can see that in the first row, we have a player <strong class="source-inline">Spaceship/Weapon2D</strong> with a high <strong class="bold">Incoming RPC</strong> count. This is probably the <strong class="source-inline">fire()</strong> method being called from another client’s game instance, so we can assume the player that destroyed the <em class="italic">Asteroids</em> used <span class="No-Break"><strong class="bold">Session 3</strong></span><span class="No-Break">.</span></p>
			<p>This client called this method 693 times. The <strong class="source-inline">fire()</strong> method doesn’t rely on any data that would require streaming it this many times. <strong class="source-inline">Weapon2D</strong> essentially has two <span class="No-Break">major states:</span></p>
			<ul>
				<li><span class="No-Break">Firing</span></li>
				<li><span class="No-Break">Not firing</span></li>
			</ul>
			<p>This means that we could improve this RPC count by sending a Boolean value through the network once when the player presses the firing action and when they release the firing action. In the meantime, <strong class="source-inline">Weapon2D</strong> itself would just toggle between these two states, firing and not firing, and use <strong class="source-inline">process()</strong> to spawn <em class="italic">Bullets</em> based on their fire rate. This would reduce this RPC count by <span class="No-Break">a lot.</span></p>
			<p>Did you notice how important this assessment can be as you build your project and adjust it along the way? Pretty <span class="No-Break">cool, right?</span></p>
			<p>Next, let’s take a look at the <strong class="source-inline">QuestDatabase</strong> node in the fourth row. It’s the only node that has an outgoing RPC count, right? So, it’s making requests to the server’s game instance. It made a total of 30 RPCs, but notice that their size is comparatively bigger than the 693 incoming <strong class="source-inline">fire()</strong> RPCs. This means that the data transmitted through this RPC is bigger. We should pay attention to it. This is likely to be the <strong class="source-inline">update_player_progress()</strong> method. Notice that we have 30 <em class="italic">Asteroids</em>, and every time we destroy one of them, we make an RPC to the <strong class="source-inline">update_player_progress()</strong> method. The count is correct and I can’t see a clear area of improvement in this regard. It has a ratio of 1:1 – one event, one trigger. So, we are likely to figure out a way to improve the data; maybe compress it somehow to decrease the <span class="No-Break">overall bandwidth.</span></p>
			<p>Finally, let’s take a look at the <em class="italic">Asteroids’</em> RPC count. Every single one of them receives only 3 RPCs; this is probably due to the server’s <em class="italic">Bullets</em> hitting the <em class="italic">Asteroids</em>, which leads to the server calling the <strong class="source-inline">hit()</strong> method twice on the clients’ instances. Then, it calls the <strong class="source-inline">explode()</strong> method the third time a <span class="No-Break"><em class="italic">Bullet</em></span><span class="No-Break"> hits</span></p>
			<p>the <em class="italic">Asteroid</em>. It seems that this class is pretty healthy regarding its RPC counts on the client’s side. There’s nothing to improve on this side of the relationship. Let’s take a look at the server’s side. The following figure showcases the server’s Network Profiler. Note that, in this playtest, the server is represented by the <strong class="bold">Session 3</strong> instance of <span class="No-Break">the game.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer125">
					<img alt="Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data it gathered" src="image/Figure_10.14_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data it gathered</p>
			<p>The server has outgoing<a id="_idIndexMarker387"/> RPCs on its <em class="italic">Asteroids</em> instances, and they also have a total count of <strong class="bold">3</strong>, so it sounds like there’s a symmetry here, right? You would be fooled into thinking that there are no improvements to make on the server side as well. Remember, in <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><em class="italic">’</em>s <em class="italic">Separating server and client responsibilities</em> section, the server should calculate the damage and remove the <em class="italic">Asteroids</em> from the <strong class="source-inline">SceneTree</strong> instance, so there’s no reason to play animations on the server. Ideally, the server will be a headless instance, so there’s really no reason to play animations on it. But we won’t dwell in these lands yet. What we can do in the current project is to change the <strong class="source-inline">hit()</strong> method’s RPC annotation to only call it remotely and not locally. This way, at least the hit animation will only play on the <span class="No-Break">client’s side.</span></p>
			<p>Let’s take the chance that we are working with the <em class="italic">Asteroids</em> and also make an analysis of their <strong class="source-inline">MultiplayerSynchronizer</strong> nodes. You can see on the right panel’s <strong class="bold">Count</strong> column that we have some quite high numbers. But remember… the <em class="italic">Asteroids</em> don’t move, yet. At least not in this implementation. So why keep updating their positions constantly? The only time their properties should be synced is when the <strong class="source-inline">World</strong> node calls its <strong class="source-inline">sync_world()</strong> method. After that, there’s no reason to keep updating the asteroids’ properties. So, we can use the asteroids <strong class="source-inline">MultiplayerSynchronizer</strong> <strong class="source-inline">update_visibility()</strong> method inside the <strong class="source-inline">sync_world()</strong> method and decrease this bandwidth consumption <span class="No-Break">as well.</span></p>
			<p>By using the <a id="_idIndexMarker388"/>Network Profiler, we already identified areas for improvement, such as reducing the number of RPCs sent to the <strong class="source-inline">Weapon2D.fire()</strong> method and manually calling the <strong class="source-inline">MultiplayerSynchronizer</strong> syncing to decrease overall bandwidth. We also saw that we can change the RPC annotation of <strong class="source-inline">Asteroid.hit()</strong> to only call it remotely and not locally to reduce unnecessary animations on the <span class="No-Break">server side.</span></p>
			<p>Well, with just a brief analysis, we spotted some clear areas for improvement, didn’t we? And we haven’t even finished our assessment yet! In the next section, we will see how we can use the <strong class="source-inline">Performance</strong> singleton to create custom monitors and track them in the <span class="No-Break">monitors track.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor274"/>Using the Monitors tab</h2>
			<p>In the previous section, we learned<a id="_idIndexMarker389"/> about the Network Profiler and how it can help us identify potential bottlenecks in our game’s network performance. In this section, we will focus on another powerful debugging tool in Godot Engine: the <span class="No-Break"><strong class="bold">Monitors</strong></span><span class="No-Break"> tab.</span></p>
			<p>The <strong class="bold">Monitors</strong> tab allows us to track and analyze specific data points in real time. We can use it to keep track of variables, functions, and even custom data points that we define ourselves. By monitoring these data points, we can gain insight into how our project is performing and identify areas <span class="No-Break">for improvement.</span></p>
			<p>In addition to the built-in monitors, we can also create custom monitors to track specific variables or functions in our project. To do this, we need to use the <strong class="source-inline">Performance.add_custom_monitor()</strong> method, passing an ID, a <strong class="source-inline">callable</strong> instance, and, optionally, an array as arguments. Godot will create a monitor in the <strong class="bold">Monitors</strong> tab using the <strong class="source-inline">id</strong> argument and track the data using the <strong class="source-inline">Callable</strong> instance passed in the <strong class="source-inline">callable</strong> argument. This means that every time we trigger an event that should count for the data tracking, we need to execute the <span class="No-Break"><strong class="source-inline">callable</strong></span><span class="No-Break"> instance.</span></p>
			<p>During the current section, we will use the <strong class="bold">Monitors</strong> tab to track some data regarding the <strong class="source-inline">QuestDatabase</strong> node and the <strong class="source-inline">QuestSingleton</strong> node. By monitoring these data points, we will gain some insights into how our quest system is performing and identify potential areas <span class="No-Break">for improvement.</span></p>
			<p>Let’s start by opening the <strong class="source-inline">res://09.prototyping-spaceadventure/Quests/QuestDatabase.gd</strong> script. We are going to create a member variable to keep track of how many times the <strong class="source-inline">QuestDatabase.update_player_progress()</strong> method was called. We can name this variable <strong class="source-inline">quest_update_count</strong> and set its default value to <strong class="source-inline">0</strong>. Then, we need to create a method that returns its current value; let’s call this <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">get_quest_update_count()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func get_quest_update_count():
     return quest_update_count</pre>			<p>To update <strong class="source-inline">quest_update_count</strong>, let’s increment its value after the server successfully updates the player’s progress in a given quest. So, in the <strong class="source-inline">update_player_progress()</strong> method, add a line inside the <strong class="source-inline">if multiplayer.is_server()</strong> statement incrementing <strong class="source-inline">quest_update_count</strong> by <span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break"> :</span></p>
			<pre class="source-code">
@rpc("any_peer", "call_remote")
func update_player_progress(quest_id, current_amount, completed, user):
     if multiplayer.is_server():
          progress_database[user][quest_id]["progress"] = current_amount
          progress_database[user][quest_id]["completed"] = completed
          quest_update_count += 1</pre>			<p>With that, we have<a id="_idIndexMarker390"/> everything ready to add <strong class="source-inline">get_quest_update_count()</strong> to our <strong class="bold">Monitors</strong> tab. For that, in the <strong class="source-inline">_ready()</strong> callback, create a <strong class="source-inline">Callable</strong> variable pointing to <strong class="source-inline">QuestDatabase</strong> using the <strong class="source-inline">self</strong> keyword, and pointing to <strong class="source-inline">"get_quest_update_count"</strong>. We can name this <strong class="source-inline">Callable</strong> variable <strong class="source-inline">callable</strong> to simplify <span class="No-Break">the process:</span></p>
			<pre class="source-code">
func _ready():
     if multiplayer.is_server():
          load_database()
          var callable = Callable(self, "get_quest_update_count")</pre>			<p>Then, let’s call the <strong class="source-inline">Performance.add_custom_monitor()</strong> method. To keep things organized, we will use a category named <strong class="source-inline">"Network"</strong> for our custom monitors. So, in the <strong class="source-inline">id</strong> argument, we will pass <strong class="source-inline">"Network/Quests Updates"</strong> and pass <strong class="source-inline">callable</strong> as the <span class="No-Break">second argument:</span></p>
			<pre class="source-code">
func _ready():
     if multiplayer.is_server():
          load_database()
         var callable = Callable(self, "get_quest_update_count")
          Performance.add_custom_monitor("Network/Quests Updates", callable)</pre>			<p>Let’s start by opening the <strong class="source-inline">res://09.prototyping-space- adventure/Quests/QuestDatabase.gd</strong> script. We are going to create a member variable to keep track of how many times the method <span class="No-Break">was called.</span></p>
			<p>Now, to test whether this custom monitor is working and assess the data it will provide, let’s test the game using<a id="_idIndexMarker391"/> three debugging sessions and use one of the clients to destroy some <em class="italic">Asteroids</em>. This time around, my server is on <strong class="bold">Session 2</strong>. The following figure showcases <strong class="bold">Session 2</strong>’s <strong class="bold">Monitors</strong> tab. You can find the <strong class="bold">Quests Updates</strong> monitor at the very bottom of the <strong class="bold">Monitor</strong> panel; tick the checkbox and Godot will display the <span class="No-Break">tracked data.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer126">
					<img alt="Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests Updates tracked data" src="image/Figure_10.15_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests Updates tracked data</p>
			<p>Notice that Godot counted only 58 quest updates. So I may have missed one asteroid. Interesting, right? Why does one <em class="italic">Asteroid</em> trigger two calls to the <strong class="source-inline">QuestDatabase.update_player_progress()</strong> method? Well, remember that currently the quest progress is shared among all peers, so this can grow exponentially. If there were 3 players, there would be 96 calls to <strong class="source-inline">QuestDatabase.update_player_progress()</strong>. We need to figure out a way to limit that. One quick solution is to check whether the quest is already completed, and if it is, stop updating it. This would limit this particular quest to 10 calls per player, which would be a <span class="No-Break">good improvement.</span></p>
			<p>Let’s make this comparison, just for testing purposes. Open <strong class="source-inline">res://09.prototyping-space-adventure/Quests/QuestSingleton.gd</strong> and let’s create a monitor that would only increment until the quest reaches the target amount required to complete the quest. To do that, let’s create a new member variable called <strong class="source-inline">increase_count</strong> and set its value to <strong class="source-inline">0</strong> <span class="No-Break">by default:</span></p>
			<pre class="source-code">
var increase_count = 0</pre>			<p>Then, let’s create a method called <strong class="source-inline">get_quest_increases()</strong> that will return <span class="No-Break">this variable:</span></p>
			<pre class="source-code">
func get_quest_increases():
  return increase_count</pre>			<p>In the <strong class="source-inline">_ready()</strong> callback, if<a id="_idIndexMarker392"/> this is a client instance, we will add a new custom monitor using the previous method as <strong class="source-inline">callable</strong>, just like we did <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">QuestDatabase.get_quest_update_count()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _ready():
  if not multiplayer.is_server():
    var callable = Callable(self, "get_quest_increases")
    Performance.add_custom_monitor("Network/Quest Increases", callable)</pre>			<p>Now, inside the <strong class="source-inline">increase_quest_progress()</strong> method, we will create an <strong class="source-inline">if</strong> statement that will only increment <strong class="source-inline">increase_count</strong> while <strong class="source-inline">quest.current_amount</strong> is less <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">quest.target_amount</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func increase_quest_progress(quest_id, amount):
  if not quest_id in quests.keys():
    return
  var quest = quests[quest_id]
  quest.current_amount += amount
  QuestDatabase.rpc_id(1, "update_player_progress", quest_id, quest.current_am
ount, quest.completed, AuthenticationCredentials.user)
  if quest.current_amount &lt; quest.target_amount:
increase_count += 1</pre>			<p>Let’s test the game again and see what happens in the clients’ <strong class="bold">Monitors</strong> tab. In the following figure, there’s something very <span class="No-Break">interesting happening.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer127">
					<img alt="Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests Increases tracked data" src="image/Figure_10.16_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests Increases tracked data</p>
			<p>This time around, <strong class="bold">Session 2</strong> corresponds<a id="_idIndexMarker393"/> to a player – particularly, the player logged in using the <strong class="source-inline">user2</strong> credentials. Why this is relevant? Notice that there were only four increments to <strong class="source-inline">increase_count</strong> in this game instance. This is due to the fact that, in the <strong class="source-inline">res://09.prototypingspace-adventure/Quests/QuestDatabase.json</strong> file, <strong class="source-inline">user2</strong> already destroyed five asteroids, so it only needed five more to complete the quest. This means that we can improve this aspect of our game even between play sessions. The more progress a player makes in a game session, the fewer RPCs we will need to make to the server if we implement this approach; pretty cool, <span class="No-Break">isn’t it?</span></p>
			<p>Throughout this <a id="_idIndexMarker394"/>section, we learned how we can use the <strong class="source-inline">Performance</strong> singleton to create new monitors in the <strong class="bold">Monitors</strong> tab using the <strong class="source-inline">Performance.add_custom_monitor()</strong> method. We also saw how we can create methods to collect data about potential bottlenecks in our game. Finally, we saw some potential fixes to the issues we found while debugging the game in order to <span class="No-Break">optimize it.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor275"/>Summary</h1>
			<p>With that, we conclude our chapter! Throughout this chapter, we introduced the <strong class="bold">Debugger</strong> dock, which is a powerful tool for assessing and debugging potential problems in our game, as well as for optimizing <span class="No-Break">its performance.</span></p>
			<p>We explored the <strong class="bold">Stack Trace</strong> tab, which gives us an overview of our game’s flow and provides us with multiple ways to gather information about the changes that happen throughout this flow, allowing us to understand the whole chain of cause and effect that led to a given change. We also talked about the <strong class="bold">Errors</strong> tab, which is where we work together with thousands of other developers who worked on the development of Godot Engine’s core and identified thousands of errors and documented them so that when they happen, we have some light on the issue and can <span class="No-Break">fix it.</span></p>
			<p>On top of that, we explored two powerful performance-based debugging tabs: the <strong class="bold">Profiler</strong> tab and the <strong class="bold">Visual Profiler</strong> tab. The <strong class="bold">Profiler</strong> tab is one of your best allies in this task, as it allows you to see rendering time, physics simulation time, audio processing time, and even how much time each of your custom script functions is taking to process and how many times they were called. The <strong class="bold">Visual Profiler</strong> tab specializes in tracking and measuring rendering-related tasks and can help you keep track of what is causing the most delay in rendering a frame on the CPU <span class="No-Break">and GPU.</span></p>
			<p>However, the protagonists of the chapter were the <strong class="bold">Network Profiler</strong> and <strong class="bold">Monitors</strong> tabs. We saw how we can identify potential bottlenecks related to RPCs and <strong class="source-inline">MultiplayerSynchronizer</strong> nodes by analyzing data gathered by the tool. By understanding and analyzing this data, we came up with possible solutions to optimize network code. In addition to that, we learned how to use the <strong class="source-inline">Performance</strong> singleton and create custom monitors to track specific data points in real time in the <strong class="bold">Monitors</strong> tab. By monitoring these data points, we gained insights into how our project is performing and even made a test for a <span class="No-Break">potential improvement.</span></p>
			<p>In the next chapter, we are going to optimize data requests, especially regarding the quests data from the <span class="No-Break"><strong class="source-inline">QuestDatabase.get_player_quests()</strong></span><span class="No-Break"> method.</span></p>
			<p>By optimizing the way we request and handle data, we can improve our game’s performance and provide a better experience for our users. See <span class="No-Break">you there!</span></p>
		</div>
	</body></html>