- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Using the File System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件系统
- en: In the early days, arcade games would never store the progress of players. Every
    time you put in a quarter, the game would start from zero, unless there was a
    system that would let you buy more lives within the same run. But in general,
    you could not return the day after and start playing where you left off the day
    before.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，街机游戏永远不会存储玩家的进度。每次你投入一个25美分的硬币，游戏就会从零开始，除非有一个系统允许你在同一轮游戏中购买更多生命。但总的来说，你无法在第二天回来并从前一天停止的地方继续游戏。
- en: Even early console games had limited functionality in terms of saving your progress.
    Some games would have a code system with which you got a secret code from the
    moment you had beaten a level. Later, you could use this code to start directly
    from there. But these games still didn’t really save your progress.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使早期的家用游戏机在保存进度方面功能有限。有些游戏会有一个代码系统，你可以从击败一个关卡的那一刻起获得一个秘密代码。后来，你可以使用这个代码直接从那里开始。但这些游戏仍然没有真正保存你的进度。
- en: This restriction was partly because storage space, like hard drives or flash
    memory, was very expensive. Nowadays, almost every computer and console comes
    standard with a few hundred gigabytes, if not terabytes, of storage. Saving data
    has become very cheap and easy and players have come to expect that some kind
    of progress is tracked between play sessions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制部分是因为存储空间，比如硬盘或闪存，非常昂贵。如今，几乎每台电脑和游戏机都标配了几百吉字节，甚至太字节，的存储空间。保存数据变得非常便宜且容易，玩家们已经习惯了在游戏会话之间跟踪某种进度。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What is the file system?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统是什么？
- en: Creating a save system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个保存系统
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with every chapter, you can find the final code in the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter15](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter15)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以在GitHub仓库的子文件夹中找到本章的最终代码：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter15](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter15)
- en: What is the file system?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统是什么？
- en: A file system is a system that manages files, their contents, as well as the
    metadata of these files. For example, a file system would manage in what folders
    the files are stored. It makes sure that we can access these files to read the
    content and metadata and write new data back. For Godot, this means that Godot
    Engine manages all resources that we could need in our game, from scenes to scripts,
    as well as images and sounds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是一个管理系统，它管理文件、文件内容以及这些文件的元数据。例如，文件系统会管理文件存储在哪些文件夹中。它确保我们可以访问这些文件来读取内容、元数据，并将新数据写回。对于Godot来说，这意味着Godot引擎管理我们在游戏中可能需要的所有资源，从场景到脚本，以及图像和声音。
- en: Metadata
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据
- en: When we have data, such as a text file, it is often accompanied by metadata.
    This is data about the data. While the text file contains the actual data, that
    is, the text, the metadata contains information such as the date of creation,
    who the author was, where it is stored, and what accounts have access to the file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有数据，比如一个文本文件时，它通常伴随着元数据。这是关于数据的数据。虽然文本文件包含实际数据，即文本，但元数据包含诸如创建日期、作者是谁、存储位置以及哪些账户可以访问文件等信息。
- en: Let’s start our exploration of file systems with file paths in the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中从文件路径开始探索文件系统。
- en: File paths
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件路径
- en: 'To be able to locate a file, the file system gives a unique path to each file.
    On our computer, we can find files through folders, also called directories, where
    we store them in a nice order. This path could look like this on a Windows-based
    system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够定位一个文件，文件系统为每个文件提供一个唯一的路径。在我们的电脑上，我们可以通过文件夹，也称为目录，找到文件，我们将它们以良好的顺序存储。在基于Windows的系统上，这个路径可能看起来像这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or it could look like this on macOS and Linux-based systems:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在macOS和基于Linux的系统上，它可能看起来像这样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For resource and other project-related files, Godot Engine’s paths work relative
    to the position where the project’s `project.godot` file is located. This file’s
    path is considered as the root directory. The paths within the Godot file system
    to access resource files always start with `res://`. To access one of the files
    within the project, for example, a path could look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于资源和项目相关的其他文件，Godot引擎的路径相对于项目`project.godot`文件的位置是相对的。该文件的路径被视为根目录。在Godot文件系统中访问资源文件的路径始终以`res://`开头。例如，要访问项目中的一个文件，路径可能看起来像这样：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For convenience and compatibility, the Godot file system always uses forward
    slashes (`/`). Even on Windows-based systems, where the backward slash (`\`) is
    normally used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和兼容性，Godot文件系统始终使用正斜杠(`/`)。即使在通常使用反斜杠(`\`)的基于Windows的系统上也是如此。
- en: We actually already used one of these paths when we preloaded the projectiles
    in [*Chapter 10*](B19358_10.xhtml#_idTextAnchor632).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在[*第10章*](B19358_10.xhtml#_idTextAnchor632)中预加载弹头时已经使用过这些路径之一。
- en: User path
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户路径
- en: The fact that we can easily access all project files using the `res://` path
    is very convenient, but there is a problem. We cannot write to any file in the
    `res://` domain; when the game is running from an exported build, we can only
    read files from it. To help developers out with this problem, Godot Engine provides
    another root path, `user://`, which files can be written to and then read from.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用`res://`路径访问所有项目文件，这非常方便，但存在一个问题。我们无法向`res://`域中的任何文件写入；当游戏从导出的构建中运行时，我们只能从中读取文件。为了帮助开发者解决这个问题，Godot引擎提供了另一个根路径，`user://`，文件可以写入并从中读取。
- en: 'Godot Engine automatically makes a folder somewhere on the computer to store
    this user data. The location of this folder is dependent on the system the game
    is running on, so it will be at a different for each OS:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Godot引擎会在计算机上的某个位置自动创建一个文件夹来存储这些用户数据。这个文件夹的位置取决于游戏运行的系统，因此对于每个操作系统都会不同：
- en: 'Windows: `%``APPDATA%\Godot\app_userdata\<project name>`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `%APPDATA%\Godot\app_userdata\<项目名称>`'
- en: 'macOS: `~/Library/Application Support/Godot/app_userdata/ <``project name>`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `~/Library/Application Support/Godot/app_userdata/<``项目名称>`'
- en: 'Linux: `~/.local/share/godot/app_userdata/ <``project name>`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `~/.local/share/godot/app_userdata/<``项目名称>`'
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the project settings, we can even specify where to locate this folder for
    each of the three OSs, but that is not needed for now, as Godot handles this for
    us and hides the folders away somewhere safe.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置中，我们甚至可以指定在每个三个操作系统中的文件夹位置，但现在不需要这样做，因为Godot会为我们处理并隐藏到某个安全的地方。
- en: You can access the `user://` folder for a given project by opening up the **Project**
    menu and choosing **Open User** **Data Folder**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开**项目**菜单并选择**打开用户** **数据文件夹**来访问给定项目的`user://`文件夹。
- en: '![Figure 15.1 - Open User Data Folder takes us to the user:// folder](img/B19358_15_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 - 打开用户数据文件夹将我们带到user://文件夹](img/B19358_15_1.jpg)'
- en: Figure 15.1 - Open User Data Folder takes us to the user:// folder
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - 打开用户数据文件夹将我们带到user://文件夹
- en: The `user://` path is what we are going to use to write our save data to in
    the next section of this chapter. So, let’s get to the actual implementation of
    our own little save system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章下一节中将使用`user://`路径来将保存数据写入。所以，让我们来实际实现我们自己的小保存系统。
- en: Creating a save system
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个保存系统
- en: In theory, all we need to do is open a file, write the data we want to save
    to it, and then, later on, read that same file whenever we need the data. As it
    turns out, in the Godot Engine, it is indeed easy to read and write files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们只需要打开一个文件，将我们想要保存的数据写入其中，然后，稍后，当我们需要数据时，再读取相同的文件。实际上，在Godot引擎中，读取和写入文件确实很容易。
- en: We’re first going to see how to write to an external file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将看到如何写入外部文件。
- en: Writing data to the disk
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据写入磁盘
- en: 'Let’s get to it by creating a new script called `save_manager.gd` under the
    `autoloads` folder. Then, to save data, put this code in the script:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`autoloads`文件夹下创建一个名为`save_manager.gd`的新脚本来实现这一点。然后，为了保存数据，将此代码放入脚本中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'func read_save_data():'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'func read_save_data():'
- en: 'var save_file: FileAccess = FileAccess.open(SAVE_FILE_PATH, FileAccess.READ)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'var save_file: FileAccess = FileAccess.open(SAVE_FILE_PATH, FileAccess.READ)'
- en: 'if save_file == null:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'if save_file == null:'
- en: print("Could not open save file.")
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: print("无法打开保存文件。")
- en: return
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: 'var file_content: String = save_file.get_as_text()'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'var file_content: String = save_file.get_as_text()'
- en: save_data = read_save_data function loads the saved file and parses the content
    so that we can use it in the game. Firstly,  we open the saved file with FileAccess.open,
    providing the file’s path and FileAccess.READ to indicate that we only want to
    read it. After this, we check to make sure the file is opened properly, else we
    need to exit the function again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_data = read_save_data`函数加载保存的文件并解析内容，以便我们可以在游戏中使用。首先，我们使用`FileAccess.open`打开保存的文件，提供文件的路径和`FileAccess.READ`以指示我们只想读取它。之后，我们检查文件是否已正确打开，否则我们需要再次退出函数。'
- en: Next, we read out the complete file as a string into a variable called `file_content`.
    We’ll have to parse this string from the JSON format it was saved in, to the format
    that GDScript can handle, a dictionary. The parsed value is directly stored in
    the `save_data` variable that we defined in the previous section.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将整个文件作为字符串读入一个名为`file_content`的变量中。我们将不得不将这个字符串从保存时的JSON格式解析为GDScript可以处理的格式，即字典。解析后的值直接存储在我们之前定义的`save_data`变量中。
- en: More information
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'For more on saving and loading data in Godot Engine, check out the official
    documentation: [https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html](https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html).'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于在Godot引擎中保存和加载数据的更多信息，请参阅官方文档：[https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html](https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html)。
- en: This is great, we have two functions that are able to write and read the saved
    data for our little game. Now we still need to add some functions to make sure
    the script is usable by the game.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这太棒了，我们有两个函数可以为我们的小游戏写入和读取保存的数据。现在我们还需要添加一些函数来确保脚本可以被游戏使用。
- en: Preparing the save manager for use in the game
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为游戏使用保存管理器做准备
- en: 'The save manager is almost ready, but we still need to add these two functions:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存管理器几乎准备好了，但我们仍然需要添加这两个函数：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first function, the `_ready()` function, makes sure that we load the saved
    data from the moment the player starts up the game.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数，即`_ready()`函数，确保我们从玩家启动游戏的那一刻起加载保存的数据。
- en: The second function adds a convenient way of storing a new high score. It adds
    the new high score to the `save_data` dictionary and then writes the data to disk.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个函数提供了一个方便的方式来存储新的高分。它将新的高分添加到`save_data`字典中，然后将数据写入磁盘。
- en: Now, to make sure we can access the save manager from anywhere, add this script
    to the project’s autoloads. What we want is for our save manager to be the first
    autoload that gets executed, which will make sure that the saved data gets loaded
    before any other part of the game executes. To do this, make sure the `save_manager.gd`
    script is at the top of the list of autoloads. You can do this by dragging and
    dropping the entry of **SaveManager** or by clicking the arrows on the right until
    it is at the top.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，为了确保我们可以从任何地方访问保存管理器，将此脚本添加到项目的自动加载中。我们希望我们的保存管理器是第一个执行的自动加载，这将确保在游戏的任何其他部分执行之前，保存的数据被加载。为此，请确保`save_manager.gd`脚本位于自动加载列表的顶部。您可以通过拖放**SaveManager**的条目或通过点击右侧的箭头直到它位于顶部来实现这一点。
- en: '![Figure 15.2 - Make sure SaveManager is the first autoload in the list](img/B19358_15_2.jpg)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图15.2 - 确保SaveManager是列表中的第一个自动加载](img/B19358_15_2.jpg)'
- en: Figure 15.2 - Make sure SaveManager is the first autoload in the list
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.2 - 确保SaveManager是列表中的第一个自动加载
- en: With this script finished and in place as an autoload, we can finally hook up
    the game to use it. Let’s do that in the next section.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成并放置此脚本作为自动加载后，我们终于可以将游戏连接到使用它。让我们在下一节中这样做。
- en: Adjusting the game to use the save manager
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调整游戏以使用保存管理器
- en: 'Now, all we need to do is to get the high score from `highscore_manager.gd`
    script and save the high score every time the player attains a new one. Add the
    following `_ready` function to the `highscore_manager``.gd` script and add the
    `SaveManager.save_highscore()` function call:'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们只需要从`highscore_manager.gd`脚本中获取高分，并在玩家获得新高分时保存高分。将以下`_ready`函数添加到`highscore_manager.gd`脚本中，并添加`SaveManager.save_highscore()`函数调用：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With these in place, we can finally play the game a bit, get a high score, close
    the game, and, when we reopen it, see our previous high score come up.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些准备工作就绪后，我们最终可以玩一会儿游戏，得到一个高分，关闭游戏，当我们再次打开它时，看到我们之前的高分出现。
- en: '![Figure 15.3 - The high score gets loaded when we open the game](img/B19358_15_3.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图15.3 - 打开游戏时加载高分](img/B19358_15_3.jpg)'
- en: Figure 15.3 - The high score gets loaded when we open the game
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.3 - 打开游戏时加载高分
- en: Now our game is really ready for users to strive over beating their high score
    over multiple days without having to keep track of it themselves. In the next
    section, we’ll take a glance at the actual content of the save file itself.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们的游戏已经真正准备好让用户在多天内努力打破自己的高分记录，而无需自己跟踪它。在下一节中，我们将简要查看保存文件的实际内容。
- en: Having a look at the save file
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看保存文件
- en: For now, we have treated the save file as a black box, without knowing its actual
    contents. We save data to it, in JSON format, and read it back in, parsing it
    back to data that is usable by GDScript.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们将保存文件视为一个黑盒，不知道其实际内容。我们以JSON格式将其保存到其中，然后读取它，将其解析回GDScript可用的数据。
- en: Black box
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 黑盒
- en: We say we interact with a black box when we don’t have an idea of how the thing
    itself actually works. We provide the system with input and it spits out some
    output.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们不知道事物本身是如何工作时，我们说我们在与黑盒交互。我们向系统提供输入，它就会输出一些输出。
- en: Of course, we can also take a look at the contents of the save file with a text
    editor, such as Notepad on Windows. Just open the `user://` folder, as we did
    in the *User path* section, earlier in this chapter. From here, open up the `save_data.save`
    file that we created in the save manager.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用文本编辑器，如Windows上的记事本，查看保存文件的内容。只需打开我们在本章早些时候在*用户路径*部分中提到的`user://`文件夹。从这里，打开我们在保存管理器中创建的`save_data.save`文件。
- en: 'You’ll see that the data within this file is very easily readable, and looks
    a lot like the actual dictionary that we defined in the `save_manager.gd` script.
    This is because JSON also has a notion of the dictionary data structure and the
    syntax is very similar to that of dictionaries in GDScript. The file looks like
    this:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会发现这个文件中的数据非常易于阅读，看起来很像我们在`save_manager.gd`脚本中定义的实际字典。这是因为JSON也有字典数据结构的概念，其语法与GDScript中的字典语法非常相似。文件看起来是这样的：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you want, you can change the save data from here and cheat, by filling in
    an impossibly high score. Unfortunately, users will also be able to do this if
    they know where to look for the save file.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以从这里更改保存数据并作弊，通过填写一个不可能的高分。不幸的是，如果用户知道在哪里查找保存文件，他们也会这样做。
- en: More information
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'There are ways to encrypt save files, but these are out of the scope of this
    book. See the  official documentation for more: [https://docs.godotengine.org/en/stable/classes/class_fileaccess.html#class-fileaccess-method-open-encrypted](https://docs.godotengine.org/en/stable/classes/class_fileaccess.html#class-fileaccess-method-open-encrypted).'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有加密保存文件的方法，但这些超出了本书的范围。更多信息请参阅官方文档：[https://docs.godotengine.org/en/stable/classes/class_fileaccess.html#class-fileaccess-method-open-encrypted](https://docs.godotengine.org/en/stable/classes/class_fileaccess.html#class-fileaccess-method-open-encrypted)。
- en: Awesome, with our game saving the player’s high score, we have come to the end
    of this chapter. There are still many tricks to be learned about loading and saving
    the game state, but for now, this will surely do.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太棒了，随着我们的游戏保存玩家的最高分，我们已经到达了这一章的结尾。关于加载和保存游戏状态，还有很多技巧要学习，但到目前为止，这已经足够了。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all about the file system of Godot and computers
    in general. It allowed us to write a little save system that keeps the high score
    of our game and loads it every time we start up the game.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于Godot和计算机的文件系统的一切。它使我们能够编写一个小型保存系统，保持我们游戏的高分，并在每次启动游戏时加载它。
- en: This was the last chapter for this part of the book. Over the course of the
    last five chapters, we took a deeper dive into programming concepts, patterns,
    and the file system.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这本书的这一部分已经结束了。在过去的五章中，我们深入探讨了编程概念、模式和文件系统。
- en: You are all ready to go and develop some games of your own. But before you do
    so, I want to give you some last pointers and steps on what to do next in the
    last chapter of this book. See you there.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你们都已经准备好去开发自己的游戏了。但在你这样做之前，我想给你一些最后的提示和步骤，告诉你在这本书的最后一章中接下来要做什么。我们那里见。
- en: Quiz time
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测验时间
- en: What is the difference between the `res://` and `user://` file paths within
    Godot Engine?
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Godot引擎中，`res://`和`user://`文件路径之间有什么区别？
- en: To save data, we used the JSON format. Is JSON a format unique to Godot Engine?
    In what other domain is the JSON format widely used?
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保存数据，我们使用了JSON格式。JSON格式是Godot引擎独有的格式吗？在哪些其他领域广泛使用JSON格式？
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
