["```cpp\n    $ vi  example.c\n    int main(int argc, char **argv) {\n      int i, j, k, t = 0;\n      for(i = 0; i < 10; i++) {\n        for(j = 0; j < 10; j++) {\n          for(k = 0; k < 10; k++) {\n            t++;\n          }\n        }\n        for(j = 0; j < 10; j++) {\n          t++;\n        }\n      }\n      for(i = 0; i < 20; i++) {\n        for(j = 0; j < 20; j++) {\n          t++;\n        }\n        for(j = 0; j < 20; j++) {\n          t++;\n        }\n      }\n      return t;\n    }\n    ```", "```cpp\n    $ clang –S –O0 –emit-llvm example.c\n\n    ```", "```cpp\n    $ opt –O0 –S example.ll\n\n    ```", "```cpp\n    $ opt –O1 –S example.ll\n    $ opt –O2 –S example.ll\n    $ opt –O3 –S example.ll\n\n    ```", "```cpp\n    $ vi Makefile\n\n    ```", "```cpp\n    LEVEL = ../../..\n    LIBRARYNAME = FuncBlockCount\n    LOADABLE_MODULE = 1\n    include $(LEVEL)/Makefile.common\n    ```", "```cpp\n    $ vi FuncBlockCount.cpp\n\n    ```", "```cpp\n    #include \"llvm/Pass.h\"\n    #include \"llvm/IR/Function.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    ```", "```cpp\n    using namespace llvm;\n    ```", "```cpp\n    namespace {\n    ```", "```cpp\n    struct FuncBlockCount : public FunctionPass {\n    ```", "```cpp\n    static char ID;\n    FuncBlockCount() : FunctionPass(ID) {}\n    ```", "```cpp\n    bool runOnFunction(Function &F) override {\n          errs() << \"Function \" << F.getName() << '\\n';\n          return false;\n        }\n      };\n    }\n    ```", "```cpp\n    char FuncBlockCount::ID = 0;\n    ```", "```cpp\n    static RegisterPass<FuncBlockCount> X(\"funcblockcount\", \"Function Block Count\", false, false);\n    ```", "```cpp\n    #include \"llvm/Pass.h\"\n    #include \"llvm/IR/Function.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    using namespace llvm;\n    namespace {\n    struct FuncBlockCount : public FunctionPass {\n      static char ID;\n      FuncBlockCount() : FunctionPass(ID) {}\n      bool runOnFunction(Function &F) override {\n        errs() << \"Function \" << F.getName() << '\\n';\n        return false;\n      }\n               };\n            }\n           char FuncBlockCount::ID = 0;\n           static RegisterPass<FuncBlockCount> X(\"funcblockcount\", \"Function Block Count\", false, false);\n    ```", "```cpp\n    $ vi sample.c\n\n    int foo(int n, int m) {\n      int sum = 0;\n      int c0;\n      for (c0 = n; c0 > 0; c0--) {\n        int c1 = m;\n        for (; c1 > 0; c1--) {\n          sum += c0 > c1 ? 1 : 0;\n        }\n      }\n      return sum;\n    }\n    ```", "```cpp\n    $ clang –O0 –S –emit-llvm sample.c –o sample.ll\n\n    ```", "```cpp\n    $ opt  -load (path_to_.so_file)/FuncBlockCount.so  -funcblockcount sample.ll\n    ```", "```cpp\n    Function foo\n\n    ```", "```cpp\n     LoopInfo *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n    ```", "```cpp\n    unsigned num_Blocks = 0;\n      Loop::block_iterator bb;\n      for(bb = L->block_begin(); bb != L->block_end();++bb)\n        num_Blocks++;\n      errs() << \"Loop level \" << nest << \" has \" << num_Blocks\n    << \" blocks\\n\";\n    ```", "```cpp\n    void countBlocksInLoop(Loop *L, unsigned nest) {\n      unsigned num_Blocks = 0;\n      Loop::block_iterator bb;\n      for(bb = L->block_begin(); bb != L->block_end();++bb)\n        num_Blocks++;\n      errs() << \"Loop level \" << nest << \" has \" << num_Blocks\n    << \" blocks\\n\";\n      std::vector<Loop*> subLoops = L->getSubLoops();\n      Loop::iterator j, f;\n      for (j = subLoops.begin(), f = subLoops.end(); j != f;\n    ++j)\n        countBlocksInLoop(*j, nest + 1);\n    }\n\n    virtual bool runOnFunction(Function &F) {\n      LoopInfo *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n      errs() << \"Function \" << F.getName() + \"\\n\";\n      for (Loop *L : *LI)\n        countBlocksInLoop(L, 0);\n      return false;\n    }\n    ```", "```cpp\n    int main(int argc, char **argv) {\n      int i, j, k, t = 0;\n      for(i = 0; i < 10; i++) {\n        for(j = 0; j < 10; j++) {\n          for(k = 0; k < 10; k++) {\n            t++;\n          }\n        }\n        for(j = 0; j < 10; j++) {\n          t++;\n        }\n      }\n      for(i = 0; i < 20; i++) {\n        for(j = 0; j < 20; j++) {\n          t++;\n        }\n        for(j = 0; j < 20; j++) {\n          t++;\n        }\n      }\n      return t;\n    }\n    ```", "```cpp\n    $ clang –O0 –S –emit-llvm sample.c –o sample.ll\n\n    ```", "```cpp\n    $ opt  -load (path_to_.so_file)/FuncBlockCount.so  -funcblockcount sample.ll\n\n    ```", "```cpp\n    Function main\n    Loop level 0 has 11 blocks\n    Loop level 1 has 3 blocks\n    Loop level 1 has 3 blocks\n    Loop level 0 has 15 blocks\n    Loop level 1 has 7 blocks\n    Loop level 2 has 3 blocks\n    Loop level 1 has 3 blocks\n\n    ```", "```cpp\n$ opt  -load (path_to_.so_file)/FuncBlockCount.so  -funcblockcount sample.ll –disable-output –debug-pass=Structure\n\n```", "```cpp\n    #define DEBUG_TYPE \"func-block-count\"\n    ```", "```cpp\n    void getAnalysisUsage(AnalysisUsage &AU) const override {\n        AU.addRequired<LoopInfoWrapperPass>();\n      }\n    ```", "```cpp\n    INITIALIZE_PASS_BEGIN(FuncBlockCount, \" funcblockcount \",\n                         \"Function Block Count\", false, false)\n    INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)\n\n    INITIALIZE_PASS_END(FuncBlockCount, \"funcblockcount\",\n                       \"Function Block Count\", false, false)\n\n    Pass *llvm::createFuncBlockCountPass() { return new FuncBlockCount(); }\n    ```", "```cpp\n    (void) llvm:: createFuncBlockCountPass ();\n\n    ```", "```cpp\n    Pass * createFuncBlockCountPass ();\n\n    ```", "```cpp\n    FuncBlockCount() : FunctionPass(ID) {initializeFuncBlockCount Pass (*PassRegistry::getPassRegistry());}\n    ```", "```cpp\n    initializeFuncBlockCountPass (Registry);\n    ```", "```cpp\n    void initializeFuncBlockCountPass (Registry);\n    ```", "```cpp\n    FuncBlockCount.cpp\n    ```", "```cpp\n$ opt –funcblockcount sample.ll\n\n```", "```cpp\n$ cat testcode.c\nint func(int a, int b){\n  int sum = 0;\n  int iter;\n  for (iter = 0; iter < a; iter++) {\n    int iter1;\n    for (iter1 = 0; iter1 < b; iter1++) {\n      sum += iter > iter1 ? 1 : 0;\n    }\n  }\n  return sum;\n}\n```", "```cpp\n$ clang -c -emit-llvm testcode.c -o testcode.bc\n\n```", "```cpp\n    #define DEBUG_TYPE \"opcodeCounter\"\n    #include \"llvm/Pass.h\"\n    #include \"llvm/IR/Function.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    #include <map>\n    using namespace llvm;\n    ```", "```cpp\n    namespace {\n    struct CountOpcode: public FunctionPass {\n    ```", "```cpp\n    std::map< std::string, int> opcodeCounter;\n    static char ID;\n    CountOpcode () : FunctionPass(ID) {}\n    ```", "```cpp\n    virtual bool runOnFunction (Function &F) {\n     llvm::outs() << \"Function \" << F.getName () << '\\n';\n    for ( Function::iterator bb = F.begin(), e = F.end(); bb != e; ++bb) {\n      for ( BasicBlock::iterator i = bb->begin(), e = bb->end(); i!= e; ++i) {\n        if(opcodeCounter.find(i->getOpcodeName()) == opcodeCounter.end()) {\n        opcodeCounter[i->getOpcodeName()] = 1;\n        } else {\n        opcodeCounter[i->getOpcodeName()] += 1;\n        }\n      }\n    }\n\n    std::map< std::string, int>::iterator i = opcodeCounter.begin();\n    std::map< std::string, int>::iterator e = opcodeCounter.end();\n    while (i != e) {\n      llvm::outs()  << i->first << \": \" << i->second << \"\\n\";\n      i++;\n    }\n    llvm::outs()  << \"\\n\";\n    opcodeCounter.clear();\n    return false;\n    }\n    };\n    }\n    ```", "```cpp\n    char CountOpcode::ID = 0;\n    static RegisterPass<CountOpcode> X(\"opcodeCounter\", \"Count number of opcode in a functions\");\n\n    ```", "```cpp\n    $ opt -load path-to-build-folder/lib/LLVMCountopcodes.so -opcodeCounter -disable-output testcode.bc\n    Function func\n    add: 3\n    alloca: 5\n    br: 8\n    icmp: 3\n    load: 10\n    ret: 1\n    select: 1\n    store: 8\n\n    ```", "```cpp\nfor (Function::iterator bb = F.begin(), e = F.end(); bb != e; ++bb) {\nfor (BasicBlock::iterator i = bb->begin(), e = bb->end(); i != e; ++i) {\n```", "```cpp\n    #include \"llvm/Pass.h\"\n    #include \"llvm/Analysis/AliasAnalysis.h\"\n    #include \"llvm/IR/DataLayout.h\"\n    #include \"llvm/IR/LLVMContext.h\"\n    #include \"llvm/IR/Module.h\"\n    using namespace llvm;\n    ```", "```cpp\n    namespace {\n    struct EverythingMustAlias : public ImmutablePass, public AliasAnalysis {\n    ```", "```cpp\n    static char ID;\n    EverythingMustAlias() : ImmutablePass(ID) {}\n    initializeEverythingMustAliasPass(*PassRegistry::getPassRegistry());}\n    ```", "```cpp\n        void *getAdjustedAnalysisPointer(const void *ID) override {\n          if (ID == &AliasAnalysis::ID)\n            return (AliasAnalysis*)this;\n          return this;\n        }\n    ```", "```cpp\n    bool doInitialization(Module &M) override {\n         DL = &M.getDataLayout();\n          return true;\n        }\n    ```", "```cpp\n    void *getAdjustedAnalysisPointer(const void *ID) override {\n          if (ID == &AliasAnalysis::ID)\n            return (AliasAnalysis*)this;\n          return this;\n        }\n    };\n    }\n    ```", "```cpp\n    char EverythingMustAlias::ID = 0;\n    INITIALIZE_AG_PASS(EverythingMustAlias, AliasAnalysis, \"must-aa\",\n    \"Everything Alias (always returns 'must' alias)\", true, true, true)\n\n    ImmutablePass *llvm::createEverythingMustAliasPass() { return new EverythingMustAlias(); }\n    ```", "```cpp\n    $ opt  -must-aa -aa-eval -disable-output testcode.bc\n    ===== Alias Analysis Evaluator Report =====\n     10 Total Alias Queries Performed\n     0 no alias responses (0.0%)\n     0 may alias responses (0.0%)\n     0 partial alias responses (0.0%)\n     10 must alias responses (100.0%)\n     Alias Analysis Evaluator Pointer Alias Summary: 0%/0%/0%/100%\n     Alias Analysis Mod/Ref Evaluator Summary: no mod/ref!\n\n    ```", "```cpp\n$ cat testcode1.c\nvoid func() {\nint i;\nchar C[2];\nchar A[10];\nfor(i = 0; i != 10; ++i) {\n  ((short*)C)[0] = A[i];\n  C[1] = A[9-i];\n}\n}\n```", "```cpp\n$ clang -c -emit-llvm testcode1.c -o testcode1.bc\n\n```", "```cpp\n    $ opt -aa-eval -disable-output testcode1.bc\n    ===== Alias Analysis Evaluator Report =====\n    36 Total Alias Queries Performed\n    0 no alias responses (0.0%)\n    36 may alias responses (100.0%) \n    0 partial alias responses (0.0%)\n    0 must alias responses (0.0%)\n    Alias Analysis Evaluator Pointer Alias Summary: 0%/100%/0%/0%\n    Alias Analysis Mod/Ref Evaluator Summary: no mod/ref!\n\n    ```", "```cpp\n    $ opt  -print-dom-info -disable-output testcode1.bc\n    =============================--------------------------------\n    Inorder Dominator Tree:\n     [1] %0 {0,9}\n     [2] %1 {1,8}\n     [3] %4 {2,5}\n     [4] %19 {3,4}\n     [3] %22 {6,7}\n\n    ```", "```cpp\n    $ opt -count-aa -basicaa -licm -disable-output testcode1.bc\n    No alias:    [4B] i32* %i, [1B] i8* %7\n    No alias:    [4B] i32* %i, [2B] i16* %12\n    No alias:    [1B] i8* %7, [2B] i16* %12\n    No alias:    [4B] i32* %i, [1B] i8* %16\n    Partial alias:    [1B] i8* %7, [1B] i8* %16\n    No alias:    [2B] i16* %12, [1B] i8* %16\n    Partial alias:    [1B] i8* %7, [1B] i8* %16\n    No alias:    [4B] i32* %i, [1B] i8* %18\n    No alias:    [1B] i8* %18, [1B] i8* %7\n    No alias:    [1B] i8* %18, [1B] i8* %16\n    Partial alias:    [2B] i16* %12, [1B] i8* %18\n    Partial alias:    [2B] i16* %12, [1B] i8* %18\n\n    ===== Alias Analysis Counter Report =====\n     Analysis counted:\n     12 Total Alias Queries Performed\n     8 no alias responses (66%)\n     0 may alias responses (0%)\n     4 partial alias responses (33%)\n     0 must alias responses (0%)\n     Alias Analysis Counter Summary: 66%/0%/33%/0%\n\n     0 Total Mod/Ref Queries Performed\n\n    ```", "```cpp\n    $ opt  -basicaa -print-alias-sets -disable-output testcode1.bc\n    Alias Set Tracker: 3 alias sets for 5 pointer values.\n     AliasSet[0x336b120, 1] must alias, Mod/Ref   Pointers: (i32* %i, 4)\n     AliasSet[0x336b1c0, 2] may alias, Ref       Pointers: (i8* %7, 1), (i8* %16, 1)\n     AliasSet[0x338b670, 2] may alias, Mod       Pointers: (i16* %12, 2), (i8* %18, 1)\n\n    ```"]