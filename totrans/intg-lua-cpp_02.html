<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-42"><a id="_idTextAnchor042"/>2</h1>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>Lua Fundamentals</h1>
<p>In this chapter, we will learn the basics of the Lua programming language. You do not need to be a Lua expert or even write any Lua code if you only work on the C++ side. However, understanding the basics will make you more efficient when integrating Lua into C++.</p>
<p>If you already know Lua programming, you can skip this chapter. If you have not used Lua for a while, you can use this chapter to recap. If you want to learn more about Lua programming, you can get the official Lua book: <em class="italic">Programming in Lua</em>. If you do not know Lua programming, this chapter is for you. Coming from C++, you can read any Lua code with the brief explanations on Lua code in this book. You can believe in yourself and research online when you need to.</p>
<p>We will talk about the following language features:</p>
<ul>
<li>Variables and types</li>
<li>Control structures</li>
</ul>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Technical requirements</h1>
<p>You will use the interactive Lua interpreter to follow the code examples in this chapter. We have built it from the Lua source code in <em class="italic">Chapter 1</em>. You can also use a Lua interpreter from another channel, for example, the one installed by your operating system’s package manager. Before continuing, make sure you have access to one.</p>
<p>When you see code examples in this chapter, like the following one, you should try the example in an interactive Lua shell:</p>
<pre class="source-code">
Lua 5.4.6  Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; os.exit()
%</pre>
<p>The first line is what the Lua interpreter outputs when it starts. Use <code>os.exit()</code> to quit the interpreter.</p>
<p>You can find the source code for this chapter within the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter02</a></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Variables and types</h1>
<p>While you may<a id="_idIndexMarker046"/> well know that C++ is a statically-typed language, Lua is a dynamically-typed language. In C++, when you declare a variable, you give it a clear type. In Lua, each value carries its own type, and you do not need to explicitly specify a type. Also, you do not need to define a global variable before referencing it. Although you are encouraged to declare it – or better yet, use local variables. We will learn about local variables later in this chapter.</p>
<p>In Lua, there are eight basic types: <strong class="bold">nil</strong>, <strong class="bold">boolean</strong>, <strong class="bold">number</strong>, <strong class="bold">string</strong>, <strong class="bold">userdata</strong>, <strong class="bold">function</strong>, <strong class="bold">thread</strong>, and <strong class="bold">table</strong>.</p>
<p>We will learn about six of these in this chapter: <code>nil</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>table</code>, and <code>function</code>. Let’s try some before we go into the details:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; a
nil
&gt; type(a)
nil
&gt; a = true
&gt; type(a)
boolean
&gt; a = 6
&gt; type(a)
number
&gt; a = "bonjour"
&gt; type(a)
string</pre>
<p>What happens here is as follows:</p>
<ol>
<li>Interactively, type <code>a</code> to check the value of the global variable <code>a</code>. Since it’s not defined yet, its value is <code>nil</code>.</li>
<li>Check the type of variable <code>a</code> with <code>type(a)</code>. The value is <code>nil</code> in this case because it is not defined.</li>
<li>Assign <code>true</code> to <code>a</code>. Use <code>=</code> for assignment; the same as in C++.</li>
<li>Now, its type is <code>boolean</code>.</li>
<li>Assign <code>6</code> to <code>a</code>.</li>
<li>Now, its type is <code>number</code>.</li>
<li>Assign <code>"bonjour"</code> to <code>a</code>.</li>
<li>Now, its type is <code>string</code>.</li>
</ol>
<p>Every line executed<a id="_idIndexMarker047"/> there is also a Lua statement. Unlike a C++ statement, you do not need to put a semicolon at the end of it.</p>
<p>Next, we will learn more about some of the types.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Nil</h2>
<p>The <code>nil</code> type has <a id="_idIndexMarker048"/>only one <a id="_idIndexMarker049"/>value to represent a non-value: <code>nil</code>. Its meaning <a id="_idIndexMarker050"/>is<a id="_idIndexMarker051"/> similar to that of <strong class="bold">nullptr</strong> (or <strong class="bold">NULL</strong>) in C++.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>Booleans</h2>
<p>The <code>boolean</code> type has<a id="_idIndexMarker052"/> two <a id="_idIndexMarker053"/>values. They are <em class="italic">true</em> and <em class="italic">false</em>. It does what <strong class="bold">bool</strong> does in C++.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Numbers</h2>
<p>The <code>number</code> type<a id="_idIndexMarker054"/> covers C++’s <strong class="bold">int</strong>, <strong class="bold">float</strong>, and <strong class="bold">double</strong>, and <a id="_idIndexMarker055"/>their variants (such as <strong class="bold">long</strong>).</p>
<p>Here, we will also learn about Lua arithmetic operators and relational operators, as these are<a id="_idIndexMarker056"/> mostly used on numbers.</p>
<h3>Arithmetic operators</h3>
<p>An arithmetic <a id="_idIndexMarker057"/>operator is an operator that performs <a id="_idIndexMarker058"/>arithmetic operations on numbers. Lua supports <em class="italic">six</em> arithmetic operators:</p>
<ul>
<li><code>+</code>: Addition</li>
<li><code>-</code>: Subtraction</li>
<li><code>*</code>: Multiplication</li>
<li><code>/</code>: Division</li>
<li><code>%</code>: Modulus</li>
<li><code>//</code>: Floor Division</li>
</ul>
<p>C++ has seven arithmetic operators: +, -, *, /, %, ++ and --. Lua’s arithmetic operators are similar to their C++ counterparts, except for the following differences:</p>
<ol>
<li>There is no ++ or -- operator.</li>
<li>C++ does not have the <code>//</code> operator, which returns the integer part of the result after division. C++ can achieve the same implicitly with normal division because C++ is strongly-typed. This we can see in the following example:<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio</pre><pre class="source-code">
&gt; 5 / 3</pre><pre class="source-code">
1.6666666666667</pre><pre class="source-code">
&gt; 5 // 3</pre><pre class="source-code">
1</pre></li>
<li>Note that Lua is a <a id="_idIndexMarker059"/>dynamically-typed language. This <a id="_idIndexMarker060"/>means 5 / 3 does not produce 1 as C++ would do.</li>
</ol>
<h3>Relational operators</h3>
<p>A relational <a id="_idIndexMarker061"/>operator is an operator that tests some kind of <a id="_idIndexMarker062"/>relation between two values. Lua supports <em class="italic">six</em> relational operators:</p>
<ul>
<li><code>&lt;</code>: Less than</li>
<li><code>&gt;</code>: Greater than</li>
<li><code>&lt;=</code>: Less than or equal to</li>
<li><code>&gt;=</code>: Greater than or equal to</li>
<li><code>==</code>: Equal to</li>
<li><code>~=</code>: Not equal to</li>
</ul>
<p>The <code>~=</code> operator tests the negation of equality. This is the same as the <code>!=</code> operator in C++. The other ones are the same as they are in C++.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Strings</h2>
<p>Strings are always<a id="_idIndexMarker063"/> a constant in Lua. You <a id="_idIndexMarker064"/>cannot change one character in a string and make it represent another string. You create a new string for that.</p>
<p>We can delimit literal strings with double or single quotes. The rest is quite similar to C++ strings, as shown in the following example:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; a = "Hello\n" .. 'C++'
&gt; a
Hello
C++
&gt; #a
9</pre>
<p>We have two operators on strings that cannot be found in C++. To concatenate two strings, you can use the <code>..</code> operator. To check the length of the string, you can use the <code>#</code> operator.</p>
<p>Like the C++ escape sequence, use <code>\</code> to escape special characters, as you can see in the line break in the preceding output. If you do not want to insert the newline escape sequence, <code>\n</code>, you <a id="_idIndexMarker065"/>can use a long string<a id="_idIndexMarker066"/> instead.</p>
<h3>Long strings</h3>
<p>You can use <code>[[</code> and <code>]]</code> to <a id="_idIndexMarker067"/>delimit multiple-line strings, for example:</p>
<pre class="source-code">
a = [[
Hello
C++
]]</pre>
<p>This defines a string that is equal to the single-line definition <code>"Hello\nC++\n"</code>.</p>
<p>Long strings can make strings more readable. You<a id="_idIndexMarker068"/> can define <strong class="bold">XML</strong> or <strong class="bold">JSON</strong> strings <a id="_idIndexMarker069"/>easily in Lua source code with long strings.</p>
<p>If your long string contains <code>[[</code> or <code>]]</code> in its content, you can add some equal signs between the opening brackets, for example:</p>
<pre class="source-code">
<code>a = [=[</code>
<code>x[y[1]]</code>
<code>]=]</code>
<code>b = [==[</code>
<code>x[y[2]]</code>
<code>]==]</code></pre>
<p>How many equal signs you add is up to you. However, one is usually enough.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Tables</h2>
<p>Lua tables <a id="_idIndexMarker070"/>are<a id="_idIndexMarker071"/> like <strong class="bold">C++ std::map</strong> containers but are more flexible. A table is the only way to construct complex data structures in Lua.</p>
<p>Let’s try a Lua table with some actions. In a Lua interpreter, type the following statements one by one and observe the outputs:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; a = {}
&gt; a['x'] = 100
&gt; a['x']
100
&gt; a.x
100</pre>
<p>This creates a table with the <code>{}</code> constructor and assigns a value of <code>100</code> to the <code>'x'</code> string key. Another way to construct this table is <code>a = {x = 100}</code>. To initialize a table with more keys, use <code>a = {x = 100, y = </code><code>200}</code>.</p>
<p><code>a.x</code> is an alternative syntax for <code>a['x']</code>. Which one you use is a style preference. But usually, the dot syntax implies that the table is used as a record or in an object-oriented way.</p>
<p>Except for <code>nil</code>, you <a id="_idIndexMarker072"/>can use all Lua types as table keys. You can also use different types as values in the same table. You have complete control, as seen next:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; b = {"Monday", "Tomorrow"}
&gt; b[1]
Monday
&gt; b[2]
Tomorrow
&gt; #b
2
&gt; a = {}
&gt; b[a] = "a table"
&gt; b[a]
a table
&gt; b.a
nil
&gt; #b
2</pre>
<p>This example <a id="_idIndexMarker073"/>explains<a id="_idIndexMarker074"/> four points related to the table:</p>
<ol>
<li>It first creates a table in the form of an array. Note that it is indexed starting from 1, not 0. When you give a value-only entry to the table constructor, it will be treated as part of the array. Do you recall that <code>#</code> is the length operator? It can tell the length of the table when it is used to represent a sequence or an array.</li>
<li>Then it adds another entry using another table, <code>a</code>, as the key and the <code>"a table"</code> string as the value. This is perfectly fine.</li>
<li>Note that <code>b.a</code> is <code>nil</code> because <code>b.a</code> means <code>b['a']</code> with the <code>'a'</code> string key, not <code>b[a]</code>.</li>
<li>Finally, we try to check the length of the table again. We have added 3 entries in the table, but it outputs a length of 2. Coming from C++, this may surprise you: Lua does not provide a built-in way to check table length. The length operator only provides convenience when a table is an array. You are able to use a table as an array and a map at the same time, but you would need to take full responsibility.</li>
</ol>
<p>Later in this chapter, when we learn about the <code>for</code> control structure, we will find out more about table <a id="_idIndexMarker075"/>traversal. Now we will learn about Lua functions.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Functions</h2>
<p>Lua functions serve <a id="_idIndexMarker076"/>a similar purpose as C++ functions. But <a id="_idIndexMarker077"/>unlike in C++, they are also a first-class citizen as one of the basic data types.</p>
<p>We can define a function by doing the following:</p>
<ol>
<li>Start with the <code>function</code> keyword.</li>
<li>Follow it with a function name and a pair of parentheses, inside which you can define function parameters if needed.</li>
<li>Implement the function body.</li>
<li>End the function definition with the <code>end</code> keyword.</li>
</ol>
<p>For example, we can define a function as follows:</p>
<pre class="source-code">
function hello()
    print("Hello C++")
end</pre>
<p>This will print out <code>"</code><code>Hello C++"</code>.</p>
<p>To define a function to use with the Lua interpreter, you have two choice:</p>
<ul>
<li>In an interactive interpreter, just start to type the function. When you end each line, the interpreter will know, and you can continue to type the next line of the function definition.</li>
<li>Alternatively, you can define your functions in another file that can be later imported into the interpreter. This is easier to work on. We will use this way from now on. Try to put your functions in this section in a file named <code>1-functions.lua</code>.</li>
</ul>
<p>To invoke a function, use its name and a pair of parentheses. This is the same as how you invoke a C++ function, for example:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; dofile("Chapter02/1-functions.lua")
&gt; hello()
Hello C++</pre>
<p><code>dofile()</code> is the Lua library method to load another Lua script. Here, we load the file where we have defined our Lua functions. If you have changed the script file, you can execute it<a id="_idIndexMarker078"/> again to<a id="_idIndexMarker079"/> load the latest script.</p>
<p>Next, we will learn about function parameters and function return values.</p>
<h3>Function parameters</h3>
<p>Function parameters, also <a id="_idIndexMarker080"/>called arguments, are values provided to the function when the function is called.</p>
<p>You can define function parameters by providing parameter declarations inside the parentheses after the function name. This is the same as in C++, but you do not need to provide parameter types, for example:</p>
<pre class="source-code">
function bag(a, b, c)
    print(a)
    print(b)
    print(c)
end</pre>
<p>When calling the function, you can pass in fewer or more parameters than defined. For example, you can call the <code>bag</code> function we just defined:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; dofile("Chapter02/1-functions.lua")
&gt; bag(1)
1
nil
nil
&gt; bag(1, 2, 3, 4)
1
2
3</pre>
<p>You can see what happens when the number of parameters provided is different from the number defined:</p>
<ul>
<li>When not enough parameters are passed, the remaining ones will have a <code>nil</code> value.</li>
<li>When more parameters are passed, the additional ones will be discarded.</li>
</ul>
<p>You cannot define a<a id="_idIndexMarker081"/> default value for function parameters because Lua does not support it at the language level. But you can check in your function, and if a parameter is <code>nil</code>, assign it a default value.</p>
<h3>Function results</h3>
<p>You can use the <code>return</code> keyword to <a id="_idIndexMarker082"/>return function results. It is possible to return multiple values. Let us define two functions that return one and two values, respectively:</p>
<pre class="source-code">
function square(a)
    return a * a
end
function sincos(a)
    return math.sin(a), math.cos(a)
end</pre>
<p>The first function returns the <code>square</code> for the given parameter. The second function returns the <code>sin</code> and <code>cos</code> of the given parameter. Let us give our two functions a try:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; dofile("Chapter02/1-functions.lua")
&gt; square(2)
4
&gt; sincos(math.pi / 3)
0.86602540378444        0.5</pre>
<p>You can see from the output that the functions return one and two values, respectively. In this example, <code>math.pi</code>, <code>math.sin</code>, and <code>math.cos</code> are from the Lua <code>math</code> library, which is loaded<a id="_idIndexMarker083"/> by default in the interactive interpreter. Have you wondered how to make a basic library for our <code>sincos</code> function?</p>
<h3>Putting a function in a table</h3>
<p>From a holistic <a id="_idIndexMarker084"/>point of view, the Lua <code>math</code> library – and any other library – is just tables holding functions and constant values. You can define your own:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; dofile("Chapter02/1-functions.lua")
&gt; mathx = {sincos = sincos}
&gt; mathx.sincos(math.pi / 3)
0.86602540378444        0.5
&gt; mathx["sincos"]
function: 0x13ca052d0
&gt; mathx["sincos"](math.pi / 3)
0.86602540378444        0.5</pre>
<p>We created a table here named <code>mathx</code> and assigned our <code>sincos</code> function to the <code>"</code><code>sincos"</code> key.</p>
<p>Now you know <a id="_idIndexMarker085"/>how to create your own Lua library. To finish our introduction to the Lua types, let us see why we should use local variables.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>Local variables and scopes</h2>
<p>So far, we have <a id="_idIndexMarker086"/>been using <a id="_idIndexMarker087"/>global variables because we just reference one when we need to, right? Yes, it is convenient. But the downside is that they will never go out of scope and can be accessed by all functions, related or not. Coming from a C++ background, you will not agree to this.</p>
<p>We can use <a id="_idIndexMarker088"/>the <code>if</code> branch, within a <code>for</code> loop, or within a function.</p>
<p>Local variables are good for preventing pollution of the global environment. Try to define two functions to test this:</p>
<pre class="source-code">
function test_variable_leakage()
    abc_leaked = 3
end
function test_local_variable()
    local abc_local = 4
end</pre>
<p>In the first<a id="_idIndexMarker089"/> function, a local variable is not used, so a global variable named <code>abc_leaked</code> will be created. In the second function, a local variable – <code>abc_local</code> – is used, which will be unknown outside its function scope. Let us see the effects:</p>
<pre class="source-code">
Lua 5.4.6 Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; dofile("Chapter02/1-functions.lua")
&gt; abc_leaked
nil
&gt; test_variable_leakage()
&gt; abc_leaked
3
&gt; test_local_variable()
&gt; abc_local
nil</pre>
<p>From the outputs, we can verify the following:</p>
<ol>
<li>First, we try the first function that does not use a local variable. Before calling the function, we verify that there is no global variable named <code>abc_leaked</code>. After calling the function, a global variable – <code>abc_leaked</code> – is created.</li>
<li>Then we try the second function that uses a local variable. No global variable is created in this case.</li>
</ol>
<p>You<a id="_idIndexMarker090"/> should <a id="_idIndexMarker091"/>always use local variables when you can. Next, let us familiarize ourselves with Lua’s control structures.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Control structures</h1>
<p>The Lua control <a id="_idIndexMarker092"/>structures are quite similar to the C++ control structures. Try to compare them with their C++ counterparts as you learn about them.</p>
<p>For the code shown in this section, you can put them in another Lua script file named <code>2-controls.lua</code>, and import it with <code>dofile</code> in the Lua interpreter. You can put each example in a separate function so that you can test the code with different parameters. By now, you should be comfortable using the Lua interpreter, so we will not show how to do it in the rest of this chapter.</p>
<p>We will first explore<a id="_idIndexMarker093"/> how to do conditional branching in Lua, and then we will venture into loops.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>if then else</h2>
<p>The Lua <code>if</code> control<a id="_idIndexMarker094"/> structure is similar to the C++ one. However, you do not need the parentheses around the test condition, and you do not use the curly brackets. Instead, you will need the <code>then</code> keyword and the <code>end</code> keyword to delimit the code branches, for example:</p>
<pre class="source-code">
if a &lt; 0 then a = 0 end
if a &gt; 0 then return a else return 0 end
if a &lt; 0 then
    a = 0
    print("changed")
else
    print("unchanged")
end</pre>
<p>The <code>else</code> branch is optional if you have no operation for that. If you have only one statement in each branch, you can also choose to write everything in one line.</p>
<p>The Lua language design emphasizes simplicity, so the <code>if</code> control structure is the only conditional branching control. What if you want to implement something that resembles a C++ <strong class="bold">switch</strong> control structure?</p>
<h3>Simulating switch</h3>
<p>There is no switch<a id="_idIndexMarker095"/> control structure in Lua. To simulate it, you can use <code>elseif</code>. The following code does that:</p>
<pre class="source-code">
if day == 1 then
    return "Monday"
elseif day == 2 then
    return "Tuesday"
elseif day == 3 then
    return "Wednesday"
elseif day == 4 then
    return "Thursday"
elseif day == 5 then
    return "Friday"
elseif day == 6 then
    return "Saturday"
elseif day == 7 then
    return "Sunday"
else
    return nil
end</pre>
<p>This behaves the same as a C++ <code>if..else if</code> control structure. The <code>if</code> and <code>elseif</code> conditions will be <a id="_idIndexMarker096"/>checked one by one until one condition is met and the name of the day of the week is returned.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>while</h2>
<p>The Lua <code>do</code> keyword and the <code>end</code> keyword. The following example prints the days of the week:</p>
<pre class="source-code">
local days = {
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"
}
local i = 1
while days[i] do
    print(days[i])
    i = i + 1
end</pre>
<p>We declare a table named <code>days</code> and use it as an array. When the <code>i</code> index reaches <code>8</code>, the loop will end because <code>days[8]</code> is <code>nil</code> and tests as <code>false</code>. Coming from C++, you may wonder why we can access the eighth element of a seven-element array. In Lua, there is no index out of bound issue when a table is accessed this way.</p>
<p>You can <a id="_idIndexMarker099"/>use <code>break</code> to end the loop<a id="_idIndexMarker100"/> immediately. This works for the <code>repeat</code> loop and the <code>for</code> loop as well, which we will explain next.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>repeat</h2>
<p>The Lua <code>do..while</code> control <a id="_idIndexMarker102"/>structure does, but the ending condition is treated differently. Lua uses the <code>until</code> condition to end the loop instead of C++’s <code>while</code>.</p>
<p>Let us implement the same code shown for the <code>while</code> control structure but with <code>repeat</code> this time:</p>
<pre class="source-code">
local days = {
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"
}
local i = 0
repeat
    i = i + 1
    print(days[i])
until i == #days</pre>
<p><code>#days</code> returns the length of the <code>day</code> array. The code block within <code>repeat..until</code> will loop until <code>i</code> reaches this length.</p>
<p class="callout-heading">Note</p>
<p class="callout">Keep in mind that for a Lua array, the index starts from 1.</p>
<p>To implement the same code with <code>do..while</code> in C++, do the following:</p>
<pre class="source-code">
const std::vector&lt;std::string&gt; days {
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"
};
size_t i = 0;
do {
    std::cout &lt;&lt; days[i] &lt;&lt; std::endl;
    i++;
} while (i &lt; days.size());</pre>
<p>The C++ implementation <a id="_idIndexMarker103"/>looks very similar to the Lua version, except for <a id="_idIndexMarker104"/>the ending condition as pointed out earlier: <code>i &lt; days.size()</code>. We are checking for less than, not equal to.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>for, numerical</h2>
<p>The<a id="_idIndexMarker105"/> numerical <strong class="bold">for</strong> loops<a id="_idIndexMarker106"/> through a list of numbers. It takes this form:</p>
<pre class="source-code">
for var = exp1, exp2, exp3 do
    do_something
end</pre>
<ul>
<li><code>var</code> is treated as a local variable scoped to the <code>for</code> block.</li>
<li><code>exp1</code> is the start value.</li>
<li><code>exp2</code> is the end value.</li>
<li><code>exp3</code> is the step and is optional. When not provided, the default step is 1.</li>
</ul>
<p>To understand this better, let us see an example:</p>
<pre class="source-code">
local days = {
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"
}
for i = 1, #days, 4 do
    print(i, days[i])
end</pre>
<p><code>i</code> is the local variable and has an initial value of <code>1</code>. The loop will end when <code>i</code> becomes greater than <code>#days</code>. A step of <code>4</code> is also provided. So, after each iteration, the effect is <code>i = i + 4</code>. Once you run this code, you will find out that only Monday and Friday are printed.</p>
<p>And, maybe to your surprise, the float type will work as well:</p>
<pre class="source-code">
Lua 5.4.6  Copyright (C) 1994-2022 Lua.org, PUC-Rio
&gt; for a = 1.0, 4.0, 1.5 do print(a) end
1.0
2.5
4.0</pre>
<p>As can be <a id="_idIndexMarker107"/>verified by the output, the <code>for</code> loop <a id="_idIndexMarker108"/>prints from <code>1.0</code> and increases the value by <code>1.5</code> every time, as long as the value is not greater than <code>4.0</code>.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>for, generic</h2>
<p>The generic <code>for</code> loop <a id="_idIndexMarker109"/>traverses <a id="_idIndexMarker110"/>all values returned by an <code>iterator function</code>. This form of <code>for</code> loops is very convenient for traversing tables.</p>
<p>When we talked about numerical <code>for</code> loops, we saw how they can traverse index-based tables. However, a table in Lua can be more than an array. The most common iterators on tables are <code>pairs</code> and <code>ipairs</code>. They return the key and value pairs for the table. <code>pairs</code> return pairs in an undefined order, as in most hash map implementations. <code>ipairs</code> returns pairs in a sorted order.</p>
<p>Even for an index-based table, if you want to traverse everything, the generic <code>for</code> loop can also be more convenient:</p>
<pre class="source-code">
local days = {
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"
}
for index, day in pairs(days) do
    print(index, day)
end</pre>
<p>This loops through the whole array without referring to the array length. The <code>pairs</code> iterator returns<a id="_idIndexMarker111"/> the key and value pair, one by one, for<a id="_idIndexMarker112"/> each loop iteration until all elements in the table are enumerated. After this, the loop ends.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Summary</h1>
<p>In this chapter, we have learned about six out of the eight data types in Lua and the four control structures. We have also learned about local variables and why you should use them. This knowledge will prepare you for the rest of the book.</p>
<p>By now, you should be able to read and understand most of the Lua code out there. Some details and topics were intentionally not included in this chapter. You can study more about them when you encounter them.</p>
<p>In the next chapter, we will learn how to call Lua code from C++.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Exercises</h1>
<ol>
<li>Locate the standard string manipulation library in the Lua reference manual. Learn about <code>string.gmatch</code>, <code>string.gsub</code>, and pattern matching. What pattern represents all non-space characters?</li>
<li>Using <code>string.gmatch</code> and a generic <code>for</code> loop, reverse the sentence “C++ loves Lua.” The output should be “Lua loves C++.”</li>
<li>Can you use <code>string.gsub</code> and achieve the same with one line of code?</li>
</ol>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>References</h1>
<p>The official Lua reference manual: <a href="https://www.lua.org/manual/5.4/">https://www.lua.org/manual/5.4/</a></p>
</div>
</div>

<div><div><h1 id="_idParaDest-62" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor062"/>Part 2 – Calling Lua from C++</h1>
<p>Now that you are familiar with setting up C++ projects with Lua, you will start to learn how to call Lua code from C++.</p>
<p>You will start to implement a general C++ utility class to load and execute Lua code. First, you will learn how to load Lua scripts and call a Lua function. Then, you will explore how to pass arguments to Lua functions and handle return values. Finally, you will dig deeper to master working with Lua tables.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><em class="italic">Chapter 3</em>, <em class="italic">How to Call Lua from C++</em></li>
<li><em class="italic">Chapter 4</em>, <em class="italic">Mapping Lua Types to C++</em></li>
<li><em class="italic">Chapter 5</em>, <em class="italic">Working with Lua Tables</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>