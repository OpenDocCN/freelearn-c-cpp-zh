<html><head></head><body>
  <div id="_idContainer049">
   <h1 class="chapter-number" id="_idParaDest-144">
    <a id="_idTextAnchor143">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     7
    </span>
   </h1>
   <h1 id="_idParaDest-145">
    <a id="_idTextAnchor144">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     The Async Function
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In the previous chapter, we learned about promises, futures, and packaged tasks.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     When we introduced packaged tasks, we mentioned that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.4.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     provides a simpler way to achieve the same result, with less code and thus being cleaner and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      more concise.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      async function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.10.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.11.1">
     ) is a function
    </span>
    <a id="_idIndexMarker465">
    </a>
    <span class="koboSpan" id="kobo.12.1">
     template that runs a callable object asynchronously where we can also select the method of execution by passing some flags defining the launch policy.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     It is a powerful tool for handling asynchronous operations, but its automatic management and lack of control over the thread of execution, among other aspects, can also make it unsuitable for certain tasks where fine-grained control or cancellation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      is required.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     In this chapter, we are going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      What is the async function and how do we
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       use it?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      What are the different
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       launch policies?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      What are the differences from previous methods, especially
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       packaged tasks?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      What are the advantages and disadvantages of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.24.1">
        std::async
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       ?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Practical scenarios
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       and examples
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-146">
    <a id="_idTextAnchor145">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     The async function has been available since C++11, but some examples use features from C++14, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.30.1">
      chrono_literals
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     , and C++20, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.32.1">
      counting_semaphore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     , so the code shown in this chapter can be compiled by compilers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      supporting C++20.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.35.1">
     Please check the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.36.1">
      Technical requirements
     </span>
    </em>
    <span class="koboSpan" id="kobo.37.1">
     section in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.38.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.39.1">
     , for guidance on how to install GCC 13 and Clang
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      8 compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     You can find all the complete code in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.43.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     The examples for this chapter are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.45.1">
      Chapter_07
     </span>
    </strong>
    <span class="koboSpan" id="kobo.46.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     All source code files can be compiled using CMake
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.48.1">
cmake . </span><span class="koboSpan" id="kobo.48.2">&amp;&amp; cmake â€”build .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     Executable binaries will be generated under the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.50.1">
       bin
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.51.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor146">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     What is std::async?
    </span>
   </h1>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.53.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     is a function template in C++ introduced by the C++ standard in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      &lt;future&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     header as part of the thread support library from C++11.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     It is used to run a function asynchronously, allowing the main thread (or other threads) to continue
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      running concurrently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     In summary,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.59.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     is a powerful tool for asynchronous programming in C++, making it easier to run
    </span>
    <a id="_idIndexMarker466">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     tasks in parallel and manage their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      results efficiently.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-148">
    <a id="_idTextAnchor147">
    </a>
    <span class="koboSpan" id="kobo.63.1">
     Launching an asynchronous task
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     To execute a function
    </span>
    <a id="_idIndexMarker467">
    </a>
    <span class="koboSpan" id="kobo.65.1">
     asynchronously
    </span>
    <a id="_idIndexMarker468">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.67.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.68.1">
     , we can use the same approaches we used when starting threads in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.69.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.70.1">
     , with the different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      callable objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     One approach is using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      function pointer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.74.1">
void func() {
Â Â Â Â std::cout &lt;&lt; "Using function pointer\n";
}
auto fut1 = std::async(func);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     Another approach is using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      lambda function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.77.1">
auto lambda_func = []() {
Â Â Â Â std::cout &lt;&lt; "Using lambda function\n";
};
auto fut2 = std::async(lambda_func);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     We can also use an embedded
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      lambda function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.80.1">
auto fut3 = std::async([]() {
Â Â Â Â std::cout &lt;&lt; "Using embedded lambda function\n";
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     We can use a function object where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      operator()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.83.1">
      is overloaded:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.84.1">
class FuncObjectClass {
Â Â Â public:
Â Â Â Â void operator()() {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; "Using function object class\n";
Â Â Â Â }
};
auto fut4 = std::async(FuncObjectClass());</span></pre>
   <p>
    <span class="koboSpan" id="kobo.85.1">
     We can use a non-static
    </span>
    <a id="_idIndexMarker469">
    </a>
    <span class="koboSpan" id="kobo.86.1">
     member function by
    </span>
    <a id="_idIndexMarker470">
    </a>
    <span class="koboSpan" id="kobo.87.1">
     passing the address of the member function and the address of an object to call the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.88.1">
      member function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.89.1">
class Obj {
Â Â public:
Â Â Â Â void func() {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; "Using a non-static member function"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; std::endl;
Â Â Â Â }
};
Obj obj;
auto fut5 = std::async(&amp;Obj::func, &amp;obj);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.90.1">
     We can also use a static member function where only the address of the member function is needed as the method
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.91.1">
      is static:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.92.1">
class Obj {
Â Â public:
Â Â Â Â static void static_func() {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; "Using a static member function"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; std::endl;
Â Â Â Â }
};
auto fut6 = std::async(&amp;Obj::static_func);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.94.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.95.1">
     is called, it returns a future where the result of the function will be stored, as we already
    </span>
    <a id="_idIndexMarker471">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     learned in the
    </span>
    <a id="_idIndexMarker472">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      previous chapter.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-149">
    <a id="_idTextAnchor148">
    </a>
    <span class="koboSpan" id="kobo.98.1">
     Passing values
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     Again, similarly to
    </span>
    <a id="_idIndexMarker473">
    </a>
    <span class="koboSpan" id="kobo.100.1">
     when we passed arguments when creating threads, arguments can be passed to the thread by value, by reference, or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.101.1">
      as pointers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     Here, we can see how to pass arguments
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      by value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.104.1">
void funcByValue(const std::string&amp; str, int val) {
Â Â Â Â std::cout &lt;&lt; Â«str: Â« &lt;&lt; str &lt;&lt; Â«, val: Â« &lt;&lt; val
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; std::endl;
}
std::string str{"Passing by value"};
auto fut1 = async(funcByValue, str, 1);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     Passing by value implies a copy as a temporary object is created and the argument value is copied into it.
    </span>
    <span class="koboSpan" id="kobo.105.2">
     This avoids data races, but it is much
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      more costly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.107.1">
     The next example shows how to pass values
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      by reference:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.109.1">
void modifyValues(std::string&amp; str) {
Â Â Â Â str += " (Thread)";
}
std::string str{"Passing by reference"};
auto fut2 = std::async(modifyValues, std::ref(str));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     We can also pass
    </span>
    <a id="_idIndexMarker474">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     values as a
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.112.1">
       const reference
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.114.1">
void printVector(const std::vector&lt;int&gt;&amp; v) {
Â Â Â Â std::cout &lt;&lt; "Vector: ";
Â Â Â Â for (int num : v) {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; num &lt;&lt; " ";
Â Â Â Â }
Â Â Â Â std::cout &lt;&lt; std::endl;
}
std::vector&lt;int&gt; v{1, 2, 3, 4, 5};
auto fut3 = std::async(printVector, std::cref(v));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     Passing by reference is achieved by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.116.1">
      std::ref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.117.1">
     (non-constant references) or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      std::cref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     (constant references), both defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      &lt;functional&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     header file, letting the variadic template (a class or function template that supports an arbitrary number of arguments) defining the thread constructor to treat the argument as a reference.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     Missing these functions when passing arguments means passing the arguments by value, which
    </span>
    <a id="_idIndexMarker475">
    </a>
    <span class="koboSpan" id="kobo.122.1">
     implies a copy, as mentioned earlier, making the function call
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      more costly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.124.1">
     You can also move an object into the thread created by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.125.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.126.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.127.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.128.1">
auto fut4 = std::async(printVector, std::move(v));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.129.1">
     Note that the vector
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.130.1">
      v
     </span>
    </strong>
    <span class="koboSpan" id="kobo.131.1">
     is in a valid but empty state after its content
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.132.1">
      being moved.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     Finally, we can also pass values by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      lambda captures:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.135.1">
std::string str5{"Hello"};
auto fut5 = std::async([&amp;]() {
Â Â Â Â std::cout &lt;&lt; "str: " &lt;&lt; str5 &lt;&lt; std::endl;
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     In this example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.137.1">
      str
     </span>
    </strong>
    <span class="koboSpan" id="kobo.138.1">
     variable is
    </span>
    <a id="_idIndexMarker476">
    </a>
    <span class="koboSpan" id="kobo.139.1">
     accessed by the lambda function executed by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.142.1">
      a reference.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-150">
    <a id="_idTextAnchor149">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     Returning values
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      std:async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     is called, it
    </span>
    <a id="_idIndexMarker477">
    </a>
    <span class="koboSpan" id="kobo.147.1">
     immediately returns a future that will hold the value that the function or callable object will compute, as we saw in the previous chapter when using promises
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      and futures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     In the previous examples, we didnÂ´t use the returned object from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     at all.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     Letâ€™s rewrite the last example from the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.152.1">
      Packaged tasks
     </span>
    </em>
    <span class="koboSpan" id="kobo.153.1">
     section in
    </span>
    <a href="B22219_06.xhtml#_idTextAnchor125">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.154.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.155.1">
     , where we used a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     object to compute the power of two values.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     But in this case, we will spawn several asynchronous tasks using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     to compute these values, wait for the tasks to finish, store the results, and finally, show them in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      the console:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.161.1">
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;syncstream&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
int compute(unsigned taskId, int x, int y) {
Â Â Â Â std::this_thread::sleep_for(std::chrono::milliseconds(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â rand() % 200));
Â Â Â Â sync_cout &lt;&lt; "Running task " &lt;&lt; taskId &lt;&lt; '\n';
Â Â Â Â return std::pow(x, y);
}
int main() {
Â Â Â Â std::vector&lt;std::future&lt;int&gt;&gt; futVec;
Â Â Â Â for (int i = 0; i &lt;= 10; i++)
Â Â Â Â Â Â Â Â futVec.emplace_back(std::async(compute,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i+1, 2, i));
Â Â Â Â sync_cout &lt;&lt; "Waiting in main thread\n";
Â Â Â Â std::this_thread::sleep_for(1s);
Â Â Â Â std::vector&lt;int&gt; results;
Â Â Â Â for (auto&amp; fut : futVec)
Â Â Â Â Â Â Â Â results.push_back(fut.get());
Â Â Â Â for (auto&amp; res : results)
Â Â Â Â Â Â Â Â std::cout &lt;&lt; res &lt;&lt; ' ';
Â Â Â Â std::cout &lt;&lt; std::endl;
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      compute()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     function
    </span>
    <a id="_idIndexMarker478">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     simply gets two numbers,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      y
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     , and computes
    </span>
    <span class="koboSpan" id="kobo.170.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" src="image/5.png" style="vertical-align:-0.012em;height:0.606em;width:0.788em"/>
    </span>
    <span class="koboSpan" id="kobo.171.1">
     .
    </span>
    <span class="koboSpan" id="kobo.171.2">
     It also gets a number representing the task identifier and waits for up to two seconds before printing a message in the console and computing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      the result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     function, the main thread launches several tasks computing a sequence of power-of-two values.
    </span>
    <span class="koboSpan" id="kobo.175.2">
     The futures returned by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     are stored in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.178.1">
      futVec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     vector.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     Then, the main thread waits for one second, emulating some work.
    </span>
    <span class="koboSpan" id="kobo.179.3">
     Finally, we traverse the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      futVec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     vector and call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.182.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     function in each future element, thus waiting for that specific task to finish and return a value, and we store the returned value in another vector called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.184.1">
      results
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     .
    </span>
    <span class="koboSpan" id="kobo.185.2">
     Then, we print the content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.186.1">
      results
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     vector before exiting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     This is the output when running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      that program:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.191.1">
Waiting in main thread
Running task 11
Running task 9
Running task 2
Running task 8
Running task 4
Running task 6
Running task 10
Running task 3
Running task 1
Running task 7
Running task 5
1 2 4 8 16 32 64 128 256 512 1024</span></pre>
   <p>
    <span class="koboSpan" id="kobo.192.1">
     As we can see, each task took a different amount of time to complete, thus the output is not ordered by task identifier.
    </span>
    <span class="koboSpan" id="kobo.192.2">
     But as we traverse the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      futVec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     vector in order when getting the results, these are shown as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.195.1">
      in order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.196.1">
     Now that we have
    </span>
    <a id="_idIndexMarker479">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     seen how to launch asynchronous tasks and pass arguments and return values, letâ€™s learn how to use launch policies to control the methods
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      of execution.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-151">
    <a id="_idTextAnchor150">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     Launch policies
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.200.1">
     Apart from specifying
    </span>
    <a id="_idIndexMarker480">
    </a>
    <span class="koboSpan" id="kobo.201.1">
     the function or callable
    </span>
    <a id="_idIndexMarker481">
    </a>
    <span class="koboSpan" id="kobo.202.1">
     object as an argument when using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     function, we can also specify the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.205.1">
      launch policy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     .
    </span>
    <span class="koboSpan" id="kobo.206.2">
     Launch policies control how
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.207.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     schedules the execution of asynchronous task.
    </span>
    <span class="koboSpan" id="kobo.208.2">
     These are defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.209.1">
      &lt;
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.210.1">
       future&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.211.1">
      library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.212.1">
     The launch policy must be specified as the first argument when calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     .
    </span>
    <span class="koboSpan" id="kobo.214.2">
     This argument is of the type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      std::launch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     , a bitmask value where its bits control the allowed methods of execution, which can be one or more of the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.217.1">
      enumeration constants:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.218.1">
       std::launch::async
      </span>
     </strong>
     <span class="koboSpan" id="kobo.219.1">
      : The task is executed in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.220.1">
       separate thread.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.221.1">
       std::launch::deferred
      </span>
     </strong>
     <span class="koboSpan" id="kobo.222.1">
      : Enables lazy evaluation by executing the task in the calling thread the first time its result is requested via the future
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.223.1">
       get()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.224.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.225.1">
       wait()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.226.1">
      method.
     </span>
     <span class="koboSpan" id="kobo.226.2">
      All further accesses to the same
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.227.1">
       std::future
      </span>
     </strong>
     <span class="koboSpan" id="kobo.228.1">
      will return the result immediately.
     </span>
     <span class="koboSpan" id="kobo.228.2">
      That means that the task will only be executed when the result is explicitly requested, which can lead to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.229.1">
       unexpected delays.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     If not defined, by default the launch policy will be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      std::launch::async | std::launch::deferred
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     .
    </span>
    <span class="koboSpan" id="kobo.232.2">
     Also, implementations can provide additional
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      launch policies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     Therefore, by default the C++ standard states that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     can run in either asynchronous or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      deferred mode.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     Note that when more
    </span>
    <a id="_idIndexMarker482">
    </a>
    <span class="koboSpan" id="kobo.239.1">
     than one flag is specified, the behavior is implementation-defined, so depending on the compiler we are using.
    </span>
    <span class="koboSpan" id="kobo.239.2">
     The standard recommends using available concurrency and deferring the task if the default launch policy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      is specified.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     Letâ€™s implement the following example to test the different launch policy behaviors.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     First, we define the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      square()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     function, which will serve as the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      asynchronous task:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.245.1">
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;syncstream&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
int square(const std::string&amp; task_name, int x) {
Â Â Â Â sync_cout &lt;&lt; "Launching " &lt;&lt; task_name
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; Â« task...\nÂ»;
Â Â Â Â return x * x;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     Then, in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.247.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.248.1">
     function, the program starts by launching three different asynchronous tasks, one using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      std::launch::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     launch policy, another task using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.251.1">
      std::launch::deferred
     </span>
    </strong>
    <span class="koboSpan" id="kobo.252.1">
     launch policy, and a third task using the default
    </span>
    <a id="_idIndexMarker483">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.253.1">
      launch
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker484">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      policy:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.255.1">
sync_cout &lt;&lt; "Starting main thread...\n";
auto fut_async = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â square, Â«async_policy", 2);
auto fut_deferred = std::async(std::launch::deferred,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â square, Â«deferred_policy", 3);
auto fut_default = std::async(square,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â«default_policy", 4);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     As mentioned in the previous chapter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.257.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.258.1">
     returns a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.259.1">
      std::future_status
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     object indicating whether the future is ready, deferred, or has timed out.
    </span>
    <span class="koboSpan" id="kobo.260.2">
     Therefore, we can use that function to check whether any of the returned futures are deferred.
    </span>
    <span class="koboSpan" id="kobo.260.3">
     We do that by using a lambda function,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      is_deferred()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     , that returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     in that case.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     At least one future object,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      fut_deferred
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     , is expected to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      return
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.268.1">
       true
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.270.1">
auto is_deferred = [](std::future&lt;int&gt;&amp; fut) {
Â Â Â Â return (fut.wait_for(0s) ==
Â Â Â Â Â Â Â Â Â Â Â Â std::future_status::deferred);
};
sync_cout &lt;&lt; "Checking if deferred:\n";
sync_cout &lt;&lt; "Â Â fut_async: " &lt;&lt; std::boolalpha
Â Â Â Â Â Â Â Â Â Â &lt;&lt; is_deferred(fut_async) &lt;&lt; '\n';
sync_cout &lt;&lt; "Â Â fut_deferred: " &lt;&lt; std::boolalpha
Â Â Â Â Â Â Â Â Â Â &lt;&lt; is_deferred(fut_deferred) &lt;&lt; '\n';
sync_cout &lt;&lt; "Â Â fut_default: " &lt;&lt; std::boolalpha
Â Â Â Â Â Â Â Â Â Â &lt;&lt; is_deferred(fut_default) &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.271.1">
     Then, the main program waits for one second, emulating some processing, and finally retrieves the results
    </span>
    <a id="_idIndexMarker485">
    </a>
    <span class="koboSpan" id="kobo.272.1">
     from the asynchronous tasks
    </span>
    <a id="_idIndexMarker486">
    </a>
    <span class="koboSpan" id="kobo.273.1">
     and prints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      their value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.275.1">
sync_cout &lt;&lt; "Waiting in main thread...\n";
std::this_thread::sleep_for(1s);
sync_cout &lt;&lt; "Wait in main thread finished.\n";
sync_cout &lt;&lt; "Getting result from "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; "async policy task...\n";
int val_async = fut_async.get();
sync_cout &lt;&lt; "Result from async policy task: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; val_async &lt;&lt; '\n';
sync_cout &lt;&lt; "Getting result from "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; "deferred policy task...\n";
int val_deferred = fut_deferred.get();
sync_cout &lt;&lt; "Result from deferred policy task: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; val_deferred &lt;&lt; '\n';
sync_cout &lt;&lt; "Getting result from "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; "default policy task...\n";
int val_default = fut_default.get();
sync_cout &lt;&lt; "Result from default policy task: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; val_default &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.276.1">
     This is the output
    </span>
    <a id="_idIndexMarker487">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     from running the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      preceding code:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.279.1">
Starting main thread...
</span><span class="koboSpan" id="kobo.279.2">Launching async_policy task...
</span><span class="koboSpan" id="kobo.279.3">Launching default_policy task...
</span><span class="koboSpan" id="kobo.279.4">Checking if deferred:
Â Â fut_async: false
Â Â fut_deferred: true
Â Â fut_default: false
Waiting in main thread...
</span><span class="koboSpan" id="kobo.279.5">Wait in main thread finished.
</span><span class="koboSpan" id="kobo.279.6">Getting result from async policy task...
</span><span class="koboSpan" id="kobo.279.7">Result from async policy task: 4
Getting result from deferred policy task...
</span><span class="koboSpan" id="kobo.279.8">Launching deferred_policy task...
</span><span class="koboSpan" id="kobo.279.9">Result from deferred policy task: 9
Getting result from default policy task...
</span><span class="koboSpan" id="kobo.279.10">Result from default policy task: 16</span></pre>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     Note how the tasks with
    </span>
    <a id="_idIndexMarker488">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     the default and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.282.1">
      std::launch::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.283.1">
     launch policies are executed while the main thread is sleeping.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     Therefore, the
    </span>
    <a id="_idIndexMarker489">
    </a>
    <span class="koboSpan" id="kobo.284.1">
     task is started as soon as it can be scheduled.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     Also note how the deferred task, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.285.1">
      std::launch::deferred
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     launch policy, starts executing once the value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      is requested.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.288.1">
     Next, letâ€™s learn how to handle exceptions happening in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      asynchronous task.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-152">
    <a id="_idTextAnchor151">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     Handling exceptions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     Exception propagation
    </span>
    <a id="_idIndexMarker490">
    </a>
    <span class="koboSpan" id="kobo.292.1">
     from the
    </span>
    <a id="_idIndexMarker491">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     asynchronous task to the main thread is not supported when using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     .
    </span>
    <span class="koboSpan" id="kobo.295.2">
     To enable exception propagation, we might need a promise object to store the exception that later can be accessed by the future returned when calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     .
    </span>
    <span class="koboSpan" id="kobo.297.2">
     But that promise object is not accessible or provided
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.299.1">
       std::async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     One feasible way to achieve this is to use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.302.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     object wrapping the asynchronous task.
    </span>
    <span class="koboSpan" id="kobo.303.2">
     But if that is the case, we should directly use a packaged task as described in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      previous chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.305.1">
     We could also use nested exceptions, available since C++11, by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      std::nested_exception
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     , a polymorphic mixin class that can capture and store the current exception, allowing nested exceptions of arbitrary types.
    </span>
    <span class="koboSpan" id="kobo.307.2">
     From a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      std::nested_exception
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     object, we can retrieve the stored exception by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      nested_ptr()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     method or rethrow it by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.313.1">
       rethrow_nested()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.315.1">
     To create a nested exception, we can throw an exception using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.316.1">
      std::throw_with_nested()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     If we want to rethrow an exception only if itâ€™s nested, we can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      std::rethrow_if_nested()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     .
    </span>
    <span class="koboSpan" id="kobo.319.2">
     All these functions are defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      &lt;
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.321.1">
       exception&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      header.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.323.1">
     Using all these functions, we can implement the following example, where an asynchronous task throws a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.324.1">
      std::runtime_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     exception, which is caught in the main body of the asynchronous task and rethrown as a nested exception.
    </span>
    <span class="koboSpan" id="kobo.325.2">
     This nested exception object is then caught again in the main function and the sequence of exceptions is printed out, as
    </span>
    <a id="_idIndexMarker492">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.328.1">
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
void print_exceptions(const std::exception&amp; e,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â int level = 1) {
Â Â Â Â auto indent = std::string(2 * level, â€¹ â€¹);
Â Â Â Â std::cerr &lt;&lt; indent &lt;&lt; e.what() &lt;&lt; '\n';
Â Â Â Â try {
Â Â Â Â Â Â Â Â std::rethrow_if_nested(e);
Â Â Â Â } catch (const std::exception&amp; nestedException) {
Â Â Â Â Â Â Â Â print_exceptions(nestedException, level + 1);
Â Â Â Â } catch (...) { }
}
void func_throwing() {
Â Â Â Â throw std::runtime_error(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â«Exception in func_throwing");
}
int main() {
Â Â Â Â auto fut = std::async([]() {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â func_throwing();
Â Â Â Â Â Â Â Â } catch (...) {
Â Â Â Â Â Â Â Â Â Â Â Â std::throw_with_nested(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â std::runtime_error(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Exception in async task."));
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â try {
Â Â Â Â Â Â Â Â fut.get();
Â Â Â Â } catch (const std::exception&amp; e) {
Â Â Â Â Â Â Â Â std::cerr &lt;&lt; "Caught exceptions:\n";
Â Â Â Â Â Â Â Â print_exceptions(e);
Â Â Â Â }
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.329.1">
     As we can see in the example, an asynchronous task is created that executes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      func_throwing()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     function
    </span>
    <a id="_idIndexMarker493">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     inside a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.333.1">
      try-catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.334.1">
     block.
    </span>
    <span class="koboSpan" id="kobo.334.2">
     This function simply throws a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.335.1">
      std::runtime_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.336.1">
     exception, which is caught and then rethrown as part of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.337.1">
      std::nested_exception
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     class by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.339.1">
      std::throw_with_nested()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     Later, in the main thread, when we try to retrieve the result from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.341.1">
      fut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.342.1">
     future object by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.343.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.344.1">
     method, the nested exception is thrown and captured again in the main try-catch block, where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      print_exceptions()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     function is called with the captured nested exception as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      an argument.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      print_exceptions()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     function prints the reason for the current exception (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.351.1">
      e.what()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     ) and rethrows the exception if nested, thus catching it again and recursively printing exception reasons with indentation by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.353.1">
      nesting level.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.354.1">
     As each asynchronous
    </span>
    <a id="_idIndexMarker494">
    </a>
    <span class="koboSpan" id="kobo.355.1">
     task has its own future, the
    </span>
    <a id="_idIndexMarker495">
    </a>
    <span class="koboSpan" id="kobo.356.1">
     program can handle exceptions from multiple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      tasks separately.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-153">
    <a id="_idTextAnchor152">
    </a>
    <span class="koboSpan" id="kobo.358.1">
     Exceptions when calling std::async
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.359.1">
     Apart from exceptions happening in
    </span>
    <a id="_idIndexMarker496">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     the asynchronous task, there are also some cases when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     might throw an exception.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     These exceptions are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.364.1">
       std::bad_alloc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.365.1">
      : If there is not enough memory to store internal data structures needed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.366.1">
       by
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.367.1">
        std::async
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.368.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.369.1">
       std:system_error
      </span>
     </strong>
     <span class="koboSpan" id="kobo.370.1">
      : If a new thread cannot be started when using
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.371.1">
       std::launch::async
      </span>
     </strong>
     <span class="koboSpan" id="kobo.372.1">
      as the launch policy.
     </span>
     <span class="koboSpan" id="kobo.372.2">
      In this case, the error condition will be
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.373.1">
       std::errc::resource_unavailable_try_again
      </span>
     </strong>
     <span class="koboSpan" id="kobo.374.1">
      .
     </span>
     <span class="koboSpan" id="kobo.374.2">
      Depending on the implementation, if the policy is the default one, it might fall back to deferred invocation or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.375.1">
       implementation-defined policies.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     Most of the time, these exceptions are thrown out due to resource exhaustion.
    </span>
    <span class="koboSpan" id="kobo.376.2">
     A solution can be retrying later when some asynchronous tasks currently working have finished and released their resources.
    </span>
    <span class="koboSpan" id="kobo.376.3">
     Another, more reliable, solution is to limit the number of asynchronous tasks running at a given time.
    </span>
    <span class="koboSpan" id="kobo.376.4">
     We will implement this solution shortly, but first, letâ€™s understand the futures returned by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     and how to achieve better
    </span>
    <a id="_idIndexMarker497">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     performance when
    </span>
    <a id="_idIndexMarker498">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     dealing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.381.1">
      with them.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-154">
    <a id="_idTextAnchor153">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     Async futures and performance
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.383.1">
     Futures
    </span>
    <a id="_idIndexMarker499">
    </a>
    <span class="koboSpan" id="kobo.384.1">
     returned by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.385.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     behave differently from the ones obtained from promises when their destructors are called.
    </span>
    <span class="koboSpan" id="kobo.386.2">
     When these futures are destroyed, their
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.387.1">
      ~future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.388.1">
     destructor is called where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.389.1">
      wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.390.1">
     function is executed, causing the thread that was spawned at creation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.391.1">
      to join.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     That would impact the program performance by adding some overhead if the thread used by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     has not already been joined, therefore we need to understand when the future object will go out of scope and thus its destructor will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      be called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     Letâ€™s see, with several short examples, how these futures behave and some recommendations on how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      use them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     We start by defining a task,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.399.1">
      func
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     , that simply multiplies its input value by 2 and also waits for some time, emulating a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      costly operation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.402.1">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
unsigned func(unsigned x) {
Â Â Â Â std::this_thread::sleep_for(10ms);
Â Â Â Â return 2 * x;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     To measure the performance of a block of code, we will asynchronously run several tasks (in this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.404.1">
      NUM_TASKS = 32
     </span>
    </strong>
    <span class="koboSpan" id="kobo.405.1">
     ) and measure the running time using the steady clock from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.406.1">
      &lt;chrono&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.407.1">
     library.
    </span>
    <span class="koboSpan" id="kobo.407.2">
     To do that, we simply record a time point representing the current point in time when the task starts by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.408.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.409.1">
auto start = std::chrono::high_resolution_clock::now();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     We can define
    </span>
    <a id="_idIndexMarker500">
    </a>
    <span class="koboSpan" id="kobo.411.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.412.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.413.1">
     function the following lambda function to be called when the task finishes to obtain the duration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      in milliseconds:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.415.1">
auto duration_from = [](auto start) {
Â Â Â Â auto dur = std::chrono::high_resolution_clock::now()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â - start;
Â Â Â Â return std::chrono::duration_cast
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;std::chrono::milliseconds&gt;(dur).count();
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.416.1">
     With that code in place, we can start measuring different approaches to how futures can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      be used.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     Letâ€™s start by running several asynchronous tasks but discarding the future returned
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.420.1">
       std::async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.421.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.422.1">
constexpr unsigned NUM_TASKS = 32;
auto start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
Â Â Â Â std::async(std::launch::async, func, i);
}
std::cout &lt;&lt; "Discarding futures: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; duration_from(start) &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     The duration of this test is 334 ms on my PC, a Pentium i7 4790K at 4 GHz with four cores and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      eight threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.425.1">
     For the next test, letâ€™s store the returned future, but donâ€™t wait for the result to be ready.
    </span>
    <span class="koboSpan" id="kobo.425.2">
     Obviously, this is not the right way of using computer power by spawning asynchronous tasks as consuming resources and not processing the results, but we are doing this for
    </span>
    <a id="_idIndexMarker501">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     testing and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      learning purposes:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.428.1">
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
Â Â Â Â auto fut = std::async(std::launch::async, func, i);
}
std::cout &lt;&lt; "In-place futures: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; duration_from(start) &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     In this case, the duration is still 334 ms.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     In both cases, a future is created, and when going out of scope at the end of each loop iteration, it must wait for the thread spawn by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.430.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.431.1">
     to finish
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.432.1">
      and join.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.433.1">
     As you can see, we are launching 32 tasks, each one consuming at least 10 ms.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     That totals 320 ms, a value equivalent to 334 ms obtained in these tests.
    </span>
    <span class="koboSpan" id="kobo.433.3">
     The remaining performance cost comes from starting threads, checking the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.434.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.435.1">
     loop variable, storing the time points when using the steady clock, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     To avoid creating a new future object each time
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.438.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.439.1">
     is called, and waiting for its destructor to be called, letâ€™s reuse the future object as shown in the following code.
    </span>
    <span class="koboSpan" id="kobo.439.2">
     Again, this is not the proper way as we are discarding access to the results of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.440.1">
      previous tasks:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.441.1">
std::future&lt;unsigned&gt; fut;
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
Â Â Â Â fut = std::async(std::launch::async, func, i);
}
std::cout &lt;&lt; "Reusing future: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; duration_from(start) &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.442.1">
     Now the duration
    </span>
    <a id="_idIndexMarker502">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     is 166 ms.
    </span>
    <span class="koboSpan" id="kobo.443.2">
     The reductions are due to not waiting for each future, as they are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.444.1">
      not destroyed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.445.1">
     But this is not ideal as we might be interested in knowing the result of the asynchronous tasks.
    </span>
    <span class="koboSpan" id="kobo.445.2">
     Therefore, we need to store the results in a vector.
    </span>
    <span class="koboSpan" id="kobo.445.3">
     Letâ€™s modify the previous example by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.446.1">
      res
     </span>
    </strong>
    <span class="koboSpan" id="kobo.447.1">
     vector to store the results from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      each task:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.449.1">
std::vector&lt;unsigned&gt; res;
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
Â Â Â Â auto fut = std::async(std::launch::async, func, i);
Â Â Â Â res.push_back(fut.get());
}
std::cout &lt;&lt; "Reused future and storing results: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; duration_from(start) &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     In this case, the duration goes back to 334 ms.
    </span>
    <span class="koboSpan" id="kobo.450.2">
     This is because we are again waiting for the results after spawning each task by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.451.1">
      fut.get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.452.1">
     before launching another asynchronous task.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     We are serializing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      tasksâ€™ execution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.454.1">
     A solution could be to store the futures returned by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     in a vector, and later traverse that vector
    </span>
    <a id="_idIndexMarker503">
    </a>
    <span class="koboSpan" id="kobo.457.1">
     and get the results.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     The following code illustrates how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.458.1">
      do this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.459.1">
std::vector&lt;unsigned&gt; res;
std::vector&lt;std::future&lt;unsigned&gt;&gt; futsVec;
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
Â Â Â Â futsVec.emplace_back(std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â func, i));
}
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
Â Â Â Â res.push_back( futsVec[i].get() );
}
std::cout &lt;&lt; "Futures vector and storing results: "
Â Â Â Â Â Â Â Â Â Â &lt;&lt; duration_from(start) &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.460.1">
     Now the duration is only 22 ms!
    </span>
    <span class="koboSpan" id="kobo.460.2">
     But why is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      that possible?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     Now all tasks are truly running asynchronously.
    </span>
    <span class="koboSpan" id="kobo.462.2">
     The first loop launches all tasks and stores the futures in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.463.1">
      futsVec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.464.1">
     vector.
    </span>
    <span class="koboSpan" id="kobo.464.2">
     There is no longer any waiting period due to future destructors
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      being called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.466.1">
     The second loop traverses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      futsVec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     , retrieves each result, and stores them in the results vector,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      res
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     .
    </span>
    <span class="koboSpan" id="kobo.470.2">
     The time to execute the second loop will be approximately the time needed to traverse the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      res
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     vector plus the time used by the slowest task to be scheduled
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      and executed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.474.1">
     If the system where the tests were running had enough threads to run all asynchronous tasks at once, the runtime could be halved.
    </span>
    <span class="koboSpan" id="kobo.474.2">
     There are systems that can automatically manage several asynchronous tasks under the hood by letting the scheduler decide what tasks to run.
    </span>
    <span class="koboSpan" id="kobo.474.3">
     In other systems, when trying to launch many threads at once, they might complain by
    </span>
    <a id="_idIndexMarker504">
    </a>
    <span class="koboSpan" id="kobo.475.1">
     raising an exception.
    </span>
    <span class="koboSpan" id="kobo.475.2">
     In the next section, we implement a thread limiter by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.476.1">
      using semaphores.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor154">
    </a>
    <span class="koboSpan" id="kobo.477.1">
     Limiting the number of threads
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     As we saw earlier, if there
    </span>
    <a id="_idIndexMarker505">
    </a>
    <span class="koboSpan" id="kobo.479.1">
     are not enough
    </span>
    <a id="_idIndexMarker506">
    </a>
    <span class="koboSpan" id="kobo.480.1">
     threads to run several
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.481.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.482.1">
     calls, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.483.1">
      std::runtime_system
     </span>
    </strong>
    <span class="koboSpan" id="kobo.484.1">
     exception can be thrown and indicate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.485.1">
      resource exhaustion.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.486.1">
     We can implement a simple solution by creating a thread limiter using counting semaphores (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.487.1">
      std::counting_semaphore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     ), a multithreading synchronization mechanism explained in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.489.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     The idea is to use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.492.1">
      std::counting_semaphore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.493.1">
     object, setting its initial value to the maximum concurrent tasks that the system allows, which can be retrieved by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      std::thread::hardware_concurrency()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     function, as learned in
    </span>
    <a href="B22219_02.xhtml#_idTextAnchor035">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.496.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.497.1">
     , and then use that semaphore in the task function to block if the total number of asynchronous tasks exceed the maximum
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      concurrent tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     The following
    </span>
    <a id="_idIndexMarker507">
    </a>
    <span class="koboSpan" id="kobo.500.1">
     snippet implements
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      this idea:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.502.1">
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;semaphore&gt;
#include &lt;syncstream&gt;
#include &lt;vector&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
void task(int id, std::counting_semaphore&lt;&gt;&amp; sem) {
Â Â Â Â sem.acquire();
Â Â Â Â sync_cout &lt;&lt; "Running task " &lt;&lt; id &lt;&lt; "...\n";
Â Â Â Â std::this_thread::sleep_for(1s);
Â Â Â Â sem.release();
}
int main() {
Â Â Â Â const int total_tasks = 20;
Â Â Â Â const int max_concurrent_tasks =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â std::thread::hardware_concurrency();
Â Â Â Â std::counting_semaphore&lt;&gt; sem(max_concurrent_tasks);
Â Â Â Â sync_cout &lt;&lt; "Allowing only "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; max_concurrent_tasks
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " concurrent tasks to run "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; total_tasks &lt;&lt; " tasks.\n";
Â Â Â Â std::vector&lt;std::future&lt;void&gt;&gt; futures;
Â Â Â Â for (int i = 0; i &lt; total_tasks; ++i) {
Â Â Â Â Â Â Â Â futures.push_back(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task, i, std::ref(sem)));
Â Â Â Â }
Â Â Â Â for (auto&amp; fut : futures) {
Â Â Â Â Â Â Â Â fut.get();
Â Â Â Â }
Â Â Â Â std::cout &lt;&lt; "All tasks completed." </span><span class="koboSpan" id="kobo.502.2">&lt;&lt; std::endl;
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     The program starts by setting the total number of tasks that will be launched.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     Then, it creates a counting semaphore,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.504.1">
      sem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     , setting its initial value to the hardware concurrency value, as explained earlier.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     Finally, it just launches all tasks and waits for their futures to be ready,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      as usual.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     The key point in
    </span>
    <a id="_idIndexMarker508">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     this
    </span>
    <a id="_idIndexMarker509">
    </a>
    <span class="koboSpan" id="kobo.509.1">
     example is that each task, before performing its job, acquires the semaphore, thus decrementing the internal counter or blocking until the counter can be decremented.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     When the job is done, the semaphore is released, which increments the internal counter and unblocks other tasks that try to acquire the semaphore at that time.
    </span>
    <span class="koboSpan" id="kobo.509.3">
     That means that a task will launch only if there is a free hardware thread to be used for that task.
    </span>
    <span class="koboSpan" id="kobo.509.4">
     Otherwise, it will be blocked until another task releases
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      the semaphore.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.511.1">
     Before exploring
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.512.1">
     some
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.513.1">
     real-life scenarios, letâ€™s first understand some drawbacks of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.515.1">
       std::async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.516.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor155">
    </a>
    <span class="koboSpan" id="kobo.517.1">
     When not to use std::async
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.518.1">
     As we have seen during
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.519.1">
     this chapter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.520.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     does not provide direct control over the number of threads used or access to the thread objects themselves.
    </span>
    <span class="koboSpan" id="kobo.521.2">
     We know now how to limit the number of asynchronous tasks by using counting semaphores, but there might be some applications where this is not the optimal solution and fine-grained control
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.522.1">
      is required.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     Also, the automatic management of threads can reduce performance by introducing overhead, especially when many small tasks are launched, leading to excessive context switching and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      resource contention.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.525.1">
     The implementation imposes some limit on the number of concurrent threads that can be used, which can degrade performance or even throw exceptions.
    </span>
    <span class="koboSpan" id="kobo.525.2">
     As
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.526.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.527.1">
     and the available
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.528.1">
      std::launch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.529.1">
     policies are implementation-dependent, the performance is not uniform across different compilers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.530.1">
      and platforms.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.531.1">
     Finally, in this chapter, we didnâ€™t mention how to cancel an asynchronous task started by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     as there is no standard way of doing so
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.534.1">
      before completion.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-157">
    <a id="_idTextAnchor156">
    </a>
    <span class="koboSpan" id="kobo.535.1">
     Practical examples
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.536.1">
     Now itâ€™s time to implement
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.537.1">
     some examples to tackle real-life scenarios using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     .
    </span>
    <span class="koboSpan" id="kobo.539.2">
     We will learn how to do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.540.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.541.1">
      Perform parallel computation
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.542.1">
       and aggregation
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.543.1">
      Asynchronously search across different containers or a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.544.1">
       large dataset
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.545.1">
      Asynchronously multiply
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.546.1">
       two matrices
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.547.1">
      Chain
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.548.1">
       asynchronous operations
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.549.1">
      Improve the pipeline example from the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.550.1">
       last chapter
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor157">
    </a>
    <span class="koboSpan" id="kobo.551.1">
     Parallel computation and aggregation
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.552.1">
      Data aggregation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     is the process
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     of collecting raw data from multiple sources and organizing, processing, and providing a summary of the data for easy consumption.
    </span>
    <span class="koboSpan" id="kobo.554.2">
     This process is useful in many fields, such as business reporting, financial services, healthcare, social media monitoring, research,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      and academia.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.556.1">
     As a naive example, letâ€™s compute the result of squaring all numbers between
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.557.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.558.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.559.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.560.1">
     and obtaining their average value.
    </span>
    <span class="koboSpan" id="kobo.560.2">
     We know that using the following formula to compute the sum of square values would be much quicker and require less computer power.
    </span>
    <span class="koboSpan" id="kobo.560.3">
     Also, the task could be more meaningful, but the purpose of this example is to understand the relationship between the tasks, not the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      task itself.
     </span>
    </span>
   </p>
   <p class="IMG---Figure">
    <span class="koboSpan" id="kobo.562.1">
     <img alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;munderover&gt;&lt;mo&gt;âˆ‘&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;msup&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" src="image/6.png" style="vertical-align:-0.781em;height:2.110em;width:12.191em"/>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.563.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.564.1">
      average_squares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.565.1">
     function in
    </span>
    <a id="_idIndexMarker515">
    </a>
    <span class="koboSpan" id="kobo.566.1">
     the following example launches an asynchronous task per value between
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.567.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.568.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.569.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.570.1">
     to compute the square value.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     The resulting future objects are stored in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.571.1">
      futsVec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.572.1">
     vector, which is later used by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.573.1">
      sum_results()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.574.1">
     function to compute the sum of the squared values.
    </span>
    <span class="koboSpan" id="kobo.574.2">
     The result is then divided by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.575.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.576.1">
     to obtain
    </span>
    <a id="_idIndexMarker516">
    </a>
    <span class="koboSpan" id="kobo.577.1">
     the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.578.1">
      average value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.579.1">
#include &lt;future&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int square(int x) {
Â Â Â Â return x * x;
}
int sum_results(std::vector&lt;std::future&lt;int&gt;&gt;&amp; futsVec) {
Â Â Â Â int sum = 0;
Â Â Â Â for (auto&amp; fut : futsVec) {
Â Â Â Â Â Â Â Â sum += fut.get();
Â Â Â Â }
Â Â Â Â return sum;
}
int average_squares(int n) {
Â Â Â Â std::vector&lt;std::future&lt;int&gt;&gt; futsVec;
Â Â Â Â for (int i = 1; i &lt;= n; ++i) {
Â Â Â Â Â Â Â Â futsVec.push_back(std::async(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â std::launch::async, square, i));
Â Â Â Â }
Â Â Â Â return double(sum_results(futures)) / n;
}
int main() {
Â Â Â Â int N = 100;
Â Â Â Â std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);
Â Â Â Â std::cout &lt;&lt; "Sum of squares for N = " &lt;&lt; N
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; Â« is Â« &lt;&lt; average_squares(N) &lt;&lt; '\n';
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.580.1">
     For example, for
    </span>
    <span class="koboSpan" id="kobo.581.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;100&lt;/mml:mn&gt;&lt;/mml:math&gt;" src="image/7.png" style="vertical-align:-0.012em;height:0.646em;width:3.562em"/>
    </span>
    <span class="koboSpan" id="kobo.582.1">
     , we can check that the value will be the same as the one returned by
    </span>
    <a id="_idIndexMarker517">
    </a>
    <span class="koboSpan" id="kobo.583.1">
     the function divided by
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.584.1">
       n
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.585.1">
      ,
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.586.1">
       3,383.50
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.587.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.588.1">
     This example can
    </span>
    <a id="_idIndexMarker518">
    </a>
    <span class="koboSpan" id="kobo.589.1">
     easily be modified to implement a solution using the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.590.1">
      MapReduce
     </span>
    </strong>
    <span class="koboSpan" id="kobo.591.1">
     programming model to handle large datasets
    </span>
    <a id="_idIndexMarker519">
    </a>
    <span class="koboSpan" id="kobo.592.1">
     efficiently.
    </span>
    <span class="koboSpan" id="kobo.592.2">
     MapReduce works by dividing the data processing into two phases; the Map phase, where independent chunks of data are filtered, sorted, and processed in parallel across multiple computers, and the Reduce phase where results from the Map phase are aggregated, summarizing the data.
    </span>
    <span class="koboSpan" id="kobo.592.3">
     This is like what we just implemented, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.593.1">
      square()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.594.1">
     function in the
    </span>
    <a id="_idIndexMarker520">
    </a>
    <span class="koboSpan" id="kobo.595.1">
     Map phase, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.596.1">
      average_squares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.597.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.598.1">
      sum_results()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.599.1">
     functions in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.600.1">
      Reduce phase.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-159">
    <a id="_idTextAnchor158">
    </a>
    <span class="koboSpan" id="kobo.601.1">
     Asynchronous searches
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.602.1">
     One way to speed up searching a target value into large containers is to parallelize the search.
    </span>
    <span class="koboSpan" id="kobo.602.2">
     Next, we will present two examples.
    </span>
    <span class="koboSpan" id="kobo.602.3">
     The first one involves searching across different containers by using one task per container, while the second one involves searching across a large container, dividing it into smaller segments, and using a task
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.603.1">
      per segment.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.604.1">
     Searching across different containers
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.605.1">
     In this example, we need to search for a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.606.1">
      target
     </span>
    </strong>
    <span class="koboSpan" id="kobo.607.1">
     value in
    </span>
    <a id="_idIndexMarker521">
    </a>
    <span class="koboSpan" id="kobo.608.1">
     different containers of diverse types (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.609.1">
      vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.610.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.611.1">
      list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.612.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      forward_list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     ) containing names
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.617.1">
      of animals:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.618.1">
#include &lt;algorithm&gt;
#include &lt;forward_list&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
int main() {
Â Â Â Â std::vector&lt;std::string&gt; africanAnimals =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â {"elephant", "giraffe", "lion", "zebra"};
Â Â Â Â std::list&lt;std::string&gt; americanAnimals =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â {"alligator", "bear", "eagle", "puma"};
Â Â Â Â std::forward_list&lt;std::string&gt; asianAnimals =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â {"orangutan", "panda", "tapir", "tiger"};
Â Â Â Â std::set&lt;std::string&gt; europeanAnimals =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â {Â«deerÂ», Â«hedgehogÂ», Â«linx", "wolf"};
Â Â Â Â std::string target = Â«elephantÂ»;
Â Â Â Â /* .... </span><span class="koboSpan" id="kobo.618.2">*/
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.619.1">
     To search for the target value, we launch an asynchronous task for each container, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.620.1">
      search()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.621.1">
     template function, which simply calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.622.1">
      std::find
     </span>
    </strong>
    <span class="koboSpan" id="kobo.623.1">
     function in a container and returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.624.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.625.1">
     if the target value is found, or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.626.1">
       false
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.627.1">
      otherwise:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.628.1">
template &lt;typename C&gt;
bool search(const C&amp; container, const std::string&amp; target) {
Â Â Â Â return std::find(container.begin(), container.end(),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â target) != container.end();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     These asynchronous tasks are launched using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.630.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.631.1">
     function with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      std::launch::async
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      launch
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker522">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      policy:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.635.1">
int main() {
Â Â Â Â /* .... </span><span class="koboSpan" id="kobo.635.2">*/
Â Â Â Â auto fut1 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â search&lt;std::vector&lt;std::string&gt;&gt;,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â africanAnimals, target);
Â Â Â Â auto fut2 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â search&lt;std::list&lt;std::string&gt;&gt;,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â americanAnimals, target);
Â Â Â Â auto fut3 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â search&lt;std::forward_list&lt;std::string&gt;&gt;,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â asianAnimals, target);
Â Â Â Â auto fut4 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â search&lt;std::set&lt;std::string&gt;&gt;,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â europeanAnimals, target);
Â Â Â Â /* .... </span><span class="koboSpan" id="kobo.635.3">*/</span></pre>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     Finally, we simply retrieve all return values from the futures created when using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.637.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.638.1">
     and bitwise
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.639.1">
      OR them:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.640.1">
int main() {
Â Â Â Â /* .... </span><span class="koboSpan" id="kobo.640.2">*/
Â Â Â Â bool found = fut1.get() || fut2.get() ||
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fut3.get() || fut4.get();
Â Â Â Â if (found) {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; target
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " found in one of the containers.\n";
Â Â Â Â } else {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; target
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " not found in any of "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; "the containers.\n";
Â Â Â Â }
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     This example also shows
    </span>
    <a id="_idIndexMarker523">
    </a>
    <span class="koboSpan" id="kobo.642.1">
     the power of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.643.1">
      Standard Template Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.644.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.645.1">
      STL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.646.1">
     ) as it
    </span>
    <a id="_idIndexMarker524">
    </a>
    <span class="koboSpan" id="kobo.647.1">
     provides generic and reusable algorithms that can be applied to different containers and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      data types.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.649.1">
     Searching in a large container
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     In the next example, we will implement a solution to find a target value in a large vector containing 5 million
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      integer values.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.652.1">
     To generate the vector, we use a random number generator with a uniform
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.653.1">
      integer distribution:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.654.1">
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;future&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;
// Generate a large vector of random integers using a uniform distribution
std::vector&lt;int&gt; generate_vector(size_t size) {
Â Â Â Â std::vector&lt;int&gt; vec(size);
Â Â Â Â std::random_device rd;
Â Â Â Â std::mt19937 gen(rd());
Â Â Â Â std::uniform_int_distribution&lt;&gt; dist(1, size);
Â Â Â Â std::generate(vec.begin(), vec.end(), [&amp;]() {
Â Â Â Â Â Â Â Â return dist(gen);
Â Â Â Â });
Â Â Â Â return vec;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.655.1">
     To search for a target value in
    </span>
    <a id="_idIndexMarker525">
    </a>
    <span class="koboSpan" id="kobo.656.1">
     a segment of a vector, we can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.657.1">
      std::find
     </span>
    </strong>
    <span class="koboSpan" id="kobo.658.1">
     function with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.659.1">
      begin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.660.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.661.1">
      end
     </span>
    </strong>
    <span class="koboSpan" id="kobo.662.1">
     iterators pointing to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.663.1">
      segment limits:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.664.1">
bool search_segment(const std::vector&lt;int&gt;&amp; vec, int target, size_t begin, size_t end) {
Â Â Â Â auto begin_it = vec.begin() + begin;
Â Â Â Â auto end_it = vec.begin() + end;
Â Â Â Â return std::find(begin_it, end_it, target) != end_it;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.665.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.666.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.667.1">
     function, we start by generating the large vector using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.668.1">
      generate_vector()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.669.1">
     function, then defining the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.670.1">
      target
     </span>
    </strong>
    <span class="koboSpan" id="kobo.671.1">
     value to find and the number of segments (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.672.1">
      num_segments
     </span>
    </strong>
    <span class="koboSpan" id="kobo.673.1">
     ) which the vector will be split for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.674.1">
      parallel searches:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.675.1">
const int target = 100;
std::vector&lt;int&gt; vec = generate_vector(5000000);
auto vec_size = vec.size();
size_t num_segments = 16;
size_t segment_size = vec.size() / num_segments;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.676.1">
     Then, for each segment, we define its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.677.1">
      begin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.678.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.679.1">
      end
     </span>
    </strong>
    <span class="koboSpan" id="kobo.680.1">
     iterators and launch an asynchronous task to search for the target value in that segment.
    </span>
    <span class="koboSpan" id="kobo.680.2">
     Thus, we execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.681.1">
      search_segment
     </span>
    </strong>
    <span class="koboSpan" id="kobo.682.1">
     asynchronously in a separate thread by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.683.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.685.1">
      std::launch::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.686.1">
     launch policy.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     To avoid copying the large vector when passing it as an input argument of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      search_segment
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     , we use a constant reference,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      std::cref
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     .
    </span>
    <span class="koboSpan" id="kobo.690.2">
     The futures
    </span>
    <a id="_idIndexMarker526">
    </a>
    <span class="koboSpan" id="kobo.691.1">
     returned by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.692.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.693.1">
     are stored in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.694.1">
       futs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.695.1">
      vector:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.696.1">
std::vector&lt;std::future&lt;bool&gt;&gt; futs;
for (size_t i = 0; i &lt; num_segments; ++i) {
Â Â Â Â auto begin = std::min(i * segment_size, vec_size);
Â Â Â Â auto end = std::min((i + 1) * segment_size, vec_size);
Â Â Â Â futs.push_back( std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â search_segment,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â std::cref(vec),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â target, begin, end) );
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.697.1">
     Note that the vector size is not always a multiple of the segment size, thus the last segment might be shorter than the others.
    </span>
    <span class="koboSpan" id="kobo.697.2">
     To deal with this situation and avoid issues when accessing out-of-bounds memory when checking the last segment, we need to properly set the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.698.1">
      begin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.699.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.700.1">
      end
     </span>
    </strong>
    <span class="koboSpan" id="kobo.701.1">
     indexes for each segment.
    </span>
    <span class="koboSpan" id="kobo.701.2">
     For that, we use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.702.1">
      std::min
     </span>
    </strong>
    <span class="koboSpan" id="kobo.703.1">
     to get the minimum value between the size of the vector and the hypothetical index of the last element in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.704.1">
      current segment.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.705.1">
     Finally, we check all results by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.706.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.707.1">
     on each future and print a message to the console if the target
    </span>
    <a id="_idIndexMarker527">
    </a>
    <span class="koboSpan" id="kobo.708.1">
     value was found in any of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.709.1">
      the segments:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.710.1">
bool found = false;
for (auto&amp; fut : futs) {
Â Â Â Â if (fut.get()) {
Â Â Â Â Â Â Â Â found = true;
Â Â Â Â Â Â Â Â break;
Â Â Â Â }
}
if (found) {
Â Â Â Â std::cout &lt;&lt; "Target " &lt;&lt; target
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " found in the large vector.\n";
} else {
Â Â Â Â std::cout &lt;&lt; "Target " &lt;&lt; target
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " not found in the large vector.\n";
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     This solution can be used as the base for more advanced solutions dealing with huge datasets in distributed systems where each asynchronous task tries to find a target value in a specific machine
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.712.1">
      or cluster.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-160">
    <a id="_idTextAnchor159">
    </a>
    <span class="koboSpan" id="kobo.713.1">
     Asynchronous matrix multiplication
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.714.1">
      Matrix multiplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.715.1">
     is one
    </span>
    <a id="_idIndexMarker528">
    </a>
    <span class="koboSpan" id="kobo.716.1">
     of the most relevant operations in
    </span>
    <a id="_idIndexMarker529">
    </a>
    <span class="koboSpan" id="kobo.717.1">
     computer science, used in many domains, such as computer graphics, computer vision, machine learning, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.718.1">
      scientific computing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.719.1">
     In the following example, we will implement a parallel computing solution by distributing the computation across
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      multiple threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.721.1">
     Letâ€™s start by defining a
    </span>
    <a id="_idIndexMarker530">
    </a>
    <span class="koboSpan" id="kobo.722.1">
     matrix type,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.723.1">
      matrix_t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.724.1">
     , as a vector of vectors holding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.725.1">
      integer values:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.726.1">
#include &lt;cmath&gt;
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using matrix_t = std::vector&lt;std::vector&lt;int&gt;&gt;;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.727.1">
     Then, we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.728.1">
      matrix_multiply
     </span>
    </strong>
    <span class="koboSpan" id="kobo.729.1">
     function, which accepts two matrices,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.730.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.731.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.732.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.733.1">
     , passing them as constant references, and returns their multiplication.
    </span>
    <span class="koboSpan" id="kobo.733.2">
     We know that if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.734.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.735.1">
     is a matrix
    </span>
    <span class="koboSpan" id="kobo.736.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/8.png" style="vertical-align:-0.012em;height:0.460em;width:1.790em"/>
    </span>
    <span class="koboSpan" id="kobo.737.1">
     (
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.738.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.739.1">
     stands for rows and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.740.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.741.1">
     for columns) and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     is a matrix
    </span>
    <span class="koboSpan" id="kobo.744.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;mml:mi&gt;q&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/9.png" style="vertical-align:-0.254em;height:0.772em;width:1.428em"/>
    </span>
    <span class="koboSpan" id="kobo.745.1">
     , we can multiply
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.746.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.747.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.748.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.749.1">
     if
    </span>
    <span class="koboSpan" id="kobo.750.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/10.png" style="vertical-align:-0.254em;height:0.772em;width:2.557em"/>
    </span>
    <span class="koboSpan" id="kobo.751.1">
     , and the resulting matrix will be of dimensions
    </span>
    <span class="koboSpan" id="kobo.752.1">
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;mml:mi&gt;q&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="image/11.png" style="vertical-align:-0.254em;height:0.702em;width:1.748em"/>
    </span>
    <span class="koboSpan" id="kobo.753.1">
     (
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.754.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.755.1">
     rows and
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.756.1">
       q
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.757.1">
      columns).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.758.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.759.1">
      matrix_multiply
     </span>
    </strong>
    <span class="koboSpan" id="kobo.760.1">
     function just starts by reserving some space to the result matrix,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.761.1">
      res
     </span>
    </strong>
    <span class="koboSpan" id="kobo.762.1">
     .
    </span>
    <span class="koboSpan" id="kobo.762.2">
     Then, it loops over the matrix by extracting column
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.763.1">
      j
     </span>
    </strong>
    <span class="koboSpan" id="kobo.764.1">
     from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.765.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.766.1">
     and multiplying it by row
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.767.1">
      i
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.768.1">
      from
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.769.1">
       A
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.770.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.771.1">
matrix_t matrix_multiply(const matrix_t&amp; A,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const matrix_t&amp; B) {
Â Â Â Â if (A[0].size() != B.size()) {
Â Â Â Â Â Â Â Â throw new std::runtime_error(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â«Wrong matrices dimmensions.");
Â Â Â Â }
Â Â Â Â size_t rows = A.size();
Â Â Â Â size_t cols = B[0].size();
Â Â Â Â size_t inner_dim = B.size();
Â Â Â Â matrix_t res(rows, std::vector&lt;int&gt;(cols, 0));
Â Â Â Â std::vector&lt;std::future&lt;int&gt;&gt; futs;
Â Â Â Â for (auto i = 0; i &lt; rows; ++i) {
Â Â Â Â Â Â Â Â for (auto j = 0; j &lt; cols; ++j) {
Â Â Â Â Â Â Â Â Â Â Â Â std::vector&lt;int&gt; column(inner_dim);
Â Â Â Â Â Â Â Â Â Â Â Â for (size_t k = 0; k &lt; inner_dim; ++k) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â column[k] = B[k][j];
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â futs.push_back(std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dot_product,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â A[i], column));
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â for (auto i = 0; i &lt; rows; ++i) {
Â Â Â Â Â Â Â Â for (auto j = 0; j &lt; cols; ++j) {
Â Â Â Â Â Â Â Â Â Â Â Â res[i][j] = futs[i * cols + j].get();
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â return res;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.772.1">
     The multiplication
    </span>
    <a id="_idIndexMarker531">
    </a>
    <span class="koboSpan" id="kobo.773.1">
     is done
    </span>
    <a id="_idIndexMarker532">
    </a>
    <span class="koboSpan" id="kobo.774.1">
     asynchronously by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.775.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.776.1">
     with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.777.1">
      std::launch::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.778.1">
     launch policy, running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.779.1">
      dot_product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.780.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.780.2">
     Each returned future from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.781.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.782.1">
     is stored in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.783.1">
      futs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.784.1">
     vector.
    </span>
    <span class="koboSpan" id="kobo.784.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.785.1">
      dot_product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.786.1">
     function computes the dot product of vectors
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.787.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.789.1">
      b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.790.1">
     , representing a row from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.791.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.792.1">
     and a column from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.793.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.794.1">
     , by multiplying element by element and returning the sum of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.795.1">
      these products:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.796.1">
int dot_product(const std::vector&lt;int&gt;&amp; a,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const std::vector&lt;int&gt;&amp; b) {
Â Â Â Â int sum = 0;
Â Â Â Â for (size_t i = 0; i &lt; a.size(); ++i) {
Â Â Â Â Â Â Â Â sum += a[i] * b[i];
Â Â Â Â }
Â Â Â Â return sum;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.797.1">
     As the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.798.1">
      dot_product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.799.1">
     function expects two vectors, we need to extract each column from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.800.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.801.1">
     before launching each asynchronous task.
    </span>
    <span class="koboSpan" id="kobo.801.2">
     This also enhances the overall performance as the vectors might be stored in contiguous blocks of memory, thus being more cache-friendly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.802.1">
      during computation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.803.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.804.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.805.1">
     function, we
    </span>
    <a id="_idIndexMarker533">
    </a>
    <span class="koboSpan" id="kobo.806.1">
     just define two matrices,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.807.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.808.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.809.1">
      B
     </span>
    </strong>
    <span class="koboSpan" id="kobo.810.1">
     , and use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.811.1">
      matrix_multipy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.812.1">
     function to compute their product.
    </span>
    <span class="koboSpan" id="kobo.812.2">
     All matrices are printed into the console using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.813.1">
      show_matrix
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.814.1">
      lambda function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.815.1">
int main() {
Â Â Â Â auto show_matrix = [](const std::string&amp; name,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â matrix_t&amp; mtx) {
Â Â Â Â Â Â Â Â std::cout &lt;&lt; name &lt;&lt; '\n';
Â Â Â Â Â Â Â Â for (const auto&amp; row : mtx) {
Â Â Â Â Â Â Â Â Â Â Â Â for (const auto&amp; elem : row) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â std::cout &lt;&lt; elem &lt;&lt; " ";
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â std::cout &lt;&lt; '\n';
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â std::cout &lt;&lt; std::endl;
Â Â Â Â };
Â Â Â Â matrix_t A = {{1, 2, 3},
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {4, 5, 6}};
Â Â Â Â matrix_t B = {{7, 8, 9},
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {10, 11, 12},
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {13, 14, 15}};
Â Â Â Â auto res = matrix_multiply(A, B);
Â Â Â Â show_matrix("A", A);
Â Â Â Â show_matrix("B", B);
Â Â Â Â show_matrix("Result", res);
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.816.1">
     This is the
    </span>
    <a id="_idIndexMarker534">
    </a>
    <span class="koboSpan" id="kobo.817.1">
     output
    </span>
    <a id="_idIndexMarker535">
    </a>
    <span class="koboSpan" id="kobo.818.1">
     from running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.819.1">
      this example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.820.1">
A
1 2 3
4 5 6
B
7 8 9
10 11 12
13 14 15
Result
66 72 78
156 171 186</span></pre>
   <p>
    <span class="koboSpan" id="kobo.821.1">
     Using contiguous memory blocks improves performance when traversing vectors as many of their elements can
    </span>
    <a id="_idIndexMarker536">
    </a>
    <span class="koboSpan" id="kobo.822.1">
     be read at once into the cache.
    </span>
    <span class="koboSpan" id="kobo.822.2">
     Using contiguous memory allocation is not guaranteed when using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.823.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     , therefore it might be better to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.825.1">
      new
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.826.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.827.1">
       malloc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.828.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-161">
    <a id="_idTextAnchor160">
    </a>
    <span class="koboSpan" id="kobo.829.1">
     Chain asynchronous operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.830.1">
     In this example, we will implement a simple pipeline composed of three stages where each stage takes the result from the previous stage and computes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.831.1">
      a value.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer047">
     <span class="koboSpan" id="kobo.832.1">
      <img alt="Figure 7.1 â€“ Simple pipeline example" src="image/B22219_07_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.833.1">
     Figure 7.1 â€“ Simple pipeline example
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.834.1">
     The first stage only
    </span>
    <a id="_idIndexMarker537">
    </a>
    <span class="koboSpan" id="kobo.835.1">
     accepts positive integers as input, otherwise it raises an exception, and adds 10 to that value before returning the result.
    </span>
    <span class="koboSpan" id="kobo.835.2">
     The second stage multiplies its input by 2, and the third subtracts 5 from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.836.1">
      its input:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.837.1">
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
int stage1(int x) {
Â Â Â Â if (x &lt; 0) throw std::runtime_error(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Negative input not allowed");
Â Â Â Â return x + 10;
}
int stage2(int x) {
Â Â Â Â return x * 2;
}
int stage3(int x) {
Â Â Â Â return x - 5;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.838.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.839.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.840.1">
     function, for the intermediate and final stages, we define the pipeline by using as input the futures generated by the previous stages.
    </span>
    <span class="koboSpan" id="kobo.840.2">
     These futures are passed by reference to the lambda expression running the asynchronous code, where their
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.841.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     function is used to get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.843.1">
      their result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.844.1">
     To retrieve the result from the pipeline, we just need to call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.845.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.846.1">
     function from the future returned by the last stage.
    </span>
    <span class="koboSpan" id="kobo.846.2">
     If an exception happens, for example, when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.847.1">
      input_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.848.1">
     is negative, it is
    </span>
    <a id="_idIndexMarker538">
    </a>
    <span class="koboSpan" id="kobo.849.1">
     caught by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.850.1">
      try-catch block:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.851.1">
int main() {
Â Â Â Â int input_value = 5;
Â Â Â Â try {
Â Â Â Â Â Â Â Â auto fut1 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â stage1, input_value);
Â Â Â Â Â Â Â Â auto fut2 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â [&amp;fut1]() {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return stage2(fut1.get()); });
Â Â Â Â Â Â Â Â auto fut3 = std::async(std::launch::async,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â [&amp;fut2]() {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return stage3(fut2.get()); });
Â Â Â Â Â Â Â Â int final_result = fut3.get();
Â Â Â Â Â Â Â Â std::cout &lt;&lt; "Final Result: "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; final_result &lt;&lt; std::endl;
Â Â Â Â } catch (const std::exception &amp;ex) {
Â Â Â Â Â Â Â Â std::cerr &lt;&lt; "Exception caught: "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; ex.what() &lt;&lt; std::endl;
Â Â Â Â }
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.852.1">
     The pipeline defined in this example is a simple one where each stage uses the future from the previous stage to get the input value and produce its result.
    </span>
    <span class="koboSpan" id="kobo.852.2">
     In the next example, we will rewrite the
    </span>
    <a id="_idIndexMarker539">
    </a>
    <span class="koboSpan" id="kobo.853.1">
     pipeline implemented in the previous chapter using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.854.1">
      std:async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.855.1">
     with deferred launch policies to only execute the stages that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.856.1">
      are needed.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor161">
    </a>
    <span class="koboSpan" id="kobo.857.1">
     Asynchronous pipeline
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.858.1">
     As promised, in the last chapter, when we were implementing a pipeline, we mentioned that the different
    </span>
    <a id="_idIndexMarker540">
    </a>
    <span class="koboSpan" id="kobo.859.1">
     tasks could be kept switched off until needed by using futures with deferred execution.
    </span>
    <span class="koboSpan" id="kobo.859.2">
     As also mentioned, this is useful in scenarios where the computation cost is high, but the result may not always be needed.
    </span>
    <span class="koboSpan" id="kobo.859.3">
     As futures with deferred status can only be created by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.860.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.861.1">
     , now itâ€™s time to see how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.862.1">
      do that.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.863.1">
     We will implement the same pipeline described in the previous chapter, which follows the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.864.1">
      task graph:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer048">
     <span class="koboSpan" id="kobo.865.1">
      <img alt="Figure 7.2 â€“ Pipeline example" src="image/B22219_07_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.866.1">
     Figure 7.2 â€“ Pipeline example
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.867.1">
     We start by defining the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.868.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.869.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.869.2">
     This class is like the one implemented in an example in the previous chapter but using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     function and storing the returned future instead of the promise used previously.
    </span>
    <span class="koboSpan" id="kobo.871.2">
     Here, we will only comment on the relevant code changes from that example, so please look at that example for a full explanation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     class or check it out in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.874.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.875.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.876.1">
     constructors store the task identifier (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.877.1">
      id_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.878.1">
     ), the function to launch (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.879.1">
      func_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.880.1">
     ), and whether the task has dependencies (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.881.1">
      has_dependency_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.882.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.882.2">
     It also starts the asynchronous task in deferred launch mode by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.883.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.884.1">
     with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.885.1">
      std::launch::deferred
     </span>
    </strong>
    <span class="koboSpan" id="kobo.886.1">
     launch policy, meaning that the task is created but not started until needed.
    </span>
    <span class="koboSpan" id="kobo.886.2">
     The
    </span>
    <a id="_idIndexMarker541">
    </a>
    <span class="koboSpan" id="kobo.887.1">
     returned future is stored in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.888.1">
       fut_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.889.1">
      variable:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.890.1">
template &lt;typename Func&gt;
class Task {
Â Â Â public:
Â Â Â Â Task(int id, Func&amp; func)
Â Â Â Â Â Â Â Â : id_(id), func_(func), has_dependency_(false) {
Â Â Â Â Â Â Â Â sync_cout &lt;&lt; "Task " &lt;&lt; id
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " constructed without dependencies.\n";
Â Â Â Â Â Â Â Â fut_ = std::async(std::launch::deferred,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â [this](){ (*this)(); });
Â Â Â Â }
Â Â Â Â template &lt;typename... </span><span class="koboSpan" id="kobo.890.2">Futures&gt;
Â Â Â Â Task(int id, Func&amp; func, Futures&amp;&amp;... </span><span class="koboSpan" id="kobo.890.3">futures)
Â Â Â Â Â Â Â Â : id_(id), func_(func), has_dependency_(true) {
Â Â Â Â Â Â Â Â sync_cout &lt;&lt; "Task " &lt;&lt; id
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; " constructed with dependencies.\n";
Â Â Â Â Â Â Â Â fut_ = std::async(std::launch::deferred,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â [this](){ (*this)(); });
Â Â Â Â Â Â Â Â add_dependencies(std::forward&lt;Futures&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (futures)...);
Â Â Â Â }
Â Â Â private:
Â Â Â Â int id_;
Â Â Â Â Func&amp; func_;
Â Â Â Â std::future&lt;void&gt; fut_;
Â Â Â Â std::vector&lt;std::shared_future&lt;void&gt;&gt; deps_;
Â Â Â Â bool has_dependency_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.891.1">
     The asynchronous tasks started by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.892.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.893.1">
     call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.894.1">
      operator()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.895.1">
     of their own instance (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     object).
    </span>
    <span class="koboSpan" id="kobo.897.2">
     When that happens,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      wait_completion()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     is called, checking whether all futures in the shared future vector,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.900.1">
      deps_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.901.1">
     , storing dependent tasks are valid by calling
    </span>
    <a id="_idIndexMarker542">
    </a>
    <span class="koboSpan" id="kobo.902.1">
     their
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.903.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.904.1">
     function, and if so, waiting for them to finish by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.905.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.906.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.906.2">
     When all dependent
    </span>
    <a id="_idIndexMarker543">
    </a>
    <span class="koboSpan" id="kobo.907.1">
     tasks are complete, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.908.1">
      func_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.909.1">
     function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.910.1">
      is called:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.911.1">
public:
void operator()() {
Â Â Â Â sync_cout &lt;&lt; "Starting task " &lt;&lt; id_ &lt;&lt; std::endl;
Â Â Â Â wait_completion();
Â Â Â Â sync_cout &lt;&lt; "Running task " &lt;&lt; id_ &lt;&lt; std::endl;
Â Â Â Â func_();
}
private:
void wait_completion() {
Â Â Â Â sync_cout &lt;&lt; "Waiting completion for task "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; id_ &lt;&lt; std::endl;
Â Â Â Â if (!deps_.empty()) {
Â Â Â Â Â Â Â Â for (auto&amp; fut : deps_) {
Â Â Â Â Â Â Â Â Â Â Â Â if (fut.valid()) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â sync_cout &lt;&lt; "Fut valid so getting "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; "value in task " &lt;&lt; id_
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; std::endl;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fut.get();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.912.1">
     There is also a new
    </span>
    <a id="_idIndexMarker544">
    </a>
    <span class="koboSpan" id="kobo.913.1">
     member function,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.914.1">
      start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.915.1">
     , that waits for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.916.1">
      fut_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.917.1">
     future created during the task construction when calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.918.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.919.1">
     .
    </span>
    <span class="koboSpan" id="kobo.919.2">
     This will be used to trigger the pipeline by requesting the result of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.920.1">
      last task:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.921.1">
public:
void start() {
Â Â Â Â fut_.get();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.922.1">
     As in the example in the previous chapter, we also define a member function called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.923.1">
      get_dependency()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.924.1">
     that returns a shared future constructed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.925.1">
      from
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.926.1">
       fut_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.927.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.928.1">
std::shared_future&lt;void&gt; get_dependency() {
Â Â Â Â sync_cout &lt;&lt; "Getting future from task "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;&lt; id_ &lt;&lt; std::endl;
Â Â Â Â return fut_;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.929.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.930.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.931.1">
     function, we define the pipeline by chaining task objects and setting their dependencies and the
    </span>
    <a id="_idIndexMarker545">
    </a>
    <span class="koboSpan" id="kobo.932.1">
     lambda function to run,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.933.1">
      sleep1s
     </span>
    </strong>
    <span class="koboSpan" id="kobo.934.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.935.1">
      sleep2s
     </span>
    </strong>
    <span class="koboSpan" id="kobo.936.1">
     , following the diagram
    </span>
    <a id="_idIndexMarker546">
    </a>
    <span class="koboSpan" id="kobo.937.1">
     shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.938.1">
       Figure 7
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.939.1">
       .2
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.940.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.941.1">
int main() {
Â Â Â Â auto sleep1s = [](){
Â Â Â Â Â Â Â Â std::this_thread::sleep_for(1s);
Â Â Â Â };
Â Â Â Â auto sleep2s = [](){
Â Â Â Â Â Â Â Â std::this_thread::sleep_for(2s);
Â Â Â Â };
Â Â Â Â Task task1(1, sleep1s);
Â Â Â Â Task task2(2, sleep2s, task1.get_dependency());
Â Â Â Â Task task3(3, sleep1s, task2.get_dependency());
Â Â Â Â Task task4(4, sleep2s, task2.get_dependency());
Â Â Â Â Task task5(5, sleep2s, task3.get_dependency(),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task4.get_dependency());
Â Â Â Â sync_cout &lt;&lt; "Starting the pipeline..." </span><span class="koboSpan" id="kobo.941.2">&lt;&lt; std::endl;
Â Â Â Â task5.start();
Â Â Â Â sync_cout &lt;&lt; "All done!" </span><span class="koboSpan" id="kobo.941.3">&lt;&lt; std::endl;
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.942.1">
     Starting the pipeline is as simple as getting the result from the last taskâ€™s future.
    </span>
    <span class="koboSpan" id="kobo.942.2">
     We can do that by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.943.1">
      start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     method of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.945.1">
      task5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.946.1">
     .
    </span>
    <span class="koboSpan" id="kobo.946.2">
     This will recursively call their dependency tasks by using the dependency vector and start the deferred
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.947.1">
      asynchronous tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.948.1">
     This is the
    </span>
    <a id="_idIndexMarker547">
    </a>
    <span class="koboSpan" id="kobo.949.1">
     output of
    </span>
    <a id="_idIndexMarker548">
    </a>
    <span class="koboSpan" id="kobo.950.1">
     executing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.951.1">
      preceding code:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.952.1">
Task 1 constructed without dependencies.
</span><span class="koboSpan" id="kobo.952.2">Getting future from task 1
Task 2 constructed with dependencies.
</span><span class="koboSpan" id="kobo.952.3">Getting future from task 2
Task 3 constructed with dependencies.
</span><span class="koboSpan" id="kobo.952.4">Getting future from task 2
Task 4 constructed with dependencies.
</span><span class="koboSpan" id="kobo.952.5">Getting future from task 4
Getting future from task 3
Task 5 constructed with dependencies.
</span><span class="koboSpan" id="kobo.952.6">Starting the pipeline...
</span><span class="koboSpan" id="kobo.952.7">Starting task 5
Waiting completion for task 5
Fut valid so getting value in task 5
Starting task 3
Waiting completion for task 3
Fut valid so getting value in task 3
Starting task 2
Waiting completion for task 2
Fut valid so getting value in task 2
Starting task 1
Waiting completion for task 1
Running task 1
Running task 2
Running task 3
Fut valid so getting value in task 5
Starting task 4
Waiting completion for task 4
Running task 4
Running task 5
All done!</span></pre>
   <p>
    <span class="koboSpan" id="kobo.953.1">
     We can see how the pipeline is created by calling each taskâ€™s constructor and getting the futures from previous
    </span>
    <a id="_idIndexMarker549">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.954.1">
      dependent tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.955.1">
     Then, when the pipeline is triggered,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.956.1">
      task5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.957.1">
     is started, starting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.958.1">
      task3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.959.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.960.1">
      task2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.961.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.962.1">
      task1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.963.1">
     recursively.
    </span>
    <span class="koboSpan" id="kobo.963.2">
     As
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.964.1">
      task1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.965.1">
     has no dependencies, it doesnâ€™t need to wait for any other task to run its work, so it completes, allowing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.966.1">
      task2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.967.1">
     to complete, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.968.1">
      later
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.969.1">
       task3
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.970.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.971.1">
     Next,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.972.1">
      task5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.973.1">
     continues checking its dependent tasks, so itâ€™s now
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.974.1">
      task4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.975.1">
     â€˜s turn to run.
    </span>
    <span class="koboSpan" id="kobo.975.2">
     Since all
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.976.1">
      task4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.977.1">
     â€˜s dependent tasks are complete,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.978.1">
      task4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.979.1">
     just executes, allowing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.980.1">
      task5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.981.1">
     to run afterward, thus completing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.982.1">
      the pipeline.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.983.1">
     This example can be improved by performing real computations and transferring results between tasks.
    </span>
    <span class="koboSpan" id="kobo.983.2">
     Also, instead of deferred tasks, we could also think of stages with several parallel steps that can
    </span>
    <a id="_idIndexMarker550">
    </a>
    <span class="koboSpan" id="kobo.984.1">
     be computed in separate
    </span>
    <a id="_idIndexMarker551">
    </a>
    <span class="koboSpan" id="kobo.985.1">
     threads.
    </span>
    <span class="koboSpan" id="kobo.985.2">
     Feel free to implement these improvements as an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.986.1">
      additional exercise.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-163">
    <a id="_idTextAnchor162">
    </a>
    <span class="koboSpan" id="kobo.987.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.988.1">
     In this chapter, we learned about
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.989.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.990.1">
     , how to use this function to execute asynchronous tasks, how to define its behavior by using launch policies, and how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.991.1">
      handle exceptions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.992.1">
     We also now understand how the futures returned by the async function can impact performance and how to use them wisely.
    </span>
    <span class="koboSpan" id="kobo.992.2">
     Also, we saw how to limit the number of asynchronous tasks by the number of available threads in the system by using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.993.1">
      counting semaphores.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.994.1">
     We also mentioned some scenarios where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.995.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.996.1">
     might not be the best tool for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.997.1">
      the job.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.998.1">
     Finally, we implemented several examples covering real-life scenarios, which is useful for parallelizing many
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.999.1">
      common tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1000.1">
     With all the knowledge acquired in this chapter, now we know when (and when not) to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1001.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1002.1">
     function to run asynchronous tasks in parallel, improving the overall performance of applications, achieving better computer resource usage, and reducing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1003.1">
      resource exhaustion.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1004.1">
     In the next chapter, we will learn how to achieve asynchronous execution by using coroutines, which have been available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1005.1">
      since C++20.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-164">
    <a id="_idTextAnchor163">
    </a>
    <span class="koboSpan" id="kobo.1006.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1007.1">
       Effective Modern C++
      </span>
     </em>
     <span class="koboSpan" id="kobo.1008.1">
      :
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1009.1">
       42 Specific Ways to Improve Your Use of C++11 and C++14
      </span>
     </em>
     <span class="koboSpan" id="kobo.1010.1">
      , Scott Meyers, Oâ€™Reilly Media, Inc., 1st Edition â€“
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1011.1">
       Chapter 7
      </span>
     </span>
     <span class="koboSpan" id="kobo.1012.1">
      , Item 35 and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1013.1">
       Item 36
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1014.1">
        std::async
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1015.1">
       :
      </span>
     </span>
     <a href="https://en.cppreference.com/w/cpp/thread/async">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1016.1">
        https://en.cppreference.com/w/cpp/thread/async
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1017.1">
        std::launch
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1018.1">
       :
      </span>
     </span>
     <a href="https://en.cppreference.com/w/cpp/thread/launch">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1019.1">
        https://en.cppreference.com/w/cpp/thread/launch
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1020.1">
      Strassen
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1021.1">
       algorithm:
      </span>
     </span>
     <a href="https://en.wikipedia.org/wiki/Strassen_algorithm">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1022.1">
        https://en.wikipedia.org/wiki/Strassen_algorithm
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1023.1">
      Karatsuba
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1024.1">
       algorithm:
      </span>
     </span>
     <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1025.1">
        https://en.wikipedia.org/wiki/Karatsuba_algorithm
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1026.1">
       OpenBLAS:
      </span>
     </span>
     <a href="https://www.openblas.net">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1027.1">
        https://www.openblas.net
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1028.1">
      BLIS
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1029.1">
       library:
      </span>
     </span>
     <a href="https://github.com/flame/blis">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1030.1">
        https://github.com/flame/blis
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1031.1">
       MapReduce:
      </span>
     </span>
     <a href="https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1032.1">
        https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html
       </span>
      </span>
     </a>
    </li>
   </ul>
  </div>
 </body></html>