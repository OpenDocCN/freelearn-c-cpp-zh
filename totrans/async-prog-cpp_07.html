<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-144">
    <a id="_idTextAnchor143">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-145">
    <a id="_idTextAnchor144">
    </a>
    
     The Async Function
    
   </h1>
   <p>
    
     In the previous chapter, we learned about promises, futures, and packaged tasks.
    
    
     When we introduced packaged tasks, we mentioned that
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     provides a simpler way to achieve the same result, with less code and thus being cleaner and
    
    
     
      more concise.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      async function
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     ) is a function
    
    <a id="_idIndexMarker465">
    </a>
    
     template that runs a callable object asynchronously where we can also select the method of execution by passing some flags defining the launch policy.
    
    
     It is a powerful tool for handling asynchronous operations, but its automatic management and lack of control over the thread of execution, among other aspects, can also make it unsuitable for certain tasks where fine-grained control or cancellation
    
    
     
      is required.
     
    
   </p>
   <p>
    
     In this chapter, we are going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      What is the async function and how do we
     
     
      
       use it?
      
     
    </li>
    <li>
     
      What are the different
     
     
      
       launch policies?
      
     
    </li>
    <li>
     
      What are the differences from previous methods, especially
     
     
      
       packaged tasks?
      
     
    </li>
    <li>
     
      What are the advantages and disadvantages of
     
     
      
       using
      
     
     
      <strong class="source-inline">
       
        std::async
       
      </strong>
     
     
      
       ?
      
     
    </li>
    <li>
     
      Practical scenarios
     
     
      
       and examples
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-146">
    <a id="_idTextAnchor145">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The async function has been available since C++11, but some examples use features from C++14, such as
    
    <strong class="source-inline">
     
      chrono_literals
     
    </strong>
    
     , and C++20, such as
    
    <strong class="source-inline">
     
      counting_semaphore
     
    </strong>
    
     , so the code shown in this chapter can be compiled by compilers
    
    
     
      supporting C++20.
     
    
   </p>
   <p>
    
     Please check the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section in
    
    <a href="B22219_03.xhtml#_idTextAnchor051">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     , for guidance on how to install GCC 13 and Clang
    
    
     
      8 compilers.
     
    
   </p>
   <p>
    
     You can find all the complete code in the following
    
    
     
      GitHub repository:
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
   </p>
   <p>
    
     The examples for this chapter are located under the
    
    <strong class="source-inline">
     
      Chapter_07
     
    </strong>
    
     folder.
    
    
     All source code files can be compiled using CMake
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
cmake . &amp;&amp; cmake —build .</pre>
   <p>
    
     Executable binaries will be generated under the
    
    
     <strong class="source-inline">
      
       bin
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor146">
    </a>
    
     What is std::async?
    
   </h1>
   <p>
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     is a function template in C++ introduced by the C++ standard in the
    
    <strong class="source-inline">
     
      &lt;future&gt;
     
    </strong>
    
     header as part of the thread support library from C++11.
    
    
     It is used to run a function asynchronously, allowing the main thread (or other threads) to continue
    
    
     
      running concurrently.
     
    
   </p>
   <p>
    
     In summary,
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     is a powerful tool for asynchronous programming in C++, making it easier to run
    
    <a id="_idIndexMarker466">
    </a>
    
     tasks in parallel and manage their
    
    
     
      results efficiently.
     
    
   </p>
   <h2 id="_idParaDest-148">
    <a id="_idTextAnchor147">
    </a>
    
     Launching an asynchronous task
    
   </h2>
   <p>
    
     To execute a function
    
    <a id="_idIndexMarker467">
    </a>
    
     asynchronously
    
    <a id="_idIndexMarker468">
    </a>
    
     using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     , we can use the same approaches we used when starting threads in
    
    <a href="B22219_03.xhtml#_idTextAnchor051">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     , with the different
    
    
     
      callable objects.
     
    
   </p>
   <p>
    
     One approach is using a
    
    
     
      function pointer:
     
    
   </p>
   <pre class="source-code">
void func() {
    std::cout &lt;&lt; "Using function pointer\n";
}
auto fut1 = std::async(func);</pre>
   <p>
    
     Another approach is using a
    
    
     
      lambda function:
     
    
   </p>
   <pre class="source-code">
auto lambda_func = []() {
    std::cout &lt;&lt; "Using lambda function\n";
};
auto fut2 = std::async(lambda_func);</pre>
   <p>
    
     We can also use an embedded
    
    
     
      lambda function:
     
    
   </p>
   <pre class="source-code">
auto fut3 = std::async([]() {
    std::cout &lt;&lt; "Using embedded lambda function\n";
});</pre>
   <p>
    
     We can use a function object where
    
    <strong class="source-inline">
     
      operator()
     
    </strong>
    
     
      is overloaded:
     
    
   </p>
   <pre class="source-code">
class FuncObjectClass {
   public:
    void operator()() {
        std::cout &lt;&lt; "Using function object class\n";
    }
};
auto fut4 = std::async(FuncObjectClass());</pre>
   <p>
    
     We can use a non-static
    
    <a id="_idIndexMarker469">
    </a>
    
     member function by
    
    <a id="_idIndexMarker470">
    </a>
    
     passing the address of the member function and the address of an object to call the
    
    
     
      member function:
     
    
   </p>
   <pre class="source-code">
class Obj {
  public:
    void func() {
        std::cout &lt;&lt; "Using a non-static member function"
                  &lt;&lt; std::endl;
    }
};
Obj obj;
auto fut5 = std::async(&amp;Obj::func, &amp;obj);</pre>
   <p>
    
     We can also use a static member function where only the address of the member function is needed as the method
    
    
     
      is static:
     
    
   </p>
   <pre class="source-code">
class Obj {
  public:
    static void static_func() {
        std::cout &lt;&lt; "Using a static member function"
                  &lt;&lt; std::endl;
    }
};
auto fut6 = std::async(&amp;Obj::static_func);</pre>
   <p>
    
     When
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     is called, it returns a future where the result of the function will be stored, as we already
    
    <a id="_idIndexMarker471">
    </a>
    
     learned in the
    
    <a id="_idIndexMarker472">
    </a>
    
     
      previous chapter.
     
    
   </p>
   <h2 id="_idParaDest-149">
    <a id="_idTextAnchor148">
    </a>
    
     Passing values
    
   </h2>
   <p>
    
     Again, similarly to
    
    <a id="_idIndexMarker473">
    </a>
    
     when we passed arguments when creating threads, arguments can be passed to the thread by value, by reference, or
    
    
     
      as pointers.
     
    
   </p>
   <p>
    
     Here, we can see how to pass arguments
    
    
     
      by value:
     
    
   </p>
   <pre class="source-code">
void funcByValue(const std::string&amp; str, int val) {
    std::cout &lt;&lt; «str: « &lt;&lt; str &lt;&lt; «, val: « &lt;&lt; val
              &lt;&lt; std::endl;
}
std::string str{"Passing by value"};
auto fut1 = async(funcByValue, str, 1);</pre>
   <p>
    
     Passing by value implies a copy as a temporary object is created and the argument value is copied into it.
    
    
     This avoids data races, but it is much
    
    
     
      more costly.
     
    
   </p>
   <p>
    
     The next example shows how to pass values
    
    
     
      by reference:
     
    
   </p>
   <pre class="source-code">
void modifyValues(std::string&amp; str) {
    str += " (Thread)";
}
std::string str{"Passing by reference"};
auto fut2 = std::async(modifyValues, std::ref(str));</pre>
   <p>
    
     We can also pass
    
    <a id="_idIndexMarker474">
    </a>
    
     values as a
    
    
     <strong class="bold">
      
       const reference
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
void printVector(const std::vector&lt;int&gt;&amp; v) {
    std::cout &lt;&lt; "Vector: ";
    for (int num : v) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}
std::vector&lt;int&gt; v{1, 2, 3, 4, 5};
auto fut3 = std::async(printVector, std::cref(v));</pre>
   <p>
    
     Passing by reference is achieved by using
    
    <strong class="source-inline">
     
      std::ref()
     
    </strong>
    
     (non-constant references) or
    
    <strong class="source-inline">
     
      std::cref()
     
    </strong>
    
     (constant references), both defined in the
    
    <strong class="source-inline">
     
      &lt;functional&gt;
     
    </strong>
    
     header file, letting the variadic template (a class or function template that supports an arbitrary number of arguments) defining the thread constructor to treat the argument as a reference.
    
    
     Missing these functions when passing arguments means passing the arguments by value, which
    
    <a id="_idIndexMarker475">
    </a>
    
     implies a copy, as mentioned earlier, making the function call
    
    
     
      more costly.
     
    
   </p>
   <p>
    
     You can also move an object into the thread created by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     ,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
auto fut4 = std::async(printVector, std::move(v));</pre>
   <p>
    
     Note that the vector
    
    <strong class="source-inline">
     
      v
     
    </strong>
    
     is in a valid but empty state after its content
    
    
     
      being moved.
     
    
   </p>
   <p>
    
     Finally, we can also pass values by
    
    
     
      lambda captures:
     
    
   </p>
   <pre class="source-code">
std::string str5{"Hello"};
auto fut5 = std::async([&amp;]() {
    std::cout &lt;&lt; "str: " &lt;&lt; str5 &lt;&lt; std::endl;
});</pre>
   <p>
    
     In this example, the
    
    <strong class="source-inline">
     
      str
     
    </strong>
    
     variable is
    
    <a id="_idIndexMarker476">
    </a>
    
     accessed by the lambda function executed by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     as
    
    
     
      a reference.
     
    
   </p>
   <h2 id="_idParaDest-150">
    <a id="_idTextAnchor149">
    </a>
    
     Returning values
    
   </h2>
   <p>
    
     When
    
    <strong class="source-inline">
     
      std:async
     
    </strong>
    
     is called, it
    
    <a id="_idIndexMarker477">
    </a>
    
     immediately returns a future that will hold the value that the function or callable object will compute, as we saw in the previous chapter when using promises
    
    
     
      and futures.
     
    
   </p>
   <p>
    
     In the previous examples, we didn´t use the returned object from
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     at all.
    
    
     Let’s rewrite the last example from the
    
    <em class="italic">
     
      Packaged tasks
     
    </em>
    
     section in
    
    <a href="B22219_06.xhtml#_idTextAnchor125">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     , where we used a
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     object to compute the power of two values.
    
    
     But in this case, we will spawn several asynchronous tasks using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     to compute these values, wait for the tasks to finish, store the results, and finally, show them in
    
    
     
      the console:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;syncstream&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
int compute(unsigned taskId, int x, int y) {
    std::this_thread::sleep_for(std::chrono::milliseconds(
                               rand() % 200));
    sync_cout &lt;&lt; "Running task " &lt;&lt; taskId &lt;&lt; '\n';
    return std::pow(x, y);
}
int main() {
    std::vector&lt;std::future&lt;int&gt;&gt; futVec;
    for (int i = 0; i &lt;= 10; i++)
        futVec.emplace_back(std::async(compute,
                            i+1, 2, i));
    sync_cout &lt;&lt; "Waiting in main thread\n";
    std::this_thread::sleep_for(1s);
    std::vector&lt;int&gt; results;
    for (auto&amp; fut : futVec)
        results.push_back(fut.get());
    for (auto&amp; res : results)
        std::cout &lt;&lt; res &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      compute()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker478">
    </a>
    
     simply gets two numbers,
    
    <strong class="source-inline">
     
      x
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      y
     
    </strong>
    
     , and computes
    
    
     <img alt="&lt;mml:math  &gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" src="img/5.png" style="vertical-align:-0.012em;height:0.606em;width:0.788em"/>
    
    
     .
    
    
     It also gets a number representing the task identifier and waits for up to two seconds before printing a message in the console and computing
    
    
     
      the result.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, the main thread launches several tasks computing a sequence of power-of-two values.
    
    
     The futures returned by calling
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     are stored in the
    
    <strong class="source-inline">
     
      futVec
     
    </strong>
    
     vector.
    
    
     Then, the main thread waits for one second, emulating some work.
    
    
     Finally, we traverse the
    
    <strong class="source-inline">
     
      futVec
     
    </strong>
    
     vector and call the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function in each future element, thus waiting for that specific task to finish and return a value, and we store the returned value in another vector called
    
    <strong class="source-inline">
     
      results
     
    </strong>
    
     .
    
    
     Then, we print the content of the
    
    <strong class="source-inline">
     
      results
     
    </strong>
    
     vector before exiting
    
    
     
      the program.
     
    
   </p>
   <p>
    
     This is the output when running
    
    
     
      that program:
     
    
   </p>
   <pre class="console">
Waiting in main thread
Running task 11
Running task 9
Running task 2
Running task 8
Running task 4
Running task 6
Running task 10
Running task 3
Running task 1
Running task 7
Running task 5
1 2 4 8 16 32 64 128 256 512 1024</pre>
   <p>
    
     As we can see, each task took a different amount of time to complete, thus the output is not ordered by task identifier.
    
    
     But as we traverse the
    
    <strong class="source-inline">
     
      futVec
     
    </strong>
    
     vector in order when getting the results, these are shown as
    
    
     
      in order.
     
    
   </p>
   <p>
    
     Now that we have
    
    <a id="_idIndexMarker479">
    </a>
    
     seen how to launch asynchronous tasks and pass arguments and return values, let’s learn how to use launch policies to control the methods
    
    
     
      of execution.
     
    
   </p>
   <h1 id="_idParaDest-151">
    <a id="_idTextAnchor150">
    </a>
    
     Launch policies
    
   </h1>
   <p>
    
     Apart from specifying
    
    <a id="_idIndexMarker480">
    </a>
    
     the function or callable
    
    <a id="_idIndexMarker481">
    </a>
    
     object as an argument when using the
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     function, we can also specify the
    
    <strong class="bold">
     
      launch policy
     
    </strong>
    
     .
    
    
     Launch policies control how
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     schedules the execution of asynchronous task.
    
    
     These are defined in the
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       future&gt;
      
     </strong>
    
    
     
      library.
     
    
   </p>
   <p>
    
     The launch policy must be specified as the first argument when calling
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     .
    
    
     This argument is of the type
    
    <strong class="source-inline">
     
      std::launch
     
    </strong>
    
     , a bitmask value where its bits control the allowed methods of execution, which can be one or more of the following
    
    
     
      enumeration constants:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       std::launch::async
      
     </strong>
     
      : The task is executed in a
     
     
      
       separate thread.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       std::launch::deferred
      
     </strong>
     
      : Enables lazy evaluation by executing the task in the calling thread the first time its result is requested via the future
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       wait()
      
     </strong>
     
      method.
     
     
      All further accesses to the same
     
     <strong class="source-inline">
      
       std::future
      
     </strong>
     
      will return the result immediately.
     
     
      That means that the task will only be executed when the result is explicitly requested, which can lead to
     
     
      
       unexpected delays.
      
     
    </li>
   </ul>
   <p>
    
     If not defined, by default the launch policy will be
    
    <strong class="source-inline">
     
      std::launch::async | std::launch::deferred
     
    </strong>
    
     .
    
    
     Also, implementations can provide additional
    
    
     
      launch policies.
     
    
   </p>
   <p>
    
     Therefore, by default the C++ standard states that
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     can run in either asynchronous or
    
    
     
      deferred mode.
     
    
   </p>
   <p>
    
     Note that when more
    
    <a id="_idIndexMarker482">
    </a>
    
     than one flag is specified, the behavior is implementation-defined, so depending on the compiler we are using.
    
    
     The standard recommends using available concurrency and deferring the task if the default launch policy
    
    
     
      is specified.
     
    
   </p>
   <p>
    
     Let’s implement the following example to test the different launch policy behaviors.
    
    
     First, we define the
    
    <strong class="source-inline">
     
      square()
     
    </strong>
    
     function, which will serve as the
    
    
     
      asynchronous task:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;syncstream&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
int square(const std::string&amp; task_name, int x) {
    sync_cout &lt;&lt; "Launching " &lt;&lt; task_name
              &lt;&lt; « task...\n»;
    return x * x;
}</pre>
   <p>
    
     Then, in the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, the program starts by launching three different asynchronous tasks, one using the
    
    <strong class="source-inline">
     
      std::launch::async
     
    </strong>
    
     launch policy, another task using the
    
    <strong class="source-inline">
     
      std::launch::deferred
     
    </strong>
    
     launch policy, and a third task using the default
    
    <a id="_idIndexMarker483">
    </a>
    
     
      launch
     
    
    
     <a id="_idIndexMarker484">
     </a>
    
    
     
      policy:
     
    
   </p>
   <pre class="source-code">
sync_cout &lt;&lt; "Starting main thread...\n";
auto fut_async = std::async(std::launch::async,
                           square, «async_policy", 2);
auto fut_deferred = std::async(std::launch::deferred,
                            square, «deferred_policy", 3);
auto fut_default = std::async(square,
                            «default_policy", 4);</pre>
   <p>
    
     As mentioned in the previous chapter,
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     returns a
    
    <strong class="source-inline">
     
      std::future_status
     
    </strong>
    
     object indicating whether the future is ready, deferred, or has timed out.
    
    
     Therefore, we can use that function to check whether any of the returned futures are deferred.
    
    
     We do that by using a lambda function,
    
    <strong class="source-inline">
     
      is_deferred()
     
    </strong>
    
     , that returns
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     in that case.
    
    
     At least one future object,
    
    <strong class="source-inline">
     
      fut_deferred
     
    </strong>
    
     , is expected to
    
    
     
      return
     
    
    
     <strong class="source-inline">
      
       true
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
auto is_deferred = [](std::future&lt;int&gt;&amp; fut) {
    return (fut.wait_for(0s) ==
            std::future_status::deferred);
};
sync_cout &lt;&lt; "Checking if deferred:\n";
sync_cout &lt;&lt; "  fut_async: " &lt;&lt; std::boolalpha
          &lt;&lt; is_deferred(fut_async) &lt;&lt; '\n';
sync_cout &lt;&lt; "  fut_deferred: " &lt;&lt; std::boolalpha
          &lt;&lt; is_deferred(fut_deferred) &lt;&lt; '\n';
sync_cout &lt;&lt; "  fut_default: " &lt;&lt; std::boolalpha
          &lt;&lt; is_deferred(fut_default) &lt;&lt; '\n';</pre>
   <p>
    
     Then, the main program waits for one second, emulating some processing, and finally retrieves the results
    
    <a id="_idIndexMarker485">
    </a>
    
     from the asynchronous tasks
    
    <a id="_idIndexMarker486">
    </a>
    
     and prints
    
    
     
      their value:
     
    
   </p>
   <pre class="source-code">
sync_cout &lt;&lt; "Waiting in main thread...\n";
std::this_thread::sleep_for(1s);
sync_cout &lt;&lt; "Wait in main thread finished.\n";
sync_cout &lt;&lt; "Getting result from "
          &lt;&lt; "async policy task...\n";
int val_async = fut_async.get();
sync_cout &lt;&lt; "Result from async policy task: "
          &lt;&lt; val_async &lt;&lt; '\n';
sync_cout &lt;&lt; "Getting result from "
          &lt;&lt; "deferred policy task...\n";
int val_deferred = fut_deferred.get();
sync_cout &lt;&lt; "Result from deferred policy task: "
          &lt;&lt; val_deferred &lt;&lt; '\n';
sync_cout &lt;&lt; "Getting result from "
          &lt;&lt; "default policy task...\n";
int val_default = fut_default.get();
sync_cout &lt;&lt; "Result from default policy task: "
          &lt;&lt; val_default &lt;&lt; '\n';</pre>
   <p>
    
     This is the output
    
    <a id="_idIndexMarker487">
    </a>
    
     from running the
    
    
     
      preceding code:
     
    
   </p>
   <pre class="console">
Starting main thread...
Launching async_policy task...
Launching default_policy task...
Checking if deferred:
  fut_async: false
  fut_deferred: true
  fut_default: false
Waiting in main thread...
Wait in main thread finished.
Getting result from async policy task...
Result from async policy task: 4
Getting result from deferred policy task...
Launching deferred_policy task...
Result from deferred policy task: 9
Getting result from default policy task...
Result from default policy task: 16</pre>
   <p>
    
     Note how the tasks with
    
    <a id="_idIndexMarker488">
    </a>
    
     the default and
    
    <strong class="source-inline">
     
      std::launch::async
     
    </strong>
    
     launch policies are executed while the main thread is sleeping.
    
    
     Therefore, the
    
    <a id="_idIndexMarker489">
    </a>
    
     task is started as soon as it can be scheduled.
    
    
     Also note how the deferred task, using the
    
    <strong class="source-inline">
     
      std::launch::deferred
     
    </strong>
    
     launch policy, starts executing once the value
    
    
     
      is requested.
     
    
   </p>
   <p>
    
     Next, let’s learn how to handle exceptions happening in the
    
    
     
      asynchronous task.
     
    
   </p>
   <h1 id="_idParaDest-152">
    <a id="_idTextAnchor151">
    </a>
    
     Handling exceptions
    
   </h1>
   <p>
    
     Exception propagation
    
    <a id="_idIndexMarker490">
    </a>
    
     from the
    
    <a id="_idIndexMarker491">
    </a>
    
     asynchronous task to the main thread is not supported when using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     .
    
    
     To enable exception propagation, we might need a promise object to store the exception that later can be accessed by the future returned when calling
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     .
    
    
     But that promise object is not accessible or provided
    
    
     
      by
     
    
    
     <strong class="source-inline">
      
       std::async
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     One feasible way to achieve this is to use a
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     object wrapping the asynchronous task.
    
    
     But if that is the case, we should directly use a packaged task as described in the
    
    
     
      previous chapter.
     
    
   </p>
   <p>
    
     We could also use nested exceptions, available since C++11, by using
    
    <strong class="source-inline">
     
      std::nested_exception
     
    </strong>
    
     , a polymorphic mixin class that can capture and store the current exception, allowing nested exceptions of arbitrary types.
    
    
     From a
    
    <strong class="source-inline">
     
      std::nested_exception
     
    </strong>
    
     object, we can retrieve the stored exception by using the
    
    <strong class="source-inline">
     
      nested_ptr()
     
    </strong>
    
     method or rethrow it by
    
    
     
      calling
     
    
    
     <strong class="source-inline">
      
       rethrow_nested()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     To create a nested exception, we can throw an exception using the
    
    <strong class="source-inline">
     
      std::throw_with_nested()
     
    </strong>
    
     method.
    
    
     If we want to rethrow an exception only if it’s nested, we can use
    
    <strong class="source-inline">
     
      std::rethrow_if_nested()
     
    </strong>
    
     .
    
    
     All these functions are defined in the
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       exception&gt;
      
     </strong>
    
    
     
      header.
     
    
   </p>
   <p>
    
     Using all these functions, we can implement the following example, where an asynchronous task throws a
    
    <strong class="source-inline">
     
      std::runtime_error
     
    </strong>
    
     exception, which is caught in the main body of the asynchronous task and rethrown as a nested exception.
    
    
     This nested exception object is then caught again in the main function and the sequence of exceptions is printed out, as
    
    <a id="_idIndexMarker492">
    </a>
    
     shown in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
void print_exceptions(const std::exception&amp; e,
                      int level = 1) {
    auto indent = std::string(2 * level, ‹ ‹);
    std::cerr &lt;&lt; indent &lt;&lt; e.what() &lt;&lt; '\n';
    try {
        std::rethrow_if_nested(e);
    } catch (const std::exception&amp; nestedException) {
        print_exceptions(nestedException, level + 1);
    } catch (...) { }
}
void func_throwing() {
    throw std::runtime_error(
               «Exception in func_throwing");
}
int main() {
    auto fut = std::async([]() {
        try {
            func_throwing();
        } catch (...) {
            std::throw_with_nested(
                 std::runtime_error(
                      "Exception in async task."));
        }
    });
    try {
        fut.get();
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Caught exceptions:\n";
        print_exceptions(e);
    }
    return 0;
}</pre>
   <p>
    
     As we can see in the example, an asynchronous task is created that executes the
    
    <strong class="source-inline">
     
      func_throwing()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker493">
    </a>
    
     inside a
    
    <strong class="source-inline">
     
      try-catch
     
    </strong>
    
     block.
    
    
     This function simply throws a
    
    <strong class="source-inline">
     
      std::runtime_error
     
    </strong>
    
     exception, which is caught and then rethrown as part of a
    
    <strong class="source-inline">
     
      std::nested_exception
     
    </strong>
    
     class by using the
    
    <strong class="source-inline">
     
      std::throw_with_nested()
     
    </strong>
    
     function.
    
    
     Later, in the main thread, when we try to retrieve the result from the
    
    <strong class="source-inline">
     
      fut
     
    </strong>
    
     future object by calling its
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     method, the nested exception is thrown and captured again in the main try-catch block, where the
    
    <strong class="source-inline">
     
      print_exceptions()
     
    </strong>
    
     function is called with the captured nested exception as
    
    
     
      an argument.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      print_exceptions()
     
    </strong>
    
     function prints the reason for the current exception (
    
    <strong class="source-inline">
     
      e.what()
     
    </strong>
    
     ) and rethrows the exception if nested, thus catching it again and recursively printing exception reasons with indentation by
    
    
     
      nesting level.
     
    
   </p>
   <p>
    
     As each asynchronous
    
    <a id="_idIndexMarker494">
    </a>
    
     task has its own future, the
    
    <a id="_idIndexMarker495">
    </a>
    
     program can handle exceptions from multiple
    
    
     
      tasks separately.
     
    
   </p>
   <h2 id="_idParaDest-153">
    <a id="_idTextAnchor152">
    </a>
    
     Exceptions when calling std::async
    
   </h2>
   <p>
    
     Apart from exceptions happening in
    
    <a id="_idIndexMarker496">
    </a>
    
     the asynchronous task, there are also some cases when
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     might throw an exception.
    
    
     These exceptions are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       std::bad_alloc
      
     </strong>
     
      : If there is not enough memory to store internal data structures needed
     
     
      
       by
      
     
     
      <strong class="source-inline">
       
        std::async
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       std:system_error
      
     </strong>
     
      : If a new thread cannot be started when using
     
     <strong class="source-inline">
      
       std::launch::async
      
     </strong>
     
      as the launch policy.
     
     
      In this case, the error condition will be
     
     <strong class="source-inline">
      
       std::errc::resource_unavailable_try_again
      
     </strong>
     
      .
     
     
      Depending on the implementation, if the policy is the default one, it might fall back to deferred invocation or
     
     
      
       implementation-defined policies.
      
     
    </li>
   </ul>
   <p>
    
     Most of the time, these exceptions are thrown out due to resource exhaustion.
    
    
     A solution can be retrying later when some asynchronous tasks currently working have finished and released their resources.
    
    
     Another, more reliable, solution is to limit the number of asynchronous tasks running at a given time.
    
    
     We will implement this solution shortly, but first, let’s understand the futures returned by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     and how to achieve better
    
    <a id="_idIndexMarker497">
    </a>
    
     performance when
    
    <a id="_idIndexMarker498">
    </a>
    
     dealing
    
    
     
      with them.
     
    
   </p>
   <h1 id="_idParaDest-154">
    <a id="_idTextAnchor153">
    </a>
    
     Async futures and performance
    
   </h1>
   <p>
    
     Futures
    
    <a id="_idIndexMarker499">
    </a>
    
     returned by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     behave differently from the ones obtained from promises when their destructors are called.
    
    
     When these futures are destroyed, their
    
    <strong class="source-inline">
     
      ~future
     
    </strong>
    
     destructor is called where the
    
    <strong class="source-inline">
     
      wait()
     
    </strong>
    
     function is executed, causing the thread that was spawned at creation
    
    
     
      to join.
     
    
   </p>
   <p>
    
     That would impact the program performance by adding some overhead if the thread used by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     has not already been joined, therefore we need to understand when the future object will go out of scope and thus its destructor will
    
    
     
      be called.
     
    
   </p>
   <p>
    
     Let’s see, with several short examples, how these futures behave and some recommendations on how to
    
    
     
      use them.
     
    
   </p>
   <p>
    
     We start by defining a task,
    
    <strong class="source-inline">
     
      func
     
    </strong>
    
     , that simply multiplies its input value by 2 and also waits for some time, emulating a
    
    
     
      costly operation:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
unsigned func(unsigned x) {
    std::this_thread::sleep_for(10ms);
    return 2 * x;
}</pre>
   <p>
    
     To measure the performance of a block of code, we will asynchronously run several tasks (in this example,
    
    <strong class="source-inline">
     
      NUM_TASKS = 32
     
    </strong>
    
     ) and measure the running time using the steady clock from the
    
    <strong class="source-inline">
     
      &lt;chrono&gt;
     
    </strong>
    
     library.
    
    
     To do that, we simply record a time point representing the current point in time when the task starts by using the
    
    
     
      following command:
     
    
   </p>
   <pre class="source-code">
auto start = std::chrono::high_resolution_clock::now();</pre>
   <p>
    
     We can define
    
    <a id="_idIndexMarker500">
    </a>
    
     in the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function the following lambda function to be called when the task finishes to obtain the duration
    
    
     
      in milliseconds:
     
    
   </p>
   <pre class="source-code">
auto duration_from = [](auto start) {
    auto dur = std::chrono::high_resolution_clock::now()
               - start;
    return std::chrono::duration_cast
               &lt;std::chrono::milliseconds&gt;(dur).count();
};</pre>
   <p>
    
     With that code in place, we can start measuring different approaches to how futures can
    
    
     
      be used.
     
    
   </p>
   <p>
    
     Let’s start by running several asynchronous tasks but discarding the future returned
    
    
     
      by
     
    
    
     <strong class="source-inline">
      
       std::async
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
constexpr unsigned NUM_TASKS = 32;
auto start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
    std::async(std::launch::async, func, i);
}
std::cout &lt;&lt; "Discarding futures: "
          &lt;&lt; duration_from(start) &lt;&lt; '\n';</pre>
   <p>
    
     The duration of this test is 334 ms on my PC, a Pentium i7 4790K at 4 GHz with four cores and
    
    
     
      eight threads.
     
    
   </p>
   <p>
    
     For the next test, let’s store the returned future, but don’t wait for the result to be ready.
    
    
     Obviously, this is not the right way of using computer power by spawning asynchronous tasks as consuming resources and not processing the results, but we are doing this for
    
    <a id="_idIndexMarker501">
    </a>
    
     testing and
    
    
     
      learning purposes:
     
    
   </p>
   <pre class="source-code">
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
    auto fut = std::async(std::launch::async, func, i);
}
std::cout &lt;&lt; "In-place futures: "
          &lt;&lt; duration_from(start) &lt;&lt; '\n';</pre>
   <p>
    
     In this case, the duration is still 334 ms.
    
    
     In both cases, a future is created, and when going out of scope at the end of each loop iteration, it must wait for the thread spawn by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     to finish
    
    
     
      and join.
     
    
   </p>
   <p>
    
     As you can see, we are launching 32 tasks, each one consuming at least 10 ms.
    
    
     That totals 320 ms, a value equivalent to 334 ms obtained in these tests.
    
    
     The remaining performance cost comes from starting threads, checking the
    
    <strong class="source-inline">
     
      for
     
    </strong>
    
     loop variable, storing the time points when using the steady clock, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     To avoid creating a new future object each time
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     is called, and waiting for its destructor to be called, let’s reuse the future object as shown in the following code.
    
    
     Again, this is not the proper way as we are discarding access to the results of
    
    
     
      previous tasks:
     
    
   </p>
   <pre class="source-code">
std::future&lt;unsigned&gt; fut;
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
    fut = std::async(std::launch::async, func, i);
}
std::cout &lt;&lt; "Reusing future: "
          &lt;&lt; duration_from(start) &lt;&lt; '\n';</pre>
   <p>
    
     Now the duration
    
    <a id="_idIndexMarker502">
    </a>
    
     is 166 ms.
    
    
     The reductions are due to not waiting for each future, as they are
    
    
     
      not destroyed.
     
    
   </p>
   <p>
    
     But this is not ideal as we might be interested in knowing the result of the asynchronous tasks.
    
    
     Therefore, we need to store the results in a vector.
    
    
     Let’s modify the previous example by using the
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     vector to store the results from
    
    
     
      each task:
     
    
   </p>
   <pre class="source-code">
std::vector&lt;unsigned&gt; res;
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
    auto fut = std::async(std::launch::async, func, i);
    res.push_back(fut.get());
}
std::cout &lt;&lt; "Reused future and storing results: "
          &lt;&lt; duration_from(start) &lt;&lt; '\n';</pre>
   <p>
    
     In this case, the duration goes back to 334 ms.
    
    
     This is because we are again waiting for the results after spawning each task by calling
    
    <strong class="source-inline">
     
      fut.get()
     
    </strong>
    
     before launching another asynchronous task.
    
    
     We are serializing the
    
    
     
      tasks’ execution.
     
    
   </p>
   <p>
    
     A solution could be to store the futures returned by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     in a vector, and later traverse that vector
    
    <a id="_idIndexMarker503">
    </a>
    
     and get the results.
    
    
     The following code illustrates how to
    
    
     
      do this:
     
    
   </p>
   <pre class="source-code">
std::vector&lt;unsigned&gt; res;
std::vector&lt;std::future&lt;unsigned&gt;&gt; futsVec;
start = std::chrono::high_resolution_clock::now();
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
    futsVec.emplace_back(std::async(std::launch::async,
                         func, i));
}
for (unsigned i = 0; i &lt; NUM_TASKS; i++) {
    res.push_back( futsVec[i].get() );
}
std::cout &lt;&lt; "Futures vector and storing results: "
          &lt;&lt; duration_from(start) &lt;&lt; '\n';</pre>
   <p>
    
     Now the duration is only 22 ms!
    
    
     But why is
    
    
     
      that possible?
     
    
   </p>
   <p>
    
     Now all tasks are truly running asynchronously.
    
    
     The first loop launches all tasks and stores the futures in the
    
    <strong class="source-inline">
     
      futsVec
     
    </strong>
    
     vector.
    
    
     There is no longer any waiting period due to future destructors
    
    
     
      being called.
     
    
   </p>
   <p>
    
     The second loop traverses
    
    <strong class="source-inline">
     
      futsVec
     
    </strong>
    
     , retrieves each result, and stores them in the results vector,
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     .
    
    
     The time to execute the second loop will be approximately the time needed to traverse the
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     vector plus the time used by the slowest task to be scheduled
    
    
     
      and executed.
     
    
   </p>
   <p>
    
     If the system where the tests were running had enough threads to run all asynchronous tasks at once, the runtime could be halved.
    
    
     There are systems that can automatically manage several asynchronous tasks under the hood by letting the scheduler decide what tasks to run.
    
    
     In other systems, when trying to launch many threads at once, they might complain by
    
    <a id="_idIndexMarker504">
    </a>
    
     raising an exception.
    
    
     In the next section, we implement a thread limiter by
    
    
     
      using semaphores.
     
    
   </p>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor154">
    </a>
    
     Limiting the number of threads
    
   </h1>
   <p>
    
     As we saw earlier, if there
    
    <a id="_idIndexMarker505">
    </a>
    
     are not enough
    
    <a id="_idIndexMarker506">
    </a>
    
     threads to run several
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     calls, a
    
    <strong class="source-inline">
     
      std::runtime_system
     
    </strong>
    
     exception can be thrown and indicate
    
    
     
      resource exhaustion.
     
    
   </p>
   <p>
    
     We can implement a simple solution by creating a thread limiter using counting semaphores (
    
    <strong class="source-inline">
     
      std::counting_semaphore
     
    </strong>
    
     ), a multithreading synchronization mechanism explained in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The idea is to use a
    
    <strong class="source-inline">
     
      std::counting_semaphore
     
    </strong>
    
     object, setting its initial value to the maximum concurrent tasks that the system allows, which can be retrieved by calling the
    
    <strong class="source-inline">
     
      std::thread::hardware_concurrency()
     
    </strong>
    
     function, as learned in
    
    <a href="B22219_02.xhtml#_idTextAnchor035">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     , and then use that semaphore in the task function to block if the total number of asynchronous tasks exceed the maximum
    
    
     
      concurrent tasks.
     
    
   </p>
   <p>
    
     The following
    
    <a id="_idIndexMarker507">
    </a>
    
     snippet implements
    
    
     
      this idea:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;semaphore&gt;
#include &lt;syncstream&gt;
#include &lt;vector&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
void task(int id, std::counting_semaphore&lt;&gt;&amp; sem) {
    sem.acquire();
    sync_cout &lt;&lt; "Running task " &lt;&lt; id &lt;&lt; "...\n";
    std::this_thread::sleep_for(1s);
    sem.release();
}
int main() {
    const int total_tasks = 20;
    const int max_concurrent_tasks =
              std::thread::hardware_concurrency();
    std::counting_semaphore&lt;&gt; sem(max_concurrent_tasks);
    sync_cout &lt;&lt; "Allowing only "
              &lt;&lt; max_concurrent_tasks
              &lt;&lt; " concurrent tasks to run "
              &lt;&lt; total_tasks &lt;&lt; " tasks.\n";
    std::vector&lt;std::future&lt;void&gt;&gt; futures;
    for (int i = 0; i &lt; total_tasks; ++i) {
        futures.push_back(
                std::async(std::launch::async,
                           task, i, std::ref(sem)));
    }
    for (auto&amp; fut : futures) {
        fut.get();
    }
    std::cout &lt;&lt; "All tasks completed." &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     The program starts by setting the total number of tasks that will be launched.
    
    
     Then, it creates a counting semaphore,
    
    <strong class="source-inline">
     
      sem
     
    </strong>
    
     , setting its initial value to the hardware concurrency value, as explained earlier.
    
    
     Finally, it just launches all tasks and waits for their futures to be ready,
    
    
     
      as usual.
     
    
   </p>
   <p>
    
     The key point in
    
    <a id="_idIndexMarker508">
    </a>
    
     this
    
    <a id="_idIndexMarker509">
    </a>
    
     example is that each task, before performing its job, acquires the semaphore, thus decrementing the internal counter or blocking until the counter can be decremented.
    
    
     When the job is done, the semaphore is released, which increments the internal counter and unblocks other tasks that try to acquire the semaphore at that time.
    
    
     That means that a task will launch only if there is a free hardware thread to be used for that task.
    
    
     Otherwise, it will be blocked until another task releases
    
    
     
      the semaphore.
     
    
   </p>
   <p>
    
     Before exploring
    
    <a id="_idIndexMarker510">
    </a>
    
     some
    
    <a id="_idIndexMarker511">
    </a>
    
     real-life scenarios, let’s first understand some drawbacks of
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       std::async
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor155">
    </a>
    
     When not to use std::async
    
   </h1>
   <p>
    
     As we have seen during
    
    <a id="_idIndexMarker512">
    </a>
    
     this chapter,
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     does not provide direct control over the number of threads used or access to the thread objects themselves.
    
    
     We know now how to limit the number of asynchronous tasks by using counting semaphores, but there might be some applications where this is not the optimal solution and fine-grained control
    
    
     
      is required.
     
    
   </p>
   <p>
    
     Also, the automatic management of threads can reduce performance by introducing overhead, especially when many small tasks are launched, leading to excessive context switching and
    
    
     
      resource contention.
     
    
   </p>
   <p>
    
     The implementation imposes some limit on the number of concurrent threads that can be used, which can degrade performance or even throw exceptions.
    
    
     As
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     and the available
    
    <strong class="source-inline">
     
      std::launch
     
    </strong>
    
     policies are implementation-dependent, the performance is not uniform across different compilers
    
    
     
      and platforms.
     
    
   </p>
   <p>
    
     Finally, in this chapter, we didn’t mention how to cancel an asynchronous task started by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     as there is no standard way of doing so
    
    
     
      before completion.
     
    
   </p>
   <h1 id="_idParaDest-157">
    <a id="_idTextAnchor156">
    </a>
    
     Practical examples
    
   </h1>
   <p>
    
     Now it’s time to implement
    
    <a id="_idIndexMarker513">
    </a>
    
     some examples to tackle real-life scenarios using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     .
    
    
     We will learn how to do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Perform parallel computation
     
     
      
       and aggregation
      
     
    </li>
    <li>
     
      Asynchronously search across different containers or a
     
     
      
       large dataset
      
     
    </li>
    <li>
     
      Asynchronously multiply
     
     
      
       two matrices
      
     
    </li>
    <li>
     
      Chain
     
     
      
       asynchronous operations
      
     
    </li>
    <li>
     
      Improve the pipeline example from the
     
     
      
       last chapter
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor157">
    </a>
    
     Parallel computation and aggregation
    
   </h2>
   <p>
    <strong class="bold">
     
      Data aggregation
     
    </strong>
    
     is the process
    
    <a id="_idIndexMarker514">
    </a>
    
     of collecting raw data from multiple sources and organizing, processing, and providing a summary of the data for easy consumption.
    
    
     This process is useful in many fields, such as business reporting, financial services, healthcare, social media monitoring, research,
    
    
     
      and academia.
     
    
   </p>
   <p>
    
     As a naive example, let’s compute the result of squaring all numbers between
    
    <em class="italic">
     
      1
     
    </em>
    
     and
    
    <em class="italic">
     
      n
     
    </em>
    
     and obtaining their average value.
    
    
     We know that using the following formula to compute the sum of square values would be much quicker and require less computer power.
    
    
     Also, the task could be more meaningful, but the purpose of this example is to understand the relationship between the tasks, not the
    
    
     
      task itself.
     
    
   </p>
   <p class="IMG---Figure">
    
     <img alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;msup&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" src="img/6.png" style="vertical-align:-0.781em;height:2.110em;width:12.191em"/>
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      average_squares()
     
    </strong>
    
     function in
    
    <a id="_idIndexMarker515">
    </a>
    
     the following example launches an asynchronous task per value between
    
    <em class="italic">
     
      1
     
    </em>
    
     and
    
    <em class="italic">
     
      n
     
    </em>
    
     to compute the square value.
    
    
     The resulting future objects are stored in the
    
    <strong class="source-inline">
     
      futsVec
     
    </strong>
    
     vector, which is later used by the
    
    <strong class="source-inline">
     
      sum_results()
     
    </strong>
    
     function to compute the sum of the squared values.
    
    
     The result is then divided by
    
    <strong class="source-inline">
     
      n
     
    </strong>
    
     to obtain
    
    <a id="_idIndexMarker516">
    </a>
    
     the
    
    
     
      average value:
     
    
   </p>
   <pre class="source-code">
#include &lt;future&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int square(int x) {
    return x * x;
}
int sum_results(std::vector&lt;std::future&lt;int&gt;&gt;&amp; futsVec) {
    int sum = 0;
    for (auto&amp; fut : futsVec) {
        sum += fut.get();
    }
    return sum;
}
int average_squares(int n) {
    std::vector&lt;std::future&lt;int&gt;&gt; futsVec;
    for (int i = 1; i &lt;= n; ++i) {
        futsVec.push_back(std::async(
                std::launch::async, square, i));
    }
    return double(sum_results(futures)) / n;
}
int main() {
    int N = 100;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);
    std::cout &lt;&lt; "Sum of squares for N = " &lt;&lt; N
              &lt;&lt; « is « &lt;&lt; average_squares(N) &lt;&lt; '\n';
    return 0;
}</pre>
   <p>
    
     For example, for
    
    
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;100&lt;/mml:mn&gt;&lt;/mml:math&gt;" src="img/7.png" style="vertical-align:-0.012em;height:0.646em;width:3.562em"/>
    
    
     , we can check that the value will be the same as the one returned by
    
    <a id="_idIndexMarker517">
    </a>
    
     the function divided by
    
    
     <em class="italic">
      
       n
      
     </em>
    
    
     
      ,
     
    
    
     <em class="italic">
      
       3,383.50
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     This example can
    
    <a id="_idIndexMarker518">
    </a>
    
     easily be modified to implement a solution using the
    
    <strong class="bold">
     
      MapReduce
     
    </strong>
    
     programming model to handle large datasets
    
    <a id="_idIndexMarker519">
    </a>
    
     efficiently.
    
    
     MapReduce works by dividing the data processing into two phases; the Map phase, where independent chunks of data are filtered, sorted, and processed in parallel across multiple computers, and the Reduce phase where results from the Map phase are aggregated, summarizing the data.
    
    
     This is like what we just implemented, using the
    
    <strong class="source-inline">
     
      square()
     
    </strong>
    
     function in the
    
    <a id="_idIndexMarker520">
    </a>
    
     Map phase, and the
    
    <strong class="source-inline">
     
      average_squares()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      sum_results()
     
    </strong>
    
     functions in the
    
    
     
      Reduce phase.
     
    
   </p>
   <h2 id="_idParaDest-159">
    <a id="_idTextAnchor158">
    </a>
    
     Asynchronous searches
    
   </h2>
   <p>
    
     One way to speed up searching a target value into large containers is to parallelize the search.
    
    
     Next, we will present two examples.
    
    
     The first one involves searching across different containers by using one task per container, while the second one involves searching across a large container, dividing it into smaller segments, and using a task
    
    
     
      per segment.
     
    
   </p>
   <h3>
    
     Searching across different containers
    
   </h3>
   <p>
    
     In this example, we need to search for a
    
    <strong class="source-inline">
     
      target
     
    </strong>
    
     value in
    
    <a id="_idIndexMarker521">
    </a>
    
     different containers of diverse types (
    
    <strong class="source-inline">
     
      vector
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      list
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      forward_list
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      set
     
    </strong>
    
     ) containing names
    
    
     
      of animals:
     
    
   </p>
   <pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;forward_list&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
int main() {
    std::vector&lt;std::string&gt; africanAnimals =
              {"elephant", "giraffe", "lion", "zebra"};
    std::list&lt;std::string&gt; americanAnimals =
              {"alligator", "bear", "eagle", "puma"};
    std::forward_list&lt;std::string&gt; asianAnimals =
              {"orangutan", "panda", "tapir", "tiger"};
    std::set&lt;std::string&gt; europeanAnimals =
              {«deer», «hedgehog», «linx", "wolf"};
    std::string target = «elephant»;
    /* .... */
}</pre>
   <p>
    
     To search for the target value, we launch an asynchronous task for each container, using the
    
    <strong class="source-inline">
     
      search()
     
    </strong>
    
     template function, which simply calls the
    
    <strong class="source-inline">
     
      std::find
     
    </strong>
    
     function in a container and returns
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     if the target value is found, or
    
    
     <strong class="source-inline">
      
       false
      
     </strong>
    
    
     
      otherwise:
     
    
   </p>
   <pre class="source-code">
template &lt;typename C&gt;
bool search(const C&amp; container, const std::string&amp; target) {
    return std::find(container.begin(), container.end(),
                     target) != container.end();
}</pre>
   <p>
    
     These asynchronous tasks are launched using the
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     function with the
    
    <strong class="source-inline">
     
      std::launch::async
     
    </strong>
    
     
      launch
     
    
    
     <a id="_idIndexMarker522">
     </a>
    
    
     
      policy:
     
    
   </p>
   <pre class="source-code">
int main() {
    /* .... */
    auto fut1 = std::async(std::launch::async,
                   search&lt;std::vector&lt;std::string&gt;&gt;,
                   africanAnimals, target);
    auto fut2 = std::async(std::launch::async,
                   search&lt;std::list&lt;std::string&gt;&gt;,
                   americanAnimals, target);
    auto fut3 = std::async(std::launch::async,
                   search&lt;std::forward_list&lt;std::string&gt;&gt;,
                   asianAnimals, target);
    auto fut4 = std::async(std::launch::async,
                search&lt;std::set&lt;std::string&gt;&gt;,
                europeanAnimals, target);
    /* .... */</pre>
   <p>
    
     Finally, we simply retrieve all return values from the futures created when using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     and bitwise
    
    
     
      OR them:
     
    
   </p>
   <pre class="source-code">
int main() {
    /* .... */
    bool found = fut1.get() || fut2.get() ||
                 fut3.get() || fut4.get();
    if (found) {
        std::cout &lt;&lt; target
                  &lt;&lt; " found in one of the containers.\n";
    } else {
        std::cout &lt;&lt; target
                  &lt;&lt; " not found in any of "
                  &lt;&lt; "the containers.\n";
    }
    return 0;
}</pre>
   <p>
    
     This example also shows
    
    <a id="_idIndexMarker523">
    </a>
    
     the power of the
    
    <strong class="bold">
     
      Standard Template Library
     
    </strong>
    
     (
    
    <strong class="bold">
     
      STL
     
    </strong>
    
     ) as it
    
    <a id="_idIndexMarker524">
    </a>
    
     provides generic and reusable algorithms that can be applied to different containers and
    
    
     
      data types.
     
    
   </p>
   <h3>
    
     Searching in a large container
    
   </h3>
   <p>
    
     In the next example, we will implement a solution to find a target value in a large vector containing 5 million
    
    
     
      integer values.
     
    
   </p>
   <p>
    
     To generate the vector, we use a random number generator with a uniform
    
    
     
      integer distribution:
     
    
   </p>
   <pre class="source-code">
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;future&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;
// Generate a large vector of random integers using a uniform distribution
std::vector&lt;int&gt; generate_vector(size_t size) {
    std::vector&lt;int&gt; vec(size);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dist(1, size);
    std::generate(vec.begin(), vec.end(), [&amp;]() {
        return dist(gen);
    });
    return vec;
}</pre>
   <p>
    
     To search for a target value in
    
    <a id="_idIndexMarker525">
    </a>
    
     a segment of a vector, we can use the
    
    <strong class="source-inline">
     
      std::find
     
    </strong>
    
     function with
    
    <strong class="source-inline">
     
      begin
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     iterators pointing to the
    
    
     
      segment limits:
     
    
   </p>
   <pre class="source-code">
bool search_segment(const std::vector&lt;int&gt;&amp; vec, int target, size_t begin, size_t end) {
    auto begin_it = vec.begin() + begin;
    auto end_it = vec.begin() + end;
    return std::find(begin_it, end_it, target) != end_it;
}</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, we start by generating the large vector using the
    
    <strong class="source-inline">
     
      generate_vector()
     
    </strong>
    
     function, then defining the
    
    <strong class="source-inline">
     
      target
     
    </strong>
    
     value to find and the number of segments (
    
    <strong class="source-inline">
     
      num_segments
     
    </strong>
    
     ) which the vector will be split for
    
    
     
      parallel searches:
     
    
   </p>
   <pre class="source-code">
const int target = 100;
std::vector&lt;int&gt; vec = generate_vector(5000000);
auto vec_size = vec.size();
size_t num_segments = 16;
size_t segment_size = vec.size() / num_segments;</pre>
   <p>
    
     Then, for each segment, we define its
    
    <strong class="source-inline">
     
      begin
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     iterators and launch an asynchronous task to search for the target value in that segment.
    
    
     Thus, we execute
    
    <strong class="source-inline">
     
      search_segment
     
    </strong>
    
     asynchronously in a separate thread by using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      std::launch::async
     
    </strong>
    
     launch policy.
    
    
     To avoid copying the large vector when passing it as an input argument of
    
    <strong class="source-inline">
     
      search_segment
     
    </strong>
    
     , we use a constant reference,
    
    <strong class="source-inline">
     
      std::cref
     
    </strong>
    
     .
    
    
     The futures
    
    <a id="_idIndexMarker526">
    </a>
    
     returned by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     are stored in the
    
    
     <strong class="source-inline">
      
       futs
      
     </strong>
    
    
     
      vector:
     
    
   </p>
   <pre class="source-code">
std::vector&lt;std::future&lt;bool&gt;&gt; futs;
for (size_t i = 0; i &lt; num_segments; ++i) {
    auto begin = std::min(i * segment_size, vec_size);
    auto end = std::min((i + 1) * segment_size, vec_size);
    futs.push_back( std::async(std::launch::async,
                               search_segment,
                               std::cref(vec),
                               target, begin, end) );
}</pre>
   <p>
    
     Note that the vector size is not always a multiple of the segment size, thus the last segment might be shorter than the others.
    
    
     To deal with this situation and avoid issues when accessing out-of-bounds memory when checking the last segment, we need to properly set the
    
    <strong class="source-inline">
     
      begin
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     indexes for each segment.
    
    
     For that, we use
    
    <strong class="source-inline">
     
      std::min
     
    </strong>
    
     to get the minimum value between the size of the vector and the hypothetical index of the last element in the
    
    
     
      current segment.
     
    
   </p>
   <p>
    
     Finally, we check all results by calling
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     on each future and print a message to the console if the target
    
    <a id="_idIndexMarker527">
    </a>
    
     value was found in any of
    
    
     
      the segments:
     
    
   </p>
   <pre class="source-code">
bool found = false;
for (auto&amp; fut : futs) {
    if (fut.get()) {
        found = true;
        break;
    }
}
if (found) {
    std::cout &lt;&lt; "Target " &lt;&lt; target
              &lt;&lt; " found in the large vector.\n";
} else {
    std::cout &lt;&lt; "Target " &lt;&lt; target
              &lt;&lt; " not found in the large vector.\n";
}</pre>
   <p>
    
     This solution can be used as the base for more advanced solutions dealing with huge datasets in distributed systems where each asynchronous task tries to find a target value in a specific machine
    
    
     
      or cluster.
     
    
   </p>
   <h2 id="_idParaDest-160">
    <a id="_idTextAnchor159">
    </a>
    
     Asynchronous matrix multiplication
    
   </h2>
   <p>
    <strong class="bold">
     
      Matrix multiplication
     
    </strong>
    
     is one
    
    <a id="_idIndexMarker528">
    </a>
    
     of the most relevant operations in
    
    <a id="_idIndexMarker529">
    </a>
    
     computer science, used in many domains, such as computer graphics, computer vision, machine learning, and
    
    
     
      scientific computing.
     
    
   </p>
   <p>
    
     In the following example, we will implement a parallel computing solution by distributing the computation across
    
    
     
      multiple threads.
     
    
   </p>
   <p>
    
     Let’s start by defining a
    
    <a id="_idIndexMarker530">
    </a>
    
     matrix type,
    
    <strong class="source-inline">
     
      matrix_t
     
    </strong>
    
     , as a vector of vectors holding
    
    
     
      integer values:
     
    
   </p>
   <pre class="source-code">
#include &lt;cmath&gt;
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using matrix_t = std::vector&lt;std::vector&lt;int&gt;&gt;;</pre>
   <p>
    
     Then, we implement the
    
    <strong class="source-inline">
     
      matrix_multiply
     
    </strong>
    
     function, which accepts two matrices,
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     , passing them as constant references, and returns their multiplication.
    
    
     We know that if
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     is a matrix
    
    
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="img/8.png" style="vertical-align:-0.012em;height:0.460em;width:1.790em"/>
    
    
     (
    
    <em class="italic">
     
      m
     
    </em>
    
     stands for rows and
    
    <em class="italic">
     
      n
     
    </em>
    
     for columns) and
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     is a matrix
    
    
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;mml:mi&gt;q&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="img/9.png" style="vertical-align:-0.254em;height:0.772em;width:1.428em"/>
    
    
     , we can multiply
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     if
    
    
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="img/10.png" style="vertical-align:-0.254em;height:0.772em;width:2.557em"/>
    
    
     , and the resulting matrix will be of dimensions
    
    
     <img alt="&lt;mml:math  &gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;mml:mi&gt;q&lt;/mml:mi&gt;&lt;/mml:math&gt;" src="img/11.png" style="vertical-align:-0.254em;height:0.702em;width:1.748em"/>
    
    
     (
    
    <em class="italic">
     
      m
     
    </em>
    
     rows and
    
    
     <em class="italic">
      
       q
      
     </em>
    
    
     
      columns).
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      matrix_multiply
     
    </strong>
    
     function just starts by reserving some space to the result matrix,
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     .
    
    
     Then, it loops over the matrix by extracting column
    
    <strong class="source-inline">
     
      j
     
    </strong>
    
     from
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     and multiplying it by row
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     
      from
     
    
    
     <strong class="source-inline">
      
       A
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
matrix_t matrix_multiply(const matrix_t&amp; A,
                         const matrix_t&amp; B) {
    if (A[0].size() != B.size()) {
        throw new std::runtime_error(
                  «Wrong matrices dimmensions.");
    }
    size_t rows = A.size();
    size_t cols = B[0].size();
    size_t inner_dim = B.size();
    matrix_t res(rows, std::vector&lt;int&gt;(cols, 0));
    std::vector&lt;std::future&lt;int&gt;&gt; futs;
    for (auto i = 0; i &lt; rows; ++i) {
        for (auto j = 0; j &lt; cols; ++j) {
            std::vector&lt;int&gt; column(inner_dim);
            for (size_t k = 0; k &lt; inner_dim; ++k) {
                column[k] = B[k][j];
            }
            futs.push_back(std::async(std::launch::async,
                                      dot_product,
                                      A[i], column));
        }
    }
    for (auto i = 0; i &lt; rows; ++i) {
        for (auto j = 0; j &lt; cols; ++j) {
            res[i][j] = futs[i * cols + j].get();
        }
    }
    return res;
}</pre>
   <p>
    
     The multiplication
    
    <a id="_idIndexMarker531">
    </a>
    
     is done
    
    <a id="_idIndexMarker532">
    </a>
    
     asynchronously by using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      std::launch::async
     
    </strong>
    
     launch policy, running the
    
    <strong class="source-inline">
     
      dot_product
     
    </strong>
    
     function.
    
    
     Each returned future from
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     is stored in the
    
    <strong class="source-inline">
     
      futs
     
    </strong>
    
     vector.
    
    
     The
    
    <strong class="source-inline">
     
      dot_product
     
    </strong>
    
     function computes the dot product of vectors
    
    <strong class="source-inline">
     
      a
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      b
     
    </strong>
    
     , representing a row from
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     and a column from
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     , by multiplying element by element and returning the sum of
    
    
     
      these products:
     
    
   </p>
   <pre class="source-code">
int dot_product(const std::vector&lt;int&gt;&amp; a,
                const std::vector&lt;int&gt;&amp; b) {
    int sum = 0;
    for (size_t i = 0; i &lt; a.size(); ++i) {
        sum += a[i] * b[i];
    }
    return sum;
}</pre>
   <p>
    
     As the
    
    <strong class="source-inline">
     
      dot_product
     
    </strong>
    
     function expects two vectors, we need to extract each column from
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     before launching each asynchronous task.
    
    
     This also enhances the overall performance as the vectors might be stored in contiguous blocks of memory, thus being more cache-friendly
    
    
     
      during computation.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, we
    
    <a id="_idIndexMarker533">
    </a>
    
     just define two matrices,
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      B
     
    </strong>
    
     , and use the
    
    <strong class="source-inline">
     
      matrix_multipy
     
    </strong>
    
     function to compute their product.
    
    
     All matrices are printed into the console using the
    
    <strong class="source-inline">
     
      show_matrix
     
    </strong>
    
     
      lambda function:
     
    
   </p>
   <pre class="source-code">
int main() {
    auto show_matrix = [](const std::string&amp; name,
                          matrix_t&amp; mtx) {
        std::cout &lt;&lt; name &lt;&lt; '\n';
        for (const auto&amp; row : mtx) {
            for (const auto&amp; elem : row) {
                std::cout &lt;&lt; elem &lt;&lt; " ";
            }
            std::cout &lt;&lt; '\n';
        }
        std::cout &lt;&lt; std::endl;
    };
    matrix_t A = {{1, 2, 3},
                  {4, 5, 6}};
    matrix_t B = {{7, 8, 9},
                  {10, 11, 12},
                  {13, 14, 15}};
    auto res = matrix_multiply(A, B);
    show_matrix("A", A);
    show_matrix("B", B);
    show_matrix("Result", res);
    return 0;
}</pre>
   <p>
    
     This is the
    
    <a id="_idIndexMarker534">
    </a>
    
     output
    
    <a id="_idIndexMarker535">
    </a>
    
     from running
    
    
     
      this example:
     
    
   </p>
   <pre class="console">
A
1 2 3
4 5 6
B
7 8 9
10 11 12
13 14 15
Result
66 72 78
156 171 186</pre>
   <p>
    
     Using contiguous memory blocks improves performance when traversing vectors as many of their elements can
    
    <a id="_idIndexMarker536">
    </a>
    
     be read at once into the cache.
    
    
     Using contiguous memory allocation is not guaranteed when using
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     , therefore it might be better to use
    
    <strong class="source-inline">
     
      new
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       malloc
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-161">
    <a id="_idTextAnchor160">
    </a>
    
     Chain asynchronous operations
    
   </h2>
   <p>
    
     In this example, we will implement a simple pipeline composed of three stages where each stage takes the result from the previous stage and computes
    
    
     
      a value.
     
    
   </p>
   <div><div><img alt="Figure 7.1 – Simple pipeline example" src="img/B22219_07_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.1 – Simple pipeline example
    
   </p>
   <p>
    
     The first stage only
    
    <a id="_idIndexMarker537">
    </a>
    
     accepts positive integers as input, otherwise it raises an exception, and adds 10 to that value before returning the result.
    
    
     The second stage multiplies its input by 2, and the third subtracts 5 from
    
    
     
      its input:
     
    
   </p>
   <pre class="source-code">
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
int stage1(int x) {
    if (x &lt; 0) throw std::runtime_error(
                        "Negative input not allowed");
    return x + 10;
}
int stage2(int x) {
    return x * 2;
}
int stage3(int x) {
    return x - 5;
}</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, for the intermediate and final stages, we define the pipeline by using as input the futures generated by the previous stages.
    
    
     These futures are passed by reference to the lambda expression running the asynchronous code, where their
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function is used to get
    
    
     
      their result.
     
    
   </p>
   <p>
    
     To retrieve the result from the pipeline, we just need to call the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function from the future returned by the last stage.
    
    
     If an exception happens, for example, when
    
    <strong class="source-inline">
     
      input_value
     
    </strong>
    
     is negative, it is
    
    <a id="_idIndexMarker538">
    </a>
    
     caught by the
    
    
     
      try-catch block:
     
    
   </p>
   <pre class="source-code">
int main() {
    int input_value = 5;
    try {
        auto fut1 = std::async(std::launch::async,
                         stage1, input_value);
        auto fut2 = std::async(std::launch::async,
                         [&amp;fut1]() {
                            return stage2(fut1.get()); });
        auto fut3 = std::async(std::launch::async,
                         [&amp;fut2]() {
                            return stage3(fut2.get()); });
        int final_result = fut3.get();
        std::cout &lt;&lt; "Final Result: "
                  &lt;&lt; final_result &lt;&lt; std::endl;
    } catch (const std::exception &amp;ex) {
        std::cerr &lt;&lt; "Exception caught: "
                  &lt;&lt; ex.what() &lt;&lt; std::endl;
    }
    return 0;
}</pre>
   <p>
    
     The pipeline defined in this example is a simple one where each stage uses the future from the previous stage to get the input value and produce its result.
    
    
     In the next example, we will rewrite the
    
    <a id="_idIndexMarker539">
    </a>
    
     pipeline implemented in the previous chapter using
    
    <strong class="source-inline">
     
      std:async
     
    </strong>
    
     with deferred launch policies to only execute the stages that
    
    
     
      are needed.
     
    
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor161">
    </a>
    
     Asynchronous pipeline
    
   </h2>
   <p>
    
     As promised, in the last chapter, when we were implementing a pipeline, we mentioned that the different
    
    <a id="_idIndexMarker540">
    </a>
    
     tasks could be kept switched off until needed by using futures with deferred execution.
    
    
     As also mentioned, this is useful in scenarios where the computation cost is high, but the result may not always be needed.
    
    
     As futures with deferred status can only be created by using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     , now it’s time to see how to
    
    
     
      do that.
     
    
   </p>
   <p>
    
     We will implement the same pipeline described in the previous chapter, which follows the next
    
    
     
      task graph:
     
    
   </p>
   <div><div><img alt="Figure 7.2 – Pipeline example" src="img/B22219_07_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.2 – Pipeline example
    
   </p>
   <p>
    
     We start by defining the
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     class.
    
    
     This class is like the one implemented in an example in the previous chapter but using the
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     function and storing the returned future instead of the promise used previously.
    
    
     Here, we will only comment on the relevant code changes from that example, so please look at that example for a full explanation of the
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     class or check it out in the
    
    
     
      GitHub repository.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     constructors store the task identifier (
    
    <strong class="source-inline">
     
      id_
     
    </strong>
    
     ), the function to launch (
    
    <strong class="source-inline">
     
      func_
     
    </strong>
    
     ), and whether the task has dependencies (
    
    <strong class="source-inline">
     
      has_dependency_
     
    </strong>
    
     ).
    
    
     It also starts the asynchronous task in deferred launch mode by using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      std::launch::deferred
     
    </strong>
    
     launch policy, meaning that the task is created but not started until needed.
    
    
     The
    
    <a id="_idIndexMarker541">
    </a>
    
     returned future is stored in the
    
    
     <strong class="source-inline">
      
       fut_
      
     </strong>
    
    
     
      variable:
     
    
   </p>
   <pre class="source-code">
template &lt;typename Func&gt;
class Task {
   public:
    Task(int id, Func&amp; func)
        : id_(id), func_(func), has_dependency_(false) {
        sync_cout &lt;&lt; "Task " &lt;&lt; id
                 &lt;&lt; " constructed without dependencies.\n";
        fut_ = std::async(std::launch::deferred,
                         [this](){ (*this)(); });
    }
    template &lt;typename... Futures&gt;
    Task(int id, Func&amp; func, Futures&amp;&amp;... futures)
        : id_(id), func_(func), has_dependency_(true) {
        sync_cout &lt;&lt; "Task " &lt;&lt; id
                  &lt;&lt; " constructed with dependencies.\n";
        fut_ = std::async(std::launch::deferred,
                         [this](){ (*this)(); });
        add_dependencies(std::forward&lt;Futures&gt;
                                     (futures)...);
    }
   private:
    int id_;
    Func&amp; func_;
    std::future&lt;void&gt; fut_;
    std::vector&lt;std::shared_future&lt;void&gt;&gt; deps_;
    bool has_dependency_;
};</pre>
   <p>
    
     The asynchronous tasks started by
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     call the
    
    <strong class="source-inline">
     
      operator()
     
    </strong>
    
     of their own instance (the
    
    <strong class="source-inline">
     
      this
     
    </strong>
    
     object).
    
    
     When that happens,
    
    <strong class="source-inline">
     
      wait_completion()
     
    </strong>
    
     is called, checking whether all futures in the shared future vector,
    
    <strong class="source-inline">
     
      deps_
     
    </strong>
    
     , storing dependent tasks are valid by calling
    
    <a id="_idIndexMarker542">
    </a>
    
     their
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     function, and if so, waiting for them to finish by calling the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function.
    
    
     When all dependent
    
    <a id="_idIndexMarker543">
    </a>
    
     tasks are complete, the
    
    <strong class="source-inline">
     
      func_
     
    </strong>
    
     function
    
    
     
      is called:
     
    
   </p>
   <pre class="source-code">
public:
void operator()() {
    sync_cout &lt;&lt; "Starting task " &lt;&lt; id_ &lt;&lt; std::endl;
    wait_completion();
    sync_cout &lt;&lt; "Running task " &lt;&lt; id_ &lt;&lt; std::endl;
    func_();
}
private:
void wait_completion() {
    sync_cout &lt;&lt; "Waiting completion for task "
              &lt;&lt; id_ &lt;&lt; std::endl;
    if (!deps_.empty()) {
        for (auto&amp; fut : deps_) {
            if (fut.valid()) {
                sync_cout &lt;&lt; "Fut valid so getting "
                          &lt;&lt; "value in task " &lt;&lt; id_
                          &lt;&lt; std::endl;
                fut.get();
            }
        }
    }
}</pre>
   <p>
    
     There is also a new
    
    <a id="_idIndexMarker544">
    </a>
    
     member function,
    
    <strong class="source-inline">
     
      start()
     
    </strong>
    
     , that waits for the
    
    <strong class="source-inline">
     
      fut_
     
    </strong>
    
     future created during the task construction when calling
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     .
    
    
     This will be used to trigger the pipeline by requesting the result of the
    
    
     
      last task:
     
    
   </p>
   <pre class="source-code">
public:
void start() {
    fut_.get();
}</pre>
   <p>
    
     As in the example in the previous chapter, we also define a member function called
    
    <strong class="source-inline">
     
      get_dependency()
     
    </strong>
    
     that returns a shared future constructed
    
    
     
      from
     
    
    
     <strong class="source-inline">
      
       fut_
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
std::shared_future&lt;void&gt; get_dependency() {
    sync_cout &lt;&lt; "Getting future from task "
              &lt;&lt; id_ &lt;&lt; std::endl;
    return fut_;
}</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, we define the pipeline by chaining task objects and setting their dependencies and the
    
    <a id="_idIndexMarker545">
    </a>
    
     lambda function to run,
    
    <strong class="source-inline">
     
      sleep1s
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      sleep2s
     
    </strong>
    
     , following the diagram
    
    <a id="_idIndexMarker546">
    </a>
    
     shown in
    
    
     <em class="italic">
      
       Figure 7
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
int main() {
    auto sleep1s = [](){
        std::this_thread::sleep_for(1s);
    };
    auto sleep2s = [](){
        std::this_thread::sleep_for(2s);
    };
    Task task1(1, sleep1s);
    Task task2(2, sleep2s, task1.get_dependency());
    Task task3(3, sleep1s, task2.get_dependency());
    Task task4(4, sleep2s, task2.get_dependency());
    Task task5(5, sleep2s, task3.get_dependency(),
               task4.get_dependency());
    sync_cout &lt;&lt; "Starting the pipeline..." &lt;&lt; std::endl;
    task5.start();
    sync_cout &lt;&lt; "All done!" &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     Starting the pipeline is as simple as getting the result from the last task’s future.
    
    
     We can do that by calling the
    
    <strong class="source-inline">
     
      start()
     
    </strong>
    
     method of
    
    <strong class="source-inline">
     
      task5
     
    </strong>
    
     .
    
    
     This will recursively call their dependency tasks by using the dependency vector and start the deferred
    
    
     
      asynchronous tasks.
     
    
   </p>
   <p>
    
     This is the
    
    <a id="_idIndexMarker547">
    </a>
    
     output of
    
    <a id="_idIndexMarker548">
    </a>
    
     executing the
    
    
     
      preceding code:
     
    
   </p>
   <pre class="console">
Task 1 constructed without dependencies.
Getting future from task 1
Task 2 constructed with dependencies.
Getting future from task 2
Task 3 constructed with dependencies.
Getting future from task 2
Task 4 constructed with dependencies.
Getting future from task 4
Getting future from task 3
Task 5 constructed with dependencies.
Starting the pipeline...
Starting task 5
Waiting completion for task 5
Fut valid so getting value in task 5
Starting task 3
Waiting completion for task 3
Fut valid so getting value in task 3
Starting task 2
Waiting completion for task 2
Fut valid so getting value in task 2
Starting task 1
Waiting completion for task 1
Running task 1
Running task 2
Running task 3
Fut valid so getting value in task 5
Starting task 4
Waiting completion for task 4
Running task 4
Running task 5
All done!</pre>
   <p>
    
     We can see how the pipeline is created by calling each task’s constructor and getting the futures from previous
    
    <a id="_idIndexMarker549">
    </a>
    
     
      dependent tasks.
     
    
   </p>
   <p>
    
     Then, when the pipeline is triggered,
    
    <strong class="source-inline">
     
      task5
     
    </strong>
    
     is started, starting
    
    <strong class="source-inline">
     
      task3
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      task2
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      task1
     
    </strong>
    
     recursively.
    
    
     As
    
    <strong class="source-inline">
     
      task1
     
    </strong>
    
     has no dependencies, it doesn’t need to wait for any other task to run its work, so it completes, allowing
    
    <strong class="source-inline">
     
      task2
     
    </strong>
    
     to complete, and
    
    
     
      later
     
    
    
     <strong class="source-inline">
      
       task3
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Next,
    
    <strong class="source-inline">
     
      task5
     
    </strong>
    
     continues checking its dependent tasks, so it’s now
    
    <strong class="source-inline">
     
      task4
     
    </strong>
    
     ‘s turn to run.
    
    
     Since all
    
    <strong class="source-inline">
     
      task4
     
    </strong>
    
     ‘s dependent tasks are complete,
    
    <strong class="source-inline">
     
      task4
     
    </strong>
    
     just executes, allowing
    
    <strong class="source-inline">
     
      task5
     
    </strong>
    
     to run afterward, thus completing
    
    
     
      the pipeline.
     
    
   </p>
   <p>
    
     This example can be improved by performing real computations and transferring results between tasks.
    
    
     Also, instead of deferred tasks, we could also think of stages with several parallel steps that can
    
    <a id="_idIndexMarker550">
    </a>
    
     be computed in separate
    
    <a id="_idIndexMarker551">
    </a>
    
     threads.
    
    
     Feel free to implement these improvements as an
    
    
     
      additional exercise.
     
    
   </p>
   <h1 id="_idParaDest-163">
    <a id="_idTextAnchor162">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned about
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     , how to use this function to execute asynchronous tasks, how to define its behavior by using launch policies, and how to
    
    
     
      handle exceptions.
     
    
   </p>
   <p>
    
     We also now understand how the futures returned by the async function can impact performance and how to use them wisely.
    
    
     Also, we saw how to limit the number of asynchronous tasks by the number of available threads in the system by using
    
    
     
      counting semaphores.
     
    
   </p>
   <p>
    
     We also mentioned some scenarios where
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     might not be the best tool for
    
    
     
      the job.
     
    
   </p>
   <p>
    
     Finally, we implemented several examples covering real-life scenarios, which is useful for parallelizing many
    
    
     
      common tasks.
     
    
   </p>
   <p>
    
     With all the knowledge acquired in this chapter, now we know when (and when not) to use the
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     function to run asynchronous tasks in parallel, improving the overall performance of applications, achieving better computer resource usage, and reducing
    
    
     
      resource exhaustion.
     
    
   </p>
   <p>
    
     In the next chapter, we will learn how to achieve asynchronous execution by using coroutines, which have been available
    
    
     
      since C++20.
     
    
   </p>
   <h1 id="_idParaDest-164">
    <a id="_idTextAnchor163">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     <em class="italic">
      
       Effective Modern C++
      
     </em>
     
      :
     
     <em class="italic">
      
       42 Specific Ways to Improve Your Use of C++11 and C++14
      
     </em>
     
      , Scott Meyers, O’Reilly Media, Inc., 1st Edition –
     
     
      
       Chapter 7
      
     
     
      , Item 35 and
     
     
      
       Item 36
      
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        std::async
       
      </strong>
     
     
      
       :
      
     
     <a href="https://en.cppreference.com/w/cpp/thread/async">
      
       
        https://en.cppreference.com/w/cpp/thread/async
       
      
     </a>
    </li>
    <li>
     
      <strong class="source-inline">
       
        std::launch
       
      </strong>
     
     
      
       :
      
     
     <a href="https://en.cppreference.com/w/cpp/thread/launch">
      
       
        https://en.cppreference.com/w/cpp/thread/launch
       
      
     </a>
    </li>
    <li>
     
      Strassen
     
     
      
       algorithm:
      
     
     <a href="https://en.wikipedia.org/wiki/Strassen_algorithm">
      
       
        https://en.wikipedia.org/wiki/Strassen_algorithm
       
      
     </a>
    </li>
    <li>
     
      Karatsuba
     
     
      
       algorithm:
      
     
     <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">
      
       
        https://en.wikipedia.org/wiki/Karatsuba_algorithm
       
      
     </a>
    </li>
    <li>
     
      
       OpenBLAS:
      
     
     <a href="https://www.openblas.net">
      
       
        https://www.openblas.net
       
      
     </a>
    </li>
    <li>
     
      BLIS
     
     
      
       library:
      
     
     <a href="https://github.com/flame/blis">
      
       
        https://github.com/flame/blis
       
      
     </a>
    </li>
    <li>
     
      
       MapReduce:
      
     
     <a href="https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html">
      
       
        https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html
       
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>