- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing an Online Pong Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to slowly get into some more complex aspects of making online multiplayer
    games. In [*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online
    Checkers Game*, we saw how two players can share the same game world and see their
    actions have repercussions in the other players’ game states. This happened with
    players taking turns, so we didn’t have one of the most troublesome aspects of
    online multiplayer games involved: time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to start working with action games, which have
    hand-eye coordination and response time as their core features. We’ll start with
    making a replica of one of the simplest physics-based games out there: Pong. Using
    the base project as a starting point, we will then turn it into an online multiplayer
    Pong game where each player controls one paddle and the Godot Engine high-level
    networking features will be responsible for keeping players in sync within the
    same game world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Pong project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up online multiplayer paddles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing remote objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we are going to use our repository of online projects, which
    can be found through the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: With the project opened in Godot Engine, open the `res://07.developing-online-pong`
    folder; everything we need for this chapter is there. That said, let’s start by
    understanding how our Pong project works and what we need to do to turn it into
    an online multiplayer game. As stated throughout the previous chapter, we will
    also use Godot Engine version 4.0, so if you have other versions of the engine,
    please make sure you are using the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Pong project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to yet another project for our fake indie game development studio, network
    engineer! This time, we need to make the onboarding of our next project.
  prefs: []
  type: TYPE_NORMAL
- en: We have a Pong game that we think we can turn into a competitive online multiplayer
    game with some leaderboards and all this cool stuff. Your core task here is to
    make its core features playable by two players through a network. Let’s understand
    what we have currently so we can point out what you going to modify.
  prefs: []
  type: TYPE_NORMAL
- en: How the player paddles work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The players’ paddles are the most important thing in our project. They are the
    only thing players actually control and, as such, they are the main way players
    interact with the game. By moving them, the players can bounce the ball off to
    the other player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a brief look at the `res://07.developing-online-pong/Paddle.tscn`
    scene. Its scene tree structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The Paddle scene’s node hierarchy](img/Figure_07.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The Paddle scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the paddle itself is a `Node2D` node, whereas the actual physical
    body is its child. This is a good way to abstract game entities. They have a physical
    body, but they aren’t a physical body. This allows us to make more sense of them
    in more levels of abstraction. Now, let’s take a look at its script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code allows the paddle to move up and down based on user input. The `speed`
    variable determines the movement speed, and the `up_action` and `down_action`
    variables represent the input actions for moving the paddle. The script handles
    input events and adjusts the character’s velocity accordingly. The paddle moves
    at a constant speed or it stops if no key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s see how the ball works. It’s another core object
    in our game that we will need to do some work on in order to turn it into an online
    multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Ball scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ball is the passive element of the game and it essentially bounces around
    when it hits another physical body – either the paddles, the ceiling, or the floor.
    The latter two are `StaticBody2D`, which use `WorldBoundaryShape2D` in their `CollisionShape2D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `res://07.developing-online-pong/Ball.tscn` scene.
    The scene structure follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The Ball scene’s node hierarchy](img/Figure_07.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The Ball scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we open the `Ball` script, notice that the `CollisionShape2D` Resource
    has a built-in tool script attached to it. It’s a very simple script that draws
    the `CircleShape2D` Resource using the `CanvasItem.draw_circle()` method. This
    is the logic behind it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, let’s open the `Ball` script and see how it works, pay attention
    especially to the bouncing logic because it uses some interesting `Vector2` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code moves the ball’s `CharacterBody2D` node at a specified speed, randomizes
    its motion direction, detects collisions with other objects, and makes the character
    bounce off surfaces upon collision. By using this script, the ball performs a
    dynamic and responsive movement with collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will understand how we detect when a player scores against
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: Managing players’ scores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the ball reaches the left or right of the screen, the player on the opposite
    side should score. To detect this condition, we make use of a `ScoreArea` node,
    which, in essence, is an `Area2D` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res://07.developing-online-pong/ScoreArea.tscn` scene and we’ll take
    a look at its scene tree structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The ScoreArea scene’s node hierarchy](img/Figure_07.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The ScoreArea scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, it’s just an `Area2D` node; it doesn’t even have a
    `CollisionShape2D` Resource because, in this case, it’s more friendly to add it
    in the final scene so we can choose a specific `Shape2D` Resource for each `ScoreArea`
    node. Now, let’s take a look at its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code provides a simple way to keep track of a score in a game using an
    `Area2D` node. It emits a scored signal whenever another physical body (in this
    case, the ball) enters the area, incrementing the score by one. By connecting
    to this signal, other game objects can respond to score updates and perform related
    actions. We use this signal later on in the `PongGame` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure the `ScoreArea` node only detects the ball, we make use of **Collision
    Layers** and **Collision Masks**. On the ball, here’s how these properties look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The Ball Collision Layer and Collision Mask properties](img/Figure_07.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The Ball Collision Layer and Collision Mask properties
  prefs: []
  type: TYPE_NORMAL
- en: 'The ball is in the second physics layer, but it masks the first one. This is
    so it detects collisions with the paddle, the floor, and the ceiling. It needs
    to be only on the second physics layer because the `ScoreArea` node only masks
    the second layer. We do that to prevent the `ScoreArea` node from detecting any
    other physics body, for instance, the floor or ceiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties](img/Figure_07.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties
  prefs: []
  type: TYPE_NORMAL
- en: And that’s how we ensure that the `ScoreArea` node will only interact with the
    ball. In the next section, we are going to see how we use this signal emitted
    by the `ScoreArea` node to actually update the displayed score, along with the
    overall logic behind the `PongGame` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tying everything together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that these classes operate independently without any coupling,
    which means that they cannot form a cohesive system on their own. The responsibility
    of integrating everything into a coherent system falls on the `PongGame` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first take a look at its scene tree structure so we can understand how
    everything will interact. Open the `res://07.developing-online-pong/PongGame.tscn`
    scene and pay attention to the **Scene** dock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The PongGame scene’s node hierarchy](img/Figure_07.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The PongGame scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you already have a sense of most of these nodes. Let’s just
    take a moment to understand what `ScoreLabel` nodes does. It’s essentially just
    a text on the screen that displays each player’s score. For that, it uses a method
    that changes its text property based on the casting of the score received by the
    `ScoreArea.scored` signal (which is an integer) into a string. The whole `ScoreLabel`
    node’s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in mind, let’s jump into the `PongGame` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code keeps track of scores, displays a winner when a player reaches the
    target score, and allows the game to be restarted when one of the players presses
    the `WinnerDisplay` Node interface. For visual reference, this is how `WinnerDisplay`
    node looks when toggled on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The WinnerDisplay overlay showing the match’s winner](img/Figure_07.07_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – The WinnerDisplay overlay showing the match’s winner
  prefs: []
  type: TYPE_NORMAL
- en: It also initializes the game by randomizing the ball’s movement and starting
    its initial motion. Also, when a player scores, it resets the ball by recentering
    it and starting its movement again.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through all the core classes in our Pong game. They
    are currently meant for local multiplayer, so we need to modify them to support
    online multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to do the necessary work to turn our game
    into a remotely playable Pong game where two players interact with each other,
    each with one paddle so they can compete together!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up online multiplayer paddles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to start your actual work. After understanding the whole project,
    let’s do the necessary work to allow players to play it online!
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online Checkers
    Game*, we saw that changing the multiplayer authority of a `SceneTree` branch
    allows the new peer to take over control of the changes made to that branch of
    nodes. This was how we made it so that the player playing on the white team couldn’t
    move the black team’s pieces, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to dynamically change the multiplayer authority is a core skill that
    we need to develop to maintain a coherent shared world for our players. In the
    situation we mentioned, players took turns in which each of them performed a single
    move and then the opposite player took control of their pieces. In this chapter,
    on the other hand, players must move simultaneously as this is an action game.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we are going to implement a simple approach to give
    each player a paddle to play with.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the paddle’s owner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our paddle implementation, we have a small issue to address. Both paddles
    call `CharacterBody2D.move_and_slide()` inside the `_physics_process()` callback,
    on top of checking for `InputEvent` in the `_unhandled_input()` callback. This
    makes it so that if the other player moves their paddle, the movement may be overwritten
    in the opponent’s game. So, on top of re-assigning the paddles’ multiplayer authority,
    we also need to disable the opponent’s paddle callbacks. Open `res://07.developing-online-pong/Paddle.gd`
    and let’s do it! Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method called `setup_multiplayer()` and include the `player_id` argument,
    which represents the network identifier of the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decorate the `setup_multiplayer()` function with the `@rpc` annotation and
    use the `call_local` option. This will ensure that only the server can call this
    method, and it will also call it locally on the server’s endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the function, call the `set_multiplayer_authority()` method and pass
    it the `player_id` argument. With that, we have set up the paddle’s new multiplayer
    authority. Now, we need to prevent its movement if the `player_id` argument doesn’t
    match its multiplayer authority ID. We do that because this RPC function will
    be called on all peers, so the opponent’s paddle is supposed to run the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `is_multiplayer_authority()` method to check that the current paddle’s
    peer ID doesn’t match the multiplayer authority’s peer ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this is the case, call the `set_physics_process()` function and pass it
    the `false` argument to disable physics processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, call the `set_process_unhandled_input()` function and pass `false`
    to disable handling unhandled input events on this paddle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end, the whole `setup_multiplayer()` method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code sets up multiplayer functionality by assigning the paddle’s multiplayer
    authority to a specified player. It then adjusts the behavior of the script based
    on whether the current instance is the authoritative peer. If the instance is
    not the authoritative peer, it disables physics and unhandled input processing
    to ensure that only the authoritative player performs those actions in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s understand how we gather and assign the player’s
    ID to each respective paddle.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the players’ paddles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that each paddle can have its own multiplayer authority and have independent
    physics and input handling processes for each player, it’s time to understand
    how we are going to assign each player to their respective paddle. To do that,
    let’s open the `res://07.developing-online-pong/PongGame.gd` script and, right
    in its `_ready()` function, let’s create the necessary logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, include the `await` keyword followed by the `get_tree().create_timer(0.1).timeout`
    expression. This creates a delay of 0.1 seconds and waits for its `timeout` signal
    to emit. This is important because we are going to use RPCs to call functions
    on remote nodes, and these nodes may not be ready by the time the game executes
    this code, so instead it waits a brief moment before executing its behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, check whether the size of the connected peers is greater than `0` by
    using the `multiplayer.get_peers().size()` method. This will ensure the following
    behavior only happens if there are peers connected; otherwise, the game runs as
    it should locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this is the case, check whether the current instance is the current multiplayer
    authority by using `is_multiplayer_authority()`. This ensures that only the server
    will perform the player assignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this condition, assign the first connected peer to the `player_1` variable.
    This will store the first player’s ID in this variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, assign the second connected peer to the `player_2` variable. This will
    store the second player’s ID in this variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s use the `rpc()` method to call the `setup_multiplayer` method remotely
    on the `player_1_paddle` and `player_2_paddle` nodes, passing their respective
    `player` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The whole `PongGame._ready()` callback should look like this after these changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code demonstrates asynchronous programming and multiplayer setup. It starts
    by randomizing the random number generator and then introduces a delay of 0.1
    seconds. It checks whether there are connected peers and whether the current instance
    is the multiplayer authority – in other words, the server. If these conditions
    are met, it assigns the connected peers to variables and uses RPCs to call the
    `Paddle.setup_multiplayer()` method with the respective peer information. Finally,
    it moves the `ball` object.
  prefs: []
  type: TYPE_NORMAL
- en: In order to properly set up who controls it, we provide `Paddle.setup_multiplayer()`
    with the required data – specifically, the player ID. However, a small problem
    arises when each player can only control their own paddle. How will players update
    their opponent’s paddle position? Moreover, who should control the ball and how
    will its position be updated in both players’ game instances? These questions
    will be addressed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing remote objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With each player controlling their respective paddle in their own game instance,
    we have a small problem. The opponent’s paddle will not update its movement because
    we ensured that both its physics and input processes were disabled after we assigned
    a new multiplayer authority. Due to that, the ball may also bounce on the opponent’s
    paddle and create a different movement trajectory in each player’s game instance.
    We need to ensure that players are sharing the same game world and, for that,
    we are going to sync the objects across the network using `MultiplayerSynchronizer`.
    In the next section, we are going to start the syncing of the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the ball’s position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is ensure the ball’s position is synced
    across all peers. This is because we want to prevent players from dealing with
    different balls in their game instances, since this may lead them to make decisions
    based on wrong information. For instance, a player may move toward a ball that,
    in their game instance, is moving toward the ceiling, while in the server’s game
    instance, the ball is actually moving toward the floor. Let’s open `res://07.developing-online-pong/Ball.tscn`
    and start the simple process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `MultiplayerSynchronizer` as the `Ball` node’s child. We are going to use
    this node’s features to keep all peers up to date with the ball’s `CharacterBody2D`
    position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node](img/Figure_07.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, using the `CharacterBody2D:position` property to replicate across the
    connected peers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu](img/Figure_07.09_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since we are working with physics bodies here, we need to ensure that
    the `MultiplayerSynchronizer` updates to the local `Physics` update, ensuring
    that the game will take into account any collisions and other physics simulations
    when it updates the `Paddle` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property
    set to Physics](img/Figure_7.10_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property
    set to Physics
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent any overwriting of the ball’s position in any player’s instance
    of the game, let’s open the ball’s script and add a code snippet at its `_ready()`
    callback stating that if this peer isn’t the multiplayer authority, it will disable
    the ball’s `_physics_process()`callback. This will make it so that only the server
    has the authority to actually calculate the ball’s movement and, ultimately, its
    position, while players only replicate this in their game instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, the ball’s movement should be the same across all connected peers,
    preventing them from making decisions based on an object that the other peers
    are seeing differently. This would break the game experience because, ultimately,
    the players would be playing in a different game world making movements that don’t
    make sense to their peers. In the next section, let’s do the same process for
    the `Paddle` object; of course, in this one, we won’t need to disable `_physics_process()`
    because we do that when we set up its multiplayer authority.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinating the paddle’s position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, it’s time to sync the players’ paddle positions to each other so they
    see their opponent’s moves and can be on the same page. Let’s open the `res://07.developing-online-pong/Paddle.tscn`
    scene and start the work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `MultiplayerSynchronizer` as a `Paddle` child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node](img/Figure_07.11_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CharacterBody2D:position` property to replicate across the connected
    peers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu](img/Figure_07.12_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the **Ball** scene case, we are also working with a physics body
    here, so change the **Visibility Update** property to update during the **Physics**
    process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property
    set to Physics](img/Figure_07.13_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property
    set to Physics
  prefs: []
  type: TYPE_NORMAL
- en: With this implementation, each opponent’s paddle will have its `CharacterBody2D`
    position synchronized across all peers in the game. This results in a shared game
    world that players can enjoy together while competing in a fair environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how the Godot Engine High-Level Network API provides
    quick and easy solutions to assign the correct “owner” of a game object and sync
    its state across the network. This ensures that players are playing in a shared
    environment with an actual human opponent on the other side.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to check whether the current game instance is the multiplayer
    authority and make it perform the proper behavior accordingly. We also learned
    how to change the multiplayer authority of a node hierarchy on the `SceneTree`,
    ensuring that only a given player can make and sync changes regarding this node
    and its children. To sync the changes, we used `MultiplayerSynchronizer` with
    the **Physics** mode of **Visibility Update** to ensure that the physics interactions
    of the game objects are synced across all network peers.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will strengthen our knowledge of online multiplayer
    games by creating a platformer game that two or more players can play together
    and explore the game world as they please. We are confident that this will be
    an exciting addition to our game development skills.
  prefs: []
  type: TYPE_NORMAL
