- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Developing an Online Pong Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发在线 Pong 游戏
- en: 'It’s time to slowly get into some more complex aspects of making online multiplayer
    games. In [*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online
    Checkers Game*, we saw how two players can share the same game world and see their
    actions have repercussions in the other players’ game states. This happened with
    players taking turns, so we didn’t have one of the most troublesome aspects of
    online multiplayer games involved: time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候逐渐深入到制作在线多人游戏的更复杂方面了。在[*第 6 章*](B18527_06.xhtml#_idTextAnchor131)“构建在线国际象棋游戏”中，我们看到了两位玩家如何共享同一个游戏世界，并看到他们的动作对其他玩家的游戏状态产生影响。这种情况发生在玩家轮流进行时，所以我们没有涉及到在线多人游戏中最麻烦的方面之一：时间。
- en: 'In this chapter, we are going to start working with action games, which have
    hand-eye coordination and response time as their core features. We’ll start with
    making a replica of one of the simplest physics-based games out there: Pong. Using
    the base project as a starting point, we will then turn it into an online multiplayer
    Pong game where each player controls one paddle and the Godot Engine high-level
    networking features will be responsible for keeping players in sync within the
    same game world.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始处理动作游戏，这些游戏的核心特征是手眼协调和反应时间。我们将从一个最简单的基于物理学的游戏之一：Pong 的复制品开始。以基础项目为起点，我们将将其变成一个在线多人
    Pong 游戏，其中每个玩家控制一个球拍，Godot 引擎的高级网络功能将负责在同一个游戏世界中保持玩家的同步。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Pong project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Pong 项目
- en: Setting up online multiplayer paddles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置在线多人球拍
- en: Syncing remote objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步远程对象
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we are going to use our repository of online projects, which
    can be found through the following link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用我们的在线项目仓库，您可以通过以下链接找到：
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
- en: With the project opened in Godot Engine, open the `res://07.developing-online-pong`
    folder; everything we need for this chapter is there. That said, let’s start by
    understanding how our Pong project works and what we need to do to turn it into
    an online multiplayer game. As stated throughout the previous chapter, we will
    also use Godot Engine version 4.0, so if you have other versions of the engine,
    please make sure you are using the correct one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 引擎中打开项目后，打开 `res://07.developing-online-pong` 文件夹；本章所需的一切都在那里。话虽如此，让我们首先了解我们的
    Pong 项目是如何工作的，以及我们需要做什么才能将其变成一个在线多人游戏。正如前一章所述，我们也将使用 Godot 引擎版本 4.0，所以如果你有其他版本的引擎，请确保你使用的是正确的版本。
- en: Introducing the Pong project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Pong 项目
- en: Welcome to yet another project for our fake indie game development studio, network
    engineer! This time, we need to make the onboarding of our next project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们虚构的独立游戏开发工作室的另一个项目，网络工程师！这次，我们需要为我们的下一个项目进行入职。
- en: We have a Pong game that we think we can turn into a competitive online multiplayer
    game with some leaderboards and all this cool stuff. Your core task here is to
    make its core features playable by two players through a network. Let’s understand
    what we have currently so we can point out what you going to modify.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 Pong 游戏，我们认为我们可以通过一些排行榜和所有这些酷炫的功能将其变成一个具有竞争力的在线多人游戏。您在这里的核心任务是使游戏的核心功能可以通过网络由两名玩家进行游戏。让我们了解我们目前拥有的内容，以便指出您将要修改的内容。
- en: How the player paddles work
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家球拍的工作原理
- en: The players’ paddles are the most important thing in our project. They are the
    only thing players actually control and, as such, they are the main way players
    interact with the game. By moving them, the players can bounce the ball off to
    the other player.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的球拍是我们项目中最重要的部分。它们是玩家唯一可以控制的东西，因此它们是玩家与游戏互动的主要方式。通过移动它们，玩家可以将球反弹给对方。
- en: 'Let’s take a brief look at the `res://07.developing-online-pong/Paddle.tscn`
    scene. Its scene tree structure looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下 `res://07.developing-online-pong/Paddle.tscn` 场景。其场景树结构如下：
- en: '![Figure 7.1 – The Paddle scene’s node hierarchy](img/Figure_07.01_B18527.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 球拍场景的节点层次结构](img/Figure_07.01_B18527.jpg)'
- en: Figure 7.1 – The Paddle scene’s node hierarchy
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 球拍场景的节点层次结构
- en: 'Note that the paddle itself is a `Node2D` node, whereas the actual physical
    body is its child. This is a good way to abstract game entities. They have a physical
    body, but they aren’t a physical body. This allows us to make more sense of them
    in more levels of abstraction. Now, let’s take a look at its script:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，球拍本身是一个`Node2D`节点，而实际的物理体是其子节点。这是一种很好的抽象游戏实体的方式。它们有一个物理体，但它们并不是物理体。这允许我们在更高级别的抽象中更好地理解它们。现在，让我们看看它的脚本：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code allows the paddle to move up and down based on user input. The `speed`
    variable determines the movement speed, and the `up_action` and `down_action`
    variables represent the input actions for moving the paddle. The script handles
    input events and adjusts the character’s velocity accordingly. The paddle moves
    at a constant speed or it stops if no key is pressed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许根据用户输入移动球拍，`speed`变量决定了移动速度，而`up_action`和`down_action`变量代表了移动球拍的输入动作。脚本处理输入事件并相应地调整角色的速度。球拍以恒定速度移动，或者在没有按键按下时停止。
- en: In the next section, let’s see how the ball works. It’s another core object
    in our game that we will need to do some work on in order to turn it into an online
    multiplayer game.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看球是如何工作的。它是我们游戏中另一个核心对象，我们需要对其进行一些工作，以便将其变成一个在线多人游戏。
- en: Understanding the Ball scene
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Ball场景
- en: The ball is the passive element of the game and it essentially bounces around
    when it hits another physical body – either the paddles, the ceiling, or the floor.
    The latter two are `StaticBody2D`, which use `WorldBoundaryShape2D` in their `CollisionShape2D`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 球是游戏中的被动元素，当它撞击另一个物理体时（无论是球拍、天花板还是地板），它本质上会弹跳。后两者是`StaticBody2D`，它们在`CollisionShape2D`中使用`WorldBoundaryShape2D`。
- en: 'Let’s take a look at the `res://07.developing-online-pong/Ball.tscn` scene.
    The scene structure follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`res://07.developing-online-pong/Ball.tscn`场景。场景结构如下：
- en: '![Figure 7.2 – The Ball scene’s node hierarchy](img/Figure_07.02_B18527.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – Ball场景的节点层次结构](img/Figure_07.02_B18527.jpg)'
- en: Figure 7.2 – The Ball scene’s node hierarchy
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – Ball场景的节点层次结构
- en: 'Before we open the `Ball` script, notice that the `CollisionShape2D` Resource
    has a built-in tool script attached to it. It’s a very simple script that draws
    the `CircleShape2D` Resource using the `CanvasItem.draw_circle()` method. This
    is the logic behind it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打开`Ball`脚本之前，请注意，`CollisionShape2D`资源附有一个内置的工具脚本。这是一个非常简单的脚本，它使用`CanvasItem.draw_circle()`方法绘制`CircleShape2D`资源。这是其背后的逻辑：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That said, let’s open the `Ball` script and see how it works, pay attention
    especially to the bouncing logic because it uses some interesting `Vector2` methods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们打开`Ball`脚本，看看它是如何工作的，特别注意弹跳逻辑，因为它使用了一些有趣的`Vector2`方法：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code moves the ball’s `CharacterBody2D` node at a specified speed, randomizes
    its motion direction, detects collisions with other objects, and makes the character
    bounce off surfaces upon collision. By using this script, the ball performs a
    dynamic and responsive movement with collision detection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以指定速度移动球的`CharacterBody2D`节点，随机化其运动方向，检测与其他对象的碰撞，并在碰撞时使角色从表面上弹起。通过使用此脚本，球可以进行动态和响应式的运动，并具有碰撞检测功能。
- en: In the next section, we will understand how we detect when a player scores against
    the other.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何检测玩家得分的情况。
- en: Managing players’ scores
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理玩家得分
- en: When the ball reaches the left or right of the screen, the player on the opposite
    side should score. To detect this condition, we make use of a `ScoreArea` node,
    which, in essence, is an `Area2D` node.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当球到达屏幕的左侧或右侧时，另一侧的玩家应该得分。为了检测这种条件，我们使用了一个`ScoreArea`节点，本质上它是一个`Area2D`节点。
- en: 'Open the `res://07.developing-online-pong/ScoreArea.tscn` scene and we’ll take
    a look at its scene tree structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`res://07.developing-online-pong/ScoreArea.tscn`场景，我们将查看其场景树结构：
- en: '![Figure 7.3 – The ScoreArea scene’s node hierarchy](img/Figure_07.03_B18527.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – ScoreArea场景的节点层次结构](img/Figure_07.03_B18527.jpg)'
- en: Figure 7.3 – The ScoreArea scene’s node hierarchy
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – ScoreArea场景的节点层次结构
- en: 'As mentioned previously, it’s just an `Area2D` node; it doesn’t even have a
    `CollisionShape2D` Resource because, in this case, it’s more friendly to add it
    in the final scene so we can choose a specific `Shape2D` Resource for each `ScoreArea`
    node. Now, let’s take a look at its code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，它只是一个`Area2D`节点；它甚至没有`CollisionShape2D`资源，因为在这种情况中，在最终场景中添加它更为友好，这样我们就可以为每个`ScoreArea`节点选择一个特定的`Shape2D`资源。现在，让我们看看它的代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code provides a simple way to keep track of a score in a game using an
    `Area2D` node. It emits a scored signal whenever another physical body (in this
    case, the ball) enters the area, incrementing the score by one. By connecting
    to this signal, other game objects can respond to score updates and perform related
    actions. We use this signal later on in the `PongGame` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码提供了一个简单的方法，使用 `Area2D` 节点在游戏中跟踪得分。每当另一个物理体（在这种情况下，是球）进入区域时，它会发出得分信号，并将得分增加一分。通过连接到这个信号，其他游戏对象可以响应得分更新并执行相关操作。我们稍后在
    `PongGame` 类中使用此信号。
- en: 'To ensure the `ScoreArea` node only detects the ball, we make use of **Collision
    Layers** and **Collision Masks**. On the ball, here’s how these properties look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `ScoreArea` 节点只检测球，我们使用了 **碰撞层** 和 **碰撞掩码**。在球上，这些属性看起来是这样的：
- en: '![Figure 7.4 – The Ball Collision Layer and Collision Mask properties](img/Figure_07.04_B18527.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 球碰撞层和碰撞掩码属性](img/Figure_07.04_B18527.jpg)'
- en: Figure 7.4 – The Ball Collision Layer and Collision Mask properties
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 球碰撞层和碰撞掩码属性
- en: 'The ball is in the second physics layer, but it masks the first one. This is
    so it detects collisions with the paddle, the floor, and the ceiling. It needs
    to be only on the second physics layer because the `ScoreArea` node only masks
    the second layer. We do that to prevent the `ScoreArea` node from detecting any
    other physics body, for instance, the floor or ceiling:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 球位于第二个物理层，但它遮蔽了第一个层。这样做是为了检测与挡板、地板和天花板的碰撞。它只需要位于第二个物理层，因为 `ScoreArea` 节点只遮蔽第二个层。我们这样做是为了防止
    `ScoreArea` 节点检测到任何其他物理体，例如地板或天花板：
- en: '![Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties](img/Figure_07.05_B18527.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – ScoreArea 碰撞层和碰撞掩码属性](img/Figure_07.05_B18527.jpg)'
- en: Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – ScoreArea 碰撞层和碰撞掩码属性
- en: And that’s how we ensure that the `ScoreArea` node will only interact with the
    ball. In the next section, we are going to see how we use this signal emitted
    by the `ScoreArea` node to actually update the displayed score, along with the
    overall logic behind the `PongGame` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就确保了 `ScoreArea` 节点只会与球交互。在下一节中，我们将看到如何使用 `ScoreArea` 节点发出的这个信号来实际更新显示的得分，以及
    `PongGame` 类背后的整体逻辑。
- en: Tying everything together
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切联系在一起
- en: You may have noticed that these classes operate independently without any coupling,
    which means that they cannot form a cohesive system on their own. The responsibility
    of integrating everything into a coherent system falls on the `PongGame` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些类独立运行，没有任何耦合，这意味着它们不能单独形成一个完整的系统。将所有内容整合成一个连贯系统的责任落在 `PongGame` 类上。
- en: 'Let’s first take a look at its scene tree structure so we can understand how
    everything will interact. Open the `res://07.developing-online-pong/PongGame.tscn`
    scene and pay attention to the **Scene** dock:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看它的场景树结构，这样我们就可以了解所有内容将如何交互。打开 `res://07.developing-online-pong/PongGame.tscn`
    场景，并注意 **场景** 选项卡：
- en: '![Figure 7.6 – The PongGame scene’s node hierarchy](img/Figure_07.06_B18527.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – PongGame 场景的节点层次结构](img/Figure_07.06_B18527.jpg)'
- en: Figure 7.6 – The PongGame scene’s node hierarchy
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – PongGame 场景的节点层次结构
- en: 'At this point, you already have a sense of most of these nodes. Let’s just
    take a moment to understand what `ScoreLabel` nodes does. It’s essentially just
    a text on the screen that displays each player’s score. For that, it uses a method
    that changes its text property based on the casting of the score received by the
    `ScoreArea.scored` signal (which is an integer) into a string. The whole `ScoreLabel`
    node’s code is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经对这些节点有了大致的了解。让我们花一点时间来理解 `ScoreLabel` 节点的作用。它本质上只是在屏幕上显示每个玩家得分的文本。为此，它使用一个根据
    `ScoreArea.scored` 信号（一个整数）转换为字符串的方法来改变其文本属性。整个 `ScoreLabel` 节点的代码如下：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With that in mind, let’s jump into the `PongGame` code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，让我们进入 `PongGame` 代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code keeps track of scores, displays a winner when a player reaches the
    target score, and allows the game to be restarted when one of the players presses
    the `WinnerDisplay` Node interface. For visual reference, this is how `WinnerDisplay`
    node looks when toggled on:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码跟踪得分，当玩家达到目标得分时显示获胜者，并且当任一玩家按下 `WinnerDisplay` 节点接口时允许游戏重新开始。为了视觉参考，这是 `WinnerDisplay`
    节点开启时的样子：
- en: '![Figure 7.7 – The WinnerDisplay overlay showing the match’s winner](img/Figure_07.07_B18527.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 显示比赛获胜者的WinnerDisplay叠加层](img/Figure_07.07_B18527.jpg)'
- en: Figure 7.7 – The WinnerDisplay overlay showing the match’s winner
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 显示比赛获胜者的WinnerDisplay叠加层
- en: It also initializes the game by randomizing the ball’s movement and starting
    its initial motion. Also, when a player scores, it resets the ball by recentering
    it and starting its movement again.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它还通过随机化球体的运动并开始其初始运动来初始化游戏。此外，当玩家得分时，它通过重新居中球体并再次开始其运动来重置球体。
- en: In this section, we went through all the core classes in our Pong game. They
    are currently meant for local multiplayer, so we need to modify them to support
    online multiplayer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了我们Pong游戏中的所有核心类。它们目前旨在支持本地多人游戏，因此我们需要修改它们以支持在线多人游戏。
- en: In the next section, we are going to do the necessary work to turn our game
    into a remotely playable Pong game where two players interact with each other,
    each with one paddle so they can compete together!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进行必要的工作，将我们的游戏转变为一个远程可玩的Pong游戏，其中两名玩家通过各自的拍子相互交互，以便他们可以一起竞争！
- en: Setting up online multiplayer paddles
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置在线多人游戏拍子
- en: It’s time to start your actual work. After understanding the whole project,
    let’s do the necessary work to allow players to play it online!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始你的实际工作了。在理解整个项目之后，让我们做必要的工作，让玩家能够在线玩游戏！
- en: In [*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online Checkers
    Game*, we saw that changing the multiplayer authority of a `SceneTree` branch
    allows the new peer to take over control of the changes made to that branch of
    nodes. This was how we made it so that the player playing on the white team couldn’t
    move the black team’s pieces, and vice versa.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18527_06.xhtml#_idTextAnchor131)《构建在线国际象棋游戏》中，我们看到了通过更改`SceneTree`分支的多人游戏权限，新的对等方可以接管对该节点分支所做的更改。这就是我们让白色队伍的玩家无法移动黑色队伍的棋子，反之亦然的方法。
- en: Being able to dynamically change the multiplayer authority is a core skill that
    we need to develop to maintain a coherent shared world for our players. In the
    situation we mentioned, players took turns in which each of them performed a single
    move and then the opposite player took control of their pieces. In this chapter,
    on the other hand, players must move simultaneously as this is an action game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 能够动态改变多人游戏权限是我们需要培养的核心技能，以保持玩家共享世界的连贯性。在我们提到的情境中，玩家轮流进行，每个玩家执行一个动作，然后由对方玩家控制他们的棋子。另一方面，在本章中，玩家必须同时移动，因为这是一款动作游戏。
- en: In the upcoming sections, we are going to implement a simple approach to give
    each player a paddle to play with.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将实现一个简单的方法，为每个玩家提供一个可以玩耍的拍子。
- en: Changing the paddle’s owner
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改拍子的所有者
- en: 'In our paddle implementation, we have a small issue to address. Both paddles
    call `CharacterBody2D.move_and_slide()` inside the `_physics_process()` callback,
    on top of checking for `InputEvent` in the `_unhandled_input()` callback. This
    makes it so that if the other player moves their paddle, the movement may be overwritten
    in the opponent’s game. So, on top of re-assigning the paddles’ multiplayer authority,
    we also need to disable the opponent’s paddle callbacks. Open `res://07.developing-online-pong/Paddle.gd`
    and let’s do it! Follow these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的拍子实现中，我们有一个小问题需要解决。两个拍子都在`_physics_process()`回调中调用`CharacterBody2D.move_and_slide()`，同时在`_unhandled_input()`回调中检查`InputEvent`。这使得如果其他玩家移动他们的拍子，移动可能会在对手的游戏中被覆盖。因此，除了重新分配拍子的多人游戏权限外，我们还需要禁用对手的拍子回调。打开`res://07.developing-online-pong/Paddle.gd`并让我们来做这件事！按照以下步骤操作：
- en: 'Create a method called `setup_multiplayer()` and include the `player_id` argument,
    which represents the network identifier of the player:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setup_multiplayer()`的方法，并包含`player_id`参数，它代表玩家的网络标识符：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Decorate the `setup_multiplayer()` function with the `@rpc` annotation and
    use the `call_local` option. This will ensure that only the server can call this
    method, and it will also call it locally on the server’s endpoint:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@rpc`注解装饰`setup_multiplayer()`函数并使用`call_local`选项。这将确保只有服务器可以调用此方法，并且它还会在服务器的端点上本地调用它：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the function, call the `set_multiplayer_authority()` method and pass
    it the `player_id` argument. With that, we have set up the paddle’s new multiplayer
    authority. Now, we need to prevent its movement if the `player_id` argument doesn’t
    match its multiplayer authority ID. We do that because this RPC function will
    be called on all peers, so the opponent’s paddle is supposed to run the following
    code block:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，调用`set_multiplayer_authority()`方法并传递`player_id`参数。这样，我们就设置了拍子的新多人授权。现在，如果`player_id`参数不匹配其多人授权ID，我们需要防止其移动。我们这样做是因为这个RPC函数将在所有对等方上调用，所以对手的拍子应该运行以下代码块：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the `is_multiplayer_authority()` method to check that the current paddle’s
    peer ID doesn’t match the multiplayer authority’s peer ID:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`is_multiplayer_authority()`方法检查当前拍子的对等方ID是否与多人授权的对等方ID不匹配：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If this is the case, call the `set_physics_process()` function and pass it
    the `false` argument to disable physics processing:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，调用`set_physics_process()`函数并传递`false`参数以禁用物理处理：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Likewise, call the `set_process_unhandled_input()` function and pass `false`
    to disable handling unhandled input events on this paddle:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，调用`set_process_unhandled_input()`函数并传递`false`以禁用在此拍子上处理未处理输入事件：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the end, the whole `setup_multiplayer()` method should look like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，整个`setup_multiplayer()`方法应该看起来像这样：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code sets up multiplayer functionality by assigning the paddle’s multiplayer
    authority to a specified player. It then adjusts the behavior of the script based
    on whether the current instance is the authoritative peer. If the instance is
    not the authoritative peer, it disables physics and unhandled input processing
    to ensure that only the authoritative player performs those actions in this instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过将拍子的多人权限分配给指定的玩家来设置多人功能。然后根据当前实例是否是授权对等方来调整脚本的行为。如果实例不是授权对等方，它将禁用物理和未处理输入处理，以确保只有授权玩家在此实例中执行这些操作。
- en: In the next section, let’s understand how we gather and assign the player’s
    ID to each respective paddle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们了解我们如何收集并将玩家的ID分配给每个相应的拍子。
- en: Assigning the players’ paddles
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配玩家的拍子
- en: 'Now that each paddle can have its own multiplayer authority and have independent
    physics and input handling processes for each player, it’s time to understand
    how we are going to assign each player to their respective paddle. To do that,
    let’s open the `res://07.developing-online-pong/PongGame.gd` script and, right
    in its `_ready()` function, let’s create the necessary logic:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然每个拍子都可以有自己的多人权限，并为每个玩家拥有独立的物理和输入处理过程，是时候了解我们如何将每个玩家分配到他们各自的拍子上了。为了做到这一点，让我们打开`res://07.developing-online-pong/PongGame.gd`脚本，并在其`_ready()`函数中创建必要的逻辑：
- en: 'First of all, include the `await` keyword followed by the `get_tree().create_timer(0.1).timeout`
    expression. This creates a delay of 0.1 seconds and waits for its `timeout` signal
    to emit. This is important because we are going to use RPCs to call functions
    on remote nodes, and these nodes may not be ready by the time the game executes
    this code, so instead it waits a brief moment before executing its behavior:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包含`await`关键字后跟`get_tree().create_timer(0.1).timeout`表达式。这会创建一个0.1秒的延迟并等待其`timeout`信号发出。这很重要，因为我们将要使用RPC调用远程节点上的函数，而这些节点可能不会在游戏执行此代码时准备好，因此它会在执行其行为之前等待一小段时间：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, check whether the size of the connected peers is greater than `0` by
    using the `multiplayer.get_peers().size()` method. This will ensure the following
    behavior only happens if there are peers connected; otherwise, the game runs as
    it should locally:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`multiplayer.get_peers().size()`方法检查连接的对等方的大小是否大于`0`。这将确保以下行为仅在存在对等方时发生；否则，游戏将像本地一样运行：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If this is the case, check whether the current instance is the current multiplayer
    authority by using `is_multiplayer_authority()`. This ensures that only the server
    will perform the player assignment:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，使用`is_multiplayer_authority()`检查当前实例是否是当前多人授权。这确保只有服务器将执行玩家分配：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside this condition, assign the first connected peer to the `player_1` variable.
    This will store the first player’s ID in this variable:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个条件内部，将第一个连接的对等方分配给`player_1`变量。这将在此变量中存储第一个玩家的ID：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, assign the second connected peer to the `player_2` variable. This will
    store the second player’s ID in this variable:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将第二个连接的对等方分配给`player_2`变量。这将在此变量中存储第二个玩家的ID：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, let’s use the `rpc()` method to call the `setup_multiplayer` method remotely
    on the `player_1_paddle` and `player_2_paddle` nodes, passing their respective
    `player` variables:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用`rpc()`方法在`player_1_paddle`和`player_2_paddle`节点上远程调用`setup_multiplayer`方法，传递它们各自的`player`变量：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The whole `PongGame._ready()` callback should look like this after these changes:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些更改之后，整个`PongGame._ready()`回调应如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code demonstrates asynchronous programming and multiplayer setup. It starts
    by randomizing the random number generator and then introduces a delay of 0.1
    seconds. It checks whether there are connected peers and whether the current instance
    is the multiplayer authority – in other words, the server. If these conditions
    are met, it assigns the connected peers to variables and uses RPCs to call the
    `Paddle.setup_multiplayer()` method with the respective peer information. Finally,
    it moves the `ball` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了异步编程和多玩家设置。它首先随机化随机数生成器，然后引入0.1秒的延迟。它检查是否有连接的对等体以及当前实例是否是多玩家权限者——换句话说，是服务器。如果这些条件得到满足，它将连接的对等体分配给变量，并使用RPC调用`Paddle.setup_multiplayer()`方法，传递相应的对等体信息。最后，它移动`ball`对象。
- en: In order to properly set up who controls it, we provide `Paddle.setup_multiplayer()`
    with the required data – specifically, the player ID. However, a small problem
    arises when each player can only control their own paddle. How will players update
    their opponent’s paddle position? Moreover, who should control the ball and how
    will its position be updated in both players’ game instances? These questions
    will be addressed in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设置谁控制它，我们向`Paddle.setup_multiplayer()`提供所需的数据——具体来说，是玩家ID。然而，当每个玩家只能控制他们自己的桨时，会出现一个小问题。玩家将如何更新对手的桨位置？此外，谁应该控制球，以及如何在两个玩家的游戏实例中更新其位置？这些问题将在下一节中解决。
- en: Syncing remote objects
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步远程对象
- en: With each player controlling their respective paddle in their own game instance,
    we have a small problem. The opponent’s paddle will not update its movement because
    we ensured that both its physics and input processes were disabled after we assigned
    a new multiplayer authority. Due to that, the ball may also bounce on the opponent’s
    paddle and create a different movement trajectory in each player’s game instance.
    We need to ensure that players are sharing the same game world and, for that,
    we are going to sync the objects across the network using `MultiplayerSynchronizer`.
    In the next section, we are going to start the syncing of the ball.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个玩家都在他们自己的游戏实例中控制他们各自的桨，我们遇到了一个小问题。对手的桨不会更新其移动，因为我们确保在分配新的多玩家权限后，其物理和输入过程都被禁用了。因此，球也可能在对手的桨上弹跳，并在每个玩家的游戏实例中创建不同的运动轨迹。我们需要确保玩家共享相同的游戏世界，为此，我们将使用`MultiplayerSynchronizer`在网络中同步对象。在下一节中，我们将开始同步球。
- en: Updating the ball’s position
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新球的位置
- en: 'The first thing we are going to do is ensure the ball’s position is synced
    across all peers. This is because we want to prevent players from dealing with
    different balls in their game instances, since this may lead them to make decisions
    based on wrong information. For instance, a player may move toward a ball that,
    in their game instance, is moving toward the ceiling, while in the server’s game
    instance, the ball is actually moving toward the floor. Let’s open `res://07.developing-online-pong/Ball.tscn`
    and start the simple process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要确保球的位置在所有对等体之间同步。这是因为我们希望防止玩家在他们的游戏实例中处理不同的球，因为这可能导致他们根据错误的信息做出决策。例如，一个玩家可能朝着在他们自己的游戏实例中朝天花板移动的球移动，而在服务器的游戏实例中，球实际上是在朝地板移动。让我们打开`res://07.developing-online-pong/Ball.tscn`并开始简单的流程：
- en: 'Add `MultiplayerSynchronizer` as the `Ball` node’s child. We are going to use
    this node’s features to keep all peers up to date with the ball’s `CharacterBody2D`
    position:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MultiplayerSynchronizer`作为`Ball`节点的子节点添加。我们将使用此节点的功能来确保所有对等体都更新球的`CharacterBody2D`位置：
- en: '![Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node](img/Figure_07.08_B18527.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 添加了MultiplayerSynchronizer节点的Ball场景的节点层次结构](img/Figure_07.08_B18527.jpg)'
- en: Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 添加了MultiplayerSynchronizer节点的Ball场景的节点层次结构
- en: 'Then, using the `CharacterBody2D:position` property to replicate across the
    connected peers:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`CharacterBody2D:position`属性在连接的对等体之间复制：
- en: '![Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu](img/Figure_07.09_B18527.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since we are working with physics bodies here, we need to ensure that
    the `MultiplayerSynchronizer` updates to the local `Physics` update, ensuring
    that the game will take into account any collisions and other physics simulations
    when it updates the `Paddle` instances:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property
    set to Physics](img/Figure_7.10_B18527.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property
    set to Physics
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent any overwriting of the ball’s position in any player’s instance
    of the game, let’s open the ball’s script and add a code snippet at its `_ready()`
    callback stating that if this peer isn’t the multiplayer authority, it will disable
    the ball’s `_physics_process()`callback. This will make it so that only the server
    has the authority to actually calculate the ball’s movement and, ultimately, its
    position, while players only replicate this in their game instances:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With that, the ball’s movement should be the same across all connected peers,
    preventing them from making decisions based on an object that the other peers
    are seeing differently. This would break the game experience because, ultimately,
    the players would be playing in a different game world making movements that don’t
    make sense to their peers. In the next section, let’s do the same process for
    the `Paddle` object; of course, in this one, we won’t need to disable `_physics_process()`
    because we do that when we set up its multiplayer authority.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Coordinating the paddle’s position
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, it’s time to sync the players’ paddle positions to each other so they
    see their opponent’s moves and can be on the same page. Let’s open the `res://07.developing-online-pong/Paddle.tscn`
    scene and start the work:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `MultiplayerSynchronizer` as a `Paddle` child:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node](img/Figure_07.11_B18527.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer
    node
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CharacterBody2D:position` property to replicate across the connected
    peers:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu](img/Figure_07.12_B18527.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer
    Replication menu
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the **Ball** scene case, we are also working with a physics body
    here, so change the **Visibility Update** property to update during the **Physics**
    process:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property
    set to Physics](img/Figure_07.13_B18527.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property
    set to Physics
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 橡皮球多玩家同步器的可见性更新属性设置为物理
- en: With this implementation, each opponent’s paddle will have its `CharacterBody2D`
    position synchronized across all peers in the game. This results in a shared game
    world that players can enjoy together while competing in a fair environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，每个对手的橡皮球都将拥有其`CharacterBody2D`位置在游戏中的所有节点之间同步。这导致了一个共享的游戏世界，玩家可以在一个公平的环境中竞争的同时一起享受游戏。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how the Godot Engine High-Level Network API provides
    quick and easy solutions to assign the correct “owner” of a game object and sync
    its state across the network. This ensures that players are playing in a shared
    environment with an actual human opponent on the other side.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Godot引擎高级网络API如何提供快速简便的解决方案来分配游戏对象的正确“所有者”并在网络中同步其状态。这确保了玩家在一个共享的环境中玩游戏，另一边是一个真实的人类对手。
- en: We learned how to check whether the current game instance is the multiplayer
    authority and make it perform the proper behavior accordingly. We also learned
    how to change the multiplayer authority of a node hierarchy on the `SceneTree`,
    ensuring that only a given player can make and sync changes regarding this node
    and its children. To sync the changes, we used `MultiplayerSynchronizer` with
    the **Physics** mode of **Visibility Update** to ensure that the physics interactions
    of the game objects are synced across all network peers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何检查当前游戏实例是否是多玩家权限，并使其相应地执行正确的行为。我们还学习了如何在`SceneTree`上的节点层次结构中更改多玩家权限，确保只有指定的玩家可以对此节点及其子节点进行创建和同步更改。为了同步更改，我们使用了具有**物理**模式的**可见性更新**的`MultiplayerSynchronizer`，以确保游戏对象的物理交互在网络所有节点之间同步。
- en: In the upcoming chapter, we will strengthen our knowledge of online multiplayer
    games by creating a platformer game that two or more players can play together
    and explore the game world as they please. We are confident that this will be
    an exciting addition to our game development skills.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过创建一个两个或更多玩家可以一起玩并随意探索游戏世界的平台游戏来加强我们对在线多人游戏的了解。我们相信这将是我们游戏开发技能的一个令人兴奋的补充。
