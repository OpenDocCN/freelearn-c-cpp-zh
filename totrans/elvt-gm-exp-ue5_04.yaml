- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Getting Started with Player Input
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用玩家输入
- en: In the previous chapter, we created our C++ class, which inherits from the `Character`
    class, and added all the necessary `Actor` components to be able to see the game
    from the character’s perspective, as well as being able to see the character itself.
    We then created a `Blueprint` class that inherits from that C++ class in order
    to visually set up all of its necessary components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个从 `Character` 类继承的 C++ 类，并添加了所有必要的 `Actor` 组件，以便能够从角色的视角看到游戏，以及能够看到角色本身。然后我们创建了一个从该
    C++ 类继承的 `Blueprint` 类，以便可视化地设置所有必要的组件。
- en: In this chapter, we will be looking at these topics in more depth, as well as
    covering their C++ usage. We will learn about how player input works in UE5, how
    the engine handles input events (*key presses and releases*), and how we can use
    them to control logic in our game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨这些主题，并涵盖它们的 C++ 使用方法。我们将学习 UE5 中玩家输入的工作原理，引擎如何处理输入事件（*按键和释放*），以及我们如何使用它们来控制游戏中的逻辑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Input Actions and Contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解输入动作和上下文
- en: Processing Player Input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家输入
- en: Pivoting the camera around the character
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕角色旋转相机
- en: By the end of this chapter, you will know about **Input Actions** and **Input
    Contexts**, how to create and modify them, how to listen to each of those mappings,
    and how to execute in-game actions when they’re pressed and released.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 **输入动作** 和 **输入上下文**，如何创建和修改它们，如何监听这些映射中的每一个，以及当它们被按下和释放时如何执行游戏中的动作。
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will be using an alternative version of the `Character`
    blueprint we created called `BP_MyTPC` in the previous chapter. This chapter’s
    version will have the default UE5 Mannequin mesh, not the one from Mixamo.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用之前章节中创建的 `Character` 蓝图的一个替代版本，称为 `BP_MyTPC`。本章的版本将使用默认的 UE5 人形网格，而不是
    Mixamo 的网格。
- en: Let’s start this chapter by getting to know how UE5 abstracts the keys pressed
    by a player to make it easier for you to be notified of those events.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解 UE5 如何抽象化玩家按下的键，以便您更容易地通知这些事件开始本章。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The project for this chapter can be found in the Chapter04 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的 Chapter04 文件夹中找到，可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Understanding Input Actions and Contexts
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解输入动作和上下文
- en: Player input is the thing that distinguishes video games from other forms of
    entertainment media – the fact that they’re interactive. For a video game to be
    interactive, it must take into account a player’s input. Many games do this by
    allowing the player to control a virtual character that acts upon the virtual
    world it’s in, depending on the keys and buttons that the player presses, which
    is exactly what we’ll be doing in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家输入是区分视频游戏与其他娱乐媒体形式的关键——它们是交互式的。为了使视频游戏具有交互性，它必须考虑玩家的输入。许多游戏通过允许玩家控制一个虚拟角色来实现这一点，该角色根据玩家按下的键和按钮在虚拟世界中采取行动，这正是本章将要做的。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It’s important to note that UE5 has two input systems – the Legacy Input System,
    used since the start of UE4, and the new Enhanced Input System, introduced only
    in the last version of UE5 as an experimental system and now as a complete plugin
    in UE5\. We will be using the new Enhanced Input System in this book. If you wish
    to know more about UE5’s Legacy Input System, you can do so by accessing this
    link: [https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，UE5 有两个输入系统——自 UE4 开始使用的旧输入系统，以及仅在 UE5 的最新版本中引入的新增强输入系统，最初作为一个实验性系统，现在作为一个完整的插件存在于
    UE5 中。本书我们将使用新的增强输入系统。如果您想了解更多关于 UE5 的旧输入系统信息，可以通过访问此链接来了解：[https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Input/)
- en: Most game development tools nowadays allow you to abstract keypresses into **actions**,
    which allow you to associate a name (for example, *Jump*) with several different
    player inputs (pressing a button, flicking a thumbstick, and so on). In UE5, the
    way in which you can specify this is through the use of **Input Actions** combined
    with **Input Contexts** (also referred to as **Input Mapping Contexts**).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现今大多数游戏开发工具都允许你将按键操作抽象为**动作**，这样你可以将一个名称（例如，*跳跃*）与多个不同的玩家输入（按按钮、滑动摇杆等）关联起来。在
    UE5 中，你可以通过使用**输入动作**结合**输入上下文**（也称为**输入映射上下文**）来指定这一点。
- en: '**Input Contexts** contain **Input Actions** that are associated with them,
    along with which keys will execute them, and **Input Actions** contain specifications
    as to how they will be executed. The combination of both of these assets allows
    you to do something when an **Input Action** is triggered but also easily change
    how that **Input Action** is triggered and by which keys.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入上下文**包含与它们关联的**输入动作**，以及哪些键将执行它们，而**输入动作**包含关于它们如何执行的说明。这两个资产的组合允许你在**输入动作**被触发时执行某些操作，同时也容易更改**输入动作**的触发方式和由哪些键触发。'
- en: In order to better understand how **Input Contexts** and **Input Actions** work
    together, let’s think of a game, such as *GTA*, where you have different gameplay
    contexts in which you control different people/objects with different keys.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解**输入上下文**和**输入动作**是如何协同工作的，让我们考虑一个游戏，比如 *GTA*，在这个游戏中，你有不同的游戏上下文，在这些上下文中，你使用不同的键控制不同的人/对象。
- en: For instance, when you’re controlling your player character running around the
    city, you use the movement keys to move the character around, and you use a different
    key to make your character jump. However, when you enter a car, the controls will
    change. The movement keys will now steer the car instead, and the same key that
    was used for jumping will now be used, for instance, for braking.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你控制你的玩家角色在城市中奔跑时，你使用移动键来移动角色，并使用不同的键来使角色跳跃。然而，当你进入一辆车时，控制方式将改变。移动键现在将控制汽车，而之前用于跳跃的同一个键现在将用于例如制动。
- en: In this example, you have two different Input Contexts (controlling the character
    and controlling the vehicle), each with its own set of Input Actions. Some of
    those Input Actions are triggered by the same key, but that’s fine, because they’re
    done in different Input Contexts (for example, using the same key to cause your
    character to jump and to stop the vehicle).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你有两个不同的输入上下文（控制角色和控制车辆），每个上下文都有自己的输入动作集合。其中一些输入动作由同一个键触发，但这没关系，因为它们在不同的输入上下文中执行（例如，使用同一个键使你的角色跳跃并停止车辆）。
- en: 'Before we start looking into some of the Enhanced Input-related assets, because
    it’s a plugin, we’ll have to enable it. To enable it, follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看一些增强输入相关的资产之前，因为这是一个插件，我们必须启用它。要启用它，请按照以下步骤操作：
- en: Go to **Edit** | **Plugins** | **Built-In** | **Input** and tick the **Enabled**
    box for the **Enhanced Input** plugin. After you have done so, you’ll be prompted
    to restart the editor.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑** | **插件** | **内置** | **输入**，并为**增强输入**插件勾选**启用**框。完成此操作后，你将提示重启编辑器。
- en: Click the **Restart Now** button when this happens. After the editor restarts,
    and now that the **Enhanced Input** plugin has been enabled, you’ll need to tell
    the engine to use its classes to handle the player’s input.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现这种情况时，点击**立即重启**按钮。在编辑器重启后，并且现在**增强输入**插件已被启用，你需要告诉引擎使用其类来处理玩家的输入。
- en: To do this, go to `EnhancedPlayerInput` and the `EnhancedInputComponent`. Now
    that the **Enhanced Input** plugin has been enabled and its classes are being
    used, we can proceed with this chapter’s content.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请转到`EnhancedPlayerInput`和`EnhancedInputComponent`。现在，**增强输入**插件已被启用，并且其类正在被使用，我们可以继续本章的内容。
- en: 'In order to know more about Input Contexts and Input Actions, let’s inspect
    them. Follow these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解输入上下文和输入动作，让我们来检查它们。请按照以下步骤操作：
- en: 'Right-click on the `IA_Movement`, and then open it. You should see the Input
    Action window, which has the following properties:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`IA_Movement`，然后打开它。你应该会看到输入动作窗口，它具有以下属性：
- en: '![Figure 4.1 – The Action window](img/Figure_4.01_B18531.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 动作窗口](img/Figure_4.01_B18531.jpg)'
- en: Figure 4.1 – The Action window
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 动作窗口
- en: 'Now, let’s take a look at its options in detail:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看它的选项：
- en: '`true`, another Input Action with a lower priority that will be triggered by
    the same key won’t be triggered.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`，另一个具有较低优先级的输入动作，如果它通过相同的键触发，则不会触发。'
- en: '**Trigger when Paused**: This specifies whether this Input Action can be triggered
    if the game is paused.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂停时触发**: 这指定了当游戏暂停时，这个输入动作是否可以被触发。'
- en: '**Reserve All Mappings**: This specifies whether a higher priority Input Action
    will be triggered if it’s triggered by the same key.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保留所有映射**: 这指定了如果通过相同的键触发，是否会有更高优先级的输入动作被触发。'
- en: '**Value Type**: This specifies the type of value for this Input Action. Its
    values can be the following:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值类型**: 这指定了此输入动作的值类型。其值可以是以下内容：'
- en: '**Digital (bool)**: Used for Input Actions that have a binary state – for instance,
    a jumping Input Action, in which the player is either pressing it or not, would
    use this value.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字 (bool)**: 用于具有二进制状态的输入动作——例如，跳跃输入动作，其中玩家要么按下它，要么不按下，就会使用这个值。'
- en: '**Axis 1D (float)**: Used for Input Actions that have a scalar state in one
    dimension – for instance, accelerating in a racing game, where you can use the
    gamepad’s triggers to control the throttle.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一维轴 (float)**: 用于具有一维标量状态的输入动作——例如，在赛车游戏中加速，你可以使用游戏手柄的触发器来控制油门。'
- en: '**Axis 2D (Vector2D)**: Used for Input Actions that have a scalar state in
    two dimensions – for instance, actions for moving your character, which are done
    using two axes (the forward axis and the sideways axis), would be good candidates
    for using this value.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二维轴 (Vector2D)**: 用于具有二维标量状态的输入动作——例如，用于移动角色的动作，这些动作是通过两个轴（前进轴和侧向轴）完成的，使用这个值会是一个不错的选择。'
- en: '**Axis 3D (Vector)**: Used for Input Actions that have a scalar state in three
    dimensions. This value isn’t as likely to be used as the others, but you may find
    a use for it.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维轴 (向量)**: 用于具有三维标量状态的输入动作。这个值不像其他值那样经常被使用，但你可能会找到它的用途。'
- en: '**Triggers**: This specifies the key events that will execute this Input Action.
    The values for this can be a combination of the following:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**: 这指定了将执行此输入动作的关键事件。这些值的组合可以是以下内容：'
- en: '**Chorded Action**: The Input Action is triggered as long as a different specified
    Input Action is also triggered.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**和弦动作**: 当指定的不同输入动作也被触发时，会触发输入动作。'
- en: '**Down**: The Input Action is triggered for every frame that the key exceeds
    the actuation threshold.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按下**: 当按键每帧超过激活阈值时，会触发输入动作。'
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The actuation threshold is the value at which a key’s input will be considered
    for executing an action. Binary keys (like the ones on a keyboard) have an input
    value of either `0` (not pressed) or `1` (pressed), while scalar keys, like the
    triggers on a gamepad, have an input value that goes continuously from `0` to
    `1` or, like the individual axes of the thumbsticks, that go continuously from
    `–1` to `1`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 激活阈值是按键输入被认为将执行动作的值。二进制键（如键盘上的键）的输入值为`0`（未按下）或`1`（按下），而标量键，如游戏手柄上的触发器，其输入值从`0`到`1`连续变化，或者像拇指摇杆的单独轴，其值从`-1`到`1`连续变化。
- en: '**Hold**: The Input Action is triggered when the key has exceeded the actuation
    threshold for a specified amount of time. You can optionally specify whether it’s
    triggered once or for every frame.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持**: 当按键超过指定时间的激活阈值时，会触发输入动作。你可以选择性地指定它是触发一次还是每帧触发一次。'
- en: '**Hold and Release**: The Input Action is triggered when the key has exceeded
    the actuation threshold for a specified amount of time and then stops exceeding
    that actuation threshold.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持和释放**: 当按键超过指定时间的激活阈值并停止超过该激活阈值时，会触发输入动作。'
- en: '**Pressed**: The Input Action is triggered once the key exceeds the actuation
    threshold and won’t be triggered again until it’s released.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按下**: 当按键超过激活阈值时，会触发输入动作，并且直到它被释放，不会再次触发。'
- en: '**Pulse**: The Input Action is triggered at a specified interval as long as
    the key exceeds the actuation threshold. You can specify whether the first pulse
    triggers the Input Action and whether there’s a limit to how many times it can
    be called.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脉冲**: 只要按键超过激活阈值，就会在指定的时间间隔内触发输入动作。你可以指定是否第一个脉冲会触发输入动作，以及是否有调用次数的限制。'
- en: '**Released**: The Input Action is triggered once the key stops exceeding the
    actuation threshold.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放**: 当按键停止超过激活阈值时，会触发输入动作。'
- en: '**Tap**: The Input Action is triggered when the key starts and then stops exceeding
    the Actuation Threshold, as long as it’s done within the specified amount of time.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻触**：当键开始并停止超过激活阈值时，只要在指定的时间内完成，就会触发输入动作。'
- en: '**Modifiers**: This specifies the ways in which this Input Action’s input will
    be modified:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符**：这指定了如何修改此输入动作的输入：'
- en: '`0` if it’s lower than the lower threshold and as `1` if it’s higher than the
    upper threshold.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它低于下限阈值，则为 `0`；如果它高于上限阈值，则为 `1`。
- en: '**FOV Scaling**: The key’s input will be scaled alongside the FOV (if the FOV
    increases, the key’s input will increase, and vice versa).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FOV 缩放**：键的输入将与 FOV（如果 FOV 增加，键的输入也将增加，反之亦然）一起缩放。'
- en: '**Modifier Collection**: The key’s input will be modified according to the
    specified list of modifiers.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符集合**：键的输入将根据指定的修饰符列表进行修改。'
- en: '**Negate**: The key’s input will be inverted.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取反**：键的输入将被反转。'
- en: '**Response Curve – Exponential**: An exponential curve will be applied on the
    key’s input.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应曲线 - 指数**：将对键的输入应用指数曲线。'
- en: '**Response Curve – User Defined**: A user-defined curve will be applied on
    the key’s input.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应曲线 - 用户定义**：将应用一个用户定义的曲线到键的输入。'
- en: '**Scalar**: The key’s input will be scaled at each axis according to the scalar
    specified.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量**：键的输入将根据指定的标量在每个轴上进行缩放。'
- en: '**Smooth**: The key’s input will be smoothed out across multiple frames.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平滑**：键的输入将在多个帧之间进行平滑处理。'
- en: '**Swizzle Input Axis Values**: The key’s axis order will be switched.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换输入轴值**：键的轴顺序将被交换。'
- en: '**To World Space**: The key’s axes will be converted toworld space.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为世界空间**：键的轴将被转换为世界空间。'
- en: After doing this, right-click on `IC_Character` and open it.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此操作后，右键单击 `IC_Character` 并打开它。
- en: You should see the Input Action window pop up. Note that it has an empty **MAPPINGS**
    property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到输入动作窗口弹出。注意，它有一个空的 **映射** 属性。
- en: '![Figure 4.2 – The MAPPINGS property ](img/Figure_4.02_B18531.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – MAPPINGS 属性](img/Figure_4.02_B18531.jpg)'
- en: Figure 4.2 – The MAPPINGS property
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – MAPPINGS 属性
- en: Let’s now add a new mapping. Press the **+** button next to the **Mappings**
    property. You’ll notice a new property show up where you can specify the Input
    Action this mapping will be associated with.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一个新的映射。按 **+** 按钮旁边的 **映射** 属性。你会注意到会出现一个新的属性，你可以在这里指定此映射将关联的输入动作。
- en: This action can be triggered by several different keys, each of which can have
    its own triggers and modifiers, which work the same as the corresponding properties
    in the Input Action asset.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作可以通过几个不同的键触发，每个键都可以有自己的触发器和修饰符，它们的工作方式与输入动作资产中的相应属性相同。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When it comes to modifying the **Triggers** and **Modifiers** properties, the
    usual practice is to change the modifiers in the Input Context asset and the triggers
    in the Input Action asset.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到修改 **触发器** 和 **修饰符** 属性时，通常的做法是在输入上下文资产中更改修饰符，在输入动作资产中更改触发器。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will not be using these properties in this book, but for each Input Mapping
    Context, you can specify whether it can be modified by a player by ticking the
    **Is Player Mappable** property and specifying **Player Mappable Options**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会在这本书中使用这些属性，但对于每个输入映射上下文，你可以指定它是否可以被玩家修改，通过勾选 **是否可映射** 属性并指定 **玩家可映射选项**。
- en: When we generated the `Third Person` template project back in [*Chapter 1*](B18531_01.xhtml#_idTextAnchor016),
    *Introduction to Unreal Engine*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [*第 1 章*](B18531_01.xhtml#_idTextAnchor016) 中生成 `Third Person` 模板项目时，*介绍
    Unreal Engine*
- en: ', it came with some inputs already configured, which were the *W*, *A*, *S*,
    and *D* keys, as well as the `left thumbstick` for movement, the *spacebar* key,
    and the `gamepad bottom face` button for jumping.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ，它已经配置了一些输入，包括 *W*、*A*、*S* 和 *D* 键，以及用于移动的 `左摇杆`，*空格键* 和用于跳跃的 `游戏手柄底部面按钮`。
- en: 'For context, let’s consider an Xbox One controller, which can be broken down
    into the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们考虑一个 Xbox One 控制器，它可以分解为以下内容：
- en: The **left analog stick**, usually used for controlling movement in games
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左模拟摇杆**，通常用于控制游戏中的移动'
- en: The **D-pad**, which can control movement and also has a variety of other uses
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十字键**，可以控制移动，也有多种其他用途'
- en: The **right analog stick**, usually used for controlling the camera and view
    perspective
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右模拟摇杆**，通常用于控制相机和视角'
- en: The **face buttons** (**X**, **Y**, **A**, and **B**), which can have various
    uses depending on the game but usually allow the player to perform actions in
    the game world
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面按键**（**X**、**Y**、**A**和**B**），根据游戏的不同可能有各种用途，但通常允许玩家在游戏世界中执行动作'
- en: The **bumpers and triggers** (**LB**, **RB**, **LT**, and **RT**), which can
    be used for actions such as aiming and shooting or accelerating and braking
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摇杆和触发器**（**LB**、**RB**、**LT**和**RT**），可用于瞄准和射击或加速和制动等动作'
- en: Now that we’ve learned how to set up `Input Actions`, let’s add some of them
    in the next exercise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何设置`输入动作`，让我们在下一个练习中添加一些：
- en: Exercise 4.01 – creating the movement and jump input actions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01 – 创建移动和跳跃输入动作
- en: In this exercise, we’ll be adding the mappings for the *Movement* and *Jump*
    Input Actions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将添加*移动*和*跳跃*输入动作的映射。
- en: 'To achieve this, follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请按照以下步骤操作：
- en: Open the **IA_Movement** Input Action.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IA_Movement**输入动作。
- en: 'Set its value type as **Axis2D**. We’ll make this an Input Action of type **Axis2D**
    because the character’s movement is done on two axes – the forward axis (the *Y*
    axis for this Input Action) and the sideways or right axis (the *X* axis for this
    Input Action):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其值类型设置为**Axis2D**。我们将将其设置为**Axis2D**类型的输入动作，因为角色的移动是在两个轴上进行的 – 前进轴（对于此输入动作的*Y*轴）和侧向或右侧轴（对于此输入动作的*X*轴）：
- en: '![Figure 4.3 – The Value Type options ](img/Figure_4.03_B18531.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 值类型选项](img/Figure_4.03_B18531.jpg)'
- en: Figure 4.3 – The Value Type options
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 值类型选项
- en: 'Add a new trigger of type **Down** with an actuation threshold of **0,1**.
    This will ensure that this Input Action is called when one of its keys has an
    actuation threshold of at least **0,1**:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为**Down**的新触发器，其激活阈值为**0,1**。这将确保当其任一键的激活阈值为至少**0,1**时调用此输入动作：
- en: '![Figure 4.4 – The Down trigger ](img/Figure_4.04_B18531.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – Down触发器](img/Figure_4.04_B18531.jpg)'
- en: Figure 4.4 – The Down trigger
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – Down触发器
- en: Open the **IC_Character** Input Context.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IC_Character**输入上下文。
- en: 'Click the **+** icon to the right of the **Mappings** property to create a
    new mapping:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Mappings**属性右侧的**+**图标以创建一个新的映射：
- en: '![Figure 4.5 – Adding a new action mapping ](img/Figure_4.05_B18531.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 添加新的动作映射](img/Figure_4.05_B18531.jpg)'
- en: Figure 4.5 – Adding a new action mapping
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 添加新的动作映射
- en: 'When you’ve done so, you should see a new empty mapping with its properties
    either empty or set to **None**:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你这样做之后，你应该会看到一个新空映射，其属性为空或设置为**None**：
- en: '![Figure 4.6 – The default settings of a new action mapping ](img/Figure_4.06_B18531.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 新动作映射的默认设置](img/Figure_4.06_B18531.jpg)'
- en: Figure 4.6 – The default settings of a new action mapping
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 新动作映射的默认设置
- en: 'Set the Input Action of this mapping (the first property that’s set to **None**)
    to **IA_Movement**:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此映射的输入动作（设置为**None**的第一个属性）设置为**IA_Movement**：
- en: '![Figure 4.7 – The new IA_Movement mapping ](img/Figure_4.07_B18531.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 新的IA_Movement映射](img/Figure_4.07_B18531.jpg)'
- en: Figure 4.7 – The new IA_Movement mapping
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 新的IA_Movement映射
- en: Set the first key in this mapping to **Gamepad Left Thumbstick Y-Axis**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此映射的第一个键设置为**游戏手柄左摇杆Y轴**。
- en: '![Figure 4.8 – The Gamepad Left Thumbstick Y-Axis key ](img/Figure_4.08_B18531.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 游戏手柄左摇杆Y轴键](img/Figure_4.08_B18531.jpg)'
- en: Figure 4.8 – The Gamepad Left Thumbstick Y-Axis key
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 游戏手柄左摇杆Y轴键
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the key you want to set is from one of the input devices you have connected
    (for example, mouse, keyboard, or gamepad), you can click the button to the left
    of the key dropdown and then press the actual key you want to set, instead of
    searching for it in the list. For instance, if you want to set a mapping to use
    the *F* key on the keyboard, you can click that button, then press the *F* key,
    and then that key will be set for that mapping.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要设置的键来自您已连接的输入设备之一（例如，鼠标、键盘或游戏手柄），您可以单击键下拉列表左侧的按钮，然后按下您要设置的键，而不是在列表中搜索它。例如，如果您想将映射设置为使用键盘上的*F*键，您可以单击该按钮，然后按下*F*键，然后该键将为该映射设置。
- en: Because we want this key to control the Input Action’s *Y* axis instead of its
    *X* axis, we need to add the **Swizzle Input Axis Values** modifier with the **YXZ**
    value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想用这个键控制输入动作的*Y*轴而不是其*X*轴，所以我们需要添加具有**YXZ**值的**Swizzle输入轴值**修改器。
- en: '![Figure 4.9 – The Swizzle Input Axis modifier ](img/Figure_4.09_B18531.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – Swizzle输入轴修改器](img/Figure_4.09_B18531.jpg)'
- en: Figure 4.9 – The Swizzle Input Axis modifier
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – Swizzle输入轴修改器
- en: 'Click the **+** button to the right of the Input Action set for this mapping
    in order to add a new key and execute that Input Action:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此映射设置的输入动作右侧的 **+** 按钮，以添加新键并执行该输入动作：
- en: '![Figure 4.10 – The + button to the right of IA_Movement ](img/Figure_4.10_B18531.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – IA_Movement右侧的+按钮](img/Figure_4.10_B18531.jpg)'
- en: Figure 4.10 – The + button to the right of IA_Movement
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – IA_Movement右侧的+按钮
- en: Set the new key to **Gamepad Left Thumbstick X-Axis**. Because this will already
    control the movement Input Action’s *X* axis, we won’t need to add any modifiers.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新键设置为 **游戏手柄左摇杆X轴**。因为这将已经控制移动输入动作的 *X* 轴，所以我们不需要添加任何修饰符。
- en: Add another key to the Input Action, this time the *W* key. Because this key
    will be used for moving forward, and therefore use the *Y* axis, it will need
    the same modifier that we added before – the **Swizzle Input Axis** modifier with
    the **YXZ** value.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向输入动作中添加另一个键，这次是 *W* 键。因为这个键将用于向前移动，因此使用 *Y* 轴，它需要我们之前添加的相同修饰符 - 带有 **YXZ**
    值的 **Swizzle输入轴** 修饰符。
- en: 'Add another key to the Input Action, this time the *S* key. Because this key
    will be used for moving backward, and therefore use the *Y* axis, it will need
    the same modifier we added before – the `–1` on the *Y* axis when this key is
    pressed (that is, when its input is `1`):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向输入动作中添加另一个键，这次是 *S* 键。因为这个键将用于向后移动，因此使用 *Y* 轴，它需要我们之前添加的相同修饰符 - 当按下此键时（即，当其输入为
    `1`）在 *Y* 轴上的 `-1`：
- en: '![Figure 4.11 – The Swizzle Input Axis Values and Negate modifiers ](img/Figure_4.11_B18531.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – Swizzle输入轴值和取反修饰符](img/Figure_4.11_B18531.jpg)'
- en: Figure 4.11 – The Swizzle Input Axis Values and Negate modifiers
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 - Swizzle输入轴值和取反修饰符
- en: Add another key to the Input Action, this time the *D* key. Because this key
    will be used for moving right, and therefore use the positive end of the *X* axis,
    it won’t need any modifiers.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向输入动作中添加另一个键，这次是 *D* 键。因为这个键将用于向右移动，因此使用 *X* 轴的正端，它不需要任何修饰符。
- en: Add another key to the Input Action, this time the *A* key. Because this key
    will be used for moving left, and therefore use the negative end of the *X* axis,
    it will need the `Negate` modifier, just like the *S* key.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向输入动作中添加另一个键，这次是 *A* 键。因为这个键将用于向左移动，因此使用 *X* 轴的负端，它需要与 *S* 键相同的 `Negate` 修饰符。
- en: Create a new Input Action asset called `IA_Jump`, and then open it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的输入动作资产，命名为 `IA_Jump`，然后打开它。
- en: 'Add a **Down** trigger and leave its actuation threshold as **0,5**:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **向下** 触发器，并保持其激活阈值为 **0,5**：
- en: '![Figure 4.12 – The Down trigger ](img/Figure_4.12_B18531.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 向下触发](img/Figure_4.12_B18531.jpg)'
- en: Figure 4.12 – The Down trigger
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 向下触发
- en: 'Go back to the **IC_Character** Input Context asset and add a new Input Action
    to the **Mapping**s property – this time, the **IA_Jump** Input Action we just
    created:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **IC_Character** 输入上下文资产，并将一个新的输入动作添加到 **映射** 属性中 - 这次是刚刚创建的 **IA_Jump**
    输入动作：
- en: '![Figure 4.13 – The IA_Jump mapping ](img/Figure_4.13_B18531.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – IA_Jump映射](img/Figure_4.13_B18531.jpg)'
- en: Figure 4.13 – The IA_Jump mapping
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – IA_Jump映射
- en: 'Add two keys to this mapping – **Space Bar** and **Gamepad Face Button Bottom**.
    If you’re using an Xbox controller, this will be the *A* button, and if you’re
    using a PlayStation controller, this will be the *X* button:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此映射中添加两个键 - **空格键** 和 **游戏手柄面按键底部**。如果你使用的是Xbox控制器，这将对应于 *A* 按钮，如果你使用的是PlayStation控制器，这将对应于
    *X* 按钮：
- en: '![Figure 4.14 – The IA_Jump mapping keys ](img/Figure_4.14_B18531.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – IA_Jump映射键](img/Figure_4.14_B18531.jpg)'
- en: Figure 4.14 – The IA_Jump mapping keys
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – IA_Jump映射键
- en: And with those steps completed, we’ve completed this chapter’s first exercise,
    where you’ve learned how you can specify Input Action Mappings in UE5, allowing
    you to abstract which keys are responsible for which in-game actions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们就完成了本章的第一个练习，你学习了如何在UE5中指定输入动作映射，这允许你抽象出哪些键负责哪些游戏动作。
- en: Let’s now take a look at how UE5 handles player input and processes it within
    the game.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看UE5如何处理玩家输入并在游戏中对其进行处理。
- en: Processing Player Input
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理玩家输入
- en: Let’s think about a situation where the player presses the **Jump** Input Action,
    which is associated with the *spacebar* key, to get the player character to jump.
    Between the moment the player presses the *Spacebar* key and the moment the game
    makes the player character jump, quite a few things have to happen to connect
    those two events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一种情况，玩家按下**跳跃**输入动作，该动作与*空格键*相关联，以使玩家角色跳跃。在玩家按下*空格键*的那一刻和游戏使玩家角色跳跃的那一刻之间，需要发生很多事情来连接这两个事件。
- en: 'Let’s take a look at all of the necessary steps that lead from one event to
    the other:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从一件事到另一件事的所有必要步骤：
- en: '`Hardware Input`: The player presses the *spacebar* key. UE5 will be listening
    to this keypress event.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`硬件输入`：玩家按下*空格键*。UE5将监听这个按键事件。'
- en: 'The `PlayerInput` class: After the key is pressed or released, this class will
    translate that key into an Input Action. If there is a corresponding Input Action,
    it will notify all classes that are listening to the action that it was just pressed,
    released, or updated. In this case, it will know that the *Spacebar* key is associated
    with the *Jump* Input Action.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayerInput`类：在按键按下或释放后，这个类将把那个键转换成输入动作。如果有相应的输入动作，它将通知所有监听该动作的类，它刚刚被按下、释放或更新。在这种情况下，它将知道*空格键*与*跳跃*输入动作相关联。'
- en: 'The `Player Controller` class: This is the first class to receive these keypress
    events, given that it’s used to represent a player in the game.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Player Controller`类：这是第一个接收这些按键事件类，因为它用于在游戏中表示玩家。'
- en: 'The `Pawn` class: This class (and consequently the `Character` class, which
    inherits from it) can also listen to those keypress events, as long as they are
    possessed by a Player Controller. If so, it will receive these events after that
    class. In this chapter, we will be using our `Character` C++ class to listen to
    action and axis events.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pawn`类：这个类（以及从它继承的`Character`类）也可以监听这些按键事件，只要它们被玩家控制器拥有。如果是这样，它将在那个类之后接收这些事件。在本章中，我们将使用我们的`Character`
    C++类来监听动作和轴事件。'
- en: Now that we know how UE5 handles player inputs, let’s see how we can listen
    to Input Actions in C++ in the next exercise.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了UE5如何处理玩家输入，让我们看看我们如何在下一节中用C++监听输入动作。
- en: Exercise 4.02 – listening to movement and jump input actions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02 – 监听移动和跳跃输入动作
- en: In this exercise, we will register the Input Actions we created in the previous
    section with our character class by binding them to specific functions in our
    character class using C++.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过将它们绑定到角色类中的特定函数来使用C++将我们在上一节中创建的输入动作注册到我们的角色类中。
- en: 'The main way for a `SetupPlayerInputComponent` function. The `MyThirdPersonChar`
    class should already have a declaration and an implementation for this function.
    Let’s have our character class listen to those events by following these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupPlayerInputComponent`函数的主要方式。`MyThirdPersonChar`类应该已经有了这个函数的声明和实现。让我们让我们的角色类通过以下步骤来监听这些事件：'
- en: 'Open the `MyThirdPersonChar` class header file in Visual Studio, and make sure
    there’s a declaration for a `protected` function called `SetupPlayerInputComponent`
    that returns nothing and receives a `class UInputComponent* PlayerInputComponent`
    property as a parameter. This function should be marked as both `virtual` and
    `override`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`MyThirdPersonChar`类头文件，确保有一个名为`SetupPlayerInputComponent`的`protected`函数的声明，该函数不返回任何内容，并接收一个`class
    UInputComponent* PlayerInputComponent`属性作为参数。这个函数应该被标记为`virtual`和`override`：
- en: '[PRE0]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a declaration for a `public` `class UInputMappingContext*` property called
    `IC_Character`. This property must be a `UPROPERTY` and have the `EditAnywhere`
    and `Category = Input` tags. This will be the Input Context we’ll be adding for
    the character’s input:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个名为`IC_Character`的`public` `class UInputMappingContext*`属性添加一个声明。这个属性必须是一个`UPROPERTY`，并具有`EditAnywhere`和`Category
    = Input`标签。这将是我们为角色输入添加的输入上下文：
- en: '[PRE1]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, we’ll need to add the Input Actions to listen for the character’s
    input. Add three `public` `class UInputAction*` properties, all of which must
    be `UPROPERTY` and have the `EditAnywhere` and `Category = Input` tags. Those
    two properties will be called the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要添加输入动作来监听角色的输入。添加三个`public` `class UInputAction*`属性，所有这些都必须是`UPROPERTY`，并具有`EditAnywhere`和`Category
    = Input`标签。这两个属性将被命名为以下：
- en: '`IA_Move`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IA_Move`'
- en: '[PRE2]'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open this class’s `source` file and make sure that this function has an implementation:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个类的`source`文件，确保这个函数有实现：
- en: '[PRE3]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because in UE5 you can use either the legacy Input Component or the Enhanced
    Input Component, we need to account for this. Inside the previous function’s implementation,
    start by casting the `PlayerInputComponent` parameter to the `UEnhancedInputComponent`
    class and saving it inside a new `EnhancedPlayerInputComponent` property of type
    `UEnhancedInputComponent*`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为在 UE5 中，你可以使用遗留的输入组件或增强型输入组件，我们需要考虑这一点。在前面函数的实现中，首先将 `PlayerInputComponent`
    参数转换为 `UEnhancedInputComponent` 类，并将其保存到一个新的 `EnhancedPlayerInputComponent` 属性中，该属性的类型为
    `UEnhancedInputComponent*`：
- en: '[PRE4]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we’ll be using `UEnhancedInputComponent`, we need to include it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用 `UEnhancedInputComponent`，所以我们需要包含它：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If it’s not `nullptr`, cast the `Controller` property to `APlayerController`
    and save it in a local `PlayerController` property:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不是 `nullptr`，将 `Controller` 属性转换为 `APlayerController` 并将其保存在一个局部 `PlayerController`
    属性中：
- en: '[PRE6]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the newly created `PlayerController` property isn’t `nullptr`, then we’ll
    need to fetch `UEnhancedLocalPlayerSubsystem` so that we can tell it to add the
    `IC_Character` Input Context and activate its Input Actions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新创建的 `PlayerController` 属性不是 `nullptr`，那么我们需要获取 `UEnhancedLocalPlayerSubsystem`，以便我们可以告诉它添加
    `IC_Character` 输入上下文并激活其输入操作。
- en: 'To do this, create a new `UEnhancedLocalPlayerSubsystem*` property called `EnhancedSubsystem`
    and set it to return the value of the `ULocalPlayer::GetSubsystem` function. This
    function receives a template parameter representing the subsystem we want to fetch,
    which is `UEnhancedLocalPlayerSubsystem`, and a normal parameter of type `ULocalPlayer*`.
    This last parameter’s type is a representation of a player who’s controlling a
    pawn in the current instance of the game, and we’ll pass it by calling `PlayerController->GetLocalPlayer()`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，创建一个新的 `UEnhancedLocalPlayerSubsystem*` 属性，命名为 `EnhancedSubsystem`，并将其设置为返回
    `ULocalPlayer::GetSubsystem` 函数的值。此函数接收一个模板参数，表示我们想要获取的子系统，即 `UEnhancedLocalPlayerSubsystem`，以及一个类型为
    `ULocalPlayer*` 的普通参数。此最后一个参数的类型是表示在当前游戏实例中控制 pawn 的玩家的表示，我们将通过调用 `PlayerController->GetLocalPlayer()`
    来传递它：
- en: '[PRE7]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because we’ll be using the `UEnhancedLocalPlayerSubsystem`, we need to include
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用 `UEnhancedLocalPlayerSubsystem`，所以我们需要包含它：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the `EnhancedSubsystem` property isn’t `nullptr`, call its `AddMappingContext`
    function, which receives the following parameters:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `EnhancedSubsystem` 属性不是 `nullptr`，则调用其 `AddMappingContext` 函数，该函数接收以下参数：
- en: '`UInputMappingContext* Mapping Context`: The Input Context we want to activate
    – in this case, the `IC_Character` property'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UInputMappingContext* Mapping Context`：我们想要激活的输入上下文——在这种情况下，是 `IC_Character`
    属性'
- en: '`int32 Priority`: The priority we want this Input Context to have, which we’ll
    pass as `1`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32 Priority`：我们想要此输入上下文具有的优先级，我们将将其传递为 `1`'
- en: '[PRE9]'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because we’ll be using `UInputMappingContext`, we need to include it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用 `UInputMappingContext`，所以我们需要包含它：
- en: '[PRE10]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we’ve added the logic to activate the Input Context, let’s add the
    logic for listening to the Input Actions. Add the code for the following steps
    after we check whether `PlayerController` is `nullptr`, but still inside the brackets
    where we check whether `EnhancedPlayerInputComponent` is `nullptr`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了激活输入上下文的逻辑，让我们添加监听输入操作的逻辑。在检查 `PlayerController` 是否为 `nullptr` 之后，但在检查
    `EnhancedPlayerInputComponent` 是否为 `nullptr` 的括号内，添加以下步骤的代码：
- en: '[PRE11]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to listen to the `IA_Movement` Input Action, we’ll call the `EnhancedPlayer
    InputComponent` `BindAction` function, which receives as parameters the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听 `IA_Movement` 输入操作，我们将调用 `EnhancedPlayer InputComponent` 的 `BindAction`
    函数，该函数接收以下参数：
- en: '`UInputAction* Action`: The Input Action to listen to, which we’ll pass as
    the `IA_Movement` property.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UInputAction* Action`：要监听的输入操作，我们将将其传递为 `IA_Movement` 属性。'
- en: '`ETriggerEvent TriggerEvent`: The input event that will cause the function
    to be called. Because this Input Action is triggered for every frame in which
    it’s being used, and it’s triggered using the `Down` trigger, we’ll pass this
    as the `Triggered` event.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETriggerEvent TriggerEvent`：将导致函数被调用的输入事件。因为此输入操作在它被使用的每一帧都会被触发，并且使用 `Down`
    触发器触发，所以我们将将其作为 `Triggered` 事件传递。'
- en: '`UserClass* Object`: The object that the `callback` function will be called
    on – in our case, that’s the `this` pointer.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserClass* Object`：`callback` 函数将被调用的对象——在我们的案例中，是 `this` 指针。'
- en: '`HANDLER_SIG::TUObjectMethodDelegate <UserClass> ::FMethodPtr Func`: This property
    is a bit wordy, but it’s essentially a pointer to the function that will be called
    when this event happens, which we can specify by typing `&`, followed by the class’s
    name, then `::`, and finally, the function’s name. In our case, we want this to
    be the `Move` function, which we’ll be creating in a following step, so we’ll
    specify it with `& AMyThirdPersonChar::Move`:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HANDLER_SIG::TUObjectMethodDelegate <UserClass> ::FMethodPtr Func`：这个属性有点冗长，但本质上是一个指向当此事件发生时将被调用的函数的指针，我们可以通过输入
    `&`，然后是类的名称，接着是 `::`，最后是函数的名称来指定它。在我们的例子中，我们希望这是 `Move` 函数，我们将在下一步创建它，所以我们将指定为
    `& AMyThirdPersonChar::Move`：'
- en: '[PRE12]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because we’ll be using `UInputAction`, we need to include it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用 `UInputAction`，我们需要包含它：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s now bind the function that will make the player character start jumping.
    In order to do this, duplicate the `BindAction` function call we added for the
    `IA_Move` Input Action, but make the following changes:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们绑定将使玩家角色开始跳跃的功能。为了做到这一点，复制我们为 `IA_Move` 输入动作添加的 `BindAction` 函数调用，但进行以下更改：
- en: Instead of passing the `IA_Move` Input Action, pass the `IA_Jump` Input Action.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将传递 `IA_Jump` 输入动作而不是 `IA_Move` 输入动作。
- en: Instead of passing the `&AMyThirdPersonChar::Move` function, pass `&ACharacter::Jump`.
    This is the function that will make the character jump.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将传递 `&AMyThirdPersonChar::Move` 函数而不是 `&ACharacter::Jump`。这是将使角色跳跃的函数。
- en: 'Instead of passing `ETriggerEvent::Trigger`, pass `ETriggerEvent::Started`.
    This is so that we can be notified when the key starts and stops being pressed:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将传递 `ETriggerEvent::Started` 而不是 `ETriggerEvent::Trigger`。这样我们就可以在键开始和停止被按下时得到通知：
- en: '[PRE14]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to bind the function that will make the player character stop jumping,
    let’s now duplicate the last `BindAction` function call that we did, but make
    the following changes to it:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绑定将使玩家角色停止跳跃的函数，现在让我们复制我们刚刚做的最后一个 `BindAction` 函数调用，但对其做出以下更改：
- en: Instead of passing the `ETriggerEvent::Started`, we’ll pass `ETriggerEvent::Completed`,
    so that the function gets called when this Input Action stops being triggered.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将传递 `ETriggerEvent::Completed` 而不是 `ETriggerEvent::Started`，这样当此输入动作停止触发时，函数就会被调用。
- en: 'Instead of passing the `&ACharacter::Jump` function, pass `&ACharacter::StopJumping`.
    This is the function that will make the character stop jumping:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将传递 `&ACharacter::Jump` 函数而不是 `&ACharacter::StopJumping`。这是将使角色停止跳跃的函数：
- en: '[PRE15]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All functions used to listen to Input Actions must receive either no parameters
    or a parameter of type `FInputActionValue&`. You can use this to check its value
    type and fetch the right one. For instance, if the Input Action that triggers
    this function has a `Digital` value type, its value will be of type `bool`, but
    if it has an `Axis2D` value type, its value will be of type `FVector2D`. The latter
    is the type we’ll be using for the `Move` function because that’s its corresponding
    value type.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于监听输入动作的功能必须接收无参数或类型为 `FInputActionValue&` 的参数。你可以使用它来检查其值类型并获取正确的类型。例如，如果触发此功能的输入动作具有
    `Digital` 值类型，其值将为 `bool` 类型，但如果它具有 `Axis2D` 值类型，其值将为 `FVector2D` 类型。后者是我们将在 `Move`
    函数中使用的类型，因为那是其对应值类型。
- en: Another option for listening to Input Actions is to use `Delegates`, which is
    outside the scope of this book.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 监听输入动作的另一种选择是使用 `Delegates`，这超出了本书的范围。
- en: 'Let’s now create the `Move` function that we referenced in a previous step.
    Go to the class’s header file and add a declaration for a `protected` function
    called `Move`, which returns nothing and receives a `const FInputActionValue&
    Value` parameter:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们在之前步骤中引用的 `Move` 函数。转到类的头文件，并添加一个名为 `Move` 的 `protected` 函数的声明，它不返回任何内容，并接收一个
    `const FInputActionValue& Value` 参数：
- en: '[PRE16]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because we’re using `FInputActionValue`, we have to include it:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们使用 `FInputActionValue`，我们必须包含它：
- en: '[PRE17]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the class’s source file, add this function’s implementation, where we’ll
    start by fetching the `Value` parameter’s input as `FVector2D`. We’ll do this
    by calling its `Get` function, passing as a template parameter the `FVector2D`
    type. We’ll also save its return value in a local variable called `InputValue`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中添加此函数的实现，我们将首先通过调用其 `Get` 函数来获取 `Value` 参数的输入作为 `FVector2D`。我们将通过传递 `FVector2D`
    类型作为模板参数来完成此操作。我们还将将其返回值保存在一个名为 `InputValue` 的局部变量中：
- en: '[PRE18]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, check whether the `Controller` property is valid (not `nullptr`) and
    whether the `InputValue` property’s `X` or `Y` value is different to `0`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查`Controller`属性是否有效（不是`nullptr`）以及`InputValue`属性的`X`或`Y`值是否不同于`0`：
- en: '[PRE19]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If all of these conditions are `true`, we’ll then get the camera’s rotation
    on the *z* axis (yaw), so that we can move the character relative to where the
    camera is facing. To achieve this, we can create a new `FRotator` property called
    `YawRotation` with a value of `0` for pitch (rotation along the *y* axis) and
    roll (rotation along the *x* axis) and the value of the camera’s current yaw for
    the property’s yaw. To get the camera’s yaw value, we can call the Player Controller’s
    `GetControlRotation` function and then access its `Yaw` property:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些条件都为`true`，我们接下来将获取相机在*z*轴上的旋转（偏航），以便我们可以相对于相机面向的方向移动角色。为了实现这一点，我们可以创建一个新的`FRotator`属性，命名为`YawRotation`，其俯仰（沿*y*轴旋转）和翻滚（沿*x*轴旋转）的值为`0`，而其偏航的值则为相机当前的偏航值。为了获取相机的偏航值，我们可以调用玩家控制器的`GetControlRotation`函数，然后访问其`Yaw`属性：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `FRotator` property’s constructor receives the `Pitch` value, the `Yaw`
    value, and then the `Roll` value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`FRotator`属性的构造函数接收`Pitch`值，然后是`Yaw`值，最后是`Roll`值。'
- en: 'After that, we’ll check whether the `InputValue`’s `X` property is different
    to `0`:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将检查`InputValue`的`X`属性是否不同于`0`：
- en: '[PRE21]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If it is, get the right vector of `YawRotation` and store it in an `Fvector
    RightDirection` property. You can get a rotator’s right vector by calling the
    `KistemMathLibrary` object’s `GetRightVector` function. A rotator or vector’s
    right vector is simply its perpendicular vector that points to its right. The
    result of this will be a vector that points to the right of where the camera is
    currently facing:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，获取`YawRotation`的右向量并将其存储在`Fvector RightDirection`属性中。你可以通过调用`KismetMathLibrary`对象的`GetRightVector`函数来获取旋转器的右向量。旋转器或向量的右向量是其垂直于自身并指向右侧的向量。这将得到一个指向相机当前面向方向右侧的向量：
- en: '[PRE22]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now call the `AddMovementInput` function, which will make our character
    move in the direction we specify, passing as parameters the `RightDirection` and
    `InputValue` `X` properties:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以调用`AddMovementInput`函数，这将使我们的角色向指定的方向移动，传递参数为`RightDirection`和`InputValue`的`X`属性：
- en: '[PRE23]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because we’ll be using both the `KismetMathLibrary` and `Controller` objects,
    we’ll need to include them at the top of this source file:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们将同时使用`KismetMathLibrary`和`Controller`对象，所以我们需要在源文件顶部包含它们：
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After checking whether the `X` property of `InputValue` is different to `0`,
    check whether its `Y` property is different to `0`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查`InputValue`的`X`属性是否不同于`0`之后，检查其`Y`属性是否不同于`0`：
- en: '[PRE25]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If it is, call the `YawRotation` property’s `Vector` function and store its
    return value in an `FVector ForwardDirection` property. This function will convert
    `FRotator` to `FVector`, which is equivalent to getting a rotator’s `ForwardVector`.
    The result of this will be a vector that points forward of where the camera is
    currently facing:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，调用`YawRotation`属性的`Vector`函数，并将返回值存储在`FVector ForwardDirection`属性中。此函数将`FRotator`转换为`FVector`，相当于获取旋转器的`ForwardVector`。这将得到一个指向相机当前面向方向前方的向量：
- en: '[PRE26]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now call the `AddMovementInput` function, passing as parameters the
    `ForwardDirection` and `InputValue` `Y` properties:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用`AddMovementInput`函数，传递参数为`ForwardDirection`和`InputValue`的`Y`属性：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we compile our code, add the `EnhancedInput` plugin to our project’s
    `Build.cs` file in order to notify UE5 that we’ll be using this plugin in our
    project. If we don’t do this, parts of our project won’t compile.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编译代码之前，将`EnhancedInput`插件添加到项目`Build.cs`文件中，以便通知UE5我们将在项目中使用此插件。如果我们不这样做，项目的一些部分将无法编译。
- en: Open the `.Build.cs` file inside your project’s `Source/<ProjectName>` folder,
    which is a C# file and not a C++ file, located inside your project’s source folder.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目源文件夹`Source/<ProjectName>`中的`.Build.cs`文件，这是一个C#文件而不是C++文件，位于项目源文件夹内。
- en: 'Open the file, and you’ll find the `AddRange` function from the `PublicDependencyModuleNames`
    property being called. This is the function that tells the engine which modules
    this project intends to use. As a parameter, an array of strings is sent with
    the names of all the intended modules for the project. Given that we intend on
    using UMG, we’ll need to add the `EnhancedInput` module after the `InputCore`
    module:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件，你会找到 `PublicDependencyModuleNames` 属性调用的 `AddRange` 函数。这个函数告诉引擎该项目打算使用哪些模块。作为参数，发送了一个包含所有预期模块名称的字符串数组。鉴于我们打算使用
    UMG，我们需要在 `InputCore` 模块之后添加 `EnhancedInput` 模块：
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that you’ve notified the engine that we’ll be using the `EnhancedInput`
    module, compile your code, open the editor, and open your `BP_MyTPS` blueprint
    asset. Delete the `InputAction Jump` event, as well as the nodes connected to
    it. Do the same for the **InputAxis MoveForward** and **InputAxis MoveRight**
    events. We will be replicating this logic in C++ and need to remove its Blueprint
    functionality so that there are no conflicts when handling input.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经通知引擎我们将使用 `EnhancedInput` 模块，编译你的代码，打开编辑器，并打开你的 `BP_MyTPS` 蓝图资产。删除 `InputAction
    跳跃` 事件以及连接到它的节点。对 **InputAxis 移动向前** 和 **InputAxis 移动向右** 事件也做同样操作。我们将在 C++ 中复制这个逻辑，并需要移除其蓝图功能，以避免处理输入时出现冲突。
- en: 'Next, set the **IC Character** property to the **IC_Character** Input Context,
    the **IA Move** property to the **IA_Movement** Input Action, and the **IA Jump**
    property to the **IA_Jump** Input Action:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 **IC 角色** 属性设置为 **IC_Character** 输入上下文，将 **IA 移动** 属性设置为 **IA_Movement**
    输入动作，将 **IA 跳跃** 属性设置为 **IA_Jump** 输入动作：
- en: '![Figure 4.15 – The IC Character, IA Move, and IA Jump properties ](img/Figure_4.15_B18531.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – IC 角色、IA 移动和 IA 跳跃属性](img/Figure_4.15_B18531.jpg)'
- en: Figure 4.15 – The IC Character, IA Move, and IA Jump properties
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – IC 角色、IA 移动和 IA 跳跃属性
- en: 'Now, play the level. You should be able to move the character using the keyboard’s
    *W*, *A*, *S*, and *D* keys or the controller’s *left thumbstick*, as well as
    jumping with the *Spacebar* key or *gamepad face button bottom*:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始游戏关卡。你应该能够使用键盘的 *W*、*A*、*S* 和 *D* 键或控制器的 *左摇杆* 来移动角色，以及使用 *空格键* 或 *游戏手柄正面按钮下*
    来跳跃：
- en: '![Figure 4.16 – The player character moving  ](img/Figure_4.16_B18531.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 玩家角色移动](img/Figure_4.16_B18531.jpg)'
- en: Figure 4.16 – The player character moving
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 玩家角色移动
- en: After following all these steps, you will have concluded this exercise. You
    now know how to create and listen to your own **Input Action** events using C++
    in UE5\. Doing this is one of the most important aspects of game development,
    so you’ve just completed an important step in your game development journey.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些步骤后，你将完成这个练习。你现在知道如何使用 C++ 在 UE5 中创建和监听自己的 **输入动作** 事件。做这件事是游戏开发最重要的方面之一，所以你刚刚完成了游戏开发旅程中的一个重要步骤。
- en: Now that we’ve set up all of the logic necessary to have our character move
    and jump, let’s add the logic responsible for rotating the camera around our character.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有必要的逻辑，使我们的角色能够移动和跳跃，让我们添加负责围绕角色旋转摄像机的逻辑。
- en: Turning the camera around the character
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕角色旋转摄像机
- en: Cameras are an extremely important part of games, as they dictate what and how
    the player will see in your game throughout the play session. When it comes to
    third-person games, which is what this project is about, the camera allows a player
    not only to see the world around them but also the character they’re controlling.
    Whether the character is taking damage, falling, or something else, it’s important
    for the player to always know the state of the character they are controlling
    and to be able to have the camera face the direction they choose.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机是游戏中的一个极其重要的部分，因为它决定了玩家在整个游戏过程中将看到什么以及如何看到。当涉及到第三人称游戏，这正是本项目所涉及的内容时，摄像机不仅允许玩家看到他们周围的世界，还能看到他们所控制的角色。无论角色是否受到伤害、坠落或其他情况，玩家始终需要知道他们所控制角色的状态，并且能够使摄像机面向他们选择的任何方向。
- en: 'Like every modern third-person game, we will always have the camera rotate
    around our player character. To have our camera rotate around our character, after
    setting up the **Camera** and **Spring Arm** components in [*Chapter 2*](B18531_02.xhtml#_idTextAnchor043),
    *Working with Unreal Engine*, let’s continue by adding a new **Look** Input Action.
    Follow these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 像每款现代第三人称游戏一样，我们总是会让摄像机围绕我们的玩家角色旋转。为了使我们的摄像机围绕我们的角色旋转，在 [*第 2 章*](B18531_02.xhtml#_idTextAnchor043)
    *使用 Unreal Engine* 中设置 **Camera** 和 **Spring Arm** 组件之后，让我们继续添加一个新的 **Look** 输入动作。按照以下步骤操作：
- en: Do this by duplicating the `IA_Look`. Because this new Input Action’s setup
    is similar to that of the **IA_Move** Input Action, we’ll leave this duplicated
    asset as is.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制 `IA_Look` 来完成此操作。因为这个新输入动作的设置与 **IA_Move** 输入动作类似，所以我们将保留这个复制的资产不变。
- en: Then, open the **IA_Character** Input Context and add a new mapping for the
    **IA_Look** Input Action.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 **IA_Character** 输入上下文，并为 **IA_Look** 输入动作添加一个新的映射。
- en: 'Add the following keys to this new mapping – **Mouse X**, **Mouse Y**, **Gamepad
    Right Thumbstick X-Axis**, and **Gamepad Right Thumbstick Y-Axis**. Because the
    *Y* keys will be controlling the Input Action’s *Y* axis, we’ll have to add the
    **Swizzle Input Axis Values** modifier to them (the **Mouse Y** and **Gamepad
    Right Thumbstick Y-Axis** keys). Additionally, because the **Mouse Y** key will
    make the camera go down when you mose the mouse up, we’ll have to also add a **Negate**
    modifier to it:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下键添加到这个新映射中 – **鼠标 X**、**鼠标 Y**、**游戏手柄右摇杆 X 轴**和**游戏手柄右摇杆 Y 轴**。因为 *Y* 键将控制输入动作的
    *Y* 轴，所以我们必须为它们添加 **Swizzle Input Axis Values** 修改器（**鼠标 Y** 和 **游戏手柄右摇杆 Y 轴**
    键）。另外，因为 **鼠标 Y** 键会在你向上移动鼠标时使摄像机向下移动，所以我们也必须为它添加一个 **Negate** 修改器：
- en: '![Figure 4.17 – The mappings for the IA_Look Input Action](img/Figure_4.17_B18531.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – IA_Look 输入动作的映射](img/Figure_4.17_B18531.jpg)'
- en: Figure 4.17 – The mappings for the IA_Look Input Action
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – IA_Look 输入动作的映射
- en: 'Let’s now add the C++ logic responsible for turning the camera with the player’s
    input:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加负责根据玩家输入旋转摄像机的 C++ 逻辑：
- en: 'Go to the `MyThirdPersonChar` class’s header file and add a `public` `class
    UInputAction* IA_Look` property, which must be `UPROPERTY` and have the `EditAnywhere`
    and `Category = Input` tags:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `MyThirdPersonChar` 类的头文件，并添加一个 `public` 的 `class UInputAction* IA_Look`
    属性，该属性必须是 `UPROPERTY`，并具有 `EditAnywhere` 和 `Category = Input` 标签：
- en: '[PRE29]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, add a declaration for a `protected` function called `Look`, which returns
    nothing and receives a `const FInputActionValue& Value` parameter:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `Look` 的 `protected` 函数的声明，该函数不返回任何内容，并接收一个 `const FInputActionValue&
    Value` 参数：
- en: '[PRE30]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, go to the `SetupPlayerInputComponent` function implementation, in the
    class’s source file, and duplicate the line responsible for listening to the `IA_Move`
    Input Action. In this duplicated line, change the first parameter to `IA_Look`
    and the last parameter to `&AMyThirdPersonChar::Look`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 `SetupPlayerInputComponent` 函数的实现，在类的源文件中，并复制负责监听 `IA_Move` 输入动作的行。在这条复制的行中，将第一个参数更改为
    `IA_Look`，并将最后一个参数更改为 `&AMyThirdPersonChar::Look`：
- en: '[PRE31]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, add the `Look` function’s implementation, where we’ll start by fetching
    the `Value` parameter’s input as `FVector2D`. We’ll do this by calling its `Get`
    function, passing as a `template` parameter the `FVector2D` type. We’ll also save
    its `return` value in a local variable called `InputValue`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加 `Look` 函数的实现，我们将首先将 `Value` 参数的输入作为 `FVector2D` 获取。我们将通过调用其 `Get` 函数来实现，将
    `FVector2D` 类型作为 `template` 参数传递。我们还将将其 `return` 值保存在一个名为 `InputValue` 的局部变量中：
- en: '[PRE32]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the `InputValue` `X` property is different to `0`, we’ll call the `AddControllerYawInput`
    function, passing this property as a parameter. After that, check whether the
    `InputValue` `Y` property is different to `0`, and then we’ll call the `AddControllerPitchInput`
    function, passing this property as a parameter:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `InputValue` 的 `X` 属性与 `0` 不同，我们将调用 `AddControllerYawInput` 函数，并将此属性作为参数传递。之后，检查
    `InputValue` 的 `Y` 属性是否与 `0` 不同，然后我们将调用 `AddControllerPitchInput` 函数，并将此属性作为参数传递：
- en: '[PRE33]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `AddControllerYawInput` and `AddControllerPitchInput` functions are responsible
    for adding rotation input around the *z* (turning left and right) and *y* (looking
    up and down) axes respectively.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddControllerYawInput` 和 `AddControllerPitchInput` 函数分别负责在 *z*（转向左右）和 *y*（向上和向下看）轴周围添加旋转输入。'
- en: 'After you’ve done this, compile your code, open the editor, and open your **BP_MyTPS**
    Blueprint asset. Set its **IA_Look** property to the **IA_Look** Input Action:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，编译你的代码，打开编辑器，并打开你的 **BP_MyTPS** 蓝图资产。将其 **IA_Look** 属性设置为 **IA_Look**
    输入动作：
- en: '![Figure 4.18 – The camera is rotated around the player ](img/Figure_4.18_B18531.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 摄像机围绕玩家旋转](img/Figure_4.18_B18531.jpg)'
- en: Figure 4.18 – The camera is rotated around the player
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 摄像机围绕玩家旋转
- en: 'When you play the level, you should now be able to move the camera by rotating
    the mouse or by tilting the controller’s *right thumbstick*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩这个关卡时，你现在应该能够通过旋转鼠标或倾斜控制器的 *right thumbstick* 来移动摄像机：
- en: '![Figure 4.19 – The camera is rotated around the player ](img/Figure_4.19_B18531.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 摄像机围绕玩家旋转](img/Figure_4.19_B18531.jpg)'
- en: Figure 4.19 – The camera is rotated around the player
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 摄像机围绕玩家旋转
- en: And that concludes the logic for rotating the camera around the player character
    with the player’s input. Now that we’ve learned how to add inputs to our game
    and associate them with in-game actions, such as jumping and moving the player
    character, let’s consolidate what we’ve learned in this chapter by going through
    how to add a new `Walk` action to our game from start to finish in the next activity.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了围绕玩家角色旋转摄像机的逻辑。现在我们已经学会了如何将输入添加到我们的游戏中，并将它们与游戏中的动作关联起来，例如跳跃和移动玩家角色，让我们通过在下一个活动中从头到尾添加一个新的
    `Walk` 动作来巩固我们在本章中学到的知识。
- en: Activity 4.01 – adding walking logic to our character
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动 4.01 – 为我们的角色添加行走逻辑
- en: In the current game, our character runs by default when we use the movement
    keys, but we need to reduce the character’s speed and make it walk.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前游戏中，当我们使用移动键时，我们的角色默认会跑动，但我们需要降低角色的速度并使其行走。
- en: So, in this activity, we’ll be adding logic that will make our character walk
    when we move it while holding the *Shift* key on the keyboard or the **Gamepad
    Face Button Right** key (*B* for the Xbox controller and *O* for the PlayStation
    controller).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个活动中，我们将添加逻辑，使得我们在按住键盘上的 *Shift* 键或 **Gamepad Face Button Right** 键（Xbox
    控制器的 *B* 键和 PlayStation 控制器的 *O* 键）移动角色时，角色能够行走。
- en: 'To do this, follow these steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: Duplicate the `IA_Walk`. Because this new Input Action’s setup is similar to
    that of the **IA_Jump** Input Action, we’ll leave this duplicated asset as is.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `IA_Walk`。由于这个新的输入动作的设置与 **IA_Jump** 输入动作类似，我们将保留这个复制的资产不变。
- en: Then, open the **IA_Character** Input Context and add a new mapping for the
    **IA_Walk** Input Action. Add the following keys to this new mapping – **Left
    Shift**, and **Gamepad Face Button Right**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 **IA_Character** 输入上下文，并为 **IA_Walk** 输入动作添加一个新的映射。将以下键添加到这个新映射中 – **Left
    Shift** 和 **Gamepad Face Button Right**。
- en: Open the `MyThirdPersonChar` class’s header file and add a `class UInputAction*
    IA_Walk` property, which must be `UPROPERTY` and have the `EditAnywhere` and `Category
    = Input` tags.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MyThirdPersonChar` 类的头文件，并添加一个 `UInputAction* IA_Walk` 属性，该属性必须是 `UPROPERTY`，并具有
    `EditAnywhere` 和 `Category = Input` 标签。
- en: Then, add declarations for two `protected` functions that return nothing and
    receive no parameters, called `BeginWalking` and `StopWalking`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加两个名为 `BeginWalking` 和 `StopWalking` 的 `protected` 函数的声明，这两个函数都不返回任何内容，也不接收任何参数。
- en: Add the implementations for both these functions in the class’s source file.
    In the implementation of the `BeginWalking` function, change the character’s speed
    to 40% of its value by modifying the `CharacterMovementComponent` property’s `MaxWalkSpeed`
    property accordingly. To access the `CharacterMovementComponent` property, use
    the `GetCharacterMovement` function.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中为这两个函数添加实现。在 `BeginWalking` 函数的实现中，通过修改 `CharacterMovementComponent`
    属性的 `MaxWalkSpeed` 属性，将角色的速度更改为其值的 40%。要访问 `CharacterMovementComponent` 属性，请使用
    `GetCharacterMovement` 函数。
- en: The implementation of the `StopWalking` function will be the inverse of that
    of the `BeginWalking` function, which will increase the character’s walk speed
    by 250%.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopWalking` 函数的实现将是 `BeginWalking` 函数实现的逆操作，这将使角色的行走速度提高 250%。'
- en: Listen to the `Walk` action by going to the `SetupPlayerInputComponent` function’s
    implementation and adding two calls to the `BindAction` function, the first one
    of which passes as parameters the `IA_Walk` property, the `ETriggerEvent::Started`
    event, the `this` pointer, and this class’s `BeginWalking` function, while the
    second passes the `IA_Walk` property, the `ETriggerEvent::Completed` event, the
    `this` pointer, and this class’s `StopWalking` function.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过进入 `SetupPlayerInputComponent` 函数的实现并添加两个对 `BindAction` 函数的调用，来监听 `Walk` 动作，第一个调用将
    `IA_Walk` 属性、`ETriggerEvent::Started` 事件、`this` 指针和本类的 `BeginWalking` 函数作为参数传递，而第二个调用将
    `IA_Walk` 属性、`ETriggerEvent::Completed` 事件、`this` 指针和本类的 `StopWalking` 函数作为参数传递。
- en: Compile your code, open the editor, open your `BP_MyTPS` Blueprint asset, and
    set the **IA_Walk** property to the **IA_Walk** Input Action.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码，打开编辑器，打开你的 `BP_MyTPS` 蓝图资产，并将 **IA_Walk** 属性设置为 **IA_Walk** 输入动作。
- en: 'After following these steps, you should be able to have your character walk,
    which decreases its speed and slightly changes its animation, by pressing either
    the keyboard’s *Left Shift* key or the controller’s **Face Button Right** key:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循这些步骤之后，你应该能够通过按键盘的 *左 Shift* 键或控制器的 **面键右** 键来使你的角色行走，这会降低其速度并略微改变其动画：
- en: '![Figure 4.20 – The character running (left) and walking (right)](img/Figure_4.20_B18531.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 正在跑动（左）和行走（右）的角色](img/Figure_4.20_B18531.jpg)'
- en: Figure 4.20 – The character running (left) and walking (right)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 正在跑动（左）和行走（右）的角色
- en: And that concludes our activity. Our character should now be able to walk slowly
    as long as the player is holding the **Walk** Input Action.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的活动。现在，只要玩家保持按下 **行走** 输入动作，我们的角色应该能够缓慢行走。
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve learned how to create and modify **Input Actions**,
    as well as add their mappings to an **Input Context**, which gives you some flexibility
    when determining which keys trigger a specific action or axis, how to listen to
    them, and how to execute in-game logic when they’re pressed and released.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建和修改 **输入动作**，以及将它们的映射添加到 **输入上下文** 中，这在你确定哪些键触发特定动作或轴时提供了灵活性，如何监听它们，以及如何在它们被按下和释放时执行游戏逻辑。
- en: Now that you know how to handle the player’s input, you can allow the player
    to interact with your game and offer the agency that video games are so well known
    for.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何处理玩家的输入，你可以允许玩家与你的游戏互动，并提供视频游戏所特有的代理权。
- en: In the next chapter, we’ll start making our own game from scratch. It’ll be
    called **Dodgeball** and will consist of the player controlling a character trying
    to run away from enemies that are throwing dodgeballs at it. In that chapter,
    we will have the opportunity to start learning about many important topics, with
    a heavy focus on collisions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从头开始制作自己的游戏。它将被命名为 **躲避球**，玩家将控制一个角色试图逃离向其投掷躲避球敌人的攻击。在那个章节中，我们将有机会开始学习许多重要主题，重点放在碰撞上。
