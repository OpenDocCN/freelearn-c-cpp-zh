- en: Lighting and Shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Shading with multiple positional lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shading with a directional light source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using per-fragment shading for improved realism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Blinn-Phong reflection model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a spotlight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a cartoon shading effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating fog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A physically-based reflection model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml), *The Basics of GLSL
    Shaders*, we covered a number of techniques for implementing some of the shading
    effects that were produced by the former fixed-function pipeline. We also looked
    at some basic features of GLSL such as functions and subroutines. In this chapter,
    we'll move beyond those introductory features, and see how to produce shading
    effects such as spotlights, fog, and cartoon style shading. We'll cover how to
    use multiple light sources and how to improve the realism of the results with
    a technique called per-fragment shading.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also cover the very popular and important Blinn-Phong reflection model
    and directional light sources.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll cover how to fine-tune the depth test by configuring the early
    depth test optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Shading with multiple positional lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When shading with multiple light sources, we need to evaluate the reflection
    model for each light, and sum the results to determine the total light intensity
    reflected by a surface location. The natural choice is to create uniform arrays
    to store the position and intensity of each light. We'll use an array of structures
    so that we can store the values for multiple lights within a single uniform variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a "pig" mesh rendered with five light sources of
    different colors. Note the multiple specular highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2498e7c9-3129-45d5-8af1-aa31ff0a0280.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your OpenGL program with the vertex position in attribute location zero,
    and the normal in location one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that renders using the Blinn-Phong reflection model
    with multiple light sources, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the vertex shader, we''ll use a similar structure as in the previous recipes,
    except we will use an array of structures for the lights. In addition, we just
    store two intensities for each light. The first is the ambient intensity and the
    second is used for both diffuse and specular. The `phongModel` function is updated
    to use light information from one of the values in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The fragment shader simply applies the color to the fragment, as in previous
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the OpenGL application, set the values for the `lights` array in the vertex
    shader. For each light, use something similar to the following code. This example
    uses the C++ shader program class described in [Chapter 2](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml),
    *Working with GLSL Programs* (`prog` is a `GLSLProgram` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the vertex shader, the lighting parameters are stored in the uniform
    array `lights`. Each element of the array is a struct of type `LightInfo`. This
    example uses five lights. The diffuse/specular light intensity is stored in the
    `L` field, the ambient intensity is stored in the `La` field, and the position
    in camera coordinates is stored in the `Position` field.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the uniform variables are essentially the same as in the Phong model
    shader presented in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml), *The
    Basics of GLSL Shaders*.
  prefs: []
  type: TYPE_NORMAL
- en: The `phongModel` function is responsible for computing the shading equation
    for a given light source. The index of the light is provided as the first parameter, `light`.
    The equation is computed based on the values in the `lights` array in that index.
    In this example, we don't use a separate light intensity for the diffuse and specular
    components.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, a `for` loop is used to compute the shading equation
    for each light, and the results are summed into the output variable `Color`.
  prefs: []
  type: TYPE_NORMAL
- en: The fragment shader simply applies the interpolated color to the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/scenemultilight.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)*,*
    *The Basics of GLSL Shaders*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Shading with a directional light source* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shading with a directional light source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core component of a shading equation is the vector that points from the surface
    location toward the light source (`s`, in previous examples). For lights that
    are extremely far away, there is very little variation in this vector over the
    surface of an object. In fact, for very distant light sources, the vector is essentially
    the same for all points on a surface (another way of thinking about this is that
    the light rays are nearly parallel). Such a model would be appropriate for a distant,
    but powerful, light source such as the sun. Such a light source is commonly called
    a **directional light source** because it does not have a specific position, only
    a direction.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we are ignoring the fact that, in reality, the intensity of the light
    decreases with the square of the distance from the source. However, it is not
    uncommon to ignore this aspect for directional light sources.
  prefs: []
  type: TYPE_NORMAL
- en: If we are using a directional light source, the direction toward the source
    is the same for all points in the scene. Therefore, we can increase the efficiency
    of our shading calculations because we no longer need to recompute the direction
    toward the light source for each location on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is a visual difference between a positional light source and
    a directional one. The following images show a torus rendered with a positional
    light (left) and a directional light (right). In the left image, the light is
    located somewhat close to the torus. The directional light covers more of the
    surface of the torus due to the fact that all of the rays are parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e1837f9-f62c-4ba8-be6b-90bb75362678.png)'
  prefs: []
  type: TYPE_IMG
- en: In previous versions of OpenGL, the fourth component of the light position was
    used to determine whether or not a light was considered directional. A zero in
    the fourth component indicated that the light source was directional and the position
    was to be treated as a direction toward the source (a vector). Otherwise, the
    position was treated as the actual location of the light source. In this example,
    we'll emulate the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your OpenGL program with the vertex position in attribute location zero,
    and the vertex normal in location one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that implements the Phong reflection model using
    a directional light source, we''ll use the same vertex shader as in the previous
    recipe, except with a single light source.  Within the `phongModel` function,
    replace the calculation of the `s` vector with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the vertex shader, the fourth coordinate of the uniform variable `Light.Position`
    is used to determine whether or not the light is to be treated as a directional
    light. Inside the `phongModel` function, which is responsible for computing the
    shading equation, the value of the vector `s` is determined based on whether or
    not the fourth coordinate of `Light.Position` is zero. If the value is zero, `Light.Position`
    is normalized and used as the direction toward the light source. Otherwise, `Light.Position`
    is treated as a location in eye coordinates, and we compute the direction toward the
    light source by subtracting the vertex position from `Light.Position` and normalizing
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a slight efficiency gain when using directional lights, due to the
    fact that there is no need to recompute the light direction for each vertex. This
    saves a subtraction operation, which is a small gain but could accumulate when
    there are several lights or when the lighting is computed per-fragment.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/scenedirectional.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using per-fragment shading **for improved realism* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using per-fragment shading for improved realism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the shading equation is evaluated within the vertex shader (as we have
    done in previous recipes), we end up with a color associated with each vertex.
    That color is then interpolated across the face, and the fragment shader assigns
    that interpolated color to the output fragment. As mentioned previously, this
    technique is called **Gouraud shading**. Gouraud shading (like all shading techniques)
    is an approximation, and can lead to some less than desirable results when, for
    example, the reflection characteristics at the vertices have little resemblance
    to those in the center of the polygon. For example, a bright specular highlight
    may reside in the center of a polygon but not at its vertices. Simply evaluating
    the shading equation at the vertices would prevent the specular highlight from
    appearing in the rendered result. Other undesirable artifacts, such as edges of
    polygons, may also appear when Gouraud shading is used, due to the fact that color
    interpolation may not match the value of the reflection model across the face.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the accuracy of our results, we can move the computation of the shading
    equation from the vertex shader to the fragment shader. Instead of interpolating
    color across the polygon, we interpolate the position and normal vector, and use
    these values to evaluate the shading equation at each fragment. This technique
    is called **Phong shading** or **Phong interpolation**. The results from Phong
    shading are much more accurate and provide more pleasing results, but some undesirable
    artifacts may still appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the difference between Gouraud and Phong shading.
    The scene on the left is rendered with Gouraud (per-vertex) shading, and on the
    right is the same scene rendered using Phong (per-fragment) shading. Underneath
    the teapot is a partial plane, drawn with a single quad. Note the difference in
    the specular highlight on the teapot, as well as the variation in the color of
    the plane beneath the teapot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6158b4-6338-4dc5-9760-02cd47873aeb.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we'll implement Phong shading by passing the position and normal
    from the vertex shader to the fragment shader, and then evaluating the Phong reflection
    model within the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your program with the vertex position in attribute location zero, and
    the normal in location one. Your OpenGL application must also provide the values
    for the uniform variables, as in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that can be used for implementing per-fragment (or
    Phong) shading using the Phong reflection model, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader simply converts the position and normal to camera coordinates
    and passes them to the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader evaluates the Phong reflection model using the values passed
    from the vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vertex shader has two output variables: `Position` and `Normal`. In the
    `main` function, we convert the vertex normal to camera coordinates by transforming
    with the normal matrix, and then store the converted value in `Normal`. Similarly,
    the vertex position is converted to eye coordinates by transforming it by the
    model-view matrix, and the converted value is stored in `Position`. The values
    of `Position` and `Normal` are automatically interpolated and provided to the
    fragment shader via the corresponding input variables. The fragment shader then
    computes the Phong reflection model using the values provided. Here, we re-normalize
    the `Normal` vector because the interpolation process can create vectors that
    are not of unit length.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the result is then stored in the output variable `FragColor`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evaluating the shading equation within the fragment shader produces more accurate
    renderings. However, the price we pay is in the evaluation of the shading model
    for each pixel of the polygon, rather than at each vertex. The good news is that
    with modern graphics cards, there may be enough processing power to evaluate all
    of the fragments for a polygon in parallel. This can essentially provide nearly
    equivalent performance for either per-fragment or per-vertex shading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/sceneperfragment.cpp` recipe in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Blinn-Phong reflection model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As covered in the *Implementing the Phong reflection model *recipe in [Chapter
    3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml), *The Basics of GLSL Shaders*,
    the specular term in the equation involves the dot product of the vector of pure
    reflection (*r*), and the direction toward the viewer (*v*):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to evaluate the preceding equation, we need to find the vector of
    pure reflection (*r*), which is the reflection of the vector toward the light
    source (*s*) about the normal vector (*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dce10af-52fa-4818-a702-2e42d3bf27ef.png)'
  prefs: []
  type: TYPE_IMG
- en: This equation is implemented using the GLSL function `reflect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid calculating *r* by making use of the following observation. When
    *v* is aligned with *r*, the normal vector (*n*) must be halfway between *v* and
    *s*. Let''s define the halfway vector (*h*) as the vector that is halfway between
    *v* and *s*, where *h* is normalized after the addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b44c9a59-70f4-489e-86c8-5c6004d39768.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the relative positions of the halfway vector and
    the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2615656a-d295-4666-9347-e2a100568868.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then replace the dot product in the equation for the specular component,
    with the dot product of *h* and *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c114917-4c01-4b1f-8f4c-f554155dc7e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Computing *h* requires fewer operations than it takes to compute *r*, so we
    should expect some efficiency gain by using the halfway vector. The angle between
    the halfway vector and the normal vector is proportional to the angle between
    the vector of pure reflection (*r*) and the vector toward the viewer (*v*) when
    all vectors are co-planar. Therefore, we expect that the visual results will be
    similar, although not exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: This small modification to the Phong reflection model was proposed by James
    Blinn, a researcher who worked at NASA's **Jet Propulsion Laboratory** (**JPL**).
    His modified version, which uses the *halfway vector* in the specular term is,
    therefore called the **Blinn-Phong model**.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that the Blinn-Phong model, despite appearing to be
    somewhat *ad hoc*, produces results that match physical measurements more closely
    than the Phong model.  For details, see this paper:[ http://people.csail.mit.edu/wojciech/BRDFValidation/index.html](http://people.csail.mit.edu/wojciech/BRDFValidation/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by utilizing the same shader program that was presented in the recipe *Using
    per-fragment shading for improved realism*, and set up your OpenGL program as
    described there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the same shader pair as in the recipe *Using per-fragment **shading for
    improved realism*, replace the `phongModel` function in the fragment shader with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We compute the halfway vector by summing the direction toward the viewer (`v`),
    and the direction toward the light source (`s`), and normalizing the result. The
    value for the halfway vector is then stored in `h`. The specular calculation is
    then modified to use the dot product between `h` and the normal vector (`n`).
    The rest of the calculation is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the teapot rendered using the Blinn-Phong model
    (right), versus the same rendering using the equation provided in the *Implementing
    the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders* (left). The halfway vector produces a larger specular
    highlight.  If desired, we could compensate for the difference in the size of
    the specular highlight by increasing the value of the exponent `Material.Shininess`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b37199d-173d-4fd7-bf5d-bef7ea751b4f.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/shader/blinnphong.vert.glsl` and `chapter04/shader/blinnphong.frag.glsl` files
    in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using per-fragment shading for improved realism* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a spotlight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fixed function pipeline had the ability to define light sources as spotlights.
    In such a configuration, the light source was considered to be one that only radiated
    light within a cone, the apex of which was located at the light source. Additionally,
    the light was attenuated so that it was maximal along the axis of the cone and
    decreased toward the outside edges. This allowed us to create light sources that
    had a similar visual effect to a real spotlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a teapot and a torus rendered with a single
    spotlight. Note the slight decrease in the intensity of the spotlight from the
    center toward the outside edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d797f40-5120-4c88-bd9f-4f11214993ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this recipe, we''ll use a shader to implement a spotlight effect, similar
    to that produced by the fixed-function pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c6e823c-5f7f-494a-8ffc-27746d130928.png)'
  prefs: []
  type: TYPE_IMG
- en: The spotlight's cone is defined by a spotlight direction (**d**, in the preceding
    image), a cutoff angle (**c**, in the preceding image), and a position (**P**, in
    the preceding image). The intensity of the spotlight is considered to be the strongest
    along the axis of the cone, and decreases as you move toward the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with the same vertex shader from the recipe, *Using per-fragment shading
    for improved realism*. Your OpenGL program must set the values for all uniform
    variables defined in that vertex shader as well as the fragment shader shown next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that uses the ADS shading model with a spotlight,
    use the following code for the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SpotLightInfo` structure defines all of the configuration options for the
    spotlight. We declare a single uniform variable named `Spot` to store the data
    for our spotlight. The `Position` field defines the location of the spotlight
    in eye coordinates. The `L` field is the intensity (diffuse and specular) of the
    spotlight, and `La` is the ambient intensity. The `Direction` field will contain
    the direction that the spotlight is pointing, which defines the center axis of
    the spotlight's cone. This vector should be specified in camera coordinates. Within
    the OpenGL program, it should be transformed by the normal matrix in the same
    way that normal vectors would be transformed. We could do so within the shader;
    however, within the shader, the normal matrix would be specified for the object
    being rendered. This may not be the appropriate transform for the spotlight's
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `Exponent` field defines the exponent that is used when calculating the
    angular attenuation of the spotlight. The intensity of the spotlight is decreased
    in proportion to the cosine of the angle between the vector from the light to
    the surface location (the negation of the variable `s`) and the direction of the
    spotlight. That cosine term is then raised to the power of the variable `Exponent`.
    The larger the value of this variable, the faster the intensity of the spotlight
    is decreased. This is similar to the exponent in the specular shading term.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cutoff` field defines the angle between the central axis and the outer
    edge of the spotlight's cone of light. We specify this angle in radians.
  prefs: []
  type: TYPE_NORMAL
- en: The `blinnPhongSpot` function computes the Blinn-Phong reflection model, using
    a spotlight as the light source. The first line computes the ambient lighting
    component and stores it in the `ambient` variable.  The second line computes the
    vector from the surface location to the spotlight's position (`s`).  Next, we
    compute the dot product between the direction from the spotlight to the surface
    point (`-s`) and the direction of the spotlight and store the result in `cosAng`.
    The angle between them is then computed and stored in the variable `angle`.   The
    variable `spotScale` will be used to scale the value of the spotlight's diffuse/specular
    intensity.  It is initially set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: We then compare the value of the `angle` variable with that of the `Spot.Cutoff`
    variable. If `angle` is greater than zero and less than `Spot.Cutoff`, then the
    surface point is within the spotlight's cone. Otherwise, the surface point only
    receives ambient light, so we skip the rest and return only the ambient component.
  prefs: []
  type: TYPE_NORMAL
- en: If `angle` is less than `Spot.Cutoff`, we compute the `spotScale` value by raising
    the dot product of `-s` and `spotDir` to the power of `Spot.Exponent`. The value
    of `spotScale` is used to scale the intensity of the light so that the light is
    maximal in the center of the cone, and decreases as you move toward the edges.
    Finally, the Blinn-Phong reflection model is computed as usual.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Chapter04/scenespot.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using per-fragment shading for improved realism* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The T*he Blinn-Phong reflection model *recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a cartoon shading effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Toon shading** (also called **cel shading**) is a non-photorealistic rendering
    technique that is intended to mimic the style of shading often used in hand-drawn
    animation. There are many different techniques that are used to produce this effect.
    In this recipe, we''ll use a very simple technique that involves a slight modification
    to the ambient and diffuse shading model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic effect is to have large areas of constant color with sharp transitions
    between them. This simulates the way that an artist might shade an object using
    strokes of a pen or brush. The following image shows an example of a teapot and
    torus rendered with toon shading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb29d75e-b189-4725-a38d-4fe472d02af9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The technique presented here involves computing only the ambient and diffuse
    components of the typical ADS shading model, and quantizing the cosine term of
    the diffuse component. In other words, the value of the dot product normally used
    in the diffuse term is restricted to a fixed number of possible values. The following
    table illustrates the concept for four levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Cosine of the angle between s and n** | **Value used** |'
  prefs: []
  type: TYPE_TB
- en: '| Between 1 and 0.75 | 0.75 |'
  prefs: []
  type: TYPE_TB
- en: '| Between 0.75 and 0.5 | 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| Between 0.5 and 0.25 | 0.25 |'
  prefs: []
  type: TYPE_TB
- en: '| Between 0.25 and 0.0 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: In the preceding table, **s** is the vector toward the light source and **n**
    is the normal vector at the surface. By restricting the value of the cosine term
    in this way, the shading displays strong discontinuities from one level to another
    (see the preceding image), simulating the pen strokes of hand-drawn cel animation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with the same vertex shader from the *Using per-fragment shading for improved
    realism* recipe. Your OpenGL program must set the values for all uniform variables
    defined in that vertex shader as well as the fragment shader code described here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that produces a toon shading effect, use the following
    fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The constant variable, `levels`, defines how many distinct values will be used
    in the diffuse calculation. This could also be defined as a uniform variable to
    allow for configuration from the main OpenGL application. We will use this variable
    to quantize the value of the cosine term in the diffuse calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The `toonShade` function is the most significant part of this shader. We start
    by computing `s`, the vector toward the light source. Next, we compute the cosine
    term of the diffuse component by evaluating the dot product of `s` and `Normal`.
    The next line quantizes that value in the following way. Since the two vectors
    are normalized, and we have removed negative values with the `max` function, we
    are sure that the value of cosine is between zero and one. By multiplying this
    value by `levels` and taking the `floor`, the result will be an integer between
    `0` and `levels -1`. When we divide that value by levels (by multiplying by `scaleFactor`),
    we scale these integral values to be between zero and one again. The result is
    a value that can be one of `levels` possible values spaced between zero and one.
    This result is then multiplied by `Material.Kd`, the diffuse reflectivity term.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we combine the diffuse and ambient components together to get the final
    color for the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When quantizing the cosine term, we could have used `ceil` instead of `floor`.
    Doing so would have simply shifted each of the possible values up by one level.
    This would make the levels of shading slightly brighter.
  prefs: []
  type: TYPE_NORMAL
- en: The typical cartoon style seen in most cel animation includes black outlines
    around the silhouettes and along other edges of a shape. The shading model presented
    here does not produce those black outlines. There are several techniques for producing
    them, and we'll look at one later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/scenetoon.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using per-fragment shading for improved realism* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Blinn-Phong reflection model* recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Drawing silhouette lines using the geometry shader* recipe in [Chapter
    6](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml), *Image Processing and Screen Space
    Techniques*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating fog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple fog effect can be achieved by mixing the color of each fragment with
    a constant fog color. The amount of influence of the fog color is determined by
    the distance from the camera. We could use either a linear relationship between
    the distance and the amount of fog color, or we could use a non-linear relationship
    such as an exponential one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows four teapots rendered with a fog effect produced
    by mixing the fog color in a linear relationship with distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b0c4b37-0dad-4535-857b-89e982167b2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To define this linear relationship, we can use the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07b17663-7f06-4f6b-8202-d51e3b7fff74.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding equation, *d[min]* is the distance from the eye where the fog
    is minimal (no fog contribution), and *d[max]* is the distance where the fog color
    obscures all other colors in the scene. The variable *z* represents the distance
    from the eye. The value *f* is the fog factor. A fog factor of zero represents
    100% fog, and a factor of one represents no fog. Since fog typically looks thickest
    at longer distances, the fog factor is minimal when *|z|* is equal to *d[max]*,
    and maximal when *|z|* is equal to *d[min]*.
  prefs: []
  type: TYPE_NORMAL
- en: Since the fog is applied by the fragment shader, the effect will only be visible
    on the objects that are rendered. It will not appear on any *empty* space in the
    scene (the background). To help make the fog effect consistent, you should use
    a background color that matches the maximum fog color.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with the same vertex shader from the *Using per-fragment shading for improved
    realism* recipe. Your OpenGL program must set the values for all uniform variables
    defined in that vertex shader as well as the fragment shader shown in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader that produces a fog-like effect, use the following code
    for the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this shader, the `blinnPhong` function is exactly the same as the one used
    in *The Blinn-Phong reflection model* recipe*.* The part of this shader that deals
    with the fog effect lies within the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: The uniform variable `Fog` contains the parameters that define the extent and
    color of the fog. The `MinDist` field is the distance from the eye to the fog's
    starting point, and `MaxDist` is the distance to the point where the fog is maximal.
    The `Color` field is the color of the fog.
  prefs: []
  type: TYPE_NORMAL
- en: The `dist` variable is used to store the distance from the surface point to
    the eye position. The `z` coordinate of the position is used as an estimate of
    the actual distance. The `fogFactor` variable is computed using the preceding
    equation. Since `dist` may not be between `Fog.MinDist` and `Fog.MaxDist`, we
    clamp the value of `fogFactor` to be between zero and one.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `blinnPhong` function to evaluate the reflection model. The
    result of this is stored in the `shadeColor` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mix `shadeColor` and `Fog.Color` together based on the value of
    `fogFactor`, and the result is used as the fragment color.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used a linear relationship between the amount of fog color
    and the distance from the eye. Another choice would be to use an exponential relationship.
    For example, the following equation could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cda3161-457c-4eba-bd09-0bece84dc867.png)'
  prefs: []
  type: TYPE_IMG
- en: In the above equation, *d* represents the density of the fog. Larger values
    would create *thicker* fog. We could also square the exponent to create a slightly
    different relationship (a faster increase in the fog with distance).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/279083d8-41b2-498f-8d5d-754c37e4a2db.png)'
  prefs: []
  type: TYPE_IMG
- en: Computing distance from the eye
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code, we used the absolute value of the *z* coordinate as
    the distance from the camera. This may cause the fog to look a bit unrealistic
    in certain situations. To compute a more precise distance, we could replace the
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the latter version requires a square root, and therefore would be
    a bit slower in practice.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/scenefog.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Blinn-Phong reflection model* recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A physically-based reflection model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Physically-based rendering** or **PBR** is an umbrella term that encompasses
    tools and techniques that make use of physically-based models of light and reflection.
    The term itself is somewhat loosely defined, but can generally be described as
    a shading/reflection model that tries to model the physics of light interacting
    with matter as accurately as possible. The term may mean slightly different things
    to different people, but for our purposes, we are interested primarily in how
    it differs from the Phong and the Blinn-Phong reflection models.'
  prefs: []
  type: TYPE_NORMAL
- en: The Blinn-Phong model is an empirical model of reflection based on observation.
    A PBR model could also be considered an empirical model, but in general, it is
    more detailed and accurate with regards to the physics of the interaction being
    represented. The Blinn-Phong model uses a few parameters which are not physically
    based but produce effective results. For example, separating the light intensity
    into three (or two) separate values is not physically accurate (there's only one
    light). However, it provides many "tuneable" parameters to the artist to work
    with, giving them the flexibility to achieve the desired look.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, PBR techniques have gained favor due to the fact that they
    reduce the number of tuneable parameters, and provide more consistent results
    across a wide variety of materials. Artists have found that previous models (non-PBR)
    have a tendency to be tricky to "get right." When a scene consists of a wide variety
    of materials, the parameters may require a significant amount of "tweaking" to
    make consistent. With PBR-based techniques, the reflection models try to represent
    the physics more accurately, which tends to make things look more consistent under
    a wide variety of lighting settings, reducing the amount of fine-tuning required
    by artists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll implement a basic PBR-based reflection model using point
    light sources. Before we get started, however, let''s go over the math. In the
    following equations, we''ll use the vectors *n*, *l*, *v*, and *h*, defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n*: The surface normal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l*: The vector representing the direction of incoming light'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*v*: The direction toward the viewer (camera)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*h*: The vector halfway between *l* and *v* (as in the Blinn-Phong model)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A popular mathematical model for describing how light scatters from a surface
    is called **the reflectance equation** (a special case of the **rendering equation**),
    and has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d20ce6f4-de33-4c14-a99d-21854e83d95a.png)'
  prefs: []
  type: TYPE_IMG
- en: This integral might look a bit scary, but basically, it means the following.
    The amount of outgoing radiance from a surface (*L[o]*) toward the viewer (*v*),
    is equal to the integral (think weighted-sum) of the BRDF (*f*) times the amount
    of incoming radiance (*L[i]*). The integral is over the hemisphere above the surface,
    for all incoming light directions (*l*) within that hemisphere weighted by a cosine
    factor (*n · l*). This cosine factor is a weight that essentially represents the
    geometry of the situation. The more directly that the light hits the surface,
    the higher it is weighted.  A more complete derivation of this equation is available
    in several texts. In this recipe, we'll simplify this integral to a simple sum,
    assuming that the only sources of incoming radiance are point light sources. This
    is of course a huge simplification, we'll consider some techniques to evaluate
    the integral more accurately later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most significant term for us is the BRDF term (*f*), which stands for bidirectional
    reflectance distribution function. It represents the fraction of radiance that
    is reflected from a surface point, given the incoming direction (*l*) and the
    outgoing direction (*v*). Its value is a spectral value (R,G,B), with components
    ranging from 0 to 1\. In this recipe, we''ll model the BRDF as a sum of two parts:
    the diffuse BRDF and the specular BRDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b20db239-6f3d-4e4a-a2d6-316d82f14ce0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The diffuse BRDF represents light that is absorbed into the surface slightly
    and then is re-radiated. It is common to model this term so that the radiated
    light has no preferred direction. It is radiated equally in all outgoing directions.
    This is also called **Lambertian reflectance**. Since it has no dependence on
    the incoming or outgoing directions, the Lambertian BRDF is simply a constant
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a41ab085-7009-407b-88d0-588792e10958.png)'
  prefs: []
  type: TYPE_IMG
- en: The *c*[*dif*f] term represents the fraction of light that is diffusely radiated.
    It is commonly considered the diffuse color of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The specular term represents surface reflectance. Light that is reflected directly
    off the surface of the object without being absorbed. This is also sometimes called
    **glossy reflectance**. A common way to model this reflectance is based on **microfacet
    theory**. This theory was developed to describe reflection from general, non-optically
    flat surfaces. It models the surface as consisting of small facets that are optically
    flat (mirrors) and are oriented in various directions. Only those that are oriented
    correctly to reflect toward the viewer can contribute to the BRDF.
  prefs: []
  type: TYPE_NORMAL
- en: 'We represent this BRDF as a product of three terms and a correction factor
    (the denominator):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0141150-3520-47fe-9f9b-d6fda1f7ef8f.png)'
  prefs: []
  type: TYPE_IMG
- en: I won't go into the details of each of these terms. For more information, check
    out the following *See also* section. Instead, I'll briefly describe each one.
    The *F* term represents **Fresnel reflection**, the fraction of light reflected
    from an optically flat surface. The Fresnel reflectance depends on the angle between
    the normal and the direction of incoming light (angle of incidence). However,
    since we are using microfacet theory, the microfacet surfaces that contribute
    are the ones that have their normal vector parallel to the halfway vector (*h*).
    Therefore, we use the angle between *l* and *h* instead of the angle between *l*
    and *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fresnel reflectance also depends on the index of refraction of the surface.
    However, we''ll use an approximation that instead uses a different parameter.
    It is known as the **Schlick approximation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e75a16a-b20c-443e-81a6-36baed8510ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Rather than using the index of refraction, this approximation uses *F[0]*, the
    **characteristic specular reflectance** of the material. Or in other words, the
    reflectance when the angle of incidence is zero degrees. This term is useful in
    that it can be used as a specular "color", which is somewhat more intuitive and
    natural for artists.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further understand this *F[0]* term, let''s consider values for common materials.
    It turns out that a material''s optical properties are closely tied to its electrical
    properties. It is therefore helpful to divide materials into three categories:
    dielectrics (insulators), metals (conductors), and semiconductors. Our model will
    ignore the third category and focus on the first two. Metals generally do not
    exhibit any diffuse reflection, because any light that is refracted into the surface
    is completely absorbed by the free electrons. The value for *F[0]* is much larger
    for metals than for dielectrics. In fact, dielectrics have very low values for
    *F[0]*, usually in the range of 0.05 (for all RGB components). This leads us to
    the following technique.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll associate a color with a material.  If the material is a metal, there's
    no diffuse reflection, so we set *c[diff]* to (0,0,0), and use the color as the
    value for *F[0]* in the Fresnel term. If the material is a dielectric, we set
    *F[0]* to some small value (we'll use (0.04, 0.04, 0.04)), and use the color as
    the value for *c*[*dif*f].  Essentially, we use two slightly different models
    for metals and dielectrics, switching between the two as needed. Rather than using
    the same model for both metals and non-metals and tweaking parameters to represent
    each, we separate them into two different categories each with a slightly different
    BRDF model. The popular term for this is **metalness workflow**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s consider the *D* term in the specular BRDF. This is the **microgeometry normal
    distribution function** (or **microfacet distribution function**). It describes
    the statistical distribution of microsurface orientations. It has a scalar value,
    and gives the relative concentration of microfacet normals in the direction *h*.
    This term has a strong effect on the size and shape of the specular highlight.
    There are many choices for this function, and several have been developed in recent
    years based on physical measurements. We''ll use a popular one from graphics researchers
    Trowbridge and Reitz, which was also given the name **GGX** by a separate research
    team:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dddc6f0b-994a-47a0-a13d-f9a2c0911f0d.png)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, *α* is a term that represents the roughness of the surface.
    Following the lead of others, we'll use a roughness parameter *r*, and set *α*
    to *r²*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll consider the *G* term in the specular BRDF. This is the geometry
    function and describes the probability that microsurfaces with a given normal
    will be visible from both the light direction (*l*) and the view direction (*v*).
    Its value is a scalar between 0 and 1\. It is essential for energy conservation.
    We''ll use the following model for *G*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76ffd085-ba46-4971-bf52-cd85f7efd28e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9f23ea1-19c9-4a9a-b121-25a9f51278da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The constant *k* is a value that is proportional to the roughness. Again, following
    the lead of others (see the following *See also*), we''ll use the following for
    *k*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/683b8189-6ac5-4a4d-8b40-adceb0dcd1aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Putting all of this together, we now have a complete representation for our
    BRDF. Before jumping into the code, let''s revisit the reflectance equation. This
    is the first equation we discussed, containing an integral over all directions
    over the hemisphere above the surface. It would be too costly to try to evaluate
    this integral in an interactive application, so we''ll simplify it by making the
    assumption that all incoming light comes directly from point light sources. If
    we do so, the integral reduces to the following sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80aec644-d2b9-416d-a8d4-78cad56e4ed8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where *N* is the number of point light sources, *L[i]* is the illumination
    received at the surface due to *i*^(th) light source and *l[i]* is the direction
    toward the *i*^(th) light source. Since the intensity of light decreases with
    distance, we''ll use an inverse-square relationship. However, other models could
    be used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbb3e979-8b22-408e-b048-292c48471ad0.png)'
  prefs: []
  type: TYPE_IMG
- en: '*I[i]* is the intensity of the source and *d[i]* is the distance from the surface
    point to the light source.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a complete microfacet-based model that can be applied for metallic
    surfaces and dielectrics. As we covered earlier, we''ll modify the BRDF slightly
    depending on whether we are working with a metal or a dielectric. The number of
    parameters to this BRDF is relatively small. The following parameters will define
    a material:'
  prefs: []
  type: TYPE_NORMAL
- en: The surface roughness (*r*), a value between 0 and 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the material is metallic (Boolean)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A color which is interpreted as the diffuse color for dielectrics, or the characteristic
    specular reflectance (*F[0]*) for metals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parameters are quite intuitive and understandable, as opposed to the many
    parameters in the Blinn-Phong model from the previous recipe. There's just one
    color, and roughness is a more intuitive concept than the specular exponent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll set up our shader by starting with the shader pair from the Blinn-Phong
    recipe, but we'll change the fragment shader. Let's set up some uniforms for the
    light and material information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the light sources, we just need a position and an intensity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For materials, we need the three values mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll define a function for each of the three terms in the specular BRDF.
    Use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function for the Fresnel term using the Schlick approximation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function for the geometry term *G*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The normal distribution function *D*, based on GGX/Trowbridge-Reitz:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now define a function that computes the entire model for a single light
    source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We put this all together by summing over the light sources, applying Gamma
    correction, and writing out the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `schlickFresnel` function computes the value of *F*.  If the material is
    a metal, the value for *F[0]* is taken from the value of `Material.Color`. Otherwise,
    we simply use (0.04, 0.04, 0.04). Since most dielectrics have similar small values
    for *F[0]*, this is a relatively good approximation for common dielectrics.
  prefs: []
  type: TYPE_NORMAL
- en: The `geomSmith` and `ggxDistribution` functions are straightforward implementations
    of the equations described previously. However, in `geomSmith`, we omit the numerator.
    This is due to the fact that it will cancel with the denominator of the overall
    specular BRDF.
  prefs: []
  type: TYPE_NORMAL
- en: The `microfacetModel` function computes the BRDF. The `diffuse` term is set
    to `0` if the material is metallic, otherwise, it is set to the value of the material's
    color. Note that we omit the factor of *π* here. This is due to the fact that
    it will cancel with the *π* term in the overall sum (the last summation equation),
    so no need to include it here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we determine the *L[i]* term (`lightI`) and the vector *l*, depending
    on whether it is a directional light or a positional one. If it is directional,
    `lightI` is just the value of `Light[lightIdx].L`, otherwise, it is scaled by
    the inverse square of the distance to the light source.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we calculate the specular BRDF (`specBrdf`), using the functions we defined
    previously. Note that (as mentioned previously) we omit the denominator of the
    BRDF (except for the factor of 0.25) due to the fact that those two dot products
    cancel with the numerators of the *G[1]* functions.
  prefs: []
  type: TYPE_NORMAL
- en: The final result of this function is the total BRDF times the light intensity,
    times the dot product of *n* and *l*. We only multiply the specular BRDF times
    *π* due to the fact that we omitted the *π* term from the diffuse BRDF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Results for some simple materials are shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e6a3e0a-0c24-4a2a-b78c-6cc4214bcede.png)'
  prefs: []
  type: TYPE_IMG
- en: The back row shows dielectric (non-metal) materials with increasing roughness
    from left to right.   The front row shows five metallic materials with various
    values for *F[0]*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than making `Material.Metal` a Boolean value, one could choose to make
    it a continuous value between 0 and 1.  Indeed, this is exactly what some implementations
    do. The value would then be used to interpolate between the two models (metallic
    and dielectric). However, that makes the parameter somewhat less intuitive for
    artists and you may find that the extra configurability may not be all that useful.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/scenepbr.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An excellent explanation of the mathematics behind PBR models and other information
    from the SIGGRAPH 2013 conference at [http://blog.selfshadow.com/publications/s2013-shading-course/](http://blog.selfshadow.com/publications/s2013-shading-course/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *wonderful* book: *Physically Based Rendering* by Pharr, Jakob, and Humphreys,
    currently in its third edition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
