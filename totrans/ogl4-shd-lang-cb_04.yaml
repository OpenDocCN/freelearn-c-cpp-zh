- en: Lighting and Shading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照明和着色
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Shading with multiple positional lights
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个位置光源进行着色
- en: Shading with a directional light source
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方向光源进行着色
- en: Using per-fragment shading for improved realism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逐片段着色提高真实感
- en: The Blinn-Phong reflection model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blinn-Phong反射模型
- en: Simulating a spotlight
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟聚光灯
- en: Creating a cartoon shading effect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建卡通着色效果
- en: Simulating fog
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟雾
- en: A physically-based reflection model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物理的反射模型
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml), *The Basics of GLSL
    Shaders*, we covered a number of techniques for implementing some of the shading
    effects that were produced by the former fixed-function pipeline. We also looked
    at some basic features of GLSL such as functions and subroutines. In this chapter,
    we'll move beyond those introductory features, and see how to produce shading
    effects such as spotlights, fog, and cartoon style shading. We'll cover how to
    use multiple light sources and how to improve the realism of the results with
    a technique called per-fragment shading.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml) *GLSL着色器的基础* 中，我们介绍了一些实现前固定功能管线产生的着色效果的技术。我们还探讨了GLSL的一些基本特性，如函数和子程序。在本章中，我们将超越这些入门特性，了解如何产生聚光灯、雾和卡通风格着色等着色效果。我们将介绍如何使用多个光源以及如何通过称为逐片段着色的技术来提高结果的真实感。
- en: We'll also cover the very popular and important Blinn-Phong reflection model
    and directional light sources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍非常流行且重要的Blinn-Phong反射模型和方向光源。
- en: Finally, we'll cover how to fine-tune the depth test by configuring the early
    depth test optimization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍如何通过配置早期深度测试优化来微调深度测试。
- en: Shading with multiple positional lights
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个位置光源进行着色
- en: When shading with multiple light sources, we need to evaluate the reflection
    model for each light, and sum the results to determine the total light intensity
    reflected by a surface location. The natural choice is to create uniform arrays
    to store the position and intensity of each light. We'll use an array of structures
    so that we can store the values for multiple lights within a single uniform variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个光源进行着色时，我们需要评估每个光源的反射模型，并将结果相加以确定表面位置反射的总光强度。自然的选择是创建统一数组来存储每个光源的位置和强度。我们将使用结构数组，这样我们就可以在单个统一变量中存储多个光源的值。
- en: 'The following image shows a "pig" mesh rendered with five light sources of
    different colors. Note the multiple specular highlights:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用五种不同颜色的光源渲染的“猪”网格。注意多个镜面高光：
- en: '![](img/2498e7c9-3129-45d5-8af1-aa31ff0a0280.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2498e7c9-3129-45d5-8af1-aa31ff0a0280.png)'
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL program with the vertex position in attribute location zero,
    and the normal in location one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶点位置在属性位置零和法线在位置一设置你的OpenGL程序。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that renders using the Blinn-Phong reflection model
    with multiple light sources, use the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建使用Blinn-Phong反射模型和多个光源进行渲染的着色器程序，请按照以下步骤操作：
- en: 'In the vertex shader, we''ll use a similar structure as in the previous recipes,
    except we will use an array of structures for the lights. In addition, we just
    store two intensities for each light. The first is the ambient intensity and the
    second is used for both diffuse and specular. The `phongModel` function is updated
    to use light information from one of the values in the array:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们将使用与之前食谱中类似的结构，但我们将使用结构数组来存储光源。此外，我们只为每个光源存储两个强度值。第一个是环境强度，第二个用于漫反射和镜面反射。`phongModel`函数更新为使用数组中的一个值来使用光源信息：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The fragment shader simply applies the color to the fragment, as in previous
    recipes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器简单地将颜色应用到片段上，就像之前的食谱中一样。
- en: 'In the OpenGL application, set the values for the `lights` array in the vertex
    shader. For each light, use something similar to the following code. This example
    uses the C++ shader program class described in [Chapter 2](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml),
    *Working with GLSL Programs* (`prog` is a `GLSLProgram` object):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中，在顶点着色器中设置`lights`数组的值。对于每个光源，使用以下类似代码。此示例使用[第2章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)中描述的C++着色器程序类*使用GLSL程序*（`prog`是一个`GLSLProgram`对象）：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Within the vertex shader, the lighting parameters are stored in the uniform
    array `lights`. Each element of the array is a struct of type `LightInfo`. This
    example uses five lights. The diffuse/specular light intensity is stored in the
    `L` field, the ambient intensity is stored in the `La` field, and the position
    in camera coordinates is stored in the `Position` field.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，光照参数存储在统一数组 `lights` 中。数组的每个元素都是一个类型为 `LightInfo` 的结构体。本例使用五个光源。漫反射/镜面反射光强度存储在
    `L` 字段中，环境光强度存储在 `La` 字段中，位置存储在相机坐标的 `Position` 字段中。
- en: The rest of the uniform variables are essentially the same as in the Phong model
    shader presented in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml), *The
    Basics of GLSL Shaders*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的统一变量基本上与第 3 章[《GLSL 着色器基础》](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)中介绍的
    Phong 模型着色器相同。
- en: The `phongModel` function is responsible for computing the shading equation
    for a given light source. The index of the light is provided as the first parameter, `light`.
    The equation is computed based on the values in the `lights` array in that index.
    In this example, we don't use a separate light intensity for the diffuse and specular
    components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`phongModel` 函数负责计算给定光源的阴影方程。光源的索引作为第一个参数，`light` 提供。方程基于该索引处的 `lights` 数组中的值进行计算。在这个例子中，我们没有为漫反射和镜面反射组件使用单独的光强度。'
- en: In the `main` function, a `for` loop is used to compute the shading equation
    for each light, and the results are summed into the output variable `Color`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，使用 `for` 循环计算每个光源的阴影方程，并将结果累加到输出变量 `Color` 中。
- en: The fragment shader simply applies the interpolated color to the fragment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器简单地将插值后的颜色应用到片段上。
- en: See also
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter04/scenemultilight.cpp` file in the example code
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter04/scenemultilight.cpp` 文件
- en: The *Implementing the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)*,*
    *The Basics of GLSL Shaders*
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 3 章[《GLSL 着色器基础》](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)中的 *实现 Phong
    反射模型* 菜谱
- en: The *Shading with a directional light source* recipe
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用方向性光源进行阴影处理* 菜谱'
- en: Shading with a directional light source
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方向性光源进行阴影处理
- en: A core component of a shading equation is the vector that points from the surface
    location toward the light source (`s`, in previous examples). For lights that
    are extremely far away, there is very little variation in this vector over the
    surface of an object. In fact, for very distant light sources, the vector is essentially
    the same for all points on a surface (another way of thinking about this is that
    the light rays are nearly parallel). Such a model would be appropriate for a distant,
    but powerful, light source such as the sun. Such a light source is commonly called
    a **directional light source** because it does not have a specific position, only
    a direction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影方程的一个核心组件是从表面位置指向光源的向量（在之前的例子中为 `s`）。对于非常远的光源，这个向量在物体表面上几乎没有变化。事实上，对于非常遥远的光源，这个向量在表面的所有点上几乎是相同的（另一种思考方式是光线几乎是平行的）。这种模型适用于遥远但强大的光源，如太阳。这种光源通常被称为**方向性光源**，因为它没有特定的位置，只有方向。
- en: Of course, we are ignoring the fact that, in reality, the intensity of the light
    decreases with the square of the distance from the source. However, it is not
    uncommon to ignore this aspect for directional light sources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们忽略了在现实中，光的强度随着与光源距离的平方而减少的事实。然而，对于方向性光源，忽略这一方面并不罕见。
- en: If we are using a directional light source, the direction toward the source
    is the same for all points in the scene. Therefore, we can increase the efficiency
    of our shading calculations because we no longer need to recompute the direction
    toward the light source for each location on the surface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用方向性光源，场景中所有点的光源方向是相同的。因此，我们可以提高阴影计算的效率，因为我们不再需要为表面上的每个位置重新计算光源方向。
- en: 'Of course, there is a visual difference between a positional light source and
    a directional one. The following images show a torus rendered with a positional
    light (left) and a directional light (right). In the left image, the light is
    located somewhat close to the torus. The directional light covers more of the
    surface of the torus due to the fact that all of the rays are parallel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，位置光源和方向光源之间有视觉上的差异。以下图像显示了使用位置光源（左）和方向光源（右）渲染的环面。在左边的图像中，光源位于环面附近。由于所有光线都是平行的，方向光源覆盖了环面的大部分表面：
- en: '![](img/5e1837f9-f62c-4ba8-be6b-90bb75362678.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e1837f9-f62c-4ba8-be6b-90bb75362678.png)'
- en: In previous versions of OpenGL, the fourth component of the light position was
    used to determine whether or not a light was considered directional. A zero in
    the fourth component indicated that the light source was directional and the position
    was to be treated as a direction toward the source (a vector). Otherwise, the
    position was treated as the actual location of the light source. In this example,
    we'll emulate the same functionality.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL的早期版本中，光位置的四分量用于确定是否将光源视为方向光源。第四分量为零表示光源是方向性的，位置应被视为指向源的方向（一个向量）。否则，位置被视为光源的实际位置。在本例中，我们将模拟相同的功能。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL program with the vertex position in attribute location zero,
    and the vertex normal in location one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的OpenGL程序设置好，顶点位置在属性位置零，顶点法线在位置一。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create a shader program that implements the Phong reflection model using
    a directional light source, we''ll use the same vertex shader as in the previous
    recipe, except with a single light source.  Within the `phongModel` function,
    replace the calculation of the `s` vector with the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个使用方向光源实现Phong反射模型的着色器程序，我们将使用与上一个配方相同的顶点着色器，只是使用单个光源。在`phongModel`函数中，用以下内容替换`s`向量的计算：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Within the vertex shader, the fourth coordinate of the uniform variable `Light.Position`
    is used to determine whether or not the light is to be treated as a directional
    light. Inside the `phongModel` function, which is responsible for computing the
    shading equation, the value of the vector `s` is determined based on whether or
    not the fourth coordinate of `Light.Position` is zero. If the value is zero, `Light.Position`
    is normalized and used as the direction toward the light source. Otherwise, `Light.Position`
    is treated as a location in eye coordinates, and we compute the direction toward the
    light source by subtracting the vertex position from `Light.Position` and normalizing
    the result.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，统一变量`Light.Position`的第四坐标用于确定是否将光源视为方向光源。在负责计算着色方程的`phongModel`函数内部，根据`Light.Position`的第四坐标是否为零来确定向量`s`的值。如果值为零，则将`Light.Position`归一化并用作指向光源的方向。否则，将`Light.Position`视为眼坐标中的位置，我们通过从顶点位置减去`Light.Position`并归一化结果来计算指向光源的方向。
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There is a slight efficiency gain when using directional lights, due to the
    fact that there is no need to recompute the light direction for each vertex. This
    saves a subtraction operation, which is a small gain but could accumulate when
    there are several lights or when the lighting is computed per-fragment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方向光源时，由于不需要为每个顶点重新计算光方向，因此可以略微提高效率。这节省了一个减法操作，虽然这是一个小的收益，但如果有多个光源或按片段计算光照时，这种收益可能会累积。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter04/scenedirectional.cpp` file in the example code
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter04/scenedirectional.cpp`文件
- en: The *Implementing the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)的*实现Phong反射模型*配方中
- en: The *Using per-fragment shading **for improved realism* recipe in this chapter
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*使用每片段着色以增强真实感*配方
- en: Using per-fragment shading for improved realism
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用每片段着色以增强真实感
- en: When the shading equation is evaluated within the vertex shader (as we have
    done in previous recipes), we end up with a color associated with each vertex.
    That color is then interpolated across the face, and the fragment shader assigns
    that interpolated color to the output fragment. As mentioned previously, this
    technique is called **Gouraud shading**. Gouraud shading (like all shading techniques)
    is an approximation, and can lead to some less than desirable results when, for
    example, the reflection characteristics at the vertices have little resemblance
    to those in the center of the polygon. For example, a bright specular highlight
    may reside in the center of a polygon but not at its vertices. Simply evaluating
    the shading equation at the vertices would prevent the specular highlight from
    appearing in the rendered result. Other undesirable artifacts, such as edges of
    polygons, may also appear when Gouraud shading is used, due to the fact that color
    interpolation may not match the value of the reflection model across the face.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: To improve the accuracy of our results, we can move the computation of the shading
    equation from the vertex shader to the fragment shader. Instead of interpolating
    color across the polygon, we interpolate the position and normal vector, and use
    these values to evaluate the shading equation at each fragment. This technique
    is called **Phong shading** or **Phong interpolation**. The results from Phong
    shading are much more accurate and provide more pleasing results, but some undesirable
    artifacts may still appear.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the difference between Gouraud and Phong shading.
    The scene on the left is rendered with Gouraud (per-vertex) shading, and on the
    right is the same scene rendered using Phong (per-fragment) shading. Underneath
    the teapot is a partial plane, drawn with a single quad. Note the difference in
    the specular highlight on the teapot, as well as the variation in the color of
    the plane beneath the teapot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6158b4-6338-4dc5-9760-02cd47873aeb.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: In this example, we'll implement Phong shading by passing the position and normal
    from the vertex shader to the fragment shader, and then evaluating the Phong reflection
    model within the fragment shader.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your program with the vertex position in attribute location zero, and
    the normal in location one. Your OpenGL application must also provide the values
    for the uniform variables, as in the previous recipes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that can be used for implementing per-fragment (or
    Phong) shading using the Phong reflection model, use the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader simply converts the position and normal to camera coordinates
    and passes them to the fragment shader:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The fragment shader evaluates the Phong reflection model using the values passed
    from the vertex shader:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vertex shader has two output variables: `Position` and `Normal`. In the
    `main` function, we convert the vertex normal to camera coordinates by transforming
    with the normal matrix, and then store the converted value in `Normal`. Similarly,
    the vertex position is converted to eye coordinates by transforming it by the
    model-view matrix, and the converted value is stored in `Position`. The values
    of `Position` and `Normal` are automatically interpolated and provided to the
    fragment shader via the corresponding input variables. The fragment shader then
    computes the Phong reflection model using the values provided. Here, we re-normalize
    the `Normal` vector because the interpolation process can create vectors that
    are not of unit length.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the result is then stored in the output variable `FragColor`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evaluating the shading equation within the fragment shader produces more accurate
    renderings. However, the price we pay is in the evaluation of the shading model
    for each pixel of the polygon, rather than at each vertex. The good news is that
    with modern graphics cards, there may be enough processing power to evaluate all
    of the fragments for a polygon in parallel. This can essentially provide nearly
    equivalent performance for either per-fragment or per-vertex shading.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter04/sceneperfragment.cpp` recipe in the example code
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Blinn-Phong reflection model
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As covered in the *Implementing the Phong reflection model *recipe in [Chapter
    3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml), *The Basics of GLSL Shaders*,
    the specular term in the equation involves the dot product of the vector of pure
    reflection (*r*), and the direction toward the viewer (*v*):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to evaluate the preceding equation, we need to find the vector of
    pure reflection (*r*), which is the reflection of the vector toward the light
    source (*s*) about the normal vector (*n*):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dce10af-52fa-4818-a702-2e42d3bf27ef.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: This equation is implemented using the GLSL function `reflect`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid calculating *r* by making use of the following observation. When
    *v* is aligned with *r*, the normal vector (*n*) must be halfway between *v* and
    *s*. Let''s define the halfway vector (*h*) as the vector that is halfway between
    *v* and *s*, where *h* is normalized after the addition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b44c9a59-70f4-489e-86c8-5c6004d39768.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the relative positions of the halfway vector and
    the others:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2615656a-d295-4666-9347-e2a100568868.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'We can then replace the dot product in the equation for the specular component,
    with the dot product of *h* and *n*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c114917-4c01-4b1f-8f4c-f554155dc7e9.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Computing *h* requires fewer operations than it takes to compute *r*, so we
    should expect some efficiency gain by using the halfway vector. The angle between
    the halfway vector and the normal vector is proportional to the angle between
    the vector of pure reflection (*r*) and the vector toward the viewer (*v*) when
    all vectors are co-planar. Therefore, we expect that the visual results will be
    similar, although not exactly the same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 计算*h*所需的操作比计算*r*要少，因此我们预计使用中点向量可以带来一些效率提升。当所有向量共面时，中点向量与法线向量之间的角度与纯反射向量(*r*)与观察者方向向量(*v*)之间的角度成正比。因此，我们预计视觉结果将相似，尽管不完全相同。
- en: This small modification to the Phong reflection model was proposed by James
    Blinn, a researcher who worked at NASA's **Jet Propulsion Laboratory** (**JPL**).
    His modified version, which uses the *halfway vector* in the specular term is,
    therefore called the **Blinn-Phong model**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对Phong反射模型的小幅修改是由James Blinn提出的，他曾在NASA的**喷气推进实验室**（**JPL**）工作。由于他的修改版本在镜面项中使用了*中点向量*，因此被称为**Blinn-Phong模型**。
- en: It is interesting to note that the Blinn-Phong model, despite appearing to be
    somewhat *ad hoc*, produces results that match physical measurements more closely
    than the Phong model.  For details, see this paper:[ http://people.csail.mit.edu/wojciech/BRDFValidation/index.html](http://people.csail.mit.edu/wojciech/BRDFValidation/index.html)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管Blinn-Phong模型看起来有些**ad hoc**，但它产生的结果比Phong模型更接近物理测量。有关详情，请参阅这篇论文：[http://people.csail.mit.edu/wojciech/BRDFValidation/index.html](http://people.csail.mit.edu/wojciech/BRDFValidation/index.html)
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start by utilizing the same shader program that was presented in the recipe *Using
    per-fragment shading for improved realism*, and set up your OpenGL program as
    described there.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，利用在配方*使用片段着色提高真实感*中展示的相同着色器程序，并按照那里的描述设置你的OpenGL程序。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Using the same shader pair as in the recipe *Using per-fragment **shading for
    improved realism*, replace the `phongModel` function in the fragment shader with
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与配方*使用片段着色提高真实感*中相同的着色器对，将片段着色器中的`phongModel`函数替换为以下内容：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We compute the halfway vector by summing the direction toward the viewer (`v`),
    and the direction toward the light source (`s`), and normalizing the result. The
    value for the halfway vector is then stored in `h`. The specular calculation is
    then modified to use the dot product between `h` and the normal vector (`n`).
    The rest of the calculation is unchanged.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将指向观察者的方向(`v`)和指向光源的方向(`s`)相加，并对结果进行归一化来计算中点向量。然后，将中点向量的值存储在`h`中。然后，将镜面计算修改为使用`h`与法线向量(`n`)的点积。其余的计算保持不变。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following screenshot shows the teapot rendered using the Blinn-Phong model
    (right), versus the same rendering using the equation provided in the *Implementing
    the Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders* (left). The halfway vector produces a larger specular
    highlight.  If desired, we could compensate for the difference in the size of
    the specular highlight by increasing the value of the exponent `Material.Shininess`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用Blinn-Phong模型（右侧）渲染的茶壶，与使用[第3章](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)中*实现Phong反射模型*配方提供的方程式进行相同渲染的结果（左侧）。中点向量产生更大的镜面高光。如果需要，我们可以通过增加`Material.Shininess`指数的值来补偿镜面高光大小的差异：
- en: '![](img/8b37199d-173d-4fd7-bf5d-bef7ea751b4f.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b37199d-173d-4fd7-bf5d-bef7ea751b4f.png)'
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The `chapter04/shader/blinnphong.vert.glsl` and `chapter04/shader/blinnphong.frag.glsl` files
    in the example code
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter04/shader/blinnphong.vert.glsl`和`chapter04/shader/blinnphong.frag.glsl`文件
- en: The *Using per-fragment shading for improved realism* recipe
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用片段着色提高真实感*配方'
- en: Simulating a spotlight
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟聚光灯
- en: The fixed function pipeline had the ability to define light sources as spotlights.
    In such a configuration, the light source was considered to be one that only radiated
    light within a cone, the apex of which was located at the light source. Additionally,
    the light was attenuated so that it was maximal along the axis of the cone and
    decreased toward the outside edges. This allowed us to create light sources that
    had a similar visual effect to a real spotlight.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a teapot and a torus rendered with a single
    spotlight. Note the slight decrease in the intensity of the spotlight from the
    center toward the outside edge:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d797f40-5120-4c88-bd9f-4f11214993ed.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'In this recipe, we''ll use a shader to implement a spotlight effect, similar
    to that produced by the fixed-function pipeline:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c6e823c-5f7f-494a-8ffc-27746d130928.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: The spotlight's cone is defined by a spotlight direction (**d**, in the preceding
    image), a cutoff angle (**c**, in the preceding image), and a position (**P**, in
    the preceding image). The intensity of the spotlight is considered to be the strongest
    along the axis of the cone, and decreases as you move toward the edges.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with the same vertex shader from the recipe, *Using per-fragment shading
    for improved realism*. Your OpenGL program must set the values for all uniform
    variables defined in that vertex shader as well as the fragment shader shown next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that uses the ADS shading model with a spotlight,
    use the following code for the fragment shader:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SpotLightInfo` structure defines all of the configuration options for the
    spotlight. We declare a single uniform variable named `Spot` to store the data
    for our spotlight. The `Position` field defines the location of the spotlight
    in eye coordinates. The `L` field is the intensity (diffuse and specular) of the
    spotlight, and `La` is the ambient intensity. The `Direction` field will contain
    the direction that the spotlight is pointing, which defines the center axis of
    the spotlight's cone. This vector should be specified in camera coordinates. Within
    the OpenGL program, it should be transformed by the normal matrix in the same
    way that normal vectors would be transformed. We could do so within the shader;
    however, within the shader, the normal matrix would be specified for the object
    being rendered. This may not be the appropriate transform for the spotlight's
    direction.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The `Exponent` field defines the exponent that is used when calculating the
    angular attenuation of the spotlight. The intensity of the spotlight is decreased
    in proportion to the cosine of the angle between the vector from the light to
    the surface location (the negation of the variable `s`) and the direction of the
    spotlight. That cosine term is then raised to the power of the variable `Exponent`.
    The larger the value of this variable, the faster the intensity of the spotlight
    is decreased. This is similar to the exponent in the specular shading term.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exponent`字段定义了在计算聚光灯的角衰减时使用的指数。聚光灯的强度与从光源到表面位置的向量（变量`s`的负值）与聚光灯方向之间的角度余弦成正比。然后将余弦项提升到变量`Exponent`的幂。此变量的值越大，聚光灯的强度衰减越快。这与镜面着色项中的指数类似。'
- en: The `Cutoff` field defines the angle between the central axis and the outer
    edge of the spotlight's cone of light. We specify this angle in radians.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cutoff`字段定义了聚光灯光锥中心轴与外边缘之间的角度。我们以弧度为单位指定此角度。'
- en: The `blinnPhongSpot` function computes the Blinn-Phong reflection model, using
    a spotlight as the light source. The first line computes the ambient lighting
    component and stores it in the `ambient` variable.  The second line computes the
    vector from the surface location to the spotlight's position (`s`).  Next, we
    compute the dot product between the direction from the spotlight to the surface
    point (`-s`) and the direction of the spotlight and store the result in `cosAng`.
    The angle between them is then computed and stored in the variable `angle`.   The
    variable `spotScale` will be used to scale the value of the spotlight's diffuse/specular
    intensity.  It is initially set to zero.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`blinnPhongSpot`函数计算Blinn-Phong反射模型，使用聚光灯作为光源。第一行计算环境光照分量并将其存储在`ambient`变量中。第二行计算从表面位置到聚光灯位置的向量（`s`）。接下来，我们计算从聚光灯到表面点的方向（`-s`）与聚光灯方向的点积，并将结果存储在`cosAng`中。然后计算它们之间的角度并将其存储在变量`angle`中。变量`spotScale`将用于缩放聚光灯的漫反射/镜面强度值。它最初设置为0。'
- en: We then compare the value of the `angle` variable with that of the `Spot.Cutoff`
    variable. If `angle` is greater than zero and less than `Spot.Cutoff`, then the
    surface point is within the spotlight's cone. Otherwise, the surface point only
    receives ambient light, so we skip the rest and return only the ambient component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将`angle`变量的值与`Spot.Cutoff`变量的值进行比较。如果`angle`大于零且小于`Spot.Cutoff`，则表面点位于聚光灯的锥体内。否则，表面点仅接收环境光，因此我们跳过其余部分并仅返回环境分量。
- en: If `angle` is less than `Spot.Cutoff`, we compute the `spotScale` value by raising
    the dot product of `-s` and `spotDir` to the power of `Spot.Exponent`. The value
    of `spotScale` is used to scale the intensity of the light so that the light is
    maximal in the center of the cone, and decreases as you move toward the edges.
    Finally, the Blinn-Phong reflection model is computed as usual.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`angle`小于`Spot.Cutoff`，我们通过将`-s`和`spotDir`的点积提升到`Spot.Exponent`的幂来计算`spotScale`值。`spotScale`的值用于缩放光强度，使得光在锥体的中心最大，并向边缘移动时逐渐减小。最后，像往常一样计算Blinn-Phong反射模型。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `Chapter04/scenespot.cpp` file in the example code
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`Chapter04/scenespot.cpp`文件
- en: The *Using per-fragment shading for improved realism* recipe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The Using per-fragment shading for improved realism recipe
- en: The T*he Blinn-Phong reflection model *recipe
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The Blinn-Phong reflection model recipe
- en: Creating a cartoon shading effect
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建卡通着色效果
- en: '**Toon shading** (also called **cel shading**) is a non-photorealistic rendering
    technique that is intended to mimic the style of shading often used in hand-drawn
    animation. There are many different techniques that are used to produce this effect.
    In this recipe, we''ll use a very simple technique that involves a slight modification
    to the ambient and diffuse shading model.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**卡通着色**（也称为**赛璐珞着色**）是一种非真实感渲染技术，旨在模仿手绘动画中常用的着色风格。有许多不同的技术被用来产生这种效果。在这个配方中，我们将使用一个非常简单的技术，它涉及到对环境光和漫反射着色模型的轻微修改。'
- en: 'The basic effect is to have large areas of constant color with sharp transitions
    between them. This simulates the way that an artist might shade an object using
    strokes of a pen or brush. The following image shows an example of a teapot and
    torus rendered with toon shading:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本效果是在大面积的恒定颜色之间有尖锐的过渡。这模拟了艺术家使用笔或刷的笔触来着色物体的方式。以下图像显示了使用卡通着色渲染的茶壶和环面示例：
- en: '![](img/bb29d75e-b189-4725-a38d-4fe472d02af9.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb29d75e-b189-4725-a38d-4fe472d02af9.png)'
- en: 'The technique presented here involves computing only the ambient and diffuse
    components of the typical ADS shading model, and quantizing the cosine term of
    the diffuse component. In other words, the value of the dot product normally used
    in the diffuse term is restricted to a fixed number of possible values. The following
    table illustrates the concept for four levels:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的技术只涉及计算典型ADS着色模型的周围和漫反射分量，并对漫反射分量的余弦项进行量化。换句话说，通常在漫反射项中使用的点积值被限制在固定数量的可能值中。以下表格说明了四个级别的概念：
- en: '| **Cosine of the angle between s and n** | **Value used** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **s 和 n 之间角度的余弦值** | **使用的值** |'
- en: '| Between 1 and 0.75 | 0.75 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 介于 1 和 0.75 之间 | 0.75 |'
- en: '| Between 0.75 and 0.5 | 0.5 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 介于 0.75 和 0.5 之间 | 0.5 |'
- en: '| Between 0.5 and 0.25 | 0.25 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 介于 0.5 和 0.25 之间 | 0.25 |'
- en: '| Between 0.25 and 0.0 | 0.0 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 介于 0.25 和 0.0 之间 | 0.0 |'
- en: In the preceding table, **s** is the vector toward the light source and **n**
    is the normal vector at the surface. By restricting the value of the cosine term
    in this way, the shading displays strong discontinuities from one level to another
    (see the preceding image), simulating the pen strokes of hand-drawn cel animation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个表格中，**s** 是指向光源的向量，**n** 是表面的法向量。通过这种方式限制余弦项的值，着色在从一级到另一级之间显示出强烈的间断（参见前一个图像），模拟手绘细胞动画的笔触。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with the same vertex shader from the *Using per-fragment shading for improved
    realism* recipe. Your OpenGL program must set the values for all uniform variables
    defined in that vertex shader as well as the fragment shader code described here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *使用片段着色提高真实感* 菜单中的相同顶点着色器开始。您的OpenGL程序必须设置该顶点着色器中定义的所有统一变量的值，以及这里描述的片段着色器代码。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that produces a toon shading effect, use the following
    fragment shader:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建产生卡通着色效果的着色器程序，请使用以下片段着色器：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The constant variable, `levels`, defines how many distinct values will be used
    in the diffuse calculation. This could also be defined as a uniform variable to
    allow for configuration from the main OpenGL application. We will use this variable
    to quantize the value of the cosine term in the diffuse calculation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 常量变量 `levels` 定义了在漫反射计算中将使用多少个不同的值。这也可以定义为统一变量，以便从主OpenGL应用程序中进行配置。我们将使用此变量来量化漫反射计算中余弦项的值。
- en: The `toonShade` function is the most significant part of this shader. We start
    by computing `s`, the vector toward the light source. Next, we compute the cosine
    term of the diffuse component by evaluating the dot product of `s` and `Normal`.
    The next line quantizes that value in the following way. Since the two vectors
    are normalized, and we have removed negative values with the `max` function, we
    are sure that the value of cosine is between zero and one. By multiplying this
    value by `levels` and taking the `floor`, the result will be an integer between
    `0` and `levels -1`. When we divide that value by levels (by multiplying by `scaleFactor`),
    we scale these integral values to be between zero and one again. The result is
    a value that can be one of `levels` possible values spaced between zero and one.
    This result is then multiplied by `Material.Kd`, the diffuse reflectivity term.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`toonShade` 函数是此着色器中最重要的一部分。我们首先计算 **s**，即指向光源的向量。接下来，我们通过评估 `s` 和 `Normal`
    的点积来计算漫反射分量的余弦项。下一行以以下方式量化该值。由于两个向量都是归一化的，并且我们使用 `max` 函数去除了负值，所以我们确信余弦值的范围在零到一之间。通过将此值乘以
    `levels` 并取 `floor`，结果将是一个介于 `0` 和 `levels -1` 之间的整数。当我们除以 levels（通过乘以 `scaleFactor`）时，我们将这些整数值缩放到零到一之间。结果是可以在零和一之间均匀分布的
    `levels` 个可能值之一。然后将此结果乘以 `Material.Kd`，即漫反射反射率项。'
- en: Finally, we combine the diffuse and ambient components together to get the final
    color for the fragment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将漫反射和周围分量组合起来，以获得片段的最终颜色。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: When quantizing the cosine term, we could have used `ceil` instead of `floor`.
    Doing so would have simply shifted each of the possible values up by one level.
    This would make the levels of shading slightly brighter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在量化余弦项时，我们本可以使用 `ceil` 而不是 `floor`。这样做将简单地将每个可能值向上移动一个级别。这将使着色级别稍微亮一些。
- en: The typical cartoon style seen in most cel animation includes black outlines
    around the silhouettes and along other edges of a shape. The shading model presented
    here does not produce those black outlines. There are several techniques for producing
    them, and we'll look at one later on in this book.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数细胞动画中常见的典型卡通风格包括围绕轮廓和形状其他边缘的黑轮廓。这里提出的着色模型不会产生这些黑轮廓。有几种产生它们的技术，我们将在本书稍后部分查看其中一种。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter04/scenetoon.cpp` file in the example code
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter04/scenetoon.cpp` 文件
- en: The *Using per-fragment shading for improved realism* recipe
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用片段着色提高真实感* 的配方'
- en: '*The Blinn-Phong reflection model* recipe'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Blinn-Phong 反射模型* 的配方'
- en: The *Drawing silhouette lines using the geometry shader* recipe in [Chapter
    6](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml), *Image Processing and Screen Space
    Techniques*
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 6 章 [Chapter 6](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml)，*图像处理和屏幕空间技术*
    中，*使用几何着色器绘制轮廓线* 的配方
- en: Simulating fog
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟雾
- en: A simple fog effect can be achieved by mixing the color of each fragment with
    a constant fog color. The amount of influence of the fog color is determined by
    the distance from the camera. We could use either a linear relationship between
    the distance and the amount of fog color, or we could use a non-linear relationship
    such as an exponential one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将每个片段的颜色与一个恒定的雾色混合，可以简单地实现雾效。雾色的影响程度由与摄像机的距离决定。我们可以使用距离和雾色量之间的线性关系，或者使用指数等非线性关系。
- en: 'The following image shows four teapots rendered with a fog effect produced
    by mixing the fog color in a linear relationship with distance:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用与距离成线性关系的雾色混合产生的雾效渲染的四个茶壶：
- en: '![](img/6b0c4b37-0dad-4535-857b-89e982167b2c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b0c4b37-0dad-4535-857b-89e982167b2c.png)'
- en: 'To define this linear relationship, we can use the following equation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义这种线性关系，我们可以使用以下方程：
- en: '![](img/07b17663-7f06-4f6b-8202-d51e3b7fff74.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07b17663-7f06-4f6b-8202-d51e3b7fff74.png)'
- en: In the preceding equation, *d[min]* is the distance from the eye where the fog
    is minimal (no fog contribution), and *d[max]* is the distance where the fog color
    obscures all other colors in the scene. The variable *z* represents the distance
    from the eye. The value *f* is the fog factor. A fog factor of zero represents
    100% fog, and a factor of one represents no fog. Since fog typically looks thickest
    at longer distances, the fog factor is minimal when *|z|* is equal to *d[max]*,
    and maximal when *|z|* is equal to *d[min]*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，*d[min]* 是雾最少的（没有雾贡献）眼睛距离，*d[max]* 是雾色掩盖场景中所有其他颜色的距离。变量 *z* 代表眼睛的距离。值
    *f* 是雾因子。雾因子为零表示 100% 雾，因子为一表示没有雾。由于雾通常在更长的距离上看起来最浓，因此当 *|z|* 等于 *d[max]* 时，雾因子最小，当
    *|z|* 等于 *d[min]* 时，雾因子最大。
- en: Since the fog is applied by the fragment shader, the effect will only be visible
    on the objects that are rendered. It will not appear on any *empty* space in the
    scene (the background). To help make the fog effect consistent, you should use
    a background color that matches the maximum fog color.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于雾是通过片段着色器应用的，因此效果只会在渲染的对象上可见。它不会出现在场景中的任何 *空* 空间（背景）中。为了帮助使雾效保持一致，您应使用与最大雾色相匹配的背景色。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with the same vertex shader from the *Using per-fragment shading for improved
    realism* recipe. Your OpenGL program must set the values for all uniform variables
    defined in that vertex shader as well as the fragment shader shown in the following
    section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *使用片段着色提高真实感* 配方中的相同顶点着色器开始。您的 OpenGL 程序必须设置该顶点着色器以及以下部分中显示的片段着色器中定义的所有统一变量的值。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To create a shader that produces a fog-like effect, use the following code
    for the fragment shader:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个产生类似雾效的着色器，请使用以下代码作为片段着色器：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this shader, the `blinnPhong` function is exactly the same as the one used
    in *The Blinn-Phong reflection model* recipe*.* The part of this shader that deals
    with the fog effect lies within the `main` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个着色器中，`blinnPhong` 函数与 *Blinn-Phong 反射模型* 配方中使用的完全相同。*处理雾效的部分位于 `main` 函数中。
- en: The uniform variable `Fog` contains the parameters that define the extent and
    color of the fog. The `MinDist` field is the distance from the eye to the fog's
    starting point, and `MaxDist` is the distance to the point where the fog is maximal.
    The `Color` field is the color of the fog.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀变量`Fog`包含定义雾的广度和颜色的参数。`MinDist`字段是眼睛到雾的起始点的距离，而`MaxDist`是雾最大时的距离。`Color`字段是雾的颜色。
- en: The `dist` variable is used to store the distance from the surface point to
    the eye position. The `z` coordinate of the position is used as an estimate of
    the actual distance. The `fogFactor` variable is computed using the preceding
    equation. Since `dist` may not be between `Fog.MinDist` and `Fog.MaxDist`, we
    clamp the value of `fogFactor` to be between zero and one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist`变量用于存储表面点到眼睛位置的距离。位置`z`坐标被用作实际距离的估计。`fogFactor`变量使用前面的方程计算。由于`dist`可能不在`Fog.MinDist`和`Fog.MaxDist`之间，我们将`fogFactor`的值夹在零和一之间。'
- en: We then call the `blinnPhong` function to evaluate the reflection model. The
    result of this is stored in the `shadeColor` variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`blinnPhong`函数来评估反射模型。这个结果存储在`shadeColor`变量中。
- en: Finally, we mix `shadeColor` and `Fog.Color` together based on the value of
    `fogFactor`, and the result is used as the fragment color.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据`fogFactor`的值将`shadeColor`和`Fog.Color`混合在一起，并将结果用作片段颜色。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this recipe, we used a linear relationship between the amount of fog color
    and the distance from the eye. Another choice would be to use an exponential relationship.
    For example, the following equation could be used:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了雾颜色与眼睛距离之间的线性关系。另一种选择是使用指数关系。例如，以下方程可以用来：
- en: '![](img/1cda3161-457c-4eba-bd09-0bece84dc867.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cda3161-457c-4eba-bd09-0bece84dc867.png)'
- en: In the above equation, *d* represents the density of the fog. Larger values
    would create *thicker* fog. We could also square the exponent to create a slightly
    different relationship (a faster increase in the fog with distance).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方程中，*d*代表雾的密度。较大的值会创建*更浓*的雾。我们还可以将指数平方，以创建一个稍微不同的关系（随着距离的增加，雾的增长更快）。
- en: '![](img/279083d8-41b2-498f-8d5d-754c37e4a2db.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/279083d8-41b2-498f-8d5d-754c37e4a2db.png)'
- en: Computing distance from the eye
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从眼睛计算距离
- en: 'In the preceding code, we used the absolute value of the *z* coordinate as
    the distance from the camera. This may cause the fog to look a bit unrealistic
    in certain situations. To compute a more precise distance, we could replace the
    line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了*z*坐标的绝对值作为从摄像机到距离的估计。这可能会在某些情况下使雾看起来有点不真实。为了计算更精确的距离，我们可以替换以下行：
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, the latter version requires a square root, and therefore would be
    a bit slower in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，后一种版本需要开平方，因此在实践中可能会稍微慢一些。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter04/scenefog.cpp` file in the example code
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter04/scenefog.cpp`文件
- en: '*The Blinn-Phong reflection model* recipe'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Blinn-Phong反射模型*的配方'
- en: A physically-based reflection model
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物理的反射模型
- en: '**Physically-based rendering** or **PBR** is an umbrella term that encompasses
    tools and techniques that make use of physically-based models of light and reflection.
    The term itself is somewhat loosely defined, but can generally be described as
    a shading/reflection model that tries to model the physics of light interacting
    with matter as accurately as possible. The term may mean slightly different things
    to different people, but for our purposes, we are interested primarily in how
    it differs from the Phong and the Blinn-Phong reflection models.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于物理的渲染**或**PBR**是一个总称，它包括利用基于物理的光和反射模型的工具和技术。这个术语本身定义得相当宽松，但可以大致描述为一个着色/反射模型，它试图尽可能准确地模拟光与物质相互作用的物理过程。这个术语对不同的人可能意味着不同的事情，但就我们的目的而言，我们主要感兴趣的是它与Phong和Blinn-Phong反射模型的区别。'
- en: The Blinn-Phong model is an empirical model of reflection based on observation.
    A PBR model could also be considered an empirical model, but in general, it is
    more detailed and accurate with regards to the physics of the interaction being
    represented. The Blinn-Phong model uses a few parameters which are not physically
    based but produce effective results. For example, separating the light intensity
    into three (or two) separate values is not physically accurate (there's only one
    light). However, it provides many "tuneable" parameters to the artist to work
    with, giving them the flexibility to achieve the desired look.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Blinn-Phong模型是一种基于观察的反射经验模型。PBR模型也可以被视为一种经验模型，但通常来说，它在表示交互的物理方面更为详细和准确。Blinn-Phong模型使用了一些并非基于物理的参数，但能产生有效结果。例如，将光强度分为三个（或两个）单独的值在物理上并不准确（只有一个光源）。然而，它为艺术家提供了许多“可调”参数来工作，使他们能够达到期望的外观。
- en: In recent years, PBR techniques have gained favor due to the fact that they
    reduce the number of tuneable parameters, and provide more consistent results
    across a wide variety of materials. Artists have found that previous models (non-PBR)
    have a tendency to be tricky to "get right." When a scene consists of a wide variety
    of materials, the parameters may require a significant amount of "tweaking" to
    make consistent. With PBR-based techniques, the reflection models try to represent
    the physics more accurately, which tends to make things look more consistent under
    a wide variety of lighting settings, reducing the amount of fine-tuning required
    by artists.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，由于PBR技术减少了可调参数的数量，并在广泛的材料上提供更一致的结果，因此受到了青睐。艺术家们发现，之前的模型（非PBR）往往难以“正确”实现。当场景由多种材料组成时，参数可能需要大量的“调整”才能保持一致。基于PBR的技术试图更准确地表示物理，这往往使得在广泛的照明设置下看起来更一致，从而减少了艺术家所需的微调量。
- en: 'In this recipe, we''ll implement a basic PBR-based reflection model using point
    light sources. Before we get started, however, let''s go over the math. In the
    following equations, we''ll use the vectors *n*, *l*, *v*, and *h*, defined as
    follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将实现一个基于点光源的基本PBR反射模型。然而，在我们开始之前，让我们回顾一下数学。在以下方程中，我们将使用向量*n*，*l*，*v*和*h*，它们如下定义：
- en: '*n*: The surface normal'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*: 表面法线'
- en: '*l*: The vector representing the direction of incoming light'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*: 表示入射光方向的向量'
- en: '*v*: The direction toward the viewer (camera)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*v*: 指向观察者（摄像机）的方向'
- en: '*h*: The vector halfway between *l* and *v* (as in the Blinn-Phong model)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*h*: 位于*l*和*v*之间的向量（如在Blinn-Phong模型中）'
- en: 'A popular mathematical model for describing how light scatters from a surface
    is called **the reflectance equation** (a special case of the **rendering equation**),
    and has the following form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 描述光线从表面散射的流行数学模型被称为**反射方程**（渲染方程的特殊情况），其形式如下：
- en: '![](img/d20ce6f4-de33-4c14-a99d-21854e83d95a.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d20ce6f4-de33-4c14-a99d-21854e83d95a.png)'
- en: This integral might look a bit scary, but basically, it means the following.
    The amount of outgoing radiance from a surface (*L[o]*) toward the viewer (*v*),
    is equal to the integral (think weighted-sum) of the BRDF (*f*) times the amount
    of incoming radiance (*L[i]*). The integral is over the hemisphere above the surface,
    for all incoming light directions (*l*) within that hemisphere weighted by a cosine
    factor (*n · l*). This cosine factor is a weight that essentially represents the
    geometry of the situation. The more directly that the light hits the surface,
    the higher it is weighted.  A more complete derivation of this equation is available
    in several texts. In this recipe, we'll simplify this integral to a simple sum,
    assuming that the only sources of incoming radiance are point light sources. This
    is of course a huge simplification, we'll consider some techniques to evaluate
    the integral more accurately later.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分可能看起来有点吓人，但基本上，它意味着以下内容。从表面（*L[o]*）向观察者（*v*）发出的辐射量等于BRDF（*f*）乘以入射辐射量（*L[i]*）的积分（可以认为是加权求和）。积分是在表面上方的半球内进行的，对于半球内的所有入射光方向（*l*），通过余弦因子（*n
    · l*）加权。这个余弦因子是一个权重，本质上代表了情况的几何形状。光线越直接地击中表面，其权重就越高。关于这个方程的更完整推导可以在几篇文献中找到。在这个配方中，我们将这个积分简化为一个简单的总和，假设唯一的入射辐射源是点光源。这当然是一个巨大的简化，我们将在稍后考虑一些更精确评估积分的技术。
- en: 'The most significant term for us is the BRDF term (*f*), which stands for bidirectional
    reflectance distribution function. It represents the fraction of radiance that
    is reflected from a surface point, given the incoming direction (*l*) and the
    outgoing direction (*v*). Its value is a spectral value (R,G,B), with components
    ranging from 0 to 1\. In this recipe, we''ll model the BRDF as a sum of two parts:
    the diffuse BRDF and the specular BRDF:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，最重要的项是BRDF项（*f*），它代表双向反射分布函数。它表示从表面点反射的光照度比例，给定入射方向（*l*）和出射方向（*v*）。它的值是一个光谱值（R,G,B），其分量范围从0到1。在这个配方中，我们将BRDF建模为两部分之和：散射BRDF和镜面BRDF：
- en: '![](img/b20db239-6f3d-4e4a-a2d6-316d82f14ce0.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b20db239-6f3d-4e4a-a2d6-316d82f14ce0.png)'
- en: 'The diffuse BRDF represents light that is absorbed into the surface slightly
    and then is re-radiated. It is common to model this term so that the radiated
    light has no preferred direction. It is radiated equally in all outgoing directions.
    This is also called **Lambertian reflectance**. Since it has no dependence on
    the incoming or outgoing directions, the Lambertian BRDF is simply a constant
    value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 散射BRDF代表稍微吸收到表面然后重新辐射的光线。通常，建模这个项时，辐射光线没有特定的方向。它在所有出射方向上均匀辐射。这也被称为**朗伯反射率**。由于它不依赖于入射或出射方向，朗伯BRDF只是一个常数：
- en: '![](img/a41ab085-7009-407b-88d0-588792e10958.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a41ab085-7009-407b-88d0-588792e10958.png)'
- en: The *c*[*dif*f] term represents the fraction of light that is diffusely radiated.
    It is commonly considered the diffuse color of the object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*[*dif*f]项代表散射辐射的光线比例。它通常被认为是物体的散射颜色。'
- en: The specular term represents surface reflectance. Light that is reflected directly
    off the surface of the object without being absorbed. This is also sometimes called
    **glossy reflectance**. A common way to model this reflectance is based on **microfacet
    theory**. This theory was developed to describe reflection from general, non-optically
    flat surfaces. It models the surface as consisting of small facets that are optically
    flat (mirrors) and are oriented in various directions. Only those that are oriented
    correctly to reflect toward the viewer can contribute to the BRDF.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面项代表表面反射率。光线直接从物体表面反射，没有被吸收。这有时也被称为**光泽反射率**。建模这种反射率的一种常见方法是基于**微facet理论**。该理论是为了描述从一般非光学平坦表面的反射而开发的。它将表面建模为由光学平坦（镜子）的小面组成，这些面以各种方向取向。只有那些正确取向以反射向观察者的面才能对BRDF做出贡献。
- en: 'We represent this BRDF as a product of three terms and a correction factor
    (the denominator):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个BRDF表示为三个项和一个校正因子（分母）的乘积：
- en: '![](img/e0141150-3520-47fe-9f9b-d6fda1f7ef8f.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0141150-3520-47fe-9f9b-d6fda1f7ef8f.png)'
- en: I won't go into the details of each of these terms. For more information, check
    out the following *See also* section. Instead, I'll briefly describe each one.
    The *F* term represents **Fresnel reflection**, the fraction of light reflected
    from an optically flat surface. The Fresnel reflectance depends on the angle between
    the normal and the direction of incoming light (angle of incidence). However,
    since we are using microfacet theory, the microfacet surfaces that contribute
    are the ones that have their normal vector parallel to the halfway vector (*h*).
    Therefore, we use the angle between *l* and *h* instead of the angle between *l*
    and *n*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍这些项的细节。更多信息，请参阅以下*也见*部分。相反，我将简要描述每一个。*F*项代表**菲涅耳反射**，从光学平坦表面反射的光线比例。菲涅耳反射率取决于法线与入射光线方向（入射角）之间的角度。然而，由于我们使用微facet理论，贡献的微facet表面是那些其法线向量与中点向量（*h*）平行的表面。因此，我们使用*l*和*h*之间的角度而不是*l*和*n*之间的角度。
- en: 'The Fresnel reflectance also depends on the index of refraction of the surface.
    However, we''ll use an approximation that instead uses a different parameter.
    It is known as the **Schlick approximation**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 菲涅耳反射率也取决于表面的折射率。然而，我们将使用一个不同的参数进行近似。这被称为**Schlick近似**：
- en: '![](img/0e75a16a-b20c-443e-81a6-36baed8510ca.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e75a16a-b20c-443e-81a6-36baed8510ca.png)'
- en: Rather than using the index of refraction, this approximation uses *F[0]*, the
    **characteristic specular reflectance** of the material. Or in other words, the
    reflectance when the angle of incidence is zero degrees. This term is useful in
    that it can be used as a specular "color", which is somewhat more intuitive and
    natural for artists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用折射率指数不同，这个近似使用的是 *F[0]*，材料的**特征镜面反射率**。换句话说，就是入射角为零度时的反射率。这个术语很有用，因为它可以用作镜面“颜色”，这对艺术家来说更加直观和自然。
- en: 'To further understand this *F[0]* term, let''s consider values for common materials.
    It turns out that a material''s optical properties are closely tied to its electrical
    properties. It is therefore helpful to divide materials into three categories:
    dielectrics (insulators), metals (conductors), and semiconductors. Our model will
    ignore the third category and focus on the first two. Metals generally do not
    exhibit any diffuse reflection, because any light that is refracted into the surface
    is completely absorbed by the free electrons. The value for *F[0]* is much larger
    for metals than for dielectrics. In fact, dielectrics have very low values for
    *F[0]*, usually in the range of 0.05 (for all RGB components). This leads us to
    the following technique.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解这个 *F[0]* 术语，让我们考虑常见材料的值。结果证明，材料的光学特性与其电学特性密切相关。因此，将材料分为三类是有帮助的：介电体（绝缘体）、金属（导体）和半导体。我们的模型将忽略第三类，并专注于前两类。金属通常不表现出任何漫反射，因为任何折射到表面的光线都会被自由电子完全吸收。金属的
    *F[0]* 值比介电体大得多。实际上，介电体的 *F[0]* 值非常低，通常在 0.05（对于所有 RGB 成分）的范围内。这导致我们采用以下技术。
- en: We'll associate a color with a material.  If the material is a metal, there's
    no diffuse reflection, so we set *c[diff]* to (0,0,0), and use the color as the
    value for *F[0]* in the Fresnel term. If the material is a dielectric, we set
    *F[0]* to some small value (we'll use (0.04, 0.04, 0.04)), and use the color as
    the value for *c*[*dif*f].  Essentially, we use two slightly different models
    for metals and dielectrics, switching between the two as needed. Rather than using
    the same model for both metals and non-metals and tweaking parameters to represent
    each, we separate them into two different categories each with a slightly different
    BRDF model. The popular term for this is **metalness workflow**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将颜色与材料关联起来。如果材料是金属，则没有漫反射，因此我们将 *c[diff]* 设置为 (0,0,0)，并将颜色作为 Fresnel 项中 *F[0]*
    的值。如果材料是介电体，我们将 *F[0]* 设置为某个小值（我们将使用 (0.04, 0.04, 0.04)），并将颜色作为 *c[*dif*f] 的值。本质上，我们为金属和介电体使用两种略有不同的模型，根据需要在这两种模型之间切换。我们不是使用相同的模型来表示金属和非金属，并调整参数来表示每个，而是将它们分为两个不同的类别，每个类别都有一个略有不同的
    BRDF 模型。这个流行术语被称为**金属度工作流程**。
- en: 'Next, let''s consider the *D* term in the specular BRDF. This is the **microgeometry normal
    distribution function** (or **microfacet distribution function**). It describes
    the statistical distribution of microsurface orientations. It has a scalar value,
    and gives the relative concentration of microfacet normals in the direction *h*.
    This term has a strong effect on the size and shape of the specular highlight.
    There are many choices for this function, and several have been developed in recent
    years based on physical measurements. We''ll use a popular one from graphics researchers
    Trowbridge and Reitz, which was also given the name **GGX** by a separate research
    team:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑镜面 BRDF 中的 *D* 项。这是**微观几何法线分布函数**（或**微观面分布函数**）。它描述了微观表面方向的统计分布。它有一个标量值，并给出在方向
    *h* 上的微观面法线的相对浓度。这个术语对镜面高光的大小和形状有很强的影响。这个函数有多个选择，近年来基于物理测量已经开发出几个。我们将使用图形研究人员
    Trowbridge 和 Reitz 中的一个流行的函数，一个独立的研究团队也将其命名为 **GGX**：
- en: '![](img/dddc6f0b-994a-47a0-a13d-f9a2c0911f0d.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dddc6f0b-994a-47a0-a13d-f9a2c0911f0d.png)'
- en: In this equation, *α* is a term that represents the roughness of the surface.
    Following the lead of others, we'll use a roughness parameter *r*, and set *α*
    to *r²*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*α* 是表示表面粗糙度的术语。遵循他人的做法，我们将使用粗糙度参数 *r*，并将 *α* 设置为 *r²*。
- en: 'Finally, we''ll consider the *G* term in the specular BRDF. This is the geometry
    function and describes the probability that microsurfaces with a given normal
    will be visible from both the light direction (*l*) and the view direction (*v*).
    Its value is a scalar between 0 and 1\. It is essential for energy conservation.
    We''ll use the following model for *G*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76ffd085-ba46-4971-bf52-cd85f7efd28e.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9f23ea1-19c9-4a9a-b121-25a9f51278da.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'The constant *k* is a value that is proportional to the roughness. Again, following
    the lead of others (see the following *See also*), we''ll use the following for
    *k*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/683b8189-6ac5-4a4d-8b40-adceb0dcd1aa.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Putting all of this together, we now have a complete representation for our
    BRDF. Before jumping into the code, let''s revisit the reflectance equation. This
    is the first equation we discussed, containing an integral over all directions
    over the hemisphere above the surface. It would be too costly to try to evaluate
    this integral in an interactive application, so we''ll simplify it by making the
    assumption that all incoming light comes directly from point light sources. If
    we do so, the integral reduces to the following sum:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80aec644-d2b9-416d-a8d4-78cad56e4ed8.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'Where *N* is the number of point light sources, *L[i]* is the illumination
    received at the surface due to *i*^(th) light source and *l[i]* is the direction
    toward the *i*^(th) light source. Since the intensity of light decreases with
    distance, we''ll use an inverse-square relationship. However, other models could
    be used here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbb3e979-8b22-408e-b048-292c48471ad0.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: '*I[i]* is the intensity of the source and *d[i]* is the distance from the surface
    point to the light source.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a complete microfacet-based model that can be applied for metallic
    surfaces and dielectrics. As we covered earlier, we''ll modify the BRDF slightly
    depending on whether we are working with a metal or a dielectric. The number of
    parameters to this BRDF is relatively small. The following parameters will define
    a material:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The surface roughness (*r*), a value between 0 and 1
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the material is metallic (Boolean)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A color which is interpreted as the diffuse color for dielectrics, or the characteristic
    specular reflectance (*F[0]*) for metals
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parameters are quite intuitive and understandable, as opposed to the many
    parameters in the Blinn-Phong model from the previous recipe. There's just one
    color, and roughness is a more intuitive concept than the specular exponent.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll set up our shader by starting with the shader pair from the Blinn-Phong
    recipe, but we'll change the fragment shader. Let's set up some uniforms for the
    light and material information.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'For the light sources, we just need a position and an intensity:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For materials, we need the three values mentioned previously:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll define a function for each of the three terms in the specular BRDF.
    Use the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function for the Fresnel term using the Schlick approximation:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Schlick 近似定义一个用于菲涅耳项的函数：
- en: '[PRE13]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define a function for the geometry term *G*:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于几何项 *G* 的函数：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The normal distribution function *D*, based on GGX/Trowbridge-Reitz:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于 GGX/Trowbridge-Reitz 的法线分布函数 *D*：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll now define a function that computes the entire model for a single light
    source:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将定义一个函数，用于计算单个光源的整个模型：
- en: '[PRE16]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We put this all together by summing over the light sources, applying Gamma
    correction, and writing out the result:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过求和光源、应用伽马校正并写出结果来将这些内容全部整合在一起：
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `schlickFresnel` function computes the value of *F*.  If the material is
    a metal, the value for *F[0]* is taken from the value of `Material.Color`. Otherwise,
    we simply use (0.04, 0.04, 0.04). Since most dielectrics have similar small values
    for *F[0]*, this is a relatively good approximation for common dielectrics.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`schlickFresnel` 函数计算 *F* 的值。如果材料是金属，则 *F[0]* 的值取自 `Material.Color` 的值。否则，我们简单地使用
    (0.04, 0.04, 0.04)。由于大多数介电体具有相似的较小的 *F[0]* 值，这对于常见的介电体来说是一个相对较好的近似。'
- en: The `geomSmith` and `ggxDistribution` functions are straightforward implementations
    of the equations described previously. However, in `geomSmith`, we omit the numerator.
    This is due to the fact that it will cancel with the denominator of the overall
    specular BRDF.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`geomSmith` 和 `ggxDistribution` 函数是之前描述的方程的直接实现。然而，在 `geomSmith` 中，我们省略了分子。这是因为它将与整体镜面
    BRDF 的分母相抵消。'
- en: The `microfacetModel` function computes the BRDF. The `diffuse` term is set
    to `0` if the material is metallic, otherwise, it is set to the value of the material's
    color. Note that we omit the factor of *π* here. This is due to the fact that
    it will cancel with the *π* term in the overall sum (the last summation equation),
    so no need to include it here.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`microfacetModel` 函数计算 BRDF。如果材料是金属的，则将 `diffuse` 项设置为 `0`，否则设置为材料颜色的值。注意，我们在这里省略了
    *π* 因子。这是因为它将与整体求和（最后一个求和方程）中的 *π* 项相抵消，因此在这里不需要包括它。'
- en: Next, we determine the *L[i]* term (`lightI`) and the vector *l*, depending
    on whether it is a directional light or a positional one. If it is directional,
    `lightI` is just the value of `Light[lightIdx].L`, otherwise, it is scaled by
    the inverse square of the distance to the light source.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据是否是方向光或位置光来确定 *L[i]* 项（`lightI`）和向量 *l*。如果是方向光，`lightI` 就是 `Light[lightIdx].L`
    的值，否则，它将按光源距离的平方倒数进行缩放。
- en: Then, we calculate the specular BRDF (`specBrdf`), using the functions we defined
    previously. Note that (as mentioned previously) we omit the denominator of the
    BRDF (except for the factor of 0.25) due to the fact that those two dot products
    cancel with the numerators of the *G[1]* functions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用之前定义的函数计算镜面 BRDF (`specBrdf`）。注意（如前所述），我们省略了 BRDF 的分母（除了 0.25 的因子），因为这些两个点积与
    *G[1]* 函数的分子相抵消。
- en: The final result of this function is the total BRDF times the light intensity,
    times the dot product of *n* and *l*. We only multiply the specular BRDF times
    *π* due to the fact that we omitted the *π* term from the diffuse BRDF.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的最终结果是总 BRDF 乘以光强度，乘以 *n* 和 *l* 的点积。我们只乘以镜面 BRDF 乘以 *π*，因为我们省略了漫反射 BRDF 中的
    *π* 项。
- en: 'Results for some simple materials are shown in the following image:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单材料的结果显示在下图中：
- en: '![](img/9e6a3e0a-0c24-4a2a-b78c-6cc4214bcede.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e6a3e0a-0c24-4a2a-b78c-6cc4214bcede.png)'
- en: The back row shows dielectric (non-metal) materials with increasing roughness
    from left to right.   The front row shows five metallic materials with various
    values for *F[0]*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 后排展示了从左到右粗糙度逐渐增加的介电（非金属）材料。前排展示了五种具有不同 *F[0]* 值的金属材料。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Rather than making `Material.Metal` a Boolean value, one could choose to make
    it a continuous value between 0 and 1.  Indeed, this is exactly what some implementations
    do. The value would then be used to interpolate between the two models (metallic
    and dielectric). However, that makes the parameter somewhat less intuitive for
    artists and you may find that the extra configurability may not be all that useful.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将 `Material.Metal` 作为布尔值，可以选择将其设置为介于 0 和 1 之间的连续值。实际上，这正是某些实现所做的那样。然后，该值将用于在两种模型（金属和介电）之间进行插值。然而，这使得参数对于艺术家来说不太直观，你可能会发现额外的可配置性并不那么有用。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter04/scenepbr.cpp` file in the example code
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter04/scenepbr.cpp` 文件
- en: An excellent explanation of the mathematics behind PBR models and other information
    from the SIGGRAPH 2013 conference at [http://blog.selfshadow.com/publications/s2013-shading-course/](http://blog.selfshadow.com/publications/s2013-shading-course/)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对PBR模型背后的数学原理以及来自SIGGRAPH 2013会议的其他信息的出色解释，请参阅[http://blog.selfshadow.com/publications/s2013-shading-course/](http://blog.selfshadow.com/publications/s2013-shading-course/)
- en: 'The *wonderful* book: *Physically Based Rendering* by Pharr, Jakob, and Humphreys,
    currently in its third edition'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本*精彩的*书籍：《基于物理的渲染》（Physically Based Rendering），作者为Pharr, Jakob, 和 Humphreys，目前为第三版
