["```cpp\n//SplashStageBuilder.h-------------------- \n#include \"M5StageBuilder.h\" \n\nclass SplashStageBuilder: public M5StageBuilder \n{ \npublic: \n  virtual M5Stage* Build(void); \n}; \n\n//SplashStageBuilder.cpp-------------------- \n#include \"SplashStageBuilder.h\" \n#include \"SplashStage.h\" \n\nM5Stage* SplashStageBuilder::Build(void) \n{ \n  return new SplashStage(); \n} \n\n```", "```cpp\n//M5StageBuilder.h \nclass M5StageBuilder \n{ \npublic: \n  virtual ~M5StageBuilder(void) {} //empty virtual destructor \n  virtual M5Stage* Build(void) = 0; \n}; \n\ntemplate <typename T> \nclass M5StageTBuilder: public M5StageBuilder \n{ \npublic: \n  virtual M5Stage* Build(void); \n}; \n\ntemplate <typename T> \nM5Stage* M5StageTBuilder<T>::Build(void) \n{ \n  return new T(); \n} \n\n```", "```cpp\n//PlayerBuilder.h-------------------- \n#include \"M5ObjectBuilder.h\" \n\nclass PlayerBuilder: public M5ObjectBuilder \n{ \npublic: \nvirtual M5Object* Build(void); \n}; \n\n//PlayerBuilder.cpp-------------------- \n#include \"PlayerBuilder.h\" \n#include \"M5Object.h\" \n#include \"M5ObjectManager.h\" \n\nM5Object* PlayerBuilder::Build(void) \n{ \nM5Object* pObj = new M5Object; \n//Build and set Gfx component for player \nGfxComponent* pGfx = \n   M5ObjectManager::CreateComponent(CT_GfxComponent); \npGfx->SetTexture(\"playerShip.tga\"); \npGfx->SetDrawSpace(DS_WORLD); \n\n//Build and set input component for player \nPlayerInputComponent* pPI = \n   M5ObjectManager::CreateComponent(CT_PlayerInputComponent); \npPI->SetSpeed(100); \npPI->SetRotationSpeed(10); \n\npObj->AddComponent(pGfx); \npObj->AddComponent(pPI); \n\n//...add more components here \n\nreturn pObj; \n} \n\n//RaiderBuilder.h-------------------- \n#include \"M5ObjectBuilder.h\" \n\nclass RaiderBuilder: public M5ObjectBuilder \n{ \npublic: \nvirtual M5Object* Build(void); \n}; \n\n// RaiderBuilder.cpp-------------------- \n#include \"RaiderBuilder.h\" \n#include \"M5Object.h\" \n#include \"M5ObjectManager.h\" \n\nM5Object* RaiderBuilder::Build(void) \n{ \n  M5Object* pObj = new M5Object; \n  //Build and set Gfx component for Raider \n  GfxComponent* pGfx = \n     M5ObjectManager::CreateComponent(CT_GfxComponent); \n  pGfx->SetTexture(\"enemyBlack3.tga\"); \n  pGfx->SetDrawSpace(DS_WORLD); \n\n  //Build and set behavior for Raider \n  ChasePlayerComponent* pCP = \n     M5ObjectManager::CreateComponent(CT_ChasePlayerComponent); \n  pPI->SetSpeed(40); \n\n  pObj->AddComponent(pGfx); \n  pObj->AddComponent(pCP); \n\nreturn pObj; \n} \n\n```", "```cpp\nclass Shape \n{ \npublic: \n  virtual ~Shape(void) {}//empty base class constructor \n  virtual void Draw(void) const    = 0; \n  virtual Shape* Clone(void) const = 0; \n}; \n\n```", "```cpp\nclass Circle : public Shape \n{ \npublic: \n  virtual void Draw(void) const \n  { \n    std::cout << \"I'm a Circle\" << std::endl; \n  } \n  virtual Shape* Clone(void) const \n  { \n    return new Circle(*this); \n  } \n}; \n\nclass Square : public Shape \n{ \npublic: \n  virtual void Draw(void) const \n  { \n    std::cout << \"I'm a Square\" << std::endl; \n  } \n  virtual Shape* Clone(void) const \n  { \n    return new Square(*this); \n  } \n}; \n\nclass Triangle : public Shape \n{ \npublic: \n  virtual void Draw(void) const \n  { \n    std::cout << \"I'm a Triangle\" << std::endl; \n  } \n  virtual Shape* Clone(void) const \n  { \n    return new Triangle(*this); \n  } \n}; \n\n```", "```cpp\nint main(void) \n{ \n  //seed the RNG \n  std::srand(static_cast<unsigned>(time(0))); \n  //Create my shapes \n  const int MAX = 3; \n  Shape* shapes[MAX] = { new Circle(),  \n                          new Square(),  \n                          new Triangle() }; \n\n      for (int i = 0; i < MAX * 2; ++i) \n  { \n    Shape* pCopy = shapes[std::rand() % MAX]->Clone(); \n    copy->Draw(); \n    delete pCopy; \n  } \n\n  //make sure to delete my original shapes \n  for (int i = 0; i < MAX; ++i) \n    delete shapes[i]; \n\n  return 0; \n} \n\n```", "```cpp\nI'm a Triangle \nI'm a Square \nI'm a Square \nI'm a Circle \nI'm a Circle \nI'm a Square \n\n```", "```cpp\nBase* p = new Derived; \n\n```", "```cpp\n//This isn't real C++ code \nShape* CreateShape(class theShape) \n{ \n  Shape* pShape = new theShape; \n  return pShape; \n} \n\n```", "```cpp\nclass ShapeSpawner \n{ \npublic: \nShapeSpawner (Shape* pShape, float maxTime): \n  m_pToSpawn(pShape), \n  m_spawnTime(0.f), \n  m_maxSpawnTime(maxTime) \n{ \n  } \nvoid Update(float dt) \n{ \n  m_spawnTime += dt; \n  if(m_spawnTime > m_maxSpawnTime) \n  { \n    //The class doesn't care what type it is cloning \n    Shape* pClone = m_pToSpawn->Clone(); \n\n    //...Register the clone somehow \n\n    //Reset timer   \n    m_spawnTime = 0; \n  } \n} \nprivate: \n  Shape* m_pToSpawn; \n  float  m_spawnTime; \n  float  m_maxSpawnTime; \n}; \n\n```", "```cpp\nclass CircleSpawner \n{ \npublic: \nCircleSpawner (Circle* pCircle, float maxTime): \n  m_pToSpawn(pCircle), \n  m_spawnTime(0.f), \n  m_maxSpawnTime(maxTime) \n{ \n} \n  void Update(float dt) \n{ \n  m_spawnTime += dt; \n  if(m_spawnTime > m_maxSpawnTime) \n  { \n    //Use copy constructor \n Circle* pClone = new Circle(*m_pToSpawn); \n\n    //...Register the clone somehow \n\n    //Reset timer   \n    m_spawnTime = 0; \n  } \n} \nprivate: \n Circle* m_pToSpawn; \n  float   m_spawnTime; \n  float   m_maxSpawnTime; \n}; \n\n```", "```cpp\n//! M5Component.h \nclass M5Component \n{ \npublic: \n//! virtual constructor for M5Component, must override \nvirtual M5Component* Clone(void) const = 0;   \n\n//The rest of the class is the same as before \n}; \n\n```", "```cpp\n//GfxComponent.h \nenum DrawSpace \n{ \n  DS_WORLD, \n  DS_HUD \n}; \n\nclass GfxComponent : public M5Component \n{ \npublic: \n  GfxComponent(void); \n  ~GfxComponent(void); \n  void Draw(void) const; \n  virtual void Update(float dt); \n  virtual GfxComponent* Clone(void) const; \n  virtual void FromFile(M5IniFile& iniFile); \n  void SetTextureID(int id); \n  void SetDrawSpace(DrawSpace drawSpace); \nprivate: \n  int       m_textureID;  //!< Texture id loaded from graphics. \n  DrawSpace m_drawSpace;  //!The space to draw in \n}; \n\n```", "```cpp\nGfxComponent* GfxComponent::Clone(void) const \n{ \n  //Allocates new object and copies data \n  GfxComponent* pNew = new GfxComponent; \n  pNew->m_pObj = m_pObj; \n  pNew->m_textureID = m_textureID; \n  pNew->m_drawSpace = m_drawSpace; \n\n  if (m_drawSpace == DrawSpace::DS_WORLD) \n    M5Gfx::RegisterWorldComponent(pNew); \n  else \n    M5Gfx::RegisterHudComponent(pNew); \n\n  return pNew; \n} \n\n```", "```cpp\nGfxComponent::GfxComponent(void): \n  M5Component(CT_GfxComponent), \n  m_textureID(0), \n  m_drawSpace(DrawSpace::DS_WORLD) \n{ \n} \nGfxComponent::~GfxComponent(void) \n{ \n  M5Gfx::UnregisterComponent(this); \n} \n\n```", "```cpp\n//ColliderComponent.h \nclass ColliderComponent : public M5Component \n{ \npublic: \n  ColliderComponent(void); \n  ~ColliderComponent(void); \n  virtual void Update(float dt); \n  virtual void FromFile(M5IniFile& iniFile); \n  virtual ColliderComponent* Clone(void) const; \n  void TestCollision(const ColliderComponent* pOther); \nprivate: \n  float m_radius; \n}; \n\n```", "```cpp\nColliderComponent* ColliderComponent::Clone(void) const \n{ \n  ColliderComponent* pNew = new ColliderComponent; \n  pNew->m_radius = m_radius; \n  pNew->m_pObj   = m_pObj; \n  M5Phy::RegisterCollider(pNew); \n\n  return pNew; \n} \n\n```", "```cpp\nColliderComponent::ColliderComponent(void) : \n   M5Component(CT_ColliderComponent), m_radius(0) \n{ \n} \nColliderComponent::~ColliderComponent(void) \n{ \n  M5Phy::UnregisterCollider(this); \n} \n\n```", "```cpp\n//M5Object.h \nclass M5Object//Everything is the same as before \n{ \npublic: \n  M5Object*    Clone(void) const; \n}; \n//M5Object.cpp \nM5Object* M5Object::Clone(void) const \n{ \n  //create new object \n  M5Object* pClone = new M5Object(m_type); \n  //copy the internal data \n  pClone->pos         = pos; \n  pClone->vel         = vel; \n  pClone->scale       = scale; \n  pClone->rotation    = rotation; \n  pClone->rotationVel = rotationVel; \n\n  //clone all components \n  size_t size = m_components.size(); \n  for (size_t i = 0; i < size; ++i) \n  { \n    M5Component* pComp = m_components[i]->Clone(); \n    pClone->AddComponent(pComp); \n  } \n  return pClone; \n} \n\n```", "```cpp\n//In M5Object.h \nM5Object(const M5Object& rhs) = delete; \n\n//In M5Component.h \nM5Component(const M5Component& rhs) = delete; \n\n```", "```cpp\nclass Shape \n{ \npublic: \n  virtual ~Shape(void) {}//empty base class constructor \n  virtual void Draw(void) const    = 0; \n  virtual Shape* Clone(void) const = 0; \n}; \n\nclass Circle : public Shape \n{ \npublic: \n  virtual void Draw(void) const; \n  virtual Shape* Clone(void) const; \n}; \n\nint main(void) \n{ \n  Circle* pCircle = new Circle(); \n\n   //The line won't compile \n Circle* pClone = pCircle->Clone(); \n\n  delete pClone; \n  delete pCircle; \n  return 0; \n} \n\n```", "```cpp\n  Circle* pCircle = new Circle(); \n  Shape* pClone  = pCircle->Clone(); \n\n  Circle* pCircle2 = dynamic_cast<Circle*>(pClone); \n  if (pCircle2) \n  { \n    //do something specific to circle \n  } \n\n```", "```cpp\nclass Circle : public Shape \n{ \npublic: \n  virtual void Draw(void) const; \n   //Example of using a covariant return type \n  virtual Circle* Clone(void) const; \n}; \n\nint main(void) \n{ \n  Circle* pCircle = new Circle(); \n  //No need to cast \n  Circle* pClone = pCircle->Clone(); \n\n  //... Do something Circle specific with pClone \n\n  delete pClone; \n  delete pCircle; \n  return 0; \n} \n\n```", "```cpp\nposX       = 0 \nposY       = 0 \nvelX       = 0 \nvelY       = 0 \nscaleX     = 10 \nscaleY     = 10 \nrot        = 0 \nrotVel     = 0 \ncomponents = GfxComponent PlayerInputComponent ColliderComponent \n\n[GfxComponent] \ntexture       = playerShip.tga \ndrawSpace     = world \n\n[PlayerInputComponent] \nforwardSpeed  = 100 \nspeedDamp     = .99 \nbulletSpeed   = 7000 \nrotationSpeed = 10 \n\n[ColliderComponent] \nradius        = 5 \n\n```", "```cpp\nclass M5ObjectManager \n{ \npublic: \n  static M5Object* CreateObject(M5ArcheTypes type); \n  static void AddArcheType(M5ArcheTypes type,  \n                            const char* fileName); \n  static void RemoveArcheType(M5ArcheTypes type); \n\n   //Plus other methods \n\nprivate: \n  typedef M5Factory<M5ComponentTypes,  \n                   M5ComponentBuilder,  \n                   M5Component>  ComponentFactory; \n  typedef std::unordered_map<M5ArcheTypes,  \n                            M5Object*>  ArcheTypeMap \nstatic ComponentFactory  s_componentFactory; \nstatic ArcheTypesMap     s_archetypes; \n\n//Plus other members \n}; \n\n```", "```cpp\nvoid M5ObjectManager::AddArcheType(M5ArcheTypes type, \n   const char* fileName) \n{ \n  MapItor found = s_archetypes.find(type); \n  M5DEBUG_ASSERT(found == s_archeypes.end(), \n     \"Trying to add a prototype that already exists\"); \n\n  M5IniFile file; \n  file.ReadFile(fileName); \n  M5Object* pObj = new M5Object(type); \n  pObj->FromFile(file); \n\n  std::string components;//A string of all my components \n  file.GetValue(\"components\", components); \n\n//parse the component string and create each component \n  std::stringstream ss(components); \n  std::string name; \n\n//Loop through the stream and get each component name \n  while (ss >> name) \n  { \n    M5Component* pComp = s_componentFactory.Build( \n                         StringToComponent(name)); \n    pComp->FromFile(file); \n    pObj->AddComponent(pComp); \n  } \n//Add the prototype to the prototype map \n  s_archeypes.insert(std::make_pair(type, pObj)); \n} \n\n```", "```cpp\nvoid M5ObjectManager::RemoveArcheType(M5ArcheTypes type) \n{ \n  MapItor found = s_archetypes.find(type); \n  M5DEBUG_ASSERT(found != s_archetypes.end(), \n     \"Trying to Remove a prototype that doesn't exist\"); \n\n  delete found->second; \n  found->second = 0; \n  s_archetypes.erase(found); \n} \n\n```", "```cpp\nM5Object* M5ObjectManager::CreateObject(M5ArcheTypes type) \n{ \n  MapItor found = s_archetypes.find(type); \n  M5DEBUG_ASSERT(found != s_archetypes.end(), \n     \"Trying to create and Archetype that doesn't exist\"); \n\n  M5Object* pClone = found->second->Clone(); \n  s_objects.push_back(pClone);//A std::vector<M5Object*> \n  return pClone; \n} \n\n```"]