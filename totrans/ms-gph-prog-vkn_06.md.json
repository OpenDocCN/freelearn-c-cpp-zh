["```cpp\nconst sizet max_meshlets = meshopt_buildMeshletsBound( \n    indices_accessor.count, max_vertices, max_triangles );\n\nArray<meshopt_Meshlet> local_meshlets;\nlocal_meshlets.init( temp_allocator, max_meshlets, \n    max_meshlets );\n\nArray<u32> meshlet_vertex_indices;\nmeshlet_vertex_indices.init( temp_allocator, max_meshlets * \n    max_vertices, max_meshlets* max_vertices );\nArray<u8> meshlet_triangles;\nmeshlet_triangles.init( temp_allocator, max_meshlets * \n    max_triangles * 3, max_meshlets* max_triangles * 3 );\n```", "```cpp\nconst sizet max_vertices = 64;\nconst sizet max_triangles = 124;\nconst f32 cone_weight = 0.0f;\n\nsizet meshlet_count = meshopt_buildMeshlets( \n    local_meshlets.data, \n    meshlet_vertex_indices.data, \n    meshlet_triangles.data, indices, \n    indices_accessor.count, \n    vertices, \n    position_buffer_accessor.count, \n    sizeof( vec3s ), \n    max_vertices, \n    max_triangles, \n    cone_weight );\n```", "```cpp\nstruct meshopt_Meshlet\n{\nunsigned int vertex_offset;\nunsigned int triangle_offset;\n\nunsigned int vertex_count;\nunsigned int triangle_count;\n};\n```", "```cpp\nmeshlet_vertex_data.normal = ( normal + 1.0 ) * 127.0;\nmeshlet_vertex_data.uv_coords = quantize_half( uv_coords );\n```", "```cpp\nfor ( u32 m = 0; m < meshlet_count; ++m ) {\n    meshopt_Meshlet& local_meshlet = local_meshlets[ m ];\n\n    meshopt_Bounds meshlet_bounds = \n    meshopt_computeMeshletBounds( \n    meshlet_vertex_indices.data + \n    local_meshlet.vertex_offset,\n    meshlet_triangles.data +\n    local_meshlet.triangle_offset,\n    local_meshlet.triangle_count,\n    vertices, \n    position_buffer_accessor\n    .count,\n    sizeof( vec3s ) );\n\n    ...\n}\n```", "```cpp\nstruct meshopt_Bounds\n{\n    float center[3];\n    float radius;\n\n    float cone_apex[3];\n    float cone_axis[3];\n    float cone_cutoff;\n\n    signed char cone_axis_s8[3];\n    signed char cone_cutoff_s8;\n};\n```", "```cpp\nvkCmdDrawMeshTasksNV( vk_command_buffer, task_count, \n    first_task );\n```", "```cpp\nvkCmdDrawMeshTasksIndirectCountNV( vk_command_buffer, \n    mesh_draw_buffer, 0, draw_count, stride );\n```", "```cpp\n#extension GL_NV_mesh_shader: require\n```", "```cpp\n#extension GL_ARB_shader_draw_parameters : enable\n```", "```cpp\nlayout(local_size_x = 32) in;\n```", "```cpp\nuint thread_index = gl_LocalInvocationID.x;\nuint group_index = gl_WorkGroupID.x;\nuint meshlet_index = group_index * 32 + thread_index;\n\nuint mesh_instance_index = draw_commands[ gl_DrawIDARB ]\n    .drawId;\n```", "```cpp\nvec4 center = model * vec4(meshlets[mi].center, 1);\nfloat scale = length( model[0] );\nfloat radius = meshlets[mi].radius * scale;\n```", "```cpp\nvec3 cone_axis = mat3( model ) * \n   vec3(int(meshlets[mi].cone_axis[0]) / 127.0, \n   int(meshlets[mi].cone_axis[1]) / 127.0, \n   int(meshlets[mi].cone_axis[2]) / 127.0); \nfloat cone_cutoff = int(meshlets[mi].cone_cutoff) / 127.0;\n```", "```cpp\naccept = !coneCull(center.xyz, radius, cone_axis, \n    cone_cutoff, eye.xyz);\n```", "```cpp\nbool coneCull(vec3 center, float radius, vec3 cone_axis, \nfloat cone_cutoff, vec3 camera_position)\n{\n    return dot(center - camera_position, cone_axis) >= \n        cone_cutoff * length(center - camera_position) + \n        radius;\n}\n```", "```cpp\ncenter = world_to_camera * center;\n```", "```cpp\nfor ( uint i = 0; i < 6; ++i ) {\n    frustum_visible = frustum_visible && \n        (dot( frustum_planes[i], center) > -radius);\n}\n```", "```cpp\naccept = accept && frustum_visible;\n```", "```cpp\nout taskNV block\n{\n    uint meshletIndices[32];\n};\n```", "```cpp\n#extension GL_KHR_shader_subgroup_ballot: require\n```", "```cpp\nuvec4 ballot = subgroupBallot(accept);\n```", "```cpp\nuint index = subgroupBallotExclusiveBitCount(ballot);\n\nif (accept)\n    meshletIndices[index] = meshlet_index;\n```", "```cpp\nuint count = subgroupBallotBitCount(ballot);\n\nif (ti == 0)\n    gl_TaskCountNV = count;\n```", "```cpp\nlayout(local_size_x = 32) in;\n```", "```cpp\nin taskNV block\n{\n    uint meshletIndices[32];\n};\n```", "```cpp\nlayout(triangles, max_vertices = 64, max_primitives = 124) out;\n```", "```cpp\nlayout (location = 0) out vec2 vTexcoord0[];\nlayout (location = 1) out vec4 vNormal_BiTanX[];\nlayout (location = 2) out vec4 vTangent_BiTanY[];\nlayout (location = 3) out vec4 vPosition_BiTanZ[];\nlayout (location = 4) out flat uint mesh_draw_index[];\n```", "```cpp\nuint ti = gl_LocalInvocationID.x;\nuint mi = meshletIndices[gl_WorkGroupID.x];\n\nMeshDraw mesh_draw = mesh_draws[ meshlets[mi].mesh_index ];\nuint mesh_instance_index = draw_commands[gl_DrawIDARB + \ntotal_count].drawId;\n```", "```cpp\nuint vertexCount = uint(meshlets[mi].vertexCount);\nuint triangleCount = uint(meshlets[mi].triangleCount);\nuint indexCount = triangleCount * 3;\n\nuint vertexOffset = meshlets[mi].dataOffset;\nuint indexOffset = vertexOffset + vertexCount;\n```", "```cpp\nfor (uint i = ti; i < vertexCount; i += 32)\n{\n    uint vi = meshletData[vertexOffset + i];\n\nvec3 position = vec3(vertex_positions[vi].v.x, \n   vertex_positions[vi].v.y, \n   vertex_positions[vi].v.z); \n\n    // normals, tangents, etc.\n\n    gl_MeshVerticesNV[ i ].gl_Position = view_projection * \n        (model * vec4(position, 1));\n\n    mesh_draw_index[ i ] = meshlets[mi].mesh_index;\n}\n```", "```cpp\nuint indexGroupCount = (indexCount + 3) / 4;\n\nfor (uint i = ti; i < indexGroupCount; i += 32)\n{\n    writePackedPrimitiveIndices4x8NV(i * 4, \n        meshletData[indexOffset + i]);\n}\n```", "```cpp\nif (ti == 0)\n    gl_PrimitiveCountNV = uint(meshlets[mi].triangleCount);\n```", "```cpp\nutil_add_image_barrier( gpu, gpu_commands->\n    vk_command_buffer, depth_texture, \n        RESOURCE_STATE_SHADER_RESOURCE, 0, 1, true );\n```", "```cpp\nu32 width = depth_pyramid_texture->width;\nu32 height = depth_pyramid_texture->\n    height for ( u32 mip_index = 0; mip_index < \n    depth_pyramid_texture->mipmaps; ++mip_index ) {\n    util_add_image_barrier( gpu, gpu_commands->\n    vk_command_buffer, depth_pyramid_texture->\n    vk_image, RESOURCE_STATE_UNDEFINED, \n    RESOURCE_STATE_UNORDERED_ACCESS, \n    mip_index, 1, false );\n```", "```cpp\n    u32 group_x = ( width + 7 ) / 8;\n    u32 group_y = ( height + 7 ) / 8;\n\n    gpu_commands->dispatch( group_x, group_y, 1 );\n```", "```cpp\n    util_add_image_barrier( gpu, gpu_commands->\n        vk_command_buffer, depth_pyramid_texture->\n        vk_image, RESOURCE_STATE_UNORDERED_ACCESS, \n        RESOURCE_STATE_SHADER_RESOURCE, mip_index, \n        1, false );\n\n    width /= 2;\n    height /= 2;\n}\n```", "```cpp\nivec2 texel_position00 = ivec2( gl_GlobalInvocationID.xy )\n    * 2;\nivec2 texel_position01 = texel_position00 + ivec2(0, 1);\nivec2 texel_position10 = texel_position00 + ivec2(1, 0);\nivec2 texel_position11 = texel_position00 + ivec2(1, 1);\n```", "```cpp\nfloat color00 = texelFetch( src, texel_position00, 0 ).r;\nfloat color01 = texelFetch( src, texel_position01, 0 ).r;\nfloat color10 = texelFetch( src, texel_position10, 0 ).r;\nfloat color11 = texelFetch( src, texel_position11, 0 ).r;\n```", "```cpp\nfloat result = max( max( max( color00, color01 ), \n    color10 ), color11 );\nimageStore( dst, ivec2( gl_GlobalInvocationID.xy ), \n    vec4( result, 0, 0, 0 ) );\n```", "```cpp\nuint mesh_draw_index = \n   mesh_instance_draws[mesh_instance_index] \n   .mesh_draw_index; \n\nMeshDraw mesh_draw = mesh_draws[mesh_draw_index];\n\nmat4 model = \n   mesh_instance_draws[mesh_instance_index].model;\n```", "```cpp\nvec4 bounding_sphere = mesh_bounds[mesh_draw_index];\n\nvec4 world_bounding_center = model * \n    vec4(bounding_sphere.xyz, 1);\nvec4 view_bounding_center = world_to_camera * \n    world_bounding_center;\n\nfloat scale = length( model[0] );\nfloat radius = bounding_sphere.w * scale;\n```", "```cpp\nbool project_sphere(vec3 C, float r, float znear, \n    float P00, float P11, out vec4 aabb) {\n        if (-C.z - r < znear)\n        return false;\n```", "```cpp\nvec2 cx = vec2(C.x, -C.z);\nvec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);\nvec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;\nvec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;\n```", "```cpp\naabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, \n       maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);\n```", "```cpp\naabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + \nvec4(0.5f);\n```", "```cpp\nivec2 depth_pyramid_size = \n   textureSize(global_textures[nonuniformEXT \n   (depth_pyramid_texture_index)], 0); \nfloat width = (aabb.z - aabb.x) * depth_pyramid_size.x ;\nfloat height = (aabb.w - aabb.y) * depth_pyramid_size.y ;\n\nfloat level = floor(log2(max(width, height)));\n```", "```cpp\nfloat depth = \n   textureLod(global_textures[nonuniformEXT \n   (depth_pyramid_texture_index)], (aabb.xy + aabb.zw) \n   0.5, level).r;\n```", "```cpp\nfloat depth_sphere = z_near / (view_bounding_center.z – \n                     radius); \n```", "```cpp\nocclusion_visible = (depth_sphere <= depth);\n```", "```cpp\ndraw_commands[draw_index].drawId = mesh_instance_index;\ndraw_commands[draw_index].taskCount = \n    (mesh_draw.meshlet_count + 31) / 32;\ndraw_commands[draw_index].firstTask = \n    mesh_draw.meshlet_offset / 32;\n```"]