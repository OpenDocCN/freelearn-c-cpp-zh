- en: Chapter 5.  Dominating the Mobile UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3.  Dividing Your Project
    and Ruling Your Code"), *Dividing Your Project and Ruling Your Code*, we created
    a strong core library to handle a picture gallery. We will now use this `gallery-core`
    library to create a mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: We will teach you how to create a Qt Quick project from scratch. You will create
    custom Qt Quick views with QML. This chapter will also cover how your QML views
    can communicate with the C++ library.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, your gallery application will run on your mobile
    (Android or iOS) with a dedicated GUI compliant with touch devices. This application
    will offer the same features as the desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Qt Quick project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Quick controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt for mobile (Android and iOS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling C++ functions from QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with Qt Quick and QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt Quick is another way of creating applications with Qt. You can use it to
    create a complete application in place of Qt Widgets. The Qt Quick module provides
    transitions, animations, and visual effects. You can also customize graphical
    effects with shaders. This module is especially efficient at making software for
    devices using touchscreens. Qt Quick uses a dedicated language: Qt Modeling Language
    (QML). It is a declarative language; the syntax is close to the JSON (JavaScript
    Object Notation) syntax. Furthermore, QML also supports JavaScript expressions
    inline or in a separate file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a simple example of a Qt Quick application using QML. Create
    a new file called `main.qml` with this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Qt 5 provides a nice tool called `qmlscene` to prototype a QML user interface.
    You can find the binary file in your Qt installation folder, for example: `Qt/5.7/gcc_64/bin/qmlscene`.
    To load your `main.qml` file, you can run the tool and select the file, or use
    the CLI with the `.qml` file in an argument: `qmlscene main.qml`. You should see
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with Qt Quick and QML](img/image00380.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use a Qt Quick module, you need to import it. The syntax is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example we import `QtQuick`, which is the common module that will provide
    basic components (`Rectangle`, `Image`, `Text`) and we also import the `QtQuick.Window`
    module that will provide the main window application (`Window`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A QML component can have properties. For example, we set the `width` property
    of the `Window` class to the value `640`. Here is the generic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update `main.qml` file with some new rectangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the visual result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with Qt Quick and QML](img/image00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your QML file describes the UI as a hierarchy of components. The hierarchy
    below the `Window` element is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Red `Rectangle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green `Rectangle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue `Rectangle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each nested item will always have its `x`, `y` coordinates relative to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To structure your application, you can build reusable QML components. You can
    easily create a new component. All QML components must have a single root item.
    Let''s build a new `MyToolbar` component by creating a new file called `MyToolbar.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The gray `Rectangle` element will be our root item used as background. We also
    created two items:'
  prefs: []
  type: TYPE_NORMAL
- en: A purple `Rectangle` element that can be identified with the ID `purpleRectangle`.
    The height of this item will be the height of its parent, that is, the gray `Rectangle`
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Text` item. In this case, we use anchors. It will help us to layout items
    without using hardcoded coordinates. The left of the `Text` item will be aligned
    with the right of `purpleRectangle`, and the right of the `Text` item will be
    aligned with the right of the parent (the gray `Rectangle` element).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Qt Quick provides a lot of anchors: `left`, `horizontalCenter`, `right`, `top`, `verticalCenter`,
    and `bottom`. You can also use convenience anchors such as `fill` or `centerIn`.
    For more information on anchors, take a look at [http://doc.qt.io/qt-5/qtquick-positioning-anchors.html](http://doc.qt.io/qt-5/qtquick-positioning-anchors.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `MyToolbar` in your window by updating your `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the width to the parent width. Like this, the toolbar fills the window''s
    width. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with Qt Quick and QML](img/image00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Anchors are great to align specific items, but if you want to layout several
    items in grid, row, or column fashion, you can use the `QtQuick.layouts` module.
    Here is an example of the updated `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with Qt Quick and QML](img/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we use a `RowLayout` element that fits under the `myToolbar`
    and to its parent, a `Window` element. This item provides a way to dynamically
    layout items in a row. Qt Quick also provides other layout items: `GridLayout`
    and `ColumnLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your custom component can also expose custom properties that can be modified
    outside of the component itself. You can do it by adding the `property` attribute.
    Please update `MyToolbar.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `iconColor` is a really new property that is a fully-fledged variable. We
    also update the `Rectangle` attribute to use this property as `color`. The `title`
    property is only an `alias`, you can see it as a pointer to update the `label.text`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'From outside you can use these attributes with the same syntax; please update
    the `main.qml` file with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a nice updated toolbar like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with Qt Quick and QML](img/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have covered the basics of QML, now we are going to proceed to mobile application
    development using QML.
  prefs: []
  type: TYPE_NORMAL
- en: Checking your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to create a Qt application for Android, you must have:'
  prefs: []
  type: TYPE_NORMAL
- en: A device with Android v2.3.3 (API 10) or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Prebuilt Components for Android x86 (from the Qt Maintenance Tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Prebuilt Components for Android ARMv7 (from the Qt Maintenance Tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To be able to create a Qt application for iOS, you must have:'
  prefs: []
  type: TYPE_NORMAL
- en: A device with iOS 5.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Mac desktop computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt for iOS (from Qt Maintenance Tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When starting, Qt Creator will detect and create Android and iOS Qt kits. You
    can check your existing kits from **Tools** | **Options** | **Build & Run** | **Kits**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking your development environment](img/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Qt Quick project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will follow the same project structure we covered in [Chapter
    4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop UI"), *Conquering
    the Desktop UI*: a parent project `ch05-gallery-mobile.pro` will host our two
    subprojects, `gallery-core` and the new `gallery-mobile`.'
  prefs: []
  type: TYPE_NORMAL
- en: In Qt creator, you can create a Qt Quick subproject from **File** | **New File
    or Project** | **Application** | **Qt Quick Controls Application** | **Choose**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wizard will allow you to customize your project creation:'
  prefs: []
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a project name (`gallery-mobile`) and a location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deselect **With ui.qml file**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deselect **Enable native styling**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select your desktop kit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select at least one mobile kit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to add gallery-mobile as a subproject of `ch05-gallery-mobile.pro`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take some time to explain why we created our project with these options.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to analyze is the application template. By default, Qt Quick
    only provides basic QML components (`Rectangle`, `Image`, `Text`, and so on).
    Advanced components will be handled by Qt Quick modules. For this project we will
    use Qt Quick Controls (`ApplicationWindow`, `Button`, `TextField`, and so on).
    That is why we chose to begin with a **Qt Quick Controls application**. Keep in
    mind that you can always import and use Qt Quick modules later.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will not use the Qt Quick Designer. As a consequence, `.ui.qml`
    files are not required. Even if the designer can help a lot, it is good to understand
    and write QML files yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The desktop "native styling" is disabled because this project mainly targets
    mobile platforms. Moreover, disabling "native styling" avoids heavy dependency
    on the Qt widgets module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we select at least two kits. The first one is our desktop kit. The
    other kits are the mobile platforms you target. We usually use the following development
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast iterations on desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check and fix behavior on mobile emulator/simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real test on the mobile device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment on a real device is generally longer so you can do most development
    with the desktop kit. The mobile kits will allow you to check your application
    behavior on a real mobile device or on an emulator (for example with a Qt Android
    x86 kit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk about the files automatically generated by the wizard. Here is
    the `main.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use here `QGuiApplication` and not `QApplication` because we do not use Qt
    widgets in this project. Then, we create the QML engine and load `qrc:/mail.qml`.
    As you may have guessed (with the `qrc:/` prefix), this QML file is in a Qt resource
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open the `qml.qrc` file to find the `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to import types used in the file. Notice the module
    version at the end of each import. The `QtQuick` module will import basic QML
    elements (`Rectangle`, `Image`, and so on) while the `QtQuick.Controls` module
    will import advanced QML elements from the `QtQuick Controls` submodule (`ApplicationWindow`, `MenuBar`, `MenuItem`, `Label`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the root element of type `ApplicationWindow`. It provides a
    top-level application window with the following items: `MenuBar`, `ToolBar` and `StatusBar`.
    The properties `visible`, `width`, `height`, and `title` of `ApplicationWindow`
    are primitive types. The syntax is simple and intelligible.
  prefs: []
  type: TYPE_NORMAL
- en: The `menuBar` property is more complex. This `MenuBar` property is composed
    of a `Menu` file, itself composed of two `MenuItems`: `Open` and `Exit`. A `MenuItem`
    emits a `triggered()`signal each time it is activated. In this case, the `MenuItem`
    file will log a message on the console. The exit `MenuItem` terminates the application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a `Label` displaying "Hello World" is added in the content area of
    our `ApplicationWindow` type. Positioning items with anchors is useful. In our
    case the label is centered vertically and horizontally in its parent, `ApplicationWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: Before going ahead, check that this sample runs correctly on your desktop and
    on your mobile.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your Qt Quick gallery entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, you need to link this project to our `gallery-core` library.
    We already covered how to link an internal library in [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*. For more
    details, refer to it. This is the updated `gallery-mobile.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Please notice that we made several changes here:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the `sql` module to deploy the dependency on your mobile device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `svg` module for the button icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `qml.qrc` file has been renamed in `gallery.qrc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We linked the `gallery-core` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the `sql` shared object (`libQt5Sql.so`) will not be deployed on
    your Android x86 device. You have to explicitly include it in your `.pro` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now use classes from the `gallery-core` library in our `gallery-mobile`
    application. Let''s see how to bind C++ models with QML. This is the updated `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our models will be instantiated in C++ and exposed to QML using the root `QQmlContext`
    object. The `setContextProperty()` function allows us to bind a C++ `QObject`
    to a QML property. The first argument will be the QML property name. We are only
    binding a C++ object to a QML property; the context object does not take ownership
    of this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now talk about the mobile application itself. We will define three pages
    with specific roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AlbumListPage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displays existing albums
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Album creation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Album selection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlbumPage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displays existing pictures as thumbnails
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds pictures in album
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Album rename
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Album deletion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture selection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PicturePage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displays selected picture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture selection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture deletion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle the navigation, we will use a `StackView` component from Qt Quick
    Controls. This QML component implements a stack-based navigation. You can push
    a page when you want to display it. When the user requests to go back, you can
    pop it. Here is the workflow using a `StackView` component for our gallery mobile
    application. The page with the solid border is the page currently displayed on
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing your Qt Quick gallery entry point](img/image00386.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the implementation of `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This main file is really simple. The application is constructed around the `StackView`
    component. We set the `id` property to allow our `StackView` to be identified
    and referred to by other QML objects. The `anchors` property will set `stackView`
    to fill its parent, the `ApplicationWindow` type. Finally, we set the `initialItem`
    property to a page, `AlbumListPage` that will be implemented soon.
  prefs: []
  type: TYPE_NORMAL
- en: On Android, `onClosing` will be executed each time the user presses the back
    button. To mimic a native Android application, we will first pop the last stacked
    page before really closing the application.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the file, we define a `property alias` for the `stackView`. A `property
    alias` is a simple reference to another existing property. This alias will be
    useful to access `stackView` from other QML components. To prevent a QML component
    to crush the `stackView` we are using the `readonly` keyword. After initialization,
    the components can access the property but not change its value.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying albums with ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make our first page for this mobile application! Create a file in `gallery.qrc`
    called `AlbumListPage.qml`. Here is the page header implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A `Page` is a container control with a header and footer. In this application,
    we will only use the header item. We assign a `ToolBar` to the `header` property.
    The height of this toolbar will be handled by Qt and will be adjusted depending
    on the target platform. In this first simple implementation, we only put a `Label`
    displaying the text "Albums".
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `ListView` element to this page after the `header` initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Qt Quick `ListView` is the Qt Widget `QListView` equivalent. It displays
    a list of items from a provided model. We set the `model` property to value `albumModel`.
    This refers to the C++ model from `main.cpp` file accessible from QML because
    we used the `setContextProperty()` function. In Qt Quick, you must provide a delegate
    to describe how a row will be displayed. In this case, a row will only display
    the album''s name with a `Text` item. Accessing the album''s name in QML is easy
    because our `AlbumModel` model exposes its role list to QML. Let''s refresh your
    memory concerning the overridden `roleNames()` function of `AlbumModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So each time your delegate from Qt Quick uses the `name` role, it will call
    the `AlbumModel` function `data()` with the correct role integer and return the
    correct album name string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the mouse, click on a row and add a `MouseArea` element on the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `MouseArea` is an invisible item that can be used with any visible item
    to handle mouse events. This also applies to a simple touch on a phone touch screen.
    Here we tell the `MouseArea` element to take the full area of the parent `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we only perform tasks on the `clicked` signal. We update the `currentIndex`
    of the `ListView` with `index`. This `index` is a special role containing the
    index of the item in the model.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks, we will tell `pictureModel` to load the selected album
    with the `pictureModel.setAlbumId(id)` call. We will see soon how QML can call
    C++ methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we push `AlbumPage` on `pageStack` property. The `push()` function
    allows us to set a list of QML properties using a {`key: value`, ... } syntax.
    Each property will be copied into the pushed item. Here the `name` and the `index`
    will be copied in the `albumName` and `albumRowIndex` properties of `AlbumPage`.
    It is a simple yet powerful way to instantiate a QML page with properties arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your QML code, you can only call some specific C++ methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties (using `Q_PROPERTY`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public slot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function decorated as invokable (using `Q_INVOKABLE`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case we will decorate `PictureModel::setAlbumId()` as `Q_INVOKABLE`,
    please update the `PictureModel.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Theming the application with a QML singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styling and theming a QML application can be done in various ways. In this chapter,
    we will declare a QML singleton with the theme data used by custom components.
    Moreover, we will also create a custom `Page` component to handle the toolbar
    and its default item (back button and page's title).
  prefs: []
  type: TYPE_NORMAL
- en: 'Please create a new `Style.qml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We declare a `QtObject` component that will only contain our theme properties.
    A `QtObject` is a non-visual QML component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a singleton type in QML requires two steps. First you need to use
    the `pragma singleton`, it will indicate the use of a single instance of the component.
    The second step is to register it. This can be done in C++ or by creating a `qmldir`
    file. Let''s see the second step. Create a new plain-text file called `qmldir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This simple line will declare a QML `singleton` type named `Style` with the
    version 1.0 from the file named `Style.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to use these theme properties in custom components. Let''s see
    a simple example. Create a new QML file called `ToolBarTheme.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This QML object describes a customized `ToolBar`. Here, the `background` element
    is a simple `Rectangle` with our color. We can easily access our singleton `Style`
    and its theme property using `Style.toolbarBackground`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: QML Singletons require an explicit import to load the `qmldir` file. The `import
    "."` is a workaround for this Qt bug. For more information, please check [https://bugreports.qt.io/browse/QTBUG-34418](https://bugreports.qt.io/browse/QTBUG-34418).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a QML file `PageTheme.qml`, with the aim of containing all
    the code related to the page''s toolbar and theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This `PageTheme` element will customize the page''s header. We use our previously
    created `ToolBarTheme`. This toolbar only contains a `RowLayout` element to display
    items horizontally in one row. This layout contains three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ToolButton`: This is the "back" that displays an image from `gallery.qrc`
    and pops the current page if required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label`: This is the element that displays the page title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Loader`: This is the element that allows a page to dynamically add specific
    items in this generic toolbar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Loader` element owns a `sourceComponent` property. In this application,
    this property can be assigned by `PageTheme` pages to add specific buttons. These
    buttons will be instantiated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The `PageTheme` pages also contain a `Rectangle` element that fits the parent
    and configures the page background color using the `Style.pageBackground`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `Style.qml` and `PageTheme.qml` files are ready, we can update
    the `AlbumListPage.qml` file to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that `AlbumListPage` is a `PageTheme` element, we do not manipulate `header`
    directly. We only need to set the property `toolbarTitle` to display a nice "Albums"
    text in the toolbar. We can also enjoy nice colors using properties from the `Style`
    singleton.
  prefs: []
  type: TYPE_NORMAL
- en: By centralizing the theme properties in a single file, you can easily change
    the look and feel of your application. The source code of the project also contains
    a dark theme.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a database on mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before continuing the UI implementation, we have to take care of the database
    deployment on mobile. Spoiler: this will not be fun.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to jump back to `DatabaseManager.cpp` in the `gallery-core` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Whereas on Desktop, the SQLite3 database is created at the instruction `mDatabase->setDatabaseName()`,
    on mobile it does not work at all. This is due to the fact that the filesystem
    is very specific on each mobile platform (Android and iOS). An application has
    only access to a narrow sandbox where it cannot mess with the rest of the filesystem.
    All the files inside the application directory must have specific file permissions.
    If we let SQLite3 create the database file, it will not have the right permission
    and the OS will block the database from opening.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, the database will not be properly created and your data cannot
    be persisted. When using the native API, this is not a problem since the OS takes
    care of the proper configuration of the database. Because we are developing with
    Qt, we do not have easy access to this API (except by using JNI or other black
    magic). A workaround is to embed a "ready-to-use" database in the application's
    package and copy it at the right filesystem path with the correct rights.
  prefs: []
  type: TYPE_NORMAL
- en: This database should contain an empty created database without any content.
    The database is available in the source code of the chapter (you can also generate
    it from the source code of [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4. 
    Conquering the Desktop UI"), *Conquering the Desktop UI*). You can add it to the `gallery.qrc`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our layers are clearly defined, we just have to modify the `DatabaseManager::instance()`
    implementation to handle this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We first retrieve the platform-specific path of the application with a nifty
    Qt class: `QStandardPaths`. This class return paths for multiple types (`AppLocalDataLocation`, `DocumentsLocation`, `PicturesLocation`,
    and so on). The database should be stored in the application data directory. If
    the file does not exist, we copy it from our assets.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the permissions of the file are modified to ensure that the OS does
    not block the opening of the database (due to permissions not being restrictive
    enough).
  prefs: []
  type: TYPE_NORMAL
- en: When everything is done, the `DatabaseManager singleton` is instantiated with
    the correct database file path and the constructor can open this database transparently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the iOS Simulator, the `QStandardPaths::writableLocation()` function will
    not return the proper path. Since iOS 8, the simulator's storage path on the host
    has changed and Qt does not reflect this. For more information, please check out [https://bugreports.qt.io/browse/QTCREATORBUG-13655](https://bugreports.qt.io/browse/QTCREATORBUG-13655).
  prefs: []
  type: TYPE_NORMAL
- en: These workarounds were not trivial. This shows the limitations of a cross-platform
    application on mobile. Each platform has its own very specific way of handling
    the filesystem and deploying its content. Even if we manage to write platform
    agnostic code in QML, we still have to deal with differences between the OSes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new album from a custom InputDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AlbumListPage` needs some data to display. The next step is to be able
    to add a new album. To do this, at some point we will have to call an `AlbumModel`
    function from QML to add this new album. Before building the UI, we have to make
    a small modification in `gallery-core`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AlbumModel` function is already available in QML. However, we cannot directly
    call `AlbumModel::addAlbum(const Album& album)` from the QML code; the QML engine
    will not recognize the function and will throw an error **TypeError: Property
    ''addAlbum'' of object AlbumModel(...) is not a function**. This can be fixed
    by simply decorating the desired function with the `Q_INVOKABLE` macro (as we
    did for `PictureModel::setAlbumId()`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, there is another issue here: `Album` is a C++ class which is not
    recognized in QML. If we wanted to have full access to `Album` in QML, it would
    involve important modifications to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: Force `Album` class to inherit from the `QObject` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `Q_PROPERTY` macro to specify which property of the class should be accessible
    from QML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add multiple constructors (copy constructor, `QObject* parent`, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force `AlbumModel::addAlbum()` function to take an `Album*` rather than an `Album&`.
    For complex objects (that is, not primitive types), QML can only handle pointers.
    This is not a big problem, but using references instead of pointers tends to make
    the code safer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These modifications are perfectly reasonable if the class is heavily manipulated
    in QML. Our use case is very limited: we only want to create a new album. Throughout
    the application, we will rely on the native Model/View API to display the album
    data and nothing specific to `Album` will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For all these reasons, we will simply add a wrapper function in `AlbumModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new function `addAlbumFromName()` just wraps the call to `addAlbum()` with
    the desired album `name` parameter. It can be called from the QML with the `Q_INVOKABLE`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now switch back to the UI in the `gallery-mobile` project. We will add
    this album using a QML `Dialog`. QtQuick provides various default implementations
    of dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ColorDialog`: This dialog is used to choose a color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dialog`: This dialog is uses the generic dialog with standard buttons (equivalent
    of a `QDialog`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileDialog`: This dialog is used to choose a file from the local filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontDialog`: This dialog is used to choose a font'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageDialog`: This dialog is used to display a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You would have expected to see an `InputDialog` in this list (as we used the `QInputDialog`
    widget in [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop
    UI"), *Conquering the Desktop UI*) but Qt Quick does not have it. Create a new **QML
    File (Qt Quick 2)** and name it `InputDialog.qml`. The content should look like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this custom `InputDialog`, we take the generic Qt Quick `Dialog` and modify
    it to contain our `TextInput` item referenced by the ID `editTextItem`. We also
    added a `labelItem` just above `editTextItem` to describe the expected input.
    There are several things to note in this dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, because we want this dialog to be generic, it has to be configurable.
    The caller should be able to provide parameters to display its specific data.
    This is done with the three properties at the top of the `Dialog` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: This property configures the displayed text in `labelItem`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hint`: This property is the default text displayed in `editTextItem`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`editText`: This property references the "local" `editTextItem` element. This
    will let the caller retrieve the value when the dialog is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also configure the `Dialog` element to automatically use the platform buttons
    to validate or cancel the dialog with `standardButtons: StandardButton.Ok | StandardButton.Cancel`
    syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to make the dialog a bit more user-friendly, `editTextItem` has the
    focus when the `Dialog` element becomes visible and the text is selected. These
    two steps are done in the `onVisibleChanged()` callback function. When the dialog
    is hidden (that is, **Ok** or **Cancel** has been clicked), we hide the virtual
    keyboard with `Qt.InputMethod.hide()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InputDialog` is ready to be used! Open `AlbumListPage.qml` and modify
    it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We add `InputDialog` with the ID `newAlbumDialog` inside `PageTheme` element.
    We define all our custom properties: `title`, `label`, and `hint`. When the user
    clicks on the **Ok** button, the `onAccepted()` function is called. Here, it is
    a simple matter of calling the wrapper function `addAlbumFromName()` in the `AlbumModel`
    element with the entered text.
  prefs: []
  type: TYPE_NORMAL
- en: This `Dialog` element is not visible by default, we open it by adding a `ToolButton`
    in  `toolbarButtons`. This `ToolButton` will be added at the far right of the
    header as we specified in the `PageTheme.qml` file. To match mobile standards,
    we simply use a custom icon inside that button rather than text.
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see that it is possible to reference images stored in the `.qrc`
    file with the syntax `qrc:/res/icons/album-add.svg`. We use SVG files to have
    scalable icons, but you are free to use your own icons for the `gallery-mobile`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the `ToolButton`, the `onClicked()` function is called,
    where we open `newAlbumDialog`. On our reference device, a Nexus 5X, this is how
    it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new album from a custom InputDialog](img/image00387.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the user clicks on the **OK** button, the whole Model/View pipeline starts
    to work. This new album is persisted, the `AlbumModel` element emits the correct
    signals to notify our `ListView`, `albumList`, to refresh itself. We are starting
    to leverage the power of our `gallery-core`, which can be used in a desktop application
    and a mobile application without rewriting a significant portion of the engine
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images with an ImageProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to display the thumbnails for our freshly persisted album. These
    thumbnails have to be loaded somehow. Because our application is targeted at mobile
    devices, we cannot afford to freeze the UI thread while loading thumbnails. We
    would either hog the CPU or be killed by the OS, neither of which are desirable
    destinies for `gallery-mobile`. Qt provides a very handy class to handle the image
    loading: `QQuickImageProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: The `QQuickImageProvider` class provides an interface to load the `QPixmap`
    class in your QML code in an asynchronous manner. This class automatically spawns
    threads to load the `QPixmap` class and you simply have to implement the function `requestPixmap()`.
    There is more to it, `QQuickImageProvider` caches by default the requested pixmap
    to avoid hitting the data source too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our thumbnails must be loaded from the `PictureModel` element, which gives
    access to the `fileUrl` of a given `Picture`. Our implementation of `r`QQuickImageProvider
    will have to get the `QPixmap` class for a row index in `PicturelModel`. Create
    a new C++ class named `PictureImageProvider`, and modify `PictureImageProvider.h`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A pointer to the `PictureModel` element has to be provided in the constructor
    to be able to retrieve `fileUrl`. We override `requestPixmap()`, which takes an `id`
    parameter in its parameters list (the `size` and `requestedSize` can be safely
    ignored for now). This `id` parameter will be provided in the QML code when we
    want to load a picture. For a given `Image` in QML, the `PictureImageProvider`
    class will be called like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image`: This is the scheme for the URL source of the image. This tells Qt
    to work with an image provider to load the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pictures`: This is the identifier of the image provider. We will link the `PictureImageProvider`
    class and this identifier at the initialization of  `QmlEngine` in `main.cpp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: This is the ID of the image. Here it is the row index of the picture.
    This corresponds to the `id` parameter in `requestPixmap()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already know that we want to display a picture in two modes: thumbnail and
    full resolution. In both cases, a `QQuickImageProvider` class will be used. These
    two modes have a very similar behavior: they will request `PictureModel` for `fileUrl`
    and return the loaded `QPixmap`.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a pattern here. We can easily encapsulate these two modes in `PictureImageProvider`.
    The only thing we have to know is when the caller wants a thumbnail or a full
    resolution `QPixmap`. This can be easily done by making the `id` parameter more
    explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement the `requestPixmap()` function to be able to be called
    in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`images://pictures/<index>/full`: Using this syntax to retrieve the full resolution
    picture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images://pictures/<index>/thumbnail`: Using this syntax to retrieve the thumbnail
    version of the picture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the `index` value was `0`, these two calls would set the ID to `0/full`
    or `0/thumbnail` in `requestPixmap()`. Let''s see the implementation in `PictureImageProvider.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start by calling the `QQuickImageProvider` constructor with the `QQuickImageProvider::Pixmap`
    parameter to configure `QQuickImageProvider` to call `requestPixmap()`. The `QQuickImageProvider`
    constructor supports various image types (`QImage`, `QPixmap`, `QSGTexture`, `QQuickImageResponse`)
    and each one has its specific `requestXXX()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `requestPixmap()` function, we start by splitting this ID with the `/`
    separator. From here, we retrieve the `row` values and the desired `pictureSize`.
    The `fileUrl` is loaded by simply calling the `mPictureModel::data()` function
    with the right parameters. We used the exact same call in [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*.
  prefs: []
  type: TYPE_NORMAL
- en: Great, we know which `fileUrl` should be loaded and what the desired dimension
    is. However, we have one last thing to handle. Because we manipulate a row and
    not a database ID, we will have the same request URL for two different pictures,
    which are in different albums. Remember that `PictureModel` loads a list of pictures
    for a given `Album`.
  prefs: []
  type: TYPE_NORMAL
- en: We should picture (pun intended) the situation. For an album called `Holidays`,
    the request URL will be `images://pictures/0/thumbnail` to load the first picture.
    It will be the same URL for another album `Pets`, which will load the first picture
    with `images://pictures/0/thumbnail`. As we said earlier, `QQuickImageProvider`
    automatically generates a cache which will avoid subsequent calls to `requestPixmap()`
    for the same URL. Thus, we will always serve the same picture, no matter which
    album is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This constraint forces us to disable the cache in `PictureImageProvider` and
    to roll out our own cache. This is an interesting thing to do; here is a possible
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This new `pictureFromCache()` function aims to store the generated `QPixmap`
    in `mPicturesCache` and return the proper `QPixmap`. The `mPicturesCache` class
    relies on a `QCache`; this class lets us store data in a key/value fashion with
    the possibility to assign a cost for each entry. This cost should roughly map
    the memory cost of the object (by default, `cost = 1`). When `QCache` is instantiated,
    it is initialized with a `maxCost` value (by default `100`). When the cost of
    the sum of all objects' exceeds the `maxCost`, `QCache` starts deleting objects
    to make room for the new objects, starting with the less recently accessed objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the `pictureFromCache()` function, we first generate a key composed of the `fileUrl`
    and the `pictureSize` before trying to retrieve the `QPixmap` from the cache.
    If it is not present, the proper `QPixmap` (scaled to `THUMBNAIL_SIZE` macro if
    needed) will be generated and stored inside the cache. The `mPicturesCache` class
    becomes the owner of this `QPixmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to complete the `PictureImageProvider` class is to make it available
    in the QML context. This is done in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `PictureImageProvider` class is added to the QML engine with `engine.addImageProvider()`.
    The first argument will be the provider identifier in QML. Note that the engine
    takes ownership of the passed `PictureImageProvider`. One last thing, the `thumbnailSize`
    parameter is also passed to `engine`, it will constrain the thumbnails to be displayed
    with the specified size in the QML code.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying thumbnails in a GridView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to display these thumbnails. Create a new QML file named `AlbumPage.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This new `PageTheme` element defines two properties: `albumName` and `albumRowIndex`.
    The `albumName` property is used to update the title in `toolbarTitle`; `albumRowIndex`
    will be used to interact with `AlbumModel` in order to rename or delete the album
    from the current page.
  prefs: []
  type: TYPE_NORMAL
- en: To display thumbnails, we rely on a `GridView` element which will layout the
    thumbnails in a grid of cells. This `thumbnailList` item uses the `pictureModel`
    to request its data. The delegate is simply a `Rectangle` element with a single `Image`
    inside. This `Rectangle` element is slightly smaller than the `thumbnailList.cellWidth`
    or `thumbnailList.cellHeight`. The `GridView` element does not provide a `spacing`
    property (like `ListView`) for some room between each item. Thus, we simulate
    it by using a smaller area to display the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Image` item will try to take all the available space with `anchors.fill:
    parent` but will still keep the aspect ratio of the provided picture with `fillMode:
    Image.PreserveAspectFit`. You recognize the `source` attribute where the current
    delegate `index` is provided to retrieve the thumbnail. Finally, the `cache: false`
    attribute ensures that the `PictureImageProvider` class will not try to use the
    native cache.'
  prefs: []
  type: TYPE_NORMAL
- en: To display `AlbumPage.qml`, we have to update the `stackView` (located in `main.qml`).
    Remember that `stackView` has been declared as a property (`pageStack`), it is
    thus accessible from any QML file.
  prefs: []
  type: TYPE_NORMAL
- en: The `AlbumPage` element will be displayed when the user clicks on the `MouseArea`
    element for a given `Album` value in `AlbumListPage.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now give the ability to the user to add a new picture. To do this,
    we will rely on a QtQuick Dialog: `FileDialog`. Here is the updated version of `AlbumPage.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileDialog` element is straightforward to implement. By using the `folder:
    shortcuts.pictures` property, QtQuick will automatically position the `FileDialog`
    element in the platform-specific pictures directory. Even better, on iOS it will
    open the native photo application where you can pick your own picture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user validates his picture choice, the path is available in the `onAccepted()`function
    with the `dialog.fileUrl` field, which we stored in the `pictureUrl` variable.
    This `pictureUrl` variable is then passed to a new wrapper function of `PictureModel:
    addPictureFromUrl()`. The pattern used is exactly the same as we did for `AlbumModel::addAlbumFromName()`:
    a `Q_INVOKABLE` wrapper function around `PictureModel::addPicture()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only missing parts of `AlbumPage` are the delete album and rename album
    features. They follow patterns we already covered. The deletion will be done using
    a wrapper function in `AlbumModel`, and the rename reuses the `InputDialog` we
    created for `AlbumListPage.qml`. Please refer to the source code of the chapter
    to see the implementation for these features. This is how the thumbnails will
    look on an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying thumbnails in a GridView](img/image00388.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Swiping through full resolution pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last page we have to implement in `gallery-mobile` is the full resolution
    picture page. In [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering
    the Desktop UI"), *Conquering the Desktop UI*, we navigated through the pictures
    using previous/next buttons. In this chapter, we target the mobile platform. Therefore,
    the navigation should be done using a touch-based gesture: a fling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of this new `PicturePage.qml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define two properties, `pictureName` and `pictureIndex`. The current `pictureName`
    property is displayed in the `toolbarTitle` and `pictureIndex` is used to initialize
    the correct `currentIndex` in `ListView`, `currentIndex: pictureIndex`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to swipe through the pictures, we again use a `ListView`. Here,
    each item (a simple `Image` element) will take the full size of its parent. When
    the component is loaded, even if `currentIndex` is correctly set, the view has
    to be updated to be positioned at the correct index. This is what we do in `pictureListView`
    with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update the position of the current visible item to `currentIndex`.
    So far so good. Nonetheless, when a `ListView` is created, the first thing it
    does is to initialize its delegate. A `ListView` has a `view` property, which
    is filled with the `delegate` content. That implies that the `ListView.view` (yes,
    it hurts) does not have any width in `Component.onCompleted()`. As a consequence,
    the `positionViewAtIndex()` function does... absolutely nothing. To prevent this
    behavior, we have to provide a default initial width to the delegate with the
    ternary expression `ListView.view.width == 0 ? parent.width : ListView.view.width`.
    The view will then have a default width on the first load and the `positionViewAtIndex()`
    function can happily move until `ListView.view` is properly loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: To swipe through each picture, we set the `snapMode` value of the `ListView`
    to `ListView.SnapOneItem`. Each fling will snap to the next or previous picture
    without continuing the motion.
  prefs: []
  type: TYPE_NORMAL
- en: The `Image` item of the delegate looks very much like the thumbnail version.
    The sole difference is the source property, where we request `PictureImageProvider`
    class with the `full` resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `PicturePage` opens, the correct `pictureName` property is displayed in
    the header. However, when the user flings to another picture, the name is not
    updated. To handle this, we have to detect the motion state. Add the following
    callbacks in `pictureListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `onMovementEnded()` class is triggered when the motion started by the swipe
    has ended. In this function, we update the `ListViewcurrentIndex` with the `itemIndex`
    of the visible item at the `contentX` and `contentY` coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The second function, `onCurrentItemChanged()`, is called upon the `currentIndex`
    update. It will simply update the `toolbarTitleLabel.text` with the picture name
    of the current item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display `PicturePage.qml`, the same `MouseArea` pattern is used in the `thumbnailList`
    delegate of `AlbumPage.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `PicturePage.qml` file is pushed on the `pageStack` and the needed
    parameters (`pictureName` and `pictureIndex`) are provided in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter brings closure to the development of the gallery application. We
    built a strong foundation with `gallery-core`, created a widget UI with `gallery-desktop`,
    and finally crafted a QML UI with `gallery-mobile`.
  prefs: []
  type: TYPE_NORMAL
- en: QML enables a very fast approach to UI development. Unfortunately, the technology
    is still young and rapidly changing. The integration with mobile OSes (Android,
    iOS) is under heavy development and we hope that it will lead to great mobile
    applications with Qt. For now, the inherent limits of a mobile cross-platform
    toolkit are still hard to overcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will take QML technology to new shores: the development of
    a snake game running on a Raspberry Pi.'
  prefs: []
  type: TYPE_NORMAL
