- en: Chapter 5.  Dominating the Mobile UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章  主导移动 UI
- en: In [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3.  Dividing Your Project
    and Ruling Your Code"), *Dividing Your Project and Ruling Your Code*, we created
    a strong core library to handle a picture gallery. We will now use this `gallery-core`
    library to create a mobile application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](part0034.xhtml#aid-10DJ42 "第 3 章。  划分项目并管理代码")，*划分项目并管理代码*中，我们创建了一个强大的核心库来处理图片库。现在我们将使用这个
    `gallery-core` 库来创建一个移动应用程序。
- en: We will teach you how to create a Qt Quick project from scratch. You will create
    custom Qt Quick views with QML. This chapter will also cover how your QML views
    can communicate with the C++ library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将教你如何从头开始创建 Qt Quick 项目。你将使用 QML 创建自定义 Qt Quick 视图。本章还将介绍你的 QML 视图如何与 C++
    库通信。
- en: At the end of this chapter, your gallery application will run on your mobile
    (Android or iOS) with a dedicated GUI compliant with touch devices. This application
    will offer the same features as the desktop application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你的画廊应用程序将在你的移动设备（Android 或 iOS）上运行，并具有符合触摸设备的专用 GUI。此应用程序将提供与桌面应用程序相同的功能。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Creating a Qt Quick project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Qt Quick 项目
- en: QML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML
- en: Qt Quick controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick 控件
- en: Qt for mobile (Android and iOS)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 移动（Android 和 iOS）
- en: Calling C++ functions from QML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 QML 调用 C++ 函数
- en: Starting with Qt Quick and QML
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Qt Quick 和 QML 开始
- en: 'Qt Quick is another way of creating applications with Qt. You can use it to
    create a complete application in place of Qt Widgets. The Qt Quick module provides
    transitions, animations, and visual effects. You can also customize graphical
    effects with shaders. This module is especially efficient at making software for
    devices using touchscreens. Qt Quick uses a dedicated language: Qt Modeling Language
    (QML). It is a declarative language; the syntax is close to the JSON (JavaScript
    Object Notation) syntax. Furthermore, QML also supports JavaScript expressions
    inline or in a separate file.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 是使用 Qt 创建应用程序的另一种方式。你可以用它来创建一个完整的应用程序，代替 Qt Widgets。Qt Quick 模块提供了过渡、动画和视觉效果。你还可以使用着色器自定义图形效果。此模块特别擅长制作使用触摸屏的设备软件。Qt
    Quick 使用一种专用语言：Qt 模型语言（QML）。它是一种声明性语言；其语法接近 JSON（JavaScript 对象表示法）语法。此外，QML 还支持内联或单独文件中的
    JavaScript 表达式。
- en: 'Let''s begin with a simple example of a Qt Quick application using QML. Create
    a new file called `main.qml` with this code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 QML 的一个简单的 Qt Quick 应用程序示例开始。创建一个名为 `main.qml` 的新文件，并使用以下代码片段：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Qt 5 provides a nice tool called `qmlscene` to prototype a QML user interface.
    You can find the binary file in your Qt installation folder, for example: `Qt/5.7/gcc_64/bin/qmlscene`.
    To load your `main.qml` file, you can run the tool and select the file, or use
    the CLI with the `.qml` file in an argument: `qmlscene main.qml`. You should see
    something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 5 提供了一个名为 `qmlscene` 的良好工具，用于原型设计 QML 用户界面。你可以在 Qt 安装文件夹中找到二进制文件，例如：`Qt/5.7/gcc_64/bin/qmlscene`。要加载你的
    `main.qml` 文件，你可以运行该工具并选择文件，或者使用 CLI 并在参数中使用 `.qml` 文件：`qmlscene main.qml`。你应该会看到类似这样的内容：
- en: '![Starting with Qt Quick and QML](img/image00380.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![从 Qt Quick 和 QML 开始](img/image00380.jpeg)'
- en: 'To use a Qt Quick module, you need to import it. The syntax is easy:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Qt Quick 模块，你需要导入它。语法很简单：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example we import `QtQuick`, which is the common module that will provide
    basic components (`Rectangle`, `Image`, `Text`) and we also import the `QtQuick.Window`
    module that will provide the main window application (`Window`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们导入了 `QtQuick`，这是一个提供基本组件（`Rectangle`、`Image`、`Text`）的通用模块，我们还导入了 `QtQuick.Window`
    模块，它将提供主窗口应用程序（`Window`）。
- en: 'A QML component can have properties. For example, we set the `width` property
    of the `Window` class to the value `640`. Here is the generic syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 QML 组件可以有属性。例如，我们将 `Window` 类的 `width` 属性设置为值 `640`。以下是通用的语法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now update `main.qml` file with some new rectangles:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新 `main.qml` 文件，添加一些新的矩形：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the visual result:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是视觉结果：
- en: '![Starting with Qt Quick and QML](img/image00381.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![从 Qt Quick 和 QML 开始](img/image00381.jpeg)'
- en: 'Your QML file describes the UI as a hierarchy of components. The hierarchy
    below the `Window` element is the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 QML 文件将 UI 描述为组件的层次结构。`Window` 元素以下的层次结构如下：
- en: Red `Rectangle`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色 `Rectangle`
- en: Green `Rectangle`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色 `Rectangle`
- en: Blue `Rectangle`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色 `Rectangle`
- en: Each nested item will always have its `x`, `y` coordinates relative to its parent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌套项都将始终相对于其父项具有其 `x`、`y` 坐标。
- en: 'To structure your application, you can build reusable QML components. You can
    easily create a new component. All QML components must have a single root item.
    Let''s build a new `MyToolbar` component by creating a new file called `MyToolbar.qml`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建你的应用程序结构，你可以构建可重用的QML组件。你可以轻松地创建一个新的组件。所有QML组件都必须有一个根项目。让我们通过创建一个名为`MyToolbar.qml`的新文件来构建一个新的`MyToolbar`组件：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The gray `Rectangle` element will be our root item used as background. We also
    created two items:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色的`Rectangle`元素将是我们用作背景的根项目。我们还创建了两个项目：
- en: A purple `Rectangle` element that can be identified with the ID `purpleRectangle`.
    The height of this item will be the height of its parent, that is, the gray `Rectangle`
    element.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以与ID`purpleRectangle`关联的紫色`Rectangle`元素。此项目的高度将是其父元素的高度，即灰色的`Rectangle`元素。
- en: A `Text` item. In this case, we use anchors. It will help us to layout items
    without using hardcoded coordinates. The left of the `Text` item will be aligned
    with the right of `purpleRectangle`, and the right of the `Text` item will be
    aligned with the right of the parent (the gray `Rectangle` element).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Text`元素。在这种情况下，我们使用锚点。它将帮助我们布局项目而不使用硬编码的坐标。`Text`元素的左侧将与`purpleRectangle`的右侧对齐，而`Text`元素的右侧将与父元素的右侧（灰色的`Rectangle`元素）对齐。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Qt Quick provides a lot of anchors: `left`, `horizontalCenter`, `right`, `top`, `verticalCenter`,
    and `bottom`. You can also use convenience anchors such as `fill` or `centerIn`.
    For more information on anchors, take a look at [http://doc.qt.io/qt-5/qtquick-positioning-anchors.html](http://doc.qt.io/qt-5/qtquick-positioning-anchors.html).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick提供了许多锚点：`left`、`horizontalCenter`、`right`、`top`、`verticalCenter`和`bottom`。你还可以使用便利锚点，如`fill`或`centerIn`。有关锚点的更多信息，请参阅[http://doc.qt.io/qt-5/qtquick-positioning-anchors.html](http://doc.qt.io/qt-5/qtquick-positioning-anchors.html)。
- en: 'You can use `MyToolbar` in your window by updating your `main.qml`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更新你的`main.qml`来在你的窗口中使用`MyToolbar`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We set the width to the parent width. Like this, the toolbar fills the window''s
    width. Here is the result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将宽度设置为父级宽度。就像这样，工具栏填满了窗口的宽度。以下是结果：
- en: '![Starting with Qt Quick and QML](img/image00382.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![从Qt Quick和QML开始](img/image00382.jpeg)'
- en: 'Anchors are great to align specific items, but if you want to layout several
    items in grid, row, or column fashion, you can use the `QtQuick.layouts` module.
    Here is an example of the updated `main.qml`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点非常适合对齐特定项目，但如果你想要以网格、行或列的形式布局多个项目，你可以使用`QtQuick.layouts`模块。以下是一个更新后的`main.qml`示例：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的结果：
- en: '![Starting with Qt Quick and QML](img/image00383.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![从Qt Quick和QML开始](img/image00383.jpeg)'
- en: As you can see, we use a `RowLayout` element that fits under the `myToolbar`
    and to its parent, a `Window` element. This item provides a way to dynamically
    layout items in a row. Qt Quick also provides other layout items: `GridLayout`
    and `ColumnLayout`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了一个`RowLayout`元素，它位于`myToolbar`下方，以及其父元素`Window`元素。此项目提供了一种动态布局行中项目的方法。Qt
    Quick还提供了其他布局元素：`GridLayout`和`ColumnLayout`。
- en: 'Your custom component can also expose custom properties that can be modified
    outside of the component itself. You can do it by adding the `property` attribute.
    Please update `MyToolbar.qml`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你的自定义组件也可以公开自定义属性，这些属性可以在组件外部修改。你可以通过添加`property`属性来实现。请更新`MyToolbar.qml`：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `iconColor` is a really new property that is a fully-fledged variable. We
    also update the `Rectangle` attribute to use this property as `color`. The `title`
    property is only an `alias`, you can see it as a pointer to update the `label.text`
    property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`iconColor`是一个全新的属性，它是一个完整的变量。我们还更新了`Rectangle`属性以使用此属性作为`color`。`title`属性只是一个`alias`，你可以将其视为更新`label.text`属性的指针。'
- en: 'From outside you can use these attributes with the same syntax; please update
    the `main.qml` file with the following snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部，你可以使用相同的语法使用这些属性；请使用以下片段更新`main.qml`文件：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should get a nice updated toolbar like this one:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个像这样的漂亮的更新后的工具栏：
- en: '![Starting with Qt Quick and QML](img/image00384.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![从Qt Quick和QML开始](img/image00384.jpeg)'
- en: We have covered the basics of QML, now we are going to proceed to mobile application
    development using QML.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了QML的基础知识，现在我们将继续使用QML进行移动应用程序开发。
- en: Checking your development environment
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查你的开发环境
- en: 'To be able to create a Qt application for Android, you must have:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够为Android创建Qt应用程序，你必须有：
- en: A device with Android v2.3.3 (API 10) or later
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Android v2.3.3（API 10）或更高版本的设备
- en: Android SDK
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android SDK
- en: Android NDK
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android NDK
- en: JDK
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK
- en: Qt Prebuilt Components for Android x86 (from the Qt Maintenance Tool)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt为Android预构建的组件x86（来自Qt维护工具）
- en: Qt Prebuilt Components for Android ARMv7 (from the Qt Maintenance Tool)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt预构建组件用于Android ARMv7（来自Qt维护工具）
- en: 'To be able to create a Qt application for iOS, you must have:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够为iOS创建Qt应用程序，您必须具备：
- en: A device with iOS 5.0 or later
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭载iOS 5.0或更高版本的设备
- en: A Mac desktop computer
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Mac桌面电脑
- en: Xcode
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcode
- en: Qt for iOS (from Qt Maintenance Tool)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt for iOS（来自Qt维护工具）
- en: 'When starting, Qt Creator will detect and create Android and iOS Qt kits. You
    can check your existing kits from **Tools** | **Options** | **Build & Run** | **Kits**,
    as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动时，Qt Creator将检测并创建Android和iOS Qt工具包。您可以从**工具** | **选项** | **构建和运行** | **工具包**检查您现有的工具包，如下面的截图所示：
- en: '![Checking your development environment](img/image00385.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![检查您的开发环境](img/image00385.jpeg)'
- en: Creating a Qt Quick project
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Qt Quick项目
- en: 'This chapter will follow the same project structure we covered in [Chapter
    4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop UI"), *Conquering
    the Desktop UI*: a parent project `ch05-gallery-mobile.pro` will host our two
    subprojects, `gallery-core` and the new `gallery-mobile`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将遵循我们在[第4章](part0040.xhtml#aid-164MG2 "第4章. 征服桌面UI")中介绍的项目结构，即*征服桌面UI*：一个父项目`ch05-gallery-mobile.pro`将包含我们的两个子项目，`gallery-core`和新的`gallery-mobile`。
- en: In Qt creator, you can create a Qt Quick subproject from **File** | **New File
    or Project** | **Application** | **Qt Quick Controls Application** | **Choose**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Creator中，您可以从**文件** | **新建文件或项目** | **应用程序** | **Qt Quick Controls应用程序**
    | **选择**创建一个Qt Quick子项目。
- en: 'The wizard will allow you to customize your project creation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 向导将允许您自定义项目创建：
- en: Location
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置
- en: Choose a project name (`gallery-mobile`) and a location
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个项目名称（`gallery-mobile`）和位置
- en: Details
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细信息
- en: Deselect **With ui.qml file**
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消选择**包含.ui.qml文件**
- en: Deselect **Enable native styling**
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消选择**启用原生样式**
- en: Kits
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具包
- en: Select your desktop kit
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您的桌面工具包
- en: Select at least one mobile kit
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少选择一个移动工具包
- en: Summary
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要
- en: Be sure to add gallery-mobile as a subproject of `ch05-gallery-mobile.pro`
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保将gallery-mobile添加为`ch05-gallery-mobile.pro`的子项目
- en: Let's take some time to explain why we created our project with these options.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花些时间解释为什么我们选择这些选项来创建我们的项目。
- en: The first thing to analyze is the application template. By default, Qt Quick
    only provides basic QML components (`Rectangle`, `Image`, `Text`, and so on).
    Advanced components will be handled by Qt Quick modules. For this project we will
    use Qt Quick Controls (`ApplicationWindow`, `Button`, `TextField`, and so on).
    That is why we chose to begin with a **Qt Quick Controls application**. Keep in
    mind that you can always import and use Qt Quick modules later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要分析的是应用程序模板。默认情况下，Qt Quick仅提供基本的QML组件（`Rectangle`、`Image`、`Text`等）。高级组件将由Qt
    Quick模块处理。对于本项目，我们将使用Qt Quick Controls（`ApplicationWindow`、`Button`、`TextField`等）。这就是我们选择从**Qt
    Quick Controls应用程序**开始的原因。请记住，您始终可以在以后导入和使用Qt Quick模块。
- en: In this chapter, we will not use the Qt Quick Designer. As a consequence, `.ui.qml`
    files are not required. Even if the designer can help a lot, it is good to understand
    and write QML files yourself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不使用Qt Quick Designer。因此，`.ui.qml`文件不是必需的。尽管设计师可以提供很多帮助，但了解并自己编写QML文件是很好的。
- en: The desktop "native styling" is disabled because this project mainly targets
    mobile platforms. Moreover, disabling "native styling" avoids heavy dependency
    on the Qt widgets module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面“原生样式”被禁用，因为本项目主要针对移动平台。此外，禁用“原生样式”可以避免对Qt小部件模块的过度依赖。
- en: 'Finally, we select at least two kits. The first one is our desktop kit. The
    other kits are the mobile platforms you target. We usually use the following development
    workflow:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择至少两个工具包。第一个是我们的桌面工具包。其他工具包是您要针对的移动平台。我们通常使用以下开发工作流程：
- en: Fast iterations on desktop
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在桌面上的快速迭代
- en: Check and fix behavior on mobile emulator/simulator
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动模拟器/模拟器上检查和修复行为
- en: Real test on the mobile device
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上进行真实测试
- en: Deployment on a real device is generally longer so you can do most development
    with the desktop kit. The mobile kits will allow you to check your application
    behavior on a real mobile device or on an emulator (for example with a Qt Android
    x86 kit).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实设备上的部署通常需要更长的时间，因此您可以使用桌面工具包进行大部分开发。移动工具包将允许您在真实移动设备或模拟器（例如使用Qt Android x86工具包）上检查应用程序的行为。
- en: 'Let''s talk about the files automatically generated by the wizard. Here is
    the `main.cpp` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论向导自动生成的文件。以下是`main.cpp`文件：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use here `QGuiApplication` and not `QApplication` because we do not use Qt
    widgets in this project. Then, we create the QML engine and load `qrc:/mail.qml`.
    As you may have guessed (with the `qrc:/` prefix), this QML file is in a Qt resource
    file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `QGuiApplication` 而不是 `QApplication`，因为我们在这个项目中不使用 Qt 小部件。然后，我们创建 QML
    引擎并加载 `qrc:/mail.qml`。正如你可能已经猜到的（带有 `qrc:/` 前缀），这个 QML 文件位于 Qt 资源文件中。
- en: 'You can open the `qml.qrc` file to find the `main.qml`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开 `qml.qrc` 文件来找到 `main.qml`：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing to do is to import types used in the file. Notice the module
    version at the end of each import. The `QtQuick` module will import basic QML
    elements (`Rectangle`, `Image`, and so on) while the `QtQuick.Controls` module
    will import advanced QML elements from the `QtQuick Controls` submodule (`ApplicationWindow`, `MenuBar`, `MenuItem`, `Label`,
    and so on).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是导入文件中使用的类型。注意每个导入语句末尾的模块版本。`QtQuick` 模块将导入基本的 QML 元素（`Rectangle`、`Image`
    等），而 `QtQuick.Controls` 模块将导入来自 `QtQuick Controls` 子模块的高级 QML 元素（`ApplicationWindow`、`MenuBar`、`MenuItem`、`Label`
    等）。
- en: Then, we define the root element of type `ApplicationWindow`. It provides a
    top-level application window with the following items: `MenuBar`, `ToolBar` and `StatusBar`.
    The properties `visible`, `width`, `height`, and `title` of `ApplicationWindow`
    are primitive types. The syntax is simple and intelligible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了类型为 `ApplicationWindow` 的根元素。它提供了一个顶级应用程序窗口，包含以下项目：`MenuBar`、`ToolBar`
    和 `StatusBar`。`ApplicationWindow` 的 `visible`、`width`、`height` 和 `title` 属性是原始类型。语法简单易懂。
- en: The `menuBar` property is more complex. This `MenuBar` property is composed
    of a `Menu` file, itself composed of two `MenuItems`: `Open` and `Exit`. A `MenuItem`
    emits a `triggered()`signal each time it is activated. In this case, the `MenuItem`
    file will log a message on the console. The exit `MenuItem` terminates the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`menuBar` 属性更复杂。这个 `MenuBar` 属性由一个 `Menu` 文件组成，该文件本身由两个 `MenuItems` 组成：`Open`
    和 `Exit`。每次激活 `MenuItem` 时，它都会发出一个 `triggered()` 信号。在这种情况下，`MenuItem` 文件将在控制台记录一条消息。退出
    `MenuItem` 将终止应用程序。'
- en: Finally, a `Label` displaying "Hello World" is added in the content area of
    our `ApplicationWindow` type. Positioning items with anchors is useful. In our
    case the label is centered vertically and horizontally in its parent, `ApplicationWindow`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `ApplicationWindow` 类型的内容区域添加了一个显示 "Hello World" 的 `Label`。使用锚点定位项目很有用。在我们的例子中，标签在父元素
    `ApplicationWindow` 中垂直和水平居中。
- en: Before going ahead, check that this sample runs correctly on your desktop and
    on your mobile.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保此示例在您的桌面和移动设备上都能正确运行。
- en: Preparing your Qt Quick gallery entry point
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的 Qt Quick 图库入口点
- en: 'First of all, you need to link this project to our `gallery-core` library.
    We already covered how to link an internal library in [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*. For more
    details, refer to it. This is the updated `gallery-mobile.pro` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将此项目链接到我们的 `gallery-core` 库。我们已经在 [第 4 章](part0040.xhtml#aid-164MG2 "第
    4 章。征服桌面 UI") 中介绍了如何链接内部库，*征服桌面 UI*。更多详情请参阅该章节。这是更新后的 `gallery-mobile.pro` 文件：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Please notice that we made several changes here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里做了几处修改：
- en: We added the `sql` module to deploy the dependency on your mobile device
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `sql` 模块以在移动设备上部署依赖项
- en: We added the `svg` module for the button icons
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为按钮图标添加了 `svg` 模块
- en: The `qml.qrc` file has been renamed in `gallery.qrc`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qml.qrc` 文件已重命名为 `gallery.qrc`'
- en: We linked the `gallery-core` library
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们链接了 `gallery-core` 库
- en: By default, the `sql` shared object (`libQt5Sql.so`) will not be deployed on
    your Android x86 device. You have to explicitly include it in your `.pro` file.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`sql` 共享对象（`libQt5Sql.so`）不会部署到你的 Android x86 设备上。你必须明确将其包含在你的 `.pro`
    文件中。
- en: 'You can now use classes from the `gallery-core` library in our `gallery-mobile`
    application. Let''s see how to bind C++ models with QML. This is the updated `main.cpp`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在我们的 `gallery-mobile` 应用程序中使用 `gallery-core` 库中的类。让我们看看如何将 C++ 模型与 QML
    绑定。这是更新后的 `main.cpp`：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our models will be instantiated in C++ and exposed to QML using the root `QQmlContext`
    object. The `setContextProperty()` function allows us to bind a C++ `QObject`
    to a QML property. The first argument will be the QML property name. We are only
    binding a C++ object to a QML property; the context object does not take ownership
    of this object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 C++ 中实例化模型，并通过根 `QQmlContext` 对象将其暴露给 QML。`setContextProperty()` 函数允许我们将
    C++ 的 `QObject` 绑定到 QML 属性。第一个参数将是 QML 属性名称。我们只绑定一个 C++ 对象到 QML 属性；上下文对象不拥有此对象。
- en: 'Let''s now talk about the mobile application itself. We will define three pages
    with specific roles:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈移动应用程序本身。我们将定义三个具有特定角色的页面：
- en: '`AlbumListPage`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlbumListPage`'
- en: Displays existing albums
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示现有专辑
- en: Album creation
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑创建
- en: Album selection
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑选择
- en: '`AlbumPage`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlbumPage`'
- en: Displays existing pictures as thumbnails
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以缩略图形式显示现有图片
- en: Adds pictures in album
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在专辑中添加图片
- en: Album rename
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑重命名
- en: Album deletion
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑删除
- en: Picture selection
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片选择
- en: '`PicturePage`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PicturePage`'
- en: Displays selected picture
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所选图片
- en: Picture selection
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片选择
- en: Picture deletion
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片删除
- en: 'To handle the navigation, we will use a `StackView` component from Qt Quick
    Controls. This QML component implements a stack-based navigation. You can push
    a page when you want to display it. When the user requests to go back, you can
    pop it. Here is the workflow using a `StackView` component for our gallery mobile
    application. The page with the solid border is the page currently displayed on
    screen:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理导航，我们将使用来自 Qt Quick Controls 的`StackView`组件。这个 QML 组件实现了基于堆栈的导航。当你想要显示一个页面时，你可以将其推入。当用户请求返回时，你可以将其弹出。以下是使用`StackView`组件为我们的图库移动应用程序创建的工作流程。带有实线边框的页面是当前屏幕上显示的页面：
- en: '![Preparing your Qt Quick gallery entry point](img/image00386.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![准备你的 Qt Quick 图库入口点](img/image00386.jpeg)'
- en: 'This is the implementation of `main.qml`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main.qml`的实现：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This main file is really simple. The application is constructed around the `StackView`
    component. We set the `id` property to allow our `StackView` to be identified
    and referred to by other QML objects. The `anchors` property will set `stackView`
    to fill its parent, the `ApplicationWindow` type. Finally, we set the `initialItem`
    property to a page, `AlbumListPage` that will be implemented soon.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主文件非常简单。应用程序是围绕`StackView`组件构建的。我们将`id`属性设置为允许我们的`StackView`被其他 QML 对象识别和引用。`anchors`属性将`stackView`设置为填充其父元素，即`ApplicationWindow`类型。最后，我们将`initialItem`属性设置为即将实现的页面`AlbumListPage`。
- en: On Android, `onClosing` will be executed each time the user presses the back
    button. To mimic a native Android application, we will first pop the last stacked
    page before really closing the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上，每次用户按下返回按钮时，`onClosing`都会执行。为了模仿原生 Android 应用程序，我们将在真正关闭应用程序之前首先弹出最后一个堆叠的页面。
- en: At the top of the file, we define a `property alias` for the `stackView`. A `property
    alias` is a simple reference to another existing property. This alias will be
    useful to access `stackView` from other QML components. To prevent a QML component
    to crush the `stackView` we are using the `readonly` keyword. After initialization,
    the components can access the property but not change its value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，我们为`stackView`定义了一个`property alias`。一个`property alias`是对另一个现有属性的简单引用。这个别名将非常有用，可以从其他
    QML 组件访问`stackView`。为了防止 QML 组件破坏我们正在使用的`stackView`，我们使用了`readonly`关键字。初始化后，组件可以访问属性但不能更改其值。
- en: Displaying albums with ListView
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ListView显示专辑
- en: 'Let''s make our first page for this mobile application! Create a file in `gallery.qrc`
    called `AlbumListPage.qml`. Here is the page header implementation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个移动应用程序创建第一个页面！在`gallery.qrc`文件中创建一个名为`AlbumListPage.qml`的文件。以下是页面头部的实现：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A `Page` is a container control with a header and footer. In this application,
    we will only use the header item. We assign a `ToolBar` to the `header` property.
    The height of this toolbar will be handled by Qt and will be adjusted depending
    on the target platform. In this first simple implementation, we only put a `Label`
    displaying the text "Albums".
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page`是一个带有头部和脚部的容器控件。在这个应用程序中，我们只会使用头部项。我们将`ToolBar`分配给`header`属性。这个工具栏的高度将由
    Qt 处理，并根据目标平台进行调整。在这个第一个简单实现中，我们只放置了一个显示文本“专辑”的`Label`。'
- en: 'Add a `ListView` element to this page after the `header` initialization:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`header`初始化之后，向此页面添加一个`ListView`元素：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Qt Quick `ListView` is the Qt Widget `QListView` equivalent. It displays
    a list of items from a provided model. We set the `model` property to value `albumModel`.
    This refers to the C++ model from `main.cpp` file accessible from QML because
    we used the `setContextProperty()` function. In Qt Quick, you must provide a delegate
    to describe how a row will be displayed. In this case, a row will only display
    the album''s name with a `Text` item. Accessing the album''s name in QML is easy
    because our `AlbumModel` model exposes its role list to QML. Let''s refresh your
    memory concerning the overridden `roleNames()` function of `AlbumModel`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick的`ListView`是Qt小部件`QListView`的等价物。它显示从提供的模型中提供的项目列表。我们将`model`属性设置为值`albumModel`。这指的是从`main.cpp`文件中可从QML访问的C++模型，因为我们使用了`setContextProperty()`函数。在Qt
    Quick中，您必须提供一个委托来描述行将如何显示。在这种情况下，一行将只显示相册名称，使用`Text`项目。在QML中访问相册名称很容易，因为我们的`AlbumModel`模型向QML公开其角色列表。让我们回顾一下`AlbumModel`的覆盖`roleNames()`函数：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So each time your delegate from Qt Quick uses the `name` role, it will call
    the `AlbumModel` function `data()` with the correct role integer and return the
    correct album name string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次您的Qt Quick委托使用`name`角色时，它将调用`AlbumModel`函数`data()`，并带有正确的角色整数，并返回正确的相册名称字符串。
- en: 'To handle the mouse, click on a row and add a `MouseArea` element on the delegate:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理鼠标，点击一行并在委托上添加一个`MouseArea`元素：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `MouseArea` is an invisible item that can be used with any visible item
    to handle mouse events. This also applies to a simple touch on a phone touch screen.
    Here we tell the `MouseArea` element to take the full area of the parent `Rectangle`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseArea`是一个不可见的项目，可以与任何可见项目一起使用来处理鼠标事件。这也适用于手机触摸屏上的简单触摸。在这里，我们告诉`MouseArea`元素占用父`Rectangle`的整个区域。'
- en: In our case, we only perform tasks on the `clicked` signal. We update the `currentIndex`
    of the `ListView` with `index`. This `index` is a special role containing the
    index of the item in the model.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只在`clicked`信号上执行任务。我们使用`index`更新`ListView`的`currentIndex`。这个`index`是一个特殊角色，包含模型中项目的索引。
- en: When the user clicks, we will tell `pictureModel` to load the selected album
    with the `pictureModel.setAlbumId(id)` call. We will see soon how QML can call
    C++ methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击时，我们将通过`pictureModel.setAlbumId(id)`调用告诉`pictureModel`加载选定的相册。我们很快就会看到QML如何调用C++方法。
- en: 'Finally, we push `AlbumPage` on `pageStack` property. The `push()` function
    allows us to set a list of QML properties using a {`key: value`, ... } syntax.
    Each property will be copied into the pushed item. Here the `name` and the `index`
    will be copied in the `albumName` and `albumRowIndex` properties of `AlbumPage`.
    It is a simple yet powerful way to instantiate a QML page with properties arguments.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们将`AlbumPage`推送到`pageStack`属性。`push()`函数允许我们使用{`key: value`, ... }语法设置一系列QML属性。每个属性都将复制到推入的项目中。在这里，`name`和`index`将复制到`AlbumPage`的`albumName`和`albumRowIndex`属性中。这是一种简单而强大的方式，可以通过属性参数实例化一个QML页面。'
- en: 'From your QML code, you can only call some specific C++ methods:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的QML代码中，您只能调用一些特定的C++方法：
- en: Properties (using `Q_PROPERTY`)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性（使用`Q_PROPERTY`）
- en: Public slot
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共槽
- en: Function decorated as invokable (using `Q_INVOKABLE`)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰为可调用的函数（使用`Q_INVOKABLE`）
- en: 'In this case we will decorate `PictureModel::setAlbumId()` as `Q_INVOKABLE`,
    please update the `PictureModel.h` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们将`PictureModel::setAlbumId()`装饰为`Q_INVOKABLE`，请更新`PictureModel.h`文件：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Theming the application with a QML singleton
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QML单例主题化应用程序
- en: Styling and theming a QML application can be done in various ways. In this chapter,
    we will declare a QML singleton with the theme data used by custom components.
    Moreover, we will also create a custom `Page` component to handle the toolbar
    and its default item (back button and page's title).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: QML应用程序的样式和主题化可以通过多种方式完成。在本章中，我们将声明一个带有主题数据的QML单例，这些数据由自定义组件使用。此外，我们还将创建一个自定义的`Page`组件来处理工具栏及其默认项（返回按钮和页面标题）。
- en: 'Please create a new `Style.qml` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请创建一个新的`Style.qml`文件：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We declare a `QtObject` component that will only contain our theme properties.
    A `QtObject` is a non-visual QML component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个只包含我们的主题属性的`QtObject`组件。`QtObject`是一个非视觉的QML组件。
- en: 'Declaring a singleton type in QML requires two steps. First you need to use
    the `pragma singleton`, it will indicate the use of a single instance of the component.
    The second step is to register it. This can be done in C++ or by creating a `qmldir`
    file. Let''s see the second step. Create a new plain-text file called `qmldir`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 中声明单例类型需要两个步骤。首先，你需要使用 `pragma singleton`，这将指示组件的单例使用。第二步是注册它。这可以通过 C++
    或创建一个 `qmldir` 文件来完成。让我们看看第二步。创建一个新的纯文本文件，命名为 `qmldir`：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This simple line will declare a QML `singleton` type named `Style` with the
    version 1.0 from the file named `Style.qml`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这条简单的语句将声明一个名为 `Style` 的 QML `singleton` 类型，版本为 1.0，来自名为 `Style.qml` 的文件。
- en: 'It is now time to use these theme properties in custom components. Let''s see
    a simple example. Create a new QML file called `ToolBarTheme.qml`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在自定义组件中使用这些主题属性了。让我们看看一个简单的例子。创建一个新的 QML 文件，命名为 `ToolBarTheme.qml`：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This QML object describes a customized `ToolBar`. Here, the `background` element
    is a simple `Rectangle` with our color. We can easily access our singleton `Style`
    and its theme property using `Style.toolbarBackground`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 QML 对象描述了一个自定义的 `ToolBar`。在这里，`background` 元素是一个简单的 `Rectangle`，带有我们的颜色。我们可以通过
    `Style.toolbarBackground` 容易地访问我们的单例 `Style` 和其主题属性。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: QML Singletons require an explicit import to load the `qmldir` file. The `import
    "."` is a workaround for this Qt bug. For more information, please check [https://bugreports.qt.io/browse/QTBUG-34418](https://bugreports.qt.io/browse/QTBUG-34418).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: QML 单例需要显式导入来加载 `qmldir` 文件。`import "."` 是解决这个 Qt 错误的一个方法。更多信息，请查看 [https://bugreports.qt.io/browse/QTBUG-34418](https://bugreports.qt.io/browse/QTBUG-34418)。
- en: 'We will now create a QML file `PageTheme.qml`, with the aim of containing all
    the code related to the page''s toolbar and theme:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个名为 `PageTheme.qml` 的 QML 文件，目的是包含与页面工具栏和主题相关的所有代码：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This `PageTheme` element will customize the page''s header. We use our previously
    created `ToolBarTheme`. This toolbar only contains a `RowLayout` element to display
    items horizontally in one row. This layout contains three elements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `PageTheme` 元素将自定义页面的头部。我们使用之前创建的 `ToolBarTheme`。这个工具栏只包含一个 `RowLayout` 元素，用于在一行中水平显示项目。这个布局包含三个元素：
- en: '`ToolButton`: This is the "back" that displays an image from `gallery.qrc`
    and pops the current page if required'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolButton`：这是显示来自 `gallery.qrc` 的图像并弹出当前页面的 "返回" 按钮'
- en: '`Label`: This is the element that displays the page title'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`：这是显示页面标题的元素'
- en: '`Loader`: This is the element that allows a page to dynamically add specific
    items in this generic toolbar'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loader`：这是允许页面在通用工具栏中动态添加特定元素的元素'
- en: The `Loader` element owns a `sourceComponent` property. In this application,
    this property can be assigned by `PageTheme` pages to add specific buttons. These
    buttons will be instantiated at runtime.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loader` 元素拥有一个 `sourceComponent` 属性。在这个应用程序中，这个属性可以通过 `PageTheme` 页面分配，以添加特定的按钮。这些按钮将在运行时实例化。'
- en: The `PageTheme` pages also contain a `Rectangle` element that fits the parent
    and configures the page background color using the `Style.pageBackground`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTheme` 页面还包含一个 `Rectangle` 元素，它适合父元素并使用 `Style.pageBackground` 配置页面背景颜色。'
- en: 'Now that our `Style.qml` and `PageTheme.qml` files are ready, we can update
    the `AlbumListPage.qml` file to use it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 `Style.qml` 和 `PageTheme.qml` 文件，我们可以更新 `AlbumListPage.qml` 文件来使用它：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that `AlbumListPage` is a `PageTheme` element, we do not manipulate `header`
    directly. We only need to set the property `toolbarTitle` to display a nice "Albums"
    text in the toolbar. We can also enjoy nice colors using properties from the `Style`
    singleton.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`AlbumListPage` 是一个 `PageTheme` 元素，我们不再直接操作 `header`。我们只需要设置属性 `toolbarTitle`
    来在工具栏中显示一个漂亮的 "Albums" 文本。我们还可以使用 `Style` 单例的属性来享受漂亮的颜色。
- en: By centralizing the theme properties in a single file, you can easily change
    the look and feel of your application. The source code of the project also contains
    a dark theme.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将主题属性集中在一个文件中，你可以轻松地更改应用程序的外观和感觉。项目的源代码还包含一个暗色主题。
- en: Loading a database on mobile
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在移动设备上加载数据库
- en: 'Before continuing the UI implementation, we have to take care of the database
    deployment on mobile. Spoiler: this will not be fun.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续 UI 实现之前，我们必须注意在移动设备上数据库部署的问题。剧透：这不会很有趣。
- en: 'We have to jump back to `DatabaseManager.cpp` in the `gallery-core` project:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须回到 `gallery-core` 项目的 `DatabaseManager.cpp`：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whereas on Desktop, the SQLite3 database is created at the instruction `mDatabase->setDatabaseName()`,
    on mobile it does not work at all. This is due to the fact that the filesystem
    is very specific on each mobile platform (Android and iOS). An application has
    only access to a narrow sandbox where it cannot mess with the rest of the filesystem.
    All the files inside the application directory must have specific file permissions.
    If we let SQLite3 create the database file, it will not have the right permission
    and the OS will block the database from opening.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面环境中，SQLite3数据库是在`mDatabase->setDatabaseName()`指令下创建的，但在移动设备上则完全不工作。这是由于每个移动平台（Android和iOS）的文件系统都非常特定。应用程序只能访问一个狭窄的沙盒，它不能干扰文件系统的其余部分。应用程序目录中的所有文件都必须具有特定的文件权限。如果我们让SQLite3创建数据库文件，它将没有正确的权限，操作系统将阻止数据库打开。
- en: As a consequence, the database will not be properly created and your data cannot
    be persisted. When using the native API, this is not a problem since the OS takes
    care of the proper configuration of the database. Because we are developing with
    Qt, we do not have easy access to this API (except by using JNI or other black
    magic). A workaround is to embed a "ready-to-use" database in the application's
    package and copy it at the right filesystem path with the correct rights.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据库将无法正确创建，你的数据也无法持久化。当使用原生API时，这不是问题，因为操作系统会负责数据库的正确配置。由于我们使用Qt进行开发，我们无法轻松访问此API（除非使用JNI或其他黑魔法）。一种解决方案是将一个“即用”数据库嵌入到应用程序包中，并将其复制到正确的文件系统路径，并赋予正确的权限。
- en: This database should contain an empty created database without any content.
    The database is available in the source code of the chapter (you can also generate
    it from the source code of [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4. 
    Conquering the Desktop UI"), *Conquering the Desktop UI*). You can add it to the `gallery.qrc`
    file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据库应包含一个空的已创建数据库，没有任何内容。该数据库位于该章节的源代码中（你也可以从[第4章](part0040.xhtml#aid-164MG2
    "第4章. 征服桌面UI")的源代码中生成，*征服桌面UI*）。你可以将其添加到`gallery.qrc`文件中。
- en: 'Because our layers are clearly defined, we just have to modify the `DatabaseManager::instance()`
    implementation to handle this case:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的层定义清晰，我们只需修改`DatabaseManager::instance()`的实现来处理这种情况：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We first retrieve the platform-specific path of the application with a nifty
    Qt class: `QStandardPaths`. This class return paths for multiple types (`AppLocalDataLocation`, `DocumentsLocation`, `PicturesLocation`,
    and so on). The database should be stored in the application data directory. If
    the file does not exist, we copy it from our assets.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一个巧妙的Qt类`QStandardPaths`检索应用程序的平台特定路径。此类返回多种类型的路径（`AppLocalDataLocation`、`DocumentsLocation`、`PicturesLocation`等）。数据库应存储在应用程序数据目录中。如果文件不存在，我们从我们的资源中复制它。
- en: Finally, the permissions of the file are modified to ensure that the OS does
    not block the opening of the database (due to permissions not being restrictive
    enough).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改文件的权限以确保操作系统不会因为权限不够严格而阻止数据库的打开。
- en: When everything is done, the `DatabaseManager singleton` is instantiated with
    the correct database file path and the constructor can open this database transparently.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切完成后，`DatabaseManager单例`将使用正确的数据库文件路径实例化，构造函数可以透明地打开此数据库。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the iOS Simulator, the `QStandardPaths::writableLocation()` function will
    not return the proper path. Since iOS 8, the simulator's storage path on the host
    has changed and Qt does not reflect this. For more information, please check out [https://bugreports.qt.io/browse/QTCREATORBUG-13655](https://bugreports.qt.io/browse/QTCREATORBUG-13655).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS模拟器中，`QStandardPaths::writableLocation()`函数不会返回正确的路径。自iOS 8以来，模拟器在主机上的存储路径已更改，Qt没有反映这一点。有关更多信息，请参阅[https://bugreports.qt.io/browse/QTCREATORBUG-13655](https://bugreports.qt.io/browse/QTCREATORBUG-13655)。
- en: These workarounds were not trivial. This shows the limitations of a cross-platform
    application on mobile. Each platform has its own very specific way of handling
    the filesystem and deploying its content. Even if we manage to write platform
    agnostic code in QML, we still have to deal with differences between the OSes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案并不简单。这显示了跨平台应用程序在移动设备上的局限性。每个平台都有自己非常特定的处理文件系统和部署内容的方式。即使我们设法在QML中编写平台无关的代码，我们仍然必须处理操作系统之间的差异。
- en: Creating a new album from a custom InputDialog
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从自定义InputDialog创建新相册
- en: The `AlbumListPage` needs some data to display. The next step is to be able
    to add a new album. To do this, at some point we will have to call an `AlbumModel`
    function from QML to add this new album. Before building the UI, we have to make
    a small modification in `gallery-core`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumListPage` 需要一些数据来显示。下一步是能够添加一个新的专辑。为此，在某个时刻，我们将不得不从 QML 中调用 `AlbumModel`
    函数来添加这个新专辑。在构建 UI 之前，我们不得不在 `gallery-core` 中进行一些小的修改。'
- en: 'The `AlbumModel` function is already available in QML. However, we cannot directly
    call `AlbumModel::addAlbum(const Album& album)` from the QML code; the QML engine
    will not recognize the function and will throw an error **TypeError: Property
    ''addAlbum'' of object AlbumModel(...) is not a function**. This can be fixed
    by simply decorating the desired function with the `Q_INVOKABLE` macro (as we
    did for `PictureModel::setAlbumId()`).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumModel` 函数已经在 QML 中可用。然而，我们无法直接从 QML 代码中调用 `AlbumModel::addAlbum(const
    Album& album)`；QML 引擎将不会识别该函数并抛出错误 **TypeError: Property ''addAlbum'' of object
    AlbumModel(...) is not a function**。这可以通过简单地用 `Q_INVOKABLE` 宏装饰所需的函数来修复（就像我们对
    `PictureModel::setAlbumId()` 所做的那样）。'
- en: 'Nonetheless, there is another issue here: `Album` is a C++ class which is not
    recognized in QML. If we wanted to have full access to `Album` in QML, it would
    involve important modifications to the class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这里还有一个问题：`Album` 是一个在 QML 中不被识别的 C++ 类。如果我们想在 QML 中完全访问 `Album`，这将涉及到对类的重大修改：
- en: Force `Album` class to inherit from the `QObject` class.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制 `Album` 类继承自 `QObject` 类。
- en: Add a `Q_PROPERTY` macro to specify which property of the class should be accessible
    from QML.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 `Q_PROPERTY` 宏来指定类中哪个属性应该可以从 QML 访问。
- en: Add multiple constructors (copy constructor, `QObject* parent`, and so on).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多个构造函数（复制构造函数、`QObject* parent` 等）。
- en: Force `AlbumModel::addAlbum()` function to take an `Album*` rather than an `Album&`.
    For complex objects (that is, not primitive types), QML can only handle pointers.
    This is not a big problem, but using references instead of pointers tends to make
    the code safer.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制 `AlbumModel::addAlbum()` 函数接受一个 `Album*` 而不是 `Album&`。对于复杂对象（即非基本类型），QML
    只能处理指针。这并不是一个大问题，但使用引用而不是指针往往会使代码更安全。
- en: 'These modifications are perfectly reasonable if the class is heavily manipulated
    in QML. Our use case is very limited: we only want to create a new album. Throughout
    the application, we will rely on the native Model/View API to display the album
    data and nothing specific to `Album` will be used.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类在 QML 中被大量操作，这些修改是完全合理的。我们的用例非常有限：我们只想创建一个新的专辑。在整个应用程序中，我们将依赖于本地的 Model/View
    API 来显示专辑数据，而不会使用 `Album` 的任何特定功能。
- en: 'For all these reasons, we will simply add a wrapper function in `AlbumModel`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，我们将在 `AlbumModel` 中简单地添加一个包装函数：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new function `addAlbumFromName()` just wraps the call to `addAlbum()` with
    the desired album `name` parameter. It can be called from the QML with the `Q_INVOKABLE`
    macro.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数 `addAlbumFromName()` 只是包装了对 `addAlbum()` 的调用，并带有所需的专辑 `name` 参数。它可以通过 `Q_INVOKABLE`
    宏从 QML 中调用。
- en: 'We can now switch back to the UI in the `gallery-mobile` project. We will add
    this album using a QML `Dialog`. QtQuick provides various default implementations
    of dialogs:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以切换回 `gallery-mobile` 项目的 UI。我们将使用 QML 的 `Dialog` 来添加这个专辑。QtQuick 提供了各种默认的对话框实现：
- en: '`ColorDialog`: This dialog is used to choose a color'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorDialog`：此对话框用于选择颜色'
- en: '`Dialog`: This dialog is uses the generic dialog with standard buttons (equivalent
    of a `QDialog`)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dialog`：此对话框使用通用的对话框和标准按钮（相当于 `QDialog`）'
- en: '`FileDialog`: This dialog is used to choose a file from the local filesystem'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileDialog`：此对话框用于从本地文件系统中选择文件'
- en: '`FontDialog`: This dialog is used to choose a font'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontDialog`：此对话框用于选择字体'
- en: '`MessageDialog`: This dialog is used to display a message'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageDialog`：此对话框用于显示消息'
- en: 'You would have expected to see an `InputDialog` in this list (as we used the `QInputDialog`
    widget in [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop
    UI"), *Conquering the Desktop UI*) but Qt Quick does not have it. Create a new **QML
    File (Qt Quick 2)** and name it `InputDialog.qml`. The content should look like
    so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你本应在这个列表中看到 `InputDialog`（因为我们曾在 [第4章](part0040.xhtml#aid-164MG2 "第4章. 征服桌面UI")
    中使用过 `QInputDialog` 小部件，*征服桌面UI*），但 Qt Quick 并没有提供它。创建一个新的 **QML 文件 (Qt Quick
    2**) 并将其命名为 `InputDialog.qml`。内容应如下所示：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this custom `InputDialog`, we take the generic Qt Quick `Dialog` and modify
    it to contain our `TextInput` item referenced by the ID `editTextItem`. We also
    added a `labelItem` just above `editTextItem` to describe the expected input.
    There are several things to note in this dialog.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个自定义`InputDialog`中，我们使用了通用的Qt Quick `Dialog`，并将其修改为包含通过ID`editTextItem`引用的`TextInput`项。我们还在`editTextItem`上方添加了一个`labelItem`来描述预期的输入。在这个对话框中有几个需要注意的事项。
- en: 'First, because we want this dialog to be generic, it has to be configurable.
    The caller should be able to provide parameters to display its specific data.
    This is done with the three properties at the top of the `Dialog` element:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为我们希望这个对话框是通用的，所以它必须是可配置的。调用者应该能够提供参数来显示其特定的数据。这是通过在`Dialog`元素顶部的三个属性来完成的：
- en: '`label`: This property configures the displayed text in `labelItem`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这个属性配置了在`labelItem`中显示的文本。'
- en: '`hint`: This property is the default text displayed in `editTextItem`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hint`: 这个属性是`editTextItem`中显示的默认文本。'
- en: '`editText`: This property references the "local" `editTextItem` element. This
    will let the caller retrieve the value when the dialog is closed.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`editText`: 这个属性引用了“本地”的`editTextItem`元素。这将允许调用者在对话框关闭时检索值。'
- en: 'We also configure the `Dialog` element to automatically use the platform buttons
    to validate or cancel the dialog with `standardButtons: StandardButton.Ok | StandardButton.Cancel`
    syntax.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还配置了`Dialog`元素，使其能够自动使用平台按钮，通过`standardButtons: StandardButton.Ok | StandardButton.Cancel`语法来验证或取消对话框。'
- en: Finally, to make the dialog a bit more user-friendly, `editTextItem` has the
    focus when the `Dialog` element becomes visible and the text is selected. These
    two steps are done in the `onVisibleChanged()` callback function. When the dialog
    is hidden (that is, **Ok** or **Cancel** has been clicked), we hide the virtual
    keyboard with `Qt.InputMethod.hide()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使对话框更加用户友好，当`Dialog`元素变为可见并且文本被选中时，`editTextItem`将获得焦点。这两个步骤在`onVisibleChanged()`回调函数中完成。当对话框隐藏（即，点击了**确定**或**取消**），我们使用`Qt.InputMethod.hide()`隐藏虚拟键盘。
- en: 'The `InputDialog` is ready to be used! Open `AlbumListPage.qml` and modify
    it like so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputDialog`已准备好使用！打开`AlbumListPage.qml`并按如下方式修改：'
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We add `InputDialog` with the ID `newAlbumDialog` inside `PageTheme` element.
    We define all our custom properties: `title`, `label`, and `hint`. When the user
    clicks on the **Ok** button, the `onAccepted()` function is called. Here, it is
    a simple matter of calling the wrapper function `addAlbumFromName()` in the `AlbumModel`
    element with the entered text.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`PageTheme`元素内部添加了ID为`newAlbumDialog`的`InputDialog`。我们定义了所有自定义属性：`title`、`label`和`hint`。当用户点击**确定**按钮时，将调用`onAccepted()`函数。在这里，只需调用`AlbumModel`元素中的包装函数`addAlbumFromName()`并传入输入的文本即可。
- en: This `Dialog` element is not visible by default, we open it by adding a `ToolButton`
    in  `toolbarButtons`. This `ToolButton` will be added at the far right of the
    header as we specified in the `PageTheme.qml` file. To match mobile standards,
    we simply use a custom icon inside that button rather than text.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个`Dialog`元素是不可见的，我们通过在`toolbarButtons`中添加一个`ToolButton`来打开它。这个`ToolButton`将按照我们在`PageTheme.qml`文件中指定的方式添加到页眉的右侧。为了符合移动标准，我们在这个按钮内部使用了一个自定义图标而不是文本。
- en: Here you can see that it is possible to reference images stored in the `.qrc`
    file with the syntax `qrc:/res/icons/album-add.svg`. We use SVG files to have
    scalable icons, but you are free to use your own icons for the `gallery-mobile`
    application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以看到，可以使用语法`qrc:/res/icons/album-add.svg`引用存储在`.qrc`文件中的图像。我们使用SVG文件来拥有可缩放的图标，但你也可以为`gallery-mobile`应用程序使用你自己的图标。
- en: 'When the user clicks on the `ToolButton`, the `onClicked()` function is called,
    where we open `newAlbumDialog`. On our reference device, a Nexus 5X, this is how
    it looks:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`ToolButton`时，将调用`onClicked()`函数，在这里我们打开`newAlbumDialog`。在我们的参考设备Nexus
    5X上，它看起来是这样的：
- en: '![Creating a new album from a custom InputDialog](img/image00387.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![从自定义InputDialog创建新相册](img/image00387.jpeg)'
- en: When the user clicks on the **OK** button, the whole Model/View pipeline starts
    to work. This new album is persisted, the `AlbumModel` element emits the correct
    signals to notify our `ListView`, `albumList`, to refresh itself. We are starting
    to leverage the power of our `gallery-core`, which can be used in a desktop application
    and a mobile application without rewriting a significant portion of the engine
    code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**确定**按钮时，整个模型/视图管道开始工作。这个新相册被持久化，`AlbumModel`元素发出正确的信号来通知我们的`ListView`、`albumList`刷新自己。我们开始利用`gallery-core`的强大功能，它可以在桌面应用程序和移动应用程序中使用，而无需重写大量引擎代码。
- en: Loading images with an ImageProvider
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ImageProvider加载图像
- en: It is now time to display the thumbnails for our freshly persisted album. These
    thumbnails have to be loaded somehow. Because our application is targeted at mobile
    devices, we cannot afford to freeze the UI thread while loading thumbnails. We
    would either hog the CPU or be killed by the OS, neither of which are desirable
    destinies for `gallery-mobile`. Qt provides a very handy class to handle the image
    loading: `QQuickImageProvider`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候显示我们刚刚持久化的相册的缩略图了。这些缩略图需要以某种方式加载。由于我们的应用程序针对的是移动设备，我们无法在加载缩略图时冻结UI线程。我们可能会占用CPU或者被操作系统杀死，这两种情况对于`gallery-mobile`来说都不是理想的结果。Qt提供了一个非常方便的类来处理图像加载：`QQuickImageProvider`。
- en: The `QQuickImageProvider` class provides an interface to load the `QPixmap`
    class in your QML code in an asynchronous manner. This class automatically spawns
    threads to load the `QPixmap` class and you simply have to implement the function `requestPixmap()`.
    There is more to it, `QQuickImageProvider` caches by default the requested pixmap
    to avoid hitting the data source too much.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`QQuickImageProvider`类提供了一个接口，以异步方式在您的QML代码中加载`QPixmap`类。这个类会自动创建线程来加载`QPixmap`类，您只需实现`requestPixmap()`函数即可。还有更多内容，`QQuickImageProvider`默认会缓存请求的位图，以避免过多地击中数据源。'
- en: 'Our thumbnails must be loaded from the `PictureModel` element, which gives
    access to the `fileUrl` of a given `Picture`. Our implementation of `r`QQuickImageProvider
    will have to get the `QPixmap` class for a row index in `PicturelModel`. Create
    a new C++ class named `PictureImageProvider`, and modify `PictureImageProvider.h`
    like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的缩略图必须从`PictureModel`元素加载，该元素提供了对给定`Picture`的`fileUrl`的访问。我们的`r`QQuickImageProvider实现将需要为`PicturelModel`中的行索引获取`QPixmap`类。创建一个新的C++类名为`PictureImageProvider`，并按如下方式修改`PictureImageProvider.h`：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A pointer to the `PictureModel` element has to be provided in the constructor
    to be able to retrieve `fileUrl`. We override `requestPixmap()`, which takes an `id`
    parameter in its parameters list (the `size` and `requestedSize` can be safely
    ignored for now). This `id` parameter will be provided in the QML code when we
    want to load a picture. For a given `Image` in QML, the `PictureImageProvider`
    class will be called like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中必须提供一个指向`PictureModel`元素的指针，以便能够检索`fileUrl`。我们重写了`requestPixmap()`，它在参数列表中有一个`id`参数（现在可以安全地忽略`size`和`requestedSize`）。当我们想要加载图片时，这个`id`参数将在QML代码中提供。对于QML中的给定`Image`，`PictureImageProvider`类将被调用如下：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s break it down:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`image`: This is the scheme for the URL source of the image. This tells Qt
    to work with an image provider to load the image.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是图像URL源的方案。这告诉Qt与图像提供者一起加载图像。'
- en: '`pictures`: This is the identifier of the image provider. We will link the `PictureImageProvider`
    class and this identifier at the initialization of  `QmlEngine` in `main.cpp`.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pictures`：这是图像提供者的标识符。我们将在`main.cpp`中初始化`QmlEngine`时将`PictureImageProvider`类和此标识符链接起来。'
- en: '`index`: This is the ID of the image. Here it is the row index of the picture.
    This corresponds to the `id` parameter in `requestPixmap()`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：这是图像的ID。在这里，它是图片的行索引。这对应于`requestPixmap()`中的`id`参数。'
- en: 'We already know that we want to display a picture in two modes: thumbnail and
    full resolution. In both cases, a `QQuickImageProvider` class will be used. These
    two modes have a very similar behavior: they will request `PictureModel` for `fileUrl`
    and return the loaded `QPixmap`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们想要以两种模式显示图片：缩略图和全分辨率。在这两种情况下，都将使用`QQuickImageProvider`类。这两个模式的行为非常相似：它们将请求`PictureModel`的`fileUrl`并返回加载的`QPixmap`。
- en: There is a pattern here. We can easily encapsulate these two modes in `PictureImageProvider`.
    The only thing we have to know is when the caller wants a thumbnail or a full
    resolution `QPixmap`. This can be easily done by making the `id` parameter more
    explicit.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个模式。我们可以轻松地将这两种模式封装在`PictureImageProvider`中。我们唯一需要知道的是调用者想要缩略图还是全分辨率`QPixmap`。这可以通过使`id`参数更加明确来实现。
- en: 'We are going to implement the `requestPixmap()` function to be able to be called
    in two ways:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现`requestPixmap()`函数，使其能够以两种方式被调用：
- en: '`images://pictures/<index>/full`: Using this syntax to retrieve the full resolution
    picture'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images://pictures/<index>/full`：使用这种语法来检索全分辨率图片'
- en: '`images://pictures/<index>/thumbnail`: Using this syntax to retrieve the thumbnail
    version of the picture'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images://pictures/<index>/thumbnail`：使用这种语法来检索图片的缩略图版本'
- en: 'If the `index` value was `0`, these two calls would set the ID to `0/full`
    or `0/thumbnail` in `requestPixmap()`. Let''s see the implementation in `PictureImageProvider.cpp`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`index`值是`0`，这两个调用将在`requestPixmap()`中将ID设置为`0/full`或`0/thumbnail`。让我们看看`PictureImageProvider.cpp`中的实现：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by calling the `QQuickImageProvider` constructor with the `QQuickImageProvider::Pixmap`
    parameter to configure `QQuickImageProvider` to call `requestPixmap()`. The `QQuickImageProvider`
    constructor supports various image types (`QImage`, `QPixmap`, `QSGTexture`, `QQuickImageResponse`)
    and each one has its specific `requestXXX()` function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用带有`QQuickImageProvider::Pixmap`参数的`QQuickImageProvider`构造函数来配置`QQuickImageProvider`以调用`requestPixmap()`。`QQuickImageProvider`构造函数支持各种图像类型（`QImage`、`QPixmap`、`QSGTexture`、`QQuickImageResponse`），并且每种类型都有自己的`requestXXX()`函数。
- en: In the `requestPixmap()` function, we start by splitting this ID with the `/`
    separator. From here, we retrieve the `row` values and the desired `pictureSize`.
    The `fileUrl` is loaded by simply calling the `mPictureModel::data()` function
    with the right parameters. We used the exact same call in [Chapter 4](part0040.xhtml#aid-164MG2
    "Chapter 4.  Conquering the Desktop UI"), *Conquering the Desktop UI*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`requestPixmap()`函数中，我们首先使用`/`分隔符拆分这个ID。从这里，我们检索`row`值和所需的`pictureSize`。通过简单地调用带有正确参数的`mPictureModel::data()`函数来加载`fileUrl`。我们在[第4章](part0040.xhtml#aid-164MG2
    "第4章。征服桌面UI")，*征服桌面UI*中使用了完全相同的调用。
- en: Great, we know which `fileUrl` should be loaded and what the desired dimension
    is. However, we have one last thing to handle. Because we manipulate a row and
    not a database ID, we will have the same request URL for two different pictures,
    which are in different albums. Remember that `PictureModel` loads a list of pictures
    for a given `Album`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们知道应该加载哪个`fileUrl`以及期望的维度。然而，我们还有最后一件事要处理。因为我们操作的是行而不是数据库ID，所以对于不同相册中的两张不同图片，我们将会有相同的请求URL。记住，`PictureModel`会为给定的`Album`加载一系列图片。
- en: We should picture (pun intended) the situation. For an album called `Holidays`,
    the request URL will be `images://pictures/0/thumbnail` to load the first picture.
    It will be the same URL for another album `Pets`, which will load the first picture
    with `images://pictures/0/thumbnail`. As we said earlier, `QQuickImageProvider`
    automatically generates a cache which will avoid subsequent calls to `requestPixmap()`
    for the same URL. Thus, we will always serve the same picture, no matter which
    album is selected.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该想象（这里是一个双关语）这种情况。对于一个名为`Holidays`的相册，请求URL将是`images://pictures/0/thumbnail`以加载第一张图片。对于另一个名为`Pets`的相册，它将以相同的URL`images://pictures/0/thumbnail`加载第一张图片。正如我们之前所说的，`QQuickImageProvider`会自动生成缓存，这将避免对相同URL的后续`requestPixmap()`调用。因此，无论选择哪个相册，我们总是会提供相同的图片。
- en: 'This constraint forces us to disable the cache in `PictureImageProvider` and
    to roll out our own cache. This is an interesting thing to do; here is a possible
    implementation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束迫使我们禁用`PictureImageProvider`中的缓存并推出我们自己的缓存。这是一件有趣的事情来做；以下是一个可能的实现：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This new `pictureFromCache()` function aims to store the generated `QPixmap`
    in `mPicturesCache` and return the proper `QPixmap`. The `mPicturesCache` class
    relies on a `QCache`; this class lets us store data in a key/value fashion with
    the possibility to assign a cost for each entry. This cost should roughly map
    the memory cost of the object (by default, `cost = 1`). When `QCache` is instantiated,
    it is initialized with a `maxCost` value (by default `100`). When the cost of
    the sum of all objects' exceeds the `maxCost`, `QCache` starts deleting objects
    to make room for the new objects, starting with the less recently accessed objects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`pictureFromCache()`函数旨在将生成的`QPixmap`存储在`mPicturesCache`中，并返回正确的`QPixmap`。`mPicturesCache`类依赖于一个`QCache`；这个类允许我们以键/值的方式存储数据，并且可以为每个条目分配一个成本。这个成本应该大致映射对象的内存成本（默认情况下，`cost
    = 1`）。当`QCache`实例化时，它使用一个`maxCost`值初始化（默认`100`）。当所有对象的成本总和超过`maxCost`时，`QCache`开始删除对象以腾出空间，从最近最少访问的对象开始。
- en: In the `pictureFromCache()` function, we first generate a key composed of the `fileUrl`
    and the `pictureSize` before trying to retrieve the `QPixmap` from the cache.
    If it is not present, the proper `QPixmap` (scaled to `THUMBNAIL_SIZE` macro if
    needed) will be generated and stored inside the cache. The `mPicturesCache` class
    becomes the owner of this `QPixmap`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pictureFromCache()`函数中，我们在尝试从缓存中检索`QPixmap`之前，首先生成一个由`fileUrl`和`pictureSize`组成的键。如果它不存在，将生成适当的`QPixmap`（如果需要，将其缩放到`THUMBNAIL_SIZE`宏），并将其存储在缓存中。`mPicturesCache`类成为这个`QPixmap`的所有者。
- en: 'The last step to complete the `PictureImageProvider` class is to make it available
    in the QML context. This is done in `main.cpp`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`PictureImageProvider`类的最后一步是使其在QML上下文中可用。这可以在`main.cpp`中完成：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `PictureImageProvider` class is added to the QML engine with `engine.addImageProvider()`.
    The first argument will be the provider identifier in QML. Note that the engine
    takes ownership of the passed `PictureImageProvider`. One last thing, the `thumbnailSize`
    parameter is also passed to `engine`, it will constrain the thumbnails to be displayed
    with the specified size in the QML code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`engine.addImageProvider()`将`PictureImageProvider`类添加到QML引擎中。第一个参数将是QML中的提供者标识符。请注意，引擎将接管传递的`PictureImageProvider`。最后一件事情，`thumbnailSize`参数也传递给`engine`，它将在QML代码中将缩略图限制为指定的尺寸。
- en: Displaying thumbnails in a GridView
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GridView中显示缩略图
- en: 'The next step is to display these thumbnails. Create a new QML file named `AlbumPage.qml`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是显示这些缩略图。创建一个新的QML文件，命名为`AlbumPage.qml`：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This new `PageTheme` element defines two properties: `albumName` and `albumRowIndex`.
    The `albumName` property is used to update the title in `toolbarTitle`; `albumRowIndex`
    will be used to interact with `AlbumModel` in order to rename or delete the album
    from the current page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`PageTheme`元素定义了两个属性：`albumName`和`albumRowIndex`。`albumName`属性用于更新`toolbarTitle`中的标题；`albumRowIndex`将用于与`AlbumModel`交互，以便从当前页面重命名或删除专辑。
- en: To display thumbnails, we rely on a `GridView` element which will layout the
    thumbnails in a grid of cells. This `thumbnailList` item uses the `pictureModel`
    to request its data. The delegate is simply a `Rectangle` element with a single `Image`
    inside. This `Rectangle` element is slightly smaller than the `thumbnailList.cellWidth`
    or `thumbnailList.cellHeight`. The `GridView` element does not provide a `spacing`
    property (like `ListView`) for some room between each item. Thus, we simulate
    it by using a smaller area to display the content.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示缩略图，我们依赖于一个`GridView`元素，它将缩略图布局在单元格的网格中。这个`thumbnailList`项目使用`pictureModel`请求其数据。代理只是一个包含单个`Image`的`Rectangle`元素。这个`Rectangle`元素略小于`thumbnailList.cellWidth`或`thumbnailList.cellHeight`。`GridView`元素不提供`spacing`属性（像`ListView`一样，在项目之间留出一些空间）。因此，我们通过使用较小的区域来显示内容来模拟它。
- en: 'The `Image` item will try to take all the available space with `anchors.fill:
    parent` but will still keep the aspect ratio of the provided picture with `fillMode:
    Image.PreserveAspectFit`. You recognize the `source` attribute where the current
    delegate `index` is provided to retrieve the thumbnail. Finally, the `cache: false`
    attribute ensures that the `PictureImageProvider` class will not try to use the
    native cache.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`项目将尝试使用`anchors.fill: parent`占用所有可用空间，但仍然会使用`fillMode: Image.PreserveAspectFit`保持提供的图片的宽高比。你可以识别出`source`属性，其中提供了当前代理`index`以检索缩略图。最后，`cache:
    false`属性确保`PictureImageProvider`类不会尝试使用本地缓存。'
- en: To display `AlbumPage.qml`, we have to update the `stackView` (located in `main.qml`).
    Remember that `stackView` has been declared as a property (`pageStack`), it is
    thus accessible from any QML file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示 `AlbumPage.qml`，我们必须更新 `stackView`（位于 `main.qml` 中）。记住，`stackView` 已声明为属性（`pageStack`），因此可以从任何
    QML 文件中访问它。
- en: The `AlbumPage` element will be displayed when the user clicks on the `MouseArea`
    element for a given `Album` value in `AlbumListPage.qml`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 `AlbumListPage.qml` 中给定 `Album` 值的 `MouseArea` 元素时，将显示 `AlbumPage` 元素。
- en: 'We will now give the ability to the user to add a new picture. To do this,
    we will rely on a QtQuick Dialog: `FileDialog`. Here is the updated version of `AlbumPage.qml`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将赋予用户添加新图片的能力。为此，我们将依赖于 QtQuick 对话框：`FileDialog`。以下是更新后的 `AlbumPage.qml`
    版本：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `FileDialog` element is straightforward to implement. By using the `folder:
    shortcuts.pictures` property, QtQuick will automatically position the `FileDialog`
    element in the platform-specific pictures directory. Even better, on iOS it will
    open the native photo application where you can pick your own picture.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileDialog` 元素的实现非常直接。通过使用 `folder: shortcuts.pictures` 属性，QtQuick 将自动将 `FileDialog`
    元素定位到平台特定的图片目录。更好的是，在 iOS 上，它将打开原生照片应用程序，您可以在其中选择自己的图片。'
- en: 'When the user validates his picture choice, the path is available in the `onAccepted()`function
    with the `dialog.fileUrl` field, which we stored in the `pictureUrl` variable.
    This `pictureUrl` variable is then passed to a new wrapper function of `PictureModel:
    addPictureFromUrl()`. The pattern used is exactly the same as we did for `AlbumModel::addAlbumFromName()`:
    a `Q_INVOKABLE` wrapper function around `PictureModel::addPicture()`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户验证其图片选择时，路径在 `onAccepted()` 函数的 `dialog.fileUrl` 字段中可用，我们将其存储在 `pictureUrl`
    变量中。然后，将此 `pictureUrl` 变量传递给 `PictureModel` 的新包装函数 `addPictureFromUrl()`。使用的模式与我们为
    `AlbumModel::addAlbumFromName()` 所做的完全相同：一个围绕 `PictureModel::addPicture()` 的 `Q_INVOKABLE`
    包装函数。
- en: 'The only missing parts of `AlbumPage` are the delete album and rename album
    features. They follow patterns we already covered. The deletion will be done using
    a wrapper function in `AlbumModel`, and the rename reuses the `InputDialog` we
    created for `AlbumListPage.qml`. Please refer to the source code of the chapter
    to see the implementation for these features. This is how the thumbnails will
    look on an Android device:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlbumPage` 中缺失的部分是删除专辑和重命名专辑的功能。它们遵循我们已讨论过的模式。删除操作将通过 `AlbumModel` 中的包装函数来完成，而重命名将重用我们为
    `AlbumListPage.qml` 创建的 `InputDialog`。请参考该章节的源代码以查看这些功能的实现。以下是缩略图在 Android 设备上的显示效果：'
- en: '![Displaying thumbnails in a GridView](img/image00388.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![在 GridView 中显示缩略图](img/image00388.jpeg)'
- en: Swiping through full resolution pictures
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动浏览全分辨率图片
- en: 'The last page we have to implement in `gallery-mobile` is the full resolution
    picture page. In [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering
    the Desktop UI"), *Conquering the Desktop UI*, we navigated through the pictures
    using previous/next buttons. In this chapter, we target the mobile platform. Therefore,
    the navigation should be done using a touch-based gesture: a fling.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gallery-mobile` 中，我们还需要实现最后一页，即全分辨率图片页面。在 [第 4 章](part0040.xhtml#aid-164MG2
    "第 4 章。征服桌面 UI")，*征服桌面 UI* 中，我们使用上一页/下一页按钮浏览图片。在本章中，我们针对移动平台。因此，导航应使用基于触摸的手势：滑动。
- en: 'Here is the implementation of this new `PicturePage.qml` file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新 `PicturePage.qml` 文件的实现：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We first define two properties, `pictureName` and `pictureIndex`. The current `pictureName`
    property is displayed in the `toolbarTitle` and `pictureIndex` is used to initialize
    the correct `currentIndex` in `ListView`, `currentIndex: pictureIndex`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先定义两个属性，`pictureName` 和 `pictureIndex`。当前的 `pictureName` 属性在 `toolbarTitle`
    中显示，而 `pictureIndex` 用于在 `ListView` 中初始化正确的 `currentIndex`，即 `currentIndex: pictureIndex`。'
- en: 'To be able to swipe through the pictures, we again use a `ListView`. Here,
    each item (a simple `Image` element) will take the full size of its parent. When
    the component is loaded, even if `currentIndex` is correctly set, the view has
    to be updated to be positioned at the correct index. This is what we do in `pictureListView`
    with this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够滑动浏览图片，我们再次使用 `ListView`。在这里，每个项目（一个简单的 `Image` 元素）将占据其父元素的全尺寸。当组件加载时，即使
    `currentIndex` 设置正确，视图也必须更新到正确的索引位置。这就是我们在 `pictureListView` 中通过以下方式所做的：
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will update the position of the current visible item to `currentIndex`.
    So far so good. Nonetheless, when a `ListView` is created, the first thing it
    does is to initialize its delegate. A `ListView` has a `view` property, which
    is filled with the `delegate` content. That implies that the `ListView.view` (yes,
    it hurts) does not have any width in `Component.onCompleted()`. As a consequence,
    the `positionViewAtIndex()` function does... absolutely nothing. To prevent this
    behavior, we have to provide a default initial width to the delegate with the
    ternary expression `ListView.view.width == 0 ? parent.width : ListView.view.width`.
    The view will then have a default width on the first load and the `positionViewAtIndex()`
    function can happily move until `ListView.view` is properly loaded.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '这将更新当前可见项的位置到`currentIndex`。到目前为止，一切顺利。然而，当创建一个`ListView`时，它首先做的事情是初始化其代理。`ListView`有一个`view`属性，其中填充了`delegate`内容。这意味着在`Component.onCompleted()`中，`ListView.view`（是的，这很痛苦）没有任何宽度。因此，`positionViewAtIndex()`函数实际上什么也不做。为了防止这种行为，我们必须使用三元表达式`ListView.view.width
    == 0 ? parent.width : ListView.view.width`为代理提供一个默认初始宽度。这样，视图在第一次加载时将有一个默认宽度，并且`positionViewAtIndex()`函数可以愉快地移动，直到`ListView.view`正确加载。'
- en: To swipe through each picture, we set the `snapMode` value of the `ListView`
    to `ListView.SnapOneItem`. Each fling will snap to the next or previous picture
    without continuing the motion.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要滑动查看每张图片，我们将`ListView`的`snapMode`值设置为`ListView.SnapOneItem`。每次快速滑动都会跳转到下一张或上一张图片，而不会继续运动。
- en: The `Image` item of the delegate looks very much like the thumbnail version.
    The sole difference is the source property, where we request `PictureImageProvider`
    class with the `full` resolution.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的`Image`项看起来非常像缩略图版本。唯一的区别是源属性，我们请求`PictureImageProvider`类使用全分辨率。
- en: 'When `PicturePage` opens, the correct `pictureName` property is displayed in
    the header. However, when the user flings to another picture, the name is not
    updated. To handle this, we have to detect the motion state. Add the following
    callbacks in `pictureListView`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PicturePage`打开时，正确的`pictureName`属性会在标题中显示。然而，当用户快速滑动到另一张图片时，名称不会更新。为了处理这个问题，我们必须检测运动状态。在`pictureListView`中添加以下回调：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `onMovementEnded()` class is triggered when the motion started by the swipe
    has ended. In this function, we update the `ListViewcurrentIndex` with the `itemIndex`
    of the visible item at the `contentX` and `contentY` coordinates.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当由滑动引起的运动结束时，会触发`onMovementEnded()`类。在这个函数中，我们使用`contentX`和`contentY`坐标的可见项的`itemIndex`更新`ListViewcurrentIndex`。
- en: The second function, `onCurrentItemChanged()`, is called upon the `currentIndex`
    update. It will simply update the `toolbarTitleLabel.text` with the picture name
    of the current item.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个功能，`onCurrentItemChanged()`，在`currentIndex`更新时被调用。它将简单地使用当前项的图片名称更新`toolbarTitleLabel.text`。
- en: 'To display `PicturePage.qml`, the same `MouseArea` pattern is used in the `thumbnailList`
    delegate of `AlbumPage.qml`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示`PicturePage.qml`，在`AlbumPage.qml`的`thumbnailList`代理中使用了相同的`MouseArea`模式：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, the `PicturePage.qml` file is pushed on the `pageStack` and the needed
    parameters (`pictureName` and `pictureIndex`) are provided in the same manner.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`PicturePage.qml`文件被推送到`pageStack`，并且所需的参数（`pictureName`和`pictureIndex`）以相同的方式提供。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter brings closure to the development of the gallery application. We
    built a strong foundation with `gallery-core`, created a widget UI with `gallery-desktop`,
    and finally crafted a QML UI with `gallery-mobile`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了画廊应用程序的开发。我们使用`gallery-core`建立了坚实的基础，使用`gallery-desktop`创建了一个小部件UI，最后使用`gallery-mobile`制作了一个QML
    UI。
- en: QML enables a very fast approach to UI development. Unfortunately, the technology
    is still young and rapidly changing. The integration with mobile OSes (Android,
    iOS) is under heavy development and we hope that it will lead to great mobile
    applications with Qt. For now, the inherent limits of a mobile cross-platform
    toolkit are still hard to overcome.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: QML使UI开发变得非常快速。不幸的是，这项技术仍然很年轻，并且正在快速发展。与移动操作系统（Android、iOS）的集成正在积极开发中，我们希望它能带来使用Qt的伟大移动应用程序。目前，移动跨平台工具包的固有限制仍然难以克服。
- en: 'The next chapter will take QML technology to new shores: the development of
    a snake game running on a Raspberry Pi.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将把QML技术带到新的领域：在Raspberry Pi上运行的蛇形游戏开发。
