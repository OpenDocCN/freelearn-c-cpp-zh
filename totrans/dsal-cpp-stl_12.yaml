- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manipulation and Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses data manipulation techniques provided by the C++ **Standard
    Template Library** (**STL**). These techniques of manipulating data structures,
    whether copying, generating new data, removing outdated entries, or performing
    advanced operations such as swapping or reversing, form a significant part of
    most applications. This chapter will expose you to many methods and nuances, allowing
    you to choose the right tool for your tasks. Accompanied by best practices, this
    chapter ensures you understand and apply these techniques efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying and moving in STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring return value optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling and generating in STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing and replacing in STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping and reversing in STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Copying and moving in STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL in C++ is known for its robust data structures and algorithms. Among
    its most fundamental aspects are the operations of copying and moving containers.
    These operations are not only crucial for data manipulation but also play a significant
    role in the efficiency and performance of C++ applications. This section explores
    the nuances of copying and moving within the STL, exploring their semantics, implications
    on performance, and the strategic decision-making involved in choosing one over
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: Copying semantics in the STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Copying**, in the most rudimentary sense, refers to creating a replica of
    an object. In the STL, when you copy a container, you duplicate its contents into
    a new one. One way to visualize this is to imagine photocopying a document. The
    original remains unchanged, and you have a new document with the same content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `duplicate` vector is now a replica of the original vector. Both containers
    are entirely independent; modifying one won’t affect the other. While this sounds
    straightforward, the devil is often in the detail. Copying can be an expensive
    operation, especially for large containers. Each element of the original container
    is duplicated, which might lead to performance pitfalls in applications where
    time efficiency is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Moving semantics in the STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in C++11, **move semantics** ushered a paradigm shift in managing
    resources. Instead of duplicating the content, moving transfers the ownership
    of resources from one object (the *source*) to another (the *destination*).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a box of toys (`std::vector`). Instead of creating a new box
    and transferring toys one by one (copying), you simply hand over the box to someone
    else (moving). The original box is empty, and the other person owns all the toys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it looks in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Post this operation, `destination` owns the data, while `original` is in a valid
    but unspecified state (often empty). This mechanism offers significant performance
    benefits, especially with large datasets, as it eliminates the overhead of duplicating
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Copying versus moving – a deliberate choice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, equipped with an understanding of both mechanics, the onus is on the developer
    to make an informed choice. Copying ensures data integrity as the original remains
    untouched. This is useful when the original data still plays a role in subsequent
    operations. However, if the original container’s data is disposable or you’re
    sure it won’t be needed afterward, opting for a move operation can dramatically
    enhance performance.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, caution is advised. The careless use of move semantics might lead to surprises,
    especially if one assumes data still resides in the source container. Always be
    conscious of the state of your objects after any operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example demonstrating the potential pitfalls of the careless use
    of move semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the `source` vector is in a valid but unspecified state after moving
    data from `source` to `destination`. It’s empty, but operations such as `push_back`
    can still be performed. The key takeaway is that one should be aware of such states
    and not assume that the `source` container’s data is intact after a move.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the power of the STL is magnified when the developer understands
    the nuances of its operations. Copying and moving are foundational pillars, determining
    how data is managed and how efficiently an application runs. As we venture deeper
    into manipulation and transformation techniques in subsequent sections, always
    keep these mechanics in mind. They often form the bedrock upon which advanced
    techniques are built.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring return value optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Return value optimization** (**RVO**) deserves special mention. Modern compilers
    optimize returning objects from functions, effectively transforming what looks
    like a copy into a move, making the operation highly efficient. This is a testament
    to the evolving nature of C++ and its inclination towards performance optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example to demonstrate the concept of RVO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, when the function `createSample` is called, it returns a `Sample`
    object. Without RVO, we might expect a sequence of calls: `Constructor` -> `Copy
    Constructor` (or `Move Constructor`) -> `Destructor`. However, because of RVO,
    many modern compilers will optimize the creation so that only the constructor
    is called. The output typically would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The absence of a call to the Copy Constructor (`Sample(const Sample&)`) or Move
    Constructor (`Sample(Sample&&) noexcept`) indicates that RVO took place. The object
    was constructed directly in the memory location of `obj` without the need for
    additional copying or moving.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore efficient ways of automatically populating STL containers
    using the concepts of filling and generating elements.
  prefs: []
  type: TYPE_NORMAL
- en: Filling and generating in STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Populating containers and generating data within them is akin to molding clay
    into a sculpture. The data structure is your foundation, and the techniques to
    fill and generate data give life to your programs. As we continue to unearth the
    vast capabilities of the STL, this segment is dedicated to the pivotal techniques
    of *filling and generating* in STL containers. Let’s roll up our sleeves and dive
    into the art and science of crafting data structures with precision!
  prefs: []
  type: TYPE_NORMAL
- en: Populating with static assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where you need a container filled with a specific value,
    be it zeroes, a particular character, or any other repeating pattern. The STL
    simplifies this with methods tailored for static assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `std::vector` offers an overload of its constructor that
    allows you to specify a size and a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Such a method ensures uniformity of data, which is essential for operations
    that rely on homogeneous collections. This isn’t exclusive to vectors. Many STL
    containers provide similar functionalities, ensuring developers have the necessary
    tools for various contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic generation with the STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While static assignment has its charm, more often, there’s a need for dynamic
    data generation. Whether it is for creating test cases, simulating scenarios,
    or any situation demanding a specific pattern, the STL doesn’t disappoint.
  prefs: []
  type: TYPE_NORMAL
- en: The STL provides the `std::generate` and `std::generate_n` algorithms for these
    needs. These functions assign values to a container based on a generator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve leveraged a lambda function to generate consecutive integers dynamically.
    This method offers unparalleled flexibility, allowing developers to generate data
    as simple as incrementing numbers or as complex as values based on intricate formulas
    or computations.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring relevance and efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, having the tools is only half the battle. Employing them effectively is
    where mastery shines. When filling and generating data, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Choose appropriately**: Consider the data’s lifecycle. If the dataset remains
    static post-creation, static assignments are straightforward and efficient. However,
    for ever-evolving data, dynamic generation methods provide flexibility and adaptability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mind the size**: Overpopulating can lead to memory inefficiencies, while
    underpopulating might result in incomplete operations or unexpected behaviors.
    Always be keenly aware of the size requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Harness the power of lambdas**: With C++11 and onward, lambdas concisely
    define quick functions. They are invaluable in dynamic generation, allowing for
    tailored functions without the verbosity of traditional function definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consider real-world contexts**: Always relate to the problem at hand. If
    you’re populating a container to simulate real-world data, ensure that your filling
    and generating techniques mirror realistic scenarios. It’s not just about filling
    containers but filling them with purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the ability to effectively fill and generate data in STL containers
    is a testament to the library’s robustness. Whether you’re aiming for uniformity
    with static assignments or seeking the dynamic flair of generated patterns, the
    STL is well-equipped to handle your needs. As we progress toward more intricate
    manipulations in the coming sections, always remember that data is the heart of
    your application. How you shape and nurture it often determines the rhythm and
    pulse of your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Removing and replacing in STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In data manipulation using the C++ STL, we often find ourselves adding or viewing
    elements and engaging in curating them. As we peel the layers of this chapter,
    the art of *removing and replacing* emerges as an essential skill, striking the
    perfect balance between retaining the valuable and discarding the redundant. By
    mastering these operations, you can elevate your proficiency in handling STL containers,
    enhancing data relevance and overall efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of removal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we dive into the rich waters of data storage in the STL, there’s an undeniable
    need for refining. Whether it is the removal of outdated records, anomalies, or
    any redundancies, the STL has powerful tools to assist you. One can pinpoint specific
    values or conditions for purging using functions such as erase and remove. For
    instance, with `std::remove`, it’s possible to relocate particular elements to
    the end of a sequence container, while `erase` can permanently eliminate them.
    It’s this tandem of operations that ensures a seamless cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, while removal operations are efficient, caution is essential. Mindlessly
    erasing elements can disturb container continuity and even impact performance.
    The key is to employ these operations judiciously and be constantly aware of iterator
    validity and potential reallocations, especially in dynamic containers such as
    `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine having a collection of dated values or placeholder elements, and the
    need arises to update them. The STL doesn’t leave you stranded. Functions such
    as `std::replace` and `std::replace_if` are your allies in this endeavor. With
    `std::replace`, you can seamlessly swap old values with new ones throughout your
    collection. For more complex scenarios, where the replacement criteria aren’t
    just a simple value match, `std::replace_if` steps into the spotlight. `std::replace_if`
    allows conditions often expressed through lambdas or function objects to dictate
    the replacement.
  prefs: []
  type: TYPE_NORMAL
- en: For a hands-on example, consider a collection where negative values are deemed
    errors and need updating. With `std::replace_if`, you can hunt down every negative
    value and replace it with a default or corrected value, all in a single, elegant
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of using `std::replace` and `std::replace_if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `std::replace` to find and replace a specific value
    (-1) with 0\. We then use `std::replace_if` with a lambda function to identify
    negative values and replace them with 0\. This example demonstrates the use of
    `std::replace` for simple, direct replacements and `std::replace_if` for more
    complex scenarios where a condition (such as identifying negative values) dictates
    the replacement.
  prefs: []
  type: TYPE_NORMAL
- en: A balancing act
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Balancing removal and replacement requires a sense of rhythm and balance. While
    it is tempting to curate aggressively, sometimes retaining specific data, even
    if outdated or redundant, can serve as a historical record or a point of reference.
    Therefore, always approach removal and replacement with a clear objective, ensuring
    data integrity, relevance, and efficiency aren’t compromised.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve honed the skill of curating and modifying collections,
    focusing on removing and replacing them. This process is pivotal, as it balances
    the retention of valuable data with the elimination of redundancy, enhancing both
    data relevance and container efficiency. We’ve explored the strategic use of functions
    such as `erase` and `remove` for precision in data refinement and the importance
    of cautious removal to maintain container integrity and performance. We learned
    about the replacement techniques using `std::replace` and `std::replace_if`, which
    are instrumental in updating collections, especially when dealing with complex
    conditions. These tools not only ensure the freshness and accuracy of data but
    also highlight the flexibility and power of the STL in data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we approach swapping and reversing, demonstrating how to efficiently alter
    the order and positioning of elements within containers, a vital aspect of managing
    and manipulating data structures in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping and reversing in STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have traversed through adding, initializing, and refining our STL containers,
    there lies an equally intriguing domain where we maneuver and shuffle elements
    to align with our requirements. This section promises to take you on an expedition,
    showcasing the capabilities of the STL in repositioning and reshuffling elements
    while also touching upon intricate manipulations including deduplication and sampling.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping – the art of interchanging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many real-world scenarios, the need arises to interchange content between
    containers. Whether for load balancing, data synchronization, or other computational
    tasks, the STL offers the swap function, an efficient and streamlined mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `std::swap` can be used with almost all STL containers. If
    you’ve two `std::vectors` and wish to exchange their contents, `std::swap` does
    the magic in constant time without any overhead of copying or moving individual
    elements. This efficiency is derived from the fact that underlying data pointers
    are swapped, not the actual content.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing – a glimpse from the end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, looking at things from a different perspective brings clarity, and
    the same holds true for data. The STL provides the `std::reverse` algorithm, which
    inverts the order of elements within a container, offering a fresh view or aiding
    specific computational needs. Whether analyzing data trends or catering to a reverse
    chronological requirement, `std::reverse` ensures your containers can flip their
    sequence in linear time.
  prefs: []
  type: TYPE_NORMAL
- en: Deduplication – singling out the unique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our data grows, so does the likelihood of redundancies. However, the STL
    is well prepared to tackle such situations. The `std::unique` algorithm helps
    remove consecutive duplicates in a sorted sequence. While it does not delete the
    duplicates directly, it repositions them to the end of the container, making it
    convenient to erase them if needed. When paired with `std::sort`, `std::unique`
    becomes a potent tool in ensuring that your container retains only singular instances
    of every element.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling – a slice of the whole
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On occasions, there’s a need to sample a subset from a more extensive collection.
    While the STL does not provide a direct *sample* function, one can derive a sample
    with a combination of other tools, like random shuffle algorithms. By randomly
    shuffling and then selecting the first `n` elements, you get a representative
    sample that can be used for testing, analysis, or any other purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping, reversing, deduplication, and sampling are just glimpses into the
    expansive capabilities of the STL. They represent the dynamic nature of data and
    the myriad ways we might need to interact with it. As you continue your journey,
    remember that the STL is more than just tools and functions; it’s a suite designed
    to move, mold, and manage your data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review optimal ways of implementing STL algorithms to ensure efficiency,
    maintain data integrity, and recognize the most apt methods suitable for diverse
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort` is versatile but may not be optimal for partially sorted sequences,
    where `std::partial_sort` or `std::stable_sort` may prevail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefer algorithms over hand-written loops**: When confronted with tasks like
    searching or sorting, favor STL algorithms over hand-written loops as they are
    optimized and tested extensively, rendering them more reliable and often faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` wherever possible. It maintains data integrity and provides better
    interface insights, avoiding accidental modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::copy_n` ensures no out-of-bound accesses compared to `std::copy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::count`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::transform` would be more suited than `std::for_each`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector::reserve` to preallocate memory. This practice avoids unnecessary
    reallocations, enhancing performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` for frequent lookups, can significantly optimize performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::move` help in achieving this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the essential techniques for altering and shaping data
    within STL containers. We began by understanding the nuances of copying and moving
    semantics in the STL, learning to make deliberate choices between copying versus
    moving elements depending on the context to optimize performance and resource
    management. We then explored RVO, a technique for optimizing compilers that removes
    redundant object copying.
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the methods for filling and generating container contents,
    which are vital to efficiently initializing and modifying large datasets. We covered
    the mechanisms for removing and replacing elements within containers, balancing
    the need for data integrity with performance. The chapter also introduced the
    operations of swapping and reversing elements, deduplication to eliminate duplicates,
    and sampling to create representative subsets of data. Throughout, we focused
    on best practices to ensure that these operations are executed with precision
    and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: As we build more complex programs, we frequently encounter the need to manipulate
    large data sets. Proficiency in these operations enables the creation of more
    sophisticated and performant applications, making the information valuable and
    vital for modern C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on basic and advanced numeric operations
    such as generating sequences, summing elements, and working with adjacent differences
    and inner products. We will also look at operations on sorted ranges, consolidating
    our understanding of how to apply STL algorithms to numerical data, thereby enhancing
    our toolkit for algorithmic problem-solving in C++. This next chapter will continue
    to build on the foundation laid by previous chapters, ensuring a cohesive and
    comprehensive understanding of the STL’s capabilities.
  prefs: []
  type: TYPE_NORMAL
