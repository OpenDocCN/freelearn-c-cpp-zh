- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Manipulation and Transformation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作和转换
- en: This chapter discusses data manipulation techniques provided by the C++ **Standard
    Template Library** (**STL**). These techniques of manipulating data structures,
    whether copying, generating new data, removing outdated entries, or performing
    advanced operations such as swapping or reversing, form a significant part of
    most applications. This chapter will expose you to many methods and nuances, allowing
    you to choose the right tool for your tasks. Accompanied by best practices, this
    chapter ensures you understand and apply these techniques efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了C++ **标准模板库**（**STL**）提供的数据操作技术。这些操作数据结构的技术，无论是复制、生成新数据、删除过时条目，还是执行交换或反转等高级操作，构成了大多数应用程序的重要组成部分。本章将向您介绍许多方法和细微差别，使您能够为您的任务选择合适的工具。伴随最佳实践，本章确保您能够高效地理解和应用这些技术。
- en: 'This chapter will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Copying and moving in STL containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器中的复制和移动
- en: Exploring return value optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索返回值优化
- en: Filling and generating in STL containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器中的填充和生成
- en: Removing and replacing in STL containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器中的删除和替换
- en: Swapping and reversing in STL containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器中的交换和反转
- en: Best practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Copying and moving in STL containers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL容器中的复制和移动
- en: The STL in C++ is known for its robust data structures and algorithms. Among
    its most fundamental aspects are the operations of copying and moving containers.
    These operations are not only crucial for data manipulation but also play a significant
    role in the efficiency and performance of C++ applications. This section explores
    the nuances of copying and moving within the STL, exploring their semantics, implications
    on performance, and the strategic decision-making involved in choosing one over
    the other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的STL以其强大的数据结构和算法而闻名。其最基本方面包括复制和移动容器的操作。这些操作不仅对数据操作至关重要，而且在C++应用程序的效率和性能中也起着重要作用。本节探讨了STL中复制和移动的细微差别，探讨了它们的语义、对性能的影响以及选择其中一个而不是另一个所涉及的战略决策。
- en: Copying semantics in the STL
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL中的复制语义
- en: '**Copying**, in the most rudimentary sense, refers to creating a replica of
    an object. In the STL, when you copy a container, you duplicate its contents into
    a new one. One way to visualize this is to imagine photocopying a document. The
    original remains unchanged, and you have a new document with the same content.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**，在最基本的意义上，是指创建一个对象的副本。在STL中，当你复制一个容器时，你将其内容复制到一个新的容器中。一种可视化这种方法的方式是想象复印一份文件。原始文件保持不变，而你有一份内容相同的新的文件。'
- en: 'For instance, consider the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `duplicate` vector is now a replica of the original vector. Both containers
    are entirely independent; modifying one won’t affect the other. While this sounds
    straightforward, the devil is often in the detail. Copying can be an expensive
    operation, especially for large containers. Each element of the original container
    is duplicated, which might lead to performance pitfalls in applications where
    time efficiency is paramount.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`duplicate`向量是原始向量的副本。这两个容器完全独立；修改一个不会影响另一个。虽然这听起来很简单，但魔鬼往往藏在细节中。复制可能是一个昂贵的操作，特别是对于大型容器。原始容器中的每个元素都会被复制，这可能在时间效率至关重要的应用程序中导致性能陷阱。
- en: Moving semantics in the STL
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL中的移动语义
- en: Introduced in C++11, **move semantics** ushered a paradigm shift in managing
    resources. Instead of duplicating the content, moving transfers the ownership
    of resources from one object (the *source*) to another (the *destination*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中引入的**移动语义**引领了资源管理的范式转变。它不是复制内容，而是将资源的所有权从（源）对象转移到（目标）对象。
- en: Imagine you have a box of toys (`std::vector`). Instead of creating a new box
    and transferring toys one by one (copying), you simply hand over the box to someone
    else (moving). The original box is empty, and the other person owns all the toys.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个玩具箱（`std::vector`）。你不需要创建一个新的玩具箱并逐个转移玩具（复制），你只需将这个玩具箱交给别人（移动）。原来的玩具箱就空了，而另一个人拥有了所有的玩具。
- en: 'Here’s how it looks in the code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这在代码中的表现如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Post this operation, `destination` owns the data, while `original` is in a valid
    but unspecified state (often empty). This mechanism offers significant performance
    benefits, especially with large datasets, as it eliminates the overhead of duplicating
    data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作之后，`destination`拥有数据，而`original`处于有效但未指定的状态（通常是空的）。这种机制提供了显著的性能优势，尤其是在处理大数据集时，因为它消除了复制数据的开销。
- en: Copying versus moving – a deliberate choice
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拷贝与移动——一个有意的选择
- en: Now, equipped with an understanding of both mechanics, the onus is on the developer
    to make an informed choice. Copying ensures data integrity as the original remains
    untouched. This is useful when the original data still plays a role in subsequent
    operations. However, if the original container’s data is disposable or you’re
    sure it won’t be needed afterward, opting for a move operation can dramatically
    enhance performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，了解了这两种机制，开发者有责任做出明智的选择。拷贝确保数据完整性，因为原始数据保持未变。这在原始数据在后续操作中仍然发挥作用时很有用。然而，如果原始容器的数据是可丢弃的，或者你确信之后不再需要它，选择移动操作可以显著提高性能。
- en: Yet, caution is advised. The careless use of move semantics might lead to surprises,
    especially if one assumes data still resides in the source container. Always be
    conscious of the state of your objects after any operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要谨慎。粗心使用移动语义可能会导致意外，尤其是如果假设数据仍然位于源容器中。在任何操作之后，始终要意识到对象的状态。
- en: 'Here’s an example demonstrating the potential pitfalls of the careless use
    of move semantics:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了粗心使用移动语义可能导致的潜在问题：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the output of the preceding code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为前述代码的输出：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As shown, the `source` vector is in a valid but unspecified state after moving
    data from `source` to `destination`. It’s empty, but operations such as `push_back`
    can still be performed. The key takeaway is that one should be aware of such states
    and not assume that the `source` container’s data is intact after a move.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在从`source`到`destination`移动数据后，`source`向量处于有效但未指定的状态。它是空的，但仍然可以执行如`push_back`之类的操作。关键是要意识到这样的状态，不要假设在移动之后`source`容器中的数据仍然完好无损。
- en: In essence, the power of the STL is magnified when the developer understands
    the nuances of its operations. Copying and moving are foundational pillars, determining
    how data is managed and how efficiently an application runs. As we venture deeper
    into manipulation and transformation techniques in subsequent sections, always
    keep these mechanics in mind. They often form the bedrock upon which advanced
    techniques are built.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，当开发者理解STL操作的细微差别时，STL的力量会得到放大。拷贝和移动是基础支柱，决定了数据如何管理以及应用程序如何高效运行。在我们深入探讨后续章节中的操作和转换技术时，始终要牢记这些机制。它们通常是构建高级技术的基础。
- en: Exploring return value optimization
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索返回值优化
- en: '**Return value optimization** (**RVO**) deserves special mention. Modern compilers
    optimize returning objects from functions, effectively transforming what looks
    like a copy into a move, making the operation highly efficient. This is a testament
    to the evolving nature of C++ and its inclination towards performance optimization.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值优化**（**RVO**）值得特别提及。现代编译器优化函数中的对象返回，有效地将看似拷贝的操作转换为移动，使操作非常高效。这是C++不断发展和其倾向于性能优化的例证。'
- en: 'Here’s a code example to demonstrate the concept of RVO:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，以展示RVO的概念：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, when the function `createSample` is called, it returns a `Sample`
    object. Without RVO, we might expect a sequence of calls: `Constructor` -> `Copy
    Constructor` (or `Move Constructor`) -> `Destructor`. However, because of RVO,
    many modern compilers will optimize the creation so that only the constructor
    is called. The output typically would be as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，当调用函数`createSample`时，它返回一个`Sample`对象。如果没有RVO（Return Value Optimization，返回值优化），我们可能会预期一系列调用：`构造函数`
    -> `拷贝构造函数`（或`移动构造函数`）-> `析构函数`。然而，由于RVO，许多现代编译器会优化创建过程，使得只需调用构造函数即可。输出通常如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The absence of a call to the Copy Constructor (`Sample(const Sample&)`) or Move
    Constructor (`Sample(Sample&&) noexcept`) indicates that RVO took place. The object
    was constructed directly in the memory location of `obj` without the need for
    additional copying or moving.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 没有调用拷贝构造函数（`Sample(const Sample&)`）或移动构造函数（`Sample(Sample&&) noexcept`）表明发生了RVO。对象直接在`obj`的内存位置中构造，无需额外的复制或移动。
- en: Next, let’s explore efficient ways of automatically populating STL containers
    using the concepts of filling and generating elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨使用填充和生成元素的概念自动填充STL容器的有效方法。
- en: Filling and generating in STL containers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在STL容器中进行填充和生成
- en: Populating containers and generating data within them is akin to molding clay
    into a sculpture. The data structure is your foundation, and the techniques to
    fill and generate data give life to your programs. As we continue to unearth the
    vast capabilities of the STL, this segment is dedicated to the pivotal techniques
    of *filling and generating* in STL containers. Let’s roll up our sleeves and dive
    into the art and science of crafting data structures with precision!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 填充容器和在其中生成数据类似于将粘土塑造成雕塑。数据结构是你的基础，而填充和生成数据的技巧则赋予了你的程序生命。随着我们继续挖掘STL的巨大潜力，本部分将专注于STL容器中*填充和生成*的关键技术。让我们挽起袖子，深入探索精确构建数据结构的艺术和科学！
- en: Populating with static assignment
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态分配填充
- en: Imagine a scenario where you need a container filled with a specific value,
    be it zeroes, a particular character, or any other repeating pattern. The STL
    simplifies this with methods tailored for static assignments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你需要一个填充了特定值的容器，无论是零、特定字符还是任何其他重复模式。STL通过针对静态分配的方法简化了这一点。
- en: 'For instance, the `std::vector` offers an overload of its constructor that
    allows you to specify a size and a default value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::vector`提供了其构造函数的重载，允许你指定大小和默认值：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Such a method ensures uniformity of data, which is essential for operations
    that rely on homogeneous collections. This isn’t exclusive to vectors. Many STL
    containers provide similar functionalities, ensuring developers have the necessary
    tools for various contexts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保了数据的一致性，这对于依赖于同质集合的操作至关重要。这并不仅限于向量。许多STL容器提供了类似的功能，确保开发者拥有在不同情境下所需的工具。
- en: Dynamic generation with the STL
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STL进行动态生成
- en: While static assignment has its charm, more often, there’s a need for dynamic
    data generation. Whether it is for creating test cases, simulating scenarios,
    or any situation demanding a specific pattern, the STL doesn’t disappoint.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然静态分配有其魅力，但更常见的情况是需要动态数据生成。无论是创建测试用例、模拟场景，还是任何需要特定模式的情况，STL都不会让人失望。
- en: The STL provides the `std::generate` and `std::generate_n` algorithms for these
    needs. These functions assign values to a container based on a generator function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了`std::generate`和`std::generate_n`算法来满足这些需求。这些函数根据生成器函数将值赋给容器。
- en: 'Consider the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we’ve leveraged a lambda function to generate consecutive integers dynamically.
    This method offers unparalleled flexibility, allowing developers to generate data
    as simple as incrementing numbers or as complex as values based on intricate formulas
    or computations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了lambda函数动态地生成连续整数。这种方法提供了无与伦比的灵活性，允许开发者生成从简单的数字递增到基于复杂公式或计算的复杂值的数据。
- en: Ensuring relevance and efficiency
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保相关性和效率
- en: 'Now, having the tools is only half the battle. Employing them effectively is
    where mastery shines. When filling and generating data, do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有工具只是战斗的一半。有效地使用它们才是掌握的关键。在填充和生成数据时，请遵循以下步骤：
- en: '**Choose appropriately**: Consider the data’s lifecycle. If the dataset remains
    static post-creation, static assignments are straightforward and efficient. However,
    for ever-evolving data, dynamic generation methods provide flexibility and adaptability.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择合适的方法**：考虑数据的生命周期。如果创建后数据集保持静态，静态分配简单且高效。然而，对于不断变化的数据，动态生成方法提供了灵活性和适应性。'
- en: '**Mind the size**: Overpopulating can lead to memory inefficiencies, while
    underpopulating might result in incomplete operations or unexpected behaviors.
    Always be keenly aware of the size requirements.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意大小**：过度填充可能导致内存效率低下，而不足填充可能会导致操作不完整或意外的行为。始终要敏锐地意识到大小需求。'
- en: '**Harness the power of lambdas**: With C++11 and onward, lambdas concisely
    define quick functions. They are invaluable in dynamic generation, allowing for
    tailored functions without the verbosity of traditional function definitions.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用lambda的力量**：从C++11开始，lambda简洁地定义了快速函数。它们在动态生成中非常有价值，允许定义定制函数，而不需要传统函数定义的冗长。'
- en: '**Consider real-world contexts**: Always relate to the problem at hand. If
    you’re populating a container to simulate real-world data, ensure that your filling
    and generating techniques mirror realistic scenarios. It’s not just about filling
    containers but filling them with purpose.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑现实世界情境**：始终将问题与手头的情境联系起来。如果你正在填充容器以模拟现实世界数据，确保你的填充和生成技术反映了现实场景。这不仅仅是填充容器，而是有目的地填充它们。'
- en: To summarize, the ability to effectively fill and generate data in STL containers
    is a testament to the library’s robustness. Whether you’re aiming for uniformity
    with static assignments or seeking the dynamic flair of generated patterns, the
    STL is well-equipped to handle your needs. As we progress toward more intricate
    manipulations in the coming sections, always remember that data is the heart of
    your application. How you shape and nurture it often determines the rhythm and
    pulse of your programs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，STL 容器中有效填充和生成数据的能力证明了该库的强大。无论你是追求静态分配的统一性，还是寻求生成模式的动态魅力，STL 都能很好地满足你的需求。随着我们在接下来的章节中向更复杂的操作迈进，始终要记住，数据是应用程序的核心。你如何塑造和培养它，往往决定了程序的节奏和脉搏。
- en: Removing and replacing in STL containers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 STL 容器中进行移除和替换
- en: In data manipulation using the C++ STL, we often find ourselves adding or viewing
    elements and engaging in curating them. As we peel the layers of this chapter,
    the art of *removing and replacing* emerges as an essential skill, striking the
    perfect balance between retaining the valuable and discarding the redundant. By
    mastering these operations, you can elevate your proficiency in handling STL containers,
    enhancing data relevance and overall efficiency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 C++ STL 进行数据处理时，我们经常发现自己正在添加或查看元素，并参与它们的整理。随着我们揭开本章的层层面纱，*移除和替换* 的艺术成为一项基本技能，在保留有价值的内容和丢弃冗余内容之间取得完美平衡。通过掌握这些操作，你可以提高处理
    STL 容器的熟练度，增强数据的相关性和整体效率。
- en: The essence of removal
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除的本质
- en: When we dive into the rich waters of data storage in the STL, there’s an undeniable
    need for refining. Whether it is the removal of outdated records, anomalies, or
    any redundancies, the STL has powerful tools to assist you. One can pinpoint specific
    values or conditions for purging using functions such as erase and remove. For
    instance, with `std::remove`, it’s possible to relocate particular elements to
    the end of a sequence container, while `erase` can permanently eliminate them.
    It’s this tandem of operations that ensures a seamless cleanup.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入探索 STL 中的数据存储丰富领域时，改进的需求是显而易见的。无论是移除过时的记录、异常值还是任何冗余信息，STL 都提供了强大的工具来协助你。你可以使用诸如
    erase 和 remove 等函数来精确指定要清除的特定值或条件。例如，使用 `std::remove`，可以将特定元素移动到序列容器的末尾，而 `erase`
    则可以永久地删除它们。正是这种操作组合确保了清理过程的流畅性。
- en: Yet, while removal operations are efficient, caution is essential. Mindlessly
    erasing elements can disturb container continuity and even impact performance.
    The key is to employ these operations judiciously and be constantly aware of iterator
    validity and potential reallocations, especially in dynamic containers such as
    `std::vector`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管移除操作效率很高，但谨慎是必要的。盲目地删除元素可能会破坏容器的连续性，甚至影响性能。关键在于明智地使用这些操作，并始终关注迭代器的有效性以及潜在的重新分配，尤其是在
    `std::vector` 等动态容器中。
- en: Replacement
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换
- en: Imagine having a collection of dated values or placeholder elements, and the
    need arises to update them. The STL doesn’t leave you stranded. Functions such
    as `std::replace` and `std::replace_if` are your allies in this endeavor. With
    `std::replace`, you can seamlessly swap old values with new ones throughout your
    collection. For more complex scenarios, where the replacement criteria aren’t
    just a simple value match, `std::replace_if` steps into the spotlight. `std::replace_if`
    allows conditions often expressed through lambdas or function objects to dictate
    the replacement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一组过时的值或占位符元素，需要更新它们。STL 不会让你陷入困境。`std::replace` 和 `std::replace_if` 等函数是你在这个任务中的盟友。使用
    `std::replace`，你可以无缝地在整个集合中交换旧值和新值。对于更复杂的场景，当替换条件不仅仅是简单的值匹配时，`std::replace_if`
    就会成为焦点。`std::replace_if` 允许通过 lambda 表达式或函数对象来指定条件，从而进行替换。
- en: For a hands-on example, consider a collection where negative values are deemed
    errors and need updating. With `std::replace_if`, you can hunt down every negative
    value and replace it with a default or corrected value, all in a single, elegant
    line of code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个动手的例子，考虑一个集合，其中负值被视为错误并需要更新。使用 `std::replace_if`，你可以查找并替换每个负值，用一个默认值或修正值替换，所有这些都在一行优雅的代码中完成。
- en: 'Let’s look at an example of using `std::replace` and `std::replace_if`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `std::replace` 和 `std::replace_if` 的一个例子：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the example output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we use `std::replace` to find and replace a specific value
    (-1) with 0\. We then use `std::replace_if` with a lambda function to identify
    negative values and replace them with 0\. This example demonstrates the use of
    `std::replace` for simple, direct replacements and `std::replace_if` for more
    complex scenarios where a condition (such as identifying negative values) dictates
    the replacement.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `std::replace` 来查找并替换一个特定的值（-1）为 0。然后我们使用 `std::replace_if` 和一个
    lambda 函数来识别负值并将它们替换为 0。这个例子展示了 `std::replace` 在简单直接替换中的应用，以及 `std::replace_if`
    在更复杂场景中的应用，其中条件（如识别负值）决定了替换。
- en: A balancing act
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡的艺术
- en: Balancing removal and replacement requires a sense of rhythm and balance. While
    it is tempting to curate aggressively, sometimes retaining specific data, even
    if outdated or redundant, can serve as a historical record or a point of reference.
    Therefore, always approach removal and replacement with a clear objective, ensuring
    data integrity, relevance, and efficiency aren’t compromised.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡删除和替换需要节奏感和平衡感。虽然积极整理很有吸引力，但有时保留特定数据，即使过时或冗余，也可以作为历史记录或参考点。因此，始终以明确的目标进行删除和替换，确保数据完整性、相关性和效率不受损害。
- en: In this section, we’ve honed the skill of curating and modifying collections,
    focusing on removing and replacing them. This process is pivotal, as it balances
    the retention of valuable data with the elimination of redundancy, enhancing both
    data relevance and container efficiency. We’ve explored the strategic use of functions
    such as `erase` and `remove` for precision in data refinement and the importance
    of cautious removal to maintain container integrity and performance. We learned
    about the replacement techniques using `std::replace` and `std::replace_if`, which
    are instrumental in updating collections, especially when dealing with complex
    conditions. These tools not only ensure the freshness and accuracy of data but
    also highlight the flexibility and power of the STL in data manipulation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们磨练了整理和修改集合的技能，重点关注它们的删除和替换。这个过程至关重要，因为它在保留有价值的数据与消除冗余之间取得平衡，提高了数据的相关性和容器效率。我们探讨了使用
    `erase` 和 `remove` 等函数进行数据精炼的战略使用，以及谨慎删除以保持容器完整性和性能的重要性。我们学习了使用 `std::replace`
    和 `std::replace_if` 的替换技术，这些技术在更新集合中至关重要，尤其是在处理复杂条件时。这些工具不仅确保数据的更新和准确性，而且突出了 STL
    在数据操作中的灵活性和强大功能。
- en: Next, we approach swapping and reversing, demonstrating how to efficiently alter
    the order and positioning of elements within containers, a vital aspect of managing
    and manipulating data structures in C++.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向交换和反转，展示如何有效地改变容器内元素顺序和位置，这是管理和管理 C++ 数据结构的一个关键方面。
- en: Swapping and reversing in STL containers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL 容器中的交换和反转
- en: While we have traversed through adding, initializing, and refining our STL containers,
    there lies an equally intriguing domain where we maneuver and shuffle elements
    to align with our requirements. This section promises to take you on an expedition,
    showcasing the capabilities of the STL in repositioning and reshuffling elements
    while also touching upon intricate manipulations including deduplication and sampling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历添加、初始化和改进我们的 STL 容器时，还有一个同样引人入胜的领域，在那里我们调整和重新排列元素以符合我们的要求。本节承诺带您进行一次探险，展示
    STL 在重新定位和重新排列元素方面的能力，同时也会涉及到包括去重和抽样在内的复杂操作。
- en: Swapping – the art of interchanging
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换——互换的艺术
- en: In many real-world scenarios, the need arises to interchange content between
    containers. Whether for load balancing, data synchronization, or other computational
    tasks, the STL offers the swap function, an efficient and streamlined mechanism.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际场景中，需要在容器之间交换内容。无论是为了负载均衡、数据同步还是其他计算任务，STL 提供了交换函数，这是一个高效且简化的机制。
- en: For instance, the `std::swap` can be used with almost all STL containers. If
    you’ve two `std::vectors` and wish to exchange their contents, `std::swap` does
    the magic in constant time without any overhead of copying or moving individual
    elements. This efficiency is derived from the fact that underlying data pointers
    are swapped, not the actual content.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::swap`可以与几乎所有的STL容器一起使用。如果你有两个`std::vector`并且希望交换它们的内容，`std::swap`可以在常数时间内完成魔法般的交换，而不需要复制或移动单个元素。这种效率来源于底层数据指针的交换，而不是实际内容。
- en: Reversing – a glimpse from the end
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转 – 从末尾的一瞥
- en: Sometimes, looking at things from a different perspective brings clarity, and
    the same holds true for data. The STL provides the `std::reverse` algorithm, which
    inverts the order of elements within a container, offering a fresh view or aiding
    specific computational needs. Whether analyzing data trends or catering to a reverse
    chronological requirement, `std::reverse` ensures your containers can flip their
    sequence in linear time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，从不同的角度看待事物可以带来清晰，对于数据也是如此。STL提供了`std::reverse`算法，它反转容器内元素顺序，提供新的视角或帮助满足特定的计算需求。无论是分析数据趋势还是满足倒序时间要求，`std::reverse`确保你的容器可以在线性时间内翻转其序列。
- en: Deduplication – singling out the unique
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去重 – 突出独特性
- en: As our data grows, so does the likelihood of redundancies. However, the STL
    is well prepared to tackle such situations. The `std::unique` algorithm helps
    remove consecutive duplicates in a sorted sequence. While it does not delete the
    duplicates directly, it repositions them to the end of the container, making it
    convenient to erase them if needed. When paired with `std::sort`, `std::unique`
    becomes a potent tool in ensuring that your container retains only singular instances
    of every element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据量的增长，冗余的可能性也在增加。然而，STL已经做好了应对这种情况的准备。`std::unique`算法有助于在排序序列中移除连续的重复项。虽然它不会直接删除重复项，但它将它们重新定位到容器的末尾，这使得在需要时删除它们变得方便。当与`std::sort`结合使用时，`std::unique`成为确保你的容器仅保留每个元素的唯一实例的有力工具。
- en: Sampling – a slice of the whole
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采样 – 整体的一部分
- en: On occasions, there’s a need to sample a subset from a more extensive collection.
    While the STL does not provide a direct *sample* function, one can derive a sample
    with a combination of other tools, like random shuffle algorithms. By randomly
    shuffling and then selecting the first `n` elements, you get a representative
    sample that can be used for testing, analysis, or any other purpose.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要从更广泛的集合中采样一个子集。虽然STL没有提供直接的*sample*函数，但可以通过组合其他工具，如随机洗牌算法来推导出样本。通过随机洗牌然后选择前`n`个元素，你可以得到一个代表性的样本，可用于测试、分析或其他目的。
- en: Swapping, reversing, deduplication, and sampling are just glimpses into the
    expansive capabilities of the STL. They represent the dynamic nature of data and
    the myriad ways we might need to interact with it. As you continue your journey,
    remember that the STL is more than just tools and functions; it’s a suite designed
    to move, mold, and manage your data efficiently.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 交换、反转、去重和采样只是STL广泛功能的一瞥。它们代表了数据的动态性质以及我们可能需要与之交互的多种方式。在你继续旅程的过程中，请记住，STL不仅仅是工具和函数；它是一个旨在高效移动、塑形和管理你的数据的套件。
- en: Best practices
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Let’s review optimal ways of implementing STL algorithms to ensure efficiency,
    maintain data integrity, and recognize the most apt methods suitable for diverse
    use cases.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾实现STL算法的最佳方式，以确保效率、维护数据完整性和识别最适合各种用例的最合适方法。
- en: '`std::sort` is versatile but may not be optimal for partially sorted sequences,
    where `std::partial_sort` or `std::stable_sort` may prevail.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort`功能多样，但可能不是部分排序序列的最佳选择，此时`std::partial_sort`或`std::stable_sort`可能更为适用。'
- en: '**Prefer algorithms over hand-written loops**: When confronted with tasks like
    searching or sorting, favor STL algorithms over hand-written loops as they are
    optimized and tested extensively, rendering them more reliable and often faster.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先选择算法而不是手写循环**：面对搜索或排序等任务时，优先选择STL算法而不是手写循环，因为它们经过优化和广泛测试，因此更可靠且通常更快。'
- en: '`const` wherever possible. It maintains data integrity and provides better
    interface insights, avoiding accidental modifications.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`const`。它维护数据完整性并提供更好的接口洞察，避免意外修改。
- en: '`std::copy_n` ensures no out-of-bound accesses compared to `std::copy`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::copy_n`确保没有越界访问，与`std::copy`相比。'
- en: '`std::count`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::count`.'
- en: '`std::transform` would be more suited than `std::for_each`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::transform`比`std::for_each`更合适。'
- en: '`std::vector::reserve` to preallocate memory. This practice avoids unnecessary
    reallocations, enhancing performance.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::vector::reserve`进行预分配内存。这种做法避免了不必要的重新分配，提高了性能。
- en: '`std::set` for frequent lookups, can significantly optimize performance.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于频繁查找的`std::set`可以显著优化性能。
- en: '`std::move` help in achieving this.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::move`有助于实现这一点。'
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the essential techniques for altering and shaping data
    within STL containers. We began by understanding the nuances of copying and moving
    semantics in the STL, learning to make deliberate choices between copying versus
    moving elements depending on the context to optimize performance and resource
    management. We then explored RVO, a technique for optimizing compilers that removes
    redundant object copying.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在STL容器内改变和塑造数据的基本技术。我们首先理解了STL中复制和移动语义的细微差别，学习根据上下文在复制与移动元素之间做出有意的选择，以优化性能和资源管理。然后我们探讨了RVO，这是一种优化编译器的技术，它消除了冗余的对象复制。
- en: We then examined the methods for filling and generating container contents,
    which are vital to efficiently initializing and modifying large datasets. We covered
    the mechanisms for removing and replacing elements within containers, balancing
    the need for data integrity with performance. The chapter also introduced the
    operations of swapping and reversing elements, deduplication to eliminate duplicates,
    and sampling to create representative subsets of data. Throughout, we focused
    on best practices to ensure that these operations are executed with precision
    and efficiency.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后检查了填充和生成容器内容的方法，这对于高效初始化和修改大型数据集至关重要。我们涵盖了在容器内删除和替换元素的方法，平衡了数据完整性与性能的需求。本章还介绍了交换和反转元素的操作、去重以消除重复项以及抽样以创建数据的代表性子集。在整个过程中，我们专注于最佳实践，以确保这些操作以精确和高效的方式执行。
- en: As we build more complex programs, we frequently encounter the need to manipulate
    large data sets. Proficiency in these operations enables the creation of more
    sophisticated and performant applications, making the information valuable and
    vital for modern C++ programming.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建更复杂的程序，我们经常需要操作大量数据集。在这些操作方面的熟练程度能够创建更复杂和性能更高的应用程序，使信息对现代C++编程变得有价值且至关重要。
- en: In the next chapter, we will focus on basic and advanced numeric operations
    such as generating sequences, summing elements, and working with adjacent differences
    and inner products. We will also look at operations on sorted ranges, consolidating
    our understanding of how to apply STL algorithms to numerical data, thereby enhancing
    our toolkit for algorithmic problem-solving in C++. This next chapter will continue
    to build on the foundation laid by previous chapters, ensuring a cohesive and
    comprehensive understanding of the STL’s capabilities.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注基本的和高级的数值操作，例如生成序列、求和元素以及处理相邻差分和内积。我们还将研究排序范围上的操作，巩固我们对如何将STL算法应用于数值数据的理解，从而增强我们在C++中进行算法问题解决的工具集。下一章将继续建立在前面章节的基础上，确保对STL功能有一个连贯和全面的理解。
