- en: Chapter 18
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章
- en: Process Synchronization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程同步
- en: This chapter continues our discussion in the previous chapter, *Process Execution*,
    and our main focus will be on process synchronization. Control mechanisms in multi-process
    programs are different from the control techniques we met in multi-threaded programs.
    It is not just the memory which differs; there are other factors that you cannot
    find in a multi-threaded program, and they exist in a multi-process environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续上一章的讨论，即*进程执行*，我们的主要焦点将是进程同步。多进程程序中的控制机制与我们在多线程程序中遇到的控制技术不同。不仅仅是内存不同；还有其他因素在多线程程序中找不到，它们存在于多进程环境中。
- en: Despite threads that are bound to a process, processes can live freely on any
    machine, with any operating system, located anywhere within a network as big as
    the internet. As you might imagine, things become complicated. It will not be
    easy to synchronize a number of processes in such a distributed system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管线程绑定到进程上，但进程可以在任何机器上自由运行，使用任何操作系统，位于互联网大小的网络中的任何位置。正如你可能想象的那样，事情变得复杂。在这样一个分布式系统中同步多个进程将不会容易。
- en: This chapter is dedicated to process synchronization happening in just one machine.
    In other words, it mainly talks about single-host synchronization and the techniques
    around it. We discuss briefly the process synchronization in distributed systems,
    but we won't go into extensive detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论仅在一台机器上发生的进程同步。换句话说，它主要讨论单主机同步及其相关技术。我们简要讨论了分布式系统中的进程同步，但不会深入探讨。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Firstly, we describe multi-process software where all processes are being run
    on the same machine. We introduce the techniques that are available in single-host
    environments. We use the knowledge from the previous chapter in order to give
    some examples that demonstrate these techniques.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们描述了多进程软件，其中所有进程都在同一台机器上运行。我们介绍了单主机环境中的可用技术。我们利用前一章的知识来给出一些示例，以展示这些技术。
- en: In our first attempt to synchronize a number of processes, we use named POSIX
    semaphores. We explain how they should be used and then we give an example that
    resolves a race condition issue we encountered in the previous chapters.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们尝试同步多个进程的第一步中，我们使用了命名POSIX信号量。我们解释了它们应该如何使用，然后给出了一个示例，解决了我们在前几章中遇到的竞态条件问题。
- en: After that, we talk about named POSIX mutexes and we show how we can use shared
    memory regions to have named mutexes up and working. As an example, we solve the
    same race condition resolved by semaphores, this time using named mutexes.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将讨论命名POSIX互斥锁，并展示如何使用共享内存区域来创建并使命名互斥锁生效。作为一个例子，我们解决了一个由信号量解决的相同竞态条件问题，这次使用的是命名互斥锁。
- en: As the last technique to synchronize a number of processes, we discuss named
    POSIX condition variables. Like named mutexes, they need to be put in a shared
    memory region to become accessible to a number of processes. We give a thorough
    example regarding this technique which shows how named POSIX condition variables
    can be used to synchronize a multi-process system.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为同步多个进程的最后一种技术，我们讨论了命名POSIX条件变量。像命名互斥锁一样，它们需要放在共享内存区域中才能被多个进程访问。我们给出了一个关于这一技术的详细示例，展示了如何使用命名POSIX条件变量来同步多进程系统。
- en: As our final discussion in this chapter, we briefly talk about the multi-process
    systems which have their own processes distributed around a network. We discuss
    their features and the problematic differences that they have in comparison to
    a single-host multi-process system.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为本章的最终讨论，我们简要讨论了那些在其网络周围分布有自己进程的多进程系统。我们讨论了它们的特性和与单主机多进程系统相比的问题性差异。
- en: Let us start the chapter with talking a bit more about single-host concurrency
    control and what techniques are available as part of it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以更多关于单主机并发控制和其中可用的技术为话题开始本章。
- en: Single-host concurrency control
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单主机并发控制
- en: It is pretty common to be in situations where there are a number of processes
    running on a single machine that, at the same time, need to have simultaneous
    access to a shared resource. Since all of the processes are running within the
    same operating system, they have access to all the facilities which their operating
    system provides.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个机器上同时运行多个进程，这些进程需要同时访问共享资源是很常见的。由于所有进程都在同一个操作系统下运行，它们可以访问操作系统提供的所有设施。
- en: In this section, we show how to use some of these facilities to create a control
    mechanism that synchronizes the processes. Shared memory plays a key role in most
    of these control mechanisms; therefore, we heavily rely on what we explained about
    shared memory in the previous chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示如何使用这些设施中的某些部分来创建一个同步进程的控制机制。共享内存在这些控制机制中起着关键作用；因此，我们高度依赖我们在上一章中解释的关于共享内存的内容。
- en: 'The following is a list of POSIX-provided control mechanisms that can be employed
    while all processes are running on the same POSIX-compliant machine:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个列表，列出了POSIX提供的控制机制，可以在所有进程都在同一POSIX兼容机器上运行时使用：
- en: '**Named POSIX semaphores**: The same POSIX semaphores that we explained in
    *Chapter 16*, *Thread Synchronization*, but with one difference: they have a name
    now and can be used globally throughout the system. In other words, they are not
    *anonymous* or *private* semaphores anymore.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名POSIX信号量**：与我们第16章“线程同步”中解释的相同POSIX信号量，但有一个区别：现在它们有名字，可以在整个系统中全局使用。换句话说，它们不再是*匿名*或*私有*的信号量了。'
- en: '**Named mutexes**: Again, the same POSIX mutexes with the same properties which
    were explained in *Chapter 16*, *Thread Synchronization*, but now named and can
    be used throughout the system. These mutexes should be placed inside a shared
    memory in order to be available to multiple processes.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名互斥锁**：再次，与第16章“线程同步”中解释的具有相同属性的相同POSIX互斥锁，但现在它们被命名，可以在整个系统中使用。这些互斥锁应放置在共享内存中，以便多个进程可以使用。'
- en: '**Named condition variables**: The same POSIX condition variables which we
    explained in *Chapter 16*, *Thread Synchronization*, but like mutexes, they should
    be placed inside a shared memory object in order to be available to a number of
    processes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名条件变量**：与我们在第16章“线程同步”中解释的相同POSIX条件变量，但像互斥锁一样，它们应放置在共享内存对象中，以便多个进程可以使用。'
- en: In the upcoming sections, we discuss all the above techniques and give examples
    to demonstrate how they work. In the following section, we are going to discuss
    named POSIX semaphores.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论所有上述技术，并给出示例以展示它们是如何工作的。在下一节中，我们将讨论命名POSIX信号量。
- en: Named POSIX semaphores
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名POSIX信号量
- en: As you saw in *Chapter 16*, *Thread Synchronization*, semaphores are the main
    tool to synchronize a number of concurrent tasks. We saw them in multi-threaded
    programs and saw how they help to overcome the concurrency issues.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第16章“线程同步”中看到的，信号量是同步多个并发任务的主要工具。我们在多线程程序中看到了它们，并看到了它们如何帮助克服并发问题。
- en: In this section, we are going to show how they can be used among some processes.
    *Example 18.1* shows how to use a POSIX semaphore to solve the data races we encountered
    in *examples 17.6* and *17.7* given in the previous chapter, *Process Execution*.
    The example is remarkably similar to *example 17.6*, and it again uses a shared
    memory region for storing the shared counter variable. But it uses named semaphores
    to synchronize the access to the shared counter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示它们如何在一些进程之间使用。*示例18.1*展示了如何使用POSIX信号量来解决我们在上一章“进程执行”中给出的*示例17.6*和*17.7*中遇到的数据竞争问题。该示例与*示例17.6*非常相似，并且它再次使用共享内存区域来存储共享计数器变量。但它使用命名信号量来同步对共享计数器的访问。
- en: 'The following code boxes show the way that we use a named semaphore to synchronize
    two processes while accessing a shared variable. The following code box shows
    the global declarations of *example 18.1*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了我们在访问共享变量时使用命名信号量同步两个进程的方式。以下代码框显示了*示例18.1*的全局声明：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 18-1 [ExtremeC_examples_chapter18_1.c]: The global declarations of
    example 18.1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-1 [ExtremeC_examples_chapter18_1.c]：示例18.1的全局声明
- en: In *Code Box 18-1*, we have declared a global counter and a global pointer to
    a semaphore object which will be set later. This pointer will be used by both
    parent and child processes to have synchronized access to the shared counter,
    addressed by the counter pointer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在*代码框18-1*中，我们声明了一个全局计数器和指向信号量对象的全球指针，该指针稍后将设置。这个指针将由父进程和子进程使用，以同步访问由计数器指针指向的共享计数器。
- en: 'The following code shows the function definitions supposed to do the actual
    process synchronization. Some of the definitions are the same as we had in *example
    17.6* and those lines are removed from the following code box:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了预期执行实际进程同步的功能定义。其中一些定义与我们在*示例17.6*中使用的相同，这些行已从以下代码框中删除：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 18-2 [ExtremeC_examples_chapter18_1.c]: The definition of synchronization
    functions'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added two new functions compared to *example 17.6*: `init_control_mechanism`
    and `shutdown_control_mechanism`. We also made some changes to the `inc_counter`
    function (shown in *Code Box 18-3*) to use the semaphore and form a critical section
    inside.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `init_control_mechanism` and `shutdown_control_mechanism` functions,
    we are using a similar API to the shared memory API to open, close, and unlink
    a named semaphore.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The functions `sem_open`, `sem_close`, and `sem_unlink` can be seen as similar
    to `shm_open`, `shm_close`, and `shm_unlink`. There is one difference and that
    is that the function `sem_open` returns a semaphore pointer instead of a file
    descriptor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the API used for working with the semaphore in this example is the
    same as we have seen before, so the rest of the code can remain unchanged as with
    *example 17.6*. In this example, the semaphore is initialized with value `1`,
    which makes it a mutex. The following code box shows the critical section and
    how the semaphore is used to synchronize the read and write operations performed
    on the shared counter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 18-3 [ExtremeC_examples_chapter18_1.c]: The critical section where
    the shared counter is being incremented'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Comparing to *example 17.6*, in the function `inc_counter`, the functions `sem_wait`
    and `sem_post` are used to enter and exit the critical sections, respectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code box, you can see the function `main`. It is almost the
    same as *example 17.6* and we only see some changes in the initial and final parts,
    and that is in accordance with the addition of two new functions seen in *Code
    Box 18-2*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 18-4 [ExtremeC_examples_chapter18_1.c]: The main function of example
    18.1'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following shell box, you can see the output for two successive runs
    of *example 18.1*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 18-1: Building in Linux and two successive runs of example 18.1'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to link the above code with the `pthread` library because
    we are using POSIX semaphores. We need also to link it with the `rt` library in
    Linux in order to use the shared memories.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output is clear. Sometimes the child process gets the CPU first
    and increments the counter, and sometimes the parent process does so. There is
    no time when both enter the critical section, and therefore they satisfy the data
    integrity of the shared counter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is not required to use the fork API in order to use named semaphores.
    Completely separated processes, which are not parent and child, can still open
    and use the same semaphores if they are run on the same machine and inside the
    same operating system. In *example 18.3*, we show how this is possible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'As the final note in this section, you should know that we have two types of
    named semaphores in Unix-like operating systems. One is *System V Semaphores*,
    and the other is *POSIX semaphores*. In this section, we explained the POSIX semaphores
    because they have a better reputation for their nice API and performance. The
    following link is a Stack Overflow question which nicely explains the differences
    between System V semaphores and POSI[X semaphores: https://stackoverflow.com/questions/368322/differences-between-system-v-and-po](https://stackoverflow.com/questions/368322/differences-between-system-v-and-posix-semaphores)six-semaphores.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一条注意事项，您应该知道在类Unix操作系统中，我们有两种类型的命名信号量。一种是**系统V信号量**，另一种是**POSIX信号量**。在本节中，我们解释了POSIX信号量，因为它们因其良好的API和性能而享有更好的声誉。以下链接是一个Stack
    Overflow问题，它很好地解释了系统V信号量和POSIX信号量之间的区别：[https://stackoverflow.com/questions/368322/differences-between-system-v-and-posix-semaphores](https://stackoverflow.com/questions/368322/differences-between-system-v-and-posix-semaphores)
- en: '**Note:**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: Microsoft Windows is not POSIX-compliant in terms of using semaphores, and it
    has its own API to create and manage semaphores.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用信号量的方面，Microsoft Windows不符合POSIX标准，并且它有自己的API来创建和管理信号量。
- en: In the next section, we discuss named mutexes. In short, named mutexes are ordinary
    mutex objects that are put into a shared memory region.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论命名互斥锁。简而言之，命名互斥锁是将普通互斥锁对象放入共享内存区域。
- en: Named mutexes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名互斥锁
- en: POSIX mutexes work simply in multi-threaded programs; we demonstrated this in
    *Chapter 16*, *Thread Synchronization*. This would not be the case with regard
    to multiple process environments, however. To have a mutex work among a number
    of processes, it would need to be defined within a place that is accessible to
    all of them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX互斥锁在多线程程序中工作简单；我们在*第16章*，*线程同步*中展示了这一点。然而，在多个进程环境中则不是这样。为了使互斥锁在多个进程之间工作，它需要在所有进程都可以访问的地方定义。
- en: The best choice for a shared place such as this is a shared memory region. Therefore,
    to have a mutex that works in a multi-process environment, it should be distributed
    in a shared memory region.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个共享位置，最佳选择是共享内存区域。因此，为了在多进程环境中使用互斥锁，它应该分布在共享内存区域中。
- en: The first example
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个示例
- en: The following example, *example 18.2*, is a clone of *example 18.1*, but it
    solves the potential race condition using named mutexes instead of named semaphores.
    It also shows how to make a shared memory region and use it to store a shared
    mutex.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例18.2*，是*示例18.1*的一个克隆，但它使用命名互斥锁而不是命名信号量来解决潜在的竞态条件。它还展示了如何创建共享内存区域并使用它来存储共享互斥锁。
- en: Since each shared memory object has a global name, a mutex stored in a shared
    memory region can be considered *named* and can be accessed by other processes
    throughout the system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个共享内存对象都有一个全局名称，存储在共享内存区域中的互斥锁可以被认为是**命名的**，并且可以通过系统中的其他进程访问。
- en: 'The following code box shows the declarations required for *example 18.2*.
    It shows what is needed for having a shared mutex:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了*示例18.2*所需的声明。它显示了需要共享互斥锁的内容：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 18-5 [ExtremeC_examples_chapter18_2.c]: The global declarations of
    example 18.2'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-5 [ExtremeC_examples_chapter18_2.c]：示例18.2的全局声明
- en: 'As you can see, we have declared:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经声明了：
- en: A global file descriptor for pointing to a shared memory region that is meant
    to store the shared counter variable
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全局文件描述符，用于指向一个存储共享计数器变量的共享内存区域
- en: A global file descriptor for the shared memory region storing the shared mutex
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储共享互斥锁的共享内存区域的全局文件描述符
- en: A pointer to the shared counter
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享计数器的指针
- en: A pointer to the shared mutex
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享互斥锁的指针
- en: These variables will be populated accordingly by the upcoming logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将由即将到来的逻辑相应填充。
- en: 'The following code boxes show all the functions we had in *example 18.1*, but
    as you see, the definitions are updated to work with a named mutex instead of
    a named semaphore:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了我们在*示例18.1*中拥有的所有函数，但如您所见，定义已更新以使用命名互斥锁而不是命名信号量：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 18-6 [ExtremeC_examples_chapter18_2.c]: The function init_control_mechanism
    in example 18.2'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-6 [ExtremeC_examples_chapter18_2.c]：示例18.2中的init_control_mechanism函数
- en: As part of the function `init_control_mechanism`, we have created a new shared
    memory object named `/mutex0`. The size of the shared memory region is initialized
    to `sizeof(pthread_mutex_t)` which shows our intention to share a POSIX mutex
    object there.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数`init_control_mechanism`的一部分，我们创建了一个名为`/mutex0`的新共享内存对象。共享内存区域的大小初始化为`sizeof(pthread_mutex_t)`，这表明我们的意图是在那里共享一个POSIX互斥锁对象。
- en: 'Following that, we get a pointer to the shared memory region. Now we have a
    mutex which is allocated from the shared memory, but it still needs to be initialized.
    The next step is therefore to initialize the mutex object using the function `pthread_mutex_init`,
    with attributes that indicate that the mutex object should be shared and accessible
    by other processes. This is especially important; otherwise, the mutex does not
    work in a multi-process environment, even though it is placed inside a shared
    memory region. As you have seen in the preceding code box and as part of the function
    `init_control_mechanism`, we have set the attribute `PTHREAD_PROCESS_SHARED` to
    mark the mutex as shared. Let''s look at the next function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们得到共享内存区域的指针。现在我们有一个从共享内存分配的互斥锁，但它仍然需要初始化。因此，下一步是使用函数`pthread_mutex_init`初始化互斥锁对象，并使用属性指示互斥锁对象应该是共享的，并且可以被其他进程访问。这一点尤为重要；否则，即使在共享内存区域内部，互斥锁在多进程环境中也不会工作。正如你在前面的代码框中看到的，以及在函数`init_control_mechanism`中，我们已经设置了属性`PTHREAD_PROCESS_SHARED`来标记互斥锁为共享的。让我们看看下一个函数：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 18-7 [ExtremeC_examples_chapter18_2.c]: The function destroy_control_mechanism
    in example 18.2'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-7 [ExtremeC_examples_chapter18_2.c]：示例 18.2 中的函数 destroy_control_mechanism
- en: 'In the function `destroy_control_mechanism` we destroy the mutex object, and
    after that we close and unlink its underlying shared memory region. This is the
    same way that we destroy an ordinary shared memory object. Let''s continue with
    other codes in the example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`destroy_control_mechanism`中，我们销毁了互斥锁对象，然后关闭并解除链接其底层的共享内存区域。这与销毁一个普通共享内存对象的方式相同。让我们继续看示例中的其他代码：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 18-8 [ExtremeC_examples_chapter18_2.c]: These functions are the same
    as we have seen in example 18.1'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-8 [ExtremeC_examples_chapter18_2.c]：这些函数与我们之前在示例 18.1 中看到的是一样的
- en: As you see, the preceding functions are not changed at all and they are the
    same as we had in *example 18.1*. Let's look at the critical section inside the
    function `inc_counter` which now uses a named mutex instead of a named semaphore.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，前面的函数完全没有改变，它们与我们之前在*示例 18.1*中看到的是一样的。让我们看看函数`inc_counter`内部的临界区，现在它使用命名互斥锁而不是命名信号量。
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 18-9 [ExtremeC_examples_chapter18_2.c]: The critical section now uses
    a named mutex to protect the shared counter'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-9 [ExtremeC_examples_chapter18_2.c]：现在关键部分使用命名互斥锁来保护共享计数器
- en: Generally, as you see in the preceding code boxes, a few places are different
    from *example 18.1*, and we have had to change only three functions greatly. For
    instance, the function `main` has not changed at all, and it is the same as in
    *example 18.1*. This is simply because we have used a different control mechanism
    in comparison to *example 18.1*, and the remaining logic is the same.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，正如你在前面的代码框中看到的，只有几个地方与*示例 18.1*不同，我们只对三个函数进行了重大修改。例如，函数`main`完全没有改变，它与*示例
    18.1*中的相同。这仅仅是因为我们与*示例 18.1*相比使用了不同的控制机制，而其余的逻辑是相同的。
- en: As the final note about *Code Box 18-9*, in the function `inc_counter`, we have
    used the mutex object exactly as we did in a multi-threaded program. The API is
    the same, and it is designed in a way that mutexes can be used both in multi-threaded
    and multi-process environments using the same API. This is a great feature of
    POSIX mutexes because it enables us to use the same written code in both multi-threaded
    and multi-process environments when consuming these objects – while of course,
    the initialization and destruction can be different.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*代码框 18-9*的最后一项说明，在函数`inc_counter`中，我们使用了互斥对象，就像我们在多线程程序中所做的那样。API是相同的，并且它被设计成可以在多线程和多进程环境中使用相同的API来使用互斥锁。这是POSIX互斥锁的一个伟大特性，因为它使我们能够在多线程和多进程环境中使用相同的代码来消费这些对象——当然，初始化和销毁可以不同。
- en: The output of the preceding code is very similar to what we observed for *example
    18.1*. While the shared counter is protected by a mutex in this example, it was
    being protected by a semaphore in the previous example. The semaphore used in
    the previous example was actually a binary semaphore, and as we have explained
    in *Chapter 16*, *Thread Synchronization*, a binary semaphore can mimic a mutex.
    Therefore, not much is new in *example 18.2*, apart from replacing the binary
    semaphore with a mutex.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出与我们观察到的 *示例 18.1* 非常相似。虽然在这个例子中共享计数器由互斥锁保护，但在上一个例子中它是由信号量保护的。上一个例子中使用的信号量实际上是一个二进制信号量，正如我们在
    *第 16 章*，*线程同步* 中所解释的，二进制信号量可以模拟互斥锁。因此，除了将二进制信号量替换为互斥锁之外，*示例 18.2* 中并没有太多新内容。
- en: The second example
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个示例
- en: The named shared memories and mutexes can be used throughout the system by any
    process. It is not mandatory to have a forked process to be able to use these
    objects. The following example, *example 18.3*, tries to show how we can use a
    shared mutex and a shared memory to simultaneously terminate a number of processes
    that are all running at the same time. We expect to have all processes terminated
    after pressing the key combination `Ctrl` + `C` in only one of them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的共享内存和互斥锁可以被系统中的任何进程使用。不需要有派生的进程才能使用这些对象。下面的例子，*示例 18.3*，试图展示我们如何使用共享互斥锁和共享内存同时终止所有同时运行的进程。我们期望在按下其中一个进程的键组合
    `Ctrl` + `C` 后，所有进程都将终止。
- en: Note that the code is going to be provided in multiple steps. The comments related
    to each step are provided right after it. Let's present the first step.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码将分多步提供。与每个步骤相关的注释将紧随其后。让我们先展示第一步。
- en: Step 1 – Global declarations
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1 – 全局声明
- en: In this example, we write a single source file that can be compiled and executed
    multiple times to create multiple processes. The processes use some shared memory
    regions to synchronize their execution. One of the processes is elected to be
    the owner of the shared memory regions and manages their creation and destruction.
    Other processes just use the created shared memories.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们编写一个可以编译和执行多次的单个源文件，以创建多个进程。这些进程使用一些共享内存区域来同步它们的执行。其中一个进程被选为共享内存区域的拥有者，并管理它们的创建和销毁。其他进程只是使用创建的共享内存。
- en: 'The first step is going to declare some global objects that we need throughout
    the code. We will initialize them later on in the code. Note that the global variables
    defined in the following code box, such as `mutex`, are not actually shared between
    the processes. They have these variables in their own memory space but each of
    the processes maps their own global variable to the objects or variables located
    in the various shared memory regions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是声明一些我们在整个代码中需要的全局对象。我们将在代码的后面部分初始化它们。请注意，在以下代码框中定义的全局变量，如 `mutex`，实际上并不是在进程间共享的。它们在自己的内存空间中有这些变量，但每个进程都将自己的全局变量映射到位于各个共享内存区域中的对象或变量：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 18-10 [ExtremeC_examples_chapter18_3.c]: The global declaration in
    example 18.3'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-10 [ExtremeC_examples_chapter18_3.c]：示例 18.3 中的全局声明
- en: In the preceding code, we can see the global declarations used in the code.
    We are going to use a shared flag to let the processes know about the cancellation
    signal. Note that, in this example, we are going to take the busy-wait approach
    to wait for the cancellation flag to become `true`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到代码中使用的全局声明。我们将使用一个共享标志让进程知道取消信号。请注意，在这个例子中，我们将采用忙等待的方法来等待取消标志变为
    `true`。
- en: We have a dedicated shared memory object for the cancellation flag and another
    shared memory object for the mutex protecting the flag as we did in *example 18.2*.
    Note that we could construct a single structure and define both the cancellation
    flag and the mutex object as its fields, and then use a single shared memory region
    to store them. But we have chosen to use separate shared memory regions to fulfill
    our purpose.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门的共享内存对象用于取消标志，还有一个共享内存对象用于保护标志的互斥锁，就像我们在 *示例 18.2* 中做的那样。请注意，我们可以构造一个单一的结构，并将取消标志和互斥锁对象定义为它的字段，然后使用一个单一的共享内存区域来存储它们。但我们选择使用单独的共享内存区域来实现我们的目的。
- en: 'In this example, one important note about the shared memory objects is that
    the cleanup should be performed by the process which has created and initialized
    them in the first place. Since all processes are using the same code, somehow,
    we need to know which process has created a certain shared memory object and make
    that process the owner of that object. Then, while cleaning up the objects, only
    the owner process can proceed and do the actual cleanup. Therefore, we had to
    declare two Boolean variables for this purpose: `mutex_owner` and `cancel_flag_shm_owner`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，关于共享内存对象的一个重要注意事项是，清理工作应由最初创建和初始化它们的进程执行。由于所有进程都在使用相同的代码，我们 somehow 需要知道哪个进程创建了一个特定的共享内存对象，并使该进程成为该对象的拥有者。然后，在清理对象时，只有拥有者进程可以继续并进行实际的清理。因此，我们不得不为此目的声明了两个布尔变量：`mutex_owner`和`cancel_flag_shm_owner`。
- en: Step 2 – Cancellation flag's shared memory
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 - 取消标志的共享内存
- en: 'The following code box shows the initialization of the shared memory region
    dedicated to the cancellation flag:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了专门用于取消标志的共享内存区域的初始化：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 18-11 [ExtremeC_examples_chapter18_3.c]: Initialization of the cancellation
    flag''s shared memory'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-11 [ExtremeC_examples_chapter18_3.c]：取消标志共享内存的初始化
- en: The approach we took is different from what we did in *example 18.2*. That's
    because whenever a new process is run, it should check whether the shared memory
    object has already been created by another process. Note that we are not using
    the fork API to create new processes as part of this example and the user can
    use their shell and start a new process at will.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的方法与我们之前在*示例 18.2*中所做的方法不同。这是因为每当运行一个新的进程时，它都应该检查共享内存对象是否已经被另一个进程创建。请注意，在这个例子中，我们没有使用`fork`
    API来创建新进程，用户可以使用他们的shell随意启动新进程。
- en: For this reason, a new process first tries to open the shared memory region
    by only providing the flag `O_RDWR`. If it succeeds, then it's a sign that the
    current process is not the owner of that region, and it proceeds with mapping
    the shared memory region. If it fails, it means that the shared memory region
    does not exist, and it is an indication that the current process should create
    the region and becomes its owner. So, it proceeds and tries to open the region
    with different flags; `O_CREAT` and `O_EXCL`. These flags create a shared memory
    object if it does not exist.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新进程首先尝试仅通过提供标志`O_RDWR`来打开共享内存区域。如果成功，则表明当前进程不是该区域的拥有者，然后它继续映射共享内存区域。如果失败，则表示共享内存区域不存在，这是当前进程应该创建该区域并成为其拥有者的一个指示。因此，它继续尝试以不同的标志打开区域；`O_CREAT`和`O_EXCL`。这些标志在不存在的情况下创建共享内存对象。
- en: If the creation succeeds, the current process is the owner, and it continues
    by truncating and mapping the shared memory region.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建成功，则当前进程是拥有者，并且它继续通过截断和映射共享内存区域。
- en: There is a small chance that between the two successive calls of the `shm_open`
    function in the previous scenario, another process creates the same shared memory
    region, and therefore the second `shm_open` fails. The flag `O_EXCL` prevents
    the current process from creating an object which already exists, and then it
    quits by showing a proper error message. If this happens, which should be very
    rare, we can always try to run the process again and it won't face the same issue
    in the second run.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个场景中，`shm_open`函数的两次连续调用之间，另一个进程可能会创建相同的共享内存区域，因此第二次`shm_open`调用失败。标志`O_EXCL`防止当前进程创建一个已经存在的对象，然后通过显示适当的错误消息退出。如果发生这种情况，这应该非常罕见，我们总是可以尝试再次运行该进程，并且在第二次运行中它不会遇到同样的问题。
- en: 'The following code is the reverse operation for destructing the cancellation
    flag and its shared memory region:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于撤销取消标志及其共享内存区域的反向操作：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 18-12 [ExtremeC_examples_chapter18_3.c]: Closing the resources allocated
    for the cancellation flag''s shared memory'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-12 [ExtremeC_examples_chapter18_3.c]：关闭为取消标志共享内存分配的资源
- en: As you can see in *Code Box 18-12*, the written logic is very similar to what
    we've seen so far, as part of previous examples, about releasing a shared memory
    object. But there is a difference here and it is the fact that only the owner
    process can unlink the shared memory object. Note that the owner process waits
    for 1 second before unlinking the shared memory object, in order to let other
    processes finalize their resources. This wait is not usually necessary due to
    the fact that, in most POSIX-compliant systems, the shared memory object remains
    in place until all depending processes quit.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*代码框 18-12*中看到的，书写的逻辑与我们之前在释放共享内存对象的部分示例中看到的内容非常相似。但这里有一个区别，那就是只有所有者进程才能解除共享内存对象的链接。请注意，所有者进程在解除共享内存对象的链接之前会等待
    1 秒，以便让其他进程完成资源释放。由于在大多数 POSIX 兼容系统中，共享内存对象会一直保留，直到所有依赖的进程退出，因此这种等待通常是不必要的。
- en: Step 3 – Named mutex's shared memory
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 命名互斥锁的共享内存
- en: 'The following code box shows how to initialize the shared mutex and its associated
    shared memory object:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了如何初始化共享互斥锁及其关联的共享内存对象：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 18-13 [ExtremeC_examples_chapter18_3.c]: Initializing the shared mutex
    and its underlying shared memory region'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-13 [ExtremeC_examples_chapter18_3.c]：初始化共享互斥锁及其底层共享内存区域
- en: Similarly to what we did while trying to create the shared memory region associated
    with the cancellation flag, we have done the same thing to create and initialize
    the shared memory region beneath the shared mutex. Note that, just like in *example
    18.2*, the mutex has been marked as `PTHREAD_PROCESS_SHARED`, which allows it
    to be used by multiple processes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们尝试创建与取消标志关联的共享内存区域时所做的操作类似，我们为创建和初始化共享互斥锁下的共享内存区域做了同样的事情。请注意，就像在 *示例 18.2*
    中一样，互斥锁已被标记为 `PTHREAD_PROCESS_SHARED`，这允许它被多个进程使用。
- en: 'The following code box shows how to finalize the shared mutex:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了如何最终化共享互斥锁：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 18-14 [ExtremeC_examples_chapter18_3.c]: Closing the shared mutex
    and its associated shared memory region'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-14 [ExtremeC_examples_chapter18_3.c]：关闭共享互斥锁及其关联的共享内存区域
- en: Again, the owner process can only unlink the shared memory object of the shared
    mutex.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有者进程只能解除共享互斥锁的共享内存对象的链接。
- en: Step 4 – Setting the cancellation flag
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 设置取消标志
- en: 'The following code box shows the functions which allow the processes to read
    or set the cancellation flag:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了允许进程读取或设置取消标志的函数：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code Box 18-15 [ExtremeC_examples_chapter18_3.c]: The synchronized functions
    that read and set the cancellation flag protected by the shared mutex'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-15 [ExtremeC_examples_chapter18_3.c]：受共享互斥锁保护的读取和设置取消标志的同步函数
- en: The preceding two functions allow us to have synchronized access to the shared
    cancellation flag. The function `is_canceled` is used to check the value of the
    flag, and the function `cancel` is used to set the flag. As you see, both are
    protected by the same shared mutex.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数允许我们对共享取消标志进行同步访问。函数 `is_canceled` 用于检查标志的值，而函数 `cancel` 用于设置标志。如您所见，这两个函数都受到相同的共享互斥锁的保护。
- en: Step 5 – The main function
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步 – 主函数
- en: 'And finally, the following code box shows the `main` function and a *signal
    handler* which we explain shortly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码框显示了 `main` 函数和一个我们将简要解释的 *信号处理程序*：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code Box 18-16 [ExtremeC_examples_chapter18_3.c]: The function main and the
    signal handler function as part of example 18.3'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 18-16 [ExtremeC_examples_chapter18_3.c]：示例 18.3 中的 main 函数和信号处理函数
- en: As you see, the logic inside the `main` function is clear and straightforward.
    It initializes the shared flag and mutex and then goes into a busy-wait until
    the cancellation flag becomes `true`. Finally, it shuts down all shared resources
    and terminates.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`main` 函数内部的逻辑清晰且直接。它初始化共享标志和互斥锁，然后进入忙等待状态，直到取消标志变为 `true`。最后，它关闭所有共享资源并终止。
- en: One thing which is new here is the usage of the `signal` function which assigns
    a signal handler to a specific set of *signals*. Signals are one of the facilities
    provided by all POSIX-compliant operating systems and using it, the processes
    within the system can send signals to each other. The *terminal* is just one normal
    process that the user interacts with and it can be used to send signals to other
    processes. Pressing `Ctrl` + `C` is one convenient way to send `SIGINT` to the
    foreground process running in a terminal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里新的是 `signal` 函数的使用，它将信号处理器分配给特定的 *信号* 集合。信号是所有 POSIX 兼容操作系统提供的一种设施，使用它可以，系统内的进程可以向彼此发送信号。*终端*
    是用户与之交互的一个普通进程，它可以用来向其他进程发送信号。按下 `Ctrl` + `C` 是向终端中运行的前台进程发送 `SIGINT` 的一种方便方法。
- en: '`SIGINT` is the *interrupt signal* which can be received by a process. In the
    preceding code, we assign the function `sigint_handler` to be the handler of the
    `SIGINT` signal. In other words, whenever the signal `SIGINT` is received by the
    process, the function `sigint_handler` will be called. If the signal `SIGINT`
    is not handled, the default routine is to terminate the process, but this can
    be overridden using signal handlers like above.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGINT` 是进程可以接收的 *中断信号*。在前面代码中，我们将函数 `sigint_handler` 分配为 `SIGINT` 信号的处理器。换句话说，每当进程接收到
    `SIGINT` 信号时，函数 `sigint_handler` 将被调用。如果未处理 `SIGINT` 信号，则默认操作是终止进程，但可以使用如上所示的信号处理器来覆盖此操作。'
- en: There are many ways to send a `SIGINT` signal to a process, but one of the easiest
    is to press the `Ctrl` + `C` keys on the keyboard. The process will immediately
    receive the `SIGINT` signal. As you see, within the signal handler, we set the
    shared cancellation flag to `true`, and after this point, all the processes start
    to exit their busy-wait loops.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 向进程发送 `SIGINT` 信号有许多方法，但其中最简单的一种是在键盘上按下 `Ctrl` + `C` 键。进程将立即接收到 `SIGINT` 信号。正如你所见，在信号处理程序中，我们将共享取消标志设置为
    `true`，从这一点开始，所有进程开始退出它们的忙等待循环。
- en: 'Following is a demonstration of how the preceding code compiles and works.
    Let''s build the preceding code and run the first process:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何编译和运行前面代码的演示。让我们构建前面的代码并运行第一个进程：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Shell Box 18-2: Compilation of example 18.3 and running the first process'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-2：编译示例 18.3 并运行第一个进程
- en: 'As you see, the preceding process is the first to be run, and therefore, it
    is the owner of the mutex and cancellation flag. The following is the run of the
    second process:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，前面的进程是首先运行的，因此它是互斥锁和取消标志的所有者。以下为第二个进程的运行情况：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shell Box 18-3: Running the second process'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-3：运行第二个进程
- en: 'As you see, the second process only opens the shared memory objects, and it
    is not the owner. The following output is showing when `Ctrl` + `C` has been pressed
    on the first process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，第二个进程只打开了共享内存对象，它不是所有者。以下输出是在第一个进程上按下 `Ctrl` + `C` 后的输出：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 18-4: The output of the first process when Ctrl + C has been pressed'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-4：按下 Ctrl + C 后第一个进程的输出
- en: 'As you see, the first process prints that it is handling a signal with the
    number `2` which is the standard signal number of the `SIGINT`. It sets the cancellation
    flag, and it exits immediately. And following it, the second process exits. The
    following is the output of the second process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，第一个进程打印出它正在处理编号为 `2` 的信号，这是 `SIGINT` 的标准信号编号。它设置了取消标志，并立即退出。随后，第二个进程退出。以下为第二个进程的输出：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 18-5: The output of the second process when it sees that the cancellation
    flag is set'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-5：当第二个进程看到取消标志被设置时的输出
- en: Also, you can send `SIGINT` to the second process and the result will be the
    same; both processes will get the signal and will quit. Also, you can create more
    than two processes and all of them will synchronously quit using the same shared
    memory and mutex.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以向第二个进程发送 `SIGINT` 信号，结果将相同；两个进程都会接收到信号并退出。你也可以创建超过两个进程，并且它们都将使用相同的共享内存和互斥锁同步退出。
- en: In the next section, we demonstrate how to use condition variables. Like named
    mutexes, if you place a condition variable inside a shared memory region, it can
    be accessed and used by multiple processes using the shared memory's name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何使用条件变量。就像命名互斥锁一样，如果你在共享内存区域中放置一个条件变量，它可以通过共享内存的名称被多个进程访问和使用。
- en: Named condition variables
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名条件变量
- en: As we explained before, similar to named POSIX mutexes, we need to allocate
    a POSIX condition variable from a shared memory region in order to use it in a
    multi-processing system. The following example, *example 18.4*, shows how to do
    so in order to make a number of processes count in a specific order. As you know
    from *Chapter 16*, *Thread Synchronization*, every condition variable should be
    used together with a companion mutex object which protects it. Therefore, we will
    have three shared memory regions in *example 18.4*; one for the shared counter,
    one for the shared *named condition variable*, and one for the shared *named mutex*
    protecting the shared condition variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，与命名 POSIX 互斥锁类似，为了在多进程系统中使用它，我们需要从共享内存区域分配一个 POSIX 条件变量。以下示例，*示例 18.4*，展示了如何这样做，以便让多个进程按特定顺序计数。正如您从
    *第 16 章*，*线程同步* 中所知，每个条件变量都应该与一个保护它的伴随互斥对象一起使用。因此，在 *示例 18.4* 中，我们将有三个共享内存区域；一个用于共享计数器，一个用于共享
    *命名条件变量*，还有一个用于保护共享条件变量的共享 *命名互斥锁*。
- en: Note that instead of having three different shared memories, we could also use
    a single shared memory. This is possible by defining a structure that encompasses
    all the required objects. In this example, we are not going to take this approach
    and we will define a separate shared memory region for each object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以使用单个共享内存而不是三个不同的共享内存。这是通过定义一个包含所有所需对象的结构的实现。在这个例子中，我们不会采取这种方法，我们将为每个对象定义一个单独的共享内存区域。
- en: '*Example 18.4* is about a number of processes which should count in an ascending
    order. Each process is given a number, starting from 1 and up to the number of
    processes, and the given number indicates the process''s rank within the other
    processes. The process must wait for the other processes with smaller numbers
    (ranks) to count first and then it can count its turn and exit. Of course, the
    process assigned the number 1 counts first, even if it is the latest spawned process.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 18.4* 是关于一些进程，它们应该按升序计数。每个进程都会被分配一个数字，从 1 开始，到进程的数量，给定的数字表示该进程在其他进程中的排名。进程必须等待排名（编号）较小的其他进程先计数，然后它才能计数并退出。当然，分配编号
    1 的进程将首先计数，即使它是最后创建的进程。'
- en: Since we are going to have three different shared memory regions, each of which
    requiring its own steps to get initialized and finalized, we would have a lot
    of code duplication if we wanted to take the same approach as we have so far in
    the previous examples. For reducing the amount of code that we write, and factoring
    out the duplications into some functions, and having a better-organized code,
    we are going to make it object-oriented according to the topics and procedures
    discussed in *Chapter 6*, *OOP and Encapsulation*, *Chapter 7*, *Composition and
    Aggregation*, and *Chapter 8*, *Inheritance and Polymorphism*. We are going to
    write *example 18.4* in an object-oriented manner and use inheritance to reduce
    the amount of duplicated code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将有三个不同的共享内存区域，每个区域都需要自己的初始化和终止步骤，如果我们想要采取与之前示例中相同的方法，那么我们将有大量的代码重复。为了减少我们编写的代码量，将重复的部分提取到一些函数中，并使代码组织得更好，我们将根据
    *第 6 章*，*面向对象编程和封装*，*第 7 章*，*组合和聚合*，以及 *第 8 章*，*继承和多态* 中讨论的主题和程序，将其做成面向对象的。我们将以面向对象的方式编写
    *示例 18.4*，并使用继承来减少重复代码的数量。
- en: We will define a parent class for all classes which need to be built upon a
    shared memory region. Therefore, while having the parent shared memory class,
    there will be one child class defined for the shared counter, one child class
    for the shared named mutex, and another child class for the shared named condition
    variable. Each class will have its own pair of header and source files, and all
    of them will be used finally in the main function of the example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为所有需要建立在共享内存区域之上的类定义一个父类。因此，在拥有父共享内存类的同时，我们将定义一个子类用于共享计数器，一个子类用于共享命名互斥锁，另一个子类用于共享命名条件变量。每个类都将有自己的头文件和源文件对，所有这些最终都将用于示例的主函数中。
- en: 'The following sections go through the mentioned classes one by one. First of
    all, let''s being with the parent class: shared memory.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将逐个介绍所提到的类。首先，让我们从父类：共享内存开始。
- en: Step 1 – Class of shared memory
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 步 – 共享内存类
- en: 'The following code box shows the declarations of the shared memory class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了共享内存类的声明：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 18-17 [ExtremeC_examples_chapter18_4_shared_mem.h]: The public interface
    of the shared memory class'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 18-17 [ExtremeC_examples_chapter18_4_shared_mem.h]: 共享内存类的公共接口'
- en: The preceding code contains the declarations (public API) needed to use a shared
    memory object. The functions `shared_mem_getptr`, `shared_mem_isowner`, and `shared_mem_setowner`
    are the behaviors of this class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含了使用共享内存对象所需的所有声明（公共 API）。函数 `shared_mem_getptr`，`shared_mem_isowner`
    和 `shared_mem_setowner` 是这个类的行为。
- en: If this syntax is not familiar to you, please have a read of *Chapter 6*, *OOP
    and Encapsulation*, *Chapter 7*, *Composition and Aggregation*, and *Chapter 8*,
    *Inheritance and Polymorphism*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个语法对你来说不熟悉，请阅读 *第 6 章*，*面向对象编程和封装*，*第 7 章*，*组合和聚合*，以及 *第 8 章*，*继承和多态*。
- en: 'The following code box shows the definitions of the functions declared as part
    of the public interface of the class, as seen in *Code Box 18-17*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了作为类公共接口一部分的函数定义，正如在 *代码框 18-17* 中所见：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code Box 18-18 [ExtremeC_examples_chapter18_4_shared_mem.c]: The definitions
    of all functions found in the shared memory class'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 18-18 [ExtremeC_examples_chapter18_4_shared_mem.c]: 共享内存类中找到的所有函数的定义'
- en: As you see, we have just copied the code we wrote for shared memories as part
    of the previous examples. The structure `shared_mem_t` encapsulates all we need
    to address a POSIX shared memory object. Note the global Boolean variable `process_owner`.
    It indicates whether the current process is the owner of all shared memory regions.
    It is set only once.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是复制了之前示例中为共享内存编写的代码。结构 `shared_mem_t` 封装了我们用来访问 POSIX 共享内存对象所需的所有内容。注意全局布尔变量
    `process_owner`。它表示当前进程是否是所有共享内存区域的拥有者。它只设置一次。
- en: Step 2 – Class of shared 32-bit integer counter
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 – 共享 32 位整数计数器类
- en: 'The following code box contains the declaration of the shared counter class
    which is a 32-bit integer counter. This class inherits from the shared memory
    class. As you might have noticed, we are using the second approach we described
    as part of *Chapter 8*, *Inheritance and Polymorphism*, to implement the inheritance
    relationship:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含共享计数器类的声明，这是一个 32 位整数计数器。这个类从共享内存类继承。正如你可能已经注意到的，我们正在使用 *第 8 章*，*继承和多态*
    中描述的第二种方法来实现继承关系：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 18-19 [ExtremeC_examples_chapter18_4_shared_int32.h]: The public interface
    of the shared counter class'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 18-19 [ExtremeC_examples_chapter18_4_shared_int32.h]: 共享计数器类的公共接口'
- en: 'And the following code box shows the implementations of the preceding declared
    functions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了前面声明的函数的实现：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code Box 18-20 [ExtremeC_examples_chapter18_4_shared_int32.c]: The definitions
    of all functions found in the shared counter class'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 18-20 [ExtremeC_examples_chapter18_4_shared_int32.c]: 共享计数器类中找到的所有函数的定义'
- en: As you can see, we have written a lot less code thanks to inheritance. All the
    necessary code for managing the associated shared memory object has been brought
    in by the field `shm` in the structure `shared_int32_t`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于继承，我们编写了更少的代码。管理相关共享内存对象所需的所有代码都通过结构 `shared_int32_t` 中的字段 `shm` 带入。
- en: Step 3 – Class of shared mutex
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 步 – 共享互斥器类
- en: 'The following code box contains the declaration of the shared mutex class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含共享互斥器类的声明：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 18-21 [ExtremeC_examples_chapter18_4_shared_mutex.h]: The public interface
    of the shared mutex class'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 18-21 [ExtremeC_examples_chapter18_4_shared_mutex.h]: 共享互斥器类的公共接口'
- en: As you see, the above class has three exposed behaviors as expected; `shared_mutex_lock`,
    `shared_mutex_unlock`, and `shared_mutex_make_consistent`. But there is one exception,
    which is that the behavior `shared_mutex_make_consistent` is only available in
    POSIX systems which are not macOS (Apple) based. That's because *robust mutexes*
    are not supported by Apple systems. We will discuss what a robust mutex is in
    the upcoming paragraphs. Note that we have used the macro `__APPLE__` to detect
    whether we are compiling on an Apple system or not.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，上述类有三种预期的公开行为；`shared_mutex_lock`，`shared_mutex_unlock` 和 `shared_mutex_make_consistent`。但有一个例外，即行为
    `shared_mutex_make_consistent` 只在 POSIX 系统中可用，不包括基于 macOS（苹果）的系统。这是因为苹果系统不支持 *健壮互斥锁*。我们将在接下来的段落中讨论什么是健壮互斥锁。请注意，我们使用了宏
    `__APPLE__` 来检测我们是否在苹果系统上编译。
- en: 'The following code box shows the implementation of the preceding class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了前面类实现的代码：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Code Box 18-22 [ExtremeC_examples_chapter18_4_shared_mutex.c]: The definitions
    of all functions found in the shared named mutex class'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-22 [ExtremeC_examples_chapter18_4_shared_mutex.c]：共享命名互斥类中找到的所有函数的定义
- en: In the preceding code, we do only the POSIX mutex initialization, finalization,
    and exposing some of the trivial behaviors such as locking and unlocking. Everything
    else regarding the shared memory object is being handled in the shared memory
    class. That's a benefit of using inheritance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只进行了POSIX互斥锁的初始化、终止和暴露一些简单的行为，例如锁定和解锁。与共享内存对象相关的所有其他事情都在共享内存类中处理。这就是使用继承的好处。
- en: Note that in the constructor function `shared_mutex_ctor`, we set the mutex
    as a *shared process* mutex to be accessible to all processes. This is absolutely
    necessary to multi-process software. Note that in systems which are not Apple-based,
    we go further and configure the mutex as a *robust mutex*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在构造函数`shared_mutex_ctor`中，我们将互斥锁设置为*共享进程*互斥锁，使其对所有进程可访问。这对于多进程软件来说是绝对必要的。注意，在非苹果系统上，我们更进一步，将互斥锁配置为*健壮互斥锁*。
- en: For an ordinary mutex that is locked by a process, if the process should suddenly
    die then the mutex goes into a non-consistent state. For a robust mutex, if this
    happens, the mutex can be put back in a consistent state. The next process, which
    is usually waiting for the mutex, can lock the mutex only by making it consistent.
    You can see how it can be done in the function `shared_mutex_lock`. Note that
    this functionality is not present in Apple systems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于被进程锁定的普通互斥锁，如果进程突然死亡，则互斥锁进入非一致状态。对于健壮互斥锁，如果发生这种情况，互斥锁可以被放回一致状态。下一个通常等待互斥锁的进程只能通过使其一致来锁定互斥锁。你可以在`shared_mutex_lock`函数中看到如何做到这一点。注意，这种功能在苹果系统中不存在。
- en: Step 4 – Class of shared condition variable
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 – 共享条件变量类
- en: 'The following code box shows the declaration of the shared condition variable
    class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了共享条件变量类的声明：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Code Box 18-23 [ExtremeC_examples_chapter18_4_shared_cond.h]: The public interface
    of the shared condition variable class'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-23 [ExtremeC_examples_chapter18_4_shared_cond.h]：共享条件变量类的公共接口
- en: Three behaviors are exposed; `shared_cond_wait`, `shared_cond_timedwait`, and
    `shared_cond_broadcast`. If you remember from *Chapter 16*, *Thread Synchronization*,
    the behavior `shared_cond_wait` waits for a signal on a condition variable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露了三种行为；`shared_cond_wait`、`shared_cond_timedwait`和`shared_cond_broadcast`。如果你还记得第16章，即*线程同步*，`shared_cond_wait`行为会在条件变量上等待信号。
- en: Above, we have added a new version of waiting behavior; `shared_cond_timedwait`.
    It waits for the signal for a specified amount of time and then it gets timed
    out if the condition variable doesn't receive a signal. On the other hand, the
    `shared_cond_wait` never exists until it receives some sort of signal. We will
    use the timed version of waiting in *example 18.4*. Note that both waiting behavior
    functions receive a pointer to the companion shared mutex just like what we saw
    in multi-threaded environments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们添加了一个新的等待行为版本；`shared_cond_timedwait`。它等待指定时间内的信号，如果条件变量没有收到信号，则超时。另一方面，`shared_cond_wait`只有在收到某种信号时才会存在。我们将在*示例18.4*中使用等待的定时版本。注意，这两个等待行为函数都接收一个指向伴随共享互斥锁的指针，就像我们在多线程环境中看到的那样。
- en: 'The following code box contains the actual implementation of the shared condition
    variable class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含了共享条件变量类的实际实现：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Code Box 18-24 [ExtremeC_examples_chapter18_4_shared_cond.c]: The definitions
    of all functions found in the shared condition variable class'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-24 [ExtremeC_examples_chapter18_4_shared_cond.c]：共享条件变量类中找到的所有函数的定义
- en: In our shared condition variable class, we have only exposed the *broadcasting*
    behavior. We could also expose the *signaling* behavior. As you might remember
    from *Chapter 16*, *Thread Synchronization*, signaling a condition variable wakes
    up only one of the many waiting processes, without the ability to specify or predict
    which one. Broadcasting in contrast will wake all the waiting processes. In *example
    18.4* we'll only use broadcasting, and that's why we have only exposed that function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的共享条件变量类中，我们只暴露了*广播*行为。我们也可以暴露*信号*行为。正如你可能从第16章，即*线程同步*中记得的，向条件变量发送信号只会唤醒许多等待进程中的一个，而没有能力指定或预测是哪一个。相比之下，广播会唤醒所有等待进程。在*示例18.4*中，我们只会使用广播，这就是为什么我们只暴露了那个函数。
- en: Note that since every condition variable has a companion mutex, the shared mutex
    class should be able to use an instance of the shared mutex class, and that's
    why we have declared `shared_mutex_t` as a forward declaration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于每个条件变量都有一个伴随的互斥锁，共享互斥锁类应该能够使用共享互斥锁类的实例，这就是为什么我们将`shared_mutex_t`声明为前向声明的原因。
- en: Step 5 – The main logic
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 – 主要逻辑
- en: 'The following code box contains the main logic implemented for our example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码框包含了为我们示例实现的主要逻辑：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 18-25 [ExtremeC_examples_chapter18_4_main.c]: The main function of
    example 18.4'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框18-25 [ExtremeC_examples_chapter18_4_main.c]：示例18.4的主函数
- en: As you can see, the program accepts an argument indicating its number. As soon
    as the process finds out about its number, it starts to initialize the shared
    counter, the shared mutex, and the shared condition variable. It then enters a
    critical section being protected by the shared mutex.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序接受一个参数来指示其数字。一旦进程得知其数字，它就开始初始化共享计数器、共享互斥锁和共享条件变量。然后它进入由共享互斥锁保护的临界区。
- en: Inside a loop, it waits for the counter to become equal to its number. Since
    it waits for 5 seconds, there could be a timeout and we may leave the `shared_cond_timedwait`
    function after 5 seconds. This basically means that the condition variable has
    not been notified during that 5 seconds. The process then checks the condition
    again and it goes to sleep for another 5 seconds. This continues until the process
    gets the turn.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，它等待计数器等于其数字。由于它等待5秒钟，可能会出现超时，我们可能在5秒后离开`shared_cond_timedwait`函数。这基本上意味着在这5秒钟内没有通知条件变量。然后进程再次检查条件，并再次休眠5秒钟。这个过程会一直持续到进程获得轮次。
- en: When this happens, the process prints its number, increments the shared counter,
    and by broadcasting a signal on the shared condition variable object, it notifies
    the rest of the waiting processes about the modification which it has made to
    the shared counter. Only then does it prepare to quit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生这种情况时，进程打印其数字，增加共享计数器，并通过在共享条件变量对象上广播信号，通知其他等待进程它对共享计数器所做的修改。然后它才准备退出。
- en: In the meantime, if the user presses `Ctrl` + `C`, the signal handler defined
    as part of the main logic sets the local flag `int_received` and as soon as the
    process leaves the function `shared_mutex_timedwait` when it is inside the main
    loop, it notices the interrupt signal and exits the loop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果用户按下`Ctrl` + `C`，作为主逻辑一部分定义的信号处理程序将设置局部标志`int_received`，并且一旦进程在主循环中离开`shared_mutex_timedwait`函数，它就会注意到中断信号并退出循环。
- en: 'The following shell box shows how to compile *example 18.4*. We are going to
    compile it in Linux:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的shell box展示了如何编译*示例18.4*。我们将在Linux上编译它：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Shell Box 18-6: Compiling the sources of example 18.4 and producing the final
    executable file'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-6：编译示例18.4的源代码并生成最终的可执行文件
- en: 'Now that we have got the final executable file `ex18_4.out`, we can run three
    processes and see how they count in sequence, no matter how you assign them the
    numbers and in what order they are run. Let''s run the first process. We assign
    to this process the the number 3, by passing the number as an option to the executable
    file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了最终的可执行文件`ex18_4.out`，我们可以运行三个进程并观察它们如何按顺序计数，无论您如何分配它们的数字以及它们的运行顺序如何。让我们运行第一个进程。我们通过将数字作为选项传递给可执行文件来给这个进程分配数字3：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Shell Box 18-7: Running the first process which takes the number 3'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-7：运行第一个进程，该进程取数字3
- en: 'As you see in the preceding output, the first process creates all the required
    shared objects and becomes the owner of the shared resources. Now, let''s run
    the second process in a separate Terminal. It takes the number 2:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的输出中看到的，第一个进程创建了所有必需的共享对象，并成为共享资源的所有者。现在，让我们在另一个终端中运行第二个进程。它取数字2：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Shell Box 18-8: Running the second process which takes the number 2'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-8：运行第二个进程，该进程取数字2
- en: 'And finally, the last process takes the number 1\. Since this process has been
    assigned the number 1, it prints its number immediately, increments the shared
    counter, and notifies the rest of the processes about it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个进程取数字1。由于这个进程被分配了数字1，它立即打印其数字，增加共享计数器，并通知其他进程这一情况：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shell Box 18-9: Running the third process which takes the number 1\. This process
    will exit immediately since it has the number 1.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-9：运行第三个进程，该进程取数字1。由于它具有数字1，这个进程将立即退出。
- en: 'Now, if you go back to the second process, it prints out its number, increments
    the shared counter, and notifies the third process about that:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你回到第二个进程，它打印出其编号，增加共享计数器，并通知第三个进程：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Shell Box 18-10: The second process prints its number and exits'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-10：第二个进程打印其编号并退出
- en: Finally, going back to the first process, it gets notified by the second process,
    then it prints out its number and exits.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到第一个进程，它被第二个进程通知，然后打印出其编号并退出。
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Shell Box 18-11: The first process prints its number and exits. It also deletes
    all shared memory entries.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 18-11：第一个进程打印其编号并退出。它还删除了所有共享内存条目。
- en: Since the first process is the owner of all shared memories, it should delete
    them upon exiting. Releasing the allocated resources in a multi-processing environment
    can be quite tricky and complex because a simple mistake is enough to cause all
    the processes to crash. Further synchronization is required when a shared resource
    is going to be removed from the system.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个进程是所有共享内存的所有者，它应该在退出时删除它们。在多进程环境中释放分配的资源可能相当复杂，因为一个简单的错误就足以导致所有进程崩溃。当要从系统中移除共享资源时，需要进一步的同步。
- en: Suppose that, in the preceding example, we'd run the first process with the
    number 2 and the second process with the number 3\. Therefore, the first process
    should print its number before the second process. When the first process exits
    since it's the creator of all shared resources, it deletes the shared objects
    and the second process crashes as soon as it wants to access them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在前面的例子中，我们用数字2运行第一个进程，用数字3运行第二个进程。因此，第一个进程应该在第二个进程之前打印其编号。当第一个进程由于它是所有共享资源的创建者而退出时，它删除共享对象，而第二个进程在试图访问它们时立即崩溃。
- en: This is just a simple example of how finalization can be tricky and problematic
    in multi-process systems. In order to mitigate the risk of such crashes, one needs
    to introduce further synchronization among processes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子，说明了在多进程系统中，终止操作可能会变得复杂且问题重重。为了减轻这种崩溃的风险，需要在进程间引入进一步的同步。
- en: During the previous sections, we covered the mechanisms which can be employed
    to synchronize a number of processes while all of them are running on the same
    host. In the following section, we are going to briefly talk about distributed
    concurrency control mechanisms and their features.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了可以用于同步同一主机上运行的多个进程的机制。在接下来的章节中，我们将简要讨论分布式并发控制机制及其特性。
- en: Distributed concurrency control
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式并发控制
- en: So far in this chapter we have assumed that all processes exist within the same
    operating system, and hence the same machine. In other words, we were constantly
    talking about a single-host software system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们假设所有进程都存在于同一个操作系统内，也就是说，同一个机器。换句话说，我们一直在谈论单主机软件系统。
- en: But real software systems usually go beyond that. Conversely to the single-host
    software system, we have distributed software systems. These systems have processes
    distributed throughout a network, and they function through communicating over
    the network.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际的软件系统通常超出了这一点。与单主机软件系统相反，我们有分布式软件系统。这些系统在网络中分布有进程，并且通过网络通信来运行。
- en: 'Regarding a distributed system of processes, we can see more challenges in
    some aspects that are not present in a centralized or single-host system in that
    degree. Next, we discuss some of them briefly:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于进程的分布式系统，我们可以看到一些在集中式或单主机系统中不那么明显的挑战。接下来，我们将简要讨论其中的一些：
- en: '**In a distributed software system, you are probably experiencing parallelism
    instead of concurrency**. Since each process runs on a separate machine, and each
    process has its own specific processor, we will be observing parallelism instead
    of concurrency. Concurrency is usually limited to the borders of a single machine.
    Note that interleavings still exist and we might experience the same non-determinism
    as we saw in concurrent systems.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在分布式软件系统中，你可能会遇到并行性而不是并发性**。由于每个进程运行在单独的机器上，并且每个进程都有自己的特定处理器，我们将观察到并行性而不是并发性。并发通常局限于单个机器的边界。请注意，交错仍然存在，我们可能会遇到与并发系统相同的非确定性。'
- en: '**Not all processes within a distributed software system are written using
    a single programming language**. It is pretty common to see various programming
    languages being used in a distributed software system. It is also common to see
    the same diversity in the processes of a single-host software system. Despite
    our implicit assumption about the processes within a system, which is that all
    of them have been written using C, we can have processes written using any other
    language. Different languages provide different ways of having concurrency and
    control mechanisms. Therefore, for example, in some languages, you may not be
    able to use a named mutex very easily. Diverse technologies and programming languages
    used in a software system, single-host or distributed, force us to use concurrency
    control mechanisms that are abstract enough to be available in all of them. This
    might limit us to using a specific synchronization technique which is available
    in a certain technology or a programming language.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并非分布式软件系统中的所有流程都是使用单一编程语言编写的**。在分布式软件系统中看到各种编程语言被使用是很常见的。在单主机软件系统的流程中，也常常看到这种多样性。尽管我们对系统内流程的隐含假设是它们都使用C语言编写，但我们仍然可以使用任何其他语言来编写流程。不同的语言提供了不同的并发和控制机制。例如，在某些语言中，你可能很难轻松地使用命名互斥锁。在软件系统中使用的各种技术和编程语言，无论是单主机还是分布式，都迫使我们使用足够抽象的并发控制机制，以便在所有这些系统中都可用。这可能会限制我们只能使用在特定技术或编程语言中可用的特定同步技术。'
- en: '**In a distributed system, you always have a network as the communication channel
    between two processes not residing on the same machine**. This is converse to
    our implicit assumption about the single-host system where all processes are running
    within the same operating system and using the available messaging infrastructures
    to communicate with each other.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在分布式系统中，你总是有一个网络作为不在同一台机器上的两个进程之间的通信通道**。这与我们对单主机系统的隐含假设相反，在单主机系统中，所有流程都在同一操作系统中运行，并使用可用的消息基础设施相互通信。'
- en: '**Having a network in the middle means that you have latency**. There is a
    slight latency in single-host systems as well, but it is determined and manageable.
    It is also much lower than the latency you might experience in a network. Latency
    simply means that a process may not receive a message immediately because of many
    reasons having roots in the networking infrastructure. Nothing should be considered
    immediate in these systems.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间存在网络意味着你会有延迟**。在单主机系统中也存在轻微的延迟，但它是可以确定和管理的。它也比你在网络中可能遇到的延迟要低得多。延迟简单地说就是，由于许多原因，一个进程可能不会立即收到消息，这些原因根植于网络基础设施。在这些系统中，没有什么应该被认为是即时的。'
- en: '**Having a network in the middle also results in security issues**. When you
    have all the processes in one system, and all of them are communicating within
    the same boundary using mechanisms with extremely low latency, the security issues
    are greatly different. One has to firstly access the system itself in order to
    attack the system, but in a distributed system, all message passing is being done
    through the network. You might get an *eavesdropper* in the middle to sniff or,
    even worse, alter the messages. Regarding our discussion about synchronization
    in distributed systems, this is also applicable to messages meant to synchronize
    the processes within a distributed system.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间存在网络也会导致安全问题**。当你有一个系统中的所有流程，并且它们都在使用具有极低延迟的机制在同一边界内进行通信时，安全问题就大不相同了。攻击者必须首先访问系统本身才能攻击系统，但在分布式系统中，所有消息传递都是通过网络进行的。你可能会在中间遇到一个监听者来窃听或，更糟糕的是，篡改消息。关于我们在分布式系统中关于同步的讨论，这也适用于旨在同步分布式系统内流程的消息。'
- en: '**Other than latency and security issues, you might have delivery issues that
    happen far less frequently in single-host multi-process systems**. Messages should
    be delivered to be processed. When a process sends a message to another process
    within the system, somehow the sender process should make sure that its message
    is received by the other end. *Delivery guarantee* mechanisms are possible, but
    they''re costly and, in some scenarios, it is just not possible to use them at
    all. In those situations, a special kind of messaging problem is seen, which is
    usually modeled by the famous *Two Generals Problem*.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除了延迟和安全问题之外，你可能会遇到在单主机多进程系统中远较少发生的交付问题**。消息应该被传递以进行处理。当一个进程向系统内的另一个进程发送消息时，发送进程应确保其消息被另一端接收。*交付保证*机制是可能的，但它们成本高昂，在某些情况下，甚至根本无法使用它们。在这些情况下，会出现一种特殊的消息问题，这通常由著名的*两个将军问题*来建模。'
- en: 'The preceding differences and possible issues are enough to force us to invent
    new ways of synchronization among processes and various components of giant distributed
    systems. Generally, there are two ways to make a distributed system transactional
    and synchronized:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的差异和可能的问题足以迫使我们发明新的进程和大型分布式系统各个组件之间的同步方式。通常，有两种方式可以使分布式系统事务性和同步：
- en: '**Centralized process synchronization**: These techniques need a central process
    (or node) that manages the processes. All the other processes within the system
    should be in constant communication with this central node, and they need its
    approval in order to enter their critical sections.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式进程同步**：这些技术需要一个中心进程（或节点）来管理进程。系统中的所有其他进程都应该与这个中心节点保持持续通信，并且它们需要其批准才能进入它们的临界区。'
- en: '**Distributed (or peer-to-peer) process synchronization**: Having a process
    synchronization infrastructure that does not have a central node is not an easy
    task. This is actually an active field of research, and there are some ad hoc
    algorithms.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式（或对等）进程同步**：拥有一个没有中心节点的进程同步基础设施并不是一件容易的事情。这实际上是一个活跃的研究领域，并且有一些专门的算法。'
- en: In this section, we tried to shine a little light over the complexity of concurrency
    control in a distributed multi-process system. Further discussions about distributed
    concurrency control would be out of the scope of this book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们试图对分布式多进程系统中并发控制的复杂性进行一些解释。关于分布式并发控制的进一步讨论将超出本书的范围。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we completed our discussion regarding multi-processing environments.
    As part of this chapter, we discussed the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了关于多进程环境的讨论。作为本章的一部分，我们讨论了以下内容：
- en: What a named semaphore is and how it can be created and used by multiple processes.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是命名信号量以及它是如何被多个进程创建和使用的。
- en: What a named mutex is and how it should be used using a shared memory region.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是命名互斥锁以及它是如何通过共享内存区域使用的。
- en: We gave an example which was about termination orchestration in which a number
    of processes were waiting for a sign to get terminated and the signal was received
    and handled by one of the processes and propagated to others. We implemented this
    example using shared mutexes.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们给出了一个关于终止编排的例子，其中多个进程正在等待一个终止信号，信号被其中一个进程接收和处理，然后传播给其他进程。我们使用共享互斥锁实现了这个例子。
- en: What a named condition variable is and how it can become shared and named using
    a shared memory region.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是命名条件变量以及它是如何通过共享内存区域实现共享和命名的。
- en: We demonstrated another example of counting processes. As part of this example,
    we used inheritance to reduce the amount of code duplication for mutex and condition
    variable objects having an associated shared memory region.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了另一个计数进程的例子。作为这个例子的一部分，我们使用了继承来减少具有相关共享内存区域的互斥锁和条件变量对象的代码重复量。
- en: We briefly explored the differences and challenges found in a distributed system.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要探讨了分布式系统中存在的差异和挑战。
- en: We briefly discussed the methods which can be employed to bring concurrency
    control into distributed software.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要讨论了可以将并发控制引入分布式软件的方法。
- en: In the upcoming chapter, we start our discussions regarding **Inter-Process
    Communication** (**IPC**) techniques. Our discussions will span two chapters and
    we will cover many topics such as computer networks, transport protocols, socket
    programming, and many more useful topics.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们开始讨论**进程间通信**（**IPC**）技术。我们的讨论将涵盖两个章节，我们将涉及许多主题，例如计算机网络、传输协议、套接字编程以及更多有用的主题。
