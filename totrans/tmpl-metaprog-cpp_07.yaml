- en: '*Chapter 5*: Type Traits and Conditional Compilation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Type traits** are an important metaprogramming technique that enables us
    to inspect properties of types or to perform transformations of types at compile-time.
    Type traits are themselves templates and you can see them as meta-types. Knowing
    information such as the nature of a type, its supported operations, and its various
    properties is key for performing conditional compilation of templated code. It
    is also very useful when writing a library of templates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and defining type traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SFINAE and its purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling SFINAE with the `enable_if` type trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `constexpr if`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the standard type traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing real-world examples of using type traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a good understanding of what type traits
    are, how they are useful, and what type traits are available in the **C++** standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the chapter by looking at what type traits are and how they help
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and defining type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, **type traits** are small class templates that contain a constant
    value whose value represents the answer to a question we ask about a type. An
    example of such a question is: is this type a floating-point type? The technique
    for building type traits that provide such information about types relies on template
    specialization: we define a primary template as well as one or more specializations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can build a type trait that tells us, at compile-time, whether
    a type is a floating-point type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: We have defined a primary template as well as several full specializations,
    one for each type that is a floating-point type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary template has a `static const` Boolean member initialized with the
    `false` value; the full specializations set the value of this member to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is nothing more to building a type trait than this. `is_floating_point<T>`
    is a type trait that tells us whether a type is a floating-point type or not.
    We can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This proves that we have built the type trait correctly. But it does not show
    a real use-case scenario. For this type trait to be really useful, we need to
    use it at compile-time to do something with the information it provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we want to build a function that does something with a floating-point
    value. There are multiple floating-point types, such as `float`, `double`, and
    `long double`. For us to avoid writing multiple implementations, we would build
    this as a template function. However, that means we could actually pass other
    types as template arguments, so we need a way to prevent that. A simple solution
    is to use the `static_assert()` statement we saw earlier and produce an error
    should the user supply a value that is not a floating-point value. This can look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a really simple example but it demonstrates the use of type traits to
    do conditional compilation. There are other approaches than using `static_assert()`
    and we will explore them throughout this chapter. For the time being, let’s look
    at a second example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have classes that define operations for writing to an output stream.
    This is basically a form of serialization. However, some support this with an
    overloaded `operator<<`, others with the help of a member function called `write`.
    The following listing shows two such classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `widget` class contains a member function, `write`. However,
    for the `gadget` class, the stream operator, `<<`, is overloaded for the same
    purpose. We can write the following code using these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our goal would be to define a function template that enables us to
    treat them the same way. In other words, instead of using either `write` or the
    `<<` operator, we should be able to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings up some questions. First, how would such a function template look,
    and second, how can we know whether a type provides a `write` method or has the
    `<<` operator overloaded? The answer to the second question is type traits. We
    can build a type trait to help us answer this latter question at compile-time.
    This is how such a type trait may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the type trait we defined previously. `uses_write`
    tells us whether a type defines the `write` member function. The primary template
    sets the data member called `value` to `false`, but the full specialization for
    the `widget` class sets it to `true`. In order to avoid the verbose syntax `uses_write<T>::value`,
    we can also define a variable template, reducing the syntax to the form `uses_write_v<T>`.
    This variable template will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: To make the exercise simple, we’ll assume that the types that don’t provide
    a `write` member function overload the output stream operator. In practice, this
    is would not be the case, but for the sake of simplicity, we will build on this
    assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in defining the function template `serialize` that provides a
    uniform API for serializing all classes is to define more class templates. However,
    these would follow the same path – a primary template that provides one form of
    serialization and a full specialization that provides a different form. Here is
    the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `serializer` class template has a single template parameter, which is a
    non-type template parameter. It is also an anonymous template parameter because
    we don’t use it anywhere in the implementation. This class template contains a
    single member function. It is actually a member function template with a single
    type template parameter. This parameter defines the type of value we would serialize.
    The primary template uses the `<<` operator to output the value to the provided
    stream. On the other hand, the full specialization of the `serializer` class template
    uses the member function `write` to do the same. Notice that we fully specialize
    the `serializer` class template and not the `serialize` member function template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left now is to implement the desired free function `serialize`.
    Its implementation will be based on the `serializer<T>::serialize` function. Let’s
    see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The signature of this function template is the same as the one of the `serialize`
    member function from the `serializer` class template. The selection between the
    primary template and the full specialization is done with the help of the variable
    template `uses_write_v`, which provides a convenient way to access the value data
    member of the `uses_write` type trait.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, we have seen how to implement type traits and use the information
    they provide at compile-time to either impose restrictions on types or select
    between one implementation or the other. A similar purpose has another metaprogramming
    technique called **SFINAE**, which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SFINAE and its purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write templates, we sometimes need to restrict the template arguments.
    For instance, we have a function template that should work for any numeric type,
    therefore integral and floating-point, but should not work with anything else.
    Or we may have a class template that should only accept trivial types for an argument.
  prefs: []
  type: TYPE_NORMAL
- en: There are also cases when we may have overloaded function templates that should
    each work with some types only. For instance, one overload should work for integral
    types and the other for floating-point types only. There are different ways to
    achieve this goal and we will explore them in this chapter and the next.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits, however, are involved in one way or another in all of them. The
    first one that will be discussed in this chapter is a feature called SFINAE. Another
    approach, superior to SFINAE, is represented by concepts, which will be discussed
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**SFINAE** stands for **Substitution Failure Is Not An Error**. When the compiler
    encounters the use of a function template, it substitutes the arguments in order
    to instantiate the template. If an error occurs at this point, it is not regarded
    as ill-informed code, only as a deduction failure. The function is removed from
    the overload set instead of causing an error. Only if there is no match in the
    overload set does an error occur.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s difficult to really understand SFINAE without concrete examples. Therefore,
    we will go through several examples to explain the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Every standard container, such as `std::vector`, `std::array`, and `std::map`,
    not only has iterators that enable us to access its elements but also modify the
    container (such as inserting after the element pointed by an iterator). Therefore,
    these containers have member functions to return iterators to the first and the
    one-past-last elements of the container. These methods are called `begin` and
    `end`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other methods such as `cbegin` and `cend`, `rbegin` and `rend`, and
    `crbegin` and `crend` but these are beyond the purpose of this topic. In C++11,
    there are also free functions, `std:begin` and `std::end`, that do the same. However,
    these work not just with standard containers but also with arrays. One benefit
    of these is enabling range-based `for` loops for arrays. The question is how this
    non-member function could be implemented to work with both containers and arrays?
    Certainly, we need two overloads of a function template. A possible implementation
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The first overload calls the member function `begin` and returns the value.
    Therefore, this overload is restricted to types that have a member function `begin`;
    otherwise, a compiler error would occur. The second overload simply returns a
    pointer to the first element of the array. This is restricted to array types;
    anything else would produce a compiler error. We can use these overloads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: If you compile this piece of code, no error, not even a warning, occurs. The
    reason for that is SFINAE. When resolving the call to `begin(arr1)`, substituting
    `std::array<int, 5>` to the first overload (at `[1]`) succeeds, but the substitution
    for the second (at `[2]`) fails. Instead of issuing an error at this point, the
    compiler just ignores it, so it builds an overload set with a single instantiation
    and, therefore, it can successfully find a match for the invocation. Similarly,
    when resolving the call to `begin(arr2)`, the substitution of `int[5]` for the
    first overload fails and is ignored, but it succeeds for the second and is added
    to the overload set, eventually finding a good match for the invocation. Therefore,
    both calls can be successfully made. Should one of the two overloads not be present,
    either `begin(arr1)` or `begin(arr2)` would fail to match the function template
    and a compiler error would occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'SFINAE only applies in the so-called **immediate context** of a function. The
    immediate context is basically the template declaration (including the template
    parameter list, the function return type, and the function parameter list). Therefore,
    it does not apply to the body of a function. Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: There are no restrictions on the type `T` in the immediate context of the `increment`
    function template. However, in the body of the function, the parameter `val` is
    incremented with the post-fix `operator++`. That means, substituting for `T` any
    type for which the post-fix `operator++` is not implemented is a failure. However,
    this failure is an error and will not be ignored by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ standard (license usage link: [http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/))
    defines the list of errors that are considered SFINAE errors (in paragraph *§13.10.2*,
    *Template argument deduction*, the **C++20** standard version). These SFINAE errors
    are the following attempts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array of `void`, an array of reference, an array of function, an
    array of negative size, an array of size zero, and an array of non-integral size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a type that is not a class or enum on the left side of the scope resolution
    operator `::` (such as in `T::value_type` with `T` being a numeric type for instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pointer to reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reference to `void`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pointer to member of `T`, where `T` is not a class type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a member of a type when the type does not contain that member
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a member of a type where a type is required but the member is not a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a member of a type where a template is required but the member is not
    a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a member of a type where a non-type is required but the member is not
    a non-type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function type with a parameter of type `void`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function type that returns an array type or another function type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an invalid conversion in a template argument expression or an expression
    used in a function declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supplying an invalid type to a non-type template parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating a pack expansion containing multiple packs of different lengths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last error in this list was introduced in C++11 together with variadic
    templates. The others were defined before C++11\. We will not go on to exemplify
    all of these errors, but we can take a look at a couple more examples. The first
    concerns attempting to create an array of size zero. Let’s say we want to have
    two function template overloads, one that handles arrays of even sizes and one
    that handles arrays of odd sizes. A solution to this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The template arguments and the first function parameter are similar to what
    we saw with the `begin` overload for arrays. However, these overloads for `handle`
    have a second anonymous parameter with the default value `0`. The type of this
    parameter is a pointer to an array of type `char` and a size specified with the
    expressions `N%2==0` and `N%2==1`. For every possible array, one of these two
    is `true` and the other is `false`. Therefore, the second parameter is either
    `char(*)[1]` or `char(*)[0]`, the latter being an SFINAE error (an attempt to
    create an array of size zero). Therefore, we are able to call either one of the
    other overloads without generating compiler errors, thanks to SFINAE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example that we will look at in this section will show SFINAE with
    an attempt to use a member of a class that does not exist. Let’s start with the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have two classes, `foo`, which has a member type called `foo_type`,
    and `bar`, which has a member type called `bar_type`. There are also classes that
    derive from these two. The goal is to write two function templates, one that handles
    the `foo` hierarchy of classes, and one that handles the `bar` hierarchy of classes.
    A possible implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Both overloads have a single template parameter and a single function parameter
    of type `T const&`. They also return the same type, and that type is `void`. The
    expression `decltype(typename T::foo_type(), void())` may need a little consideration
    to understand better. We discussed `decltype` in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. Remember that this is a type specifier that deduces
    the type of an expression. We use the comma operator, so the first argument is
    evaluated but then discarded, so `decltype` will only deduce the type from `void()`,
    and the deduced type is `void`. However, the arguments `typename T::foo_type()`
    and `typename T::bar_type()` do use an inner type, and this only exists either
    for `foo` or `bar`. This is where SFINAE manifests itself, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Calling `handle` with an `int_foo` value will match the first overload, while
    the second is discarded because of a substitution failure. Similarly, calling
    `handle` with an `int_bar` value will match the second overload, while the first
    is discarded because of a substitution failure. However, calling `handle` with
    an `int` will cause substitution failure for both overloads so the final overload
    set for substituting `int` will be empty, which means there is no match for the
    call. Therefore, a compiler error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE is not the best way to achieve conditional compilation. However, in modern
    C++ it’s probably best used together with a type trait called `enable_if`. This
    is what we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SFINAE with the enable_if type trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ standard library is a family of sub-libraries. One of these is the
    type support library. This library defines types such as `std::size_t`, `std::nullptr_t`,
    and `std::byte`, run-time type identification support with classes such as `std::type_info`,
    as well as a collection of type traits. There are two categories of type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: Type traits that enable us to query properties of types at compile-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type traits that enable us to perform type transformations at compile-time (such
    as adding or removing the `const` qualifier, or adding or removing pointer or
    reference from a type). These type traits are also called **metafunctions**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One type trait from the second category is `std::enable_if`. This is used to
    enable SFINAE and remove candidates from a function’s overload set. A possible
    implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: There is a primary template, with two template parameters, a Boolean non-type
    template, and a type parameter with `void` as the default argument. This primary
    template is an empty class. There is also a partial specialization for the `true`
    value of the non-type template parameter. This, however, defines a member type
    simply called `type`, which is an alias template for the template parameter `T`.
  prefs: []
  type: TYPE_NORMAL
- en: The `enable_if` metafunction is intended to be used with a Boolean expression.
    When this Boolean expression is evaluated as `true`, it defines a member type
    called `type`. If the Boolean expression is `false`, this member type is not defined.
    Let’s see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the example from the *Understanding and defining type traits* section
    at the beginning of the chapter, where we had classes that provided a `write`
    method to write their content to an output stream, and classes for which the `operator<<`
    was overloaded for the same purpose? In that section, we defined a type trait
    called `uses_write` and wrote a `serialize` function template that allowed us
    to serialize, in a uniform manner, both types of objects (`widget` and `gadget`).
    However, the implementation was rather complex. With `enable_if`, we can implement
    that function in a simple manner. A possible implementation is shown in the next
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: There are two overloaded function templates in this implementation. They both
    have two template parameters. The first parameter is a type template parameter,
    called `T`. The second is an anonymous non-type template parameter of a pointer
    type that also has the default value `nullptr`. We use `enable_if` to define the
    member called `type` only if the `uses_write_v` variable evaluates to `true`.
    Therefore, for classes that have the member function `write`, the substitution
    succeeds for the first overload but fails for the second overload, because `typename
    * = nullptr` is not a valid parameter. For classes for which the `operator<<`
    is overloaded, we have the opposite situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enable_if` metafunction can be used in several scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: To define a template parameter that has a default argument, which we saw earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To define a function parameter that has a default argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To specify the return type of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this reason, I mentioned earlier that the provided implementation of the
    `serialize` overloads is just one of the possibilities. A similar one that uses
    `enable_if` to define a function parameter with a default argument is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice here that we basically moved the parameter from the template
    parameter list to the function parameter list. There is no other change, and the
    usage is the same, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The third alternative is to use `enable_if` to wrap the return type of the
    function. This implementation is only slightly different (the default argument
    does not make sense for a return type). Here is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The return type, in this implementation, is defined if `uses_write_v<T>` is
    `true`. Otherwise, a substitution failure occurs and SFINAE takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although in all these examples, the `enable_if` type trait was used to enable
    SFINAE during the overload resolution for function templates, this type trait
    can also be used to restrict instantiations of class templates. In the following
    example, we have a class called `integral_wrapper` that is supposed to be instantiated
    only with integral types, and a class called `floating_wrapper` that is supposed
    to be instantiated only with floating-point types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Both these class templates have two type template parameters. The first one
    is called `T`, but the second one is anonymous and has a default argument. The
    value of this argument is defined or not with the help of the `enable_if` type
    trait, based on the value of a Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alias template called `std::enable_if_t`, which is a convenient way to access
    the `std::enable_if<B, T>::type` member type. This is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Two variable templates, `std::is_integral_v` and `std::is_floating_point_v`,
    which are convenient ways to access the data members, `std::is_integral<T>::value`
    and `std::is_floating_point<T>::value`. The `std::is_integral` and `std::is_floating_point`
    classes are standard type traits that check whether a type is an integral type
    or a floating-point type respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two wrapper class templates shown previously can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Only two of these instantiations work, `w1`, because `integral_wrapper` is instantiated
    with the `int` type, and `w5`, because `floating_wrapper` is instantiated with
    the `double` type. All the others generate compiler errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be pointed out that this code samples only work with the provided
    definitions of `integral_wrapper` and `floating_wrapper` in C++20\. For previous
    versions of the standard, even the definitions of `w1` and `w5` would generate
    compiler errors because the compiler wasn’t able to deduce the template arguments.
    In order to make them work, we’d have to change the class templates to include
    a constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Although `enable_if` helps achieve SFINAE with simpler and more readable code,
    it’s still rather complicated. Fortunately, in `constexpr if` statements. Let’s
    explore this alternative next.
  prefs: []
  type: TYPE_NORMAL
- en: Using constexpr if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A C++17 feature makes SFINAE much easier. It’s called `constexpr if` and it’s
    a compile-time version of the `if` statement. It helps replace complex template
    code with simpler versions. Let’s start by looking at a C++17 implementation of
    the `serialize` function that can uniformly serialize both widgets and gadgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for `constexpr if` is `if constexpr(condition)`. The condition must
    be a compile-time expression. There is no short-circuit logic performed when evaluating
    the expression. This means that if the expression has the form `a && b` or `a
    || b`, then both `a` and `b` must be well-formed.
  prefs: []
  type: TYPE_NORMAL
- en: '`constexpr if` enables us to discard a branch, at compile-time, based on the
    value of the expression. In our example, when the `uses_write_v` variable is `true`,
    the `else` branch is discarded, and the body of the first branch is retained.
    Otherwise, the opposite occurs. Therefore, we end up with the following specializations
    for the `widget` and `gadget` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this code is likely to be further simplified by the compiler. Therefore,
    eventually, these specializations would simply look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: The end result is the same as the one we achieved with SFINAE and `enable_if`,
    but the actual code we wrote here was simpler and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '`constexpr if` is a great tool for simplifying code and we actually saw it
    earlier in [*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*,
    in the *Parameter packs* paragraph, when we implemented a function called `sum`.
    This is shown again here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `constexpr if` helps us to avoid having two overloads, one
    for the general case and one for ending the recursion. Another example presented
    already in this book where `constexpr if` can simplify the implementation is the
    `factorial` function template from [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*, in the *Exploring template recursion* section. That
    function looked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'With `constexpr if`, we can replace all this with a single template and let
    the compiler take care of providing the right specializations. The C++17 version
    of this function may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'The `constexpr if` statements can be useful in many situations. The last example
    presented in this section is a function template called `are_equal`, which determines
    whether the two supplied arguments are equal or not. Typically, you’d think that
    using `operator==` should be enough to determine whether two values are equal
    or not. That is true in most cases, except for floating-point values. Because
    only some of the floating-point numbers can be stored without a precision loss
    (numbers like 1, 1.25, 1.5, and anything else where the fractional part is an
    exact sum of inverse powers of 2) we need to take special care when comparing
    floating-point numbers. Usually, this is solved by ensuring that the difference
    between two floating-point values is less than some threshold. Therefore, a possible
    implementation for such a function could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: When the `T` type is a floating-point type, we compare the absolute value of
    the difference of the two numbers with the selected threshold. Otherwise, we fall
    back to using `operator==`. This enables us to use this function not just with
    arithmetic types, but also any other type for which the equality operator is overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: We are able to call the `are_equal` function template with arguments of type
    `int`, `double`, and `std::string`. However, attempting to do the same with values
    of the `widget` type will trigger a compiler error, because the `==` operator
    is not overloaded for this type.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we have seen what type traits are as well as different
    ways to perform conditional compilation. We have also seen some of the type traits
    available in the standard library. In the second part of this chapter, we will
    explore what the standard has to offer with regard to type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the standard type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library features a series of type traits for querying properties
    of types as well as performing transformations on types. These type traits are
    available in the `<type_traits>` header as part of the type support library. There
    are several categories of type traits including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the type category (primary or composite)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying type properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying supported operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying type relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying cv-specifiers, references, pointers, or a sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although looking at every single type trait is beyond the scope of this book,
    we will explore all these categories to see what they contain. In the following
    subsections, we will list the type traits (or most of them) that make up each
    of these categories. These lists as well as detailed information about each type
    trait can be found in the C++ standard (see the *Further reading* section at the
    end of the chapter for a link to a freely available draft version) or on the [cppreference.com](http://cppreference.com)
    website at [https://en.cppreference.com/w/cpp/header/type_traits](https://en.cppreference.com/w/cpp/header/type_traits)
    (license usage link: [http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)).'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the type traits for querying the type category.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the type category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this book so far, we have used several type traits, such as `std::is_integral`,
    `std::is_floating_point`, and `std::is_arithmetic`. These are just some of the
    standard type traits used for querying primary and composite type categories.
    The following table lists the entire set of such type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1](img/B18367_05_Table1.1.jpg)![Table 5.1](img/B18367_05_Table1.2.jpg)![Table
    5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table1.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1
  prefs: []
  type: TYPE_NORMAL
- en: 'All these type traits are available in C++11\. For each of them, starting with
    C++17, a variable template is available to simplify the access to the Boolean
    member called `value`. For a type trait with the name `is_abc`, a variable template
    with the name `is_abc_v` exists. This is true for all the type traits that have
    a Boolean member called `value`. The definition of these variables is very simple.
    The next snippet shows the definition for the `is_arithmentic_v` variable template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of using some of these type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: The function template `as_string` returns a string containing the value pass
    as an argument. It works with arithmetic types only and with the `nullptr_t` for
    which it returns the value `"null"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must have noticed the statement, `static_assert(always_false<T>)`, and
    wondering what this `always_false<T>` expression actually is. It is a variable
    template of the `bool` type that evaluates to `false`. Its definition is as simple
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: This is needed because the statement, `static_assert(false)`, would make the
    program ill-formed. The reason for this is that its condition would not depend
    on a template argument but evaluate to `false`. When no valid specialization can
    be generated for a sub-statement of a `constexpr if` statement within a template,
    the program is ill-formed (and no diagnostic is required). To avoid this, the
    condition of the `static_assert` statement must depend on a template argument.
    With `static_assert(always_false<T>)`, the compiler does not know whether this
    would evaluate to `true` or `false` until the template is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: The next category of type traits we explore allows us to query properties of
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Querying type properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type traits that enable us to query properties of types are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table2.1.jpg)![Table 5.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table2.2.jpg)![Table 5.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table2.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2
  prefs: []
  type: TYPE_NORMAL
- en: Although most of these are probably straightforward to understand, there are
    two that seem the same at a first glance. These are `is_trivial` and `is_trivially_copyable`.
    These both are true for scalar types or arrays of scalar types. They also are
    true for classes that are trivially copyable or arrays of such classes but `is_trivial`
    is true only for copyable classes that have a trivial default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the paragraph *§11.4.4.1* in the C++ 20 standard, a default constructor
    is trivial if it is not user-provided, and the class has no virtual member functions,
    no virtual base classes, no non-static members with default initializers, every
    direct base of it has a trivial default constructor, and every non-static member
    of a class type also has a trivial default constructor. To understand this better,
    let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there are three similar classes. All three of them, `foo`,
    `bar`, and `tar`, are trivially copyable. However, only the `foo` class is a trivial
    class, because it has a trivial default constructor. The `bar` class has a non-static
    member with a default initializer, and the `tar` class has a user-defined constructor,
    and this makes them non-trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from trivial copy-ability, there are other operations that we can query
    for with the help of other type traits. We will see these in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Querying supported operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following set of type traits helps us to query supported operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table3.1.jpg)![Table 5.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table3.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Except for the last sub-set, which was introduced in C++17, the others are available
    in C++11\. Each kind of these type traits has multiple variants, including ones
    for checking operations that are trivial or declared as non-throwing with the
    `noexcept` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at type traits that allow us to query for relationships between
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Querying type relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this category, we can find several type traits that help to query relationships
    between types. These type traits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.4
  prefs: []
  type: TYPE_NORMAL
- en: Of these type traits, perhaps the most used one is `std::is_same`. This type
    trait is very useful in determining whether two types are the same. Keep in mind
    that this type trait takes into account the `const` and `volatile` qualifiers;
    therefore, `int` and `int const`, for instance, are not the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this type trait to extend the implementation of the `as_string`
    function shown earlier. Remember that if you called it with the arguments `true`
    or `false` it prints `1` or `0`, and not `true`/`false`. We can add an explicit
    check for the `bool` type and return a string containing one of these two values,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: All the type traits seen so far are used to query some kind of information about
    types. In the next sections, we will see type traits that perform modifications
    on types.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying cv-specifiers, references, pointers, or a sign
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type traits that are performing transformations on types are also called
    metafunctions. These type traits provided a member type (`typedef`) called `type`
    that represents the transformed type. This category of type traits includes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table5.1.jpg)![Table 5.5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table5.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.5
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of `remove_cvref`, which was added in C++20, all the other
    type traits listed in this table are available in C++11\. These are not all the
    metafunctions from the standard library. More are listed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the metafunctions previously listed, there are other type traits
    performing type transformations. The most important of these are listed in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table6.1.jpg)![Table 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.6
  prefs: []
  type: TYPE_NORMAL
- en: 'From this list, we have already discussed `enable_if`. There are some other
    type traits here that are worth exemplifying. Let’s first look at `std::decay`
    and for this purpose, let’s consider the following slightly changed implementation
    of the `as_string` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change is the way we pass arguments to the function. Instead of passing
    by value, we pass by rvalue reference. If you remember from [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*, this is a forwarding reference. We can still make
    calls passing rvalues (such as literals) but passing lvalues will trigger compiler
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two calls are triggering the `static_assert` statement to fail. The
    actual type template arguments are `bool&` and `int&`. Therefore `std::is_same<bool,
    bool&>` will initialize the `value` member with `false`. Similarly, `std::is_arithmetic<int&>`
    will do the same. In order to evaluate these types, we need to ignore references
    and the `const` and `volatile` qualifiers. The type trait that helps us do so
    is `std::decay`, which performs several transformations, as described in the previous
    table. Its conceptual implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: From this snippet, we can see that `std::decay` is implemented with the help
    of other metafunctions, including `std::conditional`, which is key for selecting
    between one type or another based on a compile-time expression. Actually, this
    type trait is used multiple times, which is something you can do if you need to
    make a selection based on multiple conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of `std::decay`, we can modify the implementation of the `as_string`
    function, stripping reference, and cv-qualifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: By changing the implementation as shown here, we made the previous calls to
    `as_string` that failed to compile without any more errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the implementation of `std::decay` we saw the repetitive use of `std::conditional`.
    This is a metafunction that is fairly easy to use and can help to simplify many
    implementations. In [*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), *Template
    Fundamentals*, in the section *Defining alias templates*, we saw an example where
    we built a list type called `list_t`. This had a member alias template called
    `type` that was aliasing either the template type `T`, if the size of the list
    was `1`, or `std::vector<T>`, if it was higher. Let’s look at the snippet again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation can be greatly simplified with the help of `std::conditional`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need to rely on class template specialization to define such a
    list type. The entire solution can be reduced to defining an alias template. We
    can verify this works as expected with some `static_assert` statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: Exemplifying the use of each of the standard type traits is beyond the scope
    of this book. However, the next section of this chapter provides more complex
    examples that require the use of several standard type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing real-world examples of using type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section of the chapter, we have explored the various type traits
    that the standard library provides. It is difficult and unnecessary to find examples
    for each and every type trait. However, it is worth showcasing some examples where
    multiple type traits can be used for solving a problem. We will do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a copy algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first example problem we will take a look at is a possible implementation
    for the `std::copy` standard algorithm (from the `<algorithm>` header). Keep in
    mind that what we will see next is not the actual implementation but a possible
    one that helps us learn more about the use of type traits. The signature of this
    algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'As a note, this function is `constexpr` only in C++20, but we can discuss it
    in this context. What it does is copy all the elements in the range [`first`,
    `last`) to another range that begins with `d_first`. There is also an overload
    that takes an execution policy, and a version, `std::copy_if`, that copies all
    the elements that match a predicate, but these are not important for our example.
    A straightforward implementation of this function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are cases when this implementation can be optimized by simply
    copying memory. However, there are some conditions that must be met for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Both iterator types, `InputIt` and `OutputIt`, must be pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both template parameters, `InputIt` and `OutputIt`, must point to the same type
    (ignoring cv-qualifiers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type pointed by `InputIt` must have a trivial copy assignment operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can check these conditions with the following standard type traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::is_same` (and the `std::is_same_v` variable) to check that two types
    are the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_pointer` (and the `std::is_pointer_v` variable) to check that a type
    is a pointer type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_trivially_copy_assignable` (and the `std::is_trivially_copy_assignable_v`
    variable) to check whether a type has a trivial copy assignment operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::remove_cv` (and the `std::remove_cv_t` alias template) to remove cv-qualifiers
    from a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we can implement this. First, we need to have a primary template
    with the generic implementation, and then a specialization for pointer types with
    the optimized implementation. We can do this using class templates with member
    function templates as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy memory between a source and a destination we use `std::memmove` here,
    which copies data even if objects overlap. These implementations are provided
    in a namespace called `detail`, because they are implementation details that are
    used in turn by the `copy` function and not directly by the user. The implementation
    of this generic `copy` algorithm could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here that the decision to select one specialization or the other
    is based on a `constexpr` Boolean value that is determined using the aforementioned
    type traits. Examples of using this `copy` function are shown in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this is not the real definition of the generic algorithm `copy`
    you will find in standard library implementations, which are further optimized.
    However, this was a good example to demonstrate how to use type traits for a real-world
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, I have defined the `copy` function in what appears to be the
    global namespace. This is a bad practice. In general, code, especially in libraries,
    is grouped in namespaces. In the source code on GitHub that accompanies the book,
    you will find this function defined in a namespace called `n520` (this is just
    a unique name, nothing relevant to the topic). When calling the `copy` function
    that we have defined, we would actually need to use the fully qualified name (that
    includes the namespace name) such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: Without this qualification, a process called `copy` to the `std::copy` function
    because the arguments we pass are found in the `std` namespace. You can read more
    about ADL at [https://en.cppreference.com/w/cpp/language/adl](https://en.cppreference.com/w/cpp/language/adl).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at another example.
  prefs: []
  type: TYPE_NORMAL
- en: Building a homogenous variadic function template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the second example, we want to build a variadic function template that
    can only take arguments of the same type or types that can be implicitly converted
    to a common one. Let’s start with the following skeleton definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this is that all of the following function calls work (keep
    in mind that the body of this function is empty so there will be no errors due
    to performing operations unavailable on some types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we pass three `int` values. In the second example, we
    pass an `int`, a `double`, and a `char`; both `int` and `char` are implicitly
    convertible to `double`, so this should be all right. However, in the third example,
    we pass an `int`, a `double`, and a `char const*`, and this last type is not implicitly
    convertible to either `int` or `double`. Therefore, this last call is supposed
    to trigger a compiler error but does not.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we need to ensure that when a common type for the function
    arguments is not available, the compiler will generate an error. To do so, we
    can use a `static_assert` statement or `std::enable_if` and SFINAE. However, we
    do need to figure out whether a common type exists or not. This is possible with
    the help of the `std::common_type` type trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::common_type` is a metafunction that defines the common type among
    all of its type arguments that all the types can be implicitly converted to. Therefore
    `std::common_type<int, double, char>::type` will alias the `double` type. Using
    this type trait, we can build another type trait that tells us whether a common
    type exists. A possible implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in this snippet that we base the implementation on several other
    type traits. First, there is the `std::false_type` and `std::true_type` pair.
    These are type aliases for `std::bool_constant<false>` and `std::bool_constant<true>`
    respectively. The `std::bool_constant` class is available in C++17 and is, in
    turn, an alias template for a specialization of the `std::integral_constant` class
    for the `bool` type. This last class template wraps a static constant of the specified
    type. Its conceptual implementation looks as follows (although some operations
    are also provided):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: This helps us simplify the definition of type traits that need to define a Boolean
    compile-time value, as we saw in several cases in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A third type trait used in the implementation of the `has_common_type` class
    is `std::void_t`. This type trait defines a mapping between a variable number
    of types and the `void` type. We use this to build a mapping between the common
    type, if one exists, and the `void` type. This enables us to leverage SFINAE for
    the specialization of the `has_common_type` class template.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a variable template called `has_common_type_v` is defined to ease the
    use of the `has_common_type` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these can be used to modify the definition of the `process` function template
    to ensure it only allows arguments of a common type. A possible implementation
    is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: As a result of this, calls such as `process(1, 2.0, "3")` will produce a compiler
    error because there is no overloaded `process` function for this set of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, there are different ways to use the `has_common_type`
    trait to achieve the defined goal. One of these, using `std::enable_if`, was shown
    here, but we can also use `static_assert`. However, a much better approach can
    be taken with the use of concepts, which we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the concept of type traits, which are small classes that
    define meta-information about types or transformation operations for types. We
    started by looking at how type traits can be implemented and how they help us.
    Next, we learned about **SFINAE**, which stands for **Substitution Failure Is
    Not An Error**. This is a technique that enables us to provide constraints for
    template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how this purpose can be achieved better with `enable_if` and `constexpr
    if`, in C++17\. In the second part of the chapter, we looked at the type traits
    available in the standard library and demonstrated how to use some of them. We
    ended the chapter with a couple of real-world examples where we used multiple
    type traits to solve a particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we continue the topic of constraining the template parameters
    by learning about the C++20 concepts and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are type traits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SFINAE?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `constexpr if`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `std::is_same` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `std::conditional` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++ Type traits*, John Maddock and Steve Cleary, [https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm](https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N4861 Post-Prague 2020 C++ working draft*, [https://github.com/cplusplus/draft/releases/tag/n4861](https://github.com/cplusplus/draft/releases/tag/n4861)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is ADL?*, Arthur O’Dwyer, [https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/](https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
