- en: '*Chapter 5*: Type Traits and Conditional Compilation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：类型特性和条件编译'
- en: '**Type traits** are an important metaprogramming technique that enables us
    to inspect properties of types or to perform transformations of types at compile-time.
    Type traits are themselves templates and you can see them as meta-types. Knowing
    information such as the nature of a type, its supported operations, and its various
    properties is key for performing conditional compilation of templated code. It
    is also very useful when writing a library of templates.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型特性**是一种重要的元编程技术，它使我们能够在编译时检查类型的属性或对类型进行转换。类型特性本身是模板，你可以将其视为元类型。了解诸如类型的本质、其支持的操作以及其各种属性等信息对于执行模板代码的条件编译至关重要。在编写模板库时也非常有用。'
- en: 'In this chapter, you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Understanding and defining type traits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和定义类型特性
- en: Understanding SFINAE and its purpose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SFINAE及其目的
- en: Enabling SFINAE with the `enable_if` type trait
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`enable_if`类型特性启用SFINAE
- en: Using `constexpr if`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`constexpr if`
- en: Exploring the standard type traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索标准类型特性
- en: Seeing real-world examples of using type traits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看使用类型特性的真实世界示例
- en: By the end of the chapter, you will have a good understanding of what type traits
    are, how they are useful, and what type traits are available in the **C++** standard
    library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解类型特性是什么，它们如何有用，以及C++标准库中可用的类型特性。
- en: We will start the chapter by looking at what type traits are and how they help
    us.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨类型特性是什么以及它们如何帮助我们。
- en: Understanding and defining type traits
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和定义类型特性
- en: 'In a nutshell, **type traits** are small class templates that contain a constant
    value whose value represents the answer to a question we ask about a type. An
    example of such a question is: is this type a floating-point type? The technique
    for building type traits that provide such information about types relies on template
    specialization: we define a primary template as well as one or more specializations.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**类型特性**是包含一个常量值的类模板，该值代表我们对类型提出的问题的答案。这样一个问题的例子是：这个类型是浮点类型吗？构建提供此类类型信息类型特性的技术依赖于模板特化：我们定义了一个主模板以及一个或多个特化。
- en: 'Let’s see how we can build a type trait that tells us, at compile-time, whether
    a type is a floating-point type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何构建一个类型特性，它可以在编译时告诉我们一个类型是否是浮点类型：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are two things to notice here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方：
- en: We have defined a primary template as well as several full specializations,
    one for each type that is a floating-point type.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经定义了一个主模板以及几个完整的特化，每个特化对应一个浮点类型。
- en: The primary template has a `static const` Boolean member initialized with the
    `false` value; the full specializations set the value of this member to `true`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主模板有一个初始化为`false`值的`static const`布尔成员；完整的特化将此成员的值设置为`true`。
- en: 'There is nothing more to building a type trait than this. `is_floating_point<T>`
    is a type trait that tells us whether a type is a floating-point type or not.
    We can use it as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 构建类型特性没有比这更多的东西了。`is_floating_point<T>`是一个类型特性，它告诉我们一个类型是否是浮点类型。我们可以如下使用它：
- en: '[PRE20]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This proves that we have built the type trait correctly. But it does not show
    a real use-case scenario. For this type trait to be really useful, we need to
    use it at compile-time to do something with the information it provides.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们已经正确构建了类型特性。但这并不显示一个真正的用例场景。为了使这个类型特性真正有用，我们需要在编译时使用它来对它提供的信息进行一些操作。
- en: 'Let’s suppose we want to build a function that does something with a floating-point
    value. There are multiple floating-point types, such as `float`, `double`, and
    `long double`. For us to avoid writing multiple implementations, we would build
    this as a template function. However, that means we could actually pass other
    types as template arguments, so we need a way to prevent that. A simple solution
    is to use the `static_assert()` statement we saw earlier and produce an error
    should the user supply a value that is not a floating-point value. This can look
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个对浮点值进行操作的函数。存在多种浮点类型，如`float`、`double`和`long double`。为了我们避免编写多个实现，我们将构建一个模板函数。然而，这意味着我们实际上可以将其他类型作为模板参数传递，因此我们需要一种方法来防止这种情况。一个简单的解决方案是使用我们之前看到的`static_assert()`语句，并在用户提供的值不是浮点值时产生错误。这可以看起来如下：
- en: '[PRE28]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a really simple example but it demonstrates the use of type traits to
    do conditional compilation. There are other approaches than using `static_assert()`
    and we will explore them throughout this chapter. For the time being, let’s look
    at a second example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但它展示了如何使用类型特性进行条件编译。除了使用 `static_assert()` 之外，还有其他方法，我们将在本章中探讨它们。目前，让我们看看第二个例子。
- en: 'Suppose we have classes that define operations for writing to an output stream.
    This is basically a form of serialization. However, some support this with an
    overloaded `operator<<`, others with the help of a member function called `write`.
    The following listing shows two such classes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些类，这些类定义了向输出流写入操作的函数。这基本上是一种序列化的形式。然而，一些类通过重载的 `operator<<` 来支持这一功能，而另一些类则通过一个名为
    `write` 的成员函数来实现。下面的列表展示了两个这样的类：
- en: '[PRE41]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this example, the `widget` class contains a member function, `write`. However,
    for the `gadget` class, the stream operator, `<<`, is overloaded for the same
    purpose. We can write the following code using these classes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`widget` 类包含一个名为 `write` 的成员函数。然而，对于 `gadget` 类，为了达到相同的目的，流操作符 `<<` 被重载。我们可以使用以下代码来使用这些类：
- en: '[PRE64]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, our goal would be to define a function template that enables us to
    treat them the same way. In other words, instead of using either `write` or the
    `<<` operator, we should be able to write the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的目标是为这些类定义一个函数模板，使我们能够以相同的方式对待它们。换句话说，我们不应该使用 `write` 或 `<<` 操作符，而应该能够编写以下代码：
- en: '[PRE68]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This brings up some questions. First, how would such a function template look,
    and second, how can we know whether a type provides a `write` method or has the
    `<<` operator overloaded? The answer to the second question is type traits. We
    can build a type trait to help us answer this latter question at compile-time.
    This is how such a type trait may look:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一些问题。首先，这样的函数模板看起来会是什么样子，其次，我们如何知道一个类型是否提供了 `write` 方法或重载了 `<<` 操作符？第二个问题的答案是类型特性。我们可以在编译时构建一个类型特性来帮助我们回答这个问题。这样的类型特性可能看起来如下所示：
- en: '[PRE70]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is very similar to the type trait we defined previously. `uses_write`
    tells us whether a type defines the `write` member function. The primary template
    sets the data member called `value` to `false`, but the full specialization for
    the `widget` class sets it to `true`. In order to avoid the verbose syntax `uses_write<T>::value`,
    we can also define a variable template, reducing the syntax to the form `uses_write_v<T>`.
    This variable template will look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前定义的类型特性非常相似。`uses_write` 告诉我们一个类型是否定义了 `write` 成员函数。主要模板将名为 `value` 的数据成员设置为
    `false`，但 `widget` 类的全特化将此设置为 `true`。为了避免使用冗长的语法 `uses_write<T>::value`，我们还可以定义一个变量模板，将语法简化为
    `uses_write_v<T>` 的形式。这个变量模板看起来如下所示：
- en: '[PRE80]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: To make the exercise simple, we’ll assume that the types that don’t provide
    a `write` member function overload the output stream operator. In practice, this
    is would not be the case, but for the sake of simplicity, we will build on this
    assumption.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使练习简单，我们假设那些没有提供 `write` 成员函数重载的类型会使用输出流操作符。实际上，情况可能并非如此，但为了简化，我们将基于这个假设进行构建。
- en: 'The next step in defining the function template `serialize` that provides a
    uniform API for serializing all classes is to define more class templates. However,
    these would follow the same path – a primary template that provides one form of
    serialization and a full specialization that provides a different form. Here is
    the code for it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 定义提供统一序列化API的函数模板 `serialize` 的下一步是定义更多的类模板。然而，这些模板将遵循相同的路径——一个主要模板提供一种序列化形式，一个全特化提供不同的序列化形式。以下是相应的代码：
- en: '[PRE82]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `serializer` class template has a single template parameter, which is a
    non-type template parameter. It is also an anonymous template parameter because
    we don’t use it anywhere in the implementation. This class template contains a
    single member function. It is actually a member function template with a single
    type template parameter. This parameter defines the type of value we would serialize.
    The primary template uses the `<<` operator to output the value to the provided
    stream. On the other hand, the full specialization of the `serializer` class template
    uses the member function `write` to do the same. Notice that we fully specialize
    the `serializer` class template and not the `serialize` member function template.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`serializer`类模板有一个单独的模板参数，它是一个非类型模板参数。它也是一个匿名模板参数，因为我们没有在实现中使用它。这个类模板包含一个成员函数。实际上，它是一个具有单个类型模板参数的成员函数模板。这个参数定义了我们将要序列化的值的类型。主模板使用`<<`运算符将值输出到提供的流中。另一方面，`serializer`类模板的完全特化使用成员函数`write`来完成同样的任务。请注意，我们完全特化了`serializer`类模板，而不是`serialize`成员函数模板。'
- en: 'The only thing left now is to implement the desired free function `serialize`.
    Its implementation will be based on the `serializer<T>::serialize` function. Let’s
    see how:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的唯一事情是实现所需的自由函数`serialize`。它的实现将基于`serializer<T>::serialize`函数。让我们看看它是如何实现的：
- en: '[PRE100]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The signature of this function template is the same as the one of the `serialize`
    member function from the `serializer` class template. The selection between the
    primary template and the full specialization is done with the help of the variable
    template `uses_write_v`, which provides a convenient way to access the value data
    member of the `uses_write` type trait.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数模板的签名与`serializer`类模板中的`serialize`成员函数的签名相同。在主模板和完全特化之间的选择是通过变量模板`uses_write_v`来完成的，它提供了一个方便的方式来访问`uses_write`类型特质的值数据成员。
- en: In these examples, we have seen how to implement type traits and use the information
    they provide at compile-time to either impose restrictions on types or select
    between one implementation or the other. A similar purpose has another metaprogramming
    technique called **SFINAE**, which we will cover next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们看到了如何实现类型特质并在编译时使用它们提供的信息来对类型施加限制或选择一个实现或另一个实现。具有类似目的的另一种元编程技术称为**SFINAE**，我们将在下一章中介绍。
- en: Exploring SFINAE and its purpose
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SFINAE及其目的
- en: When we write templates, we sometimes need to restrict the template arguments.
    For instance, we have a function template that should work for any numeric type,
    therefore integral and floating-point, but should not work with anything else.
    Or we may have a class template that should only accept trivial types for an argument.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写模板时，我们有时需要限制模板参数。例如，我们有一个函数模板，它应该适用于任何数值类型，因此是整数和浮点数，但不应该与任何其他类型一起工作。或者我们可能有一个类模板，它应该只接受平凡类型作为参数。
- en: There are also cases when we may have overloaded function templates that should
    each work with some types only. For instance, one overload should work for integral
    types and the other for floating-point types only. There are different ways to
    achieve this goal and we will explore them in this chapter and the next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能存在重载的函数模板，每个都应该只与某些类型一起工作。例如，一个重载应该适用于整数类型，另一个只适用于浮点数类型。有几种不同的方法可以实现这个目标，我们将在本章和下一章中探讨它们。
- en: Type traits, however, are involved in one way or another in all of them. The
    first one that will be discussed in this chapter is a feature called SFINAE. Another
    approach, superior to SFINAE, is represented by concepts, which will be discussed
    in the next chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型特质以某种方式涉及到所有这些。本章将要讨论的第一个特性是称为SFINAE的功能。另一种优于SFINAE的方法是由概念表示的，我们将在下一章中讨论。
- en: '**SFINAE** stands for **Substitution Failure Is Not An Error**. When the compiler
    encounters the use of a function template, it substitutes the arguments in order
    to instantiate the template. If an error occurs at this point, it is not regarded
    as ill-informed code, only as a deduction failure. The function is removed from
    the overload set instead of causing an error. Only if there is no match in the
    overload set does an error occur.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFINAE**代表**Substitution Failure Is Not An Error**。当编译器遇到函数模板的使用时，它会替换参数以实例化模板。如果在此处发生错误，它不被视为错误代码，而只是推导失败。函数将从重载集中移除，而不是引发错误。只有在重载集中没有匹配项时才会发生错误。'
- en: It’s difficult to really understand SFINAE without concrete examples. Therefore,
    we will go through several examples to explain the concept.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 没有具体的例子，很难真正理解SFINAE。因此，我们将通过几个例子来解释这个概念。
- en: Every standard container, such as `std::vector`, `std::array`, and `std::map`,
    not only has iterators that enable us to access its elements but also modify the
    container (such as inserting after the element pointed by an iterator). Therefore,
    these containers have member functions to return iterators to the first and the
    one-past-last elements of the container. These methods are called `begin` and
    `end`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标准容器，如`std::vector`、`std::array`和`std::map`，不仅具有使我们能够访问其元素的迭代器，而且还可以修改容器（例如，在迭代器指向的元素之后插入）。因此，这些容器有成员函数来返回容器的第一个和最后一个元素之后的迭代器。这些方法被称为`begin`和`end`。
- en: 'There are other methods such as `cbegin` and `cend`, `rbegin` and `rend`, and
    `crbegin` and `crend` but these are beyond the purpose of this topic. In C++11,
    there are also free functions, `std:begin` and `std::end`, that do the same. However,
    these work not just with standard containers but also with arrays. One benefit
    of these is enabling range-based `for` loops for arrays. The question is how this
    non-member function could be implemented to work with both containers and arrays?
    Certainly, we need two overloads of a function template. A possible implementation
    is the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`cbegin`和`cend`、`rbegin`和`rend`、`crbegin`和`crend`等其他方法之外，但这些超出了本主题的目的。在C++11中，还有自由函数`std::begin`和`std::end`，它们执行相同的操作。然而，这些函数不仅与标准容器一起工作，也与数组一起工作。这些函数的一个好处是使数组能够使用基于范围的`for`循环。问题是这个非成员函数如何实现以同时与容器和数组一起工作？当然，我们需要两个函数模板的重载。一个可能的实现如下：
- en: '[PRE105]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The first overload calls the member function `begin` and returns the value.
    Therefore, this overload is restricted to types that have a member function `begin`;
    otherwise, a compiler error would occur. The second overload simply returns a
    pointer to the first element of the array. This is restricted to array types;
    anything else would produce a compiler error. We can use these overloads as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载调用成员函数`begin`并返回值。因此，这个重载仅限于具有成员函数`begin`的类型；否则，将发生编译器错误。第二个重载简单地返回数组的第一个元素的指针。这仅限于数组类型；其他任何类型都会产生编译器错误。我们可以如下使用这些重载：
- en: '[PRE109]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If you compile this piece of code, no error, not even a warning, occurs. The
    reason for that is SFINAE. When resolving the call to `begin(arr1)`, substituting
    `std::array<int, 5>` to the first overload (at `[1]`) succeeds, but the substitution
    for the second (at `[2]`) fails. Instead of issuing an error at this point, the
    compiler just ignores it, so it builds an overload set with a single instantiation
    and, therefore, it can successfully find a match for the invocation. Similarly,
    when resolving the call to `begin(arr2)`, the substitution of `int[5]` for the
    first overload fails and is ignored, but it succeeds for the second and is added
    to the overload set, eventually finding a good match for the invocation. Therefore,
    both calls can be successfully made. Should one of the two overloads not be present,
    either `begin(arr1)` or `begin(arr2)` would fail to match the function template
    and a compiler error would occur.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译这段代码，不会出现错误，甚至没有警告。原因是SFINAE。当解析对`begin(arr1)`的调用时，将`std::array<int, 5>`替换到第一个重载（在`[1]`处）成功，但第二个（在`[2]`处）的替换失败。而不是在这个点发出错误，编译器只是忽略它，因此它构建了一个只有一个实例化的重载集，因此它可以成功找到调用的匹配。同样，当解析对`begin(arr2)`的调用时，第一个重载对`int[5]`的替换失败并被忽略，但第二个成功并被添加到重载集中，最终找到对调用的良好匹配。因此，这两个调用都可以成功执行。如果两个重载中的任何一个不存在，`begin(arr1)`或`begin(arr2)`将无法匹配函数模板，并发生编译器错误。
- en: 'SFINAE only applies in the so-called **immediate context** of a function. The
    immediate context is basically the template declaration (including the template
    parameter list, the function return type, and the function parameter list). Therefore,
    it does not apply to the body of a function. Let’s consider the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SFINAE仅在函数所谓的**直接上下文**中适用。直接上下文基本上是模板声明（包括模板参数列表、函数返回类型和函数参数列表）。因此，它不适用于函数体。让我们考虑以下例子：
- en: '[PRE113]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: There are no restrictions on the type `T` in the immediate context of the `increment`
    function template. However, in the body of the function, the parameter `val` is
    incremented with the post-fix `operator++`. That means, substituting for `T` any
    type for which the post-fix `operator++` is not implemented is a failure. However,
    this failure is an error and will not be ignored by the compiler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`increment`函数模板的直接上下文中对类型`T`没有限制。然而，在函数体中，参数`val`使用后缀`operator++`进行递增。这意味着，对于任何未实现后缀`operator++`的类型，用`T`替换都是失败的。然而，这种失败是一个错误，并且编译器不会忽略它。
- en: 'The C++ standard (license usage link: [http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/))
    defines the list of errors that are considered SFINAE errors (in paragraph *§13.10.2*,
    *Template argument deduction*, the **C++20** standard version). These SFINAE errors
    are the following attempts:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准（许可使用链接：[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/））定义了被认为是SFINAE错误的错误列表（在段落*§13.10.2*，*模板参数推导*，**C++20**标准版本）。这些SFINAE错误包括以下尝试：
- en: Creating an array of `void`, an array of reference, an array of function, an
    array of negative size, an array of size zero, and an array of non-integral size
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`void`类型的数组、一个引用类型的数组、一个函数类型的数组、一个负大小的数组、一个大小为零的数组和一个非整型大小的数组
- en: Using a type that is not a class or enum on the left side of the scope resolution
    operator `::` (such as in `T::value_type` with `T` being a numeric type for instance)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在作用域解析运算符`::`的左侧使用不是类或枚举的类型（例如，在`T::value_type`中，其中`T`是一个数值类型）
- en: Creating a pointer to reference
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个指向引用的指针
- en: Creating a reference to `void`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个指向`void`的引用
- en: Creating a pointer to member of `T`, where `T` is not a class type
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个指向`T`成员的指针，其中`T`不是一个类类型
- en: Using a member of a type when the type does not contain that member
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型不包含该成员的情况下使用类型成员
- en: Using a member of a type where a type is required but the member is not a type
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要类型而成员不是类型的情况下使用类型成员
- en: Using a member of a type where a template is required but the member is not
    a template
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要模板而成员不是模板的情况下使用类型成员
- en: Using a member of a type where a non-type is required but the member is not
    a non-type
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要非类型成员而成员不是非类型的情况下使用类型成员
- en: Creating a function type with a parameter of type `void`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有`void`类型参数的函数类型
- en: Creating a function type that returns an array type or another function type
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个返回数组类型或另一个函数类型的函数类型
- en: Performing an invalid conversion in a template argument expression or an expression
    used in a function declaration
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板参数表达式或函数声明中执行无效的类型转换
- en: Supplying an invalid type to a non-type template parameter
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向非类型模板参数提供一个无效的类型
- en: Instantiating a pack expansion containing multiple packs of different lengths
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化包含多个不同长度包的包展开
- en: 'The last error in this list was introduced in C++11 together with variadic
    templates. The others were defined before C++11\. We will not go on to exemplify
    all of these errors, but we can take a look at a couple more examples. The first
    concerns attempting to create an array of size zero. Let’s say we want to have
    two function template overloads, one that handles arrays of even sizes and one
    that handles arrays of odd sizes. A solution to this is the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的最后一个错误是在C++11中与变长模板一起引入的。其他错误是在C++11之前定义的。我们不会继续举例说明所有这些错误，但我们可以看看几个更多例子。第一个例子是尝试创建一个大小为零的数组。假设我们想要有两个函数模板重载，一个处理偶数大小的数组，另一个处理奇数大小的数组。这个问题的解决方案如下：
- en: '[PRE119]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The template arguments and the first function parameter are similar to what
    we saw with the `begin` overload for arrays. However, these overloads for `handle`
    have a second anonymous parameter with the default value `0`. The type of this
    parameter is a pointer to an array of type `char` and a size specified with the
    expressions `N%2==0` and `N%2==1`. For every possible array, one of these two
    is `true` and the other is `false`. Therefore, the second parameter is either
    `char(*)[1]` or `char(*)[0]`, the latter being an SFINAE error (an attempt to
    create an array of size zero). Therefore, we are able to call either one of the
    other overloads without generating compiler errors, thanks to SFINAE.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数和第一个函数参数与我们看到的数组 `begin` 重载类似。然而，这些 `handle` 的重载有一个带有默认值 `0` 的第二个匿名参数。此参数的类型是指向类型为
    `char` 的数组的指针，以及由表达式 `N%2==0` 和 `N%2==1` 指定的大小。对于每个可能的数组，这两个中的一个是 `true`，另一个是
    `false`。因此，第二个参数是 `char(*)[1]` 或 `char(*)[0]`，后者是一个 SFINAE 错误（尝试创建大小为零的数组）。因此，我们能够调用其他重载之一而不生成编译器错误，这要归功于
    SFINAE。
- en: 'The last example that we will look at in this section will show SFINAE with
    an attempt to use a member of a class that does not exist. Let’s start with the
    following snippet:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将要查看的最后一个示例将展示尝试使用一个不存在的类的成员的 SFINAE。让我们从以下代码片段开始：
- en: '[PRE133]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Here we have two classes, `foo`, which has a member type called `foo_type`,
    and `bar`, which has a member type called `bar_type`. There are also classes that
    derive from these two. The goal is to write two function templates, one that handles
    the `foo` hierarchy of classes, and one that handles the `bar` hierarchy of classes.
    A possible implementation is the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个类，`foo`，它有一个名为 `foo_type` 的成员类型，以及 `bar`，它有一个名为 `bar_type` 的成员类型。还有从这两个类派生出来的类。目标是编写两个函数模板，一个用于处理
    `foo` 类的层次结构，另一个用于处理 `bar` 类的层次结构。一个可能的实现如下：
- en: '[PRE145]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Both overloads have a single template parameter and a single function parameter
    of type `T const&`. They also return the same type, and that type is `void`. The
    expression `decltype(typename T::foo_type(), void())` may need a little consideration
    to understand better. We discussed `decltype` in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. Remember that this is a type specifier that deduces
    the type of an expression. We use the comma operator, so the first argument is
    evaluated but then discarded, so `decltype` will only deduce the type from `void()`,
    and the deduced type is `void`. However, the arguments `typename T::foo_type()`
    and `typename T::bar_type()` do use an inner type, and this only exists either
    for `foo` or `bar`. This is where SFINAE manifests itself, as shown in the following
    snippet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重载都有一个模板参数和一个类型为 `T const&` 的函数参数。它们还返回相同的类型，该类型是 `void`。表达式 `decltype(typename
    T::foo_type(), void())` 可能需要一点考虑才能更好地理解。我们已经在 [*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)
    中讨论了 `decltype`，*高级模板概念*。记住，这是一个类型指定器，用于推导表达式的类型。我们使用逗号运算符，因此第一个参数将被评估然后丢弃，所以
    `decltype` 将只从 `void()` 推导类型，推导出的类型是 `void`。然而，参数 `typename T::foo_type()` 和 `typename
    T::bar_type()` 确实使用了内部类型，并且这仅存在于 `foo` 或 `bar` 中。这就是 SFINAE 表现出来的地方，如下面的代码片段所示：
- en: '[PRE155]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Calling `handle` with an `int_foo` value will match the first overload, while
    the second is discarded because of a substitution failure. Similarly, calling
    `handle` with an `int_bar` value will match the second overload, while the first
    is discarded because of a substitution failure. However, calling `handle` with
    an `int` will cause substitution failure for both overloads so the final overload
    set for substituting `int` will be empty, which means there is no match for the
    call. Therefore, a compiler error occurs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `int_foo` 值调用 `handle` 将匹配第一个重载，而第二个由于替换失败而被丢弃。同样，使用 `int_bar` 值调用 `handle`
    将匹配第二个重载，而第一个由于替换失败而被丢弃。然而，使用 `int` 调用 `handle` 将导致两个重载都发生替换失败，因此用于替换 `int` 的最终重载集将为空，这意味着没有匹配的调用。因此，将发生编译器错误。
- en: SFINAE is not the best way to achieve conditional compilation. However, in modern
    C++ it’s probably best used together with a type trait called `enable_if`. This
    is what we will discuss next.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: SFINAE 不是实现条件编译的最佳方式。然而，在现代 C++ 中，它可能最好与一个名为 `enable_if` 的类型特性一起使用。这就是我们接下来要讨论的。
- en: Enabling SFINAE with the enable_if type trait
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 enable_if 类型特性启用 SFINAE
- en: 'The C++ standard library is a family of sub-libraries. One of these is the
    type support library. This library defines types such as `std::size_t`, `std::nullptr_t`,
    and `std::byte`, run-time type identification support with classes such as `std::type_info`,
    as well as a collection of type traits. There are two categories of type traits:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库是一系列子库的集合。其中之一是类型支持库。这个库定义了诸如`std::size_t`、`std::nullptr_t`和`std::byte`等类型，以及使用`std::type_info`等类提供的运行时类型识别支持，还包括一系列类型特性。类型特性分为两类：
- en: Type traits that enable us to query properties of types at compile-time.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们在编译时查询类型属性的类型特性。
- en: Type traits that enable us to perform type transformations at compile-time (such
    as adding or removing the `const` qualifier, or adding or removing pointer or
    reference from a type). These type traits are also called **metafunctions**.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们在编译时执行类型转换的类型特性（例如添加或删除`const`限定符，或添加或删除指针或引用从类型）。这些类型特性也称为**元函数**。
- en: 'One type trait from the second category is `std::enable_if`. This is used to
    enable SFINAE and remove candidates from a function’s overload set. A possible
    implementation is the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类类型特性之一是`std::enable_if`。它用于启用SFINAE并从函数的重载集中删除候选者。一个可能的实现如下：
- en: '[PRE161]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: There is a primary template, with two template parameters, a Boolean non-type
    template, and a type parameter with `void` as the default argument. This primary
    template is an empty class. There is also a partial specialization for the `true`
    value of the non-type template parameter. This, however, defines a member type
    simply called `type`, which is an alias template for the template parameter `T`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个主要模板，包含两个模板参数，一个布尔非类型模板参数和一个默认参数为`void`的类型参数。这个主要模板是一个空类。还有一个针对非类型模板参数`true`值的局部特化。然而，这仅仅定义了一个简单地称为`type`的成员类型，它是一个模板参数`T`的别名模板。
- en: The `enable_if` metafunction is intended to be used with a Boolean expression.
    When this Boolean expression is evaluated as `true`, it defines a member type
    called `type`. If the Boolean expression is `false`, this member type is not defined.
    Let’s see how it works.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable_if`元函数旨在与布尔表达式一起使用。当这个布尔表达式评估为`true`时，它定义一个名为`type`的成员类型。如果布尔表达式为`false`，则不定义这个成员类型。让我们看看它是如何工作的。'
- en: 'Remember the example from the *Understanding and defining type traits* section
    at the beginning of the chapter, where we had classes that provided a `write`
    method to write their content to an output stream, and classes for which the `operator<<`
    was overloaded for the same purpose? In that section, we defined a type trait
    called `uses_write` and wrote a `serialize` function template that allowed us
    to serialize, in a uniform manner, both types of objects (`widget` and `gadget`).
    However, the implementation was rather complex. With `enable_if`, we can implement
    that function in a simple manner. A possible implementation is shown in the next
    snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 记得本章开头“理解和定义类型特性”部分中的例子，其中我们定义了提供`write`方法将内容写入输出流的类，以及为相同目的重载了`operator<<`运算符的类。在那个部分，我们定义了一个名为`uses_write`的类型特性，并编写了一个`serialize`函数模板，允许我们以统一的方式序列化这两种类型的对象（`widget`和`gadget`）。然而，实现相当复杂。使用`enable_if`，我们可以以简单的方式实现该函数。一个可能的实现如下所示：
- en: '[PRE165]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: There are two overloaded function templates in this implementation. They both
    have two template parameters. The first parameter is a type template parameter,
    called `T`. The second is an anonymous non-type template parameter of a pointer
    type that also has the default value `nullptr`. We use `enable_if` to define the
    member called `type` only if the `uses_write_v` variable evaluates to `true`.
    Therefore, for classes that have the member function `write`, the substitution
    succeeds for the first overload but fails for the second overload, because `typename
    * = nullptr` is not a valid parameter. For classes for which the `operator<<`
    is overloaded, we have the opposite situation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，有两个重载的函数模板。它们都有两个模板参数。第一个参数是一个类型模板参数，称为`T`。第二个是一个具有默认值`nullptr`的匿名非类型模板参数的指针类型。我们使用`enable_if`来定义名为`type`的成员，只有当`uses_write_v`变量评估为`true`时。因此，对于具有成员函数`write`的类，第一个重载的替换成功，但第二个重载失败，因为`typename
    * = nullptr`不是一个有效的参数。对于重载了`operator<<`运算符的类，我们有相反的情况。
- en: 'The `enable_if` metafunction can be used in several scenarios:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable_if`元函数可以在以下几种场景中使用：'
- en: To define a template parameter that has a default argument, which we saw earlier
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个具有默认参数的模板参数，这是我们之前看到的
- en: To define a function parameter that has a default argument
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义具有默认参数的函数参数
- en: To specify the return type of a function
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定函数的返回类型
- en: 'For this reason, I mentioned earlier that the provided implementation of the
    `serialize` overloads is just one of the possibilities. A similar one that uses
    `enable_if` to define a function parameter with a default argument is shown next:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我之前提到，提供的 `serialize` 重载的实现只是众多可能性中的一种。下面展示的是一种类似的实现，它使用 `enable_if` 来定义具有默认参数的函数参数：
- en: '[PRE179]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'You will notice here that we basically moved the parameter from the template
    parameter list to the function parameter list. There is no other change, and the
    usage is the same, such as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们基本上将参数从模板参数列表移动到了函数参数列表中。没有其他变化，用法相同，如下所示：
- en: '[PRE195]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The third alternative is to use `enable_if` to wrap the return type of the
    function. This implementation is only slightly different (the default argument
    does not make sense for a return type). Here is how it looks:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选择是使用 `enable_if` 来包装函数的返回类型。这种实现方式与之前略有不同（默认参数对于返回类型来说没有意义）。以下是它的样子：
- en: '[PRE199]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The return type, in this implementation, is defined if `uses_write_v<T>` is
    `true`. Otherwise, a substitution failure occurs and SFINAE takes place.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，如果 `uses_write_v<T>` 是 `true`，则定义返回类型。否则，会发生替换失败，并执行 SFINAE。
- en: 'Although in all these examples, the `enable_if` type trait was used to enable
    SFINAE during the overload resolution for function templates, this type trait
    can also be used to restrict instantiations of class templates. In the following
    example, we have a class called `integral_wrapper` that is supposed to be instantiated
    only with integral types, and a class called `floating_wrapper` that is supposed
    to be instantiated only with floating-point types:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这些所有示例中，`enable_if` 类型特性被用来在函数模板的重载解析期间启用 SFINAE，但这种类型特性也可以用来限制类模板的实例化。以下示例中，我们有一个名为
    `integral_wrapper` 的类，它应该仅用整型类型实例化，还有一个名为 `floating_wrapper` 的类，它应该仅用浮点型类型实例化：
- en: '[PRE211]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Both these class templates have two type template parameters. The first one
    is called `T`, but the second one is anonymous and has a default argument. The
    value of this argument is defined or not with the help of the `enable_if` type
    trait, based on the value of a Boolean expression.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类模板都有两个类型模板参数。第一个被称为 `T`，但第二个是匿名的，并有一个默认参数。这个参数的值是否定义，是通过 `enable_if` 类型特性根据布尔表达式的值来确定的。
- en: 'In this implementation, we can see:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们可以看到：
- en: 'An alias template called `std::enable_if_t`, which is a convenient way to access
    the `std::enable_if<B, T>::type` member type. This is defined as follows:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `std::enable_if_t` 的别名模板，这是一种方便访问 `std::enable_if<B, T>::type` 成员类型的途径。它定义如下：
- en: '[PRE227]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Two variable templates, `std::is_integral_v` and `std::is_floating_point_v`,
    which are convenient ways to access the data members, `std::is_integral<T>::value`
    and `std::is_floating_point<T>::value`. The `std::is_integral` and `std::is_floating_point`
    classes are standard type traits that check whether a type is an integral type
    or a floating-point type respectively.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个变量模板 `std::is_integral_v` 和 `std::is_floating_point_v`，它们是方便访问数据成员 `std::is_integral<T>::value`
    和 `std::is_floating_point<T>::value` 的途径。`std::is_integral` 和 `std::is_floating_point`
    类是标准类型特性，分别检查一个类型是否是整型或浮点型。
- en: 'The two wrapper class templates shown previously can be used as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的两个包装类模板可以这样使用：
- en: '[PRE228]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Only two of these instantiations work, `w1`, because `integral_wrapper` is instantiated
    with the `int` type, and `w5`, because `floating_wrapper` is instantiated with
    the `double` type. All the others generate compiler errors.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这两种实例化是有效的，`w1` 因为 `integral_wrapper` 是用 `int` 类型实例化的，以及 `w5` 因为 `floating_wrapper`
    是用 `double` 类型实例化的。所有其他实例化都会生成编译器错误。
- en: 'It should be pointed out that this code samples only work with the provided
    definitions of `integral_wrapper` and `floating_wrapper` in C++20\. For previous
    versions of the standard, even the definitions of `w1` and `w5` would generate
    compiler errors because the compiler wasn’t able to deduce the template arguments.
    In order to make them work, we’d have to change the class templates to include
    a constructor, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，这些代码示例仅在 C++20 提供的 `integral_wrapper` 和 `floating_wrapper` 定义下工作。对于标准的前版本，即使是
    `w1` 和 `w5` 的定义也会生成编译器错误，因为编译器无法推断模板参数。为了使它们工作，我们必须将类模板更改为包含构造函数，如下所示：
- en: '[PRE234]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Although `enable_if` helps achieve SFINAE with simpler and more readable code,
    it’s still rather complicated. Fortunately, in `constexpr if` statements. Let’s
    explore this alternative next.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `enable_if` 有助于以更简单、更易读的代码实现 SFINAE，但它仍然相当复杂。幸运的是，在 `constexpr if` 语句中。让我们接下来探索这个替代方案。
- en: Using constexpr if
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `constexpr if`
- en: 'A C++17 feature makes SFINAE much easier. It’s called `constexpr if` and it’s
    a compile-time version of the `if` statement. It helps replace complex template
    code with simpler versions. Let’s start by looking at a C++17 implementation of
    the `serialize` function that can uniformly serialize both widgets and gadgets:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 的一个特性使得 SFINAE 变得更加容易。它被称为 `constexpr if`，它是 `if` 语句的编译时版本。它有助于将复杂的模板代码替换为更简单的版本。让我们先看看
    C++17 对 `serialize` 函数的实现，这个函数可以统一序列化小工具和设备：
- en: '[PRE252]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: The syntax for `constexpr if` is `if constexpr(condition)`. The condition must
    be a compile-time expression. There is no short-circuit logic performed when evaluating
    the expression. This means that if the expression has the form `a && b` or `a
    || b`, then both `a` and `b` must be well-formed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if` 的语法是 `if constexpr(condition)`。条件必须是一个编译时表达式。在评估表达式时不会执行短路逻辑。这意味着如果表达式的形式是
    `a && b` 或 `a || b`，那么 `a` 和 `b` 都必须是正确形成的。'
- en: '`constexpr if` enables us to discard a branch, at compile-time, based on the
    value of the expression. In our example, when the `uses_write_v` variable is `true`,
    the `else` branch is discarded, and the body of the first branch is retained.
    Otherwise, the opposite occurs. Therefore, we end up with the following specializations
    for the `widget` and `gadget` classes:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if` 允许我们在编译时根据表达式的值丢弃一个分支。在我们的例子中，当 `uses_write_v` 变量是 `true` 时，`else`
    分支被丢弃，并保留第一个分支的主体。否则，情况相反。因此，我们最终得到以下针对 `widget` 和 `gadget` 类的特殊化：'
- en: '[PRE260]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Of course, this code is likely to be further simplified by the compiler. Therefore,
    eventually, these specializations would simply look like the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码很可能会被编译器进一步简化。因此，最终这些特化可能看起来就像下面这样：
- en: '[PRE281]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The end result is the same as the one we achieved with SFINAE and `enable_if`,
    but the actual code we wrote here was simpler and easier to understand.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是和我们在 SFINAE 和 `enable_if` 中实现的结果相同，但这里我们编写的实际代码更简单，更容易理解。
- en: '`constexpr if` is a great tool for simplifying code and we actually saw it
    earlier in [*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*,
    in the *Parameter packs* paragraph, when we implemented a function called `sum`.
    This is shown again here:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if` 是简化代码的强大工具，我们实际上在 [*第 3 章*](B18367_03_ePub.xhtml#_idTextAnchor051)，*可变参数模板*，*参数包*
    段落中，当我们实现一个名为 `sum` 的函数时，就看到了它。这在这里再次展示：'
- en: '[PRE293]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'In this example, `constexpr if` helps us to avoid having two overloads, one
    for the general case and one for ending the recursion. Another example presented
    already in this book where `constexpr if` can simplify the implementation is the
    `factorial` function template from [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*, in the *Exploring template recursion* section. That
    function looked as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`constexpr if` 帮助我们避免有两个重载，一个用于通用情况，另一个用于结束递归。这本书中已经提出的一个例子，其中 `constexpr
    if` 可以简化实现的是来自 [*第 4 章*](B18367_04_ePub.xhtml#_idTextAnchor064)，*高级模板概念*，*探索模板递归*
    部分的 `factorial` 函数模板。该函数看起来如下：
- en: '[PRE301]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'With `constexpr if`, we can replace all this with a single template and let
    the compiler take care of providing the right specializations. The C++17 version
    of this function may look as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `constexpr if`，我们可以用单个模板替换所有这些，让编译器负责提供正确的特化。这个函数的 C++17 版本可能看起来如下所示：
- en: '[PRE310]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'The `constexpr if` statements can be useful in many situations. The last example
    presented in this section is a function template called `are_equal`, which determines
    whether the two supplied arguments are equal or not. Typically, you’d think that
    using `operator==` should be enough to determine whether two values are equal
    or not. That is true in most cases, except for floating-point values. Because
    only some of the floating-point numbers can be stored without a precision loss
    (numbers like 1, 1.25, 1.5, and anything else where the fractional part is an
    exact sum of inverse powers of 2) we need to take special care when comparing
    floating-point numbers. Usually, this is solved by ensuring that the difference
    between two floating-point values is less than some threshold. Therefore, a possible
    implementation for such a function could be as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if` 语句在许多情况下都很有用。本节最后给出的示例是一个名为 `are_equal` 的函数模板，它确定提供的两个参数是否相等。通常，你会认为使用
    `operator==` 就足以确定两个值是否相等。这在大多数情况下是正确的，除了浮点值。因为只有一些浮点数可以无精度损失地存储（如 1、1.25、1.5
    以及任何分数部分是 2 的逆幂精确和的数），在比较浮点数时我们需要特别注意。通常，这是通过确保两个浮点值之间的差小于某个阈值来解决的。因此，此类函数的一个可能的实现如下：'
- en: '[PRE318]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: When the `T` type is a floating-point type, we compare the absolute value of
    the difference of the two numbers with the selected threshold. Otherwise, we fall
    back to using `operator==`. This enables us to use this function not just with
    arithmetic types, but also any other type for which the equality operator is overloaded.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `T` 类型是浮点类型时，我们比较两个数字差值的绝对值与所选阈值。否则，我们回退到使用 `operator==`。这使得我们不仅可以在算术类型上使用此函数，还可以在重载了相等操作符的任何其他类型上使用。
- en: '[PRE326]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: We are able to call the `are_equal` function template with arguments of type
    `int`, `double`, and `std::string`. However, attempting to do the same with values
    of the `widget` type will trigger a compiler error, because the `==` operator
    is not overloaded for this type.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用类型 `int`、`double` 和 `std::string` 作为参数调用 `are_equal` 函数模板。然而，尝试使用 `widget`
    类型的值进行相同的操作将触发编译器错误，因为 `==` 操作符没有为此类型重载。
- en: So far in this chapter, we have seen what type traits are as well as different
    ways to perform conditional compilation. We have also seen some of the type traits
    available in the standard library. In the second part of this chapter, we will
    explore what the standard has to offer with regard to type traits.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经了解了类型特性是什么以及执行条件编译的不同方法。我们还看到了标准库中的一些类型特性。在本章的第二部分，我们将探讨标准在类型特性方面能提供什么。
- en: Exploring the standard type traits
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索标准类型特性
- en: 'The standard library features a series of type traits for querying properties
    of types as well as performing transformations on types. These type traits are
    available in the `<type_traits>` header as part of the type support library. There
    are several categories of type traits including the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一系列类型特性，用于查询类型的属性以及在对类型进行转换。这些类型特性作为类型支持库的一部分，在 `<type_traits>` 头文件中可用。类型特性包括以下几类：
- en: Querying the type category (primary or composite)
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类型类别（基本或复合）
- en: Querying type properties
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类型属性
- en: Querying supported operations
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询支持的操作
- en: Querying type relationships
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类型关系
- en: Modifying cv-specifiers, references, pointers, or a sign
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 cv 说明符、引用、指针或符号
- en: Miscellaneous transformations
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂项转换
- en: 'Although looking at every single type trait is beyond the scope of this book,
    we will explore all these categories to see what they contain. In the following
    subsections, we will list the type traits (or most of them) that make up each
    of these categories. These lists as well as detailed information about each type
    trait can be found in the C++ standard (see the *Further reading* section at the
    end of the chapter for a link to a freely available draft version) or on the [cppreference.com](http://cppreference.com)
    website at [https://en.cppreference.com/w/cpp/header/type_traits](https://en.cppreference.com/w/cpp/header/type_traits)
    (license usage link: [http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查看每个单独的类型特性超出了本书的范围，但我们将探索所有这些类别，以了解它们包含的内容。在以下小节中，我们将列出构成每个这些类别的类型特性（或其中大部分）。这些列表以及每个类型特性的详细信息可以在
    C++ 标准中找到（请参阅章节末尾的 *进一步阅读* 部分，以获取免费可用的草案版本链接）或 [cppreference.com](http://cppreference.com)
    网站上的 [https://en.cppreference.com/w/cpp/header/type_traits](https://en.cppreference.com/w/cpp/header/type_traits)（许可使用链接：[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/))。
- en: We will start with the type traits for querying the type category.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从查询类型类别的类型特性开始。
- en: Querying the type category
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询类型类别
- en: 'Throughout this book so far, we have used several type traits, such as `std::is_integral`,
    `std::is_floating_point`, and `std::is_arithmetic`. These are just some of the
    standard type traits used for querying primary and composite type categories.
    The following table lists the entire set of such type traits:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经使用了几个类型特性，例如 `std::is_integral`、`std::is_floating_point` 和 `std::is_arithmetic`。这些只是用于查询基本和复合类型类别的一些标准类型特性。以下表格列出了此类类型特性的完整集合：
- en: '![Table 5.1](img/B18367_05_Table1.1.jpg)![Table 5.1](img/B18367_05_Table1.2.jpg)![Table
    5.1'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 5.1](img/B18367_05_Table1.1.jpg)![表 5.1](img/B18367_05_Table1.2.jpg)![表
    5.1'
- en: '](img/B18367_05_Table1.3.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 5.1](img/B18367_05_Table1.3.jpg)'
- en: Table 5.1
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1
- en: 'All these type traits are available in C++11\. For each of them, starting with
    C++17, a variable template is available to simplify the access to the Boolean
    member called `value`. For a type trait with the name `is_abc`, a variable template
    with the name `is_abc_v` exists. This is true for all the type traits that have
    a Boolean member called `value`. The definition of these variables is very simple.
    The next snippet shows the definition for the `is_arithmentic_v` variable template:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型特性都在 C++11 中可用。从 C++17 开始，对于每个类型特性，都有一个变量模板可用于简化对名为 `value` 的布尔成员的访问。对于名为
    `is_abc` 的类型特性，存在一个名为 `is_abc_v` 的变量模板。这对于所有具有名为 `value` 的布尔成员的类型特性都适用。这些变量的定义非常简单。下面的代码片段显示了
    `is_arithmentic_v` 变量模板的定义：
- en: '[PRE330]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'Here is an example of using some of these type traits:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用一些这些类型特性的示例：
- en: '[PRE333]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: The function template `as_string` returns a string containing the value pass
    as an argument. It works with arithmetic types only and with the `nullptr_t` for
    which it returns the value `"null"`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板 `as_string` 返回一个包含作为参数传递的值的字符串。它仅适用于算术类型，对于 `nullptr_t`，它返回值 `"null"`。
- en: 'You must have noticed the statement, `static_assert(always_false<T>)`, and
    wondering what this `always_false<T>` expression actually is. It is a variable
    template of the `bool` type that evaluates to `false`. Its definition is as simple
    as the following:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了语句 `static_assert(always_false<T>)`，并想知道这个 `always_false<T>` 表达式实际上是什么。它是一个评估为
    `false` 的 `bool` 类型的变量模板。其定义与以下内容一样简单：
- en: '[PRE349]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: This is needed because the statement, `static_assert(false)`, would make the
    program ill-formed. The reason for this is that its condition would not depend
    on a template argument but evaluate to `false`. When no valid specialization can
    be generated for a sub-statement of a `constexpr if` statement within a template,
    the program is ill-formed (and no diagnostic is required). To avoid this, the
    condition of the `static_assert` statement must depend on a template argument.
    With `static_assert(always_false<T>)`, the compiler does not know whether this
    would evaluate to `true` or `false` until the template is instantiated.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为语句 `static_assert(false)` 会使程序无效。原因是其条件不会依赖于模板参数，而是评估为 `false`。当无法为模板内的
    `constexpr if` 语句的子语句生成有效特化时，程序是无效的（且不需要诊断）。为了避免这种情况，`static_assert` 语句的条件必须依赖于模板参数。使用
    `static_assert(always_false<T>)`，编译器不知道这会评估为 `true` 还是 `false`，直到模板实例化。
- en: The next category of type traits we explore allows us to query properties of
    types.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的类型特性的下一类别允许我们查询类型的属性。
- en: Querying type properties
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type traits that enable us to query properties of types are the following:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.2'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table2.1.jpg)![Table 5.2'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table2.2.jpg)![Table 5.2'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table2.3.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Although most of these are probably straightforward to understand, there are
    two that seem the same at a first glance. These are `is_trivial` and `is_trivially_copyable`.
    These both are true for scalar types or arrays of scalar types. They also are
    true for classes that are trivially copyable or arrays of such classes but `is_trivial`
    is true only for copyable classes that have a trivial default constructor.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the paragraph *§11.4.4.1* in the C++ 20 standard, a default constructor
    is trivial if it is not user-provided, and the class has no virtual member functions,
    no virtual base classes, no non-static members with default initializers, every
    direct base of it has a trivial default constructor, and every non-static member
    of a class type also has a trivial default constructor. To understand this better,
    let’s look at the following example:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: In this example, there are three similar classes. All three of them, `foo`,
    `bar`, and `tar`, are trivially copyable. However, only the `foo` class is a trivial
    class, because it has a trivial default constructor. The `bar` class has a non-static
    member with a default initializer, and the `tar` class has a user-defined constructor,
    and this makes them non-trivial.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Apart from trivial copy-ability, there are other operations that we can query
    for with the help of other type traits. We will see these in the following section.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Querying supported operations
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following set of type traits helps us to query supported operations:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.3'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table3.1.jpg)![Table 5.3'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table3.2.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Except for the last sub-set, which was introduced in C++17, the others are available
    in C++11\. Each kind of these type traits has multiple variants, including ones
    for checking operations that are trivial or declared as non-throwing with the
    `noexcept` specifier.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at type traits that allow us to query for relationships between
    types.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Querying type relationships
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this category, we can find several type traits that help to query relationships
    between types. These type traits are as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.4'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table4.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.4
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Of these type traits, perhaps the most used one is `std::is_same`. This type
    trait is very useful in determining whether two types are the same. Keep in mind
    that this type trait takes into account the `const` and `volatile` qualifiers;
    therefore, `int` and `int const`, for instance, are not the same type.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this type trait to extend the implementation of the `as_string`
    function shown earlier. Remember that if you called it with the arguments `true`
    or `false` it prints `1` or `0`, and not `true`/`false`. We can add an explicit
    check for the `bool` type and return a string containing one of these two values,
    shown as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: All the type traits seen so far are used to query some kind of information about
    types. In the next sections, we will see type traits that perform modifications
    on types.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Modifying cv-specifiers, references, pointers, or a sign
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type traits that are performing transformations on types are also called
    metafunctions. These type traits provided a member type (`typedef`) called `type`
    that represents the transformed type. This category of type traits includes the
    following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.5'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table5.1.jpg)![Table 5.5'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table5.2.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.5
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of `remove_cvref`, which was added in C++20, all the other
    type traits listed in this table are available in C++11\. These are not all the
    metafunctions from the standard library. More are listed in the next section.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous transformations
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the metafunctions previously listed, there are other type traits
    performing type transformations. The most important of these are listed in the
    following table:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.6'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table6.1.jpg)![Table 5.6'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_05_Table6.2.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.6
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'From this list, we have already discussed `enable_if`. There are some other
    type traits here that are worth exemplifying. Let’s first look at `std::decay`
    and for this purpose, let’s consider the following slightly changed implementation
    of the `as_string` function:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: 'The only change is the way we pass arguments to the function. Instead of passing
    by value, we pass by rvalue reference. If you remember from [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*, this is a forwarding reference. We can still make
    calls passing rvalues (such as literals) but passing lvalues will trigger compiler
    errors:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: 'The last two calls are triggering the `static_assert` statement to fail. The
    actual type template arguments are `bool&` and `int&`. Therefore `std::is_same<bool,
    bool&>` will initialize the `value` member with `false`. Similarly, `std::is_arithmetic<int&>`
    will do the same. In order to evaluate these types, we need to ignore references
    and the `const` and `volatile` qualifiers. The type trait that helps us do so
    is `std::decay`, which performs several transformations, as described in the previous
    table. Its conceptual implementation is the following:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: From this snippet, we can see that `std::decay` is implemented with the help
    of other metafunctions, including `std::conditional`, which is key for selecting
    between one type or another based on a compile-time expression. Actually, this
    type trait is used multiple times, which is something you can do if you need to
    make a selection based on multiple conditions.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of `std::decay`, we can modify the implementation of the `as_string`
    function, stripping reference, and cv-qualifiers:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `std::decay` 的帮助，我们可以修改 `as_string` 函数的实现，去除引用和 cv-限定符：
- en: '[PRE421]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: By changing the implementation as shown here, we made the previous calls to
    `as_string` that failed to compile without any more errors.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如上所示更改实现，我们使之前调用 `as_string` 时未能编译的调用不再出现任何错误。
- en: 'In the implementation of `std::decay` we saw the repetitive use of `std::conditional`.
    This is a metafunction that is fairly easy to use and can help to simplify many
    implementations. In [*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), *Template
    Fundamentals*, in the section *Defining alias templates*, we saw an example where
    we built a list type called `list_t`. This had a member alias template called
    `type` that was aliasing either the template type `T`, if the size of the list
    was `1`, or `std::vector<T>`, if it was higher. Let’s look at the snippet again:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `std::decay` 的实现中，我们看到了 `std::conditional` 的重复使用。这是一个相对容易使用且有助于简化许多实现的元函数。在
    [*第2章*](B18367_02_ePub.xhtml#_idTextAnchor024) 的 *模板基础* 部分，*定义别名模板* 小节中，我们看到了一个构建名为
    `list_t` 的列表类型的例子。这个类型有一个成员别名模板 `type`，它根据列表的大小是别名模板类型 `T`（如果列表大小为 `1`）还是 `std::vector<T>`（如果更大）。让我们再次看看这个片段：
- en: '[PRE434]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'This implementation can be greatly simplified with the help of `std::conditional`
    as follows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式使用 `std::conditional` 可以大大简化这个实现：
- en: '[PRE446]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'There is no need to rely on class template specialization to define such a
    list type. The entire solution can be reduced to defining an alias template. We
    can verify this works as expected with some `static_assert` statements, as follows:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要依赖类模板特化来定义这样的列表类型。整个解决方案可以简化为定义一个别名模板。我们可以通过一些 `static_assert` 语句来验证它是否按预期工作，如下所示：
- en: '[PRE450]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: Exemplifying the use of each of the standard type traits is beyond the scope
    of this book. However, the next section of this chapter provides more complex
    examples that require the use of several standard type traits.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 展示每个标准类型特性的用法超出了本书的范围。然而，本章的下一节提供了需要使用几个标准类型特性的更复杂示例。
- en: Seeing real-world examples of using type traits
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看看使用类型特性的真实世界示例
- en: In the previous section of the chapter, we have explored the various type traits
    that the standard library provides. It is difficult and unnecessary to find examples
    for each and every type trait. However, it is worth showcasing some examples where
    multiple type traits can be used for solving a problem. We will do this next.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一节中，我们已经探讨了标准库提供的各种类型特性。为每个类型特性寻找示例是困难和不必要的。然而，展示一些可以使用多个类型特性解决问题的示例是值得的。我们将在下一节中这样做。
- en: Implementing a copy algorithm
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现复制算法
- en: 'The first example problem we will take a look at is a possible implementation
    for the `std::copy` standard algorithm (from the `<algorithm>` header). Keep in
    mind that what we will see next is not the actual implementation but a possible
    one that helps us learn more about the use of type traits. The signature of this
    algorithm is as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个示例问题是 `std::copy` 标准算法（来自 `<algorithm>` 头文件）的一个可能的实现。记住，我们下面将要看到的是实际实现的一个可能版本，它有助于我们了解类型特性的用法。这个算法的签名如下：
- en: '[PRE453]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: 'As a note, this function is `constexpr` only in C++20, but we can discuss it
    in this context. What it does is copy all the elements in the range [`first`,
    `last`) to another range that begins with `d_first`. There is also an overload
    that takes an execution policy, and a version, `std::copy_if`, that copies all
    the elements that match a predicate, but these are not important for our example.
    A straightforward implementation of this function is the following:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 作为备注，这个函数仅在 C++20 中是 `constexpr`，但我们可以在这个上下文中讨论它。它的作用是将范围 `[first, last)` 中的所有元素复制到以
    `d_first` 开始的另一个范围中。还有一个重载版本，`std::copy_if`，它复制所有匹配谓词的元素，但这些对我们示例不重要。这个函数的直接实现如下：
- en: '[PRE456]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: 'However, there are cases when this implementation can be optimized by simply
    copying memory. However, there are some conditions that must be met for this purpose:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，这个实现可以通过简单地复制内存来优化。但是，为了达到这个目的，必须满足一些条件：
- en: Both iterator types, `InputIt` and `OutputIt`, must be pointers.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个迭代器类型，`InputIt` 和 `OutputIt`，必须是指针。
- en: Both template parameters, `InputIt` and `OutputIt`, must point to the same type
    (ignoring cv-qualifiers).
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个模板参数，`InputIt` 和 `OutputIt`，必须指向相同的类型（忽略 cv-限定符）。
- en: The type pointed by `InputIt` must have a trivial copy assignment operator.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputIt`指向的类型必须有一个平凡的复制赋值运算符。'
- en: 'We can check these conditions with the following standard type traits:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下标准类型特性来检查这些条件：
- en: '`std::is_same` (and the `std::is_same_v` variable) to check that two types
    are the same.'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_same`（以及`std::is_same_v`变量）用于检查两个类型是否相同。'
- en: '`std::is_pointer` (and the `std::is_pointer_v` variable) to check that a type
    is a pointer type.'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_pointer`（以及`std::is_pointer_v`变量）用于检查一个类型是否为指针类型。'
- en: '`std::is_trivially_copy_assignable` (and the `std::is_trivially_copy_assignable_v`
    variable) to check whether a type has a trivial copy assignment operator.'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_trivially_copy_assignable`（以及`std::is_trivially_copy_assignable_v`变量）用于检查一个类型是否具有平凡的复制赋值运算符。'
- en: '`std::remove_cv` (and the `std::remove_cv_t` alias template) to remove cv-qualifiers
    from a type.'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::remove_cv`（以及`std::remove_cv_t`别名模板）用于从一个类型中移除cv限定符。'
- en: 'Let’s see how we can implement this. First, we need to have a primary template
    with the generic implementation, and then a specialization for pointer types with
    the optimized implementation. We can do this using class templates with member
    function templates as shown next:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这一点。首先，我们需要一个带有泛型实现的原始模板，然后是一个针对指针类型的优化实现。我们可以使用类模板和成员函数模板来实现，如下所示：
- en: '[PRE466]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'To copy memory between a source and a destination we use `std::memmove` here,
    which copies data even if objects overlap. These implementations are provided
    in a namespace called `detail`, because they are implementation details that are
    used in turn by the `copy` function and not directly by the user. The implementation
    of this generic `copy` algorithm could be as follows:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 要在源和目标之间复制内存，我们在这里使用`std::memmove`，即使对象重叠也会复制数据。这些实现提供在一个名为`detail`的命名空间中，因为它们是`copy`函数使用的实现细节，而不是直接由用户使用。这个泛型`copy`算法的实现可能如下所示：
- en: '[PRE497]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'You can see here that the decision to select one specialization or the other
    is based on a `constexpr` Boolean value that is determined using the aforementioned
    type traits. Examples of using this `copy` function are shown in the next snippet:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到，选择一个特化或另一个特化的决定是基于使用上述类型特性确定的`constexpr`布尔值。下面是一个使用此`copy`函数的示例：
- en: '[PRE512]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: Keep in mind that this is not the real definition of the generic algorithm `copy`
    you will find in standard library implementations, which are further optimized.
    However, this was a good example to demonstrate how to use type traits for a real-world
    problem.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这并不是你在标准库实现中找到的泛型算法`copy`的真实定义，这些实现被进一步优化。然而，这是一个很好的例子，展示了如何使用类型特性来解决实际问题。
- en: 'For simplicity, I have defined the `copy` function in what appears to be the
    global namespace. This is a bad practice. In general, code, especially in libraries,
    is grouped in namespaces. In the source code on GitHub that accompanies the book,
    you will find this function defined in a namespace called `n520` (this is just
    a unique name, nothing relevant to the topic). When calling the `copy` function
    that we have defined, we would actually need to use the fully qualified name (that
    includes the namespace name) such as the following:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我将`copy`函数定义在看起来像是全局命名空间的地方。这是一个坏习惯。通常，代码，尤其是在库中，会被分组在命名空间中。在GitHub上伴随书籍的源代码中，你会找到这个函数定义在一个名为`n520`的命名空间中（这只是一个唯一的名称，与主题无关）。当我们调用我们定义的`copy`函数时，我们实际上需要使用完全限定的名称（包括命名空间名称），如下所示：
- en: '[PRE520]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Without this qualification, a process called `copy` to the `std::copy` function
    because the arguments we pass are found in the `std` namespace. You can read more
    about ADL at [https://en.cppreference.com/w/cpp/language/adl](https://en.cppreference.com/w/cpp/language/adl).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个限定，一个名为`copy`的过程被传递给`std::copy`函数，因为我们传递的参数在`std`命名空间中。你可以阅读更多关于ADL的信息，请参阅[https://en.cppreference.com/w/cpp/language/adl](https://en.cppreference.com/w/cpp/language/adl)。
- en: Now, let’s look at another example.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个例子。
- en: Building a homogenous variadic function template
  id: totrans-718
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建同质变长函数模板
- en: 'For the second example, we want to build a variadic function template that
    can only take arguments of the same type or types that can be implicitly converted
    to a common one. Let’s start with the following skeleton definition:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个例子，我们想要构建一个只能接受相同类型或可以隐式转换为公共类型的变长函数模板。让我们从以下骨架定义开始：
- en: '[PRE521]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'The problem with this is that all of the following function calls work (keep
    in mind that the body of this function is empty so there will be no errors due
    to performing operations unavailable on some types):'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于，以下所有函数调用都有效（请记住，这个函数的主体是空的，所以不会因为对某些类型执行不可用的操作而产生错误）：
- en: '[PRE523]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: In the first example, we pass three `int` values. In the second example, we
    pass an `int`, a `double`, and a `char`; both `int` and `char` are implicitly
    convertible to `double`, so this should be all right. However, in the third example,
    we pass an `int`, a `double`, and a `char const*`, and this last type is not implicitly
    convertible to either `int` or `double`. Therefore, this last call is supposed
    to trigger a compiler error but does not.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们传递了三个 `int` 值。在第二个例子中，我们传递了一个 `int`、一个 `double` 和一个 `char`；`int` 和
    `char` 都可以隐式转换为 `double`，所以这应该没问题。然而，在第三个例子中，我们传递了一个 `int`、一个 `double` 和一个 `char
    const*`，而最后一个类型既不能隐式转换为 `int` 也不能转换为 `double`。因此，这个最后的调用应该触发编译器错误，但实际上并没有。
- en: In order to do so, we need to ensure that when a common type for the function
    arguments is not available, the compiler will generate an error. To do so, we
    can use a `static_assert` statement or `std::enable_if` and SFINAE. However, we
    do need to figure out whether a common type exists or not. This is possible with
    the help of the `std::common_type` type trait.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要确保当函数参数的共同类型不可用时，编译器将生成一个错误。为此，我们可以使用 `static_assert` 语句或 `std::enable_if`
    和 SFINAE。然而，我们确实需要弄清楚是否存在共同类型。这可以通过 `std::common_type` 类型特性来实现。
- en: 'The `std::common_type` is a metafunction that defines the common type among
    all of its type arguments that all the types can be implicitly converted to. Therefore
    `std::common_type<int, double, char>::type` will alias the `double` type. Using
    this type trait, we can build another type trait that tells us whether a common
    type exists. A possible implementation is as follows:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::common_type` 是一个元函数，它定义了所有类型参数中可以隐式转换为的共同类型。因此，`std::common_type<int,
    double, char>::type` 将别名 `double` 类型。使用这种类型特性，我们可以构建另一个类型特性，它告诉我们是否存在共同类型。一个可能的实现如下：'
- en: '[PRE526]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: 'You can see in this snippet that we base the implementation on several other
    type traits. First, there is the `std::false_type` and `std::true_type` pair.
    These are type aliases for `std::bool_constant<false>` and `std::bool_constant<true>`
    respectively. The `std::bool_constant` class is available in C++17 and is, in
    turn, an alias template for a specialization of the `std::integral_constant` class
    for the `bool` type. This last class template wraps a static constant of the specified
    type. Its conceptual implementation looks as follows (although some operations
    are also provided):'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个片段中看到，我们基于几个其他类型特性来实现。首先，有 `std::false_type` 和 `std::true_type` 对。这些是
    `std::bool_constant<false>` 和 `std::bool_constant<true>` 的类型别名。`std::bool_constant`
    类在 C++17 中可用，并且是 `std::integral_constant` 类的一个别名模板，该模板针对 `bool` 类型进行了特化。最后一个类模板包装了指定类型的静态常量。其概念实现如下（尽管也提供了一些操作）：
- en: '[PRE537]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: This helps us simplify the definition of type traits that need to define a Boolean
    compile-time value, as we saw in several cases in this chapter.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们简化需要定义布尔编译时值的类型特性的定义，正如我们在本章的几个例子中看到的那样。
- en: A third type trait used in the implementation of the `has_common_type` class
    is `std::void_t`. This type trait defines a mapping between a variable number
    of types and the `void` type. We use this to build a mapping between the common
    type, if one exists, and the `void` type. This enables us to leverage SFINAE for
    the specialization of the `has_common_type` class template.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `has_common_type` 类的实现中使用的第三个类型特性是 `std::void_t`。这个类型特性定义了多个类型和 `void` 类型之间的映射。我们使用它来在存在共同类型的情况下建立共同类型和
    `void` 类型之间的映射。这使得我们能够利用 SFINAE 来特化 `has_common_type` 类模板。
- en: Finally, a variable template called `has_common_type_v` is defined to ease the
    use of the `has_common_type` trait.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了一个名为 `has_common_type_v` 的变量模板，以简化 `has_common_type` 特性的使用。
- en: 'All these can be used to modify the definition of the `process` function template
    to ensure it only allows arguments of a common type. A possible implementation
    is shown next:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以用来修改 `process` 函数模板的定义，以确保它只允许具有共同类型的参数。下面是一个可能的实现：
- en: '[PRE543]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: As a result of this, calls such as `process(1, 2.0, "3")` will produce a compiler
    error because there is no overloaded `process` function for this set of arguments.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像 `process(1, 2.0, "3")` 这样的调用将产生编译器错误，因为没有为这组参数重载 `process` 函数。
- en: As previously mentioned, there are different ways to use the `has_common_type`
    trait to achieve the defined goal. One of these, using `std::enable_if`, was shown
    here, but we can also use `static_assert`. However, a much better approach can
    be taken with the use of concepts, which we will see in the next chapter.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有不同方法可以使用 `has_common_type` 特性来实现既定的目标。其中之一，使用 `std::enable_if`，已在本文中展示，但我们也可以使用
    `static_assert`。然而，使用概念的方法会更好，我们将在下一章中看到这一点。
- en: Summary
  id: totrans-758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the concept of type traits, which are small classes that
    define meta-information about types or transformation operations for types. We
    started by looking at how type traits can be implemented and how they help us.
    Next, we learned about **SFINAE**, which stands for **Substitution Failure Is
    Not An Error**. This is a technique that enables us to provide constraints for
    template parameters.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了类型特性的概念，这些是定义类型元信息或类型转换操作的类。我们首先探讨了类型特性如何实现以及它们如何帮助我们。接下来，我们学习了 **SFINAE**，即
    **Substitution Failure Is Not An Error**。这是一种技术，使我们能够为模板参数提供约束。
- en: We then saw how this purpose can be achieved better with `enable_if` and `constexpr
    if`, in C++17\. In the second part of the chapter, we looked at the type traits
    available in the standard library and demonstrated how to use some of them. We
    ended the chapter with a couple of real-world examples where we used multiple
    type traits to solve a particular problem.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着看到了如何通过 `enable_if` 和 `constexpr if` 在 C++17 中更好地实现这一目的。在章节的第二部分，我们探讨了标准库中可用的类型特性，并展示了如何使用其中的一些。我们以几个实际案例结束本章，在这些案例中，我们使用了多个类型特性来解决特定问题。
- en: In the next chapter, we continue the topic of constraining the template parameters
    by learning about the C++20 concepts and constraints.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨通过学习 C++20 的概念和约束来限制模板参数的话题。
- en: Questions
  id: totrans-762
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are type traits?
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类型特性？
- en: What is SFINAE?
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 SFINAE？
- en: What is `constexpr if`?
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `constexpr if`？
- en: What does `std::is_same` do?
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::is_same` 是做什么的？'
- en: What does `std::conditional` do?
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::conditional` 是做什么的？'
- en: Further reading
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++ Type traits*, John Maddock and Steve Cleary, [https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm](https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm)'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 类型特性*，John Maddock 和 Steve Cleary，[https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm](https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm)'
- en: '*N4861 Post-Prague 2020 C++ working draft*, [https://github.com/cplusplus/draft/releases/tag/n4861](https://github.com/cplusplus/draft/releases/tag/n4861)'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N4861 Post-Prague 2020 C++ 工作草案*，[https://github.com/cplusplus/draft/releases/tag/n4861](https://github.com/cplusplus/draft/releases/tag/n4861)'
- en: '*What is ADL?*, Arthur O’Dwyer, [https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/](https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/)'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是 ADL？*，Arthur O’Dwyer，[https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/](https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/)'
