<html><head></head><body>
<div id="_idContainer046">
<h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.2.1">Writing Generic Containers with Allocator Support</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We have come a long way since the beginning of this book. </span><span class="koboSpan" id="kobo.3.2">Recent chapters examined how one can write memory-efficient containers, describing how to do so when memory management is done explicitly (in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.5.1">) and when it is done implicitly, through smart pointers (in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">Choosing a memory management approach is not an either/or proposition; each one is useful in its own way and solves real-life use cases depending on one’s </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">application domain.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">However, none of the approaches we have covered so far match what standard library containers do. </span><span class="koboSpan" id="kobo.9.2">Indeed, standard library containers (as well as many other standard library types that can dynamically allocate memory) are </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">allocator-aware</span></strong><span class="koboSpan" id="kobo.11.1"> and delegate low-level memory </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.12.1">management tasks to specialized objects that can be supplied by client code. </span><span class="koboSpan" id="kobo.12.2">There is merit to this idea as it allows one to pick a container based on the way it organizes objects in memory and couple said container with an allocator, a “memory allocation specialist.” </span><span class="koboSpan" id="kobo.12.3">This opens up a world of possibilities, some of them very popular, such as using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">std::vector</span></strong><span class="koboSpan" id="kobo.14.1"> whose memory comes from an arena (see </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.16.1">) or from a fixed-capacity buffer on </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">the stack.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">Allocators officially came to the C++ language, along with the standard library containers, in C++98, but they evolved and diversified themselves over time. </span><span class="koboSpan" id="kobo.18.2">Writing an allocator became significantly simpler with C++11, and C++17 introduced an entirely new approach to memory allocation</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.19.1"> with </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">polymorphic memory resource</span></strong><span class="koboSpan" id="kobo.21.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.22.1">PMR</span></strong><span class="koboSpan" id="kobo.23.1">) allocators </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">and containers.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In this chapter, you will do </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">Understand and use </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">traditional allocators</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Write a traditional allocator for a specialized </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">application domain</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Learn how to manage the allocator lifetime when a container is moved </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">or copied</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Clone an </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">allocator’s type</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Understand and use PMR allocators </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">and containers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">Equipped with a knowledge of allocators and how they interact with containers, this chapter will enrich your memory management toolbox and open up new ways to combine data organization with the way storage is obtained. </span><span class="koboSpan" id="kobo.37.2">Understanding allocators might even make writing new containers less of a necessity; sometimes, instead of trying to create an entirely new container, the solution is just a matter of combining the right data organization strategy with the right storage </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">management approach.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.39.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.40.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.44.1">A word about the examples in this chapter</span></p>
<p class="callout"><span class="koboSpan" id="kobo.45.1">As was the case with </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.47.1">, this chapter will show incomplete examples to avoid redundancy with the excerpts found earlier, particularly those in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">Allocators change the way in which containers interact with memory management facilities, but they do not require rewriting containers entirely, so a lot of code written for a given container remains stable regardless of how memory is managed. </span><span class="koboSpan" id="kobo.49.3">The code you will find in the GitHub repository is, of </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">course, complete.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.51.1">Also note that this chapter discusses allocators in the context of containers, but the idea can be extended to many types that need to dynamically allocate memory. </span><span class="koboSpan" id="kobo.51.2">It is sometimes difficult to do so; for example, support for allocators in </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">std::function</span></strong><span class="koboSpan" id="kobo.53.1"> was removed in C++17 as no known standard library implementation had managed to make it work. </span><span class="koboSpan" id="kobo.53.2">Still, allocators can be seen as a general idea, not something that is limited to containers, and you can envision using allocators in </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">other contexts.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.55.1">Why allocators?</span></h1>
<p><span class="koboSpan" id="kobo.56.1">Allocators tend to scare people, including</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.57.1"> some experts, but you will not be scared as you are already in possession of significant memory management knowledge and skills (and you are probably curious to know more about the topic given the fact that you are reading this book). </span><span class="koboSpan" id="kobo.57.2">Knowing this, the first question we need to address, before even expressing what an allocator is, is “Why do allocators exist?”. Why would we concern ourselves with an additional layer of complexity in our memory </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">management code?</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Well, this is C++, and C++ is all about giving users </span><em class="italic"><span class="koboSpan" id="kobo.60.1">control</span></em><span class="koboSpan" id="kobo.61.1">, so that’s where our explanation begins. </span><span class="koboSpan" id="kobo.61.2">To make an analogy, think about iterators: why they are useful, and how they make your life as a programmer better. </span><span class="koboSpan" id="kobo.61.3">They decouple iterating over elements of a sequence from how the elements are organized in that sequence, such that you can write code that computes something such as the sum of the values in </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">std::list&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.63.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">std::vector&lt;short&gt;</span></strong><span class="koboSpan" id="kobo.65.1"> without having to know that in the first case, you are navigating through nodes linked to one another by pointers and in the second case, you are iterating through objects stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">contiguous memory.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">The beauty of iterators is this decoupling between iteration and data organization. </span><span class="koboSpan" id="kobo.67.2">Similarly, allocators decouple data organization from the way the underlying storage is obtained or freed. </span><span class="koboSpan" id="kobo.67.3">This allows us to reason about the properties of containers independently from the properties of memory management and makes containers useful in even more situations than they would </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">otherwise be.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.69.1">A very, very thin layer…</span></p>
<p class="callout"><span class="koboSpan" id="kobo.70.1">To a container, an allocator (at least those in the “traditional” model that we are about to discuss) represents a thin (</span><em class="italic"><span class="koboSpan" id="kobo.71.1">very</span></em><span class="koboSpan" id="kobo.72.1"> thin) layer of abstraction over the hardware. </span><span class="koboSpan" id="kobo.72.2">To a container, an allocator expresses such things as “What is an address?”, “How does one put an object somewhere?”, “How does one destroy an object at some location?”, and so on. </span><span class="koboSpan" id="kobo.72.3">In a way, for a container, the allocator essentially </span><em class="italic"><span class="koboSpan" id="kobo.73.1">is</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.74.1">the hardware.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.75.1">Traditional allocators</span></h1>
<p><span class="koboSpan" id="kobo.76.1">As mentioned </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.77.1">already, allocators have been a mainstay of C++ for decades now, but they have existed in a few different guises and shapes. </span><span class="koboSpan" id="kobo.77.2">In this chapter, we will adopt a sort of chronological approach, starting from the earlier (and more complicated) allocator types and progressing toward the simpler (and more </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">versatile) ones.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">To understand this chapter, one key idea to keep in mind is that a container type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.81.1"> does not really exist. </span><span class="koboSpan" id="kobo.81.2">What does exist is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">std::vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.83.1"> type where, by default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">A</span></strong><span class="koboSpan" id="kobo.85.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">std::allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.87.1">, which allocates through </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">::operator new()</span></strong><span class="koboSpan" id="kobo.89.1"> and deallocates through </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">::operator delete()</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">By </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">traditional allocator</span></strong><span class="koboSpan" id="kobo.93.1">, we mean an allocator type that is part of the type of a container (this is not the only possible approach to writing allocators today, as we will see when we discuss PMR allocators later in </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">this chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">We will first examine what was required to write an allocator before C++11, and how a container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">std::vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.97.1"> could use an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">A</span></strong><span class="koboSpan" id="kobo.99.1"> type to abstract away its memory</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.100.1"> allocation tasks. </span><span class="koboSpan" id="kobo.100.2">Improvements to the way allocators are expressed will follow in later sections of </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">this chapter.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.102.1">Before C++11</span></h2>
<p><span class="koboSpan" id="kobo.103.1">Traditional allocators </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.104.1">written before C++11 had to implement a wide array of members, which made the task of writing allocators seem daunting to many. </span><span class="koboSpan" id="kobo.104.2">Consider what one had to write in those days, and please note that not all of what follows remains true as of this writing since the API of allocators has evolved </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">over time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.106.1">On the difficulty of tracking an evolving API</span></p>
<p class="callout"><span class="koboSpan" id="kobo.107.1">What is required of allocators changed with every version of C++ since C++03, and these days, it is not always easy (or relevant) to write examples that compile for C++11. </span><span class="koboSpan" id="kobo.107.2">For this reason, the examples we will write in a detailed manner will use C++11 allocators, to show what that actually meant, but will compile with the C++17 standard to make the code more pleasant to read (</span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">and write).</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">We will examine such an allocator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.111.1">, and implement it in a way that resembles </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">std::allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.113.1"> in order to highlight what it meant to write an allocator in the C++11 era, and then compare that with an equivalent expressed for a more recent version of the standard. </span><span class="koboSpan" id="kobo.113.2">We will use C++17 features in our implementation as we do not want to introduce unnecessary complexity in an already </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">subtle topic.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">After introducing </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.117.1">, we will show how </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.119.1"> from </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.120.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.121.1"> and </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.122.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.123.1"> can be</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.124.1"> enhanced and become </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.126.1">, and how </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">A</span></strong><span class="koboSpan" id="kobo.128.1"> can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">std::allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.130.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.132.1">, or any other conforming </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">allocator type.</span></span></p>
<h3><span class="koboSpan" id="kobo.134.1">Type aliases</span></h3>
<p><span class="koboSpan" id="kobo.135.1">An allocator of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">T</span></strong><span class="koboSpan" id="kobo.137.1"> type </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.138.1">had to expose type aliases for </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">value_type</span></strong><span class="koboSpan" id="kobo.140.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">size_type</span></strong><span class="koboSpan" id="kobo.142.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">difference_type</span></strong><span class="koboSpan" id="kobo.144.1"> (the type one would get from subtracting two </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">pointer</span></strong><span class="koboSpan" id="kobo.146.1"> objects), </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">pointer</span></strong><span class="koboSpan" id="kobo.148.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">const_pointer</span></strong><span class="koboSpan" id="kobo.150.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">reference</span></strong><span class="koboSpan" id="kobo.152.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">const_reference</span></strong><span class="koboSpan" id="kobo.154.1">. </span><span class="koboSpan" id="kobo.154.2">One way to think about this is that to a container, the allocator represents the underlying memory and consequently defines the types that best describe these low-level ideas. </span><span class="koboSpan" id="kobo.154.3">Containers could then map their own aliases to those of their allocator </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">for conformity.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.158.1"> type, this would translate to </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
template &lt;class T&gt;
struct small_allocator {
   using value_type = T;
   using pointer = T*;
   using const_pointer = const T*;
   using reference = T&amp;;
   using const_reference = const T&amp;;
   using size_type = std::size_t;
   using difference_type = std::ptrdiff_t;
   // ...</span></pre> <p><span class="koboSpan" id="kobo.161.1">In practice, for an allocator of </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">T</span></strong><span class="koboSpan" id="kobo.163.1">, one could expect these type aliases to correspond to those shown here for </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.165.1"> in all but the strangest cases: as long as </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">value_type</span></strong><span class="koboSpan" id="kobo.167.1"> is defined, we can almost always infer </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">the others.</span></span></p>
<h3><span class="koboSpan" id="kobo.169.1">Member functions</span></h3>
<p><span class="koboSpan" id="kobo.170.1">An allocator</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.171.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">T</span></strong><span class="koboSpan" id="kobo.173.1"> type had to expose a member function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">max_size()</span></strong><span class="koboSpan" id="kobo.175.1">, that was supposed to return the size of the largest block that this allocator could </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">actually allocate.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">In practice, that often proved to be unimplementable as, with some operating systems, allocation always succeeds (but usage of the allocated memory may fail if the program is over-allocated) so that function usually turned out to be implemented on a best-effort basis on a given platform. </span><span class="koboSpan" id="kobo.177.2">A possible implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
   // ...
</span><span class="koboSpan" id="kobo.179.2">   constexpr size_type max_size() const {
      return std::numeric_limits&lt;size_type&gt;::max(); // bah
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.180.1">An allocator of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">T</span></strong><span class="koboSpan" id="kobo.182.1"> type also had to expose two overloads of a function that uses all the words this author’s students “love” in a single signature (appreciate the irony!). </span><span class="koboSpan" id="kobo.182.2">Consider </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">pointer address(reference r)</span></strong><span class="koboSpan" id="kobo.184.1"> as well as the equivalent for </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">const</span></strong><span class="koboSpan" id="kobo.186.1"> objects, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">const_pointer address(const_reference r)</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">The intent here is to abstract the ways in which one would get the address of </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">an object.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">It would be tempting to implement each of these functions as </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">return &amp;r;</span></strong><span class="koboSpan" id="kobo.192.1"> but in practice, this is perilous as users are allowed to overload the unary </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">operator&amp;()</span></strong><span class="koboSpan" id="kobo.194.1"> for their types, and this means such an implementation would call arbitrary code, a scary prospect indeed… Avoid overloading something as fundamental as “taking the address of an object” unless you really, </span><em class="italic"><span class="koboSpan" id="kobo.195.1">really</span></em><span class="koboSpan" id="kobo.196.1"> have a good reason to do so, and even then, consider alternative approaches to solving </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">your problem!</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">A better implementation technique is to express these functions through </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">return std::addressof(r);</span></strong><span class="koboSpan" id="kobo.200.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">std::addressof()</span></strong><span class="koboSpan" id="kobo.202.1"> is a “magical” standard library function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">&lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.204.1"> (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">constexpr</span></strong><span class="koboSpan" id="kobo.206.1">) and returns the address of an object without going through an </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">overloadable facility:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
   // ...
</span><span class="koboSpan" id="kobo.208.2">   constexpr pointer address(reference r) const {
      return std::addressof(r);
   }
   constexpr
      const_pointer address(const_reference r) const {
      return std::addressof(r);
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.209.1">Obviously, an allocator needs to expose member functions to perform the actual memory allocation. </span><span class="koboSpan" id="kobo.209.2">The signatures for these are </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">allocate(size_type n)</span></strong><span class="koboSpan" id="kobo.211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">deallocate(pointer p, size_type n)</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">A simple implementation of these two functions </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.214.1">could be </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
   // ...
</span><span class="koboSpan" id="kobo.216.2">   pointer allocate(size_type n) {
      auto p = static_cast&lt;pointer&gt;(
         malloc(n * sizeof(value_type))
      );
      if (!p) throw std::bad_alloc{};
      return p;
   }
   void deallocate(pointer p, size_type) {
      free(p);
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.217.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">allocate()</span></strong><span class="koboSpan" id="kobo.219.1"> member </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.220.1">function used to take a second argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">void*</span></strong><span class="koboSpan" id="kobo.222.1"> type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">hint</span></strong><span class="koboSpan" id="kobo.224.1">, which was initialized to </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">nullptr</span></strong><span class="koboSpan" id="kobo.226.1"> by default. </span><span class="koboSpan" id="kobo.226.2">This argument was meant to inform the allocator of a location that could be used to provide storage, in case the container knew of such a location. </span><span class="koboSpan" id="kobo.226.3">That feature seemed rarely (if ever) used in practice, and was deprecated in C++17 and then removed </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">in C++20.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">These two functions are the essence of why allocators exist: </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">allocate()</span></strong><span class="koboSpan" id="kobo.230.1"> returns a chunk of memory big enough to hold </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">n</span></strong><span class="koboSpan" id="kobo.232.1"> contiguous elements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">value_type</span></strong><span class="koboSpan" id="kobo.234.1">, throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">bad_alloc</span></strong><span class="koboSpan" id="kobo.236.1"> on failure, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">deallocate()</span></strong><span class="koboSpan" id="kobo.238.1"> deallocates a chunk of memory big enough to hold </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">n</span></strong><span class="koboSpan" id="kobo.240.1"> contiguous elements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">value_type</span></strong><span class="koboSpan" id="kobo.242.1">. </span><span class="koboSpan" id="kobo.242.2">When one writes an allocator, one usually seeks to provide an answer to this </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">specific problem.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.244.1">Bytes or objects</span></p>
<p class="callout"><span class="koboSpan" id="kobo.245.1">Interestingly, contrary to </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">operator new()</span></strong><span class="koboSpan" id="kobo.247.1">, which takes a number of </span><em class="italic"><span class="koboSpan" id="kobo.248.1">bytes</span></em><span class="koboSpan" id="kobo.249.1"> as argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">allocate()</span></strong><span class="koboSpan" id="kobo.251.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">deallocate()</span></strong><span class="koboSpan" id="kobo.253.1"> both take as argument a number of </span><em class="italic"><span class="koboSpan" id="kobo.254.1">objects</span></em><span class="koboSpan" id="kobo.255.1">. </span><span class="koboSpan" id="kobo.255.2">That is because traditional allocators are type-aware (they are allocators of some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">T</span></strong><span class="koboSpan" id="kobo.257.1"> after all), whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">operator new()</span></strong><span class="koboSpan" id="kobo.259.1"> and friends are (mostly) type-agnostic. </span><span class="koboSpan" id="kobo.259.2">You will notice later in this chapter that PMR allocators (which one might call “a step back”) use memory resources that are type-agnostic such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">malloc()</span></strong><span class="koboSpan" id="kobo.261.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">allocate()</span></strong><span class="koboSpan" id="kobo.266.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">deallocate()</span></strong><span class="koboSpan" id="kobo.268.1"> deliberately lie</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.269.1"> to client </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.270.1">code: they trade in raw memory and neither create nor destroy objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">T</span></strong><span class="koboSpan" id="kobo.272.1">, yet </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">allocate()</span></strong><span class="koboSpan" id="kobo.274.1"> returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">pointer</span></strong><span class="koboSpan" id="kobo.276.1"> (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">T*</span></strong><span class="koboSpan" id="kobo.278.1">, essentially) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">deallocate()</span></strong><span class="koboSpan" id="kobo.280.1"> accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">pointer</span></strong><span class="koboSpan" id="kobo.282.1"> as argument even though all </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">T</span></strong><span class="koboSpan" id="kobo.284.1"> objects are assumed to have been </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">destroyed beforehand.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">The fact that these </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.287.1">functions lie to the type system is a good thing in a way, as it relieves the container from the task of doing so. </span><span class="koboSpan" id="kobo.287.2">Of course, the container has to be aware of what these functions do and should not assume the presence of objects in memory returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">allocate()</span></strong><span class="koboSpan" id="kobo.289.1"> or passed </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">deallocate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">Finally, an allocator had to expose member functions to turn raw memory into objects and conversely. </span><span class="koboSpan" id="kobo.293.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">construct(pointer p,const_reference r)</span></strong><span class="koboSpan" id="kobo.295.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">destroy(pointer p)</span></strong><span class="koboSpan" id="kobo.297.1"> functions are respectively meant to construct a copy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">r</span></strong><span class="koboSpan" id="kobo.299.1"> at location </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">p</span></strong><span class="koboSpan" id="kobo.301.1"> (which is assumed to have been allocated beforehand), and destroy the object at location </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">p</span></strong><span class="koboSpan" id="kobo.303.1"> (without deallocating the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">underlying storage):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
   // ...
</span><span class="koboSpan" id="kobo.305.2">   void construct(pointer p, const_reference r) {
      new (static_cast&lt;void*&gt;(p)) value_type(r);
   }
   void destroy(const_pointer p) {
      if(p) p-&gt;~value_type();
   }
   // ...
</span><span class="koboSpan" id="kobo.305.3">   template &lt;class U&gt;
   struct rebind {
      using other = small_allocator&lt;U&gt;;
   };
};</span></pre> <p><span class="koboSpan" id="kobo.306.1">One can expect that most implementations will do essentially what the preceding code does. </span><span class="koboSpan" id="kobo.306.2">There are alternatives, but they are rarely met </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Again, these functions lie to the type system: </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">construct()</span></strong><span class="koboSpan" id="kobo.310.1"> takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">pointer</span></strong><span class="koboSpan" id="kobo.312.1"> (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">T*</span></strong><span class="koboSpan" id="kobo.314.1">, in practice) as argument but when the function is called, that pointer points to raw memory, not to an object of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.318.1">What about rebind?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.319.1">You will notice that we did not</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.320.1"> discuss the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">rebind</span></strong><span class="koboSpan" id="kobo.322.1"> public template type, but that is only because the idea behind this type is easier to understand when facing the kind of problem it is meant to solve. </span><span class="koboSpan" id="kobo.322.2">We will face such a situation when discussing allocator-aware node-based containers through our </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.324.1"> class later in </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Past this point, the</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.327.1"> requirement for an allocator is to define whether two allocator objects of different types are equal or not. </span><span class="koboSpan" id="kobo.327.2">A possible implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
// ...
</span><span class="koboSpan" id="kobo.329.2">template &lt;class T, class U&gt;
constexpr bool operator==(const small_allocator&lt;T&gt;&amp;,
                          const small_allocator&lt;U&gt;&amp;) {
   return true;
}
template &lt;class T, class U&gt;
constexpr bool operator!=(const small_allocator&lt;T&gt;&amp;,
                          const small_allocator&lt;U&gt;&amp;) {
   return false;
}</span></pre> <p><span class="koboSpan" id="kobo.330.1">Expressed otherwise, two </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">small_allocator</span></strong><span class="koboSpan" id="kobo.332.1"> specializations for distinct types describe the same strategy and are thus considered equal. </span><span class="koboSpan" id="kobo.332.2">“But wait!” </span><span class="koboSpan" id="kobo.332.3">you say, “Where do you take into account the state of the allocators in this computation?”. But here’s a revelation: pre-C++11 allocators were essentially assumed to </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">be </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.334.1">stateless</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Well, they were not, but it was unclear what would happen to an allocator if it was associated with a container object and that object was copied. </span><span class="koboSpan" id="kobo.336.2">You see, if an allocator has </span><em class="italic"><span class="koboSpan" id="kobo.337.1">state</span></em><span class="koboSpan" id="kobo.338.1">, we have to know what to do with that state when the allocator is copied. </span><span class="koboSpan" id="kobo.338.2">Is the state copied? </span><span class="koboSpan" id="kobo.338.3">Is it shared? </span><span class="koboSpan" id="kobo.338.4">In the pre-C++11 era, we did not know what to do in such a situation, so unless a container was used in a context where it would not be copied, as in the case of a vector local to a function and associated with an allocator that uses stack space as storage, most people avoided stateful </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">allocators altogether.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.340.1">But what about stateful allocators?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.341.1">As hinted, stateful allocators</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.342.1"> were a possibility back then (they existed, and they were used in practice). </span><span class="koboSpan" id="kobo.342.2">How is one expected to define allocator equality for stateful allocators (and for allocators in general)? </span><span class="koboSpan" id="kobo.342.3">The general idea is that two allocators should compare equally if memory allocated from one can be deallocated from the other. </span><span class="koboSpan" id="kobo.342.4">With an allocator that delegates allocation tasks to free functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.344.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">::operator new()</span></strong><span class="koboSpan" id="kobo.346.1">, equality is trivially </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">true</span></strong><span class="koboSpan" id="kobo.348.1">, but stateful allocators require us to think about how to define </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">this relation.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Before we look at how we could write allocator-aware containers, we will take a step back and see how </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.351.1">we could adapt some of the uninitialized memory algorithms used in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.352.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.353.1"> and </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.354.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.355.1"> to use the services of an allocator. </span><span class="koboSpan" id="kobo.355.2">This will reduce the refactoring effort required later in </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the process.</span></span></p>
<h3><span class="koboSpan" id="kobo.357.1">Some allocator-aware support algorithms</span></h3>
<p><span class="koboSpan" id="kobo.358.1">Since we are using</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.359.1"> allocators to bridge the gap between raw storage and objects, we will not be able to use the raw memory algorithms seen in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.361.1"> and </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.362.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.363.1"> in our </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">allocator-aware implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">We have the option of writing our own versions of these algorithms in detail at each call site within our containers, but that would be tedious (and bug-prone). </span><span class="koboSpan" id="kobo.365.2">Instead, we will write somewhat simplified versions of these low-level memory management algorithms and make these simplified versions use an allocator passed as an argument. </span><span class="koboSpan" id="kobo.365.3">In so doing, we will reduce the impact of making containers allocator-aware on </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">our implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">The first three of these algorithms will be allocator-aware versions of algorithms that initialize a range of values, as well as one that destroys such a range. </span><span class="koboSpan" id="kobo.367.2">To minimize the impact on the existing implementations, we will essentially use the same signature as their non-allocator-aware counterpart, but with an added argument that is a reference to the allocator. </span><span class="koboSpan" id="kobo.367.3">For the algorithm that fills a block of raw memory with some value, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.370.1">class A</span></strong><span class="koboSpan" id="kobo.371.1">, class IIt, class T&gt;
void uninitialized_fill_with_allocator(
   </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">A&amp; alloc</span></strong><span class="koboSpan" id="kobo.373.1">, IIt bd, IIt ed, T init
) {
   // bd: beginning of destination¸
   // ed: end of destination
   auto p = bd;
   try {
      for (; p != ed; ++p)
         </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">alloc.construct(p, init);</span></strong><span class="koboSpan" id="kobo.375.1">
   } catch (...) {
      for (auto q = bd; q != p; ++q)
         </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">alloc.destroy(q);</span></strong><span class="koboSpan" id="kobo.377.1">
      throw;
   }
}</span></pre> <p><span class="koboSpan" id="kobo.378.1">Then, for the algorithm that copies a sequence of values to a block of raw memory, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.381.1">class A</span></strong><span class="koboSpan" id="kobo.382.1">, class IIt, class OIt&gt;
void uninitialized_copy_with_allocator(
   </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">A&amp; alloc</span></strong><span class="koboSpan" id="kobo.384.1">, IIt bs, IIt es, OIt bd
) {
   // bs: beginning of source
   // es: end of source
   // bd: beginning of destination¸
   auto p = bd;
   try {
      for (auto q = bs; q != es; ++q) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">alloc.construct(p, *q);</span></strong><span class="koboSpan" id="kobo.386.1">
         ++p;
      }
   } catch (...) {
      for (auto q = bd; q != p; ++q)
         </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">alloc.destroy(q);</span></strong><span class="koboSpan" id="kobo.388.1">
      throw;
   }
}</span></pre> <p><span class="koboSpan" id="kobo.389.1">For the algorithm</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.390.1"> that moves a sequence of values to a block of raw memory, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.393.1">class A</span></strong><span class="koboSpan" id="kobo.394.1">, class IIt, class OIt&gt;
void uninitialized_move_with_allocator(
   </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">A&amp; alloc</span></strong><span class="koboSpan" id="kobo.396.1">, IIt bs, IIt es, OIt bd
) {
   // bs: beginning of source
   // es: end of source
   // bd: beginning of destination¸
   auto p = bd;
   try {
      for (auto q = bs; q != es; ++q) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">alloc.construct(p, std::move(*q));</span></strong><span class="koboSpan" id="kobo.398.1">
         ++p;
      }
   } catch (...) {
      for (auto q = bd; q != p; ++q)
         </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">alloc.destroy(q);</span></strong><span class="koboSpan" id="kobo.400.1">
      throw;
   }
}</span></pre> <p><span class="koboSpan" id="kobo.401.1">Finally, for the </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.402.1">algorithm that transforms a sequence of objects into a block of raw memory, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.405.1">class A</span></strong><span class="koboSpan" id="kobo.406.1">, class It&gt;
   void destroy_with_allocator(</span><strong class="bold"><span class="koboSpan" id="kobo.407.1">A &amp;alloc</span></strong><span class="koboSpan" id="kobo.408.1">, It b, It e) {
      for (; b != e; ++b)
         </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">alloc.destroy(b);</span></strong><span class="koboSpan" id="kobo.410.1">
   }</span></pre> <p><span class="koboSpan" id="kobo.411.1">Note that in each case, the implementation would be more conformant if, when an exception occurs, objects were destroyed in reverse order of construction. </span><span class="koboSpan" id="kobo.411.2">Feel free to implement this slight adjustment; it’s not difficult but it would introduce some noise in </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">our example.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">The other standard facility we will rewrite is </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">cmp_less()</span></strong><span class="koboSpan" id="kobo.415.1">, which allows comparing a signed value with an unsigned value without getting caught by the integer promotion rules of the C language. </span><span class="koboSpan" id="kobo.415.2">It’s not directly memory-related, but we need it in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.417.1"> implementation, and it’s a C++20 feature, which makes it unavailable when we compile </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">for C++17:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
template&lt;class T, class U&gt;
   constexpr bool cmp_less(T a, U b) noexcept {
      if constexpr (std::is_signed_v&lt;T&gt; ==
                    std::is_signed_v&lt;U&gt;)
         return a &lt; b;
      else if constexpr (std::is_signed_v&lt;T&gt;)
         return a &lt; 0 || std::make_unsigned_t&lt;T&gt;(a) &lt; b;
      else
         return b &gt;= 0 &amp;&amp; a &lt; std::make_unsigned_t&lt;U&gt;(b);
   }</span></pre> <p><span class="koboSpan" id="kobo.420.1">Both</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.421.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">std::is_signed&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.423.1"> trait as well as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">std::make_unsigned&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.425.1"> function can be found in </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">header </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">&lt;type_traits&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.429.1">Conditional compilation and feature test macros</span></p>
<p class="callout"><span class="koboSpan" id="kobo.430.1">As an aside, if you find yourself having to maintain code where a feature such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">std::cmp_less()</span></strong><span class="koboSpan" id="kobo.432.1"> might or might not be available, such as a source file that is sometimes compiled for C++20 and sometimes compiled for C++17, consider conditional inclusion of your “homemade workaround” version by testing the associated feature </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">test macro.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.434.1">For this specific case, one could wrap the definition of our personal version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">cmp_less()</span></strong><span class="koboSpan" id="kobo.436.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">#ifndef __cpp_lib_integer_comparison_functions</span></strong><span class="koboSpan" id="kobo.438.1"> to make sure it is only provided if there is no version provided by one’s standard </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">library implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Now, let’s see how these allocators and our support algorithms can be used by a container, first with </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.441.1">a container that uses contiguous storage (our </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.443.1"> class) and then with a node-based container (our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">ForwardList&lt;T,A&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1"> class).</span></span></p>
<h3><span class="koboSpan" id="kobo.446.1">An allocator-aware Vector&lt;T,A&gt; class</span></h3>
<p><span class="koboSpan" id="kobo.447.1">We are now ready</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.448.1"> to look at how </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.449.1">introducing allocator awareness in a container that uses contiguous memory (more specifically, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.451.1"> class) impacts the implementation of that container. </span><span class="koboSpan" id="kobo.451.2">Note that we will use the explicit memory management approach from </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.452.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.453.1"> as a baseline in this case since we want to explore the impact of allocator awareness and this will help us make the implementation changes more apparent. </span><span class="koboSpan" id="kobo.453.2">Feel free to adapt the code in this chapter with an implicit approach to memory management if you are </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">so inclined.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Starting with the template’s signature itself, we now have a two-type template with </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">T</span></strong><span class="koboSpan" id="kobo.457.1"> being the type of the elements and </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">A</span></strong><span class="koboSpan" id="kobo.459.1"> being the type for the allocator, but with a reasonable default type for </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">A</span></strong><span class="koboSpan" id="kobo.461.1"> such that casual users will not need to worry about such </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">technical details:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
template &lt;class T</span><strong class="bold"><span class="koboSpan" id="kobo.464.1">, class A = std::allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.465.1">&gt;
class Vector </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">: A</span></strong><span class="koboSpan" id="kobo.467.1"> { // note: private inheritance
public:
   using value_type = </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">typename A::value_type</span></strong><span class="koboSpan" id="kobo.469.1">;
   using size_type = </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">typename A::size_type</span></strong><span class="koboSpan" id="kobo.471.1">;
   using pointer = </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">typename A::pointer</span></strong><span class="koboSpan" id="kobo.473.1">;
   using const_pointer = </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">typename A::const_pointer</span></strong><span class="koboSpan" id="kobo.475.1">;
   using reference = </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">typename A::reference</span></strong><span class="koboSpan" id="kobo.477.1">;
   using const_reference = </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">typename A::const_reference</span></strong><span class="koboSpan" id="kobo.479.1">;
private:
</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">   // deliberately self-exposing selected members</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.481.1">   // of the private base class as our own</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.482.1">   using A::allocate;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.483.1">   using A::deallocate;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.484.1">   using A::construct;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.485.1">   using A::destroy;</span></strong><span class="koboSpan" id="kobo.486.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.487.1">Note some </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">techniques here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.489.1">Since we expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">A</span></strong><span class="koboSpan" id="kobo.491.1"> to be stateless, we used private inheritance and made </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">A</span></strong><span class="koboSpan" id="kobo.493.1"> a base class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.495.1">, enabling the empty base optimization. </span><span class="koboSpan" id="kobo.495.2">Alternatively, we could also have used a data member of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">A</span></strong><span class="koboSpan" id="kobo.497.1"> inside each </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.499.1"> object (perhaps incurring a small </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">size penalty).</span></span></li>
<li><span class="koboSpan" id="kobo.501.1">We deduced the</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.502.1"> type </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.503.1">aliases of the container from those of its allocator. </span><span class="koboSpan" id="kobo.503.2">This probably changes nothing in practice with respect to the aliases we used in previous chapters, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">A</span></strong><span class="koboSpan" id="kobo.505.1"> might be doing some “fancy tricks” (one can never be </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">too careful).</span></span></li>
<li><span class="koboSpan" id="kobo.507.1">In a private section of our class, we expose some selected members of our base class as our own. </span><span class="koboSpan" id="kobo.507.2">This will make the code less verbose later on, allowing us to write </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">allocate(n)</span></strong><span class="koboSpan" id="kobo.509.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">this-&gt;A::allocate(n)</span></strong><span class="koboSpan" id="kobo.511.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">for example.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.513.1">The non-allocating members of our class do not change, unsurprisingly. </span><span class="koboSpan" id="kobo.513.2">Data members stay the same, and so do basic accessors such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">size()</span></strong><span class="koboSpan" id="kobo.515.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">empty()</span></strong><span class="koboSpan" id="kobo.517.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">begin()</span></strong><span class="koboSpan" id="kobo.519.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">end()</span></strong><span class="koboSpan" id="kobo.521.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">front()</span></strong><span class="koboSpan" id="kobo.523.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">operator[]</span></strong><span class="koboSpan" id="kobo.525.1">, and so on. </span><span class="koboSpan" id="kobo.525.2">Even the default constructor remains unchanged since it does not allocate memory and so does not need to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">its allocator.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">There is a new constructor needed, one that accepts as argument an allocator. </span><span class="koboSpan" id="kobo.527.2">This one is particularly useful in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">stateful allocators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
   // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.530.1">   Vector(A &amp;alloc) : A{ alloc } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.531.1">   }</span></strong><span class="koboSpan" id="kobo.532.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.533.1">Of course, when reaching the constructors that do need to allocate memory, the situation becomes more interesting. </span><span class="koboSpan" id="kobo.533.2">Take, for example, the constructor that takes as argument a number </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.534.1">of elements </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.535.1">and an </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">initial value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
   // ...
</span><span class="koboSpan" id="kobo.537.2">   Vector(size_type n, const_reference init)
      : </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">A{}</span></strong><span class="koboSpan" id="kobo.539.1">,</span><strong class="bold"><span class="koboSpan" id="kobo.540.1">elems{ allocate(n) }</span></strong><span class="koboSpan" id="kobo.541.1">,
        nelems{ n }, cap{ n } {
      try {
         </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">uninitialized_fill_with_allocator</span></strong><span class="koboSpan" id="kobo.543.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.545.1">, begin(), end(), init
         );
      } catch (...) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">deallocate(elems, capacity());</span></strong><span class="koboSpan" id="kobo.547.1">
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.548.1">There is a lot to </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">say here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.550.1">The memory block that will serve as the underlying storage for our container is allocated through a call to our base class’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">allocate()</span></strong><span class="koboSpan" id="kobo.552.1"> member function. </span><span class="koboSpan" id="kobo.552.2">Remember that even though this yields a </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">pointer</span></strong><span class="koboSpan" id="kobo.554.1"> (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">T*</span></strong><span class="koboSpan" id="kobo.556.1">), that is a lie and there are no </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">T</span></strong><span class="koboSpan" id="kobo.558.1"> objects in the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">allocated block.</span></span></li>
<li><span class="koboSpan" id="kobo.560.1">We fill that uninitialized memory block with </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">T</span></strong><span class="koboSpan" id="kobo.562.1"> objects through our homemade allocator-aware version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">std::uninitialized_fill()</span></strong><span class="koboSpan" id="kobo.564.1"> (see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">_with_allocator</span></strong><span class="koboSpan" id="kobo.566.1"> suffix). </span><span class="koboSpan" id="kobo.566.2">Note how we pass the allocator as an argument to the algorithm: the inheritance relationship between </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.568.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">A</span></strong><span class="koboSpan" id="kobo.570.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">private</span></strong><span class="koboSpan" id="kobo.572.1">, but the derived class is aware of it and can use that information </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">through </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">static_cast</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.576.1">If one of the constructors used in the process of initializing that memory block throws, the algorithm destroys the objects it had created, as usual (no one else really could do it anyway), after which we intercept that exception and deallocate the storage before re-throwing said exception in the interest of </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">exception neutrality.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.578.1">Similar maneuvers are used in other allocating constructors, with different algorithms used to initialize the allocated storage. </span><span class="koboSpan" id="kobo.578.2">The move constructor and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">swap()</span></strong><span class="koboSpan" id="kobo.580.1"> member function do not allocate memory and, for that reason, remain unchanged, and the same goes for the assignment operators: they are built from other member functions and do not need to allocate or deallocate memory </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">by themselves.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">As you probably</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.583.1"> suspected </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.584.1">already, the destructor of our container will use the allocator to destroy the objects and deallocate the </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">underlying storage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
   // ...
</span><span class="koboSpan" id="kobo.586.2">   ~Vector() {
      </span><strong class="bold"><span class="koboSpan" id="kobo.587.1">destroy_with_allocator</span></strong><span class="koboSpan" id="kobo.588.1">(
         </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.590.1">, begin(), end()
      );
      </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">deallocate(elems, capacity());</span></strong><span class="koboSpan" id="kobo.592.1">
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.593.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">push_back()</span></strong><span class="koboSpan" id="kobo.595.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">emplace_back()</span></strong><span class="koboSpan" id="kobo.597.1"> member functions do not allocate by themselves, delegating to our private </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">grow()</span></strong><span class="koboSpan" id="kobo.599.1"> member function, which, in turn, delegates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">reserve()</span></strong><span class="koboSpan" id="kobo.601.1"> for the allocation, but they do need to </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">construct()</span></strong><span class="koboSpan" id="kobo.603.1"> an object at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">the container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
   // ...
</span><span class="koboSpan" id="kobo.605.2">   void push_back(const_reference val) {
      if (full()) grow();
      </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">construct(end(), val);</span></strong><span class="koboSpan" id="kobo.607.1">
      ++nelems;
   }
   void push_back(T&amp;&amp; val) {
      if (full()) grow();
      </span><strong class="bold"><span class="koboSpan" id="kobo.608.1">construct(end(), std::move(val));</span></strong><span class="koboSpan" id="kobo.609.1">
      ++nelems;
   }
   template &lt;class ... </span><span class="koboSpan" id="kobo.609.2">Args&gt;
   reference emplace_back(Args &amp;&amp;...args) {
      if (full()) grow();
      </span><strong class="bold"><span class="koboSpan" id="kobo.610.1">construct(end(), std::forward&lt;Args&gt;(args)...);</span></strong><span class="koboSpan" id="kobo.611.1">
      ++nelems;
      return back();
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.612.1">The principal</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.613.1"> tools for</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.614.1"> memory allocation in our class are probably </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">reserve()</span></strong><span class="koboSpan" id="kobo.616.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">resize()</span></strong><span class="koboSpan" id="kobo.618.1">. </span><span class="koboSpan" id="kobo.618.2">In both cases, the algorithm remains as it was, but the low-level memory management tasks are delegated to the allocator. </span><span class="koboSpan" id="kobo.618.3">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">reserve()</span></strong><span class="koboSpan" id="kobo.620.1">, this leads us to </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
   // ...
</span><span class="koboSpan" id="kobo.622.2">   void reserve(size_type new_cap) {
      if (new_cap &lt;= capacity()) return;
      </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">auto p = allocate(new_cap);</span></strong><span class="koboSpan" id="kobo.624.1">
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">uninitialized_move_with_allocator</span></strong><span class="koboSpan" id="kobo.626.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.628.1">, begin(), end(), p
         );
      } else {
         auto src_p = begin();
         auto b = p, e = p + size();
         try {
            </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">uninitialized_copy_with_allocator</span></strong><span class="koboSpan" id="kobo.630.1">(
               </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.632.1">, begin(), end(), p
            );
         } catch (...) {
            </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">deallocate(p, new_cap);</span></strong><span class="koboSpan" id="kobo.634.1">
            throw;
         }
      }
      </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">deallocate(elems, capacity());</span></strong><span class="koboSpan" id="kobo.636.1">
      elems = p;
      cap = new_cap;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.637.1">Whereas, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">resize()</span></strong><span class="koboSpan" id="kobo.639.1">, we now </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.640.1">have </span><a id="_idIndexMarker800"/><span class="No-Break"><span class="koboSpan" id="kobo.641.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
   // ...
</span><span class="koboSpan" id="kobo.642.2">   void resize(size_type new_cap) {
      if (new_cap &lt;= capacity()) return;
      auto p = </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">allocate(new_cap)</span></strong><span class="koboSpan" id="kobo.644.1">;
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">uninitialized_move_with_allocator</span></strong><span class="koboSpan" id="kobo.646.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.647.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.648.1">, begin(), end(), p
         );
      } else {
         </span><strong class="bold"><span class="koboSpan" id="kobo.649.1">uninitialized_copy_with_allocator</span></strong><span class="koboSpan" id="kobo.650.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.652.1">, begin(), end(), p
         );
      }
      try {
         </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">uninitialized_fill_with_allocator</span></strong><span class="koboSpan" id="kobo.654.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.656.1">,
            p + size(), p + new_cap, value_type{}
         );
         </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">destroy_with_allocator</span></strong><span class="koboSpan" id="kobo.658.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.660.1">, begin(), end()
         );
         </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">deallocate(elems, capacity())</span></strong><span class="koboSpan" id="kobo.662.1">;
         elems = p;
         nelems = cap = new_cap;
      } catch(...) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">destroy_with_allocator</span></strong><span class="koboSpan" id="kobo.664.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.666.1">, p, p + size()
         );
         </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">deallocate(p, new_cap)</span></strong><span class="koboSpan" id="kobo.668.1">;
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.669.1">In previous implementations of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.671.1"> class, we had implemented one version each of </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">insert()</span></strong><span class="koboSpan" id="kobo.673.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">erase()</span></strong><span class="koboSpan" id="kobo.675.1">, as implementing the whole set of these functions would make this book unreasonably large. </span><span class="koboSpan" id="kobo.675.2">Since both functions meddle with initialized and uninitialized memory, they need to be adapted to use the services of the allocator rather than doing their own </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">memory management.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">insert()</span></strong><span class="koboSpan" id="kobo.679.1">, the key aspects of the function that need to be adjusted are those that</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.680.1"> copy or move</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.681.1"> objects into </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">raw memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.683.1">
   // ...
</span><span class="koboSpan" id="kobo.683.2">   template &lt;class It&gt;
   iterator insert(const_iterator pos, It first, It last) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      const auto remaining = capacity() - size();
      const auto n = std::distance(first, last);
</span><strong class="bold"><span class="koboSpan" id="kobo.684.1">//      if (std::cmp_less(remaining, n)) { // needs C++20</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.685.1">      if(cmp_less(remaining, n)) {</span></strong><span class="koboSpan" id="kobo.686.1">
         auto index = std::distance(begin(), pos_);
         reserve(capacity() + n - remaining);
         pos_ = std::next(begin(), index);
      }
      const auto nb_to_uninit_displace =
         std::min&lt;std::ptrdiff_t&gt;(n, end() - pos_);
      auto where_to_uninit_displace =
         end() + n - nb_to_uninit_displace;
      if constexpr (
         std::is_nothrow_move_constructible_v&lt;T&gt;
      )
         </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">uninitialized_move_with_allocator</span></strong><span class="koboSpan" id="kobo.688.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.690.1">,
            end() - nb_to_uninit_displace, end(),
            where_to_uninit_displace
         );
      else
         </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">uninitialized_copy_with_allocator</span></strong><span class="koboSpan" id="kobo.692.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.694.1">,
            end() - nb_to_uninit_displace, end(),
            where_to_uninit_displace
         );
      // note : might be zero
      const auto nb_to_uninit_insert =
         std::max&lt;std::ptrdiff_t&gt;(
            0, n - nb_to_uninit_displace
         );
      auto where_to_uninit_insert = end();
      </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">uninitialized_copy_with_allocator</span></strong><span class="koboSpan" id="kobo.696.1">(
         </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">*static_cast&lt;A*&gt;(this)</span></strong><span class="koboSpan" id="kobo.698.1">,
         last - nb_to_uninit_insert, last,
         where_to_uninit_insert
      );
      // note : might be zero
      const auto nb_to_backward_displace =
         std::max&lt;std::ptrdiff_t&gt;(
            0, end() - pos_ - nb_to_uninit_displace
         );
      auto where_to_backward_displace = end();
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;)
         std::move_backward(
            pos_, pos_ + nb_to_backward_displace,
            where_to_backward_displace
         );
      else
         std::copy_backward(
            pos_, pos_ + nb_to_backward_displace,
            where_to_backward_displace
         );
      std::copy(
         first, first + n - nb_to_uninit_insert, pos_
      );
      nelems += n;
      return pos_;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.699.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">erase()</span></strong><span class="koboSpan" id="kobo.701.1">, what</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.702.1"> we </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.703.1">do is copy all objects after the erased one “to the left” by one position; the object at the end of the sequence after this copying has been performed has to be destroyed, and for this, we need to use the allocator’s services. </span><span class="koboSpan" id="kobo.703.2">An </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">example follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
   // ...
</span><span class="koboSpan" id="kobo.705.2">   iterator erase(const_iterator pos) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      if (pos_ == end()) return pos_;
      std::copy(std::next(pos_), end(), pos_);
      </span><strong class="bold"><span class="koboSpan" id="kobo.706.1">destroy(std::prev(end()));</span></strong><span class="koboSpan" id="kobo.707.1">
      --nelems;
      return pos_;
   }
};</span></pre> <p><span class="koboSpan" id="kobo.708.1">As you have probably gathered at this point, we could optimize or simplify these functions in </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.709.1">numerous</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.710.1"> ways, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.712.1">There is a common core functionality between </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">reserve()</span></strong><span class="koboSpan" id="kobo.714.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">resize()</span></strong><span class="koboSpan" id="kobo.716.1">, so we could essentially claim that </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">resize()</span></strong><span class="koboSpan" id="kobo.718.1"> is in large part like </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">reserve()</span></strong><span class="koboSpan" id="kobo.720.1"> followed by an uninitialized fill and express it </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">as such.</span></span></li>
<li><span class="koboSpan" id="kobo.722.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">erase()</span></strong><span class="koboSpan" id="kobo.724.1">, at compile time, we could test the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">std::is_nothrow_move_assignable_v&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.726.1"> trait and, if that condition holds, replace the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">std::copy()</span></strong><span class="koboSpan" id="kobo.728.1"> with a call </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">std::move()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.732.1">We could make </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">insert()</span></strong><span class="koboSpan" id="kobo.734.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">erase()</span></strong><span class="koboSpan" id="kobo.736.1"> more exception-safe than they are, although this would make the code a bit long for a book such as </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">this one.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.738.1">At this point, we have an allocator-aware container that manages contiguous memory. </span><span class="koboSpan" id="kobo.738.2">It will now be interesting to see what the impacts of allocator awareness will be on a node-based container, something we will address through an allocator-aware version of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">ForwardList&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.740.1"> class.</span></span></p>
<h3><span class="koboSpan" id="kobo.741.1">An allocator-aware ForwardList&lt;T,A&gt; class</span></h3>
<p><span class="koboSpan" id="kobo.742.1">A funny thing </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.743.1">happens when writing allocator-aware node-based containers. </span><span class="koboSpan" id="kobo.743.2">Pay attention to the beginning of our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">ForwardList&lt;T,A&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.746.1">
template &lt;class T</span><strong class="bold"><span class="koboSpan" id="kobo.747.1">, class A = std::allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.748.1">&gt;
class ForwardList {
public:
</span><strong class="bold"><span class="koboSpan" id="kobo.749.1">   using value_type = typename A::value_type;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.750.1">   // likewise for the other aliases</span></strong><span class="koboSpan" id="kobo.751.1">
private:
</span><strong class="bold"><span class="koboSpan" id="kobo.752.1">   struct Node {</span></strong><span class="koboSpan" id="kobo.753.1">
      value_type value;
      Node *next = nullptr;
      Node(const_reference value) : value { value } {
      }
      Node(value_type &amp;&amp;value)
         : value { std::move(value) } {
      }
   };
</span><strong class="bold"><span class="koboSpan" id="kobo.754.1">   Node *head {};</span></strong><span class="koboSpan" id="kobo.755.1">
   size_type nelems {};
   // ...</span></pre> <p><span class="koboSpan" id="kobo.756.1">Did you notice</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.757.1"> something interesting about type </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">A</span></strong><span class="koboSpan" id="kobo.759.1">? </span><span class="koboSpan" id="kobo.759.2">Think </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">about it…</span></span></p>
<p><span class="koboSpan" id="kobo.761.1">Yes, that’s it: </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">A</span></strong> <em class="italic"><span class="koboSpan" id="kobo.763.1">is the wrong type</span></em><span class="koboSpan" id="kobo.764.1">! </span><span class="koboSpan" id="kobo.764.2">A node-based container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.766.1"> never allocates objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">T</span></strong><span class="koboSpan" id="kobo.768.1">: it allocates </span><em class="italic"><span class="koboSpan" id="kobo.769.1">nodes</span></em><span class="koboSpan" id="kobo.770.1"> that (most probably) contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">T</span></strong><span class="koboSpan" id="kobo.772.1"> objects and other things such as, in this case, a pointer to the next </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">Node</span></strong><span class="koboSpan" id="kobo.774.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">the sequence.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">Knowing this, if we were supplied some allocator </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">A</span></strong><span class="koboSpan" id="kobo.778.1"> that modeled a size-aware allocation strategy akin to what we used in our arena for </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">Orc</span></strong><span class="koboSpan" id="kobo.780.1"> objects in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.781.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.782.1">, making the allocator aware of </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">T</span></strong><span class="koboSpan" id="kobo.784.1"> (and thus, of </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">sizeof(T)</span></strong><span class="koboSpan" id="kobo.786.1">) would lead to an arena that manages objects of the wrong size. </span><span class="koboSpan" id="kobo.786.2">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">not good!</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">We are faced with an interesting conundrum: user code provides us with an allocator because it wants our container to put an </span><em class="italic"><span class="koboSpan" id="kobo.789.1">allocation strategy</span></em><span class="koboSpan" id="kobo.790.1"> to good use. </span><span class="koboSpan" id="kobo.790.2">That allocation strategy appears as a template parameter of our container, which is why it is associated with the type of its elements (we do not know what the nodes will be at this point in the definition of our container class). </span><span class="koboSpan" id="kobo.790.3">Only later, when we have defined what a node will be for our container, are we really ready to say what will need to be allocated, but then </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">A</span></strong><span class="koboSpan" id="kobo.792.1"> already exists and is already associated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">T</span></strong><span class="koboSpan" id="kobo.794.1">, not to the type we really need, which </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">ForwardList&lt;T,A&gt;::Node</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">Note that we have instantiated type </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">A</span></strong><span class="koboSpan" id="kobo.800.1"> but have not constructed any object of that type. </span><span class="koboSpan" id="kobo.800.2">Lucky for us, as that would have been wasteful (we would never use it!). </span><span class="koboSpan" id="kobo.800.3">What we do need is a type that is just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">A</span></strong><span class="koboSpan" id="kobo.802.1">, but able to allocate objects of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">Node</span></strong><span class="koboSpan" id="kobo.804.1"> type instead of objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">T</span></strong><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">We need a way to </span><em class="italic"><span class="koboSpan" id="kobo.807.1">clone the allocation strategy</span></em><span class="koboSpan" id="kobo.808.1"> described by </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">A</span></strong><span class="koboSpan" id="kobo.810.1"> and apply it to </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">another type.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">This is exactly what </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">rebind</span></strong><span class="koboSpan" id="kobo.814.1"> is for. </span><span class="koboSpan" id="kobo.814.2">Remember that we mentioned this template type when writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.816.1"> earlier but said we would return to it when we could put it to good use? </span><span class="koboSpan" id="kobo.816.2">There we are, dear reader. </span><span class="koboSpan" id="kobo.816.3">As a reminder, in the context of an allocator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">rebind</span></strong><span class="koboSpan" id="kobo.818.1"> presents</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.819.1"> itself</span><a id="_idIndexMarker810"/> <span class="No-Break"><span class="koboSpan" id="kobo.820.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">
template &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.822.1">class T</span></strong><span class="koboSpan" id="kobo.823.1">&gt;
   class </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">small_allocator</span></strong><span class="koboSpan" id="kobo.825.1"> { // for example
   // ...
</span><strong class="bold"><span class="koboSpan" id="kobo.826.1">   template &lt;class U&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.827.1">      struct rebind {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.828.1">         using other = small_allocator&lt;U&gt;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.829.1">      };</span></strong><span class="koboSpan" id="kobo.830.1">
   // ...
</span><span class="koboSpan" id="kobo.830.2">};</span></pre> <p><span class="koboSpan" id="kobo.831.1">You can see </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">rebind</span></strong><span class="koboSpan" id="kobo.833.1"> as some kind of weird code poetry: it is a way for the allocator to say “If you want the same type as myself but applied to some </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">U</span></strong><span class="koboSpan" id="kobo.835.1"> type instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">T</span></strong><span class="koboSpan" id="kobo.837.1">, here’s what that type </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">would be.”</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">Returning to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.841.1"> class, now that we know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">rebind</span></strong><span class="koboSpan" id="kobo.843.1"> is for, we can create our own internal allocator type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Alloc</span></strong><span class="koboSpan" id="kobo.845.1">. </span><span class="koboSpan" id="kobo.845.2">This will be “like the allocator type </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">A</span></strong><span class="koboSpan" id="kobo.847.1"> but applied to </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Node</span></strong><span class="koboSpan" id="kobo.849.1">, not to </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">T</span></strong><span class="koboSpan" id="kobo.851.1">” and create an object of that type (incidentally named </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">alloc</span></strong><span class="koboSpan" id="kobo.853.1"> in our implementation), which we will use to perform the memory management tasks in </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">our container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">
   // ...
</span><span class="koboSpan" id="kobo.855.2">   </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">using Alloc = typename A::rebind&lt;Node&gt;::other;</span></strong><span class="koboSpan" id="kobo.857.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">Alloc alloc;</span></strong><span class="koboSpan" id="kobo.859.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.860.1">It’s a nice trick, isn’t it? </span><span class="koboSpan" id="kobo.860.2">Remember that we cloned the </span><em class="italic"><span class="koboSpan" id="kobo.861.1">strategy</span></em><span class="koboSpan" id="kobo.862.1">, the type, not an actual object so any state some hypothetical </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">A</span></strong><span class="koboSpan" id="kobo.864.1"> object would have had would not necessarily be part of our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">Alloc</span></strong><span class="koboSpan" id="kobo.866.1"> type (at least not without performing some non-trivial acrobatics). </span><span class="koboSpan" id="kobo.866.2">This is yet another reminder that with traditional allocators as they were originally designed, copying and moving allocator state was a </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">complex problem.</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">As was the case for the transformation from </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.870.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.872.1">, a significant portion of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">List&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.874.1"> implementation involved no memory allocation and thus needs not change with </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">List&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.876.1">. </span><span class="koboSpan" id="kobo.876.2">This includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">size()</span></strong><span class="koboSpan" id="kobo.878.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">empty()</span></strong><span class="koboSpan" id="kobo.880.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">begin()</span></strong><span class="koboSpan" id="kobo.882.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">end()</span></strong><span class="koboSpan" id="kobo.884.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">swap()</span></strong><span class="koboSpan" id="kobo.886.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">front()</span></strong><span class="koboSpan" id="kobo.888.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">operator==()</span></strong><span class="koboSpan" id="kobo.890.1"> member functions, among others, as well as most of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">List&lt;T,A&gt;::Iterator&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.892.1"> class definition. </span><span class="koboSpan" id="kobo.892.2">As our implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.894.1"> will need to access private data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">cur</span></strong><span class="koboSpan" id="kobo.896.1"> of its</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.897.1"> iterators on </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.898.1">occasion, we give it </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">friend</span></strong><span class="koboSpan" id="kobo.900.1"> privileges </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">over </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">Iterator&lt;U&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
   // ...
</span><span class="koboSpan" id="kobo.904.2">   template &lt;class U&gt; class Iterator {
      // ...
</span><span class="koboSpan" id="kobo.904.3">   private:
      Node *cur {};
      </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">friend class ForwardList&lt;T,A&gt;;</span></strong><span class="koboSpan" id="kobo.906.1">
      // ...
</span><span class="koboSpan" id="kobo.906.2">   };
   // ...</span></pre> <p><span class="koboSpan" id="kobo.907.1">There are, of course, member functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.909.1"> that use memory allocation mechanisms. </span><span class="koboSpan" id="kobo.909.2">One of them is </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">clear()</span></strong><span class="koboSpan" id="kobo.911.1">, whose role is to destroy the nodes in the container. </span><span class="koboSpan" id="kobo.911.2">The destruction and deallocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">Node</span></strong><span class="koboSpan" id="kobo.913.1"> objects have to be performed through the allocator, replacing the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">operator delete()</span></strong><span class="koboSpan" id="kobo.915.1"> with a pair of </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">function calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
   // ...
</span><span class="koboSpan" id="kobo.917.2">   void clear() noexcept {
      for(auto p = head; p; ) {
         auto q = p-&gt;next;
</span><strong class="bold"><span class="koboSpan" id="kobo.918.1">         alloc.destroy(p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.919.1">         alloc.deallocate(p, 1);</span></strong><span class="koboSpan" id="kobo.920.1">
         p = q;
      }
      nelems = 0;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.921.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.923.1">, we made all of the allocating constructors converge toward a single sequence constructor that accepted a pair of iterators (type </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">It</span></strong><span class="koboSpan" id="kobo.925.1">) as arguments. </span><span class="koboSpan" id="kobo.925.2">This localizes the changes required for constructors in </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.927.1"> to that single function, something </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.928.1">that </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.929.1">simplifies </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">our task.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.933.1">, we had constrained template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">It</span></strong><span class="koboSpan" id="kobo.935.1"> by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">std::forward_iterator</span></strong><span class="koboSpan" id="kobo.937.1"> concept, but concepts are a C++20 feature and we are compiling this implementation in C++17 so we will (sadly) let go of this constraint for the </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">time being.</span></span></p>
<p><span class="koboSpan" id="kobo.939.1">Having to perform allocation and construction in separate steps complicates our implementation a little, but I think you esteemed readers, will not find this to </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">be unsurmountable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.941.1">
   // ...
</span><span class="koboSpan" id="kobo.941.2">   </span><strong class="bold"><span class="koboSpan" id="kobo.942.1">template &lt;class It&gt; // &lt;std::forward_iterator It&gt;</span></strong><span class="koboSpan" id="kobo.943.1">
      ForwardList(It b, It e) {
         if(b == e) return;
         try {
</span><strong class="bold"><span class="koboSpan" id="kobo.944.1">            head = alloc.allocate(1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.945.1">            alloc.construct(head, *b);</span></strong><span class="koboSpan" id="kobo.946.1">
            auto q = head;
            ++nelems;
            for(++b; b != e; ++b) {
</span><strong class="bold"><span class="koboSpan" id="kobo.947.1">               auto ptr = alloc.allocate(1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.948.1">               alloc.construct(ptr, *b);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.949.1">               q-&gt;next = ptr;</span></strong><span class="koboSpan" id="kobo.950.1">
               q = q-&gt;next;
               ++nelems;
            }
         } catch (...) {
            clear();
            throw;
         }
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.951.1">We also had </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.952.1">written</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.953.1"> insertion member functions for </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.955.1">, so these will also need to be adapted to use allocators in </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.957.1">. </span><span class="koboSpan" id="kobo.957.2">We had two overloads </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">push_front()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.961.1">
   // ...
</span><span class="koboSpan" id="kobo.961.2">   void push_front(const_reference val) {
</span><strong class="bold"><span class="koboSpan" id="kobo.962.1">      auto p = alloc.allocate(1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.963.1">      alloc.construct(p, val);</span></strong><span class="koboSpan" id="kobo.964.1">
      p-&gt;next = head;
      head = p;
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
</span><strong class="bold"><span class="koboSpan" id="kobo.965.1">      auto p = alloc.allocate(1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.966.1">      alloc.construct(p, std::move(val));</span></strong><span class="koboSpan" id="kobo.967.1">
      p-&gt;next = head;
      head = p;
      ++nelems;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.968.1">We also had two overloads of </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">insert_after()</span></strong><span class="koboSpan" id="kobo.970.1">, one that inserted a single value and one that inserted </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.971.1">the elements</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.972.1"> in a half-open range. </span><span class="koboSpan" id="kobo.972.2">In the latter case, we will need to put aside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">std::forward_iterator</span></strong><span class="koboSpan" id="kobo.974.1"> constraint on type </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">It</span></strong><span class="koboSpan" id="kobo.976.1"> again as we are compiling </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">for C++17:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
   // ...
</span><span class="koboSpan" id="kobo.978.2">   iterator
      insert_after(iterator pos, const_reference value) {
</span><strong class="bold"><span class="koboSpan" id="kobo.979.1">      auto p = alloc.allocate(1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.980.1">      alloc.construct(p, value);</span></strong><span class="koboSpan" id="kobo.981.1">
      p-&gt;next = pos.cur-&gt;next;
      pos.cur-&gt;next = p;
      ++nelems;
      return { p };
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.982.1">   template &lt;class It&gt; // &lt;std::input_iterator It&gt;</span></strong><span class="koboSpan" id="kobo.983.1">
      iterator insert_after(iterator pos, It b, It e) {
         for(; b != e; ++b)
            pos = insert_after(pos, *b);
         return pos;
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.984.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">erase_after()</span></strong><span class="koboSpan" id="kobo.986.1"> member function is </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">similarly adjusted:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.988.1">
   // ...
</span><span class="koboSpan" id="kobo.988.2">   iterator erase_after(iterator pos) {
      if (pos == end() || std::next(pos) == end())
         return end();
      auto p = pos.cur-&gt;next-&gt;next;
</span><strong class="bold"><span class="koboSpan" id="kobo.989.1">      alloc.destroy(pos.cur-&gt;next);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.990.1">      alloc.deallocate(pos.cur-&gt;next, 1);</span></strong><span class="koboSpan" id="kobo.991.1">
      --nelems;
      pos.cur-&gt;next = p;
      return { p-&gt;next };
   }
};</span></pre> <p><span class="koboSpan" id="kobo.992.1">That concludes our</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.993.1"> transformation</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.994.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.996.1"> into an allocator-aware </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.998.1"> class. </span><span class="koboSpan" id="kobo.998.2">I hope, dear reader, that this was not as difficult as some might have feared: given our understanding of the principles and fundamental techniques presented in this book, integrating allocator awareness in a container should make some sort of sense to most of us at </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">this point.</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">Now that we have seen how to write a “traditional” iterator as well as examples of how one can make a</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.1001.1"> container</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.1002.1"> allocator-aware, you might be wondering about the benefits of using allocators. </span><span class="koboSpan" id="kobo.1002.2">We know that allocators give use code control over the ways in which containers manage memory, but what can we gain from </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">that control?</span></span></p>
<h3><span class="koboSpan" id="kobo.1004.1">Example usage – a sequential buffer allocator</span></h3>
<p><span class="koboSpan" id="kobo.1005.1">A classical example of allocator usage is </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.1006.1">one that, instead</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.1007.1"> of allocating memory from the free store, manages a pre-allocated chunk of memory. </span><span class="koboSpan" id="kobo.1007.2">That memory does not have to come from the execution stack of a thread, but that’s often what is done in practice, so that’s what our example code </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">will do.</span></span></p>
<p><span class="koboSpan" id="kobo.1009.1">What you need to know before reading the following example </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">is this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1011.1">This sort of allocator is a specialized tool for specialized users. </span><span class="koboSpan" id="kobo.1011.2">We expect users to know what they </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">are doing.</span></span></li>
<li><span class="koboSpan" id="kobo.1013.1">The pre-allocated buffer that will be managed by the allocator in our example has to be properly aligned for the objects that will be stored therein. </span><span class="koboSpan" id="kobo.1013.2">If you want to adapt this example to handle memory allocation for any naturally aligned object, some additional effort will be required (you will want the allocator to yield addresses aligned on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.1015.1"> boundary, something our example allocator does </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">not do).</span></span></li>
<li><span class="koboSpan" id="kobo.1017.1">Some care will need to be taken if client code tries to “,over-allocate,” asking for more memory than what the managed buffer could provide. </span><span class="koboSpan" id="kobo.1017.2">In this example, we will throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.1019.1"> as usual, but </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">alternatives exist.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1021.1">When bad_alloc is not an option…</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1022.1">For some applications, throwing or otherwise failing to allocate is not an option. </span><span class="koboSpan" id="kobo.1022.2">The fact that a specialized allocator cannot meet an allocation request should not, for these applications, result in throwing an exception as throwing means “I cannot meet the postconditions of </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">this function.”</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1024.1">One thing that some applications do when a sequential buffer allocator runs out of memory is simply call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">::operator new()</span></strong><span class="koboSpan" id="kobo.1026.1"> and take the indeterministic allocation time “hit” but leave a trace somewhere (a log, maybe) that this happened. </span><span class="koboSpan" id="kobo.1026.2">This means the program will leak memory, but for some applications (say, a stock market exchange program that is restarted every day), one can expect those leaks to be relatively low in number, and the fact that there is a trace that something leaked will let programmers look at the problem and (hopefully) fix it before the next day. </span><span class="koboSpan" id="kobo.1026.3">The “lesser of two evils,” as some </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">might say.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">Our sequential </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.1029.1">buffer allocator</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.1030.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
#include &lt;cstdint&gt;
template &lt;class T&gt;
struct seq_buf_allocator {
   using value_type = T;
   // pointer, reference and other aliases are as
   // usual, and so is max_size()
</span><strong class="bold"><span class="koboSpan" id="kobo.1033.1">private:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1034.1">   char *buf;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1035.1">   pointer cur;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1036.1">   size_type cap;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1037.1">public:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1038.1">   seq_buf_allocator(char *buf, size_type cap) noexcept</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1039.1">      : buf{ buf }, cap{ cap } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1040.1">      cur = reinterpret_cast&lt;pointer&gt;(buf);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1041.1">   }</span></strong><span class="koboSpan" id="kobo.1042.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1043.1">As you can see, the state for this allocator resembles what we did for the size-based arena in </span><a href="B21071_10.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1044.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.1045.1">: we know where the buffer to manage starts (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">buf</span></strong><span class="koboSpan" id="kobo.1047.1">), how big it is (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">cap</span></strong><span class="koboSpan" id="kobo.1049.1">), and where we are at in our sequential allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">process (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">cur</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1053.1">We make </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">cur</span></strong><span class="koboSpan" id="kobo.1055.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">pointer</span></strong><span class="koboSpan" id="kobo.1057.1">-type object to simplify computation later, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">allocate()</span></strong><span class="koboSpan" id="kobo.1059.1">member function, but it’s a convenience, not </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">a necessity.</span></span></p>
<p><span class="koboSpan" id="kobo.1061.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">allocate()</span></strong><span class="koboSpan" id="kobo.1063.1"> member function is very simple in the sense that it performs a constant-time computation, returning contiguously allocated objects from the underlying storage without even having to reuse that memory after it has been deallocated. </span><span class="koboSpan" id="kobo.1063.2">Part of the work done in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">allocate()</span></strong><span class="koboSpan" id="kobo.1065.1"> requires avoiding over-allocating, and to do this, we will compare pointers, but we might have to compare a pointer within the allocated memory block with one that is not within that block (it all depends on the value of our arguments). </span><span class="koboSpan" id="kobo.1065.2">This would lead us into undefined behavior, something we need to avoid, so </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.1066.1">we cast our</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.1067.1"> pointers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">std::intptr_t</span></strong><span class="koboSpan" id="kobo.1069.1"> objects and compare the resulting integral </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">values instead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1071.1">What if std::intptr_t is not offered on my platform?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1072.1">Types </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">std::intptr_t</span></strong><span class="koboSpan" id="kobo.1074.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">std::uintptr_t</span></strong><span class="koboSpan" id="kobo.1076.1"> are conditionally supported in C++, which means that there might be vendors that do not offer these type aliases. </span><span class="koboSpan" id="kobo.1076.2">If you find yourself in this unlikely but not impossible situation, you can simply keep track of the number of objects allocated and compare this with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">cap</span></strong><span class="koboSpan" id="kobo.1078.1"> data member to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">same effect.</span></span></p>
<p><span class="koboSpan" id="kobo.1080.1">We end up with the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">allocate()</span></strong><span class="koboSpan" id="kobo.1082.1"> implementation, accompanied by the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">deallocate()</span></strong><span class="koboSpan" id="kobo.1084.1"> member function, which is, in this case, effectively </span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">a no-op:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1086.1">
   // ...
</span><span class="koboSpan" id="kobo.1086.2">   // rebind, address(), construct() and destroy()
   // are all as usual
   pointer allocate(size_type n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1087.1">      auto</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1088.1">         request = reinterpret_cast&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1089.1">            std::intptr_t</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1090.1">         &gt;(cur + n),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1091.1">         limit = reinterpret_cast&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1092.1">            std::intptr_t</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1093.1">         &gt;(buf + cap);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1094.1">      if(request &gt;= limit)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1095.1">         throw std::bad_alloc{};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1096.1">      auto q = cur;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1097.1">      cur += n;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1098.1">      return q;</span></strong><span class="koboSpan" id="kobo.1099.1">
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.1100.1">   void deallocate(pointer, size_type) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1101.1">   }</span></strong><span class="koboSpan" id="kobo.1102.1">
};
// ...</span></pre> <p><span class="koboSpan" id="kobo.1103.1">As this allocator </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.1104.1">is</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.1105.1"> stateful, we need to give some thought to allocator equality. </span><span class="koboSpan" id="kobo.1105.2">What we will do in this case is </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1107.1">
template &lt;class T, class U&gt;
  constexpr bool operator==(const seq_buf_allocator&lt;T&gt; &amp;a,
                            const seq_buf_allocator&lt;U&gt; &amp;b){
     return a.cur == b.cur; // maybe?
</span><span class="koboSpan" id="kobo.1107.2">  }
template &lt;class T, class U&gt;
  constexpr bool operator!=(const seq_buf_allocator&lt;T&gt; &amp;a,
                            const seq_buf_allocator&lt;U&gt; &amp;b){
     return !(a == b);
  }</span></pre> <p><span class="koboSpan" id="kobo.1108.1">These equality operators make sense at a specific moment in time only, but then this allocator type is not really meant to be copied in practice; if you plan to use a buffer such as this and share its internal state, you will need to give some thought to the way the original and the copy share their internal state and remain coherent with one another – something we do not need to do in </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">this case.</span></span></p>
<p><span class="koboSpan" id="kobo.1110.1">As you can see, we test for overflow on allocation and throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.1112.1"> if an allocation</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.1113.1"> request </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.1114.1">would lead to a buffer overflow, but that’s only one option among others, as we have discussed earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">this chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1116.1">
#include &lt;chrono&gt;
#include &lt;utility&gt;
template &lt;class F, class ... </span><span class="koboSpan" id="kobo.1116.2">Args&gt;
   auto test(F f, Args &amp;&amp;... </span><span class="koboSpan" id="kobo.1116.3">args) {
      using namespace std;
      using namespace std::chrono;
      auto pre = high_resolution_clock::now();
      auto res = f(std::forward&lt;Args&gt;(args)...);
      auto post = high_resolution_clock::now();
      return pair{ res, post - pre };
   }
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.1117.1">struct Data { int n; };</span></strong><span class="koboSpan" id="kobo.1118.1">
int main() {
   using namespace std::chrono;
   enum { N = 500'000 };
   {
</span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">      std::vector&lt;Data&gt; v;</span></strong><span class="koboSpan" id="kobo.1120.1">
      auto [r, dt] = test([](auto &amp; v) {
         v.reserve(N);
         for(int i = 0; i != N; ++i)
            v.push_back({ i + 1 });
         return v.back();
      }, v);
      std::cout &lt;&lt; "vector&lt;Data&gt;:\n\t"
                &lt;&lt; v.size()
                &lt;&lt; " insertions in "
                &lt;&lt; duration_cast&lt;microseconds&gt;(dt).count()
                &lt;&lt; " us\n";
   }
   {
</span><strong class="bold"><span class="koboSpan" id="kobo.1121.1">      alignas(Data) char buf[N * sizeof(Data)];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1122.1">      seq_buf_allocator&lt;Data&gt; alloc{ buf, sizeof buf };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1123.1">      std::vector&lt;Data, seq_buf_allocator&lt;Data&gt;&gt; v(alloc);</span></strong><span class="koboSpan" id="kobo.1124.1">
      auto [r, dt] = test([](auto &amp; v) {
         v.reserve(N);
         for(int i = 0; i != N; ++i)
            v.push_back({ i + 1 });
         return v.back();
      }, v);
      std::cout
         &lt;&lt; "vector&lt;Data, seq_buf_allocator&lt;Data&gt;&gt;:\n\t"
         &lt;&lt; v.size()
         &lt;&lt; " insertions in "
         &lt;&lt; duration_cast&lt;microseconds&gt;(dt).count()
         &lt;&lt; " us\n";
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.1125.1">   // do the same replacing std::vector with Vector</span></strong><span class="koboSpan" id="kobo.1126.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1127.1">Here are a few </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.1128.1">things you might want to note at </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">this</span></span><span class="No-Break"><a id="_idIndexMarker834"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1"> point:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1131.1">The test code is the same irrespective of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">chosen allocator.</span></span></li>
<li><span class="koboSpan" id="kobo.1133.1">When using a stateful allocator, we need to use a parametric constructor that accepts the allocator </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">as argument.</span></span></li>
<li><span class="koboSpan" id="kobo.1135.1">The responsibility with respect to the size and alignment of the buffer used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">seq_buf_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1137.1"> falls on the (metaphorical) shoulders of user code. </span><span class="koboSpan" id="kobo.1137.2">Again, remember that this is a specialized tool, so users are expected to know what they </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">are doing.</span></span></li>
<li><span class="koboSpan" id="kobo.1139.1">If you run this test on a conforming compiler, you might notice interesting performances with the sequential buffer allocator, and you might notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1141.1"> outperforms </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">std::vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1143.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1145.1"> is not as complete and rigorous as its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">std::</span></strong><span class="koboSpan" id="kobo.1147.1"> counterpart. </span><span class="koboSpan" id="kobo.1147.2">Prefer the standard facilities </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">in practice.</span></span></li>
<li><span class="koboSpan" id="kobo.1149.1">There are limitations to the size of the buffer provided to a sequential buffer allocator as stack space is a limited resource (often one or two megabytes overall, so we have less than this to work with). </span><span class="koboSpan" id="kobo.1149.2">Still, this technique is useful and used in practice in </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">low-latency systems.</span></span></li>
<li><span class="koboSpan" id="kobo.1151.1">If you apply this sort of allocator with a node-based container list </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1153.1">, remember that there is a size overhead to each node so plan the size of the buffer to </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">provide accordingly.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1155.1">Of course, that </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.1156.1">was an implementation </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.1157.1">that respects C++17 standards. </span><span class="koboSpan" id="kobo.1157.2">What has changed with respect to allocators </span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1">since then?</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.1159.1">Traditional allocators with contemporary standards</span></h2>
<p><span class="koboSpan" id="kobo.1160.1">As mentioned </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.1161.1">already, the traditional approach</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.1162.1"> of ensconcing the allocator type in the associated container type still exists as of this writing, but the way allocators themselves are expressed has changed over time, and the allocators from the previous section, whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1164.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">seq_buf_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1166.1">, do not compile as written on a C++20 compiler. </span><span class="koboSpan" id="kobo.1166.2">Before thinking this is sad, know that we can still write these allocators, but we have to write them in a simpler </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">manner. </span><span class="koboSpan" id="kobo.1167.2">Whew!</span></span></p>
<h3><span class="koboSpan" id="kobo.1168.1">Simplification and the advent of a traits-based implementation</span></h3>
<p><span class="koboSpan" id="kobo.1169.1">The first step in a simplification effort of allocators was the recognition that in most cases, a significant part of the code written in an allocator is what we call “boilerplate code,” code that is the same from class to class and could be qualified </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">as “noise.”</span></span></p>
<p><span class="koboSpan" id="kobo.1171.1">To that effect, C++11 introduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1173.1">. </span><span class="koboSpan" id="kobo.1173.2">The idea is that given some </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">typename A::value_type</span></strong><span class="koboSpan" id="kobo.1175.1"> type, one can generate a reasonable and efficient default implementation for most allocator services (including type aliases such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">pointer</span></strong><span class="koboSpan" id="kobo.1177.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">size_type</span></strong><span class="koboSpan" id="kobo.1179.1">) as long as one provides implementations for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">allocate()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1181.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">deallocate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1184.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1186.1"> as an illustration, we would now be able to simply express that entire allocator type with </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1188.1">
template &lt;class T&gt;
struct small_allocator {
</span><strong class="bold"><span class="koboSpan" id="kobo.1189.1">   using value_type = T;</span></strong><span class="koboSpan" id="kobo.1190.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.1191.1">T* allocate(std::size_t n)</span></strong><span class="koboSpan" id="kobo.1192.1"> {
      auto p = </span><strong class="bold"><span class="koboSpan" id="kobo.1193.1">static_cast&lt;T*&gt;</span></strong><span class="koboSpan" id="kobo.1194.1">(
         malloc(n * sizeof(value_type))
      );
      if (!p) throw std::bad_alloc{};
      return p;
   }
   </span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">void deallocate(T *p, std::size_t)</span></strong><span class="koboSpan" id="kobo.1196.1"> {
      free(p);
   }
};
// ... </span><span class="koboSpan" id="kobo.1196.2">insert the equality operators here</span></pre> <p><span class="koboSpan" id="kobo.1197.1">As you can see, this is quite a simplification! </span><span class="koboSpan" id="kobo.1197.2">This way, a container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1199.1"> could now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1201.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">A</span></strong><span class="koboSpan" id="kobo.1203.1"> directly when referring to some allocator </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">A</span></strong><span class="koboSpan" id="kobo.1205.1">’s members. </span><span class="koboSpan" id="kobo.1205.2">With traits being this very thin layer of abstraction that brings no runtime cost to speak of, what they do for some member </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">M</span></strong><span class="koboSpan" id="kobo.1207.1"> is essentially “If </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">A</span></strong><span class="koboSpan" id="kobo.1209.1"> exposes </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.1210.1">member “</span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">M</span></strong><span class="koboSpan" id="kobo.1212.1">, then </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.1213.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">A::M</span></strong><span class="koboSpan" id="kobo.1215.1">; otherwise, here is some reasonable default implementation instead.” </span><span class="koboSpan" id="kobo.1215.2">Of course, there will be no branching here in practice as everything is determined at </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">compile time.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1">For example, based on our previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">small_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1219.1"> type, given that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">small_allocator&lt;T&gt;::allocate()</span></strong><span class="koboSpan" id="kobo.1221.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">T*</span></strong><span class="koboSpan" id="kobo.1223.1">, then we can determine that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">std::allocator_traits&lt;small_allocator&lt;T&gt;&gt;::pointer</span></strong><span class="koboSpan" id="kobo.1225.1"> will be equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">T*</span></strong><span class="koboSpan" id="kobo.1227.1">, and a container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1229.1"> will make its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">pointer</span></strong><span class="koboSpan" id="kobo.1231.1"> type alias correspond to the type expressed </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">std::allocator_traits&lt;A&gt;::pointer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1235.1">For another example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">seq_buf_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1237.1"> would now be expressed </span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1239.1">
template &lt;class T&gt;
struct seq_buf_allocator {
</span><strong class="bold"><span class="koboSpan" id="kobo.1240.1">   using value_type = T;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1241.1">   using pointer = T*;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1242.1">   using size_type = std::size_t;</span></strong><span class="koboSpan" id="kobo.1243.1">
   char* buf;
   pointer cur;
   size_type cap;
   seq_buf_allocator(char* buf, size_type cap) noexcept
      : buf{ buf }, cap{ cap } {
      cur = reinterpret_cast&lt;pointer&gt;(buf);
   }
   pointer allocate(size_type n) {
      auto request =
         reinterpret_cast&lt;std::intptr_t&gt;(cur + n),
           limit =
         reinterpret_cast&lt;std::intptr_t&gt;(buf + cap);
      if (request &gt; limit) {
         throw std::bad_alloc{};
      }
      auto q = cur;
      cur += n;
      return q;
   }
   void deallocate(pointer, size_type) {
   }
};
// ... </span><span class="koboSpan" id="kobo.1243.2">insert equality operators here</span></pre> <p><span class="koboSpan" id="kobo.1244.1">In this</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.1245.1"> case, even </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.1246.1">though it was not necessary, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">seq_buf_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1248.1"> exposes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">pointer</span></strong><span class="koboSpan" id="kobo.1250.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">size_type</span></strong><span class="koboSpan" id="kobo.1252.1"> aliases, which means that for this type, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">std::allocator_traits</span></strong><span class="koboSpan" id="kobo.1254.1"> will use the allocator-provided versions instead of trying to synthesize an alternative. </span><span class="koboSpan" id="kobo.1254.2">As you can see, the contemporary traits-based approach to allocators is </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">very convenient.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">What services does type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1258.1"> provide exactly? </span><span class="koboSpan" id="kobo.1258.2">Well, as could be expected, this type exposes the usual type aliases of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">value_type</span></strong><span class="koboSpan" id="kobo.1260.1"> (itself being an alias for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">A::value_type</span></strong><span class="koboSpan" id="kobo.1262.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">pointer</span></strong><span class="koboSpan" id="kobo.1264.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">const_pointer</span></strong><span class="koboSpan" id="kobo.1266.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">size_type</span></strong><span class="koboSpan" id="kobo.1268.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">difference_type</span></strong><span class="koboSpan" id="kobo.1270.1">. </span><span class="koboSpan" id="kobo.1270.2">For convenience, it also exposes aliases </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">allocator_type</span></strong><span class="koboSpan" id="kobo.1272.1"> (equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">A</span></strong><span class="koboSpan" id="kobo.1274.1">): </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">void_pointer</span></strong><span class="koboSpan" id="kobo.1276.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">const_void_pointer</span></strong><span class="koboSpan" id="kobo.1278.1"> (respectively equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">void*</span></strong><span class="koboSpan" id="kobo.1280.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">const void*</span></strong><span class="koboSpan" id="kobo.1282.1"> in most cases). </span><span class="koboSpan" id="kobo.1282.2">Remember that traits can be specialized, and for that reason, these seemingly evident type aliases could map to more exotic constructs </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">on occasion.</span></span></p>
<p><span class="koboSpan" id="kobo.1284.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1286.1"> also exposes the traditional services of an allocator, but in the form of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">static</span></strong><span class="koboSpan" id="kobo.1288.1"> member functions that take the allocator as first argument, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">construct()</span></strong><span class="koboSpan" id="kobo.1290.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">destroy()</span></strong><span class="koboSpan" id="kobo.1292.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">allocate()</span></strong><span class="koboSpan" id="kobo.1294.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">deallocate()</span></strong><span class="koboSpan" id="kobo.1296.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">max_size()</span></strong><span class="koboSpan" id="kobo.1298.1">. </span><span class="koboSpan" id="kobo.1298.2">C++23 adds another </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">static</span></strong><span class="koboSpan" id="kobo.1300.1"> member function to this set: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">allocate_at_least()</span></strong><span class="koboSpan" id="kobo.1302.1">. </span><span class="koboSpan" id="kobo.1302.2">This function returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">std::allocation_result</span></strong><span class="koboSpan" id="kobo.1304.1"> object made of the allocated pointer and the actual size of the allocated chunk, expressed as a </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.1305.1">number</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.1306.1"> of objects (even though, as usual, there is no object in that memory block after allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.1307.1">has completed).</span></span></p>
<p><span class="koboSpan" id="kobo.1308.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">rebind</span></strong><span class="koboSpan" id="kobo.1310.1"> mechanism is expressed through types </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">std::rebind_alloc&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1312.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">std::rebind_traits&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1314.1">. </span><span class="koboSpan" id="kobo.1314.2">When cloning an allocation strategy (for node containers, mostly), the equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">typename A::rebind&lt;T&gt;::other</span></strong><span class="koboSpan" id="kobo.1316.1"> through these facilities is somewhat </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">more verbose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1318.1">
// ...
</span><strong class="bold"><span class="koboSpan" id="kobo.1319.1">   typename std::allocator_traits&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1320.1">      A</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1321.1">   &gt;::template rebind_alloc&lt;Node&gt;;</span></strong><span class="koboSpan" id="kobo.1322.1">
// ...</span></pre> <p><span class="koboSpan" id="kobo.1323.1">Note the presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">template</span></strong><span class="koboSpan" id="kobo.1325.1"> keyword required for grammatical disambiguation Yes, I know what you are thinking now: what a complex language! </span><span class="koboSpan" id="kobo.1325.2">But we rarely need to use that keyword in practice, and only in those strange situations where the compiler would get confused looking at the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">&lt;</span></strong><span class="koboSpan" id="kobo.1327.1"> and not knowing whether it’s part of a template signature or whether it’s the </span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">less-than operator.</span></span></p>
<p><span class="koboSpan" id="kobo.1329.1">There are also new facilities that come with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1331.1"> and deal with allocator lifetime management, something we learned to do over </span><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">the years:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1333.1">Three type aliases that inform containers as to what should be done with the allocator at key moments in the container’s life. </span><span class="koboSpan" id="kobo.1333.2">These types are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">propagate_on_container_copy_assignment</span></strong><span class="koboSpan" id="kobo.1335.1"> (also known as </span><strong class="bold"><span class="koboSpan" id="kobo.1336.1">POCCA</span></strong><span class="koboSpan" id="kobo.1337.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">propagate_on_container_move_assignment</span></strong><span class="koboSpan" id="kobo.1339.1"> (also known as </span><strong class="bold"><span class="koboSpan" id="kobo.1340.1">POCMA</span></strong><span class="koboSpan" id="kobo.1341.1">), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">propagate_on_container_swap</span></strong><span class="koboSpan" id="kobo.1343.1"> (also known as </span><strong class="bold"><span class="koboSpan" id="kobo.1344.1">POCS</span></strong><span class="koboSpan" id="kobo.1345.1">). </span><span class="koboSpan" id="kobo.1345.2">All </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.1346.1">three </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.1347.1">can be</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.1348.1"> instantiated and behave like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">constexpr</span></strong><span class="koboSpan" id="kobo.1350.1"> functions that yield </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">true</span></strong><span class="koboSpan" id="kobo.1352.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">false</span></strong><span class="koboSpan" id="kobo.1354.1"> (they are equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">std::false_type</span></strong><span class="koboSpan" id="kobo.1356.1"> by default as, by default, allocators are not meant to be copied or moved). </span><span class="koboSpan" id="kobo.1356.2">For example, if an allocator exposes type alias POCMA equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">std::true_type</span></strong><span class="koboSpan" id="kobo.1358.1">, then a container with that allocator should move the allocator along with the allocated data. </span><span class="koboSpan" id="kobo.1358.2">Note that in all three cases, this trait being </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.1359.1">equivalent </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.1360.1">to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">std::true_type</span></strong><span class="koboSpan" id="kobo.1362.1"> implies a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">noexcept</span></strong><span class="koboSpan" id="kobo.1364.1"> copy, move, or swap (respectively) operation for </span><span class="No-Break"><span class="koboSpan" id="kobo.1365.1">the allocator.</span></span></li>
<li><span class="koboSpan" id="kobo.1366.1">Type alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">is_always_equal</span></strong><span class="koboSpan" id="kobo.1368.1">; which means that allocators of that type will compare equally irrespective of the type of object to allocate (this alleviates the need for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">operator==()</span></strong><span class="koboSpan" id="kobo.1370.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">operator!=()</span></strong><span class="koboSpan" id="kobo.1372.1">, which compare two allocators of the same template but different </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">value_type</span></strong><span class="koboSpan" id="kobo.1374.1"> aliases). </span><span class="koboSpan" id="kobo.1374.2">Don’t spend too much time on this one though; it has been deprecated in C++23 and will most likely be removed </span><span class="No-Break"><span class="koboSpan" id="kobo.1375.1">in C++26.</span></span></li>
<li><span class="koboSpan" id="kobo.1376.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">select_on_container_copy_construction()</span></strong><span class="koboSpan" id="kobo.1378.1"> member function. </span><span class="koboSpan" id="kobo.1378.2">This is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">static</span></strong><span class="koboSpan" id="kobo.1380.1"> member function that takes an allocator and copies it if its allocator traits express that this is the right thing to do, or returns the original </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">allocator otherwise.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1382.1">Okay, this allocator </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.1383.1">lifetime</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.1384.1"> management is new and might be surprising. </span><span class="koboSpan" id="kobo.1384.2">What do we do with </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">this information?</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.1386.1">Managing traditional allocator lifetime</span></h2>
<p><span class="koboSpan" id="kobo.1387.1">What should a container</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.1388.1"> do with allocators within a move or a copy operation? </span><span class="koboSpan" id="kobo.1388.2">Well, here are </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">the details.</span></span></p>
<p><span class="koboSpan" id="kobo.1390.1">In a container’s copy constructor, the best thing to do is probably to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">select_on_container_copy_construction()</span></strong><span class="koboSpan" id="kobo.1392.1">. </span><span class="koboSpan" id="kobo.1392.2">It is that function’s purpose, after all. </span><span class="koboSpan" id="kobo.1392.3">Please do not use that function elsewhere: it is really meant for the copy constructor of a container. </span><span class="koboSpan" id="kobo.1392.4">Once the container under construction has obtained its allocator, this allocator can be used to perform the remainder of the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.1393.1">allocation tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.1394.1">In a container’s move constructor, the thing to do is move construct the allocator and steal the resources from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1395.1">source container.</span></span></p>
<p><span class="koboSpan" id="kobo.1396.1">In a container’s copy assignment operator, if type alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">propagate_on_container_copy_assignment</span></strong><span class="koboSpan" id="kobo.1398.1"> is equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">std::true_type</span></strong><span class="koboSpan" id="kobo.1400.1"> and both allocators compare unequally, the destination container first has to deallocate all memory (that might not be possible later on in the process). </span><span class="koboSpan" id="kobo.1400.2">Past this point, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">propagate_on_container_copy_assignment</span></strong><span class="koboSpan" id="kobo.1402.1"> is equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">std::true_type</span></strong><span class="koboSpan" id="kobo.1404.1">, then the allocators should be copy-assigned. </span><span class="koboSpan" id="kobo.1404.2">Only once this is all done should the elements </span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1">be copied.</span></span></p>
<p><span class="koboSpan" id="kobo.1406.1">The container’s move assignment operator is trickier (remember that </span><em class="italic"><span class="koboSpan" id="kobo.1407.1">move</span></em><span class="koboSpan" id="kobo.1408.1"> is an optimization, and we want it to pay off!). </span><span class="koboSpan" id="kobo.1408.2">The options we face are </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1410.1">Type alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">propagate_on_container_move_assignment</span></strong><span class="koboSpan" id="kobo.1412.1"> is equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">std::true_type</span></strong><span class="koboSpan" id="kobo.1414.1">. </span><span class="koboSpan" id="kobo.1414.2">In this situation, the steps to perform are (a) ensure that the destination container deallocates all memory under its responsibility (it might not be able to do so later on), (b) move-assign the allocator, and then (c) transfer memory ownership from the source container to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">destination container.</span></span></li>
<li><span class="koboSpan" id="kobo.1416.1">Type alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">propagate_on_container_move_assignment</span></strong><span class="koboSpan" id="kobo.1418.1"> is equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">std::false_type</span></strong><span class="koboSpan" id="kobo.1420.1"> and the allocators compare equally. </span><span class="koboSpan" id="kobo.1420.2">In this situation, you can do the same steps as in the previous case but do not move </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">the container.</span></span></li>
<li><span class="koboSpan" id="kobo.1422.1">Type alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">propagate_on_container_move_assignment</span></strong><span class="koboSpan" id="kobo.1424.1"> is equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">std::false_type</span></strong><span class="koboSpan" id="kobo.1426.1"> and the allocators compare unequally. </span><span class="koboSpan" id="kobo.1426.2">In this case, ownership cannot really be transferred, so the best one can do is move the objects themselves from the source container to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">destination container.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1428.1">Luckily, all of these</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.1429.1"> allocator properties can be tested at compile time so the decision-making process does not need to incur any </span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">runtime cost.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1431.1">Things we do for concision…</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1432.1">You will notice our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1434.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1436.1"> types do not do the entire “allocator lifetime management dance” in order to keep our examples reasonably short, and because the way in which we manage allocator copy and movement is an interesting design aspect that would require adding at least one chapter to this already rather big book. </span><span class="koboSpan" id="kobo.1436.2">Please be tolerant, </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">dear reader.</span></span></p>
<h3><span class="koboSpan" id="kobo.1438.1">Using traits-based allocators in allocator-aware containers</span></h3>
<p><span class="koboSpan" id="kobo.1439.1">The remaining</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.1440.1"> question with</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.1441.1"> traditional allocators in a traits-based approach is: how do containers </span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">use them?</span></span></p>
<p><span class="koboSpan" id="kobo.1443.1">The first thing we will need to do is to adapt our allocator-aware adaptation of the standard uninitialized memory algorithms. </span><span class="koboSpan" id="kobo.1443.2">For example, our personal adaptation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">std::uninitialized_copy()</span></strong><span class="koboSpan" id="kobo.1445.1"> becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1447.1">
template &lt;class A, class IIt, class OIt&gt;
void uninitialized_copy_with_allocator
   (A &amp;a, IIt bs, IIt es, OIt bd) {
   auto p = bd;
   try {
      for (auto q = bs; q != es; ++q) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1448.1">         std::allocator_traits&lt;A&gt;::construct(a, p, *q);</span></strong><span class="koboSpan" id="kobo.1449.1">
         ++p;
      }
   } catch (...) {
      for (auto q = bd; q != p; ++q)
</span><strong class="bold"><span class="koboSpan" id="kobo.1450.1">         std::allocator_traits&lt;A&gt;::destroy(a, q);</span></strong><span class="koboSpan" id="kobo.1451.1">
      throw;
   }
}</span></pre> <p><span class="koboSpan" id="kobo.1452.1">As you can see, we are now using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1454.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">A</span></strong><span class="koboSpan" id="kobo.1456.1"> directly, opening up customization opportunities, and passing the allocator as first argument since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1458.1"> member functions are all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">static</span></strong><span class="koboSpan" id="kobo.1460.1">. </span><span class="koboSpan" id="kobo.1460.2">The same adjustment can be applied to the other allocator-aware versions of the algorithms we wrote, with the same calling pattern and passing the allocator as </span><span class="No-Break"><span class="koboSpan" id="kobo.1461.1">first argument.</span></span></p>
<p><span class="koboSpan" id="kobo.1462.1">Then, we</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.1463.1"> reach</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.1464.1"> our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1466.1"> type. </span><span class="koboSpan" id="kobo.1466.2">How do we adjust its implementation to use the contemporary traits-based allocators? </span><span class="koboSpan" id="kobo.1466.3">The first thing to do is to adjust the source of the container’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1467.1">type aliases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1468.1">
template &lt;class T, class A = std::allocator&lt;T&gt;&gt;
class Vector : A { // note: private inheritance
public:
   using value_type =
      typename </span><strong class="bold"><span class="koboSpan" id="kobo.1469.1">std::allocator_traits&lt;A&gt;::value_type</span></strong><span class="koboSpan" id="kobo.1470.1">;
   using size_type =
      typename </span><strong class="bold"><span class="koboSpan" id="kobo.1471.1">std::allocator_traits&lt;A&gt;::size_type</span></strong><span class="koboSpan" id="kobo.1472.1">;
   using pointer =
      typename </span><strong class="bold"><span class="koboSpan" id="kobo.1473.1">std::allocator_traits&lt;A&gt;::pointer</span></strong><span class="koboSpan" id="kobo.1474.1">;
   using const_pointer =
      typename </span><strong class="bold"><span class="koboSpan" id="kobo.1475.1">std::allocator_traits&lt;A&gt;::const_pointer</span></strong><span class="koboSpan" id="kobo.1476.1">;
</span><strong class="bold"><span class="koboSpan" id="kobo.1477.1">   using reference = value_type&amp;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1478.1">   using const_reference = const value_type&amp;;</span></strong><span class="koboSpan" id="kobo.1479.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1480.1">You might be surprised that type aliases </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">reference</span></strong><span class="koboSpan" id="kobo.1482.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">const_reference</span></strong><span class="koboSpan" id="kobo.1484.1"> are not taken from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1486.1">, but there is a reason for this. </span><span class="koboSpan" id="kobo.1486.2">In C++, as in this writing, we can design types that behave like “smart pointers” (we have even done so in this book; see </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1487.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1488.1">), so an abstraction is useful in case the allocator provides pointers that are not raw pointers, but there is no known way to write “smart references” (that would require being able to overload </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">operator.()</span></strong><span class="koboSpan" id="kobo.1490.1"> and proposals to that effect have so far failed to </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">be accepted).</span></span></p>
<p><span class="koboSpan" id="kobo.1492.1">The only reference type that behaves like a reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">T</span></strong><span class="koboSpan" id="kobo.1494.1"> is… well, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">T&amp;</span></strong><span class="koboSpan" id="kobo.1496.1">. </span><span class="koboSpan" id="kobo.1496.2">For that reason, these type aliases were deprecated in C++17 and removed in C++20. </span><span class="koboSpan" id="kobo.1496.3">We can still provide them to clarify our </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.1497.1">type’s</span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.1498.1"> member function signatures, but they are no longer required by </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">the standard.</span></span></p>
<p><span class="koboSpan" id="kobo.1500.1">As far as the member functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1502.1"> go, the general idea is that all calls to member functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">A</span></strong><span class="koboSpan" id="kobo.1504.1"> are replaced with calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">static</span></strong><span class="koboSpan" id="kobo.1506.1"> member functions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">std::allocator_traits&lt;A&gt;</span></strong><span class="koboSpan" id="kobo.1508.1"> that take a reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">A</span></strong><span class="koboSpan" id="kobo.1510.1"> object as argument (remember that in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">Vector&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1512.1"> implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">A</span></strong><span class="koboSpan" id="kobo.1514.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">private</span></strong><span class="koboSpan" id="kobo.1516.1"> base class of the container). </span><span class="koboSpan" id="kobo.1516.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.1517.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1518.1">
   Vector(size_type n, const_reference init)
      : </span><strong class="bold"><span class="koboSpan" id="kobo.1519.1">A{}</span></strong><span class="koboSpan" id="kobo.1520.1">,
</span><strong class="bold"><span class="koboSpan" id="kobo.1521.1">        elems{ std::allocator_traits&lt;A&gt;::allocate(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1522.1">           static_cast&lt;A&amp;&gt;(*this), n)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1523.1">        },</span></strong><span class="koboSpan" id="kobo.1524.1">
        nelems{ n }, cap{ n } {
      try {
         </span><strong class="bold"><span class="koboSpan" id="kobo.1525.1">uninitialized_fill_with_allocator</span></strong><span class="koboSpan" id="kobo.1526.1">(
            </span><strong class="bold"><span class="koboSpan" id="kobo.1527.1">static_cast&lt;A&amp;&gt;(*this)</span></strong><span class="koboSpan" id="kobo.1528.1">, begin(), end(), init
         );
      } catch (...) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1529.1">         std::allocator_traits&lt;A&gt;::deallocate(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1530.1">            static_cast&lt;A&amp;&gt;(*this), elems, capacity()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1531.1">         );</span></strong><span class="koboSpan" id="kobo.1532.1">
         throw;
      }
   }</span></pre> <p><span class="koboSpan" id="kobo.1533.1">If you feel discomfort with the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">*this</span></strong><span class="koboSpan" id="kobo.1535.1"> in the data member initializers, you can relax as we are only using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">A</span></strong><span class="koboSpan" id="kobo.1537.1"> part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">*this</span></strong><span class="koboSpan" id="kobo.1539.1"> and that base class sub-object has been fully initialized at that point. </span><span class="koboSpan" id="kobo.1539.2">It’s a safe part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">*this</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1541.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.1542.1">The same adjustment has to be applied throughout the container (in dozens of places) and obviously makes the source code more verbose, but the good news is that this has gained us a zero-cost-at-runtime layer of abstraction and helped everyone who actually </span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">writes allocators.</span></span></p>
<p><span class="koboSpan" id="kobo.1544.1">For a node-based</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.1545.1"> container </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.1546.1">such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1547.1">ForwardList&lt;T,A&gt;</span></strong><span class="koboSpan" id="kobo.1548.1">, the situation is similar yet slightly different. </span><span class="koboSpan" id="kobo.1548.2">For one thing, the type aliases are tricky; some of them are meant for user code and should be expressed with respect to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1549.1">value_type</span></strong><span class="koboSpan" id="kobo.1550.1"> of the container, and others should be based on the types of the allocator as expressed through </span><span class="No-Break"><span class="koboSpan" id="kobo.1551.1">its traits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1552.1">
template &lt;class T, class A = std::allocator&lt;T&gt;&gt;
class ForwardList {
public:
   // note: these are the forward-facing types, expressed
   // in terms where T is the value_type
</span><strong class="bold"><span class="koboSpan" id="kobo.1553.1">   using value_type = T;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1554.1">   using size_type =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1555.1">      typename std::allocator_traits&lt;A&gt;::size_type;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1556.1">   using pointer = value_type*;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1557.1">   using const_pointer = const value_type*;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1558.1">   using reference = value_type&amp;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1559.1">   using const_reference = const value_type&amp;;</span></strong><span class="koboSpan" id="kobo.1560.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1561.1">Within the container, we</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.1562.1"> need </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.1563.1">to rebind </span><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">A</span></strong><span class="koboSpan" id="kobo.1565.1"> to an allocator of our internal </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">Node</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1567.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1568.1">
   // ...
</span><span class="koboSpan" id="kobo.1568.2">private:
   struct Node {
      value_type value;
      Node *next = nullptr;
      Node(const_reference value) : value { value } {
      }
      Node(value_type &amp;&amp;value) : value{ std::move(value) }{
      }
   };
</span><strong class="bold"><span class="koboSpan" id="kobo.1569.1">   using Alloc = typename std::allocator_traits&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1570.1">      A</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1571.1">   &gt;::template rebind_alloc&lt;Node&gt;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1572.1">   Alloc alloc;</span></strong><span class="koboSpan" id="kobo.1573.1">
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1574.1">Past this point, what we will do to perform memory management tasks is use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">static</span></strong><span class="koboSpan" id="kobo.1576.1"> member functions from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">std::allocator_traits&lt;Alloc&gt;</span></strong><span class="koboSpan" id="kobo.1578.1"> type, passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">alloc</span></strong><span class="koboSpan" id="kobo.1580.1"> data member as argument, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1582.1">
   // ...
</span><span class="koboSpan" id="kobo.1582.2">   void clear() noexcept {
      for(auto p = head; p; ) {
         auto q = p-&gt;next;
</span><strong class="bold"><span class="koboSpan" id="kobo.1583.1">         std::allocator_traits&lt;Alloc&gt;::destroy(alloc, p); </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1584.1">         std::allocator_traits&lt;Alloc&gt;::deallocate(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1585.1">            alloc, p, 1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1586.1">         );</span></strong><span class="koboSpan" id="kobo.1587.1">
         p = q;
      }
      nelems = 0;
   }
   template &lt;std::forward_iterator It&gt;
      ForwardList(It b, It e) {
         if(b == e) return;
         try {
</span><strong class="bold"><span class="koboSpan" id="kobo.1588.1">            head = std::allocator_traits&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1589.1">               Alloc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1590.1">            &gt;::allocate(alloc, 1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1591.1">            std::allocator_traits&lt;Alloc&gt;::construct(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1592.1">               alloc, head, *b</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1593.1">            );</span></strong><span class="koboSpan" id="kobo.1594.1">
            auto q = head;
            ++nelems;
            for(++b; b != e; ++b) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1595.1">               auto ptr = std::allocator_traits&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1596.1">                  Alloc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1597.1">               &gt;::allocate(alloc, 1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1598.1">               std::allocator_traits&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1599.1">                  Alloc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1600.1">               &gt;::construct(alloc, ptr, *b);</span></strong><span class="koboSpan" id="kobo.1601.1">
               q-&gt;next = ptr;
               q = q-&gt;next;
               ++nelems;
            }
         } catch (...) {
            clear();
            throw;
         }
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1602.1">The same technique needs to be applied throughout the container, of course, but the complexity remains </span><span class="No-Break"><span class="koboSpan" id="kobo.1603.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.1604.1">Now that we have seen how traditional allocators, ensconced in the type of their container, have evolved from their original (rather involved) contract to their contemporary </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.1605.1">traits-based </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.1606.1">and simplified implementation (with somewhat more verbose containers), it’s tempting to think that we have reached some form of optimality. </span><span class="koboSpan" id="kobo.1606.2">This is both right </span><span class="No-Break"><span class="koboSpan" id="kobo.1607.1">and wrong.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.1608.1">Irritants with traditional allocators</span></h2>
<p><span class="koboSpan" id="kobo.1609.1">The traditional approach </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.1610.1">to allocators is optimal at runtime in the sense that the services of such an allocator can be called without any overhead, and if an allocator is stateless, the introduction of an allocator in a container can be achieved without any costs in terms of space. </span><span class="No-Break"><span class="koboSpan" id="kobo.1611.1">Not bad!</span></span></p>
<p><span class="koboSpan" id="kobo.1612.1">Of course, the absence of runtime costs is not the absence of </span><span class="No-Break"><span class="koboSpan" id="kobo.1613.1">costs altogether:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1614.1">A container’s implementation can become somewhat complex due to the additional (compile-time) layering, and there is a cost to writing, understanding, and maintaining source code. </span><span class="koboSpan" id="kobo.1614.2">This sort of expertise is not universal; you have it, of course, dear reader, but others do not necessarily share that upside </span><span class="No-Break"><span class="koboSpan" id="kobo.1615.1">with you.</span></span></li>
<li><span class="koboSpan" id="kobo.1616.1">Two containers that are identical in essentially every respect but differ in the way they manage memory (two containers that use different allocators) will in practice be different types, which might slow down compile times in programs that have multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.1617.1">container-allocator combinations.</span></span></li>
<li><span class="koboSpan" id="kobo.1618.1">Some operations that should probably be simple become more complicated. </span><span class="koboSpan" id="kobo.1618.2">For example, if one seeks to compare containers </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">v0</span></strong><span class="koboSpan" id="kobo.1620.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">v1</span></strong><span class="koboSpan" id="kobo.1622.1"> for equality, and if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">v0</span></strong><span class="koboSpan" id="kobo.1624.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">Vector&lt;T,A0&gt;</span></strong><span class="koboSpan" id="kobo.1626.1"> while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">v1</span></strong><span class="koboSpan" id="kobo.1628.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">Vector&lt;T,A1&gt;</span></strong><span class="koboSpan" id="kobo.1630.1">, then one needs to write an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">operator==()</span></strong><span class="koboSpan" id="kobo.1632.1"> function that deals with two different types… even though the allocator of a container is probably not one of its salient properties and, as such, should not be a concern when comparing two containers with respect to their sizes </span><span class="No-Break"><span class="koboSpan" id="kobo.1633.1">and values.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1634.1">The same reasoning goes for many other container-related operations: an allocator is (traditionally) part of its container’s type with the traditional approach, but many operations are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1635.1">value_type</span></strong><span class="koboSpan" id="kobo.1636.1">-related and have nothing to do with allocators. </span><span class="koboSpan" id="kobo.1636.2">We are runtime optimal, but we have additional costs with respect to code generation complexity (which might lead to bigger binaries, which might have runtime speed impacts), and increasing the maintenance effort (including understanding code from its source) has </span><span class="No-Break"><span class="koboSpan" id="kobo.1637.1">a price.</span></span></p>
<p><span class="koboSpan" id="kobo.1638.1">Even something as seemingly simple as making allocators type-aware (traditional allocators are allocators of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1639.1">T</span></strong><span class="koboSpan" id="kobo.1640.1"> for some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1641.1">T</span></strong><span class="koboSpan" id="kobo.1642.1"> after all) is sometimes controversial. </span><span class="koboSpan" id="kobo.1642.2">Low-level memory allocation functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1643.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.1644.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1645.1">::operator new()</span></strong><span class="koboSpan" id="kobo.1646.1"> deal in raw bytes</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.1647.1"> after all, so is it a sign that our traditional allocator model </span><span class="No-Break"><span class="koboSpan" id="kobo.1648.1">is perfectible?</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.1649.1">Polymorphic memory resource allocators</span></h1>
<p><span class="koboSpan" id="kobo.1650.1">With C++17, the C++ language </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.1651.1">added so-called PMR allocators. </span><span class="koboSpan" id="kobo.1651.2">A PMR container stores allocator information as a runtime value, not as a compile-time part of its type. </span><span class="koboSpan" id="kobo.1651.3">In this model, a PMR container holds a pointer to a PMR allocator, reducing the number of types required but adding virtual function calls whenever using memory </span><span class="No-Break"><span class="koboSpan" id="kobo.1652.1">allocation services.</span></span></p>
<p><span class="koboSpan" id="kobo.1653.1">This is again not a no-cost decision, and there are trade-offs with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1654.1">traditional model:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1655.1">This new allocator model supposes that containers store a pointer to an allocation strategy, which generally (not always) makes PMR containers larger than their non-PMR counterparts. </span><span class="koboSpan" id="kobo.1655.2">Interestingly, it also means that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">std::pmr::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1657.1"> is a different container from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1658.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1659.1">, which sometimes causes very real annoyances. </span><span class="koboSpan" id="kobo.1659.2">For example, there is no implicit way to copy the contents of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1660.1">std::pmr::string</span></strong><span class="koboSpan" id="kobo.1661.1"> into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">std::string</span></strong><span class="koboSpan" id="kobo.1663.1">, but luckily, writing such a function is </span><span class="No-Break"><span class="koboSpan" id="kobo.1664.1">very easy.</span></span></li>
<li><span class="koboSpan" id="kobo.1665.1">Every allocation or deallocation service call incurs a polymorphic indirection cost. </span><span class="koboSpan" id="kobo.1665.2">This will be minor to unnoticeable in programs where the called function performs some significant computation, but the same costs can be painful when the called function</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.1666.1"> performs </span><span class="No-Break"><span class="koboSpan" id="kobo.1667.1">little computation.</span></span></li>
<li><span class="koboSpan" id="kobo.1668.1">PMR containers are parameterized on memory resources, and PMR memory resources trade in bytes, not in objects. </span><span class="koboSpan" id="kobo.1668.2">It’s unclear whether this is a good thing or a bad thing (it’s probably a matter of perspective), as both approaches work, but trading in bytes (the simplest common denominator) makes it easier to reduce the number of types in </span><span class="No-Break"><span class="koboSpan" id="kobo.1669.1">a program.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1670.1">There are also advantages to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">PMR approach:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1672.1">The type of a container is not influenced by the type of its allocator. </span><span class="koboSpan" id="kobo.1672.2">All PMR containers simply hold a pointer to the base class of all PMR memory resources </span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1674.1">std::pmr::memory_resource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1675.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1676.1">The work required to implement a PMR allocator is very small as one only needs to override three virtual member functions. </span><span class="koboSpan" id="kobo.1676.2">This opens up avenues to express reusable allocator libraries, </span><span class="No-Break"><span class="koboSpan" id="kobo.1677.1">for example.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1678.1">Under the PMR model, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">std::pmr::polymorphic_allocator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1680.1"> object uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">std::pmr::memory_resource*</span></strong><span class="koboSpan" id="kobo.1682.1"> to determine how memory is managed. </span><span class="koboSpan" id="kobo.1682.2">In most cases, when designing a memory allocation strategy, what one does is write a class that specializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">std::memory_resource</span></strong><span class="koboSpan" id="kobo.1684.1"> and determines what it means to allocate or deallocate memory with </span><span class="No-Break"><span class="koboSpan" id="kobo.1685.1">that strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.1686.1">Let’s look at a simple example of a PMR container with a sequential buffer memory resource, as we just </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.1687.1">implemented such a mechanism with </span><span class="No-Break"><span class="koboSpan" id="kobo.1688.1">traditional allocators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1689.1">
#include &lt;print&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.1690.1">#include &lt;memory_resource&gt;</span></strong><span class="koboSpan" id="kobo.1691.1">
int main() {
   enum { N = 10'000 };
</span><strong class="bold"><span class="koboSpan" id="kobo.1692.1">   alignas(int) char buf[N * sizeof(int)]{};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1693.1">   std::pmr::monotonic_buffer_resource</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1694.1">      res{ std::begin(buf), std::size(buf) };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1695.1">   std::pmr::vector&lt;int&gt; v{ &amp;res };</span></strong><span class="koboSpan" id="kobo.1696.1">
   v.reserve(N);
   for (int i = 0; i != N; ++i)
      v.emplace_back(i + 1);
   for (auto n : v)
      std::print("{} ", n);
   std::print("\n {}\n", std::string(70, '-'));
   for (char * p = buf; p != buf + std::size(buf);
        p += sizeof(int))
      std::print("{} ", *reinterpret_cast&lt;int*&gt;(p));
}</span></pre> <p><span class="koboSpan" id="kobo.1697.1">That’s quite simple, isn’t it? </span><span class="koboSpan" id="kobo.1697.2">You might want to pay attention to </span><span class="No-Break"><span class="koboSpan" id="kobo.1698.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1699.1">This program aims to “allocate” objects in a byte buffer located on the thread’s execution stack. </span><span class="koboSpan" id="kobo.1699.2">With these objects being of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1700.1">int</span></strong><span class="koboSpan" id="kobo.1701.1">, we ensure that buffer </span><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">buf</span></strong><span class="koboSpan" id="kobo.1703.1"> is appropriately aligned and is of sufficient size to hold the objects that are meant to be </span><span class="No-Break"><span class="koboSpan" id="kobo.1704.1">stored therein.</span></span></li>
<li><span class="koboSpan" id="kobo.1705.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1706.1">std::pmr::monotonic_buffer_resource</span></strong><span class="koboSpan" id="kobo.1707.1"> object named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1708.1">res</span></strong><span class="koboSpan" id="kobo.1709.1"> knows where the buffer to manage starts and how big it is. </span><span class="koboSpan" id="kobo.1709.2">It represents a perspective on </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">contiguous memory.</span></span></li>
<li><span class="koboSpan" id="kobo.1711.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1712.1">std::pmr::vector&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.1713.1"> used in this program knows about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1714.1">res</span></strong><span class="koboSpan" id="kobo.1715.1"> and uses that resource to allocate and </span><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">deallocate memory.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1717.1">That’s all there is to it. </span><span class="koboSpan" id="kobo.1717.2">In practice, this program does not allocate even a single byte from the free store in order to store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">int</span></strong><span class="koboSpan" id="kobo.1719.1"> objects. </span><span class="koboSpan" id="kobo.1719.2">Compared to what we had to do to achieve similar effects in the past, this might seem rejoiceful somewhat. </span><span class="koboSpan" id="kobo.1719.3">At the end of the program, iterating through the byte buffer and iterating through the container yield the </span><span class="No-Break"><span class="koboSpan" id="kobo.1720.1">same results.</span></span></p>
<p><span class="koboSpan" id="kobo.1721.1">That works nicely </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.1722.1">and requires very little coding effort, but what if we wanted to express something like a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1723.1">string</span></strong><span class="koboSpan" id="kobo.1724.1"> objects but wanted both the vector and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1725.1">string</span></strong><span class="koboSpan" id="kobo.1726.1"> objects it stores to use the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1727.1">allocation strategy?</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1728.1">Nested allocators</span></h2>
<p><span class="koboSpan" id="kobo.1729.1">Well, it so </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.1730.1">happens that PMR allocators propagate allocation strategies by default. </span><span class="koboSpan" id="kobo.1730.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.1731.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1732.1">
#include &lt;print&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.1733.1">#include &lt;memory_resource&gt;</span></strong><span class="koboSpan" id="kobo.1734.1">
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.1735.1">   auto make_str = [](const char *p, int n) -&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1736.1">      std::pmr::string {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1737.1">      auto s = std::string{ p } + std::to_string(n);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1738.1">      return { std::begin(s), std::end(s) };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1739.1">   };</span></strong><span class="koboSpan" id="kobo.1740.1">
   enum { N = 2'000 };
</span><strong class="bold"><span class="koboSpan" id="kobo.1741.1">   alignas(std::pmr::string) char buf[N]{};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1742.1">   std::pmr::monotonic_buffer_resource</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1743.1">      res{ std::begin(buf), std::size(buf) };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1744.1">   std::pmr::vector&lt;std::pmr::string&gt; v{ &amp;res };</span></strong><span class="koboSpan" id="kobo.1745.1">
   for (int i = 0; i != 10; ++i)
      v.emplace_back(make_str("I love my instructor ", i));
   for (const auto &amp;s : v)
      std::print("{} ", s);
   std::print("\n {}\n", std::string(70, '-'));
   for (char c : buf)
      std::print("{} ", c);
}</span></pre> <p><span class="koboSpan" id="kobo.1746.1">This example also uses a buffer on the stack, but that buffer is used both for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1747.1">std::pmr::vector</span></strong><span class="koboSpan" id="kobo.1748.1"> object and its metadata and for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1749.1">std::string</span></strong><span class="koboSpan" id="kobo.1750.1"> objects therein. </span><span class="koboSpan" id="kobo.1750.2">Propagation of</span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.1751.1"> the allocation strategy from the enclosing container to the enclosed containers </span><span class="No-Break"><span class="koboSpan" id="kobo.1752.1">is implicit.</span></span></p>
<p><span class="koboSpan" id="kobo.1753.1">Do note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1754.1">make_str</span></strong><span class="koboSpan" id="kobo.1755.1"> lambda expression in that program is used to convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.1756.1">std::string</span></strong><span class="koboSpan" id="kobo.1757.1"> (formatted to end with an integer) to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1758.1">std::pmr::string</span></strong><span class="koboSpan" id="kobo.1759.1">. </span><span class="koboSpan" id="kobo.1759.2">As mentioned earlier, the integration of types from namespace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1760.1">std</span></strong><span class="koboSpan" id="kobo.1761.1"> and types from namespace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1762.1">std::pmr</span></strong><span class="koboSpan" id="kobo.1763.1"> sometimes requires a little bit of effort, but the APIs of classes in these namespaces are sufficiently similar for this effort to </span><span class="No-Break"><span class="koboSpan" id="kobo.1764.1">remain reasonable.</span></span></p>
<p><span class="koboSpan" id="kobo.1765.1">If you use this program, you will notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">std::pmr::string</span></strong><span class="koboSpan" id="kobo.1767.1"> objects contain the expected text, but you will also probably notice from the last loop that buffer </span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">buf</span></strong><span class="koboSpan" id="kobo.1769.1"> contains (among other things) the text in the strings. </span><span class="koboSpan" id="kobo.1769.2">That’s because our strings are rather short and, in most standard library implementations, the </span><strong class="bold"><span class="koboSpan" id="kobo.1770.1">small object optimization</span></strong><span class="koboSpan" id="kobo.1771.1"> will be applied, leading</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.1772.1"> to the actual text being inscribed </span><em class="italic"><span class="koboSpan" id="kobo.1773.1">within</span></em><span class="koboSpan" id="kobo.1774.1"> the individual </span><strong class="source-inline"><span class="koboSpan" id="kobo.1775.1">std::pmr::string</span></strong><span class="koboSpan" id="kobo.1776.1"> instead of being allocated separately. </span><span class="koboSpan" id="kobo.1776.2">This shows clearly that the same allocation strategy, represented by our object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">std::pmr::monotonic_buffer_resource</span></strong><span class="koboSpan" id="kobo.1778.1">, has propagated from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1779.1">std::pmr::vector</span></strong><span class="koboSpan" id="kobo.1780.1"> object to the enclosed </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1781.1">std::pmr::string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1782.1"> objects.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1783.1">Scoped allocators and the traditional model</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1784.1">It is possible</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.1785.1"> to use a</span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.1786.1"> scoped allocator system with the traditional allocator approach, even though we did not do so in this book. </span><span class="koboSpan" id="kobo.1786.2">If you are curious, feel free to explore type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1787.1">std::scoped_allocator_adapter</span></strong><span class="koboSpan" id="kobo.1788.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1789.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.1790.1">We will now look at</span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.1791.1"> one last example that uses allocators to track the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.1792.1">allocation process.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.1793.1">Allocators and data collection</span></h2>
<p><span class="koboSpan" id="kobo.1794.1">As we saw in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1795.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1796.1"> when</span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.1797.1"> we wrote our own humble yet functional leak detector, memory management tools are often used to gather information. </span><span class="koboSpan" id="kobo.1797.2">For a non-exhaustive list, know that some companies use them to track memory fragmentation or otherwise assess where objects are placed in memory, maybe in a quest to optimize cache usage. </span><span class="koboSpan" id="kobo.1797.3">Others want to evaluate when and where allocations occur in the course of program execution to know whether a reorganization of the code could lead to better performances. </span><span class="koboSpan" id="kobo.1797.4">Of course, detecting leaks is useful, but we already </span><span class="No-Break"><span class="koboSpan" id="kobo.1798.1">knew that.</span></span></p>
<p><span class="koboSpan" id="kobo.1799.1">As our third and last example of PMR allocation usage, we will implement a </span><em class="italic"><span class="koboSpan" id="kobo.1800.1">tracing resource</span></em><span class="koboSpan" id="kobo.1801.1">, in the sense</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.1802.1"> that we will track allocation and deallocation requests from a container to understand some implementation choices made by that container. </span><span class="koboSpan" id="kobo.1802.2">For the sake of this example, we will use a standard library’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1803.1">std::pmr::vector</span></strong><span class="koboSpan" id="kobo.1804.1"> and try to understand its approach to increasing its capacity when trying to insert objects into a full container. </span><span class="koboSpan" id="kobo.1804.2">Remember that the standard mandates an amortized constant complexity for operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1805.1">push_back()</span></strong><span class="koboSpan" id="kobo.1806.1">, meaning that capacity should grow rarely and most insert-at-end operations should take constant time. </span><span class="koboSpan" id="kobo.1806.2">However, it does not impose a specific growth policy: for example, one implementation could grow by a factor of 2, another by a factor of 1.5, and another could prefer 1.67. </span><span class="koboSpan" id="kobo.1806.3">Other options exist; each one has trade-offs, and each library makes its </span><span class="No-Break"><span class="koboSpan" id="kobo.1807.1">own choices.</span></span></p>
<p><span class="koboSpan" id="kobo.1808.1">We will express this tool as class </span><strong class="source-inline"><span class="koboSpan" id="kobo.1809.1">tracing_resource</span></strong><span class="koboSpan" id="kobo.1810.1">, which derives from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1811.1">std::pmr::memory_resource</span></strong><span class="koboSpan" id="kobo.1812.1"> as expected by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">std::pmr</span></strong><span class="koboSpan" id="kobo.1814.1"> containers. </span><span class="koboSpan" id="kobo.1814.2">This lets us show how easy it is to add a memory resource type to </span><span class="No-Break"><span class="koboSpan" id="kobo.1815.1">this framework:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1816.1">The base class exposes three member functions that we need to override: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">do_allocate()</span></strong><span class="koboSpan" id="kobo.1818.1">, which is meant to perform an allocation request, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1819.1">do_deallocate()</span></strong><span class="koboSpan" id="kobo.1820.1">, whose role is, unsurprisingly, to deallocate memory that is presumed to have been allocated through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1821.1">do_allocate()</span></strong><span class="koboSpan" id="kobo.1822.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1823.1">do_is_equal()</span></strong><span class="koboSpan" id="kobo.1824.1">, which is meant to let user code test two memory resources for equality. </span><span class="koboSpan" id="kobo.1824.2">Note that “equality” in this sense means that memory allocated from one could be deallocated from </span><span class="No-Break"><span class="koboSpan" id="kobo.1825.1">the other.</span></span></li>
<li><span class="koboSpan" id="kobo.1826.1">Since we want to trace allocation requests but do not want to implement an actual memory </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.1827.1">allocation strategy ourselves, we will use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1828.1">upstream</span></strong><span class="koboSpan" id="kobo.1829.1"> resource that will do the allocation and deallocation for us. </span><span class="koboSpan" id="kobo.1829.2">In our test implementation, that resource will be a global resource obtained from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1830.1">std::pmr::new_delete_resource()</span></strong><span class="koboSpan" id="kobo.1831.1"> that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">::operator new()</span></strong><span class="koboSpan" id="kobo.1833.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">::operator delete()</span></strong><span class="koboSpan" id="kobo.1835.1"> to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.1836.1">this objective.</span></span></li>
<li><span class="koboSpan" id="kobo.1837.1">For this reason, our allocation functions will simply “log” (in our case, print) the requested allocation and deallocation sizes, then delegate the allocation work to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">upstream</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1839.1"> resource.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1840.1">A complete </span><span class="No-Break"><span class="koboSpan" id="kobo.1841.1">implementation follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1842.1">
#include &lt;print&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.1843.1">#include &lt;memory_resource&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1844.1">class tracing_resource : public std::pmr::memory_resource {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1845.1">   void* do_allocate(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1846.1">      std::size_t bytes, std::size_t alignment</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1847.1">   ) override {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1848.1">       std::print ("do_allocate of {} bytes\n", bytes);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1849.1">       return upstream-&gt;allocate(bytes, alignment);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1850.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1851.1">   void do_deallocate(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1852.1">      void* p, std::size_t bytes, std::size_t alignment</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1853.1">   ) override {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1854.1">       std::print ("do_deallocate of {} bytes\n", bytes);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1855.1">       return upstream-&gt;deallocate(p, bytes, alignment);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1856.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1857.1">   bool do_is_equal(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1858.1">      const std::pmr::memory_resource&amp; other</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1859.1">   ) const noexcept override {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1860.1">       return upstream-&gt;is_equal(other);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1861.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1862.1">   std::pmr::memory_resource *upstream;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1863.1">public:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1864.1">   tracing_resource(std::pmr::memory_resource *upstream)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1865.1">      noexcept : upstream{ upstream } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1866.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1867.1">};</span></strong><span class="koboSpan" id="kobo.1868.1">
int main() {
   enum { N = 100 };
</span><strong class="bold"><span class="koboSpan" id="kobo.1869.1">   tracing_resource tracer{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1870.1">      std::pmr::new_delete_resource()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1871.1">   };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1872.1">   std::pmr::vector&lt;int&gt; v{ &amp;tracer };</span></strong><span class="koboSpan" id="kobo.1873.1">
   for (int i = 0; i != N; ++i)
      v.emplace_back(i + 1);
   for (auto s : v)
      std::print("{} ", s);
}</span></pre> <p><span class="koboSpan" id="kobo.1874.1">If you run this very simple program, you will develop an intuition for the growth strategy of your standard </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.1875.1">library </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">std::pmr::vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1877.1"> implementation.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.1878.1">Upsides and costs</span></h2>
<p><span class="koboSpan" id="kobo.1879.1">As we have seen, there’s</span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.1880.1"> a lot to love about the PMR model. </span><span class="koboSpan" id="kobo.1880.2">It is simple to use, relatively simple to understand, and easy to extend. </span><span class="koboSpan" id="kobo.1880.3">In many application domains, it is fast enough to meet most </span><span class="No-Break"><span class="koboSpan" id="kobo.1881.1">programmers’ needs.</span></span></p>
<p><span class="koboSpan" id="kobo.1882.1">There are, of course, also domains that need the increased control over execution time and runtime behavior that the traditional allocator model allows: no indirection that stems from the model, no overhead in terms of object size… Sometimes, you just need all the control you can get. </span><span class="koboSpan" id="kobo.1882.2">This means that both models work and have their own valid reasons </span><span class="No-Break"><span class="koboSpan" id="kobo.1883.1">for being.</span></span></p>
<p><span class="koboSpan" id="kobo.1884.1">One very real benefit of PMR allocators is that they make it easier to build allocator and resource libraries that one can combine and build from. </span><span class="koboSpan" id="kobo.1884.2">The standard library offers a few useful examples from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1885.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1886.1">memory_resource&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1887.1"> header:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1888.1">We have already seen function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1889.1">std::pmr::new_delete_resource()</span></strong><span class="koboSpan" id="kobo.1890.1">, which provides a system-wide resource where allocation and deallocation are implemented through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1891.1">::operator new()</span></strong><span class="koboSpan" id="kobo.1892.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1893.1">::operator delete()</span></strong><span class="koboSpan" id="kobo.1894.1">, just as we have seen class </span><strong class="source-inline"><span class="koboSpan" id="kobo.1895.1">std::pmr::monotonic_buffer_resource</span></strong><span class="koboSpan" id="kobo.1896.1">, which formalizes the process of sequential allocation within an </span><span class="No-Break"><span class="koboSpan" id="kobo.1897.1">existing buffer.</span></span></li>
<li><span class="koboSpan" id="kobo.1898.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1899.1">std::pmr::synchronized_pool_resource</span></strong><span class="koboSpan" id="kobo.1900.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1901.1">std::pmr::unsynchronized_pool_resource</span></strong><span class="koboSpan" id="kobo.1902.1"> classes model the allocation of objects from pools of blocks of some sizes. </span><span class="koboSpan" id="kobo.1902.2">Use the synchronized one for multithreaded code, </span><span class="No-Break"><span class="koboSpan" id="kobo.1903.1">of course.</span></span></li>
<li><span class="koboSpan" id="kobo.1904.1">There are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1905.1">std::pmr::get_default_resource()</span></strong><span class="koboSpan" id="kobo.1906.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1907.1">std::pmr::set_default_resource()</span></strong><span class="koboSpan" id="kobo.1908.1"> functions that respectively obtain or replace the default memory resource of a program. </span><span class="koboSpan" id="kobo.1908.2">The default memory resource is, as could be expected, the same as what is returned by </span><span class="No-Break"><span class="koboSpan" id="kobo.1909.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1910.1">std::pmr::new_delete_resource()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1911.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1912.1">There is also a function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1913.1">std::pmr::null_memory_resource()</span></strong><span class="koboSpan" id="kobo.1914.1"> that returns a resource that never allocates (its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1915.1">do_allocate()</span></strong><span class="koboSpan" id="kobo.1916.1"> member function, when called, throws </span><strong class="source-inline"><span class="koboSpan" id="kobo.1917.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.1918.1">). </span><span class="koboSpan" id="kobo.1918.2">This is interesting as an “upstream” measure: consider a sequential buffer allocator system implemented through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1919.1">std::pmr::monotonic_buffer_resource</span></strong><span class="koboSpan" id="kobo.1920.1"> in which a request for memory allocation leads to a possible buffer overflow. </span><span class="koboSpan" id="kobo.1920.2">Since, by default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">upstream</span></strong><span class="koboSpan" id="kobo.1922.1"> of a memory resource uses another resource that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1923.1">::operator new()</span></strong><span class="koboSpan" id="kobo.1924.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1925.1">::operator delete()</span></strong><span class="koboSpan" id="kobo.1926.1">, this potential overflow will lead to an actual allocation, which could have an undesirable impact on performance. </span><span class="koboSpan" id="kobo.1926.2">Choosing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1927.1">std::pmr::null_memory_resource</span></strong><span class="koboSpan" id="kobo.1928.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1929.1">upstream</span></strong><span class="koboSpan" id="kobo.1930.1"> resource ensures no such allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.1931.1">will occur.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1932.1">As we have seen and</span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.1933.1"> done, it is simple to add to this small set of memory resources and customize the behavior of your containers to suit your needs with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1934.1">PMR model.</span></span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1935.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1936.1">This has been an eventful chapter, has it not? </span><span class="koboSpan" id="kobo.1936.2">After venturing into explicit and implicit memory allocation implementations in </span><a href="B21071_12.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1937.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.1938.1"> and </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1939.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.1940.1">, this chapter explored allocators and how these facilities let us customize the behavior of memory allocation in containers to match </span><span class="No-Break"><span class="koboSpan" id="kobo.1941.1">our needs.</span></span></p>
<p><span class="koboSpan" id="kobo.1942.1">We saw how a traditional allocator, ensconced in the type of its enclosing container, can be implemented and used. </span><span class="koboSpan" id="kobo.1942.2">We did so with a container that trades in contiguous memory as well as with a node-based container. </span><span class="koboSpan" id="kobo.1942.3">We also looked at how the task of writing (and using) such allocators evolved through the years to become the contemporary traits-based allocators that implicitly synthesize default implementations for most </span><span class="No-Break"><span class="koboSpan" id="kobo.1943.1">allocator services.</span></span></p>
<p><span class="koboSpan" id="kobo.1944.1">We then looked at the more recent PMR allocator model that represents a different take on memory allocation and discussed its upsides and downsides. </span><span class="koboSpan" id="kobo.1944.2">Equipped with the knowledge in this chapter, you should have ideas of ways in which containers can be customized to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.1945.1">your needs.</span></span></p>
<p><span class="koboSpan" id="kobo.1946.1">We are nearing the end of our journey. </span><span class="koboSpan" id="kobo.1946.2">In our next (and last) chapter, we will look at some contemporary problems of memory allocation in C++ and start to think about what awaits us in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1947.1">near future.</span></span></p>
</div>
</body></html>