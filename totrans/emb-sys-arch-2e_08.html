<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor275"/>8</h1>
<h1 id="_idParaDest-179"><a id="_idTextAnchor276"/>Power Management and Energy Saving</h1>
<p>Energy efficiency has always been one of the leading factors in the microcontroller market. Since the early 2000s, signal-processing 16-bit RISC microcontrollers, such as the MSP430, have been designed for extremely low-power usage and are still leading the path of ultra-low-power optimization architectures in embedded systems.</p>
<p>In the last few years, more advanced 32-bit RISC microcontrollers, rich in features and capable of running real-time operating systems, have scaled down in size and power consumption, and set foot in the low-power and ultra-low-power domains. Battery-powered systems and devices relying on energy-harvesting techniques are becoming more and more common in many industries. Low-power wireless communication is now offered by a number of connected platforms, so an increasing number of IoT systems include low-power and ultra-low-power characteristics in their design.</p>
<p>Depending on the architecture, microcontrollers offer different strategies to reduce power consumption while running and implement low-power states that consume very little energy when activated.</p>
<p>Reducing the energy demand of an embedded system is often a tricky process. In fact, all the devices on the board may consume power if not deactivated properly. Generating high-frequency clocks is one of the most expensive operations, so the CPU and bus clocks should only be enabled when in use.</p>
<p>Researching the ideal strategy to save energy depends on the compromises that can be made between performance and energy saving. Microcontrollers designed for ultra-low-power applications are capable of slowing down the CPU frequency, and even reaching different variations of a hibernation state, where all the clocks are stopped and the external peripherals are turned off for maximum power savings.</p>
<p>With the appropriate energy profiling techniques, and by implementing ultra-low-power strategies, battery-powered devices can run for several years before needing to be replaced. Using alternative power sources, such as solar panels, heat-converting devices, or other forms of energy harvesting from the surrounding environment, a well-profiled embedded system may run indefinitely as long as the external conditions allow it.</p>
<p>Advanced microprocessors running at very high speeds are generally not designed to implement effective power consumption optimizations, which is what makes smaller, low-power microcontrollers such as the Cortex-M so popular in all those embedded systems where a small power footprint is one of the requirements.</p>
<p>In this chapter, we will highlight a few key practices when approaching the design of low-power and ultra-low-power embedded systems. Low-power extensions of the Cortex-M microcontroller are demonstrated as examples of real-life implementations of low-power optimization on real targets. The chapter is divided into three sections:</p>
<ul>
<li>System configuration</li>
<li>Low-power operating modes</li>
<li>Measuring power</li>
<li>Designing low-power embedded applications</li>
</ul>
<p>By the end of this chapter, you will have learned about the management of different low-power configurations for the microcontroller and peripherals.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor277"/>Technical requirements</h1>
<p>The code files for this chapter are available on GitHub at <a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8</a>.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor278"/>System configuration</h1>
<p>A system<a id="_idIndexMarker536"/> that includes power consumption constraints in its specifications must be designed to meet the requirements in all its aspects, including hardware, software, and mechanical design. The selection of components and peripherals must take into account their energy profiles. External peripherals are often the most power-demanding components, and thus their power source must be interrupted by the microcontroller when they are not being used.</p>
<p>This section will describe the best practices concerning peripheral configuration, system clock settings, and voltage control, and their impact on power consumption.<a id="_idTextAnchor279"/></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor280"/>Hardware design</h2>
<p>In low-power<a id="_idIndexMarker537"/> embedded systems, the hardware design must include the possibility to power peripherals on or off using a GPIO pin. This is better done using a line that is normally low so that it can be pulled down using passive components when the GPIO is not driven by the microcontroller. MOSFETs are often used to control the power supplied to external peripherals, using a GPIO signal to control the gate voltage.</p>
<p>Even when peripherals are turned off by interrupting their power source line, smaller currents may leak through other signals connected to them, such as a serial bus or other control signals. The hardware design must be able to detect and identify these leakages in early prototyping stages to minimize the energy lost this way.</p>
<p>Additionally, if the power-saving strategy includes the possibility to put the microprocessor into a deep-sleep operation mode, the logic of the input signals must be tailored to provide the correct wake-up events to resume normal operation. Signals that might not be driven while in sleep mode must maintain a known logic value enforced using passive components<a id="_idTextAnchor281"/>.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor282"/>Clock management</h2>
<p>Internal <a id="_idIndexMarker538"/>peripherals and interfaces that are not in use must also stay off. If the platform supports it, clock gating is generally the mechanism used to selectively control the clock source for each peripheral and interface on the system. Each clock line enabled in the system clock gating configuration increases the power usage. Furthermore, the higher the scaling factor applied to generate the CPU clock from a slow oscillator, the higher the energy required by the PLL. The PLL is one of the most power-demanding components of the system, and the power consumed by the CPU is also directly proportional to its clock frequency. Many CPUs are designed to run with a reduced clock speed, offering a range of possible trade-offs between performance and energy saving. Accordingly, the PLL can generally be reconfigured at runtime to adapt to different profiles. However, every change to the system clock requires a reconfiguration of all the clock dividers for all the timers and peripherals currently in use.</p>
<p>On the reference platform, we can reconfigure the CPU frequency at runtime to save a significant amount of power whenever the system does not require computing performance. To <a id="_idIndexMarker539"/>do this, the function in <code>system.c</code>, used to set the system clock in all the examples so far, has been modified to allow the selection of two different running frequencies. In performance mode, the system runs at its maximum frequency of 168 MHz. If the <code>powersave</code> flag argument is not zero, the clocks are configured to run at 48 MHz instead, for a more energy-efficient scenario:</p>
<pre class="source-code">
void clock_pll_on(int powersave)
{
  uint32_t reg32, plln, pllm, pllq,
      pllp, pllr, hpre, ppre1, ppre2,
      flash_waitstates;
  if (powersave) {
    cpu_freq = 48000000;
    pllm = 8;
    plln = 96;
    pllp = 2;
    pllq = 2;
    pllr = 0;
    hpre = RCC_PRESCALER_DIV_NONE;
    ppre1 = RCC_PRESCALER_DIV_4;
    ppre2 = RCC_PRESCALER_DIV_2;
    flash_waitstates = 5;
  } else {
    cpu_freq = 168000000;
    pllm = 8;
    plln = 336;
    pllp = 2;
    pllq = 7;
    pllr = 0;
    hpre = RCC_PRESCALER_DIV_NONE;
    ppre1 = RCC_PRESCALER_DIV_4;
    ppre2 = RCC_PRESCALER_DIV_2;
    flash_waitstates = 3;
  }</pre>
<p>The <a id="_idIndexMarker540"/>number of wait states for the <code>flash</code> operation has also been changed here, because, according to the documentation of the STM32F407, at 48 MHz, the flash only requires three wait states:</p>
<pre class="source-code">
 flash_set_waitstates(flash_waitstates);</pre>
<p>The procedure for setting the system clock is the usual one. First, the HSI is enabled and then selected as the temporary clock source. Afterward, the 8 MHz external oscillator is enabled, and it is ready to feed the PLL:</p>
<pre class="source-code">
 RCC_CR |= RCC_CR_HSION;
 DMB();
 while ((RCC_CR &amp; RCC_CR_HSIRDY) == 0) {};
 reg32 = RCC_CFGR;
 reg32 &amp;= ~((1 &lt;&lt; 1) | (1 &lt;&lt; 0));
 RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);
 DMB();
 RCC_CR |= RCC_CR_HSEON;
 DMB();
 while ((RCC_CR &amp; RCC_CR_HSERDY) == 0)
    ;</pre>
<p>The parameters <a id="_idIndexMarker541"/>for the clock divisors and multipliers for the chosen mode are set in the PLL configuration register, and the PLL is enabled:</p>
<pre class="source-code">
 reg32 = RCC_CFGR;
 reg32 &amp;= ~(0xF0);
 RCC_CFGR = (reg32 | (hpre &lt;&lt; 4));
 DMB();
 reg32 = RCC_CFGR;
 reg32 &amp;= ~(0x1C00);
 RCC_CFGR = (reg32 | (ppre1 &lt;&lt; 10));
 DMB();
 reg32 = RCC_CFGR;
 reg32 &amp;= ~(0x07 &lt;&lt; 13);
 RCC_CFGR = (reg32 | (ppre2 &lt;&lt; 13));
 DMB();
 reg32 = RCC_PLLCFGR;
 reg32 &amp;= ~(PLL_FULL_MASK);
 RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | pllm |
 (plln &lt;&lt; 6) | (((pllp &gt;&gt; 1) - 1) &lt;&lt; 16) | (pllq &lt;&lt; 24);
}</pre>
<p>Changing the CPU and system clocks means that all the peripherals that use the clocks must be reconfigured. If a timer is running, or any device using the clocks as reference is in use by the application, the pre-scaler register that is used for providing the timing reference must be adapted accordingly based on clock speed updates.</p>
<p>Running the<a id="_idIndexMarker542"/> system at a lower speed offers other benefits, such as the possibility to decrease the number of wait states required to access the flash memory and enable extra low-power features that are only available when the system is not running at full speed.</p>
<p>An embedded platform usually includes low-frequency clock generators, in the kHz range, which may be used as sources for time-keeping devices such as watchdogs and <strong class="bold">real-time clocks</strong> (<strong class="bold">RTCs</strong>). External <a id="_idIndexMarker543"/>or internal oscillators can be active during low-power operating modes and used to implement wake-up stra<a id="_idTextAnchor283"/>tegies.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor284"/>Voltage control</h2>
<p>Microcontrollers <a id="_idIndexMarker544"/>have a relatively wide range of operating voltages. Supplying lower voltages, however, makes it impossible to run the CPU at full speed, and flash memory may require additional wait states due to the physical characteristics of the hardware. Nevertheless, lower-voltage-tolerant logic can improve the overall economy of the system in some cases.</p>
<p>Internal regulators can often be configured to produce a lower voltage for the core signals, to reach a compromise between the power consumption and performance when the CPU is not running at its maximum frequency.</p>
<p>An important aspect that is often neglected is the power consumed by the Schmitt triggers in the digital input logic. When GPIOs are configured as digital input, but not forced to a known logic state through external passive components, they might be floating around the average value, due to the electromagnetic fields in the environment. This causes the input signal to be triggered, resulting in a little energy being lost at every change in the logi<a id="_idTextAnchor285"/>c state.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor286"/>Low-power operating modes</h1>
<p>Microcontrollers<a id="_idIndexMarker545"/> can execute in different power <a id="_idIndexMarker546"/>modes, switching from full performance to complete hibernation. A proper understanding of the microcontroller’s low-power modes is fundamental to designing systems with improved energy profiles. Each architecture provides specific power <a id="_idIndexMarker547"/>configurations, where the CPU or other buses and peripherals are disabled, as well as appropriate<a id="_idIndexMarker548"/> mechanisms to be used by the system software to enter and exit low-power modes.</p>
<p>In an ARM-based microcontroller, the terminology used for the different low-power modes can be summarized as follows:</p>
<ul>
<li><strong class="bold">Normal operation mode</strong>: Active <a id="_idIndexMarker549"/>components are selected through clock gating, and the clock is running at the desired frequency.</li>
<li><strong class="bold">Sleep mode</strong>: The CPU clock is temporarily suspended, but all the peripherals keep<a id="_idIndexMarker550"/> functioning as in normal mode. As long as the CPU is not executing, there is a noticeable, even if marginal, amount of power saved in this mode. Execution can be resumed after receiving an interrupt request. This mode is also referred to as <em class="italic">wait mode</em> by some chip manufacturers.</li>
<li><strong class="bold">Stop mode</strong>: The<a id="_idIndexMarker551"/> CPU clock and the bus clocks are disabled. All the peripherals powered by the microcontroller are off. The internal RAM and the CPU registers retain the stored values because the main voltage regulator stays on. The power consumption drops consistently, but it is still possible to wake up and resume the execution through an external interrupt or event. This mode is often also less appropriately called deep-sleep mode, although it is, in fact, one of two deep-sleep modes available.</li>
<li><strong class="bold">Standby mode</strong>: All the<a id="_idIndexMarker552"/> voltage regulators are off, and the content of the RAM and register is lost. A small amount of power, in the range of a few microwatts, may be required to keep the backup circuitry alive during the standby phase. Wake-up is then only possible under a few specific conditions, such as an externally powered RTC, or a hardware-predefined wake-up event pin. When the system wakes up from standby, the normal boot procedure is followed, and the execution resumes from the reset service routine.</li>
</ul>
<p>The ARMv7 microcode provides <a id="_idIndexMarker553"/>two instructions to enter<a id="_idIndexMarker554"/> low-power operating modes:</p>
<ul>
<li><strong class="bold">Wait for </strong><strong class="bold">interrupt</strong> (<strong class="bold">WFI</strong>)</li>
<li><strong class="bold">Wait for </strong><strong class="bold">event</strong> (<strong class="bold">WFE</strong>)</li>
</ul>
<p>These <a id="_idIndexMarker555"/>instructions<a id="_idIndexMarker556"/> can be invoked at any time while in normal running mode. <code>WFI</code> will put the system in a low-power mode until the next interrupt request is received, while <code>WFE</code> is slightly different. Only a few events in the system, including the external interrupts, can be configured to generate an event. Normal interrupt requests will not put the system back into normal running mode if it is in a sleep or stop mode that has been entered using <code>WFE</code>.</p>
<p>The low-power mode that is entered upon invocation depends on the settings stored in the <code>0xE000ED10</code>. The SCR only provides 3 meaningful <a id="_idIndexMarker558"/>1-bit flag fields:</p>
<ul>
<li><code>SLEEPONEXIT</code> (bit 1): When enabled, the system will go into low-power mode at the end of the execution of the next interrupt handler.</li>
<li><code>SLEEPDEEP</code> (bit 2): Determines which mode is entered upon the invocation of <code>WFI</code> or <code>WFE</code>, or when returning from an interrupt with <code>SLEEPONEXIT</code> active. If this bit is cleared, sleep mode is selected. When a low-power mode is entered with this bit active, the system will be put on stop or standby mode, depending on the configuration of the power management registers.</li>
<li><code>SEVONPEND</code> (bit 4): When this bit is active, any interrupt pending during a low-power mode will cause a wake-up event, regardless of whether the sleep mode or the stop mode was entered using a <code>WFI</code> or a <code>WFE</code> instruction.</li>
</ul>
<p>Note that bit 0, bit 3, and bits 5-31 are reserved (mus<a id="_idTextAnchor287"/>t be kept at value 0).</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor288"/>Deep-sleep configuration</h2>
<p>To select <a id="_idIndexMarker559"/>between stop and standby mode, and to set up certain parameters related to the deep-sleep modes, our reference platform provides a power controller, mapped in the internal peripherals region, at address <code>0x40007000</code>. The controller consists of two registers:</p>
<ul>
<li><code>PWR_CR</code> (control register) at an offset of <code>0</code></li>
<li><code>PWR_SCR</code> (status and control register) at an offset of <code>4</code></li>
</ul>
<p>The<a id="_idIndexMarker560"/> relevant parameters that can be configured in these two registers are the following:</p>
<ul>
<li><code>PWR_CR</code> bit 14. When<a id="_idIndexMarker561"/> active, saves extra power in normal running mode, by configuring the internal regulator to produce a slightly lower voltage for the CPU core logic. This feature is only available if the target is not running at maximum frequency.</li>
<li><code>PWR_CR</code> bit 9. If active<a id="_idIndexMarker562"/> while going into one of the deep-sleep modes, the flash will be turned off completely while the system is sleeping. This results in a moderate amount of power saved but also impacts the wake-up time.</li>
<li><code>PWR_CR</code>, bit 1. This bit determines <a id="_idIndexMarker563"/>which mode is entered when the CPU goes into a deep sleep. If cleared, stop mode is selected. If set, the system enters standby.</li>
<li><code>PWR_CR</code> bit 0. This bit only has an effect in<a id="_idIndexMarker564"/> stop mode. If enabled, it slightly reduces the energy used while in deep sleep by enabling the <em class="italic">under-drive</em> mode in the internal voltage regulator. The current is supplied to the core logic in a reduced leakage mode, which still allows you to preserve the content of memory and registers. This feature is only available if the system is not running at full speed.</li>
<li><code>PWR_CSR</code> bit 4. This flag determines<a id="_idIndexMarker565"/> whether the wake-up pin can be used as a normal GPIO, or whether it is reserved to detect a wake-up signal during standby. The pin associated with this function in the reference platform is PA0.</li>
</ul>
<p>A <code>PWR_CSR</code> bit 0. Writing <code>1</code> into <code>PWR_CR</code> bit 2 <code>CWUF</code>).</p>
<p>On the STM32F407 microcontroller, we can access the registers related to the low-power modes and configuration using the following macros:</p>
<pre class="source-code">
#define SCB_SCR (*(volatile uint32_t *)(0xE000ED10))
#define SCB_SCR_SEVONPEND (1 &lt;&lt; 4)
#define SCB_SCR_SLEEPDEEP (1 &lt;&lt; 2)
#define SCB_SCR_SLEEPONEXIT (1 &lt;&lt; 1)
#define POW_BASE (0x40007000)
#define POW_CR (*(volatile uint32_t *)(POW_BASE + 0x00))
#define POW_SCR (*(volatile uint32_t *)(POW_BASE + 0x04))
#define POW_CR_VOS (1 &lt;&lt; 14)
#define POW_CR_FPDS (1 &lt;&lt; 9)
#define POW_CR_CWUF (1 &lt;&lt; 2)
#define POW_CR_PDDS (1 &lt;&lt; 1)
#define POW_CR_LPDS (1 &lt;&lt; 0)
#define POW_SCR_WUF (1 &lt;&lt; 0)
#define POW_SCR_EWUP (1 &lt;&lt; 4)</pre>
<p>For the<a id="_idIndexMarker567"/> activation of the low-power modes, and the generation of spontaneous events, we define macros containing single inline assembly instructions as follows:</p>
<pre class="source-code">
#define WFI() asm volatile ("wfi")
#define WFE() asm volatile ("wfe")</pre>
<p>If sleep mode is entered through <code>WFI</code>, the system suspends the execution until the next interrupt. Entering sleep mode with <code>WFE</code> instead ensures that only selected <em class="italic">events</em> can wake up the system again. Events of different types that occur on the system can be enabled to wake up the <code>WFE</code>.</p>
<p>When <code>WFE</code> is entered, all interrupts active in the NVIC will still count as events, thereby waking <a id="_idIndexMarker568"/>up the <code>WFE</code> call. Interrupts can be temporarily filtered out by disabling the corresponding IRQ line in the NVIC. If an interrupt is filtered this way, using NVIC, it remains in a pending state and it is handled as soon as the system g<a id="_idTextAnchor289"/>oes back to normal running mode.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor290"/>Stop mode</h2>
<p>Sleep mode is<a id="_idIndexMarker569"/> entered by default every time that the <code>WFI</code> or <code>WFE</code> instructions are invoked, as long as <code>SCB_SCR_SLEEPDEEP</code> remains off. Other low-power modes can be enabled by enabling the <code>SLEEPDEEP</code> flag. To enter one of the available deep-sleep modes, the <code>SCB_SCR</code> and the POW registers must be configured before calling <code>WFI</code> or <code>WFE</code>. Depending on the configuration, the system enters one of the<a id="_idIndexMarker570"/> two deep-sleep modes, stop or standby.</p>
<p>In the following example, a continuous 1 Hz timer toggles the LED 10 times before switching to deep-sleep mode, using <code>WFE</code>. The <code>main</code> loop stays in sleep mode in between timer interrupts, using <code>WFI</code>:</p>
<pre class="source-code">
void main(void) {
  int sleep = 0;
  pll_on(0);
  button_setup();
  led_setup();
  timer_init(CPU_FREQ, 1, 1000);
  while(1) {
    if (timer_elapsed) {
      WFE(); /* consume timer event */
      led_toggle();
      timer_elapsed = 0;
    }
    if (tim2_ticks &gt; 10) {
      sleep = 1;
      tim2_ticks = 0;
    }
    if (sleep) {
      enter_lowpower_mode();
      WFE();
      sleep = 0;
      exit_lowpower_mode();
    } else
      WFI();
  }
}</pre>
<p>The<a id="_idIndexMarker571"/> interrupt service routine for the timer increases the <code>tim2_ticks</code> counter by <code>1</code> and sets the <code>timer_elapsed</code> flag, which will make the <code>main</code> loop toggle the LED and consume the event generated by the timer:</p>
<pre class="source-code">
void isr_tim2(void) {
  nvic_irq_clear(NVIC_TIM2_IRQN);
  TIM2_SR &amp;= ~TIM_SR_UIF;
  tim2_ticks++;
  timer_elapsed++;
}</pre>
<p>The <code>enter_lowpower_mode</code> procedure is responsible for setting the values in the system control block and in the power control registers, depending on the desired low-power mode, and<a id="_idIndexMarker572"/> configuring all the optimizations accordingly.</p>
<p>The <code>enter_lowpower_mode</code> procedure performs the following actions:</p>
<ol>
<li value="1">It turns off the LED.</li>
<li>It sets the values in <code>SCB_SCR</code> and the power register to configure the low-power mode that will be entered upon <code>WFE</code>.</li>
<li>It selects the single extra power optimizations.</li>
</ol>
<p>It is implemented as follows:</p>
<pre class="source-code">
void enter_lowpower_mode(void)
{
  uint32_t scr = 0;
  led_off();
  scr = SCB_SCR;
  scr &amp;= ~SCB_SCR_SEVONPEND;
  scr |= SCB_SCR_SLEEPDEEP;
  scr &amp;= ~SCB_SCR_SLEEPONEXIT;
  SCB_SCR = scr;
  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | POW_CR_LPDS;
}</pre>
<p>In this case, stop mode is configured to reduce power consumption as much as possible, by activating the low-power voltage regulator settings (through <code>POW_CR_LPDS</code>) and by turning off the flash (through <code>POW_CR_FPDS</code>).</p>
<p>Low-power mode is now entered through a <code>WFE()</code> call. To be able to wake up the system, we configure an <code>EXTI</code> event, which is associated with the user pressing a button on the board. To do so, we configure <code>EXTI0</code> to be sensitive to raised edges, as the PA0 pin changes its logical value from <code>0</code> to <code>1</code> upon being pressed.</p>
<p>As we are not<a id="_idIndexMarker573"/> particularly interested in the interrupt itself, we ensure that the flag to generate an interrupt request is turned off in <code>EXTI</code>. The event controller will ensure that an event is generated instead because the flag relative to the input pin is enforced in the <code>EXTI_EMR</code> register.</p>
<p>The initial configuration for the user button event looks like the following:</p>
<pre class="source-code">
void button_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
  APB2_CLOCK_ER |= SYSCFG_APB2_CLOCK_ER;
  GPIOA_MODE &amp;= ~ (0x03 &lt;&lt; (BUTTON_PIN * 2));
  EXTI_CR0 &amp;= ~EXTI_CR_EXTI0_MASK;
  EXTI_IMR &amp;= ~0x7FFFFF;
  reg = EXTI_EMR &amp; ~0x7FFFFF;
  EXTI_EMR = reg | (1 &lt;&lt; BUTTON_PIN);
  reg = EXTI_RTSR &amp; ~0x7FFFFF;
  EXTI_RTSR = reg | (1 &lt;&lt; BUTTON_PIN);
  EXTI_FTSR &amp;= ~0x7FFFFF;
}</pre>
<p>No interrupts are configured for the button, as the event alone is sufficient to wake up the board during stop mode.</p>
<p>Upon entering stop mode, the PLL will be disabled, and the HSI will be automatically selected as the clock source when the system is back in normal running mode. To restore the clock configuration, there are a few steps to implement as soon as stop mode is exited:</p>
<ol>
<li value="1"><code>SCB_SCR_SLEEPDEEP</code> flag is cleared so that the next invocation of <code>WFI</code> or <code>WFE</code> does not trigger another switch to stop mode.</li>
<li>The <code>POW_CR</code> register is accessed to clear the wake-up flag set by the hardware at the end of the stop mode.</li>
<li>The<a id="_idIndexMarker574"/> PLL is configured again, as the clock is restored.</li>
<li>The LED is turned on.</li>
<li>The <code>TIM2</code> interrupt is enabled again for the timer to restore its functionality in normal running mode:<pre class="console">
void exit_lowpower_mode(void)</pre><pre class="console">
{</pre><pre class="console">
  SCB_SCR &amp;= ~SCB_SCR_SLEEPDEEP;</pre><pre class="console">
  POW_CR |= POW_CR_CWUF | POW_CR_CSBF;</pre><pre class="console">
  clock_pll_on(0);</pre><pre class="console">
  timer_init(cpu_freq, 1, 1000);</pre><pre class="console">
  led_on();</pre><pre class="console">
}</pre></li>
</ol>
<p>Deep-sleep mode reduces the power consumption consistently, and it is the ideal situation whenever the system must maintain the current running status <a id="_idTextAnchor291"/>but can be frozen for a longer period.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor292"/>Standby mode</h2>
<p>In<a id="_idIndexMarker575"/> standby mode, the system can go into ultra-low-power mode, consuming only a few microamperes, while waiting to be reinitialized by an external event. Entering standby mode requires you to set the <code>SCB_SCR_PDDS</code> flag prior to invoking <code>WFI</code> or <code>WFE</code>. While the system is on standby, all the voltage regulators are off, except for the low-speed oscillators, which are used to clock the independent watchdog timer and the real-time clock.</p>
<p>The procedure to enter standby mode is slightly different from the one used to enter stop mode. The <code>SCB_SCR_PDDS</code> flag is set to select standby mode as a deep-sleep variant. The flag <code>SCB_SCR_LPDS</code> is not activated in this case, because we know it has no effect in standby mode:</p>
<pre class="source-code">
void enter_lowpower_mode(void)
{
  uint32_t scr = 0;
  led_off();
  scr = SCB_SCR;
  scr &amp;= ~SCB_SCR_SEVONPEND;
  scr |= SCB_SCR_SLEEPDEEP;
  scr &amp;= ~SCB_SCR_SLEEPONEXIT;
  SCB_SCR = scr;
  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | <strong class="bold">POW_CR_PDDS</strong>;
  POW_SCR |= POW_CR_CSBF;
}</pre>
<p>In this case, it is useless to set up the <code>EXTI</code> event for the button press, as the GPIO controllers will be disabled while the microcontroller is in standby mode. The easiest way to exit this state is configuring the real-time clock to generate a wake-up event after a fixed amount of time. In fact, during the standby phase, only a few peripherals will be kept alive, and they are all grouped in a special section of the clock configuration, namely the backup domain. The backup domain consists of the real-time clock and a small portion of the clock tree, containing the internal and external low-speed oscillators. The write access to the registers related to the backup domain is controlled by the flag disabling protection of the backup domain, or <code>POW_CR_DPB</code>, located in the <code>POW_CR</code> register at bit 8.</p>
<p>The RTC configuration registers, mapped in the peripherals area starting at address <code>0x40002870</code>, are protected from accidental writing due to electromagnetic interference, meaning that a special value sequence must be written to the write protection register before accessing the other registers. The RTC integrated into the reference platform is complex and has a lot of features, such as keeping track of date and time, and setting custom alarms and regular timestamp events. For this example, we want <a id="_idIndexMarker576"/>to use only the wake-up event, so most of the RTC registers are not documented here.</p>
<p>The restricted set of registers we access for RTC is as follows:</p>
<ul>
<li>The control register (<code>RTC_CR</code>) exposes the configuration of the various functionalities provided by the RTC. In the example, we use the values related to the wake-up trigger, enabling the interrupt with the wake-up timer interrupt enable flag, <code>RTC_CR_WUTIE</code>, and enabling the wake-up timer counter also using <code>RTC_CR_WUTE</code>.</li>
<li>The initialization and status register (<code>RTC_ISR</code>) in this example is used to check the write status of the setup register for the wake-up timer through the special flag, <code>RTC_ISR_WUTWF</code>, during the timer setup.</li>
<li>The wake-up timer register (<code>RTC_WUTR</code>) is used to set the interval before the next wake-up event.</li>
<li>The write protection register (<code>RTC_WPR</code>) is used to transmit the unlock sequence before writing to other registers in the region.</li>
</ul>
<p>The preprocessor macros that map these registers and the meaningful fields are as follows:</p>
<pre class="source-code">
#define RTC_BASE (0x40002800)
#define RTC_CR (*(volatile uint32_t *)(RTC_BASE + 0x08))
#define RTC_ISR (*(volatile uint32_t *)(RTC_BASE + 0x0c))
#define RTC_WUTR (*(volatile uint32_t *)(RTC_BASE + 0x14))
#define RTC_WPR (*(volatile uint32_t *)(RTC_BASE + 0x24))
#define RTC_CR_WUP (0x03 &lt;&lt; 21)
#define RTC_CR_WUTIE (1 &lt;&lt; 14)
#define RTC_CR_WUTE (1 &lt;&lt; 10)
#define RTC_ISR_WUTF (1 &lt;&lt; 10)
#define RTC_ISR_WUTWF (1 &lt;&lt; 2)</pre>
<p>The procedure<a id="_idIndexMarker577"/> to initialize the RTC to generate a wake-up event includes the following steps:</p>
<ol>
<li value="1">Turn on the clock gating for the power configuration registers, if not already on, to enable the <code>POW_CR_DPB</code> flag, in order to initiate the setup of the RTC:<pre class="console">
void rtc_init(void) {</pre><pre class="console">
   APB1_CLOCK_ER |= PWR_APB1_CLOCK_ER_VAL;</pre><pre class="console">
   POW_CR |= POW_CR_DPB;</pre></li>
<li>Enable the RTC using bit 15 in the backup domain register configuration within the RCC:<pre class="console">
   RCC_BACKUP |= RCC_BACKUP_RTCEN;</pre></li>
<li>Enable a <a id="_idIndexMarker578"/>backup clock source, selecting from the <strong class="bold">Low-Speed Internal</strong> (<strong class="bold">LSI</strong>) oscillator <a id="_idIndexMarker579"/>or a <strong class="bold">Low-Speed External</strong> (<strong class="bold">LSE</strong>) oscillator, if available.</li>
<li>In this example, we use the LSI oscillator because the LSE oscillator is not present on the reference platform. However, external oscillators are more accurate and are always preferable, when available, for reliable timekeeping. After the clock has been enabled, the procedure waits until it becomes ready by polling a bit in the status register:<pre class="console">
   RCC_CSR |= RCC_CSR_LSION;</pre><pre class="console">
   while (!(RCC_CSR &amp; RCC_CSR_LSIRDY))</pre><pre class="console">
     ;</pre></li>
<li>Select the LSI as the source for the RTC:<pre class="console">
  RCC_BACKUP |= (RCC_BACKUP_RTCSEL_LSI &lt;&lt; </pre><pre class="console">
      RCC_BACKUP_RTCSEL_SHIFT);</pre></li>
<li>Enable the interrupt and event generation for line <code>22</code> of <code>EXTI</code>, associating an event with the raised edge:<pre class="console">
  EXTI_IMR |= (1 &lt;&lt; 22);</pre><pre class="console">
  EXTI_EMR |= (1 &lt;&lt; 22);</pre><pre class="console">
  EXTI_RTSR |= (1 &lt;&lt; 22);</pre></li>
<li>Unlock<a id="_idIndexMarker580"/> the writing to the RTC registers by writing the unlock sequence to <code>RTC_WPR</code>:<pre class="console">
  RTC_WPR = 0xCA;</pre><pre class="console">
  RTC_WPR = 0x53;</pre></li>
<li>Disable the RTC so that it is permitted to write to the configuration registers. Wait until the write operation is possible, by polling <code>RTC_ISR_WUTWF</code>:<pre class="console">
   RTC_CR &amp;= ~RTC_CR_WUTE;</pre><pre class="console">
   DMB();</pre><pre class="console">
   while (!(RTC_ISR &amp; RTC_ISR_WUTWF))</pre><pre class="console">
     ;</pre></li>
<li>Set the value for the interval before the next wake-up event. The LSI frequency is 32,768 Hz, and the default divider for the wake-up interval register is set to 16, so each unit in <code>RTC_WUTR</code> represents one <code>2048</code>th of a second. To set an interval of <code>5</code> seconds, we use the following:<pre class="console">
  RTC_WUTR = (2048 * 5) – 1;</pre></li>
<li>Enable the wake-up event:<pre class="console">
  RTC_CR |= RTC_CR_WUP;</pre></li>
<li>Clear the wake-up flag that might have been set when returning from standby mode:<pre class="console">
  RTC_ISR &amp;= ~RTC_ISR_WUTF;</pre></li>
<li>To complete the sequence, we write an invalid byte to <code>RTC_WPR</code>. This way, the write protection on the RCC register is turned on again:<pre class="console">
   RTC_WPR = 0xb0;</pre><pre class="console">
}</pre></li>
<li>To <a id="_idIndexMarker581"/>enable the RTC, right before entering standby mode, the following procedure ensures that the timer is active and counting and the event generation for the wake-up event is active:<pre class="console">
void rtc_start(void)</pre><pre class="console">
{</pre><pre class="console">
   RTC_WPR = 0xCA;</pre><pre class="console">
   RTC_WPR = 0x53;</pre><pre class="console">
   RTC_CR |= RTC_CR_WUTIE |RTC_CR_WUTE;</pre><pre class="console">
   while (((RTC_ISR) &amp; (RTC_ISR_WUTWF)))</pre><pre class="console">
     ;</pre><pre class="console">
   RTC_WPR = 0xb0;</pre><pre class="console">
}</pre></li>
</ol>
<p>If the procedure just shown is called before entering standby, the system will be up again when the wake-up event occurs, but it does not resume the execution from where it was suspended, as it happens in the other low-power modes. Instead, it starts over from the reset interrupt handler, at the beginning of the interrupt vector. For this reason, this example does not need an implementation for <code>exit_lowpower_mode</code>, and the <code>WFE</code> instruction that switches the system to standby will never return to the same context of execution. Eventually, the <code>main</code> function for the standby example looks like the <a id="_idIndexMarker582"/>following:</p>
<pre class="source-code">
void main(void) {
  int sleep = 0;
  clock_pll_on(0);
  led_setup();
  rtc_init();
  timer_init(cpu_freq, 1, 1000);
  while(1) {
    if (timer_elapsed) {
      WFE(); /* Consume timer event */
      led_toggle();
      timer_elapsed = 0;
    }
    if (tim2_ticks &gt; 10) {
      sleep = 1;
      tim2_ticks = 0;
    }
    if (sleep) {
      enter_lowpower_mode();
      <strong class="bold">rtc_start();</strong>
      <strong class="bold">WFE(); /* Neve<a id="_idTextAnchor293"/>r returns */</strong>
    }
    else
      WFI();
  }
}</pre>
<h2 id="_idParaDest-189"><a id="_idTextAnchor294"/>Wake-up intervals</h2>
<p>An<a id="_idIndexMarker583"/> important aspect to consider when designing a low-power strategy is <a id="_idIndexMarker584"/>the wake-up time intervals, or, in other words, how long the system takes to resume the execution after switching into low-power mode. A system with real-time requirements may leave some room for compromises between power usage and reactivity, but it is important to understand the impact of the wake-up operations from the different low-power modes, in order to predict the latency of operations in the worst-case scenario. Wake-up times are very much conditioned by the hardware design of the microcontroller, and largely dependent on the architecture.</p>
<p>On our reference platform, while waking up from sleep mode takes a small number of CPU cycles, the situation changes for deep-sleep modes. Waking up from stop mode takes several microseconds. Further optimizations that have been activated while in stop mode, such as changing voltage regulators or turning off the flash memory, consistently impact the amount of time spent restoring the values to return to normal running. Resetting after standby mode produces even longer wake-up intervals, in the order of milliseconds, as the system should completely reboot after a wake-up event, and the start-up code execution time adds up to the fraction of milliseconds needed by the CPU to wake up.</p>
<p>When designing a low-power system, these wake-up times must be taken into account and properly measured, especially when the system has to deal with real-time constraints. The optimal low-power mode that fits the application timing and energy profile requirements must be chosen, taking into account the overhead produced by leaving low-power mode if the system wakes up often enough for these intervals to become non-negligible.</p>
<p>Once the system is designed to operate in the appropriate low-power modes, we need a reliable mechanism to measure the power used by the system while it is running. The next section suggests a common mechanism to keep track of the current values through the circuit under test to measure the effects of the low-power operating modes of the microcontroller, and for the evaluatio<a id="_idTextAnchor295"/>n of all energy-saving optimizations introduced.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor296"/>Measuring power</h1>
<p>The<a id="_idIndexMarker585"/> current in use by the target can be measured <a id="_idIndexMarker586"/>at any time by connecting an ammeter in series with the device. This mechanism, however, does not show all the oscillations of the values during a time interval, which is why it is often useful to sample the values of the parasitic voltage at the ends of a shunt resistor using an oscilloscope.</p>
<p>A shunt resistor is placed in series with the target device, on either side of the power source. Its typical value is relatively small, in the range of a few ohms, to ensure that the parasite voltage stays low, but is still measurable by the oscilloscope:</p>
<div><div><img alt="Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage applied to the shunt resistor" src="img/B18730_08_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage applied to the shunt resistor</p>
<p>Due to the properties of a series circuit, the current running through the shunt is the same as the one used by the target system, so the voltage on t<a id="_idTextAnchor297"/>he ends of the shunt resistor varies accordingly.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor298"/>Development boards</h2>
<p>In order<a id="_idIndexMarker587"/> to see the effects of the power optimizations, we must<a id="_idIndexMarker588"/> exclude the electronics that are not related to the system. Our <a id="_idIndexMarker589"/>reference board, for example, the STM32F407DISCOVERY, has an additional microcontroller that is used to provide a debug interface for the host, and it is powered using the same USB connector. However, development kits often offer a way to measure <a id="_idIndexMarker590"/>the current, excluding the unrelated hardware, allowing us to properly evaluate the low-power features of the microcontroller, excluding the development-related circuitry on board.</p>
<p>On our<a id="_idIndexMarker591"/> reference board, the JP1 jumper can be used to open the circuit between the power supply and the microcontroller circuitry. By replacing the jumper with an ammeter connected to the two pins, we can measure the current used by the actual system. In the same way, it is possible to apply a shunt resistor to monitor the current, using the oscilloscope to sample the voltage on the shunt.</p>
<p>A lab equipped with reliable energy metering is a good starting point for evaluating low-power implementations and assisting in <a id="_idTextAnchor299"/>the prototype and design phase of energy optimization.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor300"/>Designing low-power embedded applications</h1>
<p>In this<a id="_idIndexMarker592"/> section, a few design patterns are proposed to achieve a better energy profile on the target device, by evaluating the power demand of all the components and the states of the system we are about to design. Once we know how to measure the values in the target, and the details about the low-power mode in the selected architecture and microprocessor family, the application can be programmed, keeping other parameters in mind, such a<a id="_idTextAnchor301"/>s the energy efficiency of the software we are writing.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor302"/>Replacing busy loops with sleep mode</h2>
<p>The <a id="_idIndexMarker593"/>reason busy loops are very popular among hobbyists is that they are so easy to implement. Suppose that the system needs to wait for a digital input to switch to a low-logic state, and this input is mapped to a certain GPIO. This can be easily done with the following one line of code:</p>
<pre class="source-code">
while((GPIOX_IDR &amp; (1 &lt;&lt; INPUT_PINX)) != 0)
  ;</pre>
<p>While this is perfectly working as expected, it will force the CPU into a loop of fetch-decode-execute, and to jump around the same few instructions until the condition becomes <code>false</code>. As we have seen, the power used by the microcontroller mostly depends on how fast the CPU is running. A lower frequency corresponds to a smaller amount of power used per instruction. Executing instructions in an infinite loop without switching to low-power mode sets the power demand from the CPU at its highest value for a measurable amount of time – in this case, the entire time needed for the logic input to change state.</p>
<p>Actively<a id="_idIndexMarker594"/> polling a value is the only way to go if interrupts are not enabled. The examples contained in this book tend to guide you toward a proper interrupt-handling approach. The proper way to handle the wait for the logic switch instead foresees the activation of an interrupt line related to the next operation. In the case of a GPIO line, we can use external interrupt triggers to wake up the main loop when the condition is met, and switch to a low-power mode, instead of looping, while waiting for the event.</p>
<p>In many other cases, the temptation to implement loops such as the previous one could be avoided by investigating another way to access the peripheral that is currently preventing the system from carrying out the next execution step. Modern serial and network controllers are equipped with interrupt signals, and when those are not available for the hardware we are accessing, there is always another way to sense an event through an external interrupt line. When a device can really only function in polling mode, as a last resort, the polling frequency can be reduced by associating the action with a timer interrupt, which would allow polling a few times per second, or even once in a while, using intervals that are more in line with the actual peripheral speed. Executing timed operations allows the CPU to sleep in between, and to switch to a low-power mode, reducing the average energy that the CPU would need to use while busy-looping.</p>
<p>The exception to this rule, seen many times in this chapter, is waiting for a ready flag after activating a system component. The following code activates the internal low-speed oscillator, and it is used in the standby mode example before entering low-speed mode. The CSR register is polled until the low-speed oscillator is actually running:</p>
<pre class="source-code">
RCC_CSR |= RCC_CSR_LSION;
while (!(RCC_CSR &amp; RCC_CSR_LSIRDY))
   ;</pre>
<p>Operations such as this, performed on the integrated peripherals in the microcontroller silicon, have a well-known latency of a few CPU clocks, and thus do not impact the real-time constraints, as the maximum latency for similar internal actions is often mentioned in the <a id="_idIndexMarker595"/>microcontroller documentation. The situation changes whenever the polling occurs on a less predictable register, whose state and reaction times may depend on exte<a id="_idTextAnchor303"/>rnal factors, and long busy loops may occur in the system.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor304"/>Deep sleep during longer inactivity periods</h2>
<p>As we <a id="_idIndexMarker596"/>know, standby allows the system to be frozen with the minimum possible power consumption, in the ultra-low-power range. The use of standby is advised when the design has very strict ultra-low-power requirements and the following conditions are met:</p>
<ul>
<li>A viable wake-up strategy exists and is compatible with the current hardware design</li>
<li>The system can restore the execution without relying on its previous state, as the content of the RAM and CPU registers is lost and the system restarts from the reset service routine at wake-up</li>
</ul>
<p>Usually, longer periods of inactivity, where, for instance, the RTC can be used to program a wake-up alarm at a given time, are more fit for using standby mode. This applies to cases such as reading sensors and enabling actuators at programmed intervals during the day, keeping track of the time and a few status variables.</p>
<p>In most other cases, stop mode still saves enough power and provides a shorter wake-up interval. Another major advantage of stop mode is the increased flexibility of the wake-up strategy options. In fact, any interrupt-based or configurable event can be used to wake up the system from its low-power deep-sleep mode, so it is more fit for states where there is still some asynchronous interactivity with the <a id="_idTextAnchor305"/>peripherals and interfaces surrounding the microcontroller.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor306"/>Choosing the clock speed</h2>
<p>Is all the computing power offered by the platform actually needed all the time?</p>
<p>The <a id="_idIndexMarker597"/>processing performance of microcontrollers nowadays is comparable to that of the personal computers of 20 years ago, which were already capable of fast operations and even processing real-time multimedia content. Embedded applications do not always require the CPU to run at full frequency. Especially when accessing peripherals, rather than crunching numbers, it does not matter how fast we clock the CPU and the bus. Both normal running mode and sleep mode require much less energy when the selected frequency is scaled down every single time the CPU performance is not actually the bottleneck of the execution pipe.</p>
<p>Many microcontrollers are designed to scale down the operating frequency for the CPU and the internal buses, which also generally allows the system to be fed with lower voltages. As we have seen, changing clocks can be done at runtime to compromise accordingly in terms of power and performance. However, this implies that all the devices using a clock as a reference must be reconfigured, so the change has a cost in terms of execution time and should not be abused. A convenient way to add frequency changes to the system design is to separate two or more CPU frequency scaling options into custom power states and switch to the r<a id="_idTextAnchor307"/>equired state by fading between performance and power usage.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor308"/>Power state transitions</h2>
<p>Consider<a id="_idIndexMarker598"/> a system connected to a sensor, producing and transmitting data through a network interface. The sensor is activated, then the system has to wait until it becomes ready, which is known to take several seconds. The sensor is then read multiple times in a row and then turned off. The data is processed, encrypted, and transmitted using a network device. The system remains idle for the next few hours before repeating the same operation. Initial rough modeling of the state machine is the following:</p>
<div><div><img alt="Figure 8.2 – State machine for a hypothetical sensor-reading system" src="img/B18730_08_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – State machine for a hypothetical sensor-reading system</p>
<p>The<a id="_idIndexMarker599"/> long idle interval foreseen in between two consecutive cycles suggests that it is perhaps a good idea to put the system on standby for most of the time and program an RTC alarm for the system to autonomously wake up in time for the next acquisition.</p>
<p>Other, less obvious optimizations are possible for the other states as well. While acquiring data from the sensor, the full computing power of the CPU is possibly never used, as the system is mostly busy communicating with the sensor, or waiting, possibly in sleep mode, until the next value is received. In this case, we can provide a power-saving running mode, which ensures that the system runs at a reduced frequency so, when alternating between running and sleep mode, both are affected by a smaller energy footprint. The only phases in which higher performance is required are when the data is processed, transformed, and sent over the network device. A faster system, in this case, would be optimized to run faster and elaborate data in a shorter time frame. A stop phase can be foreseen right after the sensor activation if the sensor is able to send an interrupt to wake up the system when it is ready to begin the acquisition of the data.</p>
<p>Once each phase has been associated with its optimized low-power mode and selected operating frequency, we can add notations to our design documentation, to remind us how the low-power optimization will be implemented, in the form of state transition, to achieve the best combination of performance, energy economy, and low latency. The following figure summarizes the transitions between the phases and the associated low-power modes:</p>
<div><div><img alt="Figure 8.3 – Power usage optimization for each running and idling state" src="img/B18730_08_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Power usage optimization for each running and idling state</p>
<p>Tuning <a id="_idIndexMarker600"/>an embedded system for its optimal energy profiles is a delicate process that heavily impacts other performance indicators, introducing delays and slowing down the speed of execution. In most cases, it consists of finding the best trade-off point between providing acceptable performance while keeping th<a id="_idTextAnchor309"/>e power usage and the energy demand within the desired range.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor310"/>Summary</h1>
<p>Modern embedded systems open multiple possibilities for low-power and even ultra-low-power designs. This chapter analyzed the different energy profiles available for the reference microcontroller and how to design, integrate, and evaluate those procedures to control power usage in energy-aware embedded systems. Having understood several options available for the target, implementing low-power modes and further types of energy-saving techniques is the key to building durable and reliable battery-powered and energy-harvesting devices.</p>
<p>In the next chapter, we will switch focus to introducing connected devices and describing the impact of dealing with network protocols and interfaces in the embedded system architecture.</p>
</div>
</body></html>