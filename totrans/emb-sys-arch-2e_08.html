<html><head></head><body>
<div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-179"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.2.1">Power Management and Energy Saving</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Energy efficiency has always been one of the leading factors in the microcontroller market. </span><span class="koboSpan" id="kobo.3.2">Since the early 2000s, signal-processing 16-bit RISC microcontrollers, such as the MSP430, have been designed for extremely low-power usage and are still leading the path of ultra-low-power optimization architectures in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In the last few years, more advanced 32-bit RISC microcontrollers, rich in features and capable of running real-time operating systems, have scaled down in size and power consumption, and set foot in the low-power and ultra-low-power domains. </span><span class="koboSpan" id="kobo.5.2">Battery-powered systems and devices relying on energy-harvesting techniques are becoming more and more common in many industries. </span><span class="koboSpan" id="kobo.5.3">Low-power wireless communication is now offered by a number of connected platforms, so an increasing number of IoT systems include low-power and ultra-low-power characteristics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">their design.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Depending on the architecture, microcontrollers offer different strategies to reduce power consumption while running and implement low-power states that consume very little energy </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">when activated.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Reducing the energy demand of an embedded system is often a tricky process. </span><span class="koboSpan" id="kobo.9.2">In fact, all the devices on the board may consume power if not deactivated properly. </span><span class="koboSpan" id="kobo.9.3">Generating high-frequency clocks is one of the most expensive operations, so the CPU and bus clocks should only be enabled when </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">in use.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Researching the ideal strategy to save energy depends on the compromises that can be made between performance and energy saving. </span><span class="koboSpan" id="kobo.11.2">Microcontrollers designed for ultra-low-power applications are capable of slowing down the CPU frequency, and even reaching different variations of a hibernation state, where all the clocks are stopped and the external peripherals are turned off for maximum </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">power savings.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">With the appropriate energy profiling techniques, and by implementing ultra-low-power strategies, battery-powered devices can run for several years before needing to be replaced. </span><span class="koboSpan" id="kobo.13.2">Using alternative power sources, such as solar panels, heat-converting devices, or other forms of energy harvesting from the surrounding environment, a well-profiled embedded system may run indefinitely as long as the external conditions </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">allow it.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Advanced microprocessors running at very high speeds are generally not designed to implement effective power consumption optimizations, which is what makes smaller, low-power microcontrollers such as the Cortex-M so popular in all those embedded systems where a small power footprint is one of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">the requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we will highlight a few key practices when approaching the design of low-power and ultra-low-power embedded systems. </span><span class="koboSpan" id="kobo.17.2">Low-power extensions of the Cortex-M microcontroller are demonstrated as examples of real-life implementations of low-power optimization on real targets. </span><span class="koboSpan" id="kobo.17.3">The chapter is divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">three sections:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">System configuration</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Low-power </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">operating modes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Measuring power</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Designing low-power </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">embedded applications</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.25.1">By the end of this chapter, you will have learned about the management of different low-power configurations for the microcontroller </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">and peripherals.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">The code files for this chapter are available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">at </span></span><a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.32.1">System configuration</span></h1>
<p><span class="koboSpan" id="kobo.33.1">A system</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.34.1"> that includes power consumption constraints in its specifications must be designed to meet the requirements in all its aspects, including hardware, software, and mechanical design. </span><span class="koboSpan" id="kobo.34.2">The selection of components and peripherals must take into account their energy profiles. </span><span class="koboSpan" id="kobo.34.3">External peripherals are often the most power-demanding components, and thus their power source must be interrupted by the microcontroller when they are not </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">being used.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">This section will describe the best practices concerning peripheral configuration, system clock settings, and voltage control, and their impact on </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">power consumption.</span></span><a id="_idTextAnchor279"/></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.38.1">Hardware design</span></h2>
<p><span class="koboSpan" id="kobo.39.1">In low-power</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.40.1"> embedded systems, the hardware design must include the possibility to power peripherals on or off using a GPIO pin. </span><span class="koboSpan" id="kobo.40.2">This is better done using a line that is normally low so that it can be pulled down using passive components when the GPIO is not driven by the microcontroller. </span><span class="koboSpan" id="kobo.40.3">MOSFETs are often used to control the power supplied to external peripherals, using a GPIO signal to control the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">gate voltage.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Even when peripherals are turned off by interrupting their power source line, smaller currents may leak through other signals connected to them, such as a serial bus or other control signals. </span><span class="koboSpan" id="kobo.42.2">The hardware design must be able to detect and identify these leakages in early prototyping stages to minimize the energy lost </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">this way.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Additionally, if the power-saving strategy includes the possibility to put the microprocessor into a deep-sleep operation mode, the logic of the input signals must be tailored to provide the correct wake-up events to resume normal operation. </span><span class="koboSpan" id="kobo.44.2">Signals that might not be driven while in sleep mode must maintain a known logic value enforced using </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">passive components</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.46.1">.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.47.1">Clock management</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Internal </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.49.1">peripherals and interfaces that are not in use must also stay off. </span><span class="koboSpan" id="kobo.49.2">If the platform supports it, clock gating is generally the mechanism used to selectively control the clock source for each peripheral and interface on the system. </span><span class="koboSpan" id="kobo.49.3">Each clock line enabled in the system clock gating configuration increases the power usage. </span><span class="koboSpan" id="kobo.49.4">Furthermore, the higher the scaling factor applied to generate the CPU clock from a slow oscillator, the higher the energy required by the PLL. </span><span class="koboSpan" id="kobo.49.5">The PLL is one of the most power-demanding components of the system, and the power consumed by the CPU is also directly proportional to its clock frequency. </span><span class="koboSpan" id="kobo.49.6">Many CPUs are designed to run with a reduced clock speed, offering a range of possible trade-offs between performance and energy saving. </span><span class="koboSpan" id="kobo.49.7">Accordingly, the PLL can generally be reconfigured at runtime to adapt to different profiles. </span><span class="koboSpan" id="kobo.49.8">However, every change to the system clock requires a reconfiguration of all the clock dividers for all the timers and peripherals currently </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">in use.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">On the reference platform, we can reconfigure the CPU frequency at runtime to save a significant amount of power whenever the system does not require computing performance. </span><span class="koboSpan" id="kobo.51.2">To </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.52.1">do this, the function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">system.c</span></strong><span class="koboSpan" id="kobo.54.1">, used to set the system clock in all the examples so far, has been modified to allow the selection of two different running frequencies. </span><span class="koboSpan" id="kobo.54.2">In performance mode, the system runs at its maximum frequency of 168 MHz. </span><span class="koboSpan" id="kobo.54.3">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">powersave</span></strong><span class="koboSpan" id="kobo.56.1"> flag argument is not zero, the clocks are configured to run at 48 MHz instead, for a more </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">energy-efficient scenario:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
void clock_pll_on(int powersave)
{
  uint32_t reg32, plln, pllm, pllq,
      pllp, pllr, hpre, ppre1, ppre2,
      flash_waitstates;
  if (powersave) {
    cpu_freq = 48000000;
    pllm = 8;
    plln = 96;
    pllp = 2;
    pllq = 2;
    pllr = 0;
    hpre = RCC_PRESCALER_DIV_NONE;
    ppre1 = RCC_PRESCALER_DIV_4;
    ppre2 = RCC_PRESCALER_DIV_2;
    flash_waitstates = 5;
  } else {
    cpu_freq = 168000000;
    pllm = 8;
    plln = 336;
    pllp = 2;
    pllq = 7;
    pllr = 0;
    hpre = RCC_PRESCALER_DIV_NONE;
    ppre1 = RCC_PRESCALER_DIV_4;
    ppre2 = RCC_PRESCALER_DIV_2;
    flash_waitstates = 3;
  }</span></pre>
<p><span class="koboSpan" id="kobo.59.1">The </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.60.1">number of wait states for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">flash</span></strong><span class="koboSpan" id="kobo.62.1"> operation has also been changed here, because, according to the documentation of the STM32F407, at 48 MHz, the flash only requires three </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">wait states:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
 flash_set_waitstates(flash_waitstates);</span></pre>
<p><span class="koboSpan" id="kobo.65.1">The procedure for setting the system clock is the usual one. </span><span class="koboSpan" id="kobo.65.2">First, the HSI is enabled and then selected as the temporary clock source. </span><span class="koboSpan" id="kobo.65.3">Afterward, the 8 MHz external oscillator is enabled, and it is ready to feed </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the PLL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
 RCC_CR |= RCC_CR_HSION;
 DMB();
 while ((RCC_CR &amp; RCC_CR_HSIRDY) == 0) {};
 reg32 = RCC_CFGR;
 reg32 &amp;= ~((1 &lt;&lt; 1) | (1 &lt;&lt; 0));
 RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);
 DMB();
 RCC_CR |= RCC_CR_HSEON;
 DMB();
 while ((RCC_CR &amp; RCC_CR_HSERDY) == 0)
    ;</span></pre>
<p><span class="koboSpan" id="kobo.68.1">The parameters </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.69.1">for the clock divisors and multipliers for the chosen mode are set in the PLL configuration register, and the PLL </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">is enabled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.71.1">
 reg32 = RCC_CFGR;
 reg32 &amp;= ~(0xF0);
 RCC_CFGR = (reg32 | (hpre &lt;&lt; 4));
 DMB();
 reg32 = RCC_CFGR;
 reg32 &amp;= ~(0x1C00);
 RCC_CFGR = (reg32 | (ppre1 &lt;&lt; 10));
 DMB();
 reg32 = RCC_CFGR;
 reg32 &amp;= ~(0x07 &lt;&lt; 13);
 RCC_CFGR = (reg32 | (ppre2 &lt;&lt; 13));
 DMB();
 reg32 = RCC_PLLCFGR;
 reg32 &amp;= ~(PLL_FULL_MASK);
 RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | pllm |
 (plln &lt;&lt; 6) | (((pllp &gt;&gt; 1) - 1) &lt;&lt; 16) | (pllq &lt;&lt; 24);
}</span></pre>
<p><span class="koboSpan" id="kobo.72.1">Changing the CPU and system clocks means that all the peripherals that use the clocks must be reconfigured. </span><span class="koboSpan" id="kobo.72.2">If a timer is running, or any device using the clocks as reference is in use by the application, the pre-scaler register that is used for providing the timing reference must be adapted accordingly based on clock </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">speed updates.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Running the</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.75.1"> system at a lower speed offers other benefits, such as the possibility to decrease the number of wait states required to access the flash memory and enable extra low-power features that are only available when the system is not running at </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">full speed.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">An embedded platform usually includes low-frequency clock generators, in the kHz range, which may be used as sources for time-keeping devices such as watchdogs and </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">real-time clocks</span></strong><span class="koboSpan" id="kobo.79.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.80.1">RTCs</span></strong><span class="koboSpan" id="kobo.81.1">). </span><span class="koboSpan" id="kobo.81.2">External </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.82.1">or internal oscillators can be active during low-power operating modes and used to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">wake-up stra</span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.84.1">tegies.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.85.1">Voltage control</span></h2>
<p><span class="koboSpan" id="kobo.86.1">Microcontrollers </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.87.1">have a relatively wide range of operating voltages. </span><span class="koboSpan" id="kobo.87.2">Supplying lower voltages, however, makes it impossible to run the CPU at full speed, and flash memory may require additional wait states due to the physical characteristics of the hardware. </span><span class="koboSpan" id="kobo.87.3">Nevertheless, lower-voltage-tolerant logic can improve the overall economy of the system in </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">some cases.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Internal regulators can often be configured to produce a lower voltage for the core signals, to reach a compromise between the power consumption and performance when the CPU is not running at its </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">maximum frequency.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">An important aspect that is often neglected is the power consumed by the Schmitt triggers in the digital input logic. </span><span class="koboSpan" id="kobo.91.2">When GPIOs are configured as digital input, but not forced to a known logic state through external passive components, they might be floating around the average value, due to the electromagnetic fields in the environment. </span><span class="koboSpan" id="kobo.91.3">This causes the input signal to be triggered, resulting in a little energy being lost at every change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">logi</span><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.93.1">c state.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.94.1">Low-power operating modes</span></h1>
<p><span class="koboSpan" id="kobo.95.1">Microcontrollers</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.96.1"> can execute in different power </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.97.1">modes, switching from full performance to complete hibernation. </span><span class="koboSpan" id="kobo.97.2">A proper understanding of the microcontroller’s low-power modes is fundamental to designing systems with improved energy profiles. </span><span class="koboSpan" id="kobo.97.3">Each architecture provides specific power </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.98.1">configurations, where the CPU or other buses and peripherals are disabled, as well as appropriate</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.99.1"> mechanisms to be used by the system software to enter and exit </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">low-power modes.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">In an ARM-based microcontroller, the terminology used for the different low-power modes can be summarized </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Normal operation mode</span></strong><span class="koboSpan" id="kobo.104.1">: Active </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.105.1">components are selected through clock gating, and the clock is running at the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">desired frequency.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Sleep mode</span></strong><span class="koboSpan" id="kobo.108.1">: The CPU clock is temporarily suspended, but all the peripherals keep</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.109.1"> functioning as in normal mode. </span><span class="koboSpan" id="kobo.109.2">As long as the CPU is not executing, there is a noticeable, even if marginal, amount of power saved in this mode. </span><span class="koboSpan" id="kobo.109.3">Execution can be resumed after receiving an interrupt request. </span><span class="koboSpan" id="kobo.109.4">This mode is also referred to as </span><em class="italic"><span class="koboSpan" id="kobo.110.1">wait mode</span></em><span class="koboSpan" id="kobo.111.1"> by some </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">chip manufacturers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.113.1">Stop mode</span></strong><span class="koboSpan" id="kobo.114.1">: The</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.115.1"> CPU clock and the bus clocks are disabled. </span><span class="koboSpan" id="kobo.115.2">All the peripherals powered by the microcontroller are off. </span><span class="koboSpan" id="kobo.115.3">The internal RAM and the CPU registers retain the stored values because the main voltage regulator stays on. </span><span class="koboSpan" id="kobo.115.4">The power consumption drops consistently, but it is still possible to wake up and resume the execution through an external interrupt or event. </span><span class="koboSpan" id="kobo.115.5">This mode is often also less appropriately called deep-sleep mode, although it is, in fact, one of two deep-sleep </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">modes available.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Standby mode</span></strong><span class="koboSpan" id="kobo.118.1">: All the</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.119.1"> voltage regulators are off, and the content of the RAM and register is lost. </span><span class="koboSpan" id="kobo.119.2">A small amount of power, in the range of a few microwatts, may be required to keep the backup circuitry alive during the standby phase. </span><span class="koboSpan" id="kobo.119.3">Wake-up is then only possible under a few specific conditions, such as an externally powered RTC, or a hardware-predefined wake-up event pin. </span><span class="koboSpan" id="kobo.119.4">When the system wakes up from standby, the normal boot procedure is followed, and the execution resumes from the reset </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">service routine.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.121.1">The ARMv7 microcode provides </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.122.1">two instructions to enter</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.123.1"> low-power </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">operating modes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.125.1">Wait for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.126.1">interrupt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.128.1">WFI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Wait for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.131.1">event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.133.1">WFE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.135.1">These </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.136.1">instructions</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.137.1"> can be invoked at any time while in normal running mode. </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">WFI</span></strong><span class="koboSpan" id="kobo.139.1"> will put the system in a low-power mode until the next interrupt request is received, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">WFE</span></strong><span class="koboSpan" id="kobo.141.1"> is slightly different. </span><span class="koboSpan" id="kobo.141.2">Only a few events in the system, including the external interrupts, can be configured to generate an event. </span><span class="koboSpan" id="kobo.141.3">Normal interrupt requests will not put the system back into normal running mode if it is in a sleep or stop mode that has been entered </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">WFE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">The low-power mode that is entered upon invocation depends on the settings stored in the </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">System Control Register</span></strong><span class="koboSpan" id="kobo.147.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.148.1">SCR</span></strong><span class="koboSpan" id="kobo.149.1">), which</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.150.1"> on Cortex-M is located in the system configuration region, at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">0xE000ED10</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">The SCR only provides 3 meaningful </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.153.1">1-bit </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">flag fields:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">SLEEPONEXIT</span></strong><span class="koboSpan" id="kobo.156.1"> (bit 1): When enabled, the system will go into low-power mode at the end of the execution of the next </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">interrupt handler.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">SLEEPDEEP</span></strong><span class="koboSpan" id="kobo.159.1"> (bit 2): Determines which mode is entered upon the invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">WFI</span></strong><span class="koboSpan" id="kobo.161.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">WFE</span></strong><span class="koboSpan" id="kobo.163.1">, or when returning from an interrupt with </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">SLEEPONEXIT</span></strong><span class="koboSpan" id="kobo.165.1"> active. </span><span class="koboSpan" id="kobo.165.2">If this bit is cleared, sleep mode is selected. </span><span class="koboSpan" id="kobo.165.3">When a low-power mode is entered with this bit active, the system will be put on stop or standby mode, depending on the configuration of the power </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">management registers.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">SEVONPEND</span></strong><span class="koboSpan" id="kobo.168.1"> (bit 4): When this bit is active, any interrupt pending during a low-power mode will cause a wake-up event, regardless of whether the sleep mode or the stop mode was entered using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">WFI</span></strong><span class="koboSpan" id="kobo.170.1"> or a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">WFE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1"> instruction.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.173.1">Note that bit 0, bit 3, and bits 5-31 are reserved (mus</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.174.1">t be kept at </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">value 0).</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.176.1">Deep-sleep configuration</span></h2>
<p><span class="koboSpan" id="kobo.177.1">To select </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.178.1">between stop and standby mode, and to set up certain parameters related to the deep-sleep modes, our reference platform provides a power controller, mapped in the internal peripherals region, at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">0x40007000</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">The controller consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">two registers:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">PWR_CR</span></strong><span class="koboSpan" id="kobo.183.1"> (control register) at an offset </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">0</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">PWR_SCR</span></strong><span class="koboSpan" id="kobo.187.1"> (status and control register) at an offset </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">4</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.190.1">The</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.191.1"> relevant parameters that can be configured in these two registers are </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.193.1">Regulator Voltage-Scaling Output Selection</span></strong><span class="koboSpan" id="kobo.194.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.195.1">VOS</span></strong><span class="koboSpan" id="kobo.196.1">), set through </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">PWR_CR</span></strong><span class="koboSpan" id="kobo.198.1"> bit 14. </span><span class="koboSpan" id="kobo.198.2">When</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.199.1"> active, saves extra power in normal running mode, by configuring the internal regulator to produce a slightly lower voltage for the CPU core logic. </span><span class="koboSpan" id="kobo.199.2">This feature is only available if the target is not running at </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">maximum frequency.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.201.1">Flash power down in deep sleep</span></strong><span class="koboSpan" id="kobo.202.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.203.1">FPDS</span></strong><span class="koboSpan" id="kobo.204.1">) mode, set through </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">PWR_CR</span></strong><span class="koboSpan" id="kobo.206.1"> bit 9. </span><span class="koboSpan" id="kobo.206.2">If active</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.207.1"> while going into one of the deep-sleep modes, the flash will be turned off completely while the system is sleeping. </span><span class="koboSpan" id="kobo.207.2">This results in a moderate amount of power saved but also impacts the </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">wake-up time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.209.1">Power down in deep sleep</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">PDDS</span></strong><span class="koboSpan" id="kobo.212.1">), set through </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">PWR_CR</span></strong><span class="koboSpan" id="kobo.214.1">, bit 1. </span><span class="koboSpan" id="kobo.214.2">This bit determines </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.215.1">which mode is entered when the CPU goes into a deep sleep. </span><span class="koboSpan" id="kobo.215.2">If cleared, stop mode is selected. </span><span class="koboSpan" id="kobo.215.3">If set, the system </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">enters standby.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.217.1">Low-power deep sleep</span></strong><span class="koboSpan" id="kobo.218.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.219.1">LPDS</span></strong><span class="koboSpan" id="kobo.220.1">), set through </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">PWR_CR</span></strong><span class="koboSpan" id="kobo.222.1"> bit 0. </span><span class="koboSpan" id="kobo.222.2">This bit only has an effect in</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.223.1"> stop mode. </span><span class="koboSpan" id="kobo.223.2">If enabled, it slightly reduces the energy used while in deep sleep by enabling the </span><em class="italic"><span class="koboSpan" id="kobo.224.1">under-drive</span></em><span class="koboSpan" id="kobo.225.1"> mode in the internal voltage regulator. </span><span class="koboSpan" id="kobo.225.2">The current is supplied to the core logic in a reduced leakage mode, which still allows you to preserve the content of memory and registers. </span><span class="koboSpan" id="kobo.225.3">This feature is only available if the system is not running at </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">full speed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.227.1">Enable wake-up pin</span></strong><span class="koboSpan" id="kobo.228.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.229.1">EWUP</span></strong><span class="koboSpan" id="kobo.230.1">), set through </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">PWR_CSR</span></strong><span class="koboSpan" id="kobo.232.1"> bit 4. </span><span class="koboSpan" id="kobo.232.2">This flag determines</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.233.1"> whether the wake-up pin can be used as a normal GPIO, or whether it is reserved to detect a wake-up signal during standby. </span><span class="koboSpan" id="kobo.233.2">The pin associated with this function in the reference platform </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">is PA0.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.235.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">wake-up flag</span></strong><span class="koboSpan" id="kobo.237.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.238.1">WUF</span></strong><span class="koboSpan" id="kobo.239.1">) is </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.240.1">automatically set by the hardware when exiting a sleep or a deep-sleep mode and can be read through </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">PWR_CSR</span></strong><span class="koboSpan" id="kobo.242.1"> bit 0. </span><span class="koboSpan" id="kobo.242.2">Writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">1</span></strong><span class="koboSpan" id="kobo.244.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">PWR_CR</span></strong><span class="koboSpan" id="kobo.246.1"> bit 2 </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">clears the wake-up </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.248.1">flag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1"> (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">CWUF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">On the STM32F407 microcontroller, we can access the registers related to the low-power modes and configuration using the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">following macros:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
#define SCB_SCR (*(volatile uint32_t *)(0xE000ED10))
#define SCB_SCR_SEVONPEND (1 &lt;&lt; 4)
#define SCB_SCR_SLEEPDEEP (1 &lt;&lt; 2)
#define SCB_SCR_SLEEPONEXIT (1 &lt;&lt; 1)
#define POW_BASE (0x40007000)
#define POW_CR (*(volatile uint32_t *)(POW_BASE + 0x00))
#define POW_SCR (*(volatile uint32_t *)(POW_BASE + 0x04))
#define POW_CR_VOS (1 &lt;&lt; 14)
#define POW_CR_FPDS (1 &lt;&lt; 9)
#define POW_CR_CWUF (1 &lt;&lt; 2)
#define POW_CR_PDDS (1 &lt;&lt; 1)
#define POW_CR_LPDS (1 &lt;&lt; 0)
#define POW_SCR_WUF (1 &lt;&lt; 0)
#define POW_SCR_EWUP (1 &lt;&lt; 4)</span></pre>
<p><span class="koboSpan" id="kobo.255.1">For the</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.256.1"> activation of the low-power modes, and the generation of spontaneous events, we define macros containing single inline assembly instructions </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
#define WFI() asm volatile ("wfi")
#define WFE() asm volatile ("wfe")</span></pre>
<p><span class="koboSpan" id="kobo.259.1">If sleep mode is entered through </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">WFI</span></strong><span class="koboSpan" id="kobo.261.1">, the system suspends the execution until the next interrupt. </span><span class="koboSpan" id="kobo.261.2">Entering sleep mode with </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">WFE</span></strong><span class="koboSpan" id="kobo.263.1"> instead ensures that only selected </span><em class="italic"><span class="koboSpan" id="kobo.264.1">events</span></em><span class="koboSpan" id="kobo.265.1"> can wake up the system again. </span><span class="koboSpan" id="kobo.265.2">Events of different types that occur on the system can be enabled to wake up </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">WFE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">WFE</span></strong><span class="koboSpan" id="kobo.271.1"> is entered, all interrupts active in the NVIC will still count as events, thereby waking </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.272.1">up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">WFE</span></strong><span class="koboSpan" id="kobo.274.1"> call. </span><span class="koboSpan" id="kobo.274.2">Interrupts can be temporarily filtered out by disabling the corresponding IRQ line in the NVIC. </span><span class="koboSpan" id="kobo.274.3">If an interrupt is filtered this way, using NVIC, it remains in a pending state and it is handled as soon as the system g</span><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.275.1">oes back to normal </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">running mode.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.277.1">Stop mode</span></h2>
<p><span class="koboSpan" id="kobo.278.1">Sleep mode is</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.279.1"> entered by default every time that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">WFI</span></strong><span class="koboSpan" id="kobo.281.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">WFE</span></strong><span class="koboSpan" id="kobo.283.1"> instructions are invoked, as long as </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">SCB_SCR_SLEEPDEEP</span></strong><span class="koboSpan" id="kobo.285.1"> remains off. </span><span class="koboSpan" id="kobo.285.2">Other low-power modes can be enabled by enabling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">SLEEPDEEP</span></strong><span class="koboSpan" id="kobo.287.1"> flag. </span><span class="koboSpan" id="kobo.287.2">To enter one of the available deep-sleep modes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">SCB_SCR</span></strong><span class="koboSpan" id="kobo.289.1"> and the POW registers must be configured before calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">WFI</span></strong><span class="koboSpan" id="kobo.291.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">WFE</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">Depending on the configuration, the system enters one of the</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.294.1"> two deep-sleep modes, stop </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">or standby.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">In the following example, a continuous 1 Hz timer toggles the LED 10 times before switching to deep-sleep mode, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">WFE</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">main</span></strong><span class="koboSpan" id="kobo.300.1"> loop stays in sleep mode in between timer interrupts, </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">WFI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
void main(void) {
  int sleep = 0;
  pll_on(0);
  button_setup();
  led_setup();
  timer_init(CPU_FREQ, 1, 1000);
  while(1) {
    if (timer_elapsed) {
      WFE(); /* consume timer event */
      led_toggle();
      timer_elapsed = 0;
    }
    if (tim2_ticks &gt; 10) {
      sleep = 1;
      tim2_ticks = 0;
    }
    if (sleep) {
      enter_lowpower_mode();
      WFE();
      sleep = 0;
      exit_lowpower_mode();
    } else
      WFI();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.305.1">The</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.306.1"> interrupt service routine for the timer increases the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">tim2_ticks</span></strong><span class="koboSpan" id="kobo.308.1"> counter by </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">1</span></strong><span class="koboSpan" id="kobo.310.1"> and sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">timer_elapsed</span></strong><span class="koboSpan" id="kobo.312.1"> flag, which will make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">main</span></strong><span class="koboSpan" id="kobo.314.1"> loop toggle the LED and consume the event generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the timer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
void isr_tim2(void) {
  nvic_irq_clear(NVIC_TIM2_IRQN);
  TIM2_SR &amp;= ~TIM_SR_UIF;
  tim2_ticks++;
  timer_elapsed++;
}</span></pre>
<p><span class="koboSpan" id="kobo.317.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">enter_lowpower_mode</span></strong><span class="koboSpan" id="kobo.319.1"> procedure is responsible for setting the values in the system control block and in the power control registers, depending on the desired low-power mode, and</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.320.1"> configuring all the </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">optimizations accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">enter_lowpower_mode</span></strong><span class="koboSpan" id="kobo.324.1"> procedure performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">following actions:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.326.1">It turns off </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the LED.</span></span></li>
<li><span class="koboSpan" id="kobo.328.1">It sets the values in </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">SCB_SCR</span></strong><span class="koboSpan" id="kobo.330.1"> and the power register to configure the low-power mode that will be entered </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">upon </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">WFE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.334.1">It selects the single extra </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">power optimizations.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.336.1">It is implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
void enter_lowpower_mode(void)
{
  uint32_t scr = 0;
  led_off();
  scr = SCB_SCR;
  scr &amp;= ~SCB_SCR_SEVONPEND;
  scr |= SCB_SCR_SLEEPDEEP;
  scr &amp;= ~SCB_SCR_SLEEPONEXIT;
  SCB_SCR = scr;
  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | POW_CR_LPDS;
}</span></pre>
<p><span class="koboSpan" id="kobo.339.1">In this case, stop mode is configured to reduce power consumption as much as possible, by activating the low-power voltage regulator settings (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">POW_CR_LPDS</span></strong><span class="koboSpan" id="kobo.341.1">) and by turning off the flash (</span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">through </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">POW_CR_FPDS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Low-power mode is now entered through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">WFE()</span></strong><span class="koboSpan" id="kobo.347.1"> call. </span><span class="koboSpan" id="kobo.347.2">To be able to wake up the system, we configure an </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">EXTI</span></strong><span class="koboSpan" id="kobo.349.1"> event, which is associated with the user pressing a button on the board. </span><span class="koboSpan" id="kobo.349.2">To do so, we configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">EXTI0</span></strong><span class="koboSpan" id="kobo.351.1"> to be sensitive to raised edges, as the PA0 pin changes its logical value from </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">0</span></strong><span class="koboSpan" id="kobo.353.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">1</span></strong><span class="koboSpan" id="kobo.355.1"> upon </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">being pressed.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">As we are not</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.358.1"> particularly interested in the interrupt itself, we ensure that the flag to generate an interrupt request is turned off in </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">EXTI</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">The event controller will ensure that an event is generated instead because the flag relative to the input pin is enforced in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">EXTI_EMR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.362.1"> register.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">The initial configuration for the user button event looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
void button_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
  APB2_CLOCK_ER |= SYSCFG_APB2_CLOCK_ER;
  GPIOA_MODE &amp;= ~ (0x03 &lt;&lt; (BUTTON_PIN * 2));
  EXTI_CR0 &amp;= ~EXTI_CR_EXTI0_MASK;
  EXTI_IMR &amp;= ~0x7FFFFF;
  reg = EXTI_EMR &amp; ~0x7FFFFF;
  EXTI_EMR = reg | (1 &lt;&lt; BUTTON_PIN);
  reg = EXTI_RTSR &amp; ~0x7FFFFF;
  EXTI_RTSR = reg | (1 &lt;&lt; BUTTON_PIN);
  EXTI_FTSR &amp;= ~0x7FFFFF;
}</span></pre>
<p><span class="koboSpan" id="kobo.366.1">No interrupts are configured for the button, as the event alone is sufficient to wake up the board during </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">stop mode.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">Upon entering stop mode, the PLL will be disabled, and the HSI will be automatically selected as the clock source when the system is back in normal running mode. </span><span class="koboSpan" id="kobo.368.2">To restore the clock configuration, there are a few steps to implement as soon as stop mode </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">is exited:</span></span></p>
<ol>
<li value="1"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">SCB_SCR_SLEEPDEEP</span></strong><span class="koboSpan" id="kobo.371.1"> flag is cleared so that the next invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">WFI</span></strong><span class="koboSpan" id="kobo.373.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">WFE</span></strong><span class="koboSpan" id="kobo.375.1"> does not trigger another switch to </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">stop mode.</span></span></li>
<li><span class="koboSpan" id="kobo.377.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">POW_CR</span></strong><span class="koboSpan" id="kobo.379.1"> register is accessed to clear the wake-up flag set by the hardware at the end of the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">stop mode.</span></span></li>
<li><span class="koboSpan" id="kobo.381.1">The</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.382.1"> PLL is configured again, as the clock </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">is restored.</span></span></li>
<li><span class="koboSpan" id="kobo.384.1">The LED is </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">turned on.</span></span></li>
<li><span class="koboSpan" id="kobo.386.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">TIM2</span></strong><span class="koboSpan" id="kobo.388.1"> interrupt is enabled again for the timer to restore its functionality in normal </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">running mode:</span></span><pre class="console"><span class="koboSpan" id="kobo.390.1">
void exit_lowpower_mode(void)</span></pre><pre class="console"><span class="koboSpan" id="kobo.391.1">
{</span></pre><pre class="console"><span class="koboSpan" id="kobo.392.1">
  SCB_SCR &amp;= ~SCB_SCR_SLEEPDEEP;</span></pre><pre class="console"><span class="koboSpan" id="kobo.393.1">
  POW_CR |= POW_CR_CWUF | POW_CR_CSBF;</span></pre><pre class="console"><span class="koboSpan" id="kobo.394.1">
  clock_pll_on(0);</span></pre><pre class="console"><span class="koboSpan" id="kobo.395.1">
  timer_init(cpu_freq, 1, 1000);</span></pre><pre class="console"><span class="koboSpan" id="kobo.396.1">
  led_on();</span></pre><pre class="console"><span class="koboSpan" id="kobo.397.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.398.1">Deep-sleep mode reduces the power consumption consistently, and it is the ideal situation whenever the system must maintain the current running status </span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.399.1">but can be frozen for a </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">longer period.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.401.1">Standby mode</span></h2>
<p><span class="koboSpan" id="kobo.402.1">In</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.403.1"> standby mode, the system can go into ultra-low-power mode, consuming only a few microamperes, while waiting to be reinitialized by an external event. </span><span class="koboSpan" id="kobo.403.2">Entering standby mode requires you to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">SCB_SCR_PDDS</span></strong><span class="koboSpan" id="kobo.405.1"> flag prior to invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">WFI</span></strong><span class="koboSpan" id="kobo.407.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">WFE</span></strong><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">While the system is on standby, all the voltage regulators are off, except for the low-speed oscillators, which are used to clock the independent watchdog timer and the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">real-time clock.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">The procedure to enter standby mode is slightly different from the one used to enter stop mode. </span><span class="koboSpan" id="kobo.411.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">SCB_SCR_PDDS</span></strong><span class="koboSpan" id="kobo.413.1"> flag is set to select standby mode as a deep-sleep variant. </span><span class="koboSpan" id="kobo.413.2">The flag </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">SCB_SCR_LPDS</span></strong><span class="koboSpan" id="kobo.415.1"> is not activated in this case, because we know it has no effect in </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">standby mode:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
void enter_lowpower_mode(void)
{
  uint32_t scr = 0;
  led_off();
  scr = SCB_SCR;
  scr &amp;= ~SCB_SCR_SEVONPEND;
  scr |= SCB_SCR_SLEEPDEEP;
  scr &amp;= ~SCB_SCR_SLEEPONEXIT;
  SCB_SCR = scr;
  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">POW_CR_PDDS</span></strong><span class="koboSpan" id="kobo.419.1">;
  POW_SCR |= POW_CR_CSBF;
}</span></pre>
<p><span class="koboSpan" id="kobo.420.1">In this case, it is useless to set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">EXTI</span></strong><span class="koboSpan" id="kobo.422.1"> event for the button press, as the GPIO controllers will be disabled while the microcontroller is in standby mode. </span><span class="koboSpan" id="kobo.422.2">The easiest way to exit this state is configuring the real-time clock to generate a wake-up event after a fixed amount of time. </span><span class="koboSpan" id="kobo.422.3">In fact, during the standby phase, only a few peripherals will be kept alive, and they are all grouped in a special section of the clock configuration, namely the backup domain. </span><span class="koboSpan" id="kobo.422.4">The backup domain consists of the real-time clock and a small portion of the clock tree, containing the internal and external low-speed oscillators. </span><span class="koboSpan" id="kobo.422.5">The write access to the registers related to the backup domain is controlled by the flag disabling protection of the backup domain, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">POW_CR_DPB</span></strong><span class="koboSpan" id="kobo.424.1">, located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">POW_CR</span></strong><span class="koboSpan" id="kobo.426.1"> register at </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">bit 8.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The RTC configuration registers, mapped in the peripherals area starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">0x40002870</span></strong><span class="koboSpan" id="kobo.430.1">, are protected from accidental writing due to electromagnetic interference, meaning that a special value sequence must be written to the write protection register before accessing the other registers. </span><span class="koboSpan" id="kobo.430.2">The RTC integrated into the reference platform is complex and has a lot of features, such as keeping track of date and time, and setting custom alarms and regular timestamp events. </span><span class="koboSpan" id="kobo.430.3">For this example, we want </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.431.1">to use only the wake-up event, so most of the RTC registers are not </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">documented here.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">The restricted set of registers we access for RTC is </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.435.1">The control register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">RTC_CR</span></strong><span class="koboSpan" id="kobo.437.1">) exposes the configuration of the various functionalities provided by the RTC. </span><span class="koboSpan" id="kobo.437.2">In the example, we use the values related to the wake-up trigger, enabling the interrupt with the wake-up timer interrupt enable flag, </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">RTC_CR_WUTIE</span></strong><span class="koboSpan" id="kobo.439.1">, and enabling the wake-up timer counter also </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">RTC_CR_WUTE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.443.1">The initialization and status register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">RTC_ISR</span></strong><span class="koboSpan" id="kobo.445.1">) in this example is used to check the write status of the setup register for the wake-up timer through the special flag, </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">RTC_ISR_WUTWF</span></strong><span class="koboSpan" id="kobo.447.1">, during the </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">timer setup.</span></span></li>
<li><span class="koboSpan" id="kobo.449.1">The wake-up timer register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">RTC_WUTR</span></strong><span class="koboSpan" id="kobo.451.1">) is used to set the interval before the next </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">wake-up event.</span></span></li>
<li><span class="koboSpan" id="kobo.453.1">The write protection register (</span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">RTC_WPR</span></strong><span class="koboSpan" id="kobo.455.1">) is used to transmit the unlock sequence before writing to other registers in </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">the region.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.457.1">The preprocessor macros that map these registers and the meaningful fields are </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
#define RTC_BASE (0x40002800)
#define RTC_CR (*(volatile uint32_t *)(RTC_BASE + 0x08))
#define RTC_ISR (*(volatile uint32_t *)(RTC_BASE + 0x0c))
#define RTC_WUTR (*(volatile uint32_t *)(RTC_BASE + 0x14))
#define RTC_WPR (*(volatile uint32_t *)(RTC_BASE + 0x24))
#define RTC_CR_WUP (0x03 &lt;&lt; 21)
#define RTC_CR_WUTIE (1 &lt;&lt; 14)
#define RTC_CR_WUTE (1 &lt;&lt; 10)
#define RTC_ISR_WUTF (1 &lt;&lt; 10)
#define RTC_ISR_WUTWF (1 &lt;&lt; 2)</span></pre>
<p><span class="koboSpan" id="kobo.460.1">The procedure</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.461.1"> to initialize the RTC to generate a wake-up event includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">following steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.463.1">Turn on the clock gating for the power configuration registers, if not already on, to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">POW_CR_DPB</span></strong><span class="koboSpan" id="kobo.465.1"> flag, in order to initiate the setup of </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the RTC:</span></span><pre class="console"><span class="koboSpan" id="kobo.467.1">
void rtc_init(void) {</span></pre><pre class="console"><span class="koboSpan" id="kobo.468.1">
   APB1_CLOCK_ER |= PWR_APB1_CLOCK_ER_VAL;</span></pre><pre class="console"><span class="koboSpan" id="kobo.469.1">
   POW_CR |= POW_CR_DPB;</span></pre></li>
<li><span class="koboSpan" id="kobo.470.1">Enable the RTC using bit 15 in the backup domain register configuration within </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">the RCC:</span></span><pre class="console"><span class="koboSpan" id="kobo.472.1">
   RCC_BACKUP |= RCC_BACKUP_RTCEN;</span></pre></li>
<li><span class="koboSpan" id="kobo.473.1">Enable a </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.474.1">backup clock source, selecting from the </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Low-Speed Internal</span></strong><span class="koboSpan" id="kobo.476.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.477.1">LSI</span></strong><span class="koboSpan" id="kobo.478.1">) oscillator </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.479.1">or a </span><strong class="bold"><span class="koboSpan" id="kobo.480.1">Low-Speed External</span></strong><span class="koboSpan" id="kobo.481.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.482.1">LSE</span></strong><span class="koboSpan" id="kobo.483.1">) oscillator, </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">if available.</span></span></li>
<li><span class="koboSpan" id="kobo.485.1">In this example, we use the LSI oscillator because the LSE oscillator is not present on the reference platform. </span><span class="koboSpan" id="kobo.485.2">However, external oscillators are more accurate and are always preferable, when available, for reliable timekeeping. </span><span class="koboSpan" id="kobo.485.3">After the clock has been enabled, the procedure waits until it becomes ready by polling a bit in the </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">status register:</span></span><pre class="console"><span class="koboSpan" id="kobo.487.1">
   RCC_CSR |= RCC_CSR_LSION;</span></pre><pre class="console"><span class="koboSpan" id="kobo.488.1">
   while (!(RCC_CSR &amp; RCC_CSR_LSIRDY))</span></pre><pre class="console"><span class="koboSpan" id="kobo.489.1">
     ;</span></pre></li>
<li><span class="koboSpan" id="kobo.490.1">Select the LSI as the source for </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">the RTC:</span></span><pre class="console"><span class="koboSpan" id="kobo.492.1">
  RCC_BACKUP |= (RCC_BACKUP_RTCSEL_LSI &lt;&lt; </span></pre><pre class="console"><span class="koboSpan" id="kobo.493.1">
      RCC_BACKUP_RTCSEL_SHIFT);</span></pre></li>
<li><span class="koboSpan" id="kobo.494.1">Enable the interrupt and event generation for line </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">22</span></strong><span class="koboSpan" id="kobo.496.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">EXTI</span></strong><span class="koboSpan" id="kobo.498.1">, associating an event with the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">raised edge:</span></span><pre class="console"><span class="koboSpan" id="kobo.500.1">
  EXTI_IMR |= (1 &lt;&lt; 22);</span></pre><pre class="console"><span class="koboSpan" id="kobo.501.1">
  EXTI_EMR |= (1 &lt;&lt; 22);</span></pre><pre class="console"><span class="koboSpan" id="kobo.502.1">
  EXTI_RTSR |= (1 &lt;&lt; 22);</span></pre></li>
<li><span class="koboSpan" id="kobo.503.1">Unlock</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.504.1"> the writing to the RTC registers by writing the unlock sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">RTC_WPR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">:</span></span><pre class="console"><span class="koboSpan" id="kobo.508.1">
  RTC_WPR = 0xCA;</span></pre><pre class="console"><span class="koboSpan" id="kobo.509.1">
  RTC_WPR = 0x53;</span></pre></li>
<li><span class="koboSpan" id="kobo.510.1">Disable the RTC so that it is permitted to write to the configuration registers. </span><span class="koboSpan" id="kobo.510.2">Wait until the write operation is possible, by </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">polling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">RTC_ISR_WUTWF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">:</span></span><pre class="console"><span class="koboSpan" id="kobo.514.1">
   RTC_CR &amp;= ~RTC_CR_WUTE;</span></pre><pre class="console"><span class="koboSpan" id="kobo.515.1">
   DMB();</span></pre><pre class="console"><span class="koboSpan" id="kobo.516.1">
   while (!(RTC_ISR &amp; RTC_ISR_WUTWF))</span></pre><pre class="console"><span class="koboSpan" id="kobo.517.1">
     ;</span></pre></li>
<li><span class="koboSpan" id="kobo.518.1">Set the value for the interval before the next wake-up event. </span><span class="koboSpan" id="kobo.518.2">The LSI frequency is 32,768 Hz, and the default divider for the wake-up interval register is set to 16, so each unit in </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">RTC_WUTR</span></strong><span class="koboSpan" id="kobo.520.1"> represents one </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">2048</span></strong><span class="superscript"><span class="koboSpan" id="kobo.522.1">th</span></span><span class="koboSpan" id="kobo.523.1"> of a second. </span><span class="koboSpan" id="kobo.523.2">To set an interval of </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">5</span></strong><span class="koboSpan" id="kobo.525.1"> seconds, we use </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">the following:</span></span><pre class="console"><span class="koboSpan" id="kobo.527.1">
  RTC_WUTR = (2048 * 5) – 1;</span></pre></li>
<li><span class="koboSpan" id="kobo.528.1">Enable the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">wake-up event:</span></span><pre class="console"><span class="koboSpan" id="kobo.530.1">
  RTC_CR |= RTC_CR_WUP;</span></pre></li>
<li><span class="koboSpan" id="kobo.531.1">Clear the wake-up flag that might have been set when returning from </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">standby mode:</span></span><pre class="console"><span class="koboSpan" id="kobo.533.1">
  RTC_ISR &amp;= ~RTC_ISR_WUTF;</span></pre></li>
<li><span class="koboSpan" id="kobo.534.1">To complete the sequence, we write an invalid byte to </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">RTC_WPR</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">This way, the write protection on the RCC register is turned </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">on again:</span></span><pre class="console"><span class="koboSpan" id="kobo.538.1">
   RTC_WPR = 0xb0;</span></pre><pre class="console"><span class="koboSpan" id="kobo.539.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.540.1">To </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.541.1">enable the RTC, right before entering standby mode, the following procedure ensures that the timer is active and counting and the event generation for the wake-up event </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">is active:</span></span><pre class="console"><span class="koboSpan" id="kobo.543.1">
void rtc_start(void)</span></pre><pre class="console"><span class="koboSpan" id="kobo.544.1">
{</span></pre><pre class="console"><span class="koboSpan" id="kobo.545.1">
   RTC_WPR = 0xCA;</span></pre><pre class="console"><span class="koboSpan" id="kobo.546.1">
   RTC_WPR = 0x53;</span></pre><pre class="console"><span class="koboSpan" id="kobo.547.1">
   RTC_CR |= RTC_CR_WUTIE |RTC_CR_WUTE;</span></pre><pre class="console"><span class="koboSpan" id="kobo.548.1">
   while (((RTC_ISR) &amp; (RTC_ISR_WUTWF)))</span></pre><pre class="console"><span class="koboSpan" id="kobo.549.1">
     ;</span></pre><pre class="console"><span class="koboSpan" id="kobo.550.1">
   RTC_WPR = 0xb0;</span></pre><pre class="console"><span class="koboSpan" id="kobo.551.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.552.1">If the procedure just shown is called before entering standby, the system will be up again when the wake-up event occurs, but it does not resume the execution from where it was suspended, as it happens in the other low-power modes. </span><span class="koboSpan" id="kobo.552.2">Instead, it starts over from the reset interrupt handler, at the beginning of the interrupt vector. </span><span class="koboSpan" id="kobo.552.3">For this reason, this example does not need an implementation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">exit_lowpower_mode</span></strong><span class="koboSpan" id="kobo.554.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">WFE</span></strong><span class="koboSpan" id="kobo.556.1"> instruction that switches the system to standby will never return to the same context of execution. </span><span class="koboSpan" id="kobo.556.2">Eventually, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">main</span></strong><span class="koboSpan" id="kobo.558.1"> function for the standby example looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">the </span></span><span class="No-Break"><a id="_idIndexMarker582"/></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
void main(void) {
  int sleep = 0;
  clock_pll_on(0);
  led_setup();
  rtc_init();
  timer_init(cpu_freq, 1, 1000);
  while(1) {
    if (timer_elapsed) {
      WFE(); /* Consume timer event */
      led_toggle();
      timer_elapsed = 0;
    }
    if (tim2_ticks &gt; 10) {
      sleep = 1;
      tim2_ticks = 0;
    }
    if (sleep) {
      enter_lowpower_mode();
      </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">rtc_start();</span></strong><span class="koboSpan" id="kobo.563.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">WFE(); /* Neve</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.565.1">r returns */</span></strong><span class="koboSpan" id="kobo.566.1">
    }
    else
      WFI();
  }
}</span></pre>
<h2 id="_idParaDest-189"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.567.1">Wake-up intervals</span></h2>
<p><span class="koboSpan" id="kobo.568.1">An</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.569.1"> important aspect to consider when designing a low-power strategy is </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.570.1">the wake-up time intervals, or, in other words, how long the system takes to resume the execution after switching into low-power mode. </span><span class="koboSpan" id="kobo.570.2">A system with real-time requirements may leave some room for compromises between power usage and reactivity, but it is important to understand the impact of the wake-up operations from the different low-power modes, in order to predict the latency of operations in the worst-case scenario. </span><span class="koboSpan" id="kobo.570.3">Wake-up times are very much conditioned by the hardware design of the microcontroller, and largely dependent on </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">the architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">On our reference platform, while waking up from sleep mode takes a small number of CPU cycles, the situation changes for deep-sleep modes. </span><span class="koboSpan" id="kobo.572.2">Waking up from stop mode takes several microseconds. </span><span class="koboSpan" id="kobo.572.3">Further optimizations that have been activated while in stop mode, such as changing voltage regulators or turning off the flash memory, consistently impact the amount of time spent restoring the values to return to normal running. </span><span class="koboSpan" id="kobo.572.4">Resetting after standby mode produces even longer wake-up intervals, in the order of milliseconds, as the system should completely reboot after a wake-up event, and the start-up code execution time adds up to the fraction of milliseconds needed by the CPU to </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">wake up.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">When designing a low-power system, these wake-up times must be taken into account and properly measured, especially when the system has to deal with real-time constraints. </span><span class="koboSpan" id="kobo.574.2">The optimal low-power mode that fits the application timing and energy profile requirements must be chosen, taking into account the overhead produced by leaving low-power mode if the system wakes up often enough for these intervals to </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">become non-negligible.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">Once the system is designed to operate in the appropriate low-power modes, we need a reliable mechanism to measure the power used by the system while it is running. </span><span class="koboSpan" id="kobo.576.2">The next section suggests a common mechanism to keep track of the current values through the circuit under test to measure the effects of the low-power operating modes of the microcontroller, and for the evaluatio</span><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.577.1">n of all energy-saving </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">optimizations introduced.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.579.1">Measuring power</span></h1>
<p><span class="koboSpan" id="kobo.580.1">The</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.581.1"> current in use by the target can be measured </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.582.1">at any time by connecting an ammeter in series with the device. </span><span class="koboSpan" id="kobo.582.2">This mechanism, however, does not show all the oscillations of the values during a time interval, which is why it is often useful to sample the values of the parasitic voltage at the ends of a shunt resistor using </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">an oscilloscope.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">A shunt resistor is placed in series with the target device, on either side of the power source. </span><span class="koboSpan" id="kobo.584.2">Its typical value is relatively small, in the range of a few ohms, to ensure that the parasite voltage stays low, but is still measurable by </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">the oscilloscope:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.586.1"><img alt="Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage applied to the shunt resistor" src="image/B18730_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.587.1">Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage applied to the shunt resistor</span></p>
<p><span class="koboSpan" id="kobo.588.1">Due to the properties of a series circuit, the current running through the shunt is the same as the one used by the target system, so the voltage on t</span><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.589.1">he ends of the shunt resistor </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">varies accordingly.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.591.1">Development boards</span></h2>
<p><span class="koboSpan" id="kobo.592.1">In order</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.593.1"> to see the effects of the power optimizations, we must</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.594.1"> exclude the electronics that are not related to the system. </span><span class="koboSpan" id="kobo.594.2">Our </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.595.1">reference board, for example, the STM32F407DISCOVERY, has an additional microcontroller that is used to provide a debug interface for the host, and it is powered using the same USB connector. </span><span class="koboSpan" id="kobo.595.2">However, development kits often offer a way to measure </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.596.1">the current, excluding the unrelated hardware, allowing us to properly evaluate the low-power features of the microcontroller, excluding the development-related circuitry </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">on board.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">On our</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.599.1"> reference board, the JP1 jumper can be used to open the circuit between the power supply and the microcontroller circuitry. </span><span class="koboSpan" id="kobo.599.2">By replacing the jumper with an ammeter connected to the two pins, we can measure the current used by the actual system. </span><span class="koboSpan" id="kobo.599.3">In the same way, it is possible to apply a shunt resistor to monitor the current, using the oscilloscope to sample the voltage on </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">the shunt.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">A lab equipped with reliable energy metering is a good starting point for evaluating low-power implementations and assisting in </span><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.602.1">the prototype and design phase of </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">energy optimization.</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.604.1">Designing low-power embedded applications</span></h1>
<p><span class="koboSpan" id="kobo.605.1">In this</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.606.1"> section, a few design patterns are proposed to achieve a better energy profile on the target device, by evaluating the power demand of all the components and the states of the system we are about to design. </span><span class="koboSpan" id="kobo.606.2">Once we know how to measure the values in the target, and the details about the low-power mode in the selected architecture and microprocessor family, the application can be programmed, keeping other parameters in mind, such a</span><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.607.1">s the energy efficiency of the software we </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">are writing.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.609.1">Replacing busy loops with sleep mode</span></h2>
<p><span class="koboSpan" id="kobo.610.1">The </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.611.1">reason busy loops are very popular among hobbyists is that they are so easy to implement. </span><span class="koboSpan" id="kobo.611.2">Suppose that the system needs to wait for a digital input to switch to a low-logic state, and this input is mapped to a certain GPIO. </span><span class="koboSpan" id="kobo.611.3">This can be easily done with the following one line </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.613.1">
while((GPIOX_IDR &amp; (1 &lt;&lt; INPUT_PINX)) != 0)
  ;</span></pre>
<p><span class="koboSpan" id="kobo.614.1">While this is perfectly working as expected, it will force the CPU into a loop of fetch-decode-execute, and to jump around the same few instructions until the condition becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">false</span></strong><span class="koboSpan" id="kobo.616.1">. </span><span class="koboSpan" id="kobo.616.2">As we have seen, the power used by the microcontroller mostly depends on how fast the CPU is running. </span><span class="koboSpan" id="kobo.616.3">A lower frequency corresponds to a smaller amount of power used per instruction. </span><span class="koboSpan" id="kobo.616.4">Executing instructions in an infinite loop without switching to low-power mode sets the power demand from the CPU at its highest value for a measurable amount of time – in this case, the entire time needed for the logic input to </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">change state.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">Actively</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.619.1"> polling a value is the only way to go if interrupts are not enabled. </span><span class="koboSpan" id="kobo.619.2">The examples contained in this book tend to guide you toward a proper interrupt-handling approach. </span><span class="koboSpan" id="kobo.619.3">The proper way to handle the wait for the logic switch instead foresees the activation of an interrupt line related to the next operation. </span><span class="koboSpan" id="kobo.619.4">In the case of a GPIO line, we can use external interrupt triggers to wake up the main loop when the condition is met, and switch to a low-power mode, instead of looping, while waiting for </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">the event.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">In many other cases, the temptation to implement loops such as the previous one could be avoided by investigating another way to access the peripheral that is currently preventing the system from carrying out the next execution step. </span><span class="koboSpan" id="kobo.621.2">Modern serial and network controllers are equipped with interrupt signals, and when those are not available for the hardware we are accessing, there is always another way to sense an event through an external interrupt line. </span><span class="koboSpan" id="kobo.621.3">When a device can really only function in polling mode, as a last resort, the polling frequency can be reduced by associating the action with a timer interrupt, which would allow polling a few times per second, or even once in a while, using intervals that are more in line with the actual peripheral speed. </span><span class="koboSpan" id="kobo.621.4">Executing timed operations allows the CPU to sleep in between, and to switch to a low-power mode, reducing the average energy that the CPU would need to use </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">while busy-looping.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">The exception to this rule, seen many times in this chapter, is waiting for a ready flag after activating a system component. </span><span class="koboSpan" id="kobo.623.2">The following code activates the internal low-speed oscillator, and it is used in the standby mode example before entering low-speed mode. </span><span class="koboSpan" id="kobo.623.3">The CSR register is polled until the low-speed oscillator is </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">actually running:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
RCC_CSR |= RCC_CSR_LSION;
while (!(RCC_CSR &amp; RCC_CSR_LSIRDY))
   ;</span></pre>
<p><span class="koboSpan" id="kobo.626.1">Operations such as this, performed on the integrated peripherals in the microcontroller silicon, have a well-known latency of a few CPU clocks, and thus do not impact the real-time constraints, as the maximum latency for similar internal actions is often mentioned in the </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.627.1">microcontroller documentation. </span><span class="koboSpan" id="kobo.627.2">The situation changes whenever the polling occurs on a less predictable register, whose state and reaction times may depend on exte</span><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.628.1">rnal factors, and long busy loops may occur in </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">the system.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.630.1">Deep sleep during longer inactivity periods</span></h2>
<p><span class="koboSpan" id="kobo.631.1">As we </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.632.1">know, standby allows the system to be frozen with the minimum possible power consumption, in the ultra-low-power range. </span><span class="koboSpan" id="kobo.632.2">The use of standby is advised when the design has very strict ultra-low-power requirements and the following conditions </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">are met:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.634.1">A viable wake-up strategy exists and is compatible with the current </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">hardware design</span></span></li>
<li><span class="koboSpan" id="kobo.636.1">The system can restore the execution without relying on its previous state, as the content of the RAM and CPU registers is lost and the system restarts from the reset service routine </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">at wake-up</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.638.1">Usually, longer periods of inactivity, where, for instance, the RTC can be used to program a wake-up alarm at a given time, are more fit for using standby mode. </span><span class="koboSpan" id="kobo.638.2">This applies to cases such as reading sensors and enabling actuators at programmed intervals during the day, keeping track of the time and a few </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">status variables.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">In most other cases, stop mode still saves enough power and provides a shorter wake-up interval. </span><span class="koboSpan" id="kobo.640.2">Another major advantage of stop mode is the increased flexibility of the wake-up strategy options. </span><span class="koboSpan" id="kobo.640.3">In fact, any interrupt-based or configurable event can be used to wake up the system from its low-power deep-sleep mode, so it is more fit for states where there is still some asynchronous interactivity with the </span><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.641.1">peripherals and interfaces surrounding </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">the microcontroller.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.643.1">Choosing the clock speed</span></h2>
<p><span class="koboSpan" id="kobo.644.1">Is all the computing power offered by the platform actually needed all </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">the time?</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">The </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.647.1">processing performance of microcontrollers nowadays is comparable to that of the personal computers of 20 years ago, which were already capable of fast operations and even processing real-time multimedia content. </span><span class="koboSpan" id="kobo.647.2">Embedded applications do not always require the CPU to run at full frequency. </span><span class="koboSpan" id="kobo.647.3">Especially when accessing peripherals, rather than crunching numbers, it does not matter how fast we clock the CPU and the bus. </span><span class="koboSpan" id="kobo.647.4">Both normal running mode and sleep mode require much less energy when the selected frequency is scaled down every single time the CPU performance is not actually the bottleneck of the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">execution pipe.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Many microcontrollers are designed to scale down the operating frequency for the CPU and the internal buses, which also generally allows the system to be fed with lower voltages. </span><span class="koboSpan" id="kobo.649.2">As we have seen, changing clocks can be done at runtime to compromise accordingly in terms of power and performance. </span><span class="koboSpan" id="kobo.649.3">However, this implies that all the devices using a clock as a reference must be reconfigured, so the change has a cost in terms of execution time and should not be abused. </span><span class="koboSpan" id="kobo.649.4">A convenient way to add frequency changes to the system design is to separate two or more CPU frequency scaling options into custom power states and switch to the r</span><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.650.1">equired state by fading between performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">power usage.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.652.1">Power state transitions</span></h2>
<p><span class="koboSpan" id="kobo.653.1">Consider</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.654.1"> a system connected to a sensor, producing and transmitting data through a network interface. </span><span class="koboSpan" id="kobo.654.2">The sensor is activated, then the system has to wait until it becomes ready, which is known to take several seconds. </span><span class="koboSpan" id="kobo.654.3">The sensor is then read multiple times in a row and then turned off. </span><span class="koboSpan" id="kobo.654.4">The data is processed, encrypted, and transmitted using a network device. </span><span class="koboSpan" id="kobo.654.5">The system remains idle for the next few hours before repeating the same operation. </span><span class="koboSpan" id="kobo.654.6">Initial rough modeling of the state machine is </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.656.1"><img alt="Figure 8.2 – State machine for a hypothetical sensor-reading system" src="image/B18730_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.657.1">Figure 8.2 – State machine for a hypothetical sensor-reading system</span></p>
<p><span class="koboSpan" id="kobo.658.1">The</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.659.1"> long idle interval foreseen in between two consecutive cycles suggests that it is perhaps a good idea to put the system on standby for most of the time and program an RTC alarm for the system to autonomously wake up in time for the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">next acquisition.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">Other, less obvious optimizations are possible for the other states as well. </span><span class="koboSpan" id="kobo.661.2">While acquiring data from the sensor, the full computing power of the CPU is possibly never used, as the system is mostly busy communicating with the sensor, or waiting, possibly in sleep mode, until the next value is received. </span><span class="koboSpan" id="kobo.661.3">In this case, we can provide a power-saving running mode, which ensures that the system runs at a reduced frequency so, when alternating between running and sleep mode, both are affected by a smaller energy footprint. </span><span class="koboSpan" id="kobo.661.4">The only phases in which higher performance is required are when the data is processed, transformed, and sent over the network device. </span><span class="koboSpan" id="kobo.661.5">A faster system, in this case, would be optimized to run faster and elaborate data in a shorter time frame. </span><span class="koboSpan" id="kobo.661.6">A stop phase can be foreseen right after the sensor activation if the sensor is able to send an interrupt to wake up the system when it is ready to begin the acquisition of </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">Once each phase has been associated with its optimized low-power mode and selected operating frequency, we can add notations to our design documentation, to remind us how the low-power optimization will be implemented, in the form of state transition, to achieve the best combination of performance, energy economy, and low latency. </span><span class="koboSpan" id="kobo.663.2">The following figure summarizes the transitions between the phases and the associated </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">low-power modes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.665.1"><img alt="Figure 8.3 – Power usage optimization for each running and idling state" src="image/B18730_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.666.1">Figure 8.3 – Power usage optimization for each running and idling state</span></p>
<p><span class="koboSpan" id="kobo.667.1">Tuning </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.668.1">an embedded system for its optimal energy profiles is a delicate process that heavily impacts other performance indicators, introducing delays and slowing down the speed of execution. </span><span class="koboSpan" id="kobo.668.2">In most cases, it consists of finding the best trade-off point between providing acceptable performance while keeping th</span><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.669.1">e power usage and the energy demand within the </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">desired range.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.671.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.672.1">Modern embedded systems open multiple possibilities for low-power and even ultra-low-power designs. </span><span class="koboSpan" id="kobo.672.2">This chapter analyzed the different energy profiles available for the reference microcontroller and how to design, integrate, and evaluate those procedures to control power usage in energy-aware embedded systems. </span><span class="koboSpan" id="kobo.672.3">Having understood several options available for the target, implementing low-power modes and further types of energy-saving techniques is the key to building durable and reliable battery-powered and </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">energy-harvesting devices.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">In the next chapter, we will switch focus to introducing connected devices and describing the impact of dealing with network protocols and interfaces in the embedded </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">system architecture.</span></span></p>
</div>
</body></html>