["```cpp\nstd::unique_ptr<int> p(new int(0));\n```", "```cpp\nclass MyHeap {\n  public:\n  ...\n  void* allocate(size_t size);\n  void deallocate(void* p);\n  ...\n};\nvoid* operator new(size_t size, MyHeap* heap) {\n  return heap->allocate(size);\n}\n```", "```cpp\nMyHeap heap;\nstd::unique_ptr<int> p(new(&heap) int(0));\n```", "```cpp\ntemplate <typename T> struct MyDeleter {\n  void operator()(T* p);\n};\n```", "```cpp\nclass MyDeleter {\n  MyHeap* heap_;\n  public:\n  MyDeleter(MyHeap* heap) : heap_(heap) {}\n  template <typename T> void operator()(T* p) {\n    p->~T();\n    heap_->deallocate(p);\n  }\n};\n```", "```cpp\n// Example 01\nMyHeap heap;\nMyDeleter deleter(&heap);\nstd::unique_ptr<int, MyDeleter> p(\n  new(&heap) int(0), deleter);\n```", "```cpp\nMyHeap heap;\nstd::unique_ptr<int, MyDeleter> p(\n  new(&heap) int(0), MyDeleter(&heap));\n```", "```cpp\n// Example 02\nMyHeap heap;\nstd::unique_ptr<int, MyDeleter> p(\n  new(&heap) int(0), MyDeleter(&heap));\nstd::unique_ptr<int> q(new int(0));\np = std::move(q);    // Error: p and q are different types\n```", "```cpp\nstd::unique_ptr<int> p(new(&heap) int(0),\n  MyDeleter(&heap));    // Does not compile\n```", "```cpp\nstd::unique_ptr<int> p(new int(0));\nstd::shared_ptr<int> q(new int(0));\n```", "```cpp\nMyHeap heap;\nstd::unique_ptr<int, MyDeleter> p(\n  new(&heap) int(0), MyDeleter(&heap));\nstd::shared_ptr<int> q(\n  new(&heap) int(0), MyDeleter(&heap));\n```", "```cpp\n// Example 03\nvoid some_function(std::shared_ptr<int>);     // no deleter\nMyHeap heap;\n{\n  std::shared_ptr<int> p(    // No deleter in the type\n    new(&heap) int(0),\n    MyDeleter(&heap));    // Deleter in constructor only\n  std::shared_ptr<int> q(p);    // No deleter type anywhere\n  some_function(p);    // uses p, no deleter\n}    // Deletion happens, MyDeleter is invoked\n```", "```cpp\nstd::function<int(long, double)> f;\n```", "```cpp\n// Example 04\nstd::function<size_t(const std::string&)> f;\nsize_t f1(const std::string& s) { return s.capacity(); }\nf = f1;\nstd::cout << f(\"abcde\");    // 15\nchar c = 'b';\nf = [=](const std::string& s) { return s.find(c); };\nstd::cout << f(\"abcde\");    // 1\nf = &std::string::size;\nstd::cout << f(\"abcde\");    // 5\n```", "```cpp\nclass Network {\n  …\n  void send(const char* data);\n  void receive(const char* buffer);\n  …\n};\n```", "```cpp\nclass Network {\n  …\n  bool needs_processing;\n  void send(const char* data) {\n    if (needs_processing) apply_processing(buffer);\n    …\n  }\n  …\n};\n```", "```cpp\n// Example 05\nclass Network {\n  static const char* default_processor(const char* data) {\n    std::cout << \"Default processing\" << std::endl;\n    return data;\n  }\n  std::function<const char*(const char*)> processor =\n    default_processor;\n  void send(const char* data) {\n    data = processor(data);\n    …\n  }\n  public:\n  template <typename F>\n  void set_processor(F&& f) { processor = f; }\n};\n```", "```cpp\nNetwork N;\nN.set_processor([](const char* s){ char* c; …; return c; };\n```", "```cpp\n// Example 06\nint less(const void* a, const int* b) {\n  return *(const int*)a - *(const int*)b;\n}\nint main() {\n  int a[10] = { 1, 10, 2, 9, 3, 8, 4, 7, 5, 0 };\n  qsort(a, 10, sizeof(int), less);\n}\n```", "```cpp\nvoid qsort(void *base, size_t nmemb, size_t size,\n  int (*compare)(const void *, const void *));\n```", "```cpp\nint less(const void* a, const int* b) {\n  return *(const int*)a - *(const int*)b;\n}\n```", "```cpp\n// Example 07\ntemplate <typename T> class smartptr {\n  struct destroy_base {\n    virtual void operator()(void*) = 0;\n    virtual ~deleter_base() {}\n  };\n  template <typename Deleter>\n  struct destroy : public destroy _base {\n    destroy (Deleter d) : d_(d) {}\n    void operator()(void* p) override {\n      d_(static_cast<T*>(p));\n    }\n    Deleter d_;\n  };\n  public:\n  template <typename Deleter> smartptr(T* p, Deleter d) :\n    p_(p), d_(new destroy<Deleter>(d)) {}\n  ~smartptr() { (*d_)(p_); delete d_; }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n  private:\n  T* p_;\n  destroy _base* d_;\n};\n```", "```cpp\n// Example 08\nstd::any a(5);\nint i = std::any_cast<int>(a);    // i == 5\nstd::any_cast<long>(a);        // throws bad_any_cast\n```", "```cpp\n// Example 07\ntemplate <typename T> class smartptr {\n  …\n  public:\n  template <typename Deleter> smartptr(T* p, Deleter d) :\n    p_(p) {\n    static_assert(sizeof(Deleter) <= sizeof(buf_));\n    ::new (static_cast<void*>(buf_)) destroy<Deleter>(d));\n  }\n  ~smartptr() {\n    destroy_base* d = (destroy_base*)buf_;\n    (*d)(p_);\n    d->~destroy_base();\n  }\n  private:\n  T* p_;\n  alignas(8) char buf_[16];\n};\n```", "```cpp\nvoid erased_func(void* p) {\n  TE* q = static_cast<T*>(p);\n  … do work on type TE …\n}\n```", "```cpp\ntemplate <typename TE> void erased_func(void* p) {\n  TE* q = static_cast<T*>(p);\n  … do work on type TE …\n}\n```", "```cpp\nvoid(*)(void*) fp = erased_func<int>; // or any other type\n```", "```cpp\n// Example 07\ntemplate <typename T>\nclass smartptr_te_static {\n  T* p_;\n  using destroy_t = void(*)(T*, void*);\n  destroy_t destroy_;\n  alignas(8) char buf_[8];\n  template<typename Deleter>\n  static void invoke_destroy(T* p, void* d) {\n    (*static_cast<Deleter*>(d))(p);\n  }\n  public:\n  template <typename Deleter>\n  smartptr_te_static(T* p, Deleter d)\n    : p_(p), destroy_(invoke_destroy<Deleter>)\n  {\n    static_assert(sizeof(Deleter) <= sizeof(buf_));\n    ::new (static_cast<void*>(buf_)) Deleter(d);\n  }\n  ~smartptr_te_static() {\n    this->destroy_(p_, buf_);\n  }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n};\n```", "```cpp\n// Example 07\ntemplate <typename T>\nclass smartptr_te_vtable {\n  T* p_;\n  struct vtable_t {\n    using destroy_t = void(*)(T*, void*);\n    using destructor_t = void(*)(void*);\n    destroy_t destroy_;\n    destructor_t destructor_;\n  };\n  const vtable_t* vtable_ = nullptr;\n  template <typename Deleter>\n  constexpr static vtable_t vtable = {\n    smartptr_te_vtable::template destroy<Deleter>,\n    smartptr_te_vtable::template destructor<Deleter>\n  };\n  template <typename Deleter>\n  static void destroy(T* p, void* d) {\n    (*static_cast<Deleter*>(d))(p);\n  }\n  template <typename Deleter>\n  static void destructor(void* d) {\n    static_cast<Deleter*>(d)->~Deleter();\n  }\n  alignas(8) char buf_[8];\n  public:\n  template <typename Deleter>\n  smartptr_te_vtable(T* p, Deleter d)\n    : p_(p), vtable_(&vtable<Deleter>)\n  {\n    static_assert(sizeof(Deleter) <= sizeof(buf_));\n    ::new (static_cast<void*>(buf_)) Deleter(d);\n  }\n  ~smartptr_te_vtable() {\n    this->vtable_->destroy_(p_, buf_);\n    this->vtable_->destructor_(buf_);\n  }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n};\n```", "```cpp\ntemplate<typename Signature> class Function;\n```", "```cpp\ntemplate<typename Signature, size_t Size = 16,\n         size_t Alignment = 8> struct Function;\n```", "```cpp\n// Example 09\ntemplate<typename Signature, size_t Size = 16,\n         size_t Alignment = 8> struct Function;\ntemplate<size_t Size, size_t Alignment,\n         typename Res, typename... Args>\nstruct Function<Res(Args...), Size, Alignment> {…};\n```", "```cpp\n// Example 09\nalignas(Alignment) char space_[Size];\n```", "```cpp\n// Example 09\nusing executor_t = Res(*)(Args..., void*);\nexecutor_t executor_;\ntemplate<typename Callable>\nstatic Res executor(Args... args, void* this_function) {\n  return (*reinterpret_cast<Callable*>(\n    static_cast<Function*>(this_function)->space_))\n  (std::forward<Args>(args)...);\n}\n```", "```cpp\n// Example 09\ntemplate <typename CallableArg,\n          typename Callable = std::decay_t<CallableArg>>\n  requires(!std::same_as<Function, Callable>)\nFunction(CallableArg&& callable) :\n  executor_(executor<Callable>)\n{\n  ::new (static_cast<void*>(space_))\n    Callable(std::forward<CallableArg>(callable));\n}\n```", "```cpp\n#define REQUIRES(...) \\\n  std::enable_if_t<__VA_ARGS__, int> = 0\ntemplate <typename CallableArg,\n          typename Callable = std::decay_t<CallableArg>,\n          REQUIRES(!std::is_same_v<Function, Callable>)>)\nFunction(CallableArg&& callable) …\n```", "```cpp\n// Example 09\nstatic constexpr Res default_executor(Args..., void*) {\n  throw std::bad_function_call();\n}\nconstexpr static executor_t default_executor_ =\n  default_executor;\nexecutor_t executor_ = default_executor_;\n```", "```cpp\nFunction<int(int, int, int, int)> f =\n  [](int a, int b, int c, int d) { return a + b + c + d; };\nint res = f(1, 2, 3, 4);\n```", "```cpp\n// Example 09\nusing Signature = int(int, int, int, int);\nusing SF = std::function<Signature>;\nauto invoke_sf(int a, int b, int c, int d, const SF& f) {\n  return f(a, b, c, d);\n}\n```", "```cpp\nendbr64\nsub    $0x28,%rsp\nmov    %r8,%rax\nmov    %fs:0x28,%r8\nmov    %r8,0x18(%rsp)\nxor    %r8d,%r8d\ncmpq   $0x0,0x10(%rax)\nmov    %edi,0x8(%rsp)\nmov    %esi,0xc(%rsp)\nmov    %edx,0x10(%rsp)\nmov    %ecx,0x14(%rsp)\nje     62 <_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x62>\nlea    0xc(%rsp),%rdx\nlea    0x10(%rsp),%rcx\nmov    %rax,%rdi\nlea    0x8(%rsp),%rsi\nlea    0x14(%rsp),%r8\ncallq  *0x18(%rax)\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    67 <_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x67>\nadd    $0x28,%rsp\nretq\ncallq  67 <_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x67>\ncallq  6c <_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x6c>\n```", "```cpp\n// Example 09\nusing F = Function<Signature>;\nauto invoke_f(int a, int b, int c, int d, const F& f) {\n  return f(a, b, c, d);\n}\n```", "```cpp\nendbr64\njmpq   *0x10(%r8)\n```", "```cpp\n$CXX smartptr.C smartptr_ext.C -o smartptr -g –O3 \\\n  -I. -I$GBENCH_DIR/include \\\n  -Wall -Wextra -Werror -pedantic --std=c++20 \\\n  $GBENCH_DIR/lib/libbenchmark.a -lpthread -lrt -lm && \\\n./smartptr\n```", "```cpp\n// Example 07\nstruct deleter {\n  template <typename T> void operator()(T* p) { delete p; }\n};\ndeleter d;\nvoid BM_rawptr(benchmark::State& state) {\n  for (auto _ : state) {\n    int* p = new int(0);\n    d(p);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\n// 07_smartptr.C:\nvoid BM_rawptr(benchmark::State& state) {\n  for (auto _ : state) {\n    int* p = get_raw_ptr()\n    d(p);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n// 07_smartptr_ext.C:\nint* get_raw_ptr() { return new int(0); }\n```", "```cpp\nBenchmark                      Time\nBM_rawptr                   8.72 ns\n```", "```cpp\n// smartptr.C\nvoid BM_uniqueptr(benchmark::State& state) {\n  for (auto _ : state) {\n    auto p(get_unique_ptr());\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n// smartptr_ext.C\nauto get_unique_ptr() {\n  return std::unique_ptr<int, deleter>(new int(0), d);\n}\n```", "```cpp\nBenchmark                      Time\nBM_uniqueptr                8.82 ns\n```", "```cpp\nBenchmark                      Time\nBM_sharedptr                22.9 ns\nBM_make_sharedptr           17.5 ns\nBM_smartptr_te              19.5 ns\n```", "```cpp\nvoid BM_smartptr_te(benchmark::State& state) {\n  for (auto _ : state) {\n    auto get_smartptr_te();\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\nBenchmark                      Time\nBM_smartptr_te_lb           11.3 ns\nBM_smartptr_te_lb0          10.5 ns\nBM_smartptr_te_static       9.58 ns\nBM_smartptr_te_vtable       10.4 ns\n```", "```cpp\n// Example 09\nvoid BM_fast_lambda(benchmark::State& state) {\n  int a = rand(), b = rand(), c = rand(), d = rand();\n  int x = rand();\n  Function<int(int, int, int, int)> f {\n    [=](int a, int b, int c, int d) {\n      return x + a + b + c + d; }\n  };\n  for (auto _ : state) {\n    benchmark::DoNotOptimize(f(a, b, c, d));\n    benchmark::ClobberMemory();\n  }\n}\n```", "```cpp\nBenchmark                      Time\nBM_fast_lambda                 0.884 ns\nBM_std_lambda                   1.33 ns\n```", "```cpp\nBenchmark                      Time\nBM_lambda                      0.219 ns\n```"]