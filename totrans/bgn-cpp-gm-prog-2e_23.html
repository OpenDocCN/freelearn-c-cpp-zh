<html><head></head><body>
		<div><h1 id="_idParaDest-431"><a id="_idTextAnchor445"/><em class="italic">Chapter 22</em>: Using Game Objects and Building a Game</h1>
			<p>This chapter is the final stage of the Space Invaders ++ project. We will learn how to receive input from a gamepad using SFML to do all the hard work and we will also code a class that will handle communication between the invaders and the <code>GameScreen</code> class, as well as the player and the <code>GameScreen</code> class. The class will allow the player and the invaders to spawn bullets, but the exact same technique could be used for any kind of communication that you need between different parts of your own game, so it is useful to know. The final part of the game (as usual) will be the collision detection and the logic of the game itself. Once Space Invaders ++ is up and running, we will learn how to use the Visual Studio debugger, which will be invaluable when you are designing your own logic because it allows you to step through your code a line at a time and see the value of variables. It is also a useful tool for studying the execution flow of the patterns we have assembled over the course of this project.</p>
			<p>Here is what we will do in this chapter:</p>
			<ul>
				<li>Code a solution for spawning bullets</li>
				<li>Handle the player's input, including with a gamepad</li>
				<li>Detect collisions between all the necessary objects</li>
				<li>Code the main logic of the game</li>
				<li>Learn about debugging and understand the execution flow</li>
			</ul>
			<p>Let's start by spawning bullets.</p>
			<h1 id="_idParaDest-432"><a id="_idTextAnchor446"/>Spawning bullets</h1>
			<p>We need a way to spawn bullets from both the player and each of the invaders. The solutions to both are very similar but not identical. We need a way to allow <code>GameInputHandler</code> to spawn bullets when a keyboard key or gamepad button is pressed, and we need <code>InvaderUpdateComponent</code> to use its already existing logic to spawn bullets.</p>
			<p>The <code>GameScreen</code> class has a <code>vector</code> holding all the <code>GameObject</code> instances, so <code>GameScreen</code> is the ideal candidate to move a bullet into position and set it moving up or down the screen, depending on who or what triggered the shot. We need a way for the <code>GameInputHandler</code> class and <code>InvaderUpdateComponenet</code> to communicate with the <code>GameScreen</code> class, but we also need to restrict the communication to just spawning bullets; we don't want them to be able to take control of any other part of the <code>GameScreen</code> class.</p>
			<p>Let's code an abstract class that <code>GameScreen</code> can inherit from. </p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor447"/>Coding the BulletSpawner class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>BulletSpawner.h</code> and add the following code:</p>
			<pre>#include &lt;SFML/Graphics.hpp&gt;
class BulletSpawner
{
public:
    virtual void spawnBullet(
        sf::Vector2f spawnLocation, bool forPlayer) = 0;
};</pre>
			<p>The preceding code creates a new class called <code>BulletSpawner</code> with a single pure virtual function called <code>spawnBullet</code>. The <code>spawnBullet</code> function has two parameters. The first is a <code>Vector2f</code> instance that will determine the spawn location. Actually, as we will see soon, when the bullet is spawned, this position will be tweaked slightly, depending on whether the bullet is going up the screen (as a player bullet) or down the screen (as an invader bullet). The second parameter is a Boolean that will be true if the bullet belongs to the player or false if it belongs to an invader.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>BulletSpawner.cpp</code> and add the following code:</p>
			<pre>/*********************************
******THIS IS AN INTERFACE********
*********************************/</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">As usual, this<code>.cpp</code> file is optional. I just wanted to bring balance to the source.</p>
			<p>Now, go to <code>GameScreen.h</code>, since this is where we will implement the function of this class.</p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor448"/>Updating GameScreen.h</h2>
			<p>First, update the include directives and the class declaration, as highlighted in the following code, to make the <code>GameScreen</code> class inherit from <code>BulletSpawner</code>:</p>
			<pre>#pragma once
#include "Screen.h"
#include "GameInputHandler.h"
#include "GameOverInputHandler.h"
<strong class="bold">#include "BulletSpawner.h"</strong>
class GameScreen : public Screen<strong class="bold">, public BulletSpawner</strong>
{
   …
   …</pre>
			<p>Next, add some extra functions and variable declarations, as highlighted in the following code, to <code>GameScreen.h</code>:</p>
			<pre>private:
    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;
    shared_ptr&lt;GameInputHandler&gt; m_GIH;
<strong class="bold">    int m_NumberInvadersInWorldFile = 0;</strong>
<strong class="bold">    vector&lt;int&gt; m_BulletObjectLocations;</strong>
<strong class="bold">    int m_NextBullet = 0;</strong>
<strong class="bold">    bool m_WaitingToSpawnBulletForPlayer = false;</strong>
<strong class="bold">    bool m_WaitingToSpawnBulletForInvader = false;</strong>
<strong class="bold">    Vector2f m_PlayerBulletSpawnLocation;</strong>
<strong class="bold">    Vector2f m_InvaderBulletSpawnLocation;</strong>
<strong class="bold">    Clock m_BulletClock;</strong>
    Texture m_BackgroundTexture;
    Sprite m_BackgroundSprite;
public:
    static bool m_GameOver;
    GameScreen(ScreenManagerRemoteControl* smrc, Vector2i res);
    void initialise() override;
    void virtual update(float fps);
    void virtual draw(RenderWindow&amp; window);
<strong class="bold">    BulletSpawner* getBulletSpawner();</strong></pre>
			<p>The new variables include a <code>vector</code> of <code>int</code> values that will hold the locations of all the bullets in the <code>vector</code>, which holds all the game objects. It also has a few control variables so that we can keep track of the next bullet to use, whether the bullet is for the player or an invader, and the position to spawn the bullet in. We have also declared a new <code>sf::Clock</code> instance because we want to limit the fire rate of the player. Finally, we have the <code>getBulletSpawner</code> function, which will return a pointer to this class in the form of a <code>BulletSpawner</code>. This will give the recipient access to the <code>spawnBullet</code> function, but nothing else.</p>
			<p>Now, we can add the implementation of the <code>spawnBullet</code> function. Add the following code to <code>GameScreen.h</code> at the end of all the other code, but inside the closing curly brace of the <code>GameScreen</code> class:</p>
			<pre>/****************************************************
*****************************************************
From BulletSpawner interface
*****************************************************
*****************************************************/
void BulletSpawner::spawnBullet(Vector2f spawnLocation, 
    bool forPlayer)
{
    if (forPlayer)
    {
        Time elapsedTime = m_BulletClock.getElapsedTime();
        if (elapsedTime.asMilliseconds() &gt; 500) {
            m_PlayerBulletSpawnLocation.x = spawnLocation.x;
            m_PlayerBulletSpawnLocation.y = spawnLocation.y;
            m_WaitingToSpawnBulletForPlayer = true;
            m_BulletClock.restart();
        }
    }
    else
    {
        m_InvaderBulletSpawnLocation.x = spawnLocation.x;
        m_InvaderBulletSpawnLocation.y = spawnLocation.y;
        m_WaitingToSpawnBulletForInvader = true;
    }
}</pre>
			<p>The implementation of the <code>spawnBullet</code> function is a simple <code>if</code> – <code>else</code> structure. The <code>if</code> block executes if a bullet is requested for the player and the <code>else</code> block executes if a bullet is requested for an invader.</p>
			<p>The <code>if</code> block checks that at least half a second has passed since the last bullet was requested and, if it has, the <code>m_WaitingToSpawnBulletForPlayer</code> variable is set to true, the location to spawn the bullet at is copied, and the clock is restarted, ready to test the player's next request.</p>
			<p>The <code>else</code> block records the spawn location for an invader's bullet and sets <code>m_WaitingToSpawnBulletForInvader</code> to <code>true</code>. No interaction with the <code>Clock</code> instance is necessary as the rate of fire for the invaders is controlled in the <code>InvaderUpdateComponent</code> class.</p>
			<p>The last part of the <code>BulletSpawner</code> puzzle, before we get to actually spawning the bullets, is to add the definition of <code>getBulletSpawner</code> to the end of <code>GameScreen.cpp</code>. Here is the code to add:</p>
			<pre>BulletSpawner* GameScreen::getBulletSpawner()
{
    return this;
}</pre>
			<p>This returns a pointer to <code>GameScreen</code>, which gives us access to the <code>spawnBullet</code> function.</p>
			<h1 id="_idParaDest-435"><a id="_idTextAnchor449"/>Handling the player's input</h1>
			<p>Add some more declarations to the <code>GameInputHandler.h</code> file so that your code matches what follows. I have highlighted the new code to add:</p>
			<pre>#pragma once
#include "InputHandler.h"
<strong class="bold">#include "PlayerUpdateComponent.h"</strong>
<strong class="bold">#include "TransformComponent.h"</strong>
class GameScreen;
class GameInputHandler : public InputHandler
{
<strong class="bold">private:</strong>
<strong class="bold">    shared_ptr&lt;PlayerUpdateComponent&gt; m_PUC;</strong>
<strong class="bold">    shared_ptr&lt;TransformComponent&gt; m_PTC;</strong>
<strong class="bold">    bool mBButtonPressed = false;</strong>
public:
    void initialize();
    void handleGamepad() override;
    void handleKeyPressed(Event&amp; event, 
        RenderWindow&amp; window) override;
    void handleKeyReleased(Event&amp; event, 
        RenderWindow&amp; window) override;    
};</pre>
			<p>The <code>GameInputHandler</code> class now has access to the player's update component and the player's transform component. This is very useful because it means we can tell the <code>PlayerUpdateComponent</code> instance and the player's <code>TransformComponent</code> instance what keyboard keys and gamepad controls the player is manipulating. What we haven't seen yet is how exactly these two shared pointers will be initialized – after all, aren't the <code>GameObject</code> instances and all their components packed away in a <code>vector</code>? You can probably guess the solution has something to do with <code>GameObjectSharer</code>. Let's keep coding to find out more.</p>
			<p>In the <code>GameInputHanldler.cpp</code> file, add a forward declaration of the <code>BulletSpawner</code> class after the include directives but before the initialize function, as highlighted in the following code:</p>
			<pre>#include "GameInputHandler.h"
#include "SoundEngine.h"
#include "GameScreen.h"
<strong class="bold">class BulletSpawner;</strong>
void GameInputHandler::initialize() {
…</pre>
			<p>In the <code>GameInputHandler.cpp</code> file, add the following highlighted code to the <code>handleKeyPressed</code> function:</p>
			<pre>void GameInputHandler::handleKeyPressed(
    Event&amp; event, RenderWindow&amp; window)
{
    // Handle key presses
    if (event.key.code == Keyboard::Escape)
    {
        SoundEngine::playClick();
        getPointerToScreenManagerRemoteControl()-&gt;
            SwitchScreens("Select");
    }
    
<strong class="bold">if (event.key.code == Keyboard::Left)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;moveLeft();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    if (event.key.code == Keyboard::Right)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;moveRight();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    if (event.key.code == Keyboard::Up)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;moveUp();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    if (event.key.code == Keyboard::Down)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;moveDown();</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>Notice that we are responding to keyboard presses just like we have been doing throughout this book. Here, however, we are calling the functions from the <code>PlayerUpdateComponent</code> class that we coded in <a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, in order to take the required actions.</p>
			<p>In the <code>GameInputHandler.cpp</code> file, add the following highlighted code to the <code>handleKeyReleased</code> function:</p>
			<pre>void GameInputHandler::handleKeyReleased(
    Event&amp; event, RenderWindow&amp; window)
{
<strong class="bold">    if (event.key.code == Keyboard::Left)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;stopLeft();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else if (event.key.code == Keyboard::Right)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;stopRight();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else if (event.key.code == Keyboard::Up)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;stopUp();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else if (event.key.code == Keyboard::Down)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PUC-&gt;stopDown();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else if (event.key.code == Keyboard::Space)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Shoot a bullet</strong>
<strong class="bold">        SoundEngine::playShoot();</strong>
<strong class="bold">        Vector2f spawnLocation;</strong>
<strong class="bold">        spawnLocation.x = m_PTC-&gt;getLocation().x + </strong>
<strong class="bold">            m_PTC-&gt;getSize().x / 2;</strong>
<strong class="bold">        spawnLocation.y = m_PTC-&gt;getLocation().y;</strong>
<strong class="bold">        static_cast&lt;GameScreen*&gt;(getmParentScreen())-&gt;</strong>
<strong class="bold">            spawnBullet(spawnLocation, true);</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>The preceding code also relies on calling functions from the <code>PlayerUpdateComponent</code> class to handle what happens when the player releases a keyboard key. The <code>PlayerUpdateComponent</code> class can then stop movement in the appropriate direction, depending on which keyboard key has just been released. When the <em class="italic">space</em> key is released, the <code>getParentScreen</code> function is chained with the <code>spawnBullet</code> function to trigger a bullet being spawned. Notice that the spawn coordinates (<code>spawnLocation</code>) are calculated using the shared pointer to the <code>PlayerTransformComponent</code> instance.</p>
			<p>Let's learn about how SFML helps us interact with a gamepad and then we can return to the <code>PlayerInputHandler</code> class to add some more functionality.</p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor450"/>Using a gamepad</h2>
			<p>Handling gamepad input is made exceptionally easy by SFML. Gamepad (or joystick) input is handled by the <code>sf::Joystick</code> class. SFML can handle input from up to eight gamepads, but this tutorial will stick to just one.</p>
			<p>You can think of the position of a thumbstick/joystick as a 2D graph that starts at -100, -100 at the top left corner and goes to 100, 100 at the bottom right corner. The position of the thumbstick can, therefore, be represented by a 2D coordinate. The following diagram illustrates this with a few example coordinates:</p>
			<div><div><img src="img/B14278_22_01.jpg" alt=""/>
				</div>
			</div>
			<p>All we need to do is grab the value and report it to the <code>PlayerUpdateComponent</code> class for each frame of the game loop. Capturing the position is as simple as the following two lines of code:</p>
			<pre>float x  = Joystick::getAxisPosition(0, sf::Joystick::X);
float y = Joystick::getAxisPosition(0, sf::Joystick::Y);</pre>
			<p>The zero parameter requests data from the primary gamepad. You can use values  0 through 7 to get input from eight gamepads.</p>
			<p>There is something else we need to consider as well. Most gamepads, especially thumbsticks, are mechanically imperfect and will register small values even when they are not being touched. If we send these values to the <code>PlayerUpdateComponent</code> class, then the ship will aimlessly drift around the screen. For this reason, we will create a <code>getAxisPosition</code> function are between -10 and 10 on either axis, we will ignore them. </p>
			<p>To get input from the B button of the gamepad, we use the following line of code:</p>
			<p>// Has the player pressed the B button?</p>
			<pre>if (Joystick::isButtonPressed(0, 1))
{
    // Take action here
}</pre>
			<p>The preceding code detects when the B button on an Xbox One gamepad is pressed. Other controllers will vary. The 0, 1 parameters refer to the primary gamepad and button number 1. To detect when a button is released, we will need to code a bit of our own logic. As we want to shoot a bullet on release and not when it is pressed, we will use a simple Boolean to track this. Let's code the rest of the <code>GameInputHandler</code> class and see how we can put what we have just learned into action.</p>
			<p>In the <code>GameInputHandler.cpp</code> file, add the following highlighted code to the <code>handleGamepad</code> function:</p>
			<pre>void GameInputHandler::handleGamepad()
{
<strong class="bold">    float deadZone = 10.0f;</strong>
<strong class="bold">    float x  = Joystick::getAxisPosition(0, sf::Joystick::X);</strong>
<strong class="bold">    float y = Joystick::getAxisPosition(0, sf::Joystick::Y);    </strong>
<strong class="bold">    </strong>
<strong class="bold">    if (x &lt; deadZone &amp;&amp; x &gt; -deadZone)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        x = 0;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    if (y &lt; deadZone &amp;&amp; y &gt; -deadZone)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        y = 0;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    m_PUC-&gt;updateShipTravelWithController(x, y);    </strong>
<strong class="bold">    // Has the player pressed the B button?</strong>
<strong class="bold">    if (Joystick::isButtonPressed(0, 1))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        mBButtonPressed = true;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    // Has player just released the B button?</strong>
<strong class="bold">    if (!Joystick::isButtonPressed(0, 1) &amp;&amp; mBButtonPressed)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        mBButtonPressed = false;</strong>
<strong class="bold">        // Shoot a bullet</strong>
<strong class="bold">        SoundEngine::playShoot();</strong>
<strong class="bold">        Vector2f spawnLocation;</strong>
<strong class="bold">        spawnLocation.x = m_PTC-&gt;getLocation().x + </strong>
<strong class="bold">            m_PTC-&gt;getSize().x / 2;</strong>
<strong class="bold">        spawnLocation.y = m_PTC-&gt;getLocation().y;</strong>
<strong class="bold">        </strong>
<strong class="bold">        static_cast&lt;GameScreen*&gt;(getmParentScreen())-&gt;</strong>
<strong class="bold">            getBulletSpawner()-&gt;spawnBullet(</strong>
<strong class="bold">               spawnLocation, true);</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>We begin by defining a dead zone of 10 and then proceed to capture the position of the thumbstick. The next two <code>if</code> blocks test whether the thumbstick position is within the dead zone. If it is, then the appropriate value is set to zero to avoid the ship drifting. Then, we can call the <code>updateShipTravelWithController</code> function on the <code>PlayerUpdateComponent</code> instance. That is the thumbstick dealt with.</p>
			<p>The next <code>if</code> statement sets a Boolean to <code>true</code> if the B button on the gamepad is pressed. The next <code>if</code> statement detects when the B button is not pressed, and the Boolean is set to <code>true</code>. This indicates that the B button has just been released.</p>
			<p>Inside the <code>if</code> block, we set the Boolean to <code>false</code>, ready to handle the next button release, play a shooting sound, get the location to spawn the bullet, and call the <code>spawnBullet</code> function by chaining the <code>getmParentScreen</code> and <code>getBulletSpawner</code> functions.</p>
			<h1 id="_idParaDest-437"><a id="_idTextAnchor451"/>Coding the PhysicsEnginePlayMode class</h1>
			<p>This is the class that will do all the collision detection. In this game, there are several collision events we want to watch out for: </p>
			<ul>
				<li>Has an invader reached the left- or right-hand side of the screen? If so, all the invaders need to drop down one row and head back in the other direction.</li>
				<li>Has an invader collided with the player? As the invaders get lower, we want them to be able to bump into the player and cause a life to be lost.</li>
				<li>Has an invader bullet hit the player? Each time an invader bullet hits the player, we need to hide the bullet, ready for reuse, and deduct a life from the player.</li>
				<li>Has a player bullet hit an invader? Each time the player hits an invader, the invader should be destroyed, the bullet hidden (ready for reuse), and the player's score increased.</li>
			</ul>
			<p>This class will have an <code>initialize</code> function that the <code>GameScreen</code> class will call to prepare for detecting collisions, a <code>detectCollisions</code> function that the <code>GameScreen</code> class will call once for each frame after all the game objects have updated themselves, and three more functions which will be called from the <code>detectCollisions</code> function to separate out the work of detecting the different collisions I have just listed. </p>
			<p>Those three functions are <code>detectInvaderCollisions</code>, <code>detectPlayerCollisionsAndInvaderDirection</code>, and <code>handleInvaderDirection</code>. Hopefully, the names of these functions make it clear what will happen in each function.</p>
			<p>Create a new source file in the <code>Header Files/Engine</code> filter called <code>PhysicsEnginePlayMode.h</code> and add the following code:</p>
			<pre>#pragma once
#include "GameObjectSharer.h"
#include "PlayerUpdateComponent.h"
class PhysicsEnginePlayMode
{
private:
    shared_ptr&lt;PlayerUpdateComponent&gt; m_PUC;
    GameObject* m_Player;
    bool m_InvaderHitWallThisFrame = false;
    bool m_InvaderHitWallPreviousFrame = false;
    bool m_NeedToDropDownAndReverse = false;
    bool m_CompletedDropDownAndReverse = false;
    void detectInvaderCollisions(
        vector&lt;GameObject&gt;&amp; objects,
        const vector&lt;int&gt;&amp; bulletPositions);
    void detectPlayerCollisionsAndInvaderDirection(
        vector&lt;GameObject&gt;&amp; objects,
        const vector&lt;int&gt;&amp; bulletPositions);
    void handleInvaderDirection();
public:
    void initilize(GameObjectSharer&amp; gos);
    void detectCollisions(
        vector&lt;GameObject&gt;&amp; objects,
        const vector&lt;int&gt;&amp; bulletPositions);
};</pre>
			<p>Study the preceding code to make a note of the parameters that are passed to each of the functions. Also take note of the four member Boolean variables that will be used throughout the class. Furthermore, notice that there is a pointer to a <code>GameObject</code> type being declared which will be a permanent reference to the player ship, so we don't need to keep finding the <code>GameObject</code> that represents the player for each frame of the game loop.</p>
			<p>Create a new source file in the <code>Source Files/Engine</code> filter called <code>PhysicsEnginePlayMode.cpp</code> and add the following include directives and the <code>detectInvaderCollisions</code> function. Study the code and then we will discuss it:</p>
			<pre>#include "DevelopState.h"
#include "PhysicsEnginePlayMode.h"
#include &lt;iostream&gt;
#include "SoundEngine.h"
#include "WorldState.h"
#include "InvaderUpdateComponent.h"
#include "BulletUpdateComponent.h"
void PhysicsEnginePlayMode::
detectInvaderCollisions(
    vector&lt;GameObject&gt;&amp; objects, 
    const vector&lt;int&gt;&amp; bulletPositions)
{
Vector2f offScreen(-1, -1);
auto invaderIt = objects.begin();
auto invaderEnd = objects.end();
for (invaderIt;
    invaderIt != invaderEnd;
    ++invaderIt)
{
    if ((*invaderIt).isActive()
        &amp;&amp; (*invaderIt).getTag() == "invader")
    {
        auto bulletIt = objects.begin();
        // Jump to the first bullet
        advance(bulletIt, bulletPositions[0]);
        auto bulletEnd = objects.end();
        for (bulletIt;
            bulletIt != bulletEnd;
            ++bulletIt)
        {
            if ((*invaderIt).getEncompassingRectCollider()
                .intersects((*bulletIt)
                    .getEncompassingRectCollider())
                &amp;&amp; (*bulletIt).getTag() == "bullet"
                &amp;&amp; static_pointer_cast&lt;
                      BulletUpdateComponent&gt;(
                (*bulletIt).getFirstUpdateComponent())
                -&gt;m_BelongsToPlayer)
            {
                SoundEngine::playInvaderExplode();
                (*invaderIt).getTransformComponent()
                    -&gt;getLocation() = offScreen;
                (*bulletIt).getTransformComponent()
                    -&gt;getLocation() = offScreen;
                WorldState::SCORE++;
                WorldState::NUM_INVADERS--;
                (*invaderIt).setInactive();
            }
        }
    }
}
}</pre>
			<p>The preceding code loops through all the game objects. The first <code>if</code> statement checks whether the current game object is both active and an invader:</p>
			<pre>if ((*invaderIt).isActive()
        &amp;&amp; (*invaderIt).getTag() == "invader")</pre>
			<p>If it is an active invader, another loop is entered and each of the game objects that represents a bullet is looped through:</p>
			<pre>auto bulletIt = objects.begin();
// Jump to the first bullet
advance(bulletIt, bulletPositions[0]);
auto bulletEnd = objects.end();
for (bulletIt;
    bulletIt != bulletEnd;
    ++bulletIt)</pre>
			<p>The next <code>if </code>statement checks whether the current invader has collided with the current bullet and whether that bullet was fired by the player (we don't want invaders shooting themselves):</p>
			<pre>if ((*invaderIt).getEncompassingRectCollider()
        .intersects((*bulletIt)
        .getEncompassingRectCollider())
        &amp;&amp; (*bulletIt).getTag() == "bullet"
        &amp;&amp; static_pointer_cast&lt;BulletUpdateComponent&gt;(
        (*bulletIt).getFirstUpdateComponent())
        -&gt;m_BelongsToPlayer)</pre>
			<p>When this test is true, a sound is played, the bullet is moved off-screen, the number of invaders is decremented, the player's score is increased, and the invader is set to inactive.</p>
			<p>Now, we will detect player collisions and the invader's direction of travel.</p>
			<p>Add the <code>detectPlayerCollisionsAndInvaderDirection</code> function, as follows:</p>
			<pre>void PhysicsEnginePlayMode::
detectPlayerCollisionsAndInvaderDirection(
    vector&lt;GameObject&gt;&amp; objects, 
    const vector&lt;int&gt;&amp; bulletPositions)
{
Vector2f offScreen(-1, -1);
FloatRect playerCollider = 
    m_Player-&gt;getEncompassingRectCollider();
shared_ptr&lt;TransformComponent&gt; playerTransform = 
    m_Player-&gt;getTransformComponent();
Vector2f playerLocation = 
    playerTransform-&gt;getLocation();
auto it3 = objects.begin();
auto end3 = objects.end();
for (it3;
    it3 != end3;
    ++it3)
{
    if ((*it3).isActive() &amp;&amp;
        (*it3).hasCollider() &amp;&amp;
        (*it3).getTag() != "Player")
    {
        // Get a reference to all the parts of 
        // the current game object we might need
        FloatRect currentCollider = (*it3)
            .getEncompassingRectCollider();
        // Detect collisions between objects 
        // with the player
        if (currentCollider.intersects(playerCollider))
        {
            if ((*it3).getTag() == "bullet")
            {
                SoundEngine::playPlayerExplode();
                WorldState::LIVES--;
                (*it3).getTransformComponent()-&gt;
                    getLocation() = offScreen;
            }
            if ((*it3).getTag() == "invader")
            {
                SoundEngine::playPlayerExplode();
                SoundEngine::playInvaderExplode();
                WorldState::LIVES--;
                (*it3).getTransformComponent()-&gt;
                    getLocation() = offScreen;
                WorldState::SCORE++;
                (*it3).setInactive();
            }
        }
        shared_ptr&lt;TransformComponent&gt; 
            currentTransform =
            (*it3).getTransformComponent();
        Vector2f currentLocation = 
            currentTransform-&gt;getLocation();
        string currentTag = (*it3).getTag();
        Vector2f currentSize = 
            currentTransform-&gt;getSize();
        // Handle the direction and descent 
        // of the invaders
        if (currentTag == "invader")
        {
            // This is an invader
            if (!m_NeedToDropDownAndReverse &amp;&amp; 
                !m_InvaderHitWallThisFrame)
            {
                // Currently no need to dropdown 
                // and reverse from previous frame 
                // or any hits this frame
                if (currentLocation.x &gt;= 
                    WorldState::WORLD_WIDTH – 
                            currentSize.x)
                {
                    // The invader is passed its 
                    // furthest right position
                    if (static_pointer_cast
                        &lt;InvaderUpdateComponent&gt;((*it3)
                        .getFirstUpdateComponent())-&gt;
                        isMovingRight())
                    {
                        // The invader is travelling 
                        // right so set a flag that
                        // an invader has collided
                         
                        m_InvaderHitWallThisFrame 
                                         = true;
                    }
                }
                else if (currentLocation.x &lt; 0)
                {
                    // The invader is past its furthest 
                    // left position
                    if (!static_pointer_cast
                        &lt;InvaderUpdateComponent&gt;(        
                            (*it3).getFirstUpdateComponent())
                        -&gt;isMovingRight())
                    {
                        // The invader is travelling 
                        // left so set a flag that an
                        // invader has collided 
                        m_InvaderHitWallThisFrame 
                                         = true;
                    }
                }
            }
            else if (m_NeedToDropDownAndReverse 
                &amp;&amp; !m_InvaderHitWallPreviousFrame)
            {
                // Drop down and reverse has been set
                if ((*it3).hasUpdateComponent())
                {
                    // Drop down and reverse
                    static_pointer_cast&lt;
                            InvaderUpdateComponent&gt;(            
                            (*it3).getFirstUpdateComponent())
                    -&gt;dropDownAndReverse();
                }
            }
        }
    }
}
}</pre>
			<p>The preceding code is longer than the previous function because we are checking for more conditions. Before the code loops through all the game objects, it gets a reference to all the relevant player data. This is so we don't have to do this for every check:</p>
			<pre>FloatRect playerCollider = 
    m_Player-&gt;getEncompassingRectCollider();
shared_ptr&lt;TransformComponent&gt; playerTransform = 
    m_Player-&gt;getTransformComponent();
Vector2f playerLocation = 
    playerTransform-&gt;getLocation();</pre>
			<p>Next, the loop goes through every game object. The first <code>if</code> test checks whether the current object is active, has a collider, and is not the player. We don't want to test the player colliding with themselves:</p>
			<pre>if ((*it3).isActive() &amp;&amp;
    (*it3).hasCollider() &amp;&amp;
    (*it3).getTag() != "Player")</pre>
			<p>The next <code>if</code> test does the actual collision detection to see if the current game object intersects with the player:</p>
			<pre>if (currentCollider.intersects(playerCollider))</pre>
			<p>Next, there are two nested <code>if</code> statements: one that handles collisions with a bullet belonging to an invader and one that handles collisions with an invader.</p>
			<p>Next, the code checks each and every game object that is an invader to see whether it has hit the left- or right-hand side of the screen. Note that the <code>m_NeedToDropDownAndReverse</code> and <code>m_InvaderHitWallLastFrame</code> Boolean variables are used because it will not always be the first invader in the vector that hits the side of the screen. Therefore, detecting the collision and triggering dropdown and reversal are handled in consecutive frames to guarantee that all the invaders drop down and reverse, regardless of which one of them triggers it.</p>
			<p>Finally, when both conditions are <code>true</code>, <code>handleInvaderDirection</code> is called.</p>
			<p>Add the <code>handleInvaderDirection</code> function, as follows:</p>
			<pre>void PhysicsEnginePlayMode::handleInvaderDirection()
{
    if (m_InvaderHitWallThisFrame) {
        m_NeedToDropDownAndReverse = true;
        m_InvaderHitWallThisFrame = false;
    }
    else {
        m_NeedToDropDownAndReverse = false;
    }
}</pre>
			<p>This function just sets and unsets Booleans accordingly so that the next pass through the <code>detectPlayerCollisionAndDirection</code> function will actually drop-down the invaders and change their direction.</p>
			<p>Add the <code>initialize</code> function to prepare the class for action:</p>
			<pre>void PhysicsEnginePlayMode::initilize(GameObjectSharer&amp; gos) {
    m_PUC = static_pointer_cast&lt;PlayerUpdateComponent&gt;(
        gos.findFirstObjectWithTag("Player")
        .getComponentByTypeAndSpecificType("update", "player"));
    m_Player = &amp;gos.findFirstObjectWithTag("Player");
}</pre>
			<p>In the preceding code, the pointer to <code>PlayerUpdateComponent</code> is initialized, as well as the pointer to the player <code>GameObject</code>. This will avoid calling these relatively slow functions during the game loop.</p>
			<p>Add the <code>detectCollisions</code> function, which will be called from the <code>GameScreen</code> class once each frame:</p>
			<pre>void PhysicsEnginePlayMode::detectCollisions(
    vector&lt;GameObject&gt;&amp; objects,
    const vector&lt;int&gt;&amp; bulletPositions)
{
    detectInvaderCollisions(objects, bulletPositions);
    detectPlayerCollisionsAndInvaderDirection(
        objects, bulletPositions);
    handleInvaderDirection();    
}</pre>
			<p>The <code>detectCollisions</code> function calls the three functions that handle the different phases of collision detection. You could have lumped all the code into this single function, but then it would be quite unwieldy. Alternatively, you could separate the three big functions into their own <code>.cpp</code> files, just like we did with the <code>update</code> and <code>draw</code> functions in the Thomas Was Late game.</p>
			<p>In the next section, we will create an instance of the <code>PhysicsEngineGameMode</code> class and use it in the <code>GameScreen</code> class as we bring the game to life.</p>
			<h1 id="_idParaDest-438"><a id="_idTextAnchor452"/>Making the game</h1>
			<p>By the end of this section, we will have a playable game. In this section, we will add code to the <code>GameScreen</code> class to bring together everything we have been coding over the last three chapters. To get started, add an instance of <code>PhysicsEngineGameMode</code> to <code>GameScreen.h</code> by adding an extra include directive, as follows:</p>
			<pre>#include "PhysicsEnginePlayMode.h"</pre>
			<p>Then, declare an instance, as highlighted in the following code:</p>
			<pre>private:
    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;
    shared_ptr&lt;GameInputHandler&gt; m_GIH;
<strong class="bold">    PhysicsEnginePlayMode m_PhysicsEnginePlayMode;</strong>
…
…</pre>
			<p>Now, open the <code>GameScreen.cpp</code> file, add some extra include directives, and forward-declare the <code>BulletSpawner</code> class, as highlighted in the following code:</p>
			<pre>#include "GameScreen.h"
#include "GameUIPanel.h"
#include "GameInputHandler.h"
#include "GameOverUIPanel.h"
<strong class="bold">#include "GameObject.h"</strong>
<strong class="bold">#include "WorldState.h"</strong>
<strong class="bold">#include "BulletUpdateComponent.h"</strong>
<strong class="bold">#include "InvaderUpdateComponent.h"</strong>
<strong class="bold">class BulletSpawner;</strong>
int WorldState::WORLD_HEIGHT;
int WorldState::NUM_INVADERS;
int WorldState::NUM_INVADERS_AT_START;</pre>
			<p>Next, in the <code>GameScreen.cpp</code> file, update the <code>initialize</code> function by adding the following highlighted code inside the existing code:</p>
			<pre>void GameScreen::initialise()
{
    m_GIH-&gt;initialize();
<strong class="bold">    m_PhysicsEnginePlayMode.initilize(</strong>
<strong class="bold">        m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">        shareGameObjectSharer());</strong>
    WorldState::NUM_INVADERS = 0;
<strong class="bold">    // Store all the bullet locations and</strong>
<strong class="bold">    // Initialize all the BulletSpawners in the invaders</strong>
<strong class="bold">    // Count the number of invaders</strong>
<strong class="bold">    int i = 0;</strong>
<strong class="bold">    auto it = m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">        getGameObjects().begin();</strong>
<strong class="bold">    auto end = m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">        getGameObjects().end();</strong>
<strong class="bold">    for (it;</strong>
<strong class="bold">        it != end;</strong>
<strong class="bold">        ++it)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if ((*it).getTag() == "bullet")</strong>
<strong class="bold">        {</strong>
<strong class="bold">            m_BulletObjectLocations.push_back(i);</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if ((*it).getTag() == "invader")</strong>
<strong class="bold">        {</strong>
<strong class="bold">            static_pointer_cast&lt;InvaderUpdateComponent&gt;(</strong>
<strong class="bold">                (*it).getFirstUpdateComponent())-&gt;</strong>
<strong class="bold">                initializeBulletSpawner(</strong>
<strong class="bold">                    getBulletSpawner(), i);</strong>
<strong class="bold">            WorldState::NUM_INVADERS++;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        ++i;</strong>
<strong class="bold">    }</strong>
    m_GameOver = false;
    if (WorldState::WAVE_NUMBER == 0)
    {
        WorldState::NUM_INVADERS_AT_START = 
            WorldState::NUM_INVADERS;
            
        WorldState::WAVE_NUMBER = 1;
        WorldState::LIVES = 3;
        WorldState::SCORE = 0;
    }
}</pre>
			<p>The preceding code in the <code>initialize</code> function initializes the physics engine that will handle all the collision detection. Next, it loops through all the game objects and performs two tasks: one task in each of the <code>if</code> blocks.</p>
			<p>The first <code>if</code> block tests whether the current game object is a bullet. If it is, then its integer location in the vector of game objects is stored in the <code>m_BulletObjectLocations vector</code>. Remember from when we coded the physics engine that this <code>vector</code> is useful when doing collision detection. The vector will also be used in this class to keep track of the next bullet to use when the player or an invader wants to take a shot.</p>
			<p>The second <code>if</code> block detects whether the current game object is an invader and, if it is, calls the <code>initializeBulletSpawner</code> function on its update component and passes in a pointer to a <code>BulletSpawner</code> by calling the <code>getBulletSpawner</code> function. The invaders are now capable of spawning bullets. </p>
			<p>Now, we need to add some code to the <code>update</code> function to handle what happens in each frame of the game during the updating phase. This is highlighted in the following code. All the new code goes inside the already existing <code>if(!m_GameOver)</code> block:</p>
			<pre>void GameScreen::update(float fps)
{
    Screen::update(fps);
    if (!m_GameOver)
    {
<strong class="bold">        if (m_WaitingToSpawnBulletForPlayer)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            static_pointer_cast&lt;BulletUpdateComponent&gt;(</strong>
<strong class="bold">                m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">                getGameObjects()</strong>
<strong class="bold">                [m_BulletObjectLocations[m_NextBullet]].</strong>
<strong class="bold">                getFirstUpdateComponent())-&gt;</strong>
<strong class="bold">                spawnForPlayer(</strong>
<strong class="bold">                      m_PlayerBulletSpawnLocation);</strong>
<strong class="bold">            </strong>
<strong class="bold">            m_WaitingToSpawnBulletForPlayer = false;</strong>
<strong class="bold">            m_NextBullet++;</strong>
<strong class="bold">            if (m_NextBullet == m_BulletObjectLocations</strong>
<strong class="bold">                      .size())</strong>
<strong class="bold">            {</strong>
<strong class="bold">                m_NextBullet = 0;</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (m_WaitingToSpawnBulletForInvader)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            static_pointer_cast&lt;BulletUpdateComponent&gt;(</strong>
<strong class="bold">                m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">                getGameObjects()</strong>
<strong class="bold">                [m_BulletObjectLocations[m_NextBullet]].</strong>
<strong class="bold">                getFirstUpdateComponent())-&gt;</strong>
<strong class="bold">                spawnForInvader(</strong>
<strong class="bold">                      m_InvaderBulletSpawnLocation);</strong>
<strong class="bold">            </strong>
<strong class="bold">            m_WaitingToSpawnBulletForInvader = false;</strong>
<strong class="bold">            m_NextBullet++;</strong>
<strong class="bold">            if (m_NextBullet == </strong>
<strong class="bold">                      m_BulletObjectLocations.size())</strong>
<strong class="bold">            {</strong>
<strong class="bold">                m_NextBullet = 0;</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">        auto it = m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">            getGameObjects().begin();</strong>
<strong class="bold">        auto end = m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">            getGameObjects().end();</strong>
<strong class="bold">        for (it;</strong>
<strong class="bold">            it != end;</strong>
<strong class="bold">            ++it)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            (*it).update(fps);</strong>
<strong class="bold">        }</strong>
<strong class="bold">        </strong>
<strong class="bold">        m_PhysicsEnginePlayMode.detectCollisions(</strong>
<strong class="bold">            m_ScreenManagerRemoteControl-&gt;getGameObjects(), </strong>
<strong class="bold">            m_BulletObjectLocations);</strong>
        if (WorldState::NUM_INVADERS &lt;= 0)
        {
            WorldState::WAVE_NUMBER++;
            m_ScreenManagerRemoteControl-&gt;
                loadLevelInPlayMode("level1");
        }
        
        if (WorldState::LIVES &lt;= 0)
        {
            m_GameOver = true;            
        }
    }
}</pre>
			<p>In the preceding new code, the first <code>if</code> block checks whether a new bullet is required for the player. If it is the next available bullet, the <code>GameObject</code> instance, has its <code>BulletUpdateComponent</code> instance's <code>spawnForPlayer</code> function called. The specific <code>GameObject</code> instance to use is identified using the <code>m_NextBulletObject</code> variable with the <code>m_BulletObjectLocations</code> vector. The remaining code in the first <code>if</code> block prepares for the next bullet to be fired.</p>
			<p>The second <code>if</code> block executes if an invader is waiting for a bullet to be fired. Exactly the same technique is used to activate a bullet, except the <code>spawnForInvader</code> function is used, which sets it moving downward.</p>
			<p>Next, there is a loop which loops through every game object. This is key to everything because, inside the loop, the <code>update</code> function is called on every <code>GameObject</code> instance.</p>
			<p>The final line of code in the preceding new code calls the <code>detectCollisions</code> function to see if any of the <code>GameObject</code> instances (in their just-updated positions) have collided.</p>
			<p>Finally, we will add some code to the <code>draw</code> function in <code>GameScreen.cpp</code>. The new code is highlighted inside the existing code in the following listing:</p>
			<pre>void GameScreen::draw(RenderWindow &amp; window)
{    
    // Change to this screen's view to draw
    window.setView(m_View);
    window.draw(m_BackgroundSprite);
<strong class="bold">    // Draw the GameObject instances</strong>
<strong class="bold">    auto it = m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">        getGameObjects().begin();</strong>
<strong class="bold">    auto end = m_ScreenManagerRemoteControl-&gt;</strong>
<strong class="bold">        getGameObjects().end();</strong>
<strong class="bold">    for (it;</strong>
<strong class="bold">        it != end;</strong>
<strong class="bold">        ++it)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        (*it).draw(window);</strong>
<strong class="bold">    }</strong>
    // Draw the UIPanel view(s)
    Screen::draw(window);
}</pre>
			<p>The preceding code simply calls the <code>draw</code> function on each of the <code>GameObject</code> instances in turn. Now, you have completed the Space Invaders ++ project and can run the game. Congratulations!</p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor453"/>Understanding the flow of execution and debugging</h1>
			<p>Much of the last four chapters has been about the code structure. It is very possible that you still have doubts and uncertainties about which class instantiates which instance or in what order the various functions are called. Wouldn't it be useful if there was a way to execute the project and follow the path of execution from <code>int main()</code> right through to <code>return 0;</code> in the <code>Space Invaders ++.cpp</code> file? It turns out we can, and the following is how to do it.</p>
			<p>We will now explore the debugging facilities in Visual Studio while simultaneously trying to understand the structure of the project.</p>
			<p>Open the <code>Space Invaders ++.cpp</code> file and find the first line of code, as follows:</p>
			<pre>GameEngine m_GameEngine;</pre>
			<p>The preceding code is the first line of code that gets executed. It declares an instance of the <code>GameEngine</code> class and sets all our hard work in motion.</p>
			<p>Right-click the preceding line of code and select <strong class="bold">Breakpoint</strong> | <strong class="bold">Insert Breakpoint</strong>. The following is what the screen should look like:</p>
			<div><div><img src="img/B14278_22_02.jpg" alt=""/>
				</div>
			</div>
			<p>Notice that there is a red circle next to the line of code. This is a breakpoint. When you run the code, execution will pause at this point and we will have some interesting options available to us.</p>
			<p>Run the game in the usual way. When execution pauses, an arrow indicates the current line of execution, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_22_03.jpg" alt=""/>
				</div>
			</div>
			<p>If you hover the mouse over the <code>m_GameEngine</code> text and then click the arrow (the top-left corner in the following screenshot), you will get a preview of all the member variables and their values in the <code>m_GameEngine</code> instance:</p>
			<div><div><img src="img/B14278_22_04.jpg" alt=""/>
				</div>
			</div>
			<p>Let's progress through the code. In the main menu, look for the following set of icons:</p>
			<div><div><img src="img/B14278_22_05.jpg" alt=""/>
				</div>
			</div>
			<p>If you click the arrow icon highlighted in the previous screenshot, it will move to the next line of code. This arrow icon is the <code>GameEngine</code> constructor function. You can keep clicking the <strong class="bold">Step into</strong> button and examine the value of any of the variables at any stage.</p>
			<p>If you click into the initialization of <code>m_Resolution</code>, then you will see the code jumps into the <code>Vector2i</code> class provided by SFML. Keep clicking to see the code flow progress through all the steps that make up our game. </p>
			<p>If you want to skip to the next function, you can click the <strong class="bold">Step out</strong> button, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_22_06.jpg" alt=""/>
				</div>
			</div>
			<p>Follow the flow of execution for as long as it interests you. When you are done, simply click the <strong class="bold">Stop</strong> button, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_22_07.jpg" alt=""/>
				</div>
			</div>
			<p>Alternatively, if you want to run the game without stepping through the code, you can click the <strong class="bold">Continue</strong> button shown in the following screenshot. Note, however, that if the breakpoint is placed inside a loop, it will stop each time the flow of execution reaches the breakpoint:</p>
			<div><div><img src="img/B14278_22_08.jpg" alt=""/>
				</div>
			</div>
			<p>If you <a id="_idTextAnchor454"/>want to examine the flow of code from a different starting point and don't want to have to click through every line or function from the start, then all you need to do is set a different breakpoint. </p>
			<p>You can delete a breakpoint by stopping debugging (with the <strong class="bold">Stop</strong> button), right-clicking the red circle, and selecting <strong class="bold">Delete Breakpoint</strong>.</p>
			<p>You could then begin stepping through the game loop by setting a breakpoint at the first line of code in the <code>update</code> function of <code>GameEngine.cpp</code>. You can put a breakpoint anywhere, so feel free to explore the flow of execution in individual components or anywhere else. One of the key parts of the code that is worth examining is the flow of execution in the <em class="italic">update</em> function of the <code>GameScreen</code> class. Why not try it?</p>
			<p>While what we have just explored is useful and instructive, the real purpose of these facilities provided by Visual Studio is to debug our games. Whenever you get behavior that is not as you expect, just add a breakpoint to any likely lines that might be causing the problem, step through the execution, and observe the variable values.</p>
			<h1 id="_idParaDest-440"><a id="_idTextAnchor455"/>Reusing the code to make a different game and building a design mode</h1>
			<p>On a few occasions, we have already discussed  the possibility that this system we have coded can be reused to make a totally different game. I just thought it was worth giving this fact a full hearing.</p>
			<p>The way that you would make a different game is as follows. I have already mentioned that you could code the appearance of game objects into new components that derive from the <code>GraphicsComponent</code> class and that you could code new behaviors into classes that derive from the <code>UpdateComponent</code> class. </p>
			<p>Suppose you wanted a set of game objects that had overlapping behaviors; consider perhaps a 2D game where the enemy hunted the player and then shot at the player at a certain distance.</p>
			<p>Maybe you could have an enemy type that got close to the player and fired a pistol at the player and an enemy type that took long distance shots at the player, like a sniper might. </p>
			<p>You could code an <code>EnemyShooterUpdateComponent</code> class and an <code>EnemySniperUpdateComponent</code> class. You could get a shared pointer to the player transform component during the <code>start</code> function and code an abstract class (such as  <code>BulletSpawner</code>) to trigger spawning shots at the player, and you would be done. </p>
			<p>Consider, however, that both of these game objects would have code to take a shot and code to close in on the player. Then consider that, at some stage, you might want a "brawler" enemy who tries to punch the player. </p>
			<p>The current system can also have multiple update components. You could then have a <code>ChasePlayerUpdateComponent</code> class which closes in on the player and separate update components to punch, shoot, or snipe the player. The punching/shooting/sniping component would enforce some values on the chasing component regarding when to stop and start chasing, and then the more specific component (punch, shoot, or snipe) would attack the player when prompted that the time was right. </p>
			<p>As we've already mentioned, the ability to call the <code>update</code> function on multiple different update components is already built into the code, although it has never been tested. If you take a look at the <code>update</code> function in <code>GameObject.cpp</code>, you will see this code:</p>
			<pre>    for (int i = m_FirstUpdateComponentLocation; i &lt; 
        m_FirstUpdateComponentLocation + 
        m_NumberUpdateComponents; i++) 
    {
   …
}</pre>
			<p>In the preceding code, the <code>update</code> function would be called on as many update components that are present. You just need to code them and add them to specific game objects in the <code>level1.txt</code> file. Using this system, a game object can have as many update components as it needs, allowing you to encapsulate very specific behaviors and share them as needed around the required game objects.</p>
			<p>When you want to create a pool of objects, like we did for the invaders and the bullets, you can be more efficient than we were in the Space Invaders ++ project. For the purposes of showing you how to position objects in the game world, we added all the invaders and bullets individually. In a real project, you would simply design a type that represents a pool of bullets, perhaps a magazine of bullets, like so:</p>
			<pre>[NAME]magazine of bullets[-NAME]</pre>
			<p>You could do the same for a fleet of invaders:</p>
			<pre>[NAME]fleet of invaders[-NAME]</pre>
			<p>Then, you would code the factory to handle a magazine or a fleet, probably with a <code>for</code> loop, and the slightly cumbersome text file would be improved upon. And, of course, there is no limit to the number of different levels you can design across multiple text files. More likely names for these text files are <code>beach_level.txt</code> or <code>urban_level.txt</code>.</p>
			<p>You might have wondered about the names of some of the classes, such as  <code>PhysicsEnginePlayMode</code> or <code>GameObjectFactoryPlayMode</code>. This implies that <code>…PlayMode</code> is just one option for these classes.</p>
			<p>The suggestion I am making here is that, even if you use the fleet/magazine strategy in your level design files, they could still become cumbersome and unwieldy as they grow. It would be much better if you could view the levels and edit them on-screen and then save changes back to the file. </p>
			<p>You would certainly need new physics engine rules (detecting clicks and drags on objects), a new screen type (that didn't update each frame), and probably new classes for interpreting and building the objects from the text files. The point is, however, that the Entity-Component/screen/UI panel/input handling systems could remain unchanged.</p>
			<p>There isn't even anything stopping you from devising some completely new component types, for example, a scrolling background object that detects which direction the player is moving and moves accordingly, or perhaps an interactive lift object that detects when the player is standing on it and then accepts input to move up and down. We could even have a door that opens and closes, or a teleport object that detects input when the player is touching it and loads a new level from another text file. The point here is that these are all game mechanics that can be easily integrated into the same system.</p>
			<p>I could go on about these possibilities for much longer, but you would probably rather make your own game.</p>
			<h1 id="_idParaDest-441"><a id="_idTextAnchor456"/>Summary</h1>
			<p>In this chapter, we finally completed the Space Invaders ++ game. We coded a way for game objects to request bullets to be spawned, learned how to receive input from a gamepad, and we put in the final logic of the game to bring it to life. </p>
			<p>Perhaps the most important thing to take from this chapter, however, is how the toil of the last four chapters will help you get started on your next project.</p>
			<p>There is one final chapter in this slightly chunky book, and it is a short and simple one, I promise.</p>
		</div>
	</body></html>