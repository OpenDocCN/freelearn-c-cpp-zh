<html><head></head><body>
		<div id="_idContainer138">
			<h1 id="_idParaDest-431"><a id="_idTextAnchor445"/><em class="italic">Chapter 22</em>: Using Game Objects and Building a Game</h1>
			<p>This chapter is the final stage of the Space Invaders ++ project. We will learn how to receive input from a gamepad using SFML to do all the hard work and we will also code a class that will handle communication between the invaders and the <strong class="source-inline">GameScreen</strong> class, as well as the player and the <strong class="source-inline">GameScreen</strong> class. The class will allow the player and the invaders to spawn bullets, but the exact same technique could be used for any kind of communication that you need between different parts of your own game, so it is useful to know. The final part of the game (as usual) will be the collision detection and the logic of the game itself. Once Space Invaders ++ is up and running, we will learn how to use the Visual Studio debugger, which will be invaluable when you are designing your own logic because it allows you to step through your code a line at a time and see the value of variables. It is also a useful tool for studying the execution flow of the patterns we have assembled over the course of this project.</p>
			<p>Here is what we will do in this chapter:</p>
			<ul>
				<li>Code a solution for spawning bullets</li>
				<li>Handle the player's input, including with a gamepad</li>
				<li>Detect collisions between all the necessary objects</li>
				<li>Code the main logic of the game</li>
				<li>Learn about debugging and understand the execution flow</li>
			</ul>
			<p>Let's start by spawning bullets.</p>
			<h1 id="_idParaDest-432"><a id="_idTextAnchor446"/>Spawning bullets</h1>
			<p>We need a way to spawn bullets from both the player and each of the invaders. The solutions to both are very similar but not identical. We need a way to allow <strong class="source-inline">GameInputHandler</strong> to spawn bullets when a keyboard key or gamepad button is pressed, and we need <strong class="source-inline">InvaderUpdateComponent</strong> to use its already existing logic to spawn bullets.</p>
			<p>The <strong class="source-inline">GameScreen</strong> class has a <strong class="source-inline">vector</strong> holding all the <strong class="source-inline">GameObject</strong> instances, so <strong class="source-inline">GameScreen</strong> is the ideal candidate to move a bullet into position and set it moving up or down the screen, depending on who or what triggered the shot. We need a way for the <strong class="source-inline">GameInputHandler</strong> class and <strong class="source-inline">InvaderUpdateComponenet</strong> to communicate with the <strong class="source-inline">GameScreen</strong> class, but we also need to restrict the communication to just spawning bullets; we don't want them to be able to take control of any other part of the <strong class="source-inline">GameScreen</strong> class.</p>
			<p>Let's code an abstract class that <strong class="source-inline">GameScreen</strong> can inherit from. </p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor447"/>Coding the BulletSpawner class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">BulletSpawner.h</strong> and add the following code:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">class BulletSpawner</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void spawnBullet(</p>
			<p class="source-code">        sf::Vector2f spawnLocation, bool forPlayer) = 0;</p>
			<p class="source-code">};</p>
			<p>The preceding code creates a new class called <strong class="source-inline">BulletSpawner</strong> with a single pure virtual function called <strong class="source-inline">spawnBullet</strong>. The <strong class="source-inline">spawnBullet</strong> function has two parameters. The first is a <strong class="source-inline">Vector2f</strong> instance that will determine the spawn location. Actually, as we will see soon, when the bullet is spawned, this position will be tweaked slightly, depending on whether the bullet is going up the screen (as a player bullet) or down the screen (as an invader bullet). The second parameter is a Boolean that will be true if the bullet belongs to the player or false if it belongs to an invader.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">BulletSpawner.cpp</strong> and add the following code:</p>
			<p class="source-code">/*********************************</p>
			<p class="source-code">******THIS IS AN INTERFACE********</p>
			<p class="source-code">*********************************/</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As usual, this<strong class="source-inline">.cpp</strong> file is optional. I just wanted to bring balance to the source.</p>
			<p>Now, go to <strong class="source-inline">GameScreen.h</strong>, since this is where we will implement the function of this class.</p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor448"/>Updating GameScreen.h</h2>
			<p>First, update the include directives and the class declaration, as highlighted in the following code, to make the <strong class="source-inline">GameScreen</strong> class inherit from <strong class="source-inline">BulletSpawner</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Screen.h"</p>
			<p class="source-code">#include "GameInputHandler.h"</p>
			<p class="source-code">#include "GameOverInputHandler.h"</p>
			<p class="source-code"><strong class="bold">#include "BulletSpawner.h"</strong></p>
			<p class="source-code">class GameScreen : public Screen<strong class="bold">, public BulletSpawner</strong></p>
			<p class="source-code">{</p>
			<p class="source-code">   …</p>
			<p class="source-code">   …</p>
			<p>Next, add some extra functions and variable declarations, as highlighted in the following code, to <strong class="source-inline">GameScreen.h</strong>:</p>
			<p class="source-code">private:</p>
			<p class="source-code">    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;</p>
			<p class="source-code">    shared_ptr&lt;GameInputHandler&gt; m_GIH;</p>
			<p class="source-code"><strong class="bold">    int m_NumberInvadersInWorldFile = 0;</strong></p>
			<p class="source-code"><strong class="bold">    vector&lt;int&gt; m_BulletObjectLocations;</strong></p>
			<p class="source-code"><strong class="bold">    int m_NextBullet = 0;</strong></p>
			<p class="source-code"><strong class="bold">    bool m_WaitingToSpawnBulletForPlayer = false;</strong></p>
			<p class="source-code"><strong class="bold">    bool m_WaitingToSpawnBulletForInvader = false;</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f m_PlayerBulletSpawnLocation;</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f m_InvaderBulletSpawnLocation;</strong></p>
			<p class="source-code"><strong class="bold">    Clock m_BulletClock;</strong></p>
			<p class="source-code">    Texture m_BackgroundTexture;</p>
			<p class="source-code">    Sprite m_BackgroundSprite;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    static bool m_GameOver;</p>
			<p class="source-code">    GameScreen(ScreenManagerRemoteControl* smrc, Vector2i res);</p>
			<p class="source-code">    void initialise() override;</p>
			<p class="source-code">    void virtual update(float fps);</p>
			<p class="source-code">    void virtual draw(RenderWindow&amp; window);</p>
			<p class="source-code"><strong class="bold">    BulletSpawner* getBulletSpawner();</strong></p>
			<p>The new variables include a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong> values that will hold the locations of all the bullets in the <strong class="source-inline">vector</strong>, which holds all the game objects. It also has a few control variables so that we can keep track of the next bullet to use, whether the bullet is for the player or an invader, and the position to spawn the bullet in. We have also declared a new <strong class="source-inline">sf::Clock</strong> instance because we want to limit the fire rate of the player. Finally, we have the <strong class="source-inline">getBulletSpawner</strong> function, which will return a pointer to this class in the form of a <strong class="source-inline">BulletSpawner</strong>. This will give the recipient access to the <strong class="source-inline">spawnBullet</strong> function, but nothing else.</p>
			<p>Now, we can add the implementation of the <strong class="source-inline">spawnBullet</strong> function. Add the following code to <strong class="source-inline">GameScreen.h</strong> at the end of all the other code, but inside the closing curly brace of the <strong class="source-inline">GameScreen</strong> class:</p>
			<p class="source-code">/****************************************************</p>
			<p class="source-code">*****************************************************</p>
			<p class="source-code">From BulletSpawner interface</p>
			<p class="source-code">*****************************************************</p>
			<p class="source-code">*****************************************************/</p>
			<p class="source-code">void BulletSpawner::spawnBullet(Vector2f spawnLocation, </p>
			<p class="source-code">    bool forPlayer)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (forPlayer)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Time elapsedTime = m_BulletClock.getElapsedTime();</p>
			<p class="source-code">        if (elapsedTime.asMilliseconds() &gt; 500) {</p>
			<p class="source-code">            m_PlayerBulletSpawnLocation.x = spawnLocation.x;</p>
			<p class="source-code">            m_PlayerBulletSpawnLocation.y = spawnLocation.y;</p>
			<p class="source-code">            m_WaitingToSpawnBulletForPlayer = true;</p>
			<p class="source-code">            m_BulletClock.restart();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_InvaderBulletSpawnLocation.x = spawnLocation.x;</p>
			<p class="source-code">        m_InvaderBulletSpawnLocation.y = spawnLocation.y;</p>
			<p class="source-code">        m_WaitingToSpawnBulletForInvader = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The implementation of the <strong class="source-inline">spawnBullet</strong> function is a simple <strong class="source-inline">if</strong> – <strong class="source-inline">else</strong> structure. The <strong class="source-inline">if</strong> block executes if a bullet is requested for the player and the <strong class="source-inline">else</strong> block executes if a bullet is requested for an invader.</p>
			<p>The <strong class="source-inline">if</strong> block checks that at least half a second has passed since the last bullet was requested and, if it has, the <strong class="source-inline">m_WaitingToSpawnBulletForPlayer</strong> variable is set to true, the location to spawn the bullet at is copied, and the clock is restarted, ready to test the player's next request.</p>
			<p>The <strong class="source-inline">else</strong> block records the spawn location for an invader's bullet and sets <strong class="source-inline">m_WaitingToSpawnBulletForInvader</strong> to <strong class="source-inline">true</strong>. No interaction with the <strong class="source-inline">Clock</strong> instance is necessary as the rate of fire for the invaders is controlled in the <strong class="source-inline">InvaderUpdateComponent</strong> class.</p>
			<p>The last part of the <strong class="source-inline">BulletSpawner</strong> puzzle, before we get to actually spawning the bullets, is to add the definition of <strong class="source-inline">getBulletSpawner</strong> to the end of <strong class="source-inline">GameScreen.cpp</strong>. Here is the code to add:</p>
			<p class="source-code">BulletSpawner* GameScreen::getBulletSpawner()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return this;</p>
			<p class="source-code">}</p>
			<p>This returns a pointer to <strong class="source-inline">GameScreen</strong>, which gives us access to the <strong class="source-inline">spawnBullet</strong> function.</p>
			<h1 id="_idParaDest-435"><a id="_idTextAnchor449"/>Handling the player's input</h1>
			<p>Add some more declarations to the <strong class="source-inline">GameInputHandler.h</strong> file so that your code matches what follows. I have highlighted the new code to add:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "InputHandler.h"</p>
			<p class="source-code"><strong class="bold">#include "PlayerUpdateComponent.h"</strong></p>
			<p class="source-code"><strong class="bold">#include "TransformComponent.h"</strong></p>
			<p class="source-code">class GameScreen;</p>
			<p class="source-code">class GameInputHandler : public InputHandler</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">private:</strong></p>
			<p class="source-code"><strong class="bold">    shared_ptr&lt;PlayerUpdateComponent&gt; m_PUC;</strong></p>
			<p class="source-code"><strong class="bold">    shared_ptr&lt;TransformComponent&gt; m_PTC;</strong></p>
			<p class="source-code"><strong class="bold">    bool mBButtonPressed = false;</strong></p>
			<p class="source-code">public:</p>
			<p class="source-code">    void initialize();</p>
			<p class="source-code">    void handleGamepad() override;</p>
			<p class="source-code">    void handleKeyPressed(Event&amp; event, </p>
			<p class="source-code">        RenderWindow&amp; window) override;</p>
			<p class="source-code">    void handleKeyReleased(Event&amp; event, </p>
			<p class="source-code">        RenderWindow&amp; window) override;    </p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">GameInputHandler</strong> class now has access to the player's update component and the player's transform component. This is very useful because it means we can tell the <strong class="source-inline">PlayerUpdateComponent</strong> instance and the player's <strong class="source-inline">TransformComponent</strong> instance what keyboard keys and gamepad controls the player is manipulating. What we haven't seen yet is how exactly these two shared pointers will be initialized – after all, aren't the <strong class="source-inline">GameObject</strong> instances and all their components packed away in a <strong class="source-inline">vector</strong>? You can probably guess the solution has something to do with <strong class="source-inline">GameObjectSharer</strong>. Let's keep coding to find out more.</p>
			<p>In the <strong class="source-inline">GameInputHanldler.cpp</strong> file, add a forward declaration of the <strong class="source-inline">BulletSpawner</strong> class after the include directives but before the initialize function, as highlighted in the following code:</p>
			<p class="source-code">#include "GameInputHandler.h"</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">#include "GameScreen.h"</p>
			<p class="source-code"><strong class="bold">class BulletSpawner;</strong></p>
			<p class="source-code">void GameInputHandler::initialize() {</p>
			<p class="source-code">…</p>
			<p>In the <strong class="source-inline">GameInputHandler.cpp</strong> file, add the following highlighted code to the <strong class="source-inline">handleKeyPressed</strong> function:</p>
			<p class="source-code">void GameInputHandler::handleKeyPressed(</p>
			<p class="source-code">    Event&amp; event, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Handle key presses</p>
			<p class="source-code">    if (event.key.code == Keyboard::Escape)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl()-&gt;</p>
			<p class="source-code">            SwitchScreens("Select");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code"><strong class="bold">if (event.key.code == Keyboard::Left)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;moveLeft();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    if (event.key.code == Keyboard::Right)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;moveRight();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    if (event.key.code == Keyboard::Up)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;moveUp();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    if (event.key.code == Keyboard::Down)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;moveDown();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>Notice that we are responding to keyboard presses just like we have been doing throughout this book. Here, however, we are calling the functions from the <strong class="source-inline">PlayerUpdateComponent</strong> class that we coded in <a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, in order to take the required actions.</p>
			<p>In the <strong class="source-inline">GameInputHandler.cpp</strong> file, add the following highlighted code to the <strong class="source-inline">handleKeyReleased</strong> function:</p>
			<p class="source-code">void GameInputHandler::handleKeyReleased(</p>
			<p class="source-code">    Event&amp; event, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    if (event.key.code == Keyboard::Left)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;stopLeft();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else if (event.key.code == Keyboard::Right)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;stopRight();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else if (event.key.code == Keyboard::Up)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;stopUp();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else if (event.key.code == Keyboard::Down)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PUC-&gt;stopDown();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else if (event.key.code == Keyboard::Space)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Shoot a bullet</strong></p>
			<p class="source-code"><strong class="bold">        SoundEngine::playShoot();</strong></p>
			<p class="source-code"><strong class="bold">        Vector2f spawnLocation;</strong></p>
			<p class="source-code"><strong class="bold">        spawnLocation.x = m_PTC-&gt;getLocation().x + </strong></p>
			<p class="source-code"><strong class="bold">            m_PTC-&gt;getSize().x / 2;</strong></p>
			<p class="source-code"><strong class="bold">        spawnLocation.y = m_PTC-&gt;getLocation().y;</strong></p>
			<p class="source-code"><strong class="bold">        static_cast&lt;GameScreen*&gt;(getmParentScreen())-&gt;</strong></p>
			<p class="source-code"><strong class="bold">            spawnBullet(spawnLocation, true);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>The preceding code also relies on calling functions from the <strong class="source-inline">PlayerUpdateComponent</strong> class to handle what happens when the player releases a keyboard key. The <strong class="source-inline">PlayerUpdateComponent</strong> class can then stop movement in the appropriate direction, depending on which keyboard key has just been released. When the <em class="italic">space</em> key is released, the <strong class="source-inline">getParentScreen</strong> function is chained with the <strong class="source-inline">spawnBullet</strong> function to trigger a bullet being spawned. Notice that the spawn coordinates (<strong class="source-inline">spawnLocation</strong>) are calculated using the shared pointer to the <strong class="source-inline">PlayerTransformComponent</strong> instance.</p>
			<p>Let's learn about how SFML helps us interact with a gamepad and then we can return to the <strong class="source-inline">PlayerInputHandler</strong> class to add some more functionality.</p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor450"/>Using a gamepad</h2>
			<p>Handling gamepad input is made exceptionally easy by SFML. Gamepad (or joystick) input is handled by the <strong class="source-inline">sf::Joystick</strong> class. SFML can handle input from up to eight gamepads, but this tutorial will stick to just one.</p>
			<p>You can think of the position of a thumbstick/joystick as a 2D graph that starts at -100, -100 at the top left corner and goes to 100, 100 at the bottom right corner. The position of the thumbstick can, therefore, be represented by a 2D coordinate. The following diagram illustrates this with a few example coordinates:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B14278_22_01.jpg" alt=""/>
				</div>
			</div>
			<p>All we need to do is grab the value and report it to the <strong class="source-inline">PlayerUpdateComponent</strong> class for each frame of the game loop. Capturing the position is as simple as the following two lines of code:</p>
			<p class="source-code">float x  = Joystick::getAxisPosition(0, sf::Joystick::X);</p>
			<p class="source-code">float y = Joystick::getAxisPosition(0, sf::Joystick::Y);</p>
			<p>The zero parameter requests data from the primary gamepad. You can use values  0 through 7 to get input from eight gamepads.</p>
			<p>There is something else we need to consider as well. Most gamepads, especially thumbsticks, are mechanically imperfect and will register small values even when they are not being touched. If we send these values to the <strong class="source-inline">PlayerUpdateComponent</strong> class, then the ship will aimlessly drift around the screen. For this reason, we will create a <strong class="bold">dead zone</strong>. This is a range of movement where we will ignore any values. 10 percent of the range of movement works quite well. Therefore, if the values that are retrieved from the <strong class="source-inline">getAxisPosition</strong> function are between -10 and 10 on either axis, we will ignore them. </p>
			<p>To get input from the B button of the gamepad, we use the following line of code:</p>
			<p>// Has the player pressed the B button?</p>
			<p class="source-code">if (Joystick::isButtonPressed(0, 1))</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Take action here</p>
			<p class="source-code">}</p>
			<p>The preceding code detects when the B button on an Xbox One gamepad is pressed. Other controllers will vary. The 0, 1 parameters refer to the primary gamepad and button number 1. To detect when a button is released, we will need to code a bit of our own logic. As we want to shoot a bullet on release and not when it is pressed, we will use a simple Boolean to track this. Let's code the rest of the <strong class="source-inline">GameInputHandler</strong> class and see how we can put what we have just learned into action.</p>
			<p>In the <strong class="source-inline">GameInputHandler.cpp</strong> file, add the following highlighted code to the <strong class="source-inline">handleGamepad</strong> function:</p>
			<p class="source-code">void GameInputHandler::handleGamepad()</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    float deadZone = 10.0f;</strong></p>
			<p class="source-code"><strong class="bold">    float x  = Joystick::getAxisPosition(0, sf::Joystick::X);</strong></p>
			<p class="source-code"><strong class="bold">    float y = Joystick::getAxisPosition(0, sf::Joystick::Y);    </strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">    if (x &lt; deadZone &amp;&amp; x &gt; -deadZone)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        x = 0;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    if (y &lt; deadZone &amp;&amp; y &gt; -deadZone)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        y = 0;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    m_PUC-&gt;updateShipTravelWithController(x, y);    </strong></p>
			<p class="source-code"><strong class="bold">    // Has the player pressed the B button?</strong></p>
			<p class="source-code"><strong class="bold">    if (Joystick::isButtonPressed(0, 1))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        mBButtonPressed = true;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    // Has player just released the B button?</strong></p>
			<p class="source-code"><strong class="bold">    if (!Joystick::isButtonPressed(0, 1) &amp;&amp; mBButtonPressed)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        mBButtonPressed = false;</strong></p>
			<p class="source-code"><strong class="bold">        // Shoot a bullet</strong></p>
			<p class="source-code"><strong class="bold">        SoundEngine::playShoot();</strong></p>
			<p class="source-code"><strong class="bold">        Vector2f spawnLocation;</strong></p>
			<p class="source-code"><strong class="bold">        spawnLocation.x = m_PTC-&gt;getLocation().x + </strong></p>
			<p class="source-code"><strong class="bold">            m_PTC-&gt;getSize().x / 2;</strong></p>
			<p class="source-code"><strong class="bold">        spawnLocation.y = m_PTC-&gt;getLocation().y;</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        static_cast&lt;GameScreen*&gt;(getmParentScreen())-&gt;</strong></p>
			<p class="source-code"><strong class="bold">            getBulletSpawner()-&gt;spawnBullet(</strong></p>
			<p class="source-code"><strong class="bold">               spawnLocation, true);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>We begin by defining a dead zone of 10 and then proceed to capture the position of the thumbstick. The next two <strong class="source-inline">if</strong> blocks test whether the thumbstick position is within the dead zone. If it is, then the appropriate value is set to zero to avoid the ship drifting. Then, we can call the <strong class="source-inline">updateShipTravelWithController</strong> function on the <strong class="source-inline">PlayerUpdateComponent</strong> instance. That is the thumbstick dealt with.</p>
			<p>The next <strong class="source-inline">if</strong> statement sets a Boolean to <strong class="source-inline">true</strong> if the B button on the gamepad is pressed. The next <strong class="source-inline">if</strong> statement detects when the B button is not pressed, and the Boolean is set to <strong class="source-inline">true</strong>. This indicates that the B button has just been released.</p>
			<p>Inside the <strong class="source-inline">if</strong> block, we set the Boolean to <strong class="source-inline">false</strong>, ready to handle the next button release, play a shooting sound, get the location to spawn the bullet, and call the <strong class="source-inline">spawnBullet</strong> function by chaining the <strong class="source-inline">getmParentScreen</strong> and <strong class="source-inline">getBulletSpawner</strong> functions.</p>
			<h1 id="_idParaDest-437"><a id="_idTextAnchor451"/>Coding the PhysicsEnginePlayMode class</h1>
			<p>This is the class that will do all the collision detection. In this game, there are several collision events we want to watch out for: </p>
			<ul>
				<li>Has an invader reached the left- or right-hand side of the screen? If so, all the invaders need to drop down one row and head back in the other direction.</li>
				<li>Has an invader collided with the player? As the invaders get lower, we want them to be able to bump into the player and cause a life to be lost.</li>
				<li>Has an invader bullet hit the player? Each time an invader bullet hits the player, we need to hide the bullet, ready for reuse, and deduct a life from the player.</li>
				<li>Has a player bullet hit an invader? Each time the player hits an invader, the invader should be destroyed, the bullet hidden (ready for reuse), and the player's score increased.</li>
			</ul>
			<p>This class will have an <strong class="source-inline">initialize</strong> function that the <strong class="source-inline">GameScreen</strong> class will call to prepare for detecting collisions, a <strong class="source-inline">detectCollisions</strong> function that the <strong class="source-inline">GameScreen</strong> class will call once for each frame after all the game objects have updated themselves, and three more functions which will be called from the <strong class="source-inline">detectCollisions</strong> function to separate out the work of detecting the different collisions I have just listed. </p>
			<p>Those three functions are <strong class="source-inline">detectInvaderCollisions</strong>, <strong class="source-inline">detectPlayerCollisionsAndInvaderDirection</strong>, and <strong class="source-inline">handleInvaderDirection</strong>. Hopefully, the names of these functions make it clear what will happen in each function.</p>
			<p>Create a new source file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">PhysicsEnginePlayMode.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include "PlayerUpdateComponent.h"</p>
			<p class="source-code">class PhysicsEnginePlayMode</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    shared_ptr&lt;PlayerUpdateComponent&gt; m_PUC;</p>
			<p class="source-code">    GameObject* m_Player;</p>
			<p class="source-code">    bool m_InvaderHitWallThisFrame = false;</p>
			<p class="source-code">    bool m_InvaderHitWallPreviousFrame = false;</p>
			<p class="source-code">    bool m_NeedToDropDownAndReverse = false;</p>
			<p class="source-code">    bool m_CompletedDropDownAndReverse = false;</p>
			<p class="source-code">    void detectInvaderCollisions(</p>
			<p class="source-code">        vector&lt;GameObject&gt;&amp; objects,</p>
			<p class="source-code">        const vector&lt;int&gt;&amp; bulletPositions);</p>
			<p class="source-code">    void detectPlayerCollisionsAndInvaderDirection(</p>
			<p class="source-code">        vector&lt;GameObject&gt;&amp; objects,</p>
			<p class="source-code">        const vector&lt;int&gt;&amp; bulletPositions);</p>
			<p class="source-code">    void handleInvaderDirection();</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void initilize(GameObjectSharer&amp; gos);</p>
			<p class="source-code">    void detectCollisions(</p>
			<p class="source-code">        vector&lt;GameObject&gt;&amp; objects,</p>
			<p class="source-code">        const vector&lt;int&gt;&amp; bulletPositions);</p>
			<p class="source-code">};</p>
			<p>Study the preceding code to make a note of the parameters that are passed to each of the functions. Also take note of the four member Boolean variables that will be used throughout the class. Furthermore, notice that there is a pointer to a <strong class="source-inline">GameObject</strong> type being declared which will be a permanent reference to the player ship, so we don't need to keep finding the <strong class="source-inline">GameObject</strong> that represents the player for each frame of the game loop.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Engine</strong> filter called <strong class="source-inline">PhysicsEnginePlayMode.cpp</strong> and add the following include directives and the <strong class="source-inline">detectInvaderCollisions</strong> function. Study the code and then we will discuss it:</p>
			<p class="source-code">#include "DevelopState.h"</p>
			<p class="source-code">#include "PhysicsEnginePlayMode.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">#include "InvaderUpdateComponent.h"</p>
			<p class="source-code">#include "BulletUpdateComponent.h"</p>
			<p class="source-code">void PhysicsEnginePlayMode::</p>
			<p class="source-code">detectInvaderCollisions(</p>
			<p class="source-code">    vector&lt;GameObject&gt;&amp; objects, </p>
			<p class="source-code">    const vector&lt;int&gt;&amp; bulletPositions)</p>
			<p class="source-code">{</p>
			<p class="source-code">Vector2f offScreen(-1, -1);</p>
			<p class="source-code">auto invaderIt = objects.begin();</p>
			<p class="source-code">auto invaderEnd = objects.end();</p>
			<p class="source-code">for (invaderIt;</p>
			<p class="source-code">    invaderIt != invaderEnd;</p>
			<p class="source-code">    ++invaderIt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if ((*invaderIt).isActive()</p>
			<p class="source-code">        &amp;&amp; (*invaderIt).getTag() == "invader")</p>
			<p class="source-code">    {</p>
			<p class="source-code">        auto bulletIt = objects.begin();</p>
			<p class="source-code">        // Jump to the first bullet</p>
			<p class="source-code">        advance(bulletIt, bulletPositions[0]);</p>
			<p class="source-code">        auto bulletEnd = objects.end();</p>
			<p class="source-code">        for (bulletIt;</p>
			<p class="source-code">            bulletIt != bulletEnd;</p>
			<p class="source-code">            ++bulletIt)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            if ((*invaderIt).getEncompassingRectCollider()</p>
			<p class="source-code">                .intersects((*bulletIt)</p>
			<p class="source-code">                    .getEncompassingRectCollider())</p>
			<p class="source-code">                &amp;&amp; (*bulletIt).getTag() == "bullet"</p>
			<p class="source-code">                &amp;&amp; static_pointer_cast&lt;</p>
			<p class="source-code">                      BulletUpdateComponent&gt;(</p>
			<p class="source-code">                (*bulletIt).getFirstUpdateComponent())</p>
			<p class="source-code">                -&gt;m_BelongsToPlayer)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                SoundEngine::playInvaderExplode();</p>
			<p class="source-code">                (*invaderIt).getTransformComponent()</p>
			<p class="source-code">                    -&gt;getLocation() = offScreen;</p>
			<p class="source-code">                (*bulletIt).getTransformComponent()</p>
			<p class="source-code">                    -&gt;getLocation() = offScreen;</p>
			<p class="source-code">                WorldState::SCORE++;</p>
			<p class="source-code">                WorldState::NUM_INVADERS--;</p>
			<p class="source-code">                (*invaderIt).setInactive();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p>The preceding code loops through all the game objects. The first <strong class="source-inline">if</strong> statement checks whether the current game object is both active and an invader:</p>
			<p class="source-code">if ((*invaderIt).isActive()</p>
			<p class="source-code">        &amp;&amp; (*invaderIt).getTag() == "invader")</p>
			<p>If it is an active invader, another loop is entered and each of the game objects that represents a bullet is looped through:</p>
			<p class="source-code">auto bulletIt = objects.begin();</p>
			<p class="source-code">// Jump to the first bullet</p>
			<p class="source-code">advance(bulletIt, bulletPositions[0]);</p>
			<p class="source-code">auto bulletEnd = objects.end();</p>
			<p class="source-code">for (bulletIt;</p>
			<p class="source-code">    bulletIt != bulletEnd;</p>
			<p class="source-code">    ++bulletIt)</p>
			<p>The next <strong class="source-inline">if </strong>statement checks whether the current invader has collided with the current bullet and whether that bullet was fired by the player (we don't want invaders shooting themselves):</p>
			<p class="source-code">if ((*invaderIt).getEncompassingRectCollider()</p>
			<p class="source-code">        .intersects((*bulletIt)</p>
			<p class="source-code">        .getEncompassingRectCollider())</p>
			<p class="source-code">        &amp;&amp; (*bulletIt).getTag() == "bullet"</p>
			<p class="source-code">        &amp;&amp; static_pointer_cast&lt;BulletUpdateComponent&gt;(</p>
			<p class="source-code">        (*bulletIt).getFirstUpdateComponent())</p>
			<p class="source-code">        -&gt;m_BelongsToPlayer)</p>
			<p>When this test is true, a sound is played, the bullet is moved off-screen, the number of invaders is decremented, the player's score is increased, and the invader is set to inactive.</p>
			<p>Now, we will detect player collisions and the invader's direction of travel.</p>
			<p>Add the <strong class="source-inline">detectPlayerCollisionsAndInvaderDirection</strong> function, as follows:</p>
			<p class="source-code">void PhysicsEnginePlayMode::</p>
			<p class="source-code">detectPlayerCollisionsAndInvaderDirection(</p>
			<p class="source-code">    vector&lt;GameObject&gt;&amp; objects, </p>
			<p class="source-code">    const vector&lt;int&gt;&amp; bulletPositions)</p>
			<p class="source-code">{</p>
			<p class="source-code">Vector2f offScreen(-1, -1);</p>
			<p class="source-code">FloatRect playerCollider = </p>
			<p class="source-code">    m_Player-&gt;getEncompassingRectCollider();</p>
			<p class="source-code">shared_ptr&lt;TransformComponent&gt; playerTransform = </p>
			<p class="source-code">    m_Player-&gt;getTransformComponent();</p>
			<p class="source-code">Vector2f playerLocation = </p>
			<p class="source-code">    playerTransform-&gt;getLocation();</p>
			<p class="source-code">auto it3 = objects.begin();</p>
			<p class="source-code">auto end3 = objects.end();</p>
			<p class="source-code">for (it3;</p>
			<p class="source-code">    it3 != end3;</p>
			<p class="source-code">    ++it3)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if ((*it3).isActive() &amp;&amp;</p>
			<p class="source-code">        (*it3).hasCollider() &amp;&amp;</p>
			<p class="source-code">        (*it3).getTag() != "Player")</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Get a reference to all the parts of </p>
			<p class="source-code">        // the current game object we might need</p>
			<p class="source-code">        FloatRect currentCollider = (*it3)</p>
			<p class="source-code">            .getEncompassingRectCollider();</p>
			<p class="source-code">        // Detect collisions between objects </p>
			<p class="source-code">        // with the player</p>
			<p class="source-code">        if (currentCollider.intersects(playerCollider))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            if ((*it3).getTag() == "bullet")</p>
			<p class="source-code">            {</p>
			<p class="source-code">                SoundEngine::playPlayerExplode();</p>
			<p class="source-code">                WorldState::LIVES--;</p>
			<p class="source-code">                (*it3).getTransformComponent()-&gt;</p>
			<p class="source-code">                    getLocation() = offScreen;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            if ((*it3).getTag() == "invader")</p>
			<p class="source-code">            {</p>
			<p class="source-code">                SoundEngine::playPlayerExplode();</p>
			<p class="source-code">                SoundEngine::playInvaderExplode();</p>
			<p class="source-code">                WorldState::LIVES--;</p>
			<p class="source-code">                (*it3).getTransformComponent()-&gt;</p>
			<p class="source-code">                    getLocation() = offScreen;</p>
			<p class="source-code">                WorldState::SCORE++;</p>
			<p class="source-code">                (*it3).setInactive();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        shared_ptr&lt;TransformComponent&gt; </p>
			<p class="source-code">            currentTransform =</p>
			<p class="source-code">            (*it3).getTransformComponent();</p>
			<p class="source-code">        Vector2f currentLocation = </p>
			<p class="source-code">            currentTransform-&gt;getLocation();</p>
			<p class="source-code">        string currentTag = (*it3).getTag();</p>
			<p class="source-code">        Vector2f currentSize = </p>
			<p class="source-code">            currentTransform-&gt;getSize();</p>
			<p class="source-code">        // Handle the direction and descent </p>
			<p class="source-code">        // of the invaders</p>
			<p class="source-code">        if (currentTag == "invader")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // This is an invader</p>
			<p class="source-code">            if (!m_NeedToDropDownAndReverse &amp;&amp; </p>
			<p class="source-code">                !m_InvaderHitWallThisFrame)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                // Currently no need to dropdown </p>
			<p class="source-code">                // and reverse from previous frame </p>
			<p class="source-code">                // or any hits this frame</p>
			<p class="source-code">                if (currentLocation.x &gt;= </p>
			<p class="source-code">                    WorldState::WORLD_WIDTH – </p>
			<p class="source-code">                            currentSize.x)</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    // The invader is passed its </p>
			<p class="source-code">                    // furthest right position</p>
			<p class="source-code">                    if (static_pointer_cast</p>
			<p class="source-code">                        &lt;InvaderUpdateComponent&gt;((*it3)</p>
			<p class="source-code">                        .getFirstUpdateComponent())-&gt;</p>
			<p class="source-code">                        isMovingRight())</p>
			<p class="source-code">                    {</p>
			<p class="source-code">                        // The invader is travelling </p>
			<p class="source-code">                        // right so set a flag that</p>
			<p class="source-code">                        // an invader has collided</p>
			<p class="source-code">                         </p>
			<p class="source-code">                        m_InvaderHitWallThisFrame </p>
			<p class="source-code">                                         = true;</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">                else if (currentLocation.x &lt; 0)</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    // The invader is past its furthest </p>
			<p class="source-code">                    // left position</p>
			<p class="source-code">                    if (!static_pointer_cast</p>
			<p class="source-code">                        &lt;InvaderUpdateComponent&gt;(        </p>
			<p class="source-code">                            (*it3).getFirstUpdateComponent())</p>
			<p class="source-code">                        -&gt;isMovingRight())</p>
			<p class="source-code">                    {</p>
			<p class="source-code">                        // The invader is travelling </p>
			<p class="source-code">                        // left so set a flag that an</p>
			<p class="source-code">                        // invader has collided </p>
			<p class="source-code">                        m_InvaderHitWallThisFrame </p>
			<p class="source-code">                                         = true;</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            else if (m_NeedToDropDownAndReverse </p>
			<p class="source-code">                &amp;&amp; !m_InvaderHitWallPreviousFrame)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                // Drop down and reverse has been set</p>
			<p class="source-code">                if ((*it3).hasUpdateComponent())</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    // Drop down and reverse</p>
			<p class="source-code">                    static_pointer_cast&lt;</p>
			<p class="source-code">                            InvaderUpdateComponent&gt;(            </p>
			<p class="source-code">                            (*it3).getFirstUpdateComponent())</p>
			<p class="source-code">                    -&gt;dropDownAndReverse();</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p>The preceding code is longer than the previous function because we are checking for more conditions. Before the code loops through all the game objects, it gets a reference to all the relevant player data. This is so we don't have to do this for every check:</p>
			<p class="source-code">FloatRect playerCollider = </p>
			<p class="source-code">    m_Player-&gt;getEncompassingRectCollider();</p>
			<p class="source-code">shared_ptr&lt;TransformComponent&gt; playerTransform = </p>
			<p class="source-code">    m_Player-&gt;getTransformComponent();</p>
			<p class="source-code">Vector2f playerLocation = </p>
			<p class="source-code">    playerTransform-&gt;getLocation();</p>
			<p>Next, the loop goes through every game object. The first <strong class="source-inline">if</strong> test checks whether the current object is active, has a collider, and is not the player. We don't want to test the player colliding with themselves:</p>
			<p class="source-code">if ((*it3).isActive() &amp;&amp;</p>
			<p class="source-code">    (*it3).hasCollider() &amp;&amp;</p>
			<p class="source-code">    (*it3).getTag() != "Player")</p>
			<p>The next <strong class="source-inline">if</strong> test does the actual collision detection to see if the current game object intersects with the player:</p>
			<p class="source-code">if (currentCollider.intersects(playerCollider))</p>
			<p>Next, there are two nested <strong class="source-inline">if</strong> statements: one that handles collisions with a bullet belonging to an invader and one that handles collisions with an invader.</p>
			<p>Next, the code checks each and every game object that is an invader to see whether it has hit the left- or right-hand side of the screen. Note that the <strong class="source-inline">m_NeedToDropDownAndReverse</strong> and <strong class="source-inline">m_InvaderHitWallLastFrame</strong> Boolean variables are used because it will not always be the first invader in the vector that hits the side of the screen. Therefore, detecting the collision and triggering dropdown and reversal are handled in consecutive frames to guarantee that all the invaders drop down and reverse, regardless of which one of them triggers it.</p>
			<p>Finally, when both conditions are <strong class="source-inline">true</strong>, <strong class="source-inline">handleInvaderDirection</strong> is called.</p>
			<p>Add the <strong class="source-inline">handleInvaderDirection</strong> function, as follows:</p>
			<p class="source-code">void PhysicsEnginePlayMode::handleInvaderDirection()</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_InvaderHitWallThisFrame) {</p>
			<p class="source-code">        m_NeedToDropDownAndReverse = true;</p>
			<p class="source-code">        m_InvaderHitWallThisFrame = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else {</p>
			<p class="source-code">        m_NeedToDropDownAndReverse = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This function just sets and unsets Booleans accordingly so that the next pass through the <strong class="source-inline">detectPlayerCollisionAndDirection</strong> function will actually drop-down the invaders and change their direction.</p>
			<p>Add the <strong class="source-inline">initialize</strong> function to prepare the class for action:</p>
			<p class="source-code">void PhysicsEnginePlayMode::initilize(GameObjectSharer&amp; gos) {</p>
			<p class="source-code">    m_PUC = static_pointer_cast&lt;PlayerUpdateComponent&gt;(</p>
			<p class="source-code">        gos.findFirstObjectWithTag("Player")</p>
			<p class="source-code">        .getComponentByTypeAndSpecificType("update", "player"));</p>
			<p class="source-code">    m_Player = &amp;gos.findFirstObjectWithTag("Player");</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the pointer to <strong class="source-inline">PlayerUpdateComponent</strong> is initialized, as well as the pointer to the player <strong class="source-inline">GameObject</strong>. This will avoid calling these relatively slow functions during the game loop.</p>
			<p>Add the <strong class="source-inline">detectCollisions</strong> function, which will be called from the <strong class="source-inline">GameScreen</strong> class once each frame:</p>
			<p class="source-code">void PhysicsEnginePlayMode::detectCollisions(</p>
			<p class="source-code">    vector&lt;GameObject&gt;&amp; objects,</p>
			<p class="source-code">    const vector&lt;int&gt;&amp; bulletPositions)</p>
			<p class="source-code">{</p>
			<p class="source-code">    detectInvaderCollisions(objects, bulletPositions);</p>
			<p class="source-code">    detectPlayerCollisionsAndInvaderDirection(</p>
			<p class="source-code">        objects, bulletPositions);</p>
			<p class="source-code">    handleInvaderDirection();    </p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">detectCollisions</strong> function calls the three functions that handle the different phases of collision detection. You could have lumped all the code into this single function, but then it would be quite unwieldy. Alternatively, you could separate the three big functions into their own <strong class="source-inline">.cpp</strong> files, just like we did with the <strong class="source-inline">update</strong> and <strong class="source-inline">draw</strong> functions in the Thomas Was Late game.</p>
			<p>In the next section, we will create an instance of the <strong class="source-inline">PhysicsEngineGameMode</strong> class and use it in the <strong class="source-inline">GameScreen</strong> class as we bring the game to life.</p>
			<h1 id="_idParaDest-438"><a id="_idTextAnchor452"/>Making the game</h1>
			<p>By the end of this section, we will have a playable game. In this section, we will add code to the <strong class="source-inline">GameScreen</strong> class to bring together everything we have been coding over the last three chapters. To get started, add an instance of <strong class="source-inline">PhysicsEngineGameMode</strong> to <strong class="source-inline">GameScreen.h</strong> by adding an extra include directive, as follows:</p>
			<p class="source-code">#include "PhysicsEnginePlayMode.h"</p>
			<p>Then, declare an instance, as highlighted in the following code:</p>
			<p class="source-code">private:</p>
			<p class="source-code">    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;</p>
			<p class="source-code">    shared_ptr&lt;GameInputHandler&gt; m_GIH;</p>
			<p class="source-code"><strong class="bold">    PhysicsEnginePlayMode m_PhysicsEnginePlayMode;</strong></p>
			<p class="source-code">…</p>
			<p class="source-code">…</p>
			<p>Now, open the <strong class="source-inline">GameScreen.cpp</strong> file, add some extra include directives, and forward-declare the <strong class="source-inline">BulletSpawner</strong> class, as highlighted in the following code:</p>
			<p class="source-code">#include "GameScreen.h"</p>
			<p class="source-code">#include "GameUIPanel.h"</p>
			<p class="source-code">#include "GameInputHandler.h"</p>
			<p class="source-code">#include "GameOverUIPanel.h"</p>
			<p class="source-code"><strong class="bold">#include "GameObject.h"</strong></p>
			<p class="source-code"><strong class="bold">#include "WorldState.h"</strong></p>
			<p class="source-code"><strong class="bold">#include "BulletUpdateComponent.h"</strong></p>
			<p class="source-code"><strong class="bold">#include "InvaderUpdateComponent.h"</strong></p>
			<p class="source-code"><strong class="bold">class BulletSpawner;</strong></p>
			<p class="source-code">int WorldState::WORLD_HEIGHT;</p>
			<p class="source-code">int WorldState::NUM_INVADERS;</p>
			<p class="source-code">int WorldState::NUM_INVADERS_AT_START;</p>
			<p>Next, in the <strong class="source-inline">GameScreen.cpp</strong> file, update the <strong class="source-inline">initialize</strong> function by adding the following highlighted code inside the existing code:</p>
			<p class="source-code">void GameScreen::initialise()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_GIH-&gt;initialize();</p>
			<p class="source-code"><strong class="bold">    m_PhysicsEnginePlayMode.initilize(</strong></p>
			<p class="source-code"><strong class="bold">        m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">        shareGameObjectSharer());</strong></p>
			<p class="source-code">    WorldState::NUM_INVADERS = 0;</p>
			<p class="source-code"><strong class="bold">    // Store all the bullet locations and</strong></p>
			<p class="source-code"><strong class="bold">    // Initialize all the BulletSpawners in the invaders</strong></p>
			<p class="source-code"><strong class="bold">    // Count the number of invaders</strong></p>
			<p class="source-code"><strong class="bold">    int i = 0;</strong></p>
			<p class="source-code"><strong class="bold">    auto it = m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">        getGameObjects().begin();</strong></p>
			<p class="source-code"><strong class="bold">    auto end = m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">        getGameObjects().end();</strong></p>
			<p class="source-code"><strong class="bold">    for (it;</strong></p>
			<p class="source-code"><strong class="bold">        it != end;</strong></p>
			<p class="source-code"><strong class="bold">        ++it)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if ((*it).getTag() == "bullet")</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            m_BulletObjectLocations.push_back(i);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if ((*it).getTag() == "invader")</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            static_pointer_cast&lt;InvaderUpdateComponent&gt;(</strong></p>
			<p class="source-code"><strong class="bold">                (*it).getFirstUpdateComponent())-&gt;</strong></p>
			<p class="source-code"><strong class="bold">                initializeBulletSpawner(</strong></p>
			<p class="source-code"><strong class="bold">                    getBulletSpawner(), i);</strong></p>
			<p class="source-code"><strong class="bold">            WorldState::NUM_INVADERS++;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        ++i;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    m_GameOver = false;</p>
			<p class="source-code">    if (WorldState::WAVE_NUMBER == 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        WorldState::NUM_INVADERS_AT_START = </p>
			<p class="source-code">            WorldState::NUM_INVADERS;</p>
			<p class="source-code">            </p>
			<p class="source-code">        WorldState::WAVE_NUMBER = 1;</p>
			<p class="source-code">        WorldState::LIVES = 3;</p>
			<p class="source-code">        WorldState::SCORE = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code in the <strong class="source-inline">initialize</strong> function initializes the physics engine that will handle all the collision detection. Next, it loops through all the game objects and performs two tasks: one task in each of the <strong class="source-inline">if</strong> blocks.</p>
			<p>The first <strong class="source-inline">if</strong> block tests whether the current game object is a bullet. If it is, then its integer location in the vector of game objects is stored in the <strong class="source-inline">m_BulletObjectLocations vector</strong>. Remember from when we coded the physics engine that this <strong class="source-inline">vector</strong> is useful when doing collision detection. The vector will also be used in this class to keep track of the next bullet to use when the player or an invader wants to take a shot.</p>
			<p>The second <strong class="source-inline">if</strong> block detects whether the current game object is an invader and, if it is, calls the <strong class="source-inline">initializeBulletSpawner</strong> function on its update component and passes in a pointer to a <strong class="source-inline">BulletSpawner</strong> by calling the <strong class="source-inline">getBulletSpawner</strong> function. The invaders are now capable of spawning bullets. </p>
			<p>Now, we need to add some code to the <strong class="source-inline">update</strong> function to handle what happens in each frame of the game during the updating phase. This is highlighted in the following code. All the new code goes inside the already existing <strong class="source-inline">if(!m_GameOver)</strong> block:</p>
			<p class="source-code">void GameScreen::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    Screen::update(fps);</p>
			<p class="source-code">    if (!m_GameOver)</p>
			<p class="source-code">    {</p>
			<p class="source-code"><strong class="bold">        if (m_WaitingToSpawnBulletForPlayer)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            static_pointer_cast&lt;BulletUpdateComponent&gt;(</strong></p>
			<p class="source-code"><strong class="bold">                m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">                getGameObjects()</strong></p>
			<p class="source-code"><strong class="bold">                [m_BulletObjectLocations[m_NextBullet]].</strong></p>
			<p class="source-code"><strong class="bold">                getFirstUpdateComponent())-&gt;</strong></p>
			<p class="source-code"><strong class="bold">                spawnForPlayer(</strong></p>
			<p class="source-code"><strong class="bold">                      m_PlayerBulletSpawnLocation);</strong></p>
			<p class="source-code"><strong class="bold">            </strong></p>
			<p class="source-code"><strong class="bold">            m_WaitingToSpawnBulletForPlayer = false;</strong></p>
			<p class="source-code"><strong class="bold">            m_NextBullet++;</strong></p>
			<p class="source-code"><strong class="bold">            if (m_NextBullet == m_BulletObjectLocations</strong></p>
			<p class="source-code"><strong class="bold">                      .size())</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                m_NextBullet = 0;</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (m_WaitingToSpawnBulletForInvader)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            static_pointer_cast&lt;BulletUpdateComponent&gt;(</strong></p>
			<p class="source-code"><strong class="bold">                m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">                getGameObjects()</strong></p>
			<p class="source-code"><strong class="bold">                [m_BulletObjectLocations[m_NextBullet]].</strong></p>
			<p class="source-code"><strong class="bold">                getFirstUpdateComponent())-&gt;</strong></p>
			<p class="source-code"><strong class="bold">                spawnForInvader(</strong></p>
			<p class="source-code"><strong class="bold">                      m_InvaderBulletSpawnLocation);</strong></p>
			<p class="source-code"><strong class="bold">            </strong></p>
			<p class="source-code"><strong class="bold">            m_WaitingToSpawnBulletForInvader = false;</strong></p>
			<p class="source-code"><strong class="bold">            m_NextBullet++;</strong></p>
			<p class="source-code"><strong class="bold">            if (m_NextBullet == </strong></p>
			<p class="source-code"><strong class="bold">                      m_BulletObjectLocations.size())</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                m_NextBullet = 0;</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        auto it = m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">            getGameObjects().begin();</strong></p>
			<p class="source-code"><strong class="bold">        auto end = m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">            getGameObjects().end();</strong></p>
			<p class="source-code"><strong class="bold">        for (it;</strong></p>
			<p class="source-code"><strong class="bold">            it != end;</strong></p>
			<p class="source-code"><strong class="bold">            ++it)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            (*it).update(fps);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        m_PhysicsEnginePlayMode.detectCollisions(</strong></p>
			<p class="source-code"><strong class="bold">            m_ScreenManagerRemoteControl-&gt;getGameObjects(), </strong></p>
			<p class="source-code"><strong class="bold">            m_BulletObjectLocations);</strong></p>
			<p class="source-code">        if (WorldState::NUM_INVADERS &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            WorldState::WAVE_NUMBER++;</p>
			<p class="source-code">            m_ScreenManagerRemoteControl-&gt;</p>
			<p class="source-code">                loadLevelInPlayMode("level1");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        </p>
			<p class="source-code">        if (WorldState::LIVES &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_GameOver = true;            </p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding new code, the first <strong class="source-inline">if</strong> block checks whether a new bullet is required for the player. If it is the next available bullet, the <strong class="source-inline">GameObject</strong> instance, has its <strong class="source-inline">BulletUpdateComponent</strong> instance's <strong class="source-inline">spawnForPlayer</strong> function called. The specific <strong class="source-inline">GameObject</strong> instance to use is identified using the <strong class="source-inline">m_NextBulletObject</strong> variable with the <strong class="source-inline">m_BulletObjectLocations</strong> vector. The remaining code in the first <strong class="source-inline">if</strong> block prepares for the next bullet to be fired.</p>
			<p>The second <strong class="source-inline">if</strong> block executes if an invader is waiting for a bullet to be fired. Exactly the same technique is used to activate a bullet, except the <strong class="source-inline">spawnForInvader</strong> function is used, which sets it moving downward.</p>
			<p>Next, there is a loop which loops through every game object. This is key to everything because, inside the loop, the <strong class="source-inline">update</strong> function is called on every <strong class="source-inline">GameObject</strong> instance.</p>
			<p>The final line of code in the preceding new code calls the <strong class="source-inline">detectCollisions</strong> function to see if any of the <strong class="source-inline">GameObject</strong> instances (in their just-updated positions) have collided.</p>
			<p>Finally, we will add some code to the <strong class="source-inline">draw</strong> function in <strong class="source-inline">GameScreen.cpp</strong>. The new code is highlighted inside the existing code in the following listing:</p>
			<p class="source-code">void GameScreen::draw(RenderWindow &amp; window)</p>
			<p class="source-code">{    </p>
			<p class="source-code">    // Change to this screen's view to draw</p>
			<p class="source-code">    window.setView(m_View);</p>
			<p class="source-code">    window.draw(m_BackgroundSprite);</p>
			<p class="source-code"><strong class="bold">    // Draw the GameObject instances</strong></p>
			<p class="source-code"><strong class="bold">    auto it = m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">        getGameObjects().begin();</strong></p>
			<p class="source-code"><strong class="bold">    auto end = m_ScreenManagerRemoteControl-&gt;</strong></p>
			<p class="source-code"><strong class="bold">        getGameObjects().end();</strong></p>
			<p class="source-code"><strong class="bold">    for (it;</strong></p>
			<p class="source-code"><strong class="bold">        it != end;</strong></p>
			<p class="source-code"><strong class="bold">        ++it)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        (*it).draw(window);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    // Draw the UIPanel view(s)</p>
			<p class="source-code">    Screen::draw(window);</p>
			<p class="source-code">}</p>
			<p>The preceding code simply calls the <strong class="source-inline">draw</strong> function on each of the <strong class="source-inline">GameObject</strong> instances in turn. Now, you have completed the Space Invaders ++ project and can run the game. Congratulations!</p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor453"/>Understanding the flow of execution and debugging</h1>
			<p>Much of the last four chapters has been about the code structure. It is very possible that you still have doubts and uncertainties about which class instantiates which instance or in what order the various functions are called. Wouldn't it be useful if there was a way to execute the project and follow the path of execution from <strong class="source-inline">int main()</strong> right through to <strong class="source-inline">return 0;</strong> in the <strong class="source-inline">Space Invaders ++.cpp</strong> file? It turns out we can, and the following is how to do it.</p>
			<p>We will now explore the debugging facilities in Visual Studio while simultaneously trying to understand the structure of the project.</p>
			<p>Open the <strong class="source-inline">Space Invaders ++.cpp</strong> file and find the first line of code, as follows:</p>
			<p class="source-code">GameEngine m_GameEngine;</p>
			<p>The preceding code is the first line of code that gets executed. It declares an instance of the <strong class="source-inline">GameEngine</strong> class and sets all our hard work in motion.</p>
			<p>Right-click the preceding line of code and select <strong class="bold">Breakpoint</strong> | <strong class="bold">Insert Breakpoint</strong>. The following is what the screen should look like:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B14278_22_02.jpg" alt=""/>
				</div>
			</div>
			<p>Notice that there is a red circle next to the line of code. This is a breakpoint. When you run the code, execution will pause at this point and we will have some interesting options available to us.</p>
			<p>Run the game in the usual way. When execution pauses, an arrow indicates the current line of execution, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B14278_22_03.jpg" alt=""/>
				</div>
			</div>
			<p>If you hover the mouse over the <strong class="source-inline">m_GameEngine</strong> text and then click the arrow (the top-left corner in the following screenshot), you will get a preview of all the member variables and their values in the <strong class="source-inline">m_GameEngine</strong> instance:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B14278_22_04.jpg" alt=""/>
				</div>
			</div>
			<p>Let's progress through the code. In the main menu, look for the following set of icons:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B14278_22_05.jpg" alt=""/>
				</div>
			</div>
			<p>If you click the arrow icon highlighted in the previous screenshot, it will move to the next line of code. This arrow icon is the <strong class="bold">Step into</strong> button. The next line of code will be the top of the <strong class="source-inline">GameEngine</strong> constructor function. You can keep clicking the <strong class="bold">Step into</strong> button and examine the value of any of the variables at any stage.</p>
			<p>If you click into the initialization of <strong class="source-inline">m_Resolution</strong>, then you will see the code jumps into the <strong class="source-inline">Vector2i</strong> class provided by SFML. Keep clicking to see the code flow progress through all the steps that make up our game. </p>
			<p>If you want to skip to the next function, you can click the <strong class="bold">Step out</strong> button, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B14278_22_06.jpg" alt=""/>
				</div>
			</div>
			<p>Follow the flow of execution for as long as it interests you. When you are done, simply click the <strong class="bold">Stop</strong> button, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B14278_22_07.jpg" alt=""/>
				</div>
			</div>
			<p>Alternatively, if you want to run the game without stepping through the code, you can click the <strong class="bold">Continue</strong> button shown in the following screenshot. Note, however, that if the breakpoint is placed inside a loop, it will stop each time the flow of execution reaches the breakpoint:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B14278_22_08.jpg" alt=""/>
				</div>
			</div>
			<p>If you <a id="_idTextAnchor454"/>want to examine the flow of code from a different starting point and don't want to have to click through every line or function from the start, then all you need to do is set a different breakpoint. </p>
			<p>You can delete a breakpoint by stopping debugging (with the <strong class="bold">Stop</strong> button), right-clicking the red circle, and selecting <strong class="bold">Delete Breakpoint</strong>.</p>
			<p>You could then begin stepping through the game loop by setting a breakpoint at the first line of code in the <strong class="source-inline">update</strong> function of <strong class="source-inline">GameEngine.cpp</strong>. You can put a breakpoint anywhere, so feel free to explore the flow of execution in individual components or anywhere else. One of the key parts of the code that is worth examining is the flow of execution in the <em class="italic">update</em> function of the <strong class="source-inline">GameScreen</strong> class. Why not try it?</p>
			<p>While what we have just explored is useful and instructive, the real purpose of these facilities provided by Visual Studio is to debug our games. Whenever you get behavior that is not as you expect, just add a breakpoint to any likely lines that might be causing the problem, step through the execution, and observe the variable values.</p>
			<h1 id="_idParaDest-440"><a id="_idTextAnchor455"/>Reusing the code to make a different game and building a design mode</h1>
			<p>On a few occasions, we have already discussed  the possibility that this system we have coded can be reused to make a totally different game. I just thought it was worth giving this fact a full hearing.</p>
			<p>The way that you would make a different game is as follows. I have already mentioned that you could code the appearance of game objects into new components that derive from the <strong class="source-inline">GraphicsComponent</strong> class and that you could code new behaviors into classes that derive from the <strong class="source-inline">UpdateComponent</strong> class. </p>
			<p>Suppose you wanted a set of game objects that had overlapping behaviors; consider perhaps a 2D game where the enemy hunted the player and then shot at the player at a certain distance.</p>
			<p>Maybe you could have an enemy type that got close to the player and fired a pistol at the player and an enemy type that took long distance shots at the player, like a sniper might. </p>
			<p>You could code an <strong class="source-inline">EnemyShooterUpdateComponent</strong> class and an <strong class="source-inline">EnemySniperUpdateComponent</strong> class. You could get a shared pointer to the player transform component during the <strong class="source-inline">start</strong> function and code an abstract class (such as  <strong class="source-inline">BulletSpawner</strong>) to trigger spawning shots at the player, and you would be done. </p>
			<p>Consider, however, that both of these game objects would have code to take a shot and code to close in on the player. Then consider that, at some stage, you might want a "brawler" enemy who tries to punch the player. </p>
			<p>The current system can also have multiple update components. You could then have a <strong class="source-inline">ChasePlayerUpdateComponent</strong> class which closes in on the player and separate update components to punch, shoot, or snipe the player. The punching/shooting/sniping component would enforce some values on the chasing component regarding when to stop and start chasing, and then the more specific component (punch, shoot, or snipe) would attack the player when prompted that the time was right. </p>
			<p>As we've already mentioned, the ability to call the <strong class="source-inline">update</strong> function on multiple different update components is already built into the code, although it has never been tested. If you take a look at the <strong class="source-inline">update</strong> function in <strong class="source-inline">GameObject.cpp</strong>, you will see this code:</p>
			<p class="source-code">    for (int i = m_FirstUpdateComponentLocation; i &lt; </p>
			<p class="source-code">        m_FirstUpdateComponentLocation + </p>
			<p class="source-code">        m_NumberUpdateComponents; i++) </p>
			<p class="source-code">    {</p>
			<p class="source-code">   …</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">update</strong> function would be called on as many update components that are present. You just need to code them and add them to specific game objects in the <strong class="source-inline">level1.txt</strong> file. Using this system, a game object can have as many update components as it needs, allowing you to encapsulate very specific behaviors and share them as needed around the required game objects.</p>
			<p>When you want to create a pool of objects, like we did for the invaders and the bullets, you can be more efficient than we were in the Space Invaders ++ project. For the purposes of showing you how to position objects in the game world, we added all the invaders and bullets individually. In a real project, you would simply design a type that represents a pool of bullets, perhaps a magazine of bullets, like so:</p>
			<p class="source-code">[NAME]magazine of bullets[-NAME]</p>
			<p>You could do the same for a fleet of invaders:</p>
			<p class="source-code">[NAME]fleet of invaders[-NAME]</p>
			<p>Then, you would code the factory to handle a magazine or a fleet, probably with a <strong class="source-inline">for</strong> loop, and the slightly cumbersome text file would be improved upon. And, of course, there is no limit to the number of different levels you can design across multiple text files. More likely names for these text files are <strong class="source-inline">beach_level.txt</strong> or <strong class="source-inline">urban_level.txt</strong>.</p>
			<p>You might have wondered about the names of some of the classes, such as  <strong class="source-inline">PhysicsEnginePlayMode</strong> or <strong class="source-inline">GameObjectFactoryPlayMode</strong>. This implies that <strong class="source-inline">…PlayMode</strong> is just one option for these classes.</p>
			<p>The suggestion I am making here is that, even if you use the fleet/magazine strategy in your level design files, they could still become cumbersome and unwieldy as they grow. It would be much better if you could view the levels and edit them on-screen and then save changes back to the file. </p>
			<p>You would certainly need new physics engine rules (detecting clicks and drags on objects), a new screen type (that didn't update each frame), and probably new classes for interpreting and building the objects from the text files. The point is, however, that the Entity-Component/screen/UI panel/input handling systems could remain unchanged.</p>
			<p>There isn't even anything stopping you from devising some completely new component types, for example, a scrolling background object that detects which direction the player is moving and moves accordingly, or perhaps an interactive lift object that detects when the player is standing on it and then accepts input to move up and down. We could even have a door that opens and closes, or a teleport object that detects input when the player is touching it and loads a new level from another text file. The point here is that these are all game mechanics that can be easily integrated into the same system.</p>
			<p>I could go on about these possibilities for much longer, but you would probably rather make your own game.</p>
			<h1 id="_idParaDest-441"><a id="_idTextAnchor456"/>Summary</h1>
			<p>In this chapter, we finally completed the Space Invaders ++ game. We coded a way for game objects to request bullets to be spawned, learned how to receive input from a gamepad, and we put in the final logic of the game to bring it to life. </p>
			<p>Perhaps the most important thing to take from this chapter, however, is how the toil of the last four chapters will help you get started on your next project.</p>
			<p>There is one final chapter in this slightly chunky book, and it is a short and simple one, I promise.</p>
		</div>
	</body></html>